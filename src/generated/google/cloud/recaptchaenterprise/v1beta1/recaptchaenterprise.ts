// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/recaptchaenterprise/v1beta1/recaptchaenterprise.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.recaptchaenterprise.v1beta1";

/** The create assessment request message. */
export interface CreateAssessmentRequest {
  /**
   * Required. The name of the project in which the assessment will be created,
   * in the format `projects/{project_number}`.
   */
  parent: string;
  /** Required. The assessment details. */
  assessment: Assessment | undefined;
}

/** Describes an event in the lifecycle of a payment transaction. */
export interface TransactionEvent {
  /** Optional. The type of this transaction event. */
  eventType: TransactionEvent_TransactionEventType;
  /**
   * Optional. The reason or standardized code that corresponds with this
   * transaction event, if one exists. For example, a CHARGEBACK event with code
   * 6005.
   */
  reason: string;
  /**
   * Optional. The value that corresponds with this transaction event, if one
   * exists. For example, a refund event where $5.00 was refunded. Currency is
   * obtained from the original transaction data.
   */
  value: number;
  /**
   * Optional. Timestamp when this transaction event occurred; otherwise assumed
   * to be the time of the API call.
   */
  eventTime: Date | undefined;
}

/** Enum that represents an event in the payment transaction lifecycle. */
export enum TransactionEvent_TransactionEventType {
  /** TRANSACTION_EVENT_TYPE_UNSPECIFIED - Default, unspecified event type. */
  TRANSACTION_EVENT_TYPE_UNSPECIFIED = 0,
  /**
   * MERCHANT_APPROVE - Indicates that the transaction is approved by the merchant. The
   * accompanying reasons can include terms such as 'INHOUSE', 'ACCERTIFY',
   * 'CYBERSOURCE', or 'MANUAL_REVIEW'.
   */
  MERCHANT_APPROVE = 1,
  /**
   * MERCHANT_DENY - Indicates that the transaction is denied and concluded due to risks
   * detected by the merchant. The accompanying reasons can include terms such
   * as 'INHOUSE',  'ACCERTIFY',  'CYBERSOURCE', or 'MANUAL_REVIEW'.
   */
  MERCHANT_DENY = 2,
  /**
   * MANUAL_REVIEW - Indicates that the transaction is being evaluated by a human, due to
   * suspicion or risk.
   */
  MANUAL_REVIEW = 3,
  /** AUTHORIZATION - Indicates that the authorization attempt with the card issuer succeeded. */
  AUTHORIZATION = 4,
  /**
   * AUTHORIZATION_DECLINE - Indicates that the authorization attempt with the card issuer failed.
   * The accompanying reasons can include Visa's '54' indicating that the card
   * is expired, or '82' indicating that the CVV is incorrect.
   */
  AUTHORIZATION_DECLINE = 5,
  /**
   * PAYMENT_CAPTURE - Indicates that the transaction is completed because the funds were
   * settled.
   */
  PAYMENT_CAPTURE = 6,
  /**
   * PAYMENT_CAPTURE_DECLINE - Indicates that the transaction could not be completed because the funds
   * were not settled.
   */
  PAYMENT_CAPTURE_DECLINE = 7,
  /**
   * CANCEL - Indicates that the transaction has been canceled. Specify the reason
   * for the cancellation. For example, 'INSUFFICIENT_INVENTORY'.
   */
  CANCEL = 8,
  /**
   * CHARGEBACK_INQUIRY - Indicates that the merchant has received a chargeback inquiry due to
   * fraud for the transaction, requesting additional information before a
   * fraud chargeback is officially issued and a formal chargeback
   * notification is sent.
   */
  CHARGEBACK_INQUIRY = 9,
  /**
   * CHARGEBACK_ALERT - Indicates that the merchant has received a chargeback alert due to fraud
   * for the transaction. The process of resolving the dispute without
   * involving the payment network is started.
   */
  CHARGEBACK_ALERT = 10,
  /**
   * FRAUD_NOTIFICATION - Indicates that a fraud notification is issued for the transaction, sent
   * by the payment instrument's issuing bank because the transaction appears
   * to be fraudulent. We recommend including TC40 or SAFE data in the
   * `reason` field for this event type. For partial chargebacks, we recommend
   * that you include an amount in the `value` field.
   */
  FRAUD_NOTIFICATION = 11,
  /**
   * CHARGEBACK - Indicates that the merchant is informed by the payment network that the
   * transaction has entered the chargeback process due to fraud. Reason code
   * examples include Discover's '6005' and '6041'. For partial chargebacks,
   * we recommend that you include an amount in the `value` field.
   */
  CHARGEBACK = 12,
  /**
   * CHARGEBACK_REPRESENTMENT - Indicates that the transaction has entered the chargeback process due to
   * fraud, and that the merchant has chosen to enter representment. Reason
   * examples include Discover's '6005' and '6041'. For partial chargebacks,
   * we recommend that you include an amount in the `value` field.
   */
  CHARGEBACK_REPRESENTMENT = 13,
  /**
   * CHARGEBACK_REVERSE - Indicates that the transaction has had a fraud chargeback which was
   * illegitimate and was reversed as a result. For partial chargebacks, we
   * recommend that you include an amount in the `value` field.
   */
  CHARGEBACK_REVERSE = 14,
  /**
   * REFUND_REQUEST - Indicates that the merchant has received a refund for a completed
   * transaction. For partial refunds, we recommend that you include an amount
   * in the `value` field. Reason example: 'TAX_EXEMPT' (partial refund of
   * exempt tax)
   */
  REFUND_REQUEST = 15,
  /**
   * REFUND_DECLINE - Indicates that the merchant has received a refund request for this
   * transaction, but that they have declined it. For partial refunds, we
   * recommend that you include an amount in the `value` field. Reason
   * example: 'TAX_EXEMPT' (partial refund of exempt tax)
   */
  REFUND_DECLINE = 16,
  /**
   * REFUND - Indicates that the completed transaction was refunded by the merchant.
   * For partial refunds, we recommend that you include an amount in the
   * `value` field. Reason example: 'TAX_EXEMPT' (partial refund of exempt
   * tax)
   */
  REFUND = 17,
  /**
   * REFUND_REVERSE - Indicates that the completed transaction was refunded by the merchant,
   * and that this refund was reversed. For partial refunds, we recommend that
   * you include an amount in the `value` field.
   */
  REFUND_REVERSE = 18,
  UNRECOGNIZED = -1,
}

export function transactionEvent_TransactionEventTypeFromJSON(object: any): TransactionEvent_TransactionEventType {
  switch (object) {
    case 0:
    case "TRANSACTION_EVENT_TYPE_UNSPECIFIED":
      return TransactionEvent_TransactionEventType.TRANSACTION_EVENT_TYPE_UNSPECIFIED;
    case 1:
    case "MERCHANT_APPROVE":
      return TransactionEvent_TransactionEventType.MERCHANT_APPROVE;
    case 2:
    case "MERCHANT_DENY":
      return TransactionEvent_TransactionEventType.MERCHANT_DENY;
    case 3:
    case "MANUAL_REVIEW":
      return TransactionEvent_TransactionEventType.MANUAL_REVIEW;
    case 4:
    case "AUTHORIZATION":
      return TransactionEvent_TransactionEventType.AUTHORIZATION;
    case 5:
    case "AUTHORIZATION_DECLINE":
      return TransactionEvent_TransactionEventType.AUTHORIZATION_DECLINE;
    case 6:
    case "PAYMENT_CAPTURE":
      return TransactionEvent_TransactionEventType.PAYMENT_CAPTURE;
    case 7:
    case "PAYMENT_CAPTURE_DECLINE":
      return TransactionEvent_TransactionEventType.PAYMENT_CAPTURE_DECLINE;
    case 8:
    case "CANCEL":
      return TransactionEvent_TransactionEventType.CANCEL;
    case 9:
    case "CHARGEBACK_INQUIRY":
      return TransactionEvent_TransactionEventType.CHARGEBACK_INQUIRY;
    case 10:
    case "CHARGEBACK_ALERT":
      return TransactionEvent_TransactionEventType.CHARGEBACK_ALERT;
    case 11:
    case "FRAUD_NOTIFICATION":
      return TransactionEvent_TransactionEventType.FRAUD_NOTIFICATION;
    case 12:
    case "CHARGEBACK":
      return TransactionEvent_TransactionEventType.CHARGEBACK;
    case 13:
    case "CHARGEBACK_REPRESENTMENT":
      return TransactionEvent_TransactionEventType.CHARGEBACK_REPRESENTMENT;
    case 14:
    case "CHARGEBACK_REVERSE":
      return TransactionEvent_TransactionEventType.CHARGEBACK_REVERSE;
    case 15:
    case "REFUND_REQUEST":
      return TransactionEvent_TransactionEventType.REFUND_REQUEST;
    case 16:
    case "REFUND_DECLINE":
      return TransactionEvent_TransactionEventType.REFUND_DECLINE;
    case 17:
    case "REFUND":
      return TransactionEvent_TransactionEventType.REFUND;
    case 18:
    case "REFUND_REVERSE":
      return TransactionEvent_TransactionEventType.REFUND_REVERSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionEvent_TransactionEventType.UNRECOGNIZED;
  }
}

export function transactionEvent_TransactionEventTypeToJSON(object: TransactionEvent_TransactionEventType): string {
  switch (object) {
    case TransactionEvent_TransactionEventType.TRANSACTION_EVENT_TYPE_UNSPECIFIED:
      return "TRANSACTION_EVENT_TYPE_UNSPECIFIED";
    case TransactionEvent_TransactionEventType.MERCHANT_APPROVE:
      return "MERCHANT_APPROVE";
    case TransactionEvent_TransactionEventType.MERCHANT_DENY:
      return "MERCHANT_DENY";
    case TransactionEvent_TransactionEventType.MANUAL_REVIEW:
      return "MANUAL_REVIEW";
    case TransactionEvent_TransactionEventType.AUTHORIZATION:
      return "AUTHORIZATION";
    case TransactionEvent_TransactionEventType.AUTHORIZATION_DECLINE:
      return "AUTHORIZATION_DECLINE";
    case TransactionEvent_TransactionEventType.PAYMENT_CAPTURE:
      return "PAYMENT_CAPTURE";
    case TransactionEvent_TransactionEventType.PAYMENT_CAPTURE_DECLINE:
      return "PAYMENT_CAPTURE_DECLINE";
    case TransactionEvent_TransactionEventType.CANCEL:
      return "CANCEL";
    case TransactionEvent_TransactionEventType.CHARGEBACK_INQUIRY:
      return "CHARGEBACK_INQUIRY";
    case TransactionEvent_TransactionEventType.CHARGEBACK_ALERT:
      return "CHARGEBACK_ALERT";
    case TransactionEvent_TransactionEventType.FRAUD_NOTIFICATION:
      return "FRAUD_NOTIFICATION";
    case TransactionEvent_TransactionEventType.CHARGEBACK:
      return "CHARGEBACK";
    case TransactionEvent_TransactionEventType.CHARGEBACK_REPRESENTMENT:
      return "CHARGEBACK_REPRESENTMENT";
    case TransactionEvent_TransactionEventType.CHARGEBACK_REVERSE:
      return "CHARGEBACK_REVERSE";
    case TransactionEvent_TransactionEventType.REFUND_REQUEST:
      return "REFUND_REQUEST";
    case TransactionEvent_TransactionEventType.REFUND_DECLINE:
      return "REFUND_DECLINE";
    case TransactionEvent_TransactionEventType.REFUND:
      return "REFUND";
    case TransactionEvent_TransactionEventType.REFUND_REVERSE:
      return "REFUND_REVERSE";
    case TransactionEvent_TransactionEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The request message to annotate an Assessment. */
export interface AnnotateAssessmentRequest {
  /**
   * Required. The resource name of the Assessment, in the format
   * `projects/{project_number}/assessments/{assessment_id}`.
   */
  name: string;
  /**
   * Optional. The annotation that will be assigned to the Event. This field can
   * be left empty to provide reasons that apply to an event without concluding
   * whether the event is legitimate or fraudulent.
   */
  annotation: AnnotateAssessmentRequest_Annotation;
  /** Optional. Reasons for the annotation that are assigned to the event. */
  reasons: AnnotateAssessmentRequest_Reason[];
  /**
   * Optional. Unique stable hashed user identifier to apply to the assessment.
   * This is an alternative to setting the `hashed_account_id` in
   * `CreateAssessment`, for example, when the account identifier is not yet
   * known in the initial request. It is recommended that the identifier is
   * hashed using hmac-sha256 with stable secret.
   */
  hashedAccountId: Buffer;
  /**
   * Optional. If the assessment is part of a payment transaction, provide
   * details on payment lifecycle events that occur in the transaction.
   */
  transactionEvent: TransactionEvent | undefined;
}

/** Enum that represents the types of annotations. */
export enum AnnotateAssessmentRequest_Annotation {
  /** ANNOTATION_UNSPECIFIED - Default unspecified type. */
  ANNOTATION_UNSPECIFIED = 0,
  /** LEGITIMATE - Provides information that the event turned out to be legitimate. */
  LEGITIMATE = 1,
  /** FRAUDULENT - Provides information that the event turned out to be fraudulent. */
  FRAUDULENT = 2,
  /**
   * PASSWORD_CORRECT - Provides information that the event was related to a login event in which
   * the user typed the correct password. Deprecated, prefer indicating
   * CORRECT_PASSWORD through the reasons field instead.
   *
   * @deprecated
   */
  PASSWORD_CORRECT = 3,
  /**
   * PASSWORD_INCORRECT - Provides information that the event was related to a login event in which
   * the user typed the incorrect password. Deprecated, prefer indicating
   * INCORRECT_PASSWORD through the reasons field instead.
   *
   * @deprecated
   */
  PASSWORD_INCORRECT = 4,
  UNRECOGNIZED = -1,
}

export function annotateAssessmentRequest_AnnotationFromJSON(object: any): AnnotateAssessmentRequest_Annotation {
  switch (object) {
    case 0:
    case "ANNOTATION_UNSPECIFIED":
      return AnnotateAssessmentRequest_Annotation.ANNOTATION_UNSPECIFIED;
    case 1:
    case "LEGITIMATE":
      return AnnotateAssessmentRequest_Annotation.LEGITIMATE;
    case 2:
    case "FRAUDULENT":
      return AnnotateAssessmentRequest_Annotation.FRAUDULENT;
    case 3:
    case "PASSWORD_CORRECT":
      return AnnotateAssessmentRequest_Annotation.PASSWORD_CORRECT;
    case 4:
    case "PASSWORD_INCORRECT":
      return AnnotateAssessmentRequest_Annotation.PASSWORD_INCORRECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnnotateAssessmentRequest_Annotation.UNRECOGNIZED;
  }
}

export function annotateAssessmentRequest_AnnotationToJSON(object: AnnotateAssessmentRequest_Annotation): string {
  switch (object) {
    case AnnotateAssessmentRequest_Annotation.ANNOTATION_UNSPECIFIED:
      return "ANNOTATION_UNSPECIFIED";
    case AnnotateAssessmentRequest_Annotation.LEGITIMATE:
      return "LEGITIMATE";
    case AnnotateAssessmentRequest_Annotation.FRAUDULENT:
      return "FRAUDULENT";
    case AnnotateAssessmentRequest_Annotation.PASSWORD_CORRECT:
      return "PASSWORD_CORRECT";
    case AnnotateAssessmentRequest_Annotation.PASSWORD_INCORRECT:
      return "PASSWORD_INCORRECT";
    case AnnotateAssessmentRequest_Annotation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enum that represents potential reasons for annotating an assessment. */
export enum AnnotateAssessmentRequest_Reason {
  /** REASON_UNSPECIFIED - Default unspecified reason. */
  REASON_UNSPECIFIED = 0,
  /**
   * CHARGEBACK - Indicates that the transaction had a chargeback issued with no other
   * details. When possible, specify the type by using CHARGEBACK_FRAUD or
   * CHARGEBACK_DISPUTE instead.
   */
  CHARGEBACK = 1,
  /**
   * CHARGEBACK_FRAUD - Indicates that the transaction had a chargeback issued related to an
   * alleged unauthorized transaction from the cardholder's perspective (for
   * example, the card number was stolen).
   */
  CHARGEBACK_FRAUD = 8,
  /**
   * CHARGEBACK_DISPUTE - Indicates that the transaction had a chargeback issued related to the
   * cardholder having provided their card details but allegedly not being
   * satisfied with the purchase (for example, misrepresentation, attempted
   * cancellation).
   */
  CHARGEBACK_DISPUTE = 9,
  /**
   * REFUND - Indicates that the completed payment transaction was refunded by the
   * seller.
   */
  REFUND = 10,
  /**
   * REFUND_FRAUD - Indicates that the completed payment transaction was determined to be
   * fraudulent by the seller, and was cancelled and refunded as a result.
   */
  REFUND_FRAUD = 11,
  /**
   * TRANSACTION_ACCEPTED - Indicates that the payment transaction was accepted, and the user was
   * charged.
   */
  TRANSACTION_ACCEPTED = 12,
  /**
   * TRANSACTION_DECLINED - Indicates that the payment transaction was declined, for example due to
   * invalid card details.
   */
  TRANSACTION_DECLINED = 13,
  /**
   * PAYMENT_HEURISTICS - Indicates the transaction associated with the assessment is suspected of
   * being fraudulent based on the payment method, billing details, shipping
   * address or other transaction information.
   */
  PAYMENT_HEURISTICS = 2,
  /**
   * INITIATED_TWO_FACTOR - Indicates that the user was served a 2FA challenge. An old assessment
   * with `ENUM_VALUES.INITIATED_TWO_FACTOR` reason that has not been
   * overwritten with `PASSED_TWO_FACTOR` is treated as an abandoned 2FA flow.
   * This is equivalent to `FAILED_TWO_FACTOR`.
   */
  INITIATED_TWO_FACTOR = 7,
  /** PASSED_TWO_FACTOR - Indicates that the user passed a 2FA challenge. */
  PASSED_TWO_FACTOR = 3,
  /** FAILED_TWO_FACTOR - Indicates that the user failed a 2FA challenge. */
  FAILED_TWO_FACTOR = 4,
  /** CORRECT_PASSWORD - Indicates the user provided the correct password. */
  CORRECT_PASSWORD = 5,
  /** INCORRECT_PASSWORD - Indicates the user provided an incorrect password. */
  INCORRECT_PASSWORD = 6,
  /**
   * SOCIAL_SPAM - Indicates that the user sent unwanted and abusive messages to other users
   * of the platform, such as spam, scams, phishing, or social engineering.
   */
  SOCIAL_SPAM = 14,
  UNRECOGNIZED = -1,
}

export function annotateAssessmentRequest_ReasonFromJSON(object: any): AnnotateAssessmentRequest_Reason {
  switch (object) {
    case 0:
    case "REASON_UNSPECIFIED":
      return AnnotateAssessmentRequest_Reason.REASON_UNSPECIFIED;
    case 1:
    case "CHARGEBACK":
      return AnnotateAssessmentRequest_Reason.CHARGEBACK;
    case 8:
    case "CHARGEBACK_FRAUD":
      return AnnotateAssessmentRequest_Reason.CHARGEBACK_FRAUD;
    case 9:
    case "CHARGEBACK_DISPUTE":
      return AnnotateAssessmentRequest_Reason.CHARGEBACK_DISPUTE;
    case 10:
    case "REFUND":
      return AnnotateAssessmentRequest_Reason.REFUND;
    case 11:
    case "REFUND_FRAUD":
      return AnnotateAssessmentRequest_Reason.REFUND_FRAUD;
    case 12:
    case "TRANSACTION_ACCEPTED":
      return AnnotateAssessmentRequest_Reason.TRANSACTION_ACCEPTED;
    case 13:
    case "TRANSACTION_DECLINED":
      return AnnotateAssessmentRequest_Reason.TRANSACTION_DECLINED;
    case 2:
    case "PAYMENT_HEURISTICS":
      return AnnotateAssessmentRequest_Reason.PAYMENT_HEURISTICS;
    case 7:
    case "INITIATED_TWO_FACTOR":
      return AnnotateAssessmentRequest_Reason.INITIATED_TWO_FACTOR;
    case 3:
    case "PASSED_TWO_FACTOR":
      return AnnotateAssessmentRequest_Reason.PASSED_TWO_FACTOR;
    case 4:
    case "FAILED_TWO_FACTOR":
      return AnnotateAssessmentRequest_Reason.FAILED_TWO_FACTOR;
    case 5:
    case "CORRECT_PASSWORD":
      return AnnotateAssessmentRequest_Reason.CORRECT_PASSWORD;
    case 6:
    case "INCORRECT_PASSWORD":
      return AnnotateAssessmentRequest_Reason.INCORRECT_PASSWORD;
    case 14:
    case "SOCIAL_SPAM":
      return AnnotateAssessmentRequest_Reason.SOCIAL_SPAM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnnotateAssessmentRequest_Reason.UNRECOGNIZED;
  }
}

export function annotateAssessmentRequest_ReasonToJSON(object: AnnotateAssessmentRequest_Reason): string {
  switch (object) {
    case AnnotateAssessmentRequest_Reason.REASON_UNSPECIFIED:
      return "REASON_UNSPECIFIED";
    case AnnotateAssessmentRequest_Reason.CHARGEBACK:
      return "CHARGEBACK";
    case AnnotateAssessmentRequest_Reason.CHARGEBACK_FRAUD:
      return "CHARGEBACK_FRAUD";
    case AnnotateAssessmentRequest_Reason.CHARGEBACK_DISPUTE:
      return "CHARGEBACK_DISPUTE";
    case AnnotateAssessmentRequest_Reason.REFUND:
      return "REFUND";
    case AnnotateAssessmentRequest_Reason.REFUND_FRAUD:
      return "REFUND_FRAUD";
    case AnnotateAssessmentRequest_Reason.TRANSACTION_ACCEPTED:
      return "TRANSACTION_ACCEPTED";
    case AnnotateAssessmentRequest_Reason.TRANSACTION_DECLINED:
      return "TRANSACTION_DECLINED";
    case AnnotateAssessmentRequest_Reason.PAYMENT_HEURISTICS:
      return "PAYMENT_HEURISTICS";
    case AnnotateAssessmentRequest_Reason.INITIATED_TWO_FACTOR:
      return "INITIATED_TWO_FACTOR";
    case AnnotateAssessmentRequest_Reason.PASSED_TWO_FACTOR:
      return "PASSED_TWO_FACTOR";
    case AnnotateAssessmentRequest_Reason.FAILED_TWO_FACTOR:
      return "FAILED_TWO_FACTOR";
    case AnnotateAssessmentRequest_Reason.CORRECT_PASSWORD:
      return "CORRECT_PASSWORD";
    case AnnotateAssessmentRequest_Reason.INCORRECT_PASSWORD:
      return "INCORRECT_PASSWORD";
    case AnnotateAssessmentRequest_Reason.SOCIAL_SPAM:
      return "SOCIAL_SPAM";
    case AnnotateAssessmentRequest_Reason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Empty response for AnnotateAssessment. */
export interface AnnotateAssessmentResponse {
}

/** Password leak verification info. */
export interface PasswordLeakVerification {
  /**
   * Optional. Scrypt hash of the username+password that the customer wants to
   * verify against a known password leak.
   */
  hashedUserCredentials: Buffer;
  /**
   * Output only. Whether or not the user's credentials are present in a known
   * leak.
   */
  credentialsLeaked: boolean;
  /**
   * Optional. The username part of the user credentials for which we want to
   * trigger a leak check in canonicalized form. This is the same data used to
   * create the hashed_user_credentials on the customer side.
   */
  canonicalizedUsername: string;
}

/** A reCAPTCHA Enterprise assessment resource. */
export interface Assessment {
  /**
   * Output only. The resource name for the Assessment in the format
   * `projects/{project_number}/assessments/{assessment_id}`.
   */
  name: string;
  /** The event being assessed. */
  event:
    | Event
    | undefined;
  /**
   * Output only. Legitimate event score from 0.0 to 1.0.
   * (1.0 means very likely legitimate traffic while 0.0 means very likely
   * non-legitimate traffic).
   */
  score: number;
  /** Output only. Properties of the provided event token. */
  tokenProperties:
    | TokenProperties
    | undefined;
  /** Output only. Reasons contributing to the risk analysis verdict. */
  reasons: Assessment_ClassificationReason[];
  /**
   * Information about the user's credentials used to check for leaks.
   * This feature is part of the Early Access Program (EAP). Exercise caution,
   * and do not deploy integrations based on this feature in a production
   * environment.
   */
  passwordLeakVerification:
    | PasswordLeakVerification
    | undefined;
  /**
   * Assessment returned by account defender when a hashed_account_id is
   * provided.
   */
  accountDefenderAssessment:
    | AccountDefenderAssessment
    | undefined;
  /** Assessment returned by Fraud Prevention when TransactionData is provided. */
  fraudPreventionAssessment: FraudPreventionAssessment | undefined;
}

/** Reasons contributing to the risk analysis verdict. */
export enum Assessment_ClassificationReason {
  /** CLASSIFICATION_REASON_UNSPECIFIED - Default unspecified type. */
  CLASSIFICATION_REASON_UNSPECIFIED = 0,
  /** AUTOMATION - Interactions matched the behavior of an automated agent. */
  AUTOMATION = 1,
  /** UNEXPECTED_ENVIRONMENT - The event originated from an illegitimate environment. */
  UNEXPECTED_ENVIRONMENT = 2,
  /** TOO_MUCH_TRAFFIC - Traffic volume from the event source is higher than normal. */
  TOO_MUCH_TRAFFIC = 3,
  /**
   * UNEXPECTED_USAGE_PATTERNS - Interactions with the site were significantly different than expected
   * patterns.
   */
  UNEXPECTED_USAGE_PATTERNS = 4,
  /**
   * LOW_CONFIDENCE_SCORE - Too little traffic has been received from this site thus far to generate
   * quality risk analysis.
   */
  LOW_CONFIDENCE_SCORE = 5,
  /** SUSPECTED_CARDING - The request matches behavioral characteristics of a carding attack. */
  SUSPECTED_CARDING = 6,
  /** SUSPECTED_CHARGEBACK - The request matches behavioral characteristics of chargebacks for fraud. */
  SUSPECTED_CHARGEBACK = 7,
  UNRECOGNIZED = -1,
}

export function assessment_ClassificationReasonFromJSON(object: any): Assessment_ClassificationReason {
  switch (object) {
    case 0:
    case "CLASSIFICATION_REASON_UNSPECIFIED":
      return Assessment_ClassificationReason.CLASSIFICATION_REASON_UNSPECIFIED;
    case 1:
    case "AUTOMATION":
      return Assessment_ClassificationReason.AUTOMATION;
    case 2:
    case "UNEXPECTED_ENVIRONMENT":
      return Assessment_ClassificationReason.UNEXPECTED_ENVIRONMENT;
    case 3:
    case "TOO_MUCH_TRAFFIC":
      return Assessment_ClassificationReason.TOO_MUCH_TRAFFIC;
    case 4:
    case "UNEXPECTED_USAGE_PATTERNS":
      return Assessment_ClassificationReason.UNEXPECTED_USAGE_PATTERNS;
    case 5:
    case "LOW_CONFIDENCE_SCORE":
      return Assessment_ClassificationReason.LOW_CONFIDENCE_SCORE;
    case 6:
    case "SUSPECTED_CARDING":
      return Assessment_ClassificationReason.SUSPECTED_CARDING;
    case 7:
    case "SUSPECTED_CHARGEBACK":
      return Assessment_ClassificationReason.SUSPECTED_CHARGEBACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Assessment_ClassificationReason.UNRECOGNIZED;
  }
}

export function assessment_ClassificationReasonToJSON(object: Assessment_ClassificationReason): string {
  switch (object) {
    case Assessment_ClassificationReason.CLASSIFICATION_REASON_UNSPECIFIED:
      return "CLASSIFICATION_REASON_UNSPECIFIED";
    case Assessment_ClassificationReason.AUTOMATION:
      return "AUTOMATION";
    case Assessment_ClassificationReason.UNEXPECTED_ENVIRONMENT:
      return "UNEXPECTED_ENVIRONMENT";
    case Assessment_ClassificationReason.TOO_MUCH_TRAFFIC:
      return "TOO_MUCH_TRAFFIC";
    case Assessment_ClassificationReason.UNEXPECTED_USAGE_PATTERNS:
      return "UNEXPECTED_USAGE_PATTERNS";
    case Assessment_ClassificationReason.LOW_CONFIDENCE_SCORE:
      return "LOW_CONFIDENCE_SCORE";
    case Assessment_ClassificationReason.SUSPECTED_CARDING:
      return "SUSPECTED_CARDING";
    case Assessment_ClassificationReason.SUSPECTED_CHARGEBACK:
      return "SUSPECTED_CHARGEBACK";
    case Assessment_ClassificationReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Event {
  /**
   * Optional. The user response token provided by the reCAPTCHA Enterprise
   * client-side integration on your site.
   */
  token: string;
  /**
   * Optional. The site key that was used to invoke reCAPTCHA Enterprise on your
   * site and generate the token.
   */
  siteKey: string;
  /**
   * Optional. The user agent present in the request from the user's device
   * related to this event.
   */
  userAgent: string;
  /**
   * Optional. The IP address in the request from the user's device related to
   * this event.
   */
  userIpAddress: string;
  /**
   * Optional. The expected action for this type of event. This should be the
   * same action provided at token generation time on client-side platforms
   * already integrated with recaptcha enterprise.
   */
  expectedAction: string;
  /**
   * Optional. Unique stable hashed user identifier for the request. The
   * identifier must be hashed using hmac-sha256 with stable secret.
   */
  hashedAccountId: Buffer;
  /**
   * Optional. Data describing a payment transaction to be assessed. Sending
   * this data enables reCAPTCHA Enterprise Fraud Prevention and the
   * FraudPreventionAssessment component in the response.
   */
  transactionData:
    | TransactionData
    | undefined;
  /** Optional. The Fraud Prevention setting for this Assessment. */
  fraudPrevention: Event_FraudPrevention;
}

/** Setting that controls Fraud Prevention assessments. */
export enum Event_FraudPrevention {
  /**
   * FRAUD_PREVENTION_UNSPECIFIED - Default, unspecified setting. If opted in for automatic detection,
   * `fraud_prevention_assessment` is returned based on the request.
   * Otherwise, `fraud_prevention_assessment` is returned if
   * `transaction_data` is present in the `Event` and Fraud Prevention is
   * enabled in the Google Cloud console.
   */
  FRAUD_PREVENTION_UNSPECIFIED = 0,
  /**
   * ENABLED - Enable Fraud Prevention for this assessment, if Fraud Prevention is
   * enabled in the Google Cloud console.
   */
  ENABLED = 1,
  /**
   * DISABLED - Disable Fraud Prevention for this assessment, regardless of opt-in
   * status or the Google Cloud console settings.
   */
  DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function event_FraudPreventionFromJSON(object: any): Event_FraudPrevention {
  switch (object) {
    case 0:
    case "FRAUD_PREVENTION_UNSPECIFIED":
      return Event_FraudPrevention.FRAUD_PREVENTION_UNSPECIFIED;
    case 1:
    case "ENABLED":
      return Event_FraudPrevention.ENABLED;
    case 2:
    case "DISABLED":
      return Event_FraudPrevention.DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Event_FraudPrevention.UNRECOGNIZED;
  }
}

export function event_FraudPreventionToJSON(object: Event_FraudPrevention): string {
  switch (object) {
    case Event_FraudPrevention.FRAUD_PREVENTION_UNSPECIFIED:
      return "FRAUD_PREVENTION_UNSPECIFIED";
    case Event_FraudPrevention.ENABLED:
      return "ENABLED";
    case Event_FraudPrevention.DISABLED:
      return "DISABLED";
    case Event_FraudPrevention.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Transaction data associated with a payment protected by reCAPTCHA Enterprise. */
export interface TransactionData {
  /**
   * Unique identifier for the transaction. This custom identifier can be used
   * to reference this transaction in the future, for example, labeling a refund
   * or chargeback event. Two attempts at the same transaction should use the
   * same transaction id.
   */
  transactionId?:
    | string
    | undefined;
  /**
   * The payment method for the transaction. The allowed values are:
   *
   * * credit-card
   * * debit-card
   * * gift-card
   * * processor-{name} (If a third-party is used, for example,
   * processor-paypal)
   * * custom-{name} (If an alternative method is used, for example,
   * custom-crypto)
   */
  paymentMethod: string;
  /**
   * The Bank Identification Number - generally the first 6 or 8 digits of the
   * card.
   */
  cardBin: string;
  /** The last four digits of the card. */
  cardLastFour: string;
  /** The currency code in ISO-4217 format. */
  currencyCode: string;
  /** The decimal value of the transaction in the specified currency. */
  value: number;
  /** The value of shipping in the specified currency. 0 for free or no shipping. */
  shippingValue: number;
  /** Destination address if this transaction involves shipping a physical item. */
  shippingAddress:
    | TransactionData_Address
    | undefined;
  /** Address associated with the payment method when applicable. */
  billingAddress:
    | TransactionData_Address
    | undefined;
  /** Information about the user paying/initiating the transaction. */
  user:
    | TransactionData_User
    | undefined;
  /** Information about the user or users fulfilling the transaction. */
  merchants: TransactionData_User[];
  /** Items purchased in this transaction. */
  items: TransactionData_Item[];
  /** Information about the payment gateway's response to the transaction. */
  gatewayInfo: TransactionData_GatewayInfo | undefined;
}

/** Structured address format for billing and shipping addresses. */
export interface TransactionData_Address {
  /** The recipient name, potentially including information such as "care of". */
  recipient: string;
  /**
   * The first lines of the address. The first line generally contains the
   * street name and number, and further lines may include information such as
   * an apartment number.
   */
  address: string[];
  /** The town/city of the address. */
  locality: string;
  /** The state, province, or otherwise administrative area of the address. */
  administrativeArea: string;
  /** The CLDR country/region of the address. */
  regionCode: string;
  /** The postal or ZIP code of the address. */
  postalCode: string;
}

/** Details about a user's account involved in the transaction. */
export interface TransactionData_User {
  /**
   * Unique account identifier for this user. If using account defender,
   * this should match the hashed_account_id field. Otherwise, a unique and
   * persistent identifier for this account.
   */
  accountId: string;
  /** The epoch milliseconds of the user's account creation. */
  creationMs: Long;
  /** The email address of the user. */
  email: string;
  /**
   * Whether the email has been verified to be accessible by the user (OTP or
   * similar).
   */
  emailVerified: boolean;
  /** The phone number of the user, with country code. */
  phoneNumber: string;
  /**
   * Whether the phone number has been verified to be accessible by the user
   * (OTP or similar).
   */
  phoneVerified: boolean;
}

/** Line items being purchased in this transaction. */
export interface TransactionData_Item {
  /** The full name of the item. */
  name: string;
  /**
   * The value per item that the user is paying, in the transaction currency,
   * after discounts.
   */
  value: number;
  /** The quantity of this item that is being purchased. */
  quantity: Long;
  /**
   * When a merchant is specified, its corresponding account_id. Necessary to
   * populate marketplace-style transactions.
   */
  merchantAccountId: string;
}

/** Details about the transaction from the gateway. */
export interface TransactionData_GatewayInfo {
  /** Name of the gateway service (for example, stripe, square, paypal). */
  name: string;
  /** Gateway response code describing the state of the transaction. */
  gatewayResponseCode: string;
  /**
   * AVS response code from the gateway
   * (available only when reCAPTCHA Enterprise is called after authorization).
   */
  avsResponseCode: string;
  /**
   * CVV response code from the gateway
   * (available only when reCAPTCHA Enterprise is called after authorization).
   */
  cvvResponseCode: string;
}

export interface TokenProperties {
  /**
   * Whether the provided user response token is valid. When valid = false, the
   * reason could be specified in invalid_reason or it could also be due to
   * a user failing to solve a challenge or a sitekey mismatch (i.e the sitekey
   * used to generate the token was different than the one specified in the
   * assessment).
   */
  valid: boolean;
  /** Reason associated with the response when valid = false. */
  invalidReason: TokenProperties_InvalidReason;
  /** The timestamp corresponding to the generation of the token. */
  createTime:
    | Date
    | undefined;
  /** The hostname of the page on which the token was generated. */
  hostname: string;
  /** Action name provided at token generation. */
  action: string;
}

/** Enum that represents the types of invalid token reasons. */
export enum TokenProperties_InvalidReason {
  /** INVALID_REASON_UNSPECIFIED - Default unspecified type. */
  INVALID_REASON_UNSPECIFIED = 0,
  /** UNKNOWN_INVALID_REASON - If the failure reason was not accounted for. */
  UNKNOWN_INVALID_REASON = 1,
  /** MALFORMED - The provided user verification token was malformed. */
  MALFORMED = 2,
  /** EXPIRED - The user verification token had expired. */
  EXPIRED = 3,
  /** DUPE - The user verification had already been seen. */
  DUPE = 4,
  /**
   * SITE_MISMATCH - The user verification token did not match the provided site key.
   * This may be a configuration error (for example, development keys used in
   * production) or end users trying to use verification tokens from other
   * sites.
   *
   * @deprecated
   */
  SITE_MISMATCH = 5,
  /** MISSING - The user verification token was not present.  It is a required input. */
  MISSING = 6,
  /**
   * BROWSER_ERROR - A retriable error (such as network failure) occurred on the browser.
   * Could easily be simulated by an attacker.
   */
  BROWSER_ERROR = 7,
  UNRECOGNIZED = -1,
}

export function tokenProperties_InvalidReasonFromJSON(object: any): TokenProperties_InvalidReason {
  switch (object) {
    case 0:
    case "INVALID_REASON_UNSPECIFIED":
      return TokenProperties_InvalidReason.INVALID_REASON_UNSPECIFIED;
    case 1:
    case "UNKNOWN_INVALID_REASON":
      return TokenProperties_InvalidReason.UNKNOWN_INVALID_REASON;
    case 2:
    case "MALFORMED":
      return TokenProperties_InvalidReason.MALFORMED;
    case 3:
    case "EXPIRED":
      return TokenProperties_InvalidReason.EXPIRED;
    case 4:
    case "DUPE":
      return TokenProperties_InvalidReason.DUPE;
    case 5:
    case "SITE_MISMATCH":
      return TokenProperties_InvalidReason.SITE_MISMATCH;
    case 6:
    case "MISSING":
      return TokenProperties_InvalidReason.MISSING;
    case 7:
    case "BROWSER_ERROR":
      return TokenProperties_InvalidReason.BROWSER_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TokenProperties_InvalidReason.UNRECOGNIZED;
  }
}

export function tokenProperties_InvalidReasonToJSON(object: TokenProperties_InvalidReason): string {
  switch (object) {
    case TokenProperties_InvalidReason.INVALID_REASON_UNSPECIFIED:
      return "INVALID_REASON_UNSPECIFIED";
    case TokenProperties_InvalidReason.UNKNOWN_INVALID_REASON:
      return "UNKNOWN_INVALID_REASON";
    case TokenProperties_InvalidReason.MALFORMED:
      return "MALFORMED";
    case TokenProperties_InvalidReason.EXPIRED:
      return "EXPIRED";
    case TokenProperties_InvalidReason.DUPE:
      return "DUPE";
    case TokenProperties_InvalidReason.SITE_MISMATCH:
      return "SITE_MISMATCH";
    case TokenProperties_InvalidReason.MISSING:
      return "MISSING";
    case TokenProperties_InvalidReason.BROWSER_ERROR:
      return "BROWSER_ERROR";
    case TokenProperties_InvalidReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Assessment for Fraud Prevention. */
export interface FraudPreventionAssessment {
  /**
   * Probability (0-1) of this transaction being fraudulent. Summarizes the
   * combined risk of attack vectors below.
   */
  transactionRisk: number;
  /** Assessment of this transaction for risk of a stolen instrument. */
  stolenInstrumentVerdict:
    | FraudPreventionAssessment_StolenInstrumentVerdict
    | undefined;
  /**
   * Assessment of this transaction for risk of being part of a card testing
   * attack.
   */
  cardTestingVerdict:
    | FraudPreventionAssessment_CardTestingVerdict
    | undefined;
  /** Assessment of this transaction for behavioral trust. */
  behavioralTrustVerdict: FraudPreventionAssessment_BehavioralTrustVerdict | undefined;
}

/**
 * Information about stolen instrument fraud, where the user is not the
 * legitimate owner of the instrument being used for the purchase.
 */
export interface FraudPreventionAssessment_StolenInstrumentVerdict {
  /**
   * Probability (0-1) of this transaction being executed with a stolen
   * instrument.
   */
  risk: number;
}

/**
 * Information about card testing fraud, where an adversary is testing
 * fraudulently obtained cards or brute forcing their details.
 */
export interface FraudPreventionAssessment_CardTestingVerdict {
  /**
   * Probability (0-1) of this transaction attempt being part of a card
   * testing attack.
   */
  risk: number;
}

/** Information about behavioral trust of the transaction. */
export interface FraudPreventionAssessment_BehavioralTrustVerdict {
  /**
   * Probability (0-1) of this transaction attempt being executed in a
   * behaviorally trustworthy way.
   */
  trust: number;
}

/** Account defender risk assessment. */
export interface AccountDefenderAssessment {
  /** Labels for this request. */
  labels: AccountDefenderAssessment_AccountDefenderLabel[];
}

/** Labels returned by account defender for this request. */
export enum AccountDefenderAssessment_AccountDefenderLabel {
  /** ACCOUNT_DEFENDER_LABEL_UNSPECIFIED - Default unspecified type. */
  ACCOUNT_DEFENDER_LABEL_UNSPECIFIED = 0,
  /** PROFILE_MATCH - The request matches a known good profile for the user. */
  PROFILE_MATCH = 1,
  /**
   * SUSPICIOUS_LOGIN_ACTIVITY - The request is potentially a suspicious login event and should be further
   * verified either via multi-factor authentication or another system.
   */
  SUSPICIOUS_LOGIN_ACTIVITY = 2,
  /**
   * SUSPICIOUS_ACCOUNT_CREATION - The request matched a profile that previously had suspicious account
   * creation behavior. This could mean this is a fake account.
   */
  SUSPICIOUS_ACCOUNT_CREATION = 3,
  /**
   * RELATED_ACCOUNTS_NUMBER_HIGH - The account in the request has a high number of related accounts. It does
   * not necessarily imply that the account is bad but could require
   * investigating.
   */
  RELATED_ACCOUNTS_NUMBER_HIGH = 4,
  UNRECOGNIZED = -1,
}

export function accountDefenderAssessment_AccountDefenderLabelFromJSON(
  object: any,
): AccountDefenderAssessment_AccountDefenderLabel {
  switch (object) {
    case 0:
    case "ACCOUNT_DEFENDER_LABEL_UNSPECIFIED":
      return AccountDefenderAssessment_AccountDefenderLabel.ACCOUNT_DEFENDER_LABEL_UNSPECIFIED;
    case 1:
    case "PROFILE_MATCH":
      return AccountDefenderAssessment_AccountDefenderLabel.PROFILE_MATCH;
    case 2:
    case "SUSPICIOUS_LOGIN_ACTIVITY":
      return AccountDefenderAssessment_AccountDefenderLabel.SUSPICIOUS_LOGIN_ACTIVITY;
    case 3:
    case "SUSPICIOUS_ACCOUNT_CREATION":
      return AccountDefenderAssessment_AccountDefenderLabel.SUSPICIOUS_ACCOUNT_CREATION;
    case 4:
    case "RELATED_ACCOUNTS_NUMBER_HIGH":
      return AccountDefenderAssessment_AccountDefenderLabel.RELATED_ACCOUNTS_NUMBER_HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccountDefenderAssessment_AccountDefenderLabel.UNRECOGNIZED;
  }
}

export function accountDefenderAssessment_AccountDefenderLabelToJSON(
  object: AccountDefenderAssessment_AccountDefenderLabel,
): string {
  switch (object) {
    case AccountDefenderAssessment_AccountDefenderLabel.ACCOUNT_DEFENDER_LABEL_UNSPECIFIED:
      return "ACCOUNT_DEFENDER_LABEL_UNSPECIFIED";
    case AccountDefenderAssessment_AccountDefenderLabel.PROFILE_MATCH:
      return "PROFILE_MATCH";
    case AccountDefenderAssessment_AccountDefenderLabel.SUSPICIOUS_LOGIN_ACTIVITY:
      return "SUSPICIOUS_LOGIN_ACTIVITY";
    case AccountDefenderAssessment_AccountDefenderLabel.SUSPICIOUS_ACCOUNT_CREATION:
      return "SUSPICIOUS_ACCOUNT_CREATION";
    case AccountDefenderAssessment_AccountDefenderLabel.RELATED_ACCOUNTS_NUMBER_HIGH:
      return "RELATED_ACCOUNTS_NUMBER_HIGH";
    case AccountDefenderAssessment_AccountDefenderLabel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseCreateAssessmentRequest(): CreateAssessmentRequest {
  return { parent: "", assessment: undefined };
}

export const CreateAssessmentRequest: MessageFns<CreateAssessmentRequest> = {
  encode(message: CreateAssessmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.assessment !== undefined) {
      Assessment.encode(message.assessment, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAssessmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAssessmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assessment = Assessment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAssessmentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      assessment: isSet(object.assessment) ? Assessment.fromJSON(object.assessment) : undefined,
    };
  },

  toJSON(message: CreateAssessmentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.assessment !== undefined) {
      obj.assessment = Assessment.toJSON(message.assessment);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAssessmentRequest>): CreateAssessmentRequest {
    return CreateAssessmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAssessmentRequest>): CreateAssessmentRequest {
    const message = createBaseCreateAssessmentRequest();
    message.parent = object.parent ?? "";
    message.assessment = (object.assessment !== undefined && object.assessment !== null)
      ? Assessment.fromPartial(object.assessment)
      : undefined;
    return message;
  },
};

function createBaseTransactionEvent(): TransactionEvent {
  return { eventType: 0, reason: "", value: 0, eventTime: undefined };
}

export const TransactionEvent: MessageFns<TransactionEvent> = {
  encode(message: TransactionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventType !== 0) {
      writer.uint32(8).int32(message.eventType);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.value !== 0) {
      writer.uint32(25).double(message.value);
    }
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.value = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEvent {
    return {
      eventType: isSet(object.eventType) ? transactionEvent_TransactionEventTypeFromJSON(object.eventType) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
    };
  },

  toJSON(message: TransactionEvent): unknown {
    const obj: any = {};
    if (message.eventType !== 0) {
      obj.eventType = transactionEvent_TransactionEventTypeToJSON(message.eventType);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionEvent>): TransactionEvent {
    return TransactionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionEvent>): TransactionEvent {
    const message = createBaseTransactionEvent();
    message.eventType = object.eventType ?? 0;
    message.reason = object.reason ?? "";
    message.value = object.value ?? 0;
    message.eventTime = object.eventTime ?? undefined;
    return message;
  },
};

function createBaseAnnotateAssessmentRequest(): AnnotateAssessmentRequest {
  return { name: "", annotation: 0, reasons: [], hashedAccountId: Buffer.alloc(0), transactionEvent: undefined };
}

export const AnnotateAssessmentRequest: MessageFns<AnnotateAssessmentRequest> = {
  encode(message: AnnotateAssessmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.annotation !== 0) {
      writer.uint32(16).int32(message.annotation);
    }
    writer.uint32(26).fork();
    for (const v of message.reasons) {
      writer.int32(v);
    }
    writer.join();
    if (message.hashedAccountId.length !== 0) {
      writer.uint32(34).bytes(message.hashedAccountId);
    }
    if (message.transactionEvent !== undefined) {
      TransactionEvent.encode(message.transactionEvent, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotateAssessmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotateAssessmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.annotation = reader.int32() as any;
          continue;
        case 3:
          if (tag === 24) {
            message.reasons.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.reasons.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.hashedAccountId = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transactionEvent = TransactionEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotateAssessmentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      annotation: isSet(object.annotation) ? annotateAssessmentRequest_AnnotationFromJSON(object.annotation) : 0,
      reasons: globalThis.Array.isArray(object?.reasons)
        ? object.reasons.map((e: any) => annotateAssessmentRequest_ReasonFromJSON(e))
        : [],
      hashedAccountId: isSet(object.hashedAccountId)
        ? Buffer.from(bytesFromBase64(object.hashedAccountId))
        : Buffer.alloc(0),
      transactionEvent: isSet(object.transactionEvent) ? TransactionEvent.fromJSON(object.transactionEvent) : undefined,
    };
  },

  toJSON(message: AnnotateAssessmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.annotation !== 0) {
      obj.annotation = annotateAssessmentRequest_AnnotationToJSON(message.annotation);
    }
    if (message.reasons?.length) {
      obj.reasons = message.reasons.map((e) => annotateAssessmentRequest_ReasonToJSON(e));
    }
    if (message.hashedAccountId.length !== 0) {
      obj.hashedAccountId = base64FromBytes(message.hashedAccountId);
    }
    if (message.transactionEvent !== undefined) {
      obj.transactionEvent = TransactionEvent.toJSON(message.transactionEvent);
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotateAssessmentRequest>): AnnotateAssessmentRequest {
    return AnnotateAssessmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotateAssessmentRequest>): AnnotateAssessmentRequest {
    const message = createBaseAnnotateAssessmentRequest();
    message.name = object.name ?? "";
    message.annotation = object.annotation ?? 0;
    message.reasons = object.reasons?.map((e) => e) || [];
    message.hashedAccountId = object.hashedAccountId ?? Buffer.alloc(0);
    message.transactionEvent = (object.transactionEvent !== undefined && object.transactionEvent !== null)
      ? TransactionEvent.fromPartial(object.transactionEvent)
      : undefined;
    return message;
  },
};

function createBaseAnnotateAssessmentResponse(): AnnotateAssessmentResponse {
  return {};
}

export const AnnotateAssessmentResponse: MessageFns<AnnotateAssessmentResponse> = {
  encode(_: AnnotateAssessmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotateAssessmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotateAssessmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AnnotateAssessmentResponse {
    return {};
  },

  toJSON(_: AnnotateAssessmentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AnnotateAssessmentResponse>): AnnotateAssessmentResponse {
    return AnnotateAssessmentResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AnnotateAssessmentResponse>): AnnotateAssessmentResponse {
    const message = createBaseAnnotateAssessmentResponse();
    return message;
  },
};

function createBasePasswordLeakVerification(): PasswordLeakVerification {
  return { hashedUserCredentials: Buffer.alloc(0), credentialsLeaked: false, canonicalizedUsername: "" };
}

export const PasswordLeakVerification: MessageFns<PasswordLeakVerification> = {
  encode(message: PasswordLeakVerification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hashedUserCredentials.length !== 0) {
      writer.uint32(10).bytes(message.hashedUserCredentials);
    }
    if (message.credentialsLeaked !== false) {
      writer.uint32(16).bool(message.credentialsLeaked);
    }
    if (message.canonicalizedUsername !== "") {
      writer.uint32(26).string(message.canonicalizedUsername);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PasswordLeakVerification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePasswordLeakVerification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hashedUserCredentials = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.credentialsLeaked = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.canonicalizedUsername = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PasswordLeakVerification {
    return {
      hashedUserCredentials: isSet(object.hashedUserCredentials)
        ? Buffer.from(bytesFromBase64(object.hashedUserCredentials))
        : Buffer.alloc(0),
      credentialsLeaked: isSet(object.credentialsLeaked) ? globalThis.Boolean(object.credentialsLeaked) : false,
      canonicalizedUsername: isSet(object.canonicalizedUsername) ? globalThis.String(object.canonicalizedUsername) : "",
    };
  },

  toJSON(message: PasswordLeakVerification): unknown {
    const obj: any = {};
    if (message.hashedUserCredentials.length !== 0) {
      obj.hashedUserCredentials = base64FromBytes(message.hashedUserCredentials);
    }
    if (message.credentialsLeaked !== false) {
      obj.credentialsLeaked = message.credentialsLeaked;
    }
    if (message.canonicalizedUsername !== "") {
      obj.canonicalizedUsername = message.canonicalizedUsername;
    }
    return obj;
  },

  create(base?: DeepPartial<PasswordLeakVerification>): PasswordLeakVerification {
    return PasswordLeakVerification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PasswordLeakVerification>): PasswordLeakVerification {
    const message = createBasePasswordLeakVerification();
    message.hashedUserCredentials = object.hashedUserCredentials ?? Buffer.alloc(0);
    message.credentialsLeaked = object.credentialsLeaked ?? false;
    message.canonicalizedUsername = object.canonicalizedUsername ?? "";
    return message;
  },
};

function createBaseAssessment(): Assessment {
  return {
    name: "",
    event: undefined,
    score: 0,
    tokenProperties: undefined,
    reasons: [],
    passwordLeakVerification: undefined,
    accountDefenderAssessment: undefined,
    fraudPreventionAssessment: undefined,
  };
}

export const Assessment: MessageFns<Assessment> = {
  encode(message: Assessment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.event !== undefined) {
      Event.encode(message.event, writer.uint32(18).fork()).join();
    }
    if (message.score !== 0) {
      writer.uint32(29).float(message.score);
    }
    if (message.tokenProperties !== undefined) {
      TokenProperties.encode(message.tokenProperties, writer.uint32(34).fork()).join();
    }
    writer.uint32(42).fork();
    for (const v of message.reasons) {
      writer.int32(v);
    }
    writer.join();
    if (message.passwordLeakVerification !== undefined) {
      PasswordLeakVerification.encode(message.passwordLeakVerification, writer.uint32(58).fork()).join();
    }
    if (message.accountDefenderAssessment !== undefined) {
      AccountDefenderAssessment.encode(message.accountDefenderAssessment, writer.uint32(66).fork()).join();
    }
    if (message.fraudPreventionAssessment !== undefined) {
      FraudPreventionAssessment.encode(message.fraudPreventionAssessment, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Assessment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssessment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.event = Event.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.score = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tokenProperties = TokenProperties.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag === 40) {
            message.reasons.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.reasons.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.passwordLeakVerification = PasswordLeakVerification.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.accountDefenderAssessment = AccountDefenderAssessment.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.fraudPreventionAssessment = FraudPreventionAssessment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Assessment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      event: isSet(object.event) ? Event.fromJSON(object.event) : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      tokenProperties: isSet(object.tokenProperties) ? TokenProperties.fromJSON(object.tokenProperties) : undefined,
      reasons: globalThis.Array.isArray(object?.reasons)
        ? object.reasons.map((e: any) => assessment_ClassificationReasonFromJSON(e))
        : [],
      passwordLeakVerification: isSet(object.passwordLeakVerification)
        ? PasswordLeakVerification.fromJSON(object.passwordLeakVerification)
        : undefined,
      accountDefenderAssessment: isSet(object.accountDefenderAssessment)
        ? AccountDefenderAssessment.fromJSON(object.accountDefenderAssessment)
        : undefined,
      fraudPreventionAssessment: isSet(object.fraudPreventionAssessment)
        ? FraudPreventionAssessment.fromJSON(object.fraudPreventionAssessment)
        : undefined,
    };
  },

  toJSON(message: Assessment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.event !== undefined) {
      obj.event = Event.toJSON(message.event);
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.tokenProperties !== undefined) {
      obj.tokenProperties = TokenProperties.toJSON(message.tokenProperties);
    }
    if (message.reasons?.length) {
      obj.reasons = message.reasons.map((e) => assessment_ClassificationReasonToJSON(e));
    }
    if (message.passwordLeakVerification !== undefined) {
      obj.passwordLeakVerification = PasswordLeakVerification.toJSON(message.passwordLeakVerification);
    }
    if (message.accountDefenderAssessment !== undefined) {
      obj.accountDefenderAssessment = AccountDefenderAssessment.toJSON(message.accountDefenderAssessment);
    }
    if (message.fraudPreventionAssessment !== undefined) {
      obj.fraudPreventionAssessment = FraudPreventionAssessment.toJSON(message.fraudPreventionAssessment);
    }
    return obj;
  },

  create(base?: DeepPartial<Assessment>): Assessment {
    return Assessment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Assessment>): Assessment {
    const message = createBaseAssessment();
    message.name = object.name ?? "";
    message.event = (object.event !== undefined && object.event !== null) ? Event.fromPartial(object.event) : undefined;
    message.score = object.score ?? 0;
    message.tokenProperties = (object.tokenProperties !== undefined && object.tokenProperties !== null)
      ? TokenProperties.fromPartial(object.tokenProperties)
      : undefined;
    message.reasons = object.reasons?.map((e) => e) || [];
    message.passwordLeakVerification =
      (object.passwordLeakVerification !== undefined && object.passwordLeakVerification !== null)
        ? PasswordLeakVerification.fromPartial(object.passwordLeakVerification)
        : undefined;
    message.accountDefenderAssessment =
      (object.accountDefenderAssessment !== undefined && object.accountDefenderAssessment !== null)
        ? AccountDefenderAssessment.fromPartial(object.accountDefenderAssessment)
        : undefined;
    message.fraudPreventionAssessment =
      (object.fraudPreventionAssessment !== undefined && object.fraudPreventionAssessment !== null)
        ? FraudPreventionAssessment.fromPartial(object.fraudPreventionAssessment)
        : undefined;
    return message;
  },
};

function createBaseEvent(): Event {
  return {
    token: "",
    siteKey: "",
    userAgent: "",
    userIpAddress: "",
    expectedAction: "",
    hashedAccountId: Buffer.alloc(0),
    transactionData: undefined,
    fraudPrevention: 0,
  };
}

export const Event: MessageFns<Event> = {
  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.siteKey !== "") {
      writer.uint32(18).string(message.siteKey);
    }
    if (message.userAgent !== "") {
      writer.uint32(26).string(message.userAgent);
    }
    if (message.userIpAddress !== "") {
      writer.uint32(34).string(message.userIpAddress);
    }
    if (message.expectedAction !== "") {
      writer.uint32(42).string(message.expectedAction);
    }
    if (message.hashedAccountId.length !== 0) {
      writer.uint32(50).bytes(message.hashedAccountId);
    }
    if (message.transactionData !== undefined) {
      TransactionData.encode(message.transactionData, writer.uint32(106).fork()).join();
    }
    if (message.fraudPrevention !== 0) {
      writer.uint32(136).int32(message.fraudPrevention);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.siteKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userIpAddress = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.expectedAction = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.hashedAccountId = Buffer.from(reader.bytes());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.transactionData = TransactionData.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.fraudPrevention = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      siteKey: isSet(object.siteKey) ? globalThis.String(object.siteKey) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      userIpAddress: isSet(object.userIpAddress) ? globalThis.String(object.userIpAddress) : "",
      expectedAction: isSet(object.expectedAction) ? globalThis.String(object.expectedAction) : "",
      hashedAccountId: isSet(object.hashedAccountId)
        ? Buffer.from(bytesFromBase64(object.hashedAccountId))
        : Buffer.alloc(0),
      transactionData: isSet(object.transactionData) ? TransactionData.fromJSON(object.transactionData) : undefined,
      fraudPrevention: isSet(object.fraudPrevention) ? event_FraudPreventionFromJSON(object.fraudPrevention) : 0,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.siteKey !== "") {
      obj.siteKey = message.siteKey;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.userIpAddress !== "") {
      obj.userIpAddress = message.userIpAddress;
    }
    if (message.expectedAction !== "") {
      obj.expectedAction = message.expectedAction;
    }
    if (message.hashedAccountId.length !== 0) {
      obj.hashedAccountId = base64FromBytes(message.hashedAccountId);
    }
    if (message.transactionData !== undefined) {
      obj.transactionData = TransactionData.toJSON(message.transactionData);
    }
    if (message.fraudPrevention !== 0) {
      obj.fraudPrevention = event_FraudPreventionToJSON(message.fraudPrevention);
    }
    return obj;
  },

  create(base?: DeepPartial<Event>): Event {
    return Event.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Event>): Event {
    const message = createBaseEvent();
    message.token = object.token ?? "";
    message.siteKey = object.siteKey ?? "";
    message.userAgent = object.userAgent ?? "";
    message.userIpAddress = object.userIpAddress ?? "";
    message.expectedAction = object.expectedAction ?? "";
    message.hashedAccountId = object.hashedAccountId ?? Buffer.alloc(0);
    message.transactionData = (object.transactionData !== undefined && object.transactionData !== null)
      ? TransactionData.fromPartial(object.transactionData)
      : undefined;
    message.fraudPrevention = object.fraudPrevention ?? 0;
    return message;
  },
};

function createBaseTransactionData(): TransactionData {
  return {
    transactionId: undefined,
    paymentMethod: "",
    cardBin: "",
    cardLastFour: "",
    currencyCode: "",
    value: 0,
    shippingValue: 0,
    shippingAddress: undefined,
    billingAddress: undefined,
    user: undefined,
    merchants: [],
    items: [],
    gatewayInfo: undefined,
  };
}

export const TransactionData: MessageFns<TransactionData> = {
  encode(message: TransactionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== undefined) {
      writer.uint32(90).string(message.transactionId);
    }
    if (message.paymentMethod !== "") {
      writer.uint32(10).string(message.paymentMethod);
    }
    if (message.cardBin !== "") {
      writer.uint32(18).string(message.cardBin);
    }
    if (message.cardLastFour !== "") {
      writer.uint32(26).string(message.cardLastFour);
    }
    if (message.currencyCode !== "") {
      writer.uint32(34).string(message.currencyCode);
    }
    if (message.value !== 0) {
      writer.uint32(41).double(message.value);
    }
    if (message.shippingValue !== 0) {
      writer.uint32(97).double(message.shippingValue);
    }
    if (message.shippingAddress !== undefined) {
      TransactionData_Address.encode(message.shippingAddress, writer.uint32(50).fork()).join();
    }
    if (message.billingAddress !== undefined) {
      TransactionData_Address.encode(message.billingAddress, writer.uint32(58).fork()).join();
    }
    if (message.user !== undefined) {
      TransactionData_User.encode(message.user, writer.uint32(66).fork()).join();
    }
    for (const v of message.merchants) {
      TransactionData_User.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.items) {
      TransactionData_Item.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.gatewayInfo !== undefined) {
      TransactionData_GatewayInfo.encode(message.gatewayInfo, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 11:
          if (tag !== 90) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cardBin = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cardLastFour = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.value = reader.double();
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.shippingValue = reader.double();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.shippingAddress = TransactionData_Address.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.billingAddress = TransactionData_Address.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.user = TransactionData_User.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.merchants.push(TransactionData_User.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.items.push(TransactionData_Item.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.gatewayInfo = TransactionData_GatewayInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionData {
    return {
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : undefined,
      paymentMethod: isSet(object.paymentMethod) ? globalThis.String(object.paymentMethod) : "",
      cardBin: isSet(object.cardBin) ? globalThis.String(object.cardBin) : "",
      cardLastFour: isSet(object.cardLastFour) ? globalThis.String(object.cardLastFour) : "",
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      shippingValue: isSet(object.shippingValue) ? globalThis.Number(object.shippingValue) : 0,
      shippingAddress: isSet(object.shippingAddress)
        ? TransactionData_Address.fromJSON(object.shippingAddress)
        : undefined,
      billingAddress: isSet(object.billingAddress)
        ? TransactionData_Address.fromJSON(object.billingAddress)
        : undefined,
      user: isSet(object.user) ? TransactionData_User.fromJSON(object.user) : undefined,
      merchants: globalThis.Array.isArray(object?.merchants)
        ? object.merchants.map((e: any) => TransactionData_User.fromJSON(e))
        : [],
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => TransactionData_Item.fromJSON(e))
        : [],
      gatewayInfo: isSet(object.gatewayInfo) ? TransactionData_GatewayInfo.fromJSON(object.gatewayInfo) : undefined,
    };
  },

  toJSON(message: TransactionData): unknown {
    const obj: any = {};
    if (message.transactionId !== undefined) {
      obj.transactionId = message.transactionId;
    }
    if (message.paymentMethod !== "") {
      obj.paymentMethod = message.paymentMethod;
    }
    if (message.cardBin !== "") {
      obj.cardBin = message.cardBin;
    }
    if (message.cardLastFour !== "") {
      obj.cardLastFour = message.cardLastFour;
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.shippingValue !== 0) {
      obj.shippingValue = message.shippingValue;
    }
    if (message.shippingAddress !== undefined) {
      obj.shippingAddress = TransactionData_Address.toJSON(message.shippingAddress);
    }
    if (message.billingAddress !== undefined) {
      obj.billingAddress = TransactionData_Address.toJSON(message.billingAddress);
    }
    if (message.user !== undefined) {
      obj.user = TransactionData_User.toJSON(message.user);
    }
    if (message.merchants?.length) {
      obj.merchants = message.merchants.map((e) => TransactionData_User.toJSON(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => TransactionData_Item.toJSON(e));
    }
    if (message.gatewayInfo !== undefined) {
      obj.gatewayInfo = TransactionData_GatewayInfo.toJSON(message.gatewayInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionData>): TransactionData {
    return TransactionData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionData>): TransactionData {
    const message = createBaseTransactionData();
    message.transactionId = object.transactionId ?? undefined;
    message.paymentMethod = object.paymentMethod ?? "";
    message.cardBin = object.cardBin ?? "";
    message.cardLastFour = object.cardLastFour ?? "";
    message.currencyCode = object.currencyCode ?? "";
    message.value = object.value ?? 0;
    message.shippingValue = object.shippingValue ?? 0;
    message.shippingAddress = (object.shippingAddress !== undefined && object.shippingAddress !== null)
      ? TransactionData_Address.fromPartial(object.shippingAddress)
      : undefined;
    message.billingAddress = (object.billingAddress !== undefined && object.billingAddress !== null)
      ? TransactionData_Address.fromPartial(object.billingAddress)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null)
      ? TransactionData_User.fromPartial(object.user)
      : undefined;
    message.merchants = object.merchants?.map((e) => TransactionData_User.fromPartial(e)) || [];
    message.items = object.items?.map((e) => TransactionData_Item.fromPartial(e)) || [];
    message.gatewayInfo = (object.gatewayInfo !== undefined && object.gatewayInfo !== null)
      ? TransactionData_GatewayInfo.fromPartial(object.gatewayInfo)
      : undefined;
    return message;
  },
};

function createBaseTransactionData_Address(): TransactionData_Address {
  return { recipient: "", address: [], locality: "", administrativeArea: "", regionCode: "", postalCode: "" };
}

export const TransactionData_Address: MessageFns<TransactionData_Address> = {
  encode(message: TransactionData_Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recipient !== "") {
      writer.uint32(10).string(message.recipient);
    }
    for (const v of message.address) {
      writer.uint32(18).string(v!);
    }
    if (message.locality !== "") {
      writer.uint32(26).string(message.locality);
    }
    if (message.administrativeArea !== "") {
      writer.uint32(34).string(message.administrativeArea);
    }
    if (message.regionCode !== "") {
      writer.uint32(42).string(message.regionCode);
    }
    if (message.postalCode !== "") {
      writer.uint32(50).string(message.postalCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionData_Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionData_Address();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.recipient = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.locality = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.administrativeArea = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.postalCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionData_Address {
    return {
      recipient: isSet(object.recipient) ? globalThis.String(object.recipient) : "",
      address: globalThis.Array.isArray(object?.address) ? object.address.map((e: any) => globalThis.String(e)) : [],
      locality: isSet(object.locality) ? globalThis.String(object.locality) : "",
      administrativeArea: isSet(object.administrativeArea) ? globalThis.String(object.administrativeArea) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : "",
    };
  },

  toJSON(message: TransactionData_Address): unknown {
    const obj: any = {};
    if (message.recipient !== "") {
      obj.recipient = message.recipient;
    }
    if (message.address?.length) {
      obj.address = message.address;
    }
    if (message.locality !== "") {
      obj.locality = message.locality;
    }
    if (message.administrativeArea !== "") {
      obj.administrativeArea = message.administrativeArea;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionData_Address>): TransactionData_Address {
    return TransactionData_Address.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionData_Address>): TransactionData_Address {
    const message = createBaseTransactionData_Address();
    message.recipient = object.recipient ?? "";
    message.address = object.address?.map((e) => e) || [];
    message.locality = object.locality ?? "";
    message.administrativeArea = object.administrativeArea ?? "";
    message.regionCode = object.regionCode ?? "";
    message.postalCode = object.postalCode ?? "";
    return message;
  },
};

function createBaseTransactionData_User(): TransactionData_User {
  return {
    accountId: "",
    creationMs: Long.ZERO,
    email: "",
    emailVerified: false,
    phoneNumber: "",
    phoneVerified: false,
  };
}

export const TransactionData_User: MessageFns<TransactionData_User> = {
  encode(message: TransactionData_User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(50).string(message.accountId);
    }
    if (!message.creationMs.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.creationMs.toString());
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.emailVerified !== false) {
      writer.uint32(24).bool(message.emailVerified);
    }
    if (message.phoneNumber !== "") {
      writer.uint32(34).string(message.phoneNumber);
    }
    if (message.phoneVerified !== false) {
      writer.uint32(40).bool(message.phoneVerified);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionData_User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionData_User();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.creationMs = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.emailVerified = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.phoneVerified = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionData_User {
    return {
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      creationMs: isSet(object.creationMs) ? Long.fromValue(object.creationMs) : Long.ZERO,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      emailVerified: isSet(object.emailVerified) ? globalThis.Boolean(object.emailVerified) : false,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : "",
      phoneVerified: isSet(object.phoneVerified) ? globalThis.Boolean(object.phoneVerified) : false,
    };
  },

  toJSON(message: TransactionData_User): unknown {
    const obj: any = {};
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (!message.creationMs.equals(Long.ZERO)) {
      obj.creationMs = (message.creationMs || Long.ZERO).toString();
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.emailVerified !== false) {
      obj.emailVerified = message.emailVerified;
    }
    if (message.phoneNumber !== "") {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.phoneVerified !== false) {
      obj.phoneVerified = message.phoneVerified;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionData_User>): TransactionData_User {
    return TransactionData_User.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionData_User>): TransactionData_User {
    const message = createBaseTransactionData_User();
    message.accountId = object.accountId ?? "";
    message.creationMs = (object.creationMs !== undefined && object.creationMs !== null)
      ? Long.fromValue(object.creationMs)
      : Long.ZERO;
    message.email = object.email ?? "";
    message.emailVerified = object.emailVerified ?? false;
    message.phoneNumber = object.phoneNumber ?? "";
    message.phoneVerified = object.phoneVerified ?? false;
    return message;
  },
};

function createBaseTransactionData_Item(): TransactionData_Item {
  return { name: "", value: 0, quantity: Long.ZERO, merchantAccountId: "" };
}

export const TransactionData_Item: MessageFns<TransactionData_Item> = {
  encode(message: TransactionData_Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    if (!message.quantity.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.quantity.toString());
    }
    if (message.merchantAccountId !== "") {
      writer.uint32(34).string(message.merchantAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionData_Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionData_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.quantity = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.merchantAccountId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionData_Item {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      quantity: isSet(object.quantity) ? Long.fromValue(object.quantity) : Long.ZERO,
      merchantAccountId: isSet(object.merchantAccountId) ? globalThis.String(object.merchantAccountId) : "",
    };
  },

  toJSON(message: TransactionData_Item): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (!message.quantity.equals(Long.ZERO)) {
      obj.quantity = (message.quantity || Long.ZERO).toString();
    }
    if (message.merchantAccountId !== "") {
      obj.merchantAccountId = message.merchantAccountId;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionData_Item>): TransactionData_Item {
    return TransactionData_Item.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionData_Item>): TransactionData_Item {
    const message = createBaseTransactionData_Item();
    message.name = object.name ?? "";
    message.value = object.value ?? 0;
    message.quantity = (object.quantity !== undefined && object.quantity !== null)
      ? Long.fromValue(object.quantity)
      : Long.ZERO;
    message.merchantAccountId = object.merchantAccountId ?? "";
    return message;
  },
};

function createBaseTransactionData_GatewayInfo(): TransactionData_GatewayInfo {
  return { name: "", gatewayResponseCode: "", avsResponseCode: "", cvvResponseCode: "" };
}

export const TransactionData_GatewayInfo: MessageFns<TransactionData_GatewayInfo> = {
  encode(message: TransactionData_GatewayInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.gatewayResponseCode !== "") {
      writer.uint32(18).string(message.gatewayResponseCode);
    }
    if (message.avsResponseCode !== "") {
      writer.uint32(26).string(message.avsResponseCode);
    }
    if (message.cvvResponseCode !== "") {
      writer.uint32(34).string(message.cvvResponseCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionData_GatewayInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionData_GatewayInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gatewayResponseCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avsResponseCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cvvResponseCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionData_GatewayInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      gatewayResponseCode: isSet(object.gatewayResponseCode) ? globalThis.String(object.gatewayResponseCode) : "",
      avsResponseCode: isSet(object.avsResponseCode) ? globalThis.String(object.avsResponseCode) : "",
      cvvResponseCode: isSet(object.cvvResponseCode) ? globalThis.String(object.cvvResponseCode) : "",
    };
  },

  toJSON(message: TransactionData_GatewayInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.gatewayResponseCode !== "") {
      obj.gatewayResponseCode = message.gatewayResponseCode;
    }
    if (message.avsResponseCode !== "") {
      obj.avsResponseCode = message.avsResponseCode;
    }
    if (message.cvvResponseCode !== "") {
      obj.cvvResponseCode = message.cvvResponseCode;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionData_GatewayInfo>): TransactionData_GatewayInfo {
    return TransactionData_GatewayInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionData_GatewayInfo>): TransactionData_GatewayInfo {
    const message = createBaseTransactionData_GatewayInfo();
    message.name = object.name ?? "";
    message.gatewayResponseCode = object.gatewayResponseCode ?? "";
    message.avsResponseCode = object.avsResponseCode ?? "";
    message.cvvResponseCode = object.cvvResponseCode ?? "";
    return message;
  },
};

function createBaseTokenProperties(): TokenProperties {
  return { valid: false, invalidReason: 0, createTime: undefined, hostname: "", action: "" };
}

export const TokenProperties: MessageFns<TokenProperties> = {
  encode(message: TokenProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.invalidReason !== 0) {
      writer.uint32(16).int32(message.invalidReason);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.hostname !== "") {
      writer.uint32(34).string(message.hostname);
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.invalidReason = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenProperties {
    return {
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      invalidReason: isSet(object.invalidReason) ? tokenProperties_InvalidReasonFromJSON(object.invalidReason) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: TokenProperties): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.invalidReason !== 0) {
      obj.invalidReason = tokenProperties_InvalidReasonToJSON(message.invalidReason);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create(base?: DeepPartial<TokenProperties>): TokenProperties {
    return TokenProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TokenProperties>): TokenProperties {
    const message = createBaseTokenProperties();
    message.valid = object.valid ?? false;
    message.invalidReason = object.invalidReason ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.hostname = object.hostname ?? "";
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseFraudPreventionAssessment(): FraudPreventionAssessment {
  return {
    transactionRisk: 0,
    stolenInstrumentVerdict: undefined,
    cardTestingVerdict: undefined,
    behavioralTrustVerdict: undefined,
  };
}

export const FraudPreventionAssessment: MessageFns<FraudPreventionAssessment> = {
  encode(message: FraudPreventionAssessment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionRisk !== 0) {
      writer.uint32(13).float(message.transactionRisk);
    }
    if (message.stolenInstrumentVerdict !== undefined) {
      FraudPreventionAssessment_StolenInstrumentVerdict.encode(
        message.stolenInstrumentVerdict,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.cardTestingVerdict !== undefined) {
      FraudPreventionAssessment_CardTestingVerdict.encode(message.cardTestingVerdict, writer.uint32(26).fork()).join();
    }
    if (message.behavioralTrustVerdict !== undefined) {
      FraudPreventionAssessment_BehavioralTrustVerdict.encode(message.behavioralTrustVerdict, writer.uint32(34).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FraudPreventionAssessment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFraudPreventionAssessment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.transactionRisk = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stolenInstrumentVerdict = FraudPreventionAssessment_StolenInstrumentVerdict.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cardTestingVerdict = FraudPreventionAssessment_CardTestingVerdict.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.behavioralTrustVerdict = FraudPreventionAssessment_BehavioralTrustVerdict.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FraudPreventionAssessment {
    return {
      transactionRisk: isSet(object.transactionRisk) ? globalThis.Number(object.transactionRisk) : 0,
      stolenInstrumentVerdict: isSet(object.stolenInstrumentVerdict)
        ? FraudPreventionAssessment_StolenInstrumentVerdict.fromJSON(object.stolenInstrumentVerdict)
        : undefined,
      cardTestingVerdict: isSet(object.cardTestingVerdict)
        ? FraudPreventionAssessment_CardTestingVerdict.fromJSON(object.cardTestingVerdict)
        : undefined,
      behavioralTrustVerdict: isSet(object.behavioralTrustVerdict)
        ? FraudPreventionAssessment_BehavioralTrustVerdict.fromJSON(object.behavioralTrustVerdict)
        : undefined,
    };
  },

  toJSON(message: FraudPreventionAssessment): unknown {
    const obj: any = {};
    if (message.transactionRisk !== 0) {
      obj.transactionRisk = message.transactionRisk;
    }
    if (message.stolenInstrumentVerdict !== undefined) {
      obj.stolenInstrumentVerdict = FraudPreventionAssessment_StolenInstrumentVerdict.toJSON(
        message.stolenInstrumentVerdict,
      );
    }
    if (message.cardTestingVerdict !== undefined) {
      obj.cardTestingVerdict = FraudPreventionAssessment_CardTestingVerdict.toJSON(message.cardTestingVerdict);
    }
    if (message.behavioralTrustVerdict !== undefined) {
      obj.behavioralTrustVerdict = FraudPreventionAssessment_BehavioralTrustVerdict.toJSON(
        message.behavioralTrustVerdict,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<FraudPreventionAssessment>): FraudPreventionAssessment {
    return FraudPreventionAssessment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FraudPreventionAssessment>): FraudPreventionAssessment {
    const message = createBaseFraudPreventionAssessment();
    message.transactionRisk = object.transactionRisk ?? 0;
    message.stolenInstrumentVerdict =
      (object.stolenInstrumentVerdict !== undefined && object.stolenInstrumentVerdict !== null)
        ? FraudPreventionAssessment_StolenInstrumentVerdict.fromPartial(object.stolenInstrumentVerdict)
        : undefined;
    message.cardTestingVerdict = (object.cardTestingVerdict !== undefined && object.cardTestingVerdict !== null)
      ? FraudPreventionAssessment_CardTestingVerdict.fromPartial(object.cardTestingVerdict)
      : undefined;
    message.behavioralTrustVerdict =
      (object.behavioralTrustVerdict !== undefined && object.behavioralTrustVerdict !== null)
        ? FraudPreventionAssessment_BehavioralTrustVerdict.fromPartial(object.behavioralTrustVerdict)
        : undefined;
    return message;
  },
};

function createBaseFraudPreventionAssessment_StolenInstrumentVerdict(): FraudPreventionAssessment_StolenInstrumentVerdict {
  return { risk: 0 };
}

export const FraudPreventionAssessment_StolenInstrumentVerdict: MessageFns<
  FraudPreventionAssessment_StolenInstrumentVerdict
> = {
  encode(
    message: FraudPreventionAssessment_StolenInstrumentVerdict,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.risk !== 0) {
      writer.uint32(13).float(message.risk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FraudPreventionAssessment_StolenInstrumentVerdict {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFraudPreventionAssessment_StolenInstrumentVerdict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.risk = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FraudPreventionAssessment_StolenInstrumentVerdict {
    return { risk: isSet(object.risk) ? globalThis.Number(object.risk) : 0 };
  },

  toJSON(message: FraudPreventionAssessment_StolenInstrumentVerdict): unknown {
    const obj: any = {};
    if (message.risk !== 0) {
      obj.risk = message.risk;
    }
    return obj;
  },

  create(
    base?: DeepPartial<FraudPreventionAssessment_StolenInstrumentVerdict>,
  ): FraudPreventionAssessment_StolenInstrumentVerdict {
    return FraudPreventionAssessment_StolenInstrumentVerdict.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FraudPreventionAssessment_StolenInstrumentVerdict>,
  ): FraudPreventionAssessment_StolenInstrumentVerdict {
    const message = createBaseFraudPreventionAssessment_StolenInstrumentVerdict();
    message.risk = object.risk ?? 0;
    return message;
  },
};

function createBaseFraudPreventionAssessment_CardTestingVerdict(): FraudPreventionAssessment_CardTestingVerdict {
  return { risk: 0 };
}

export const FraudPreventionAssessment_CardTestingVerdict: MessageFns<FraudPreventionAssessment_CardTestingVerdict> = {
  encode(
    message: FraudPreventionAssessment_CardTestingVerdict,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.risk !== 0) {
      writer.uint32(13).float(message.risk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FraudPreventionAssessment_CardTestingVerdict {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFraudPreventionAssessment_CardTestingVerdict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.risk = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FraudPreventionAssessment_CardTestingVerdict {
    return { risk: isSet(object.risk) ? globalThis.Number(object.risk) : 0 };
  },

  toJSON(message: FraudPreventionAssessment_CardTestingVerdict): unknown {
    const obj: any = {};
    if (message.risk !== 0) {
      obj.risk = message.risk;
    }
    return obj;
  },

  create(
    base?: DeepPartial<FraudPreventionAssessment_CardTestingVerdict>,
  ): FraudPreventionAssessment_CardTestingVerdict {
    return FraudPreventionAssessment_CardTestingVerdict.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FraudPreventionAssessment_CardTestingVerdict>,
  ): FraudPreventionAssessment_CardTestingVerdict {
    const message = createBaseFraudPreventionAssessment_CardTestingVerdict();
    message.risk = object.risk ?? 0;
    return message;
  },
};

function createBaseFraudPreventionAssessment_BehavioralTrustVerdict(): FraudPreventionAssessment_BehavioralTrustVerdict {
  return { trust: 0 };
}

export const FraudPreventionAssessment_BehavioralTrustVerdict: MessageFns<
  FraudPreventionAssessment_BehavioralTrustVerdict
> = {
  encode(
    message: FraudPreventionAssessment_BehavioralTrustVerdict,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trust !== 0) {
      writer.uint32(13).float(message.trust);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FraudPreventionAssessment_BehavioralTrustVerdict {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFraudPreventionAssessment_BehavioralTrustVerdict();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.trust = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FraudPreventionAssessment_BehavioralTrustVerdict {
    return { trust: isSet(object.trust) ? globalThis.Number(object.trust) : 0 };
  },

  toJSON(message: FraudPreventionAssessment_BehavioralTrustVerdict): unknown {
    const obj: any = {};
    if (message.trust !== 0) {
      obj.trust = message.trust;
    }
    return obj;
  },

  create(
    base?: DeepPartial<FraudPreventionAssessment_BehavioralTrustVerdict>,
  ): FraudPreventionAssessment_BehavioralTrustVerdict {
    return FraudPreventionAssessment_BehavioralTrustVerdict.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FraudPreventionAssessment_BehavioralTrustVerdict>,
  ): FraudPreventionAssessment_BehavioralTrustVerdict {
    const message = createBaseFraudPreventionAssessment_BehavioralTrustVerdict();
    message.trust = object.trust ?? 0;
    return message;
  },
};

function createBaseAccountDefenderAssessment(): AccountDefenderAssessment {
  return { labels: [] };
}

export const AccountDefenderAssessment: MessageFns<AccountDefenderAssessment> = {
  encode(message: AccountDefenderAssessment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.labels) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountDefenderAssessment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountDefenderAssessment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.labels.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.labels.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountDefenderAssessment {
    return {
      labels: globalThis.Array.isArray(object?.labels)
        ? object.labels.map((e: any) => accountDefenderAssessment_AccountDefenderLabelFromJSON(e))
        : [],
    };
  },

  toJSON(message: AccountDefenderAssessment): unknown {
    const obj: any = {};
    if (message.labels?.length) {
      obj.labels = message.labels.map((e) => accountDefenderAssessment_AccountDefenderLabelToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AccountDefenderAssessment>): AccountDefenderAssessment {
    return AccountDefenderAssessment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountDefenderAssessment>): AccountDefenderAssessment {
    const message = createBaseAccountDefenderAssessment();
    message.labels = object.labels?.map((e) => e) || [];
    return message;
  },
};

/** Service to determine the likelihood an event is legitimate. */
export type RecaptchaEnterpriseServiceV1Beta1Definition = typeof RecaptchaEnterpriseServiceV1Beta1Definition;
export const RecaptchaEnterpriseServiceV1Beta1Definition = {
  name: "RecaptchaEnterpriseServiceV1Beta1",
  fullName: "google.cloud.recaptchaenterprise.v1beta1.RecaptchaEnterpriseServiceV1Beta1",
  methods: {
    /** Creates an Assessment of the likelihood an event is legitimate. */
    createAssessment: {
      name: "CreateAssessment",
      requestType: CreateAssessmentRequest,
      requestStream: false,
      responseType: Assessment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([17, 112, 97, 114, 101, 110, 116, 44, 97, 115, 115, 101, 115, 115, 109, 101, 110, 116])],
          578365826: [
            Buffer.from([
              54,
              58,
              10,
              97,
              115,
              115,
              101,
              115,
              115,
              109,
              101,
              110,
              116,
              34,
              40,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              115,
              115,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Annotates a previously created Assessment to provide additional information
     * on whether the event turned out to be authentic or fradulent.
     */
    annotateAssessment: {
      name: "AnnotateAssessment",
      requestType: AnnotateAssessmentRequest,
      requestStream: false,
      responseType: AnnotateAssessmentResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 110, 97, 109, 101, 44, 97, 110, 110, 111, 116, 97, 116, 105, 111, 110])],
          578365826: [
            Buffer.from([
              54,
              58,
              1,
              42,
              34,
              49,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              115,
              115,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface RecaptchaEnterpriseServiceV1Beta1ServiceImplementation<CallContextExt = {}> {
  /** Creates an Assessment of the likelihood an event is legitimate. */
  createAssessment(
    request: CreateAssessmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Assessment>>;
  /**
   * Annotates a previously created Assessment to provide additional information
   * on whether the event turned out to be authentic or fradulent.
   */
  annotateAssessment(
    request: AnnotateAssessmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AnnotateAssessmentResponse>>;
}

export interface RecaptchaEnterpriseServiceV1Beta1Client<CallOptionsExt = {}> {
  /** Creates an Assessment of the likelihood an event is legitimate. */
  createAssessment(
    request: DeepPartial<CreateAssessmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Assessment>;
  /**
   * Annotates a previously created Assessment to provide additional information
   * on whether the event turned out to be authentic or fradulent.
   */
  annotateAssessment(
    request: DeepPartial<AnnotateAssessmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AnnotateAssessmentResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
