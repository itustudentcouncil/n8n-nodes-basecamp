// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/networkmanagement/v1/connectivity_test.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { EndpointInfo, LoadBalancerType, loadBalancerTypeFromJSON, loadBalancerTypeToJSON, Trace } from "./trace.js";

export const protobufPackage = "google.cloud.networkmanagement.v1";

/** A Connectivity Test for a network reachability analysis. */
export interface ConnectivityTest {
  /**
   * Required. Unique name of the resource using the form:
   *     `projects/{project_id}/locations/global/connectivityTests/{test_id}`
   */
  name: string;
  /**
   * The user-supplied description of the Connectivity Test.
   * Maximum of 512 characters.
   */
  description: string;
  /**
   * Required. Source specification of the Connectivity Test.
   *
   * You can use a combination of source IP address, virtual machine
   * (VM) instance, or Compute Engine network to uniquely identify
   * the source location.
   *
   * Examples:
   * If the source IP address is an internal IP address within a Google Cloud
   * Virtual Private Cloud (VPC) network, then you must also specify the VPC
   * network. Otherwise, specify the VM instance, which already contains its
   * internal IP address and VPC network information.
   *
   * If the source of the test is within an on-premises network, then you must
   * provide the destination VPC network.
   *
   * If the source endpoint is a Compute Engine VM instance with multiple
   * network interfaces, the instance itself is not sufficient to identify the
   * endpoint. So, you must also specify the source IP address or VPC network.
   *
   * A reachability analysis proceeds even if the source location is
   * ambiguous. However, the test result may include endpoints that you don't
   * intend to test.
   */
  source:
    | Endpoint
    | undefined;
  /**
   * Required. Destination specification of the Connectivity Test.
   *
   * You can use a combination of destination IP address, Compute Engine
   * VM instance, or VPC network to uniquely identify the destination
   * location.
   *
   * Even if the destination IP address is not unique, the source IP
   * location is unique. Usually, the analysis can infer the destination
   * endpoint from route information.
   *
   * If the destination you specify is a VM instance and the instance has
   * multiple network interfaces, then you must also specify either
   * a destination IP address  or VPC network to identify the destination
   * interface.
   *
   * A reachability analysis proceeds even if the destination location is
   * ambiguous. However, the result can include endpoints that you don't
   * intend to test.
   */
  destination:
    | Endpoint
    | undefined;
  /** IP Protocol of the test. When not provided, "TCP" is assumed. */
  protocol: string;
  /**
   * Other projects that may be relevant for reachability analysis.
   * This is applicable to scenarios where a test can cross project boundaries.
   */
  relatedProjects: string[];
  /** Output only. The display name of a Connectivity Test. */
  displayName: string;
  /** Resource labels to represent user-provided metadata. */
  labels: { [key: string]: string };
  /** Output only. The time the test was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the test's configuration was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. The reachability details of this test from the latest run.
   * The details are updated when creating a new test, updating an
   * existing test, or triggering a one-time rerun of an existing test.
   */
  reachabilityDetails:
    | ReachabilityDetails
    | undefined;
  /**
   * Output only. The probing details of this test from the latest run, present
   * for applicable tests only. The details are updated when creating a new
   * test, updating an existing test, or triggering a one-time rerun of an
   * existing test.
   */
  probingDetails:
    | ProbingDetails
    | undefined;
  /**
   * Whether the test should skip firewall checking.
   * If not provided, we assume false.
   */
  bypassFirewallChecks: boolean;
}

export interface ConnectivityTest_LabelsEntry {
  key: string;
  value: string;
}

/** Source or destination of the Connectivity Test. */
export interface Endpoint {
  /** The IP address of the endpoint, which can be an external or internal IP. */
  ipAddress: string;
  /**
   * The IP protocol port of the endpoint.
   * Only applicable when protocol is TCP or UDP.
   */
  port: number;
  /** A Compute Engine instance URI. */
  instance: string;
  /**
   * A forwarding rule and its corresponding IP address represent the frontend
   * configuration of a Google Cloud load balancer. Forwarding rules are also
   * used for protocol forwarding, Private Service Connect and other network
   * services to provide forwarding information in the control plane. Format:
   *  projects/{project}/global/forwardingRules/{id} or
   *  projects/{project}/regions/{region}/forwardingRules/{id}
   */
  forwardingRule: string;
  /** Output only. Specifies the type of the target of the forwarding rule. */
  forwardingRuleTarget?:
    | Endpoint_ForwardingRuleTarget
    | undefined;
  /**
   * Output only. ID of the load balancer the forwarding rule points to. Empty
   * for forwarding rules not related to load balancers.
   */
  loadBalancerId?:
    | string
    | undefined;
  /** Output only. Type of the load balancer the forwarding rule points to. */
  loadBalancerType?:
    | LoadBalancerType
    | undefined;
  /**
   * A cluster URI for [Google Kubernetes Engine
   * master](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture).
   */
  gkeMasterCluster: string;
  /** A [Cloud SQL](https://cloud.google.com/sql) instance URI. */
  cloudSqlInstance: string;
  /** A [Cloud Function](https://cloud.google.com/functions). */
  cloudFunction:
    | Endpoint_CloudFunctionEndpoint
    | undefined;
  /**
   * An [App Engine](https://cloud.google.com/appengine) [service
   * version](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions).
   */
  appEngineVersion:
    | Endpoint_AppEngineVersionEndpoint
    | undefined;
  /**
   * A [Cloud Run](https://cloud.google.com/run)
   * [revision](https://cloud.google.com/run/docs/reference/rest/v1/namespaces.revisions/get)
   */
  cloudRunRevision:
    | Endpoint_CloudRunRevisionEndpoint
    | undefined;
  /** A Compute Engine network URI. */
  network: string;
  /**
   * Type of the network where the endpoint is located.
   * Applicable only to source endpoint, as destination network type can be
   * inferred from the source.
   */
  networkType: Endpoint_NetworkType;
  /**
   * Project ID where the endpoint is located.
   * The Project ID can be derived from the URI if you provide a VM instance or
   * network URI.
   * The following are two cases where you must provide the project ID:
   * 1. Only the IP address is specified, and the IP address is within a Google
   * Cloud project.
   * 2. When you are using Shared VPC and the IP address that you provide is
   * from the service project. In this case, the network that the IP address
   * resides in is defined in the host project.
   */
  projectId: string;
}

/**
 * The type definition of an endpoint's network. Use one of the
 * following choices:
 */
export enum Endpoint_NetworkType {
  /** NETWORK_TYPE_UNSPECIFIED - Default type if unspecified. */
  NETWORK_TYPE_UNSPECIFIED = 0,
  /**
   * GCP_NETWORK - A network hosted within Google Cloud.
   * To receive more detailed output, specify the URI for the source or
   * destination network.
   */
  GCP_NETWORK = 1,
  /**
   * NON_GCP_NETWORK - A network hosted outside of Google Cloud.
   * This can be an on-premises network, or a network hosted by another cloud
   * provider.
   */
  NON_GCP_NETWORK = 2,
  UNRECOGNIZED = -1,
}

export function endpoint_NetworkTypeFromJSON(object: any): Endpoint_NetworkType {
  switch (object) {
    case 0:
    case "NETWORK_TYPE_UNSPECIFIED":
      return Endpoint_NetworkType.NETWORK_TYPE_UNSPECIFIED;
    case 1:
    case "GCP_NETWORK":
      return Endpoint_NetworkType.GCP_NETWORK;
    case 2:
    case "NON_GCP_NETWORK":
      return Endpoint_NetworkType.NON_GCP_NETWORK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Endpoint_NetworkType.UNRECOGNIZED;
  }
}

export function endpoint_NetworkTypeToJSON(object: Endpoint_NetworkType): string {
  switch (object) {
    case Endpoint_NetworkType.NETWORK_TYPE_UNSPECIFIED:
      return "NETWORK_TYPE_UNSPECIFIED";
    case Endpoint_NetworkType.GCP_NETWORK:
      return "GCP_NETWORK";
    case Endpoint_NetworkType.NON_GCP_NETWORK:
      return "NON_GCP_NETWORK";
    case Endpoint_NetworkType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of the target of a forwarding rule. */
export enum Endpoint_ForwardingRuleTarget {
  /** FORWARDING_RULE_TARGET_UNSPECIFIED - Forwarding rule target is unknown. */
  FORWARDING_RULE_TARGET_UNSPECIFIED = 0,
  /** INSTANCE - Compute Engine instance for protocol forwarding. */
  INSTANCE = 1,
  /**
   * LOAD_BALANCER - Load Balancer. The specific type can be found from [load_balancer_type]
   * [google.cloud.networkmanagement.v1.Endpoint.load_balancer_type].
   */
  LOAD_BALANCER = 2,
  /** VPN_GATEWAY - Classic Cloud VPN Gateway. */
  VPN_GATEWAY = 3,
  /** PSC - Forwarding Rule is a Private Service Connect endpoint. */
  PSC = 4,
  UNRECOGNIZED = -1,
}

export function endpoint_ForwardingRuleTargetFromJSON(object: any): Endpoint_ForwardingRuleTarget {
  switch (object) {
    case 0:
    case "FORWARDING_RULE_TARGET_UNSPECIFIED":
      return Endpoint_ForwardingRuleTarget.FORWARDING_RULE_TARGET_UNSPECIFIED;
    case 1:
    case "INSTANCE":
      return Endpoint_ForwardingRuleTarget.INSTANCE;
    case 2:
    case "LOAD_BALANCER":
      return Endpoint_ForwardingRuleTarget.LOAD_BALANCER;
    case 3:
    case "VPN_GATEWAY":
      return Endpoint_ForwardingRuleTarget.VPN_GATEWAY;
    case 4:
    case "PSC":
      return Endpoint_ForwardingRuleTarget.PSC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Endpoint_ForwardingRuleTarget.UNRECOGNIZED;
  }
}

export function endpoint_ForwardingRuleTargetToJSON(object: Endpoint_ForwardingRuleTarget): string {
  switch (object) {
    case Endpoint_ForwardingRuleTarget.FORWARDING_RULE_TARGET_UNSPECIFIED:
      return "FORWARDING_RULE_TARGET_UNSPECIFIED";
    case Endpoint_ForwardingRuleTarget.INSTANCE:
      return "INSTANCE";
    case Endpoint_ForwardingRuleTarget.LOAD_BALANCER:
      return "LOAD_BALANCER";
    case Endpoint_ForwardingRuleTarget.VPN_GATEWAY:
      return "VPN_GATEWAY";
    case Endpoint_ForwardingRuleTarget.PSC:
      return "PSC";
    case Endpoint_ForwardingRuleTarget.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Wrapper for Cloud Function attributes. */
export interface Endpoint_CloudFunctionEndpoint {
  /** A [Cloud Function](https://cloud.google.com/functions) name. */
  uri: string;
}

/** Wrapper for the App Engine service version attributes. */
export interface Endpoint_AppEngineVersionEndpoint {
  /**
   * An [App Engine](https://cloud.google.com/appengine) [service
   * version](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions)
   * name.
   */
  uri: string;
}

/** Wrapper for Cloud Run revision attributes. */
export interface Endpoint_CloudRunRevisionEndpoint {
  /**
   * A [Cloud Run](https://cloud.google.com/run)
   * [revision](https://cloud.google.com/run/docs/reference/rest/v1/namespaces.revisions/get)
   * URI. The format is:
   * projects/{project}/locations/{location}/revisions/{revision}
   */
  uri: string;
}

/** Results of the configuration analysis from the last run of the test. */
export interface ReachabilityDetails {
  /** The overall result of the test's configuration analysis. */
  result: ReachabilityDetails_Result;
  /** The time of the configuration analysis. */
  verifyTime:
    | Date
    | undefined;
  /** The details of a failure or a cancellation of reachability analysis. */
  error:
    | Status
    | undefined;
  /**
   * Result may contain a list of traces if a test has multiple possible
   * paths in the network, such as when destination endpoint is a load balancer
   * with multiple backends.
   */
  traces: Trace[];
}

/** The overall result of the test's configuration analysis. */
export enum ReachabilityDetails_Result {
  /** RESULT_UNSPECIFIED - No result was specified. */
  RESULT_UNSPECIFIED = 0,
  /**
   * REACHABLE - Possible scenarios are:
   *
   * * The configuration analysis determined that a packet originating from
   *   the source is expected to reach the destination.
   * * The analysis didn't complete because the user lacks permission for
   *   some of the resources in the trace. However, at the time the user's
   *   permission became insufficient, the trace had been successful so far.
   */
  REACHABLE = 1,
  /**
   * UNREACHABLE - A packet originating from the source is expected to be dropped before
   * reaching the destination.
   */
  UNREACHABLE = 2,
  /**
   * AMBIGUOUS - The source and destination endpoints do not uniquely identify
   * the test location in the network, and the reachability result contains
   * multiple traces. For some traces, a packet could be delivered, and for
   * others, it would not be. This result is also assigned to
   * configuration analysis of return path if on its own it should be
   * REACHABLE, but configuration analysis of forward path is AMBIGUOUS.
   */
  AMBIGUOUS = 4,
  /**
   * UNDETERMINED - The configuration analysis did not complete. Possible reasons are:
   *
   * * A permissions error occurred--for example, the user might not have
   *   read permission for all of the resources named in the test.
   * * An internal error occurred.
   * * The analyzer received an invalid or unsupported argument or was unable
   *   to identify a known endpoint.
   */
  UNDETERMINED = 5,
  UNRECOGNIZED = -1,
}

export function reachabilityDetails_ResultFromJSON(object: any): ReachabilityDetails_Result {
  switch (object) {
    case 0:
    case "RESULT_UNSPECIFIED":
      return ReachabilityDetails_Result.RESULT_UNSPECIFIED;
    case 1:
    case "REACHABLE":
      return ReachabilityDetails_Result.REACHABLE;
    case 2:
    case "UNREACHABLE":
      return ReachabilityDetails_Result.UNREACHABLE;
    case 4:
    case "AMBIGUOUS":
      return ReachabilityDetails_Result.AMBIGUOUS;
    case 5:
    case "UNDETERMINED":
      return ReachabilityDetails_Result.UNDETERMINED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReachabilityDetails_Result.UNRECOGNIZED;
  }
}

export function reachabilityDetails_ResultToJSON(object: ReachabilityDetails_Result): string {
  switch (object) {
    case ReachabilityDetails_Result.RESULT_UNSPECIFIED:
      return "RESULT_UNSPECIFIED";
    case ReachabilityDetails_Result.REACHABLE:
      return "REACHABLE";
    case ReachabilityDetails_Result.UNREACHABLE:
      return "UNREACHABLE";
    case ReachabilityDetails_Result.AMBIGUOUS:
      return "AMBIGUOUS";
    case ReachabilityDetails_Result.UNDETERMINED:
      return "UNDETERMINED";
    case ReachabilityDetails_Result.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Latency percentile rank and value. */
export interface LatencyPercentile {
  /** Percentage of samples this data point applies to. */
  percent: number;
  /**
   * percent-th percentile of latency observed, in microseconds.
   * Fraction of percent/100 of samples have latency lower or
   * equal to the value of this field.
   */
  latencyMicros: Long;
}

/** Describes measured latency distribution. */
export interface LatencyDistribution {
  /** Representative latency percentiles. */
  latencyPercentiles: LatencyPercentile[];
}

/** Results of active probing from the last run of the test. */
export interface ProbingDetails {
  /** The overall result of active probing. */
  result: ProbingDetails_ProbingResult;
  /** The time that reachability was assessed through active probing. */
  verifyTime:
    | Date
    | undefined;
  /** Details about an internal failure or the cancellation of active probing. */
  error:
    | Status
    | undefined;
  /** The reason probing was aborted. */
  abortCause: ProbingDetails_ProbingAbortCause;
  /** Number of probes sent. */
  sentProbeCount: number;
  /** Number of probes that reached the destination. */
  successfulProbeCount: number;
  /**
   * The source and destination endpoints derived from the test input and used
   * for active probing.
   */
  endpointInfo:
    | EndpointInfo
    | undefined;
  /**
   * Latency as measured by active probing in one direction:
   * from the source to the destination endpoint.
   */
  probingLatency:
    | LatencyDistribution
    | undefined;
  /**
   * The EdgeLocation from which a packet destined for/originating from the
   * internet will egress/ingress the Google network.
   * This will only be populated for a connectivity test which has an internet
   * destination/source address.
   * The absence of this field *must not* be used as an indication that the
   * destination/source is part of the Google network.
   */
  destinationEgressLocation: ProbingDetails_EdgeLocation | undefined;
}

/** Overall probing result of the test. */
export enum ProbingDetails_ProbingResult {
  /** PROBING_RESULT_UNSPECIFIED - No result was specified. */
  PROBING_RESULT_UNSPECIFIED = 0,
  /** REACHABLE - At least 95% of packets reached the destination. */
  REACHABLE = 1,
  /** UNREACHABLE - No packets reached the destination. */
  UNREACHABLE = 2,
  /** REACHABILITY_INCONSISTENT - Less than 95% of packets reached the destination. */
  REACHABILITY_INCONSISTENT = 3,
  /**
   * UNDETERMINED - Reachability could not be determined. Possible reasons are:
   * * The user lacks permission to access some of the network resources
   *   required to run the test.
   * * No valid source endpoint could be derived from the request.
   * * An internal error occurred.
   */
  UNDETERMINED = 4,
  UNRECOGNIZED = -1,
}

export function probingDetails_ProbingResultFromJSON(object: any): ProbingDetails_ProbingResult {
  switch (object) {
    case 0:
    case "PROBING_RESULT_UNSPECIFIED":
      return ProbingDetails_ProbingResult.PROBING_RESULT_UNSPECIFIED;
    case 1:
    case "REACHABLE":
      return ProbingDetails_ProbingResult.REACHABLE;
    case 2:
    case "UNREACHABLE":
      return ProbingDetails_ProbingResult.UNREACHABLE;
    case 3:
    case "REACHABILITY_INCONSISTENT":
      return ProbingDetails_ProbingResult.REACHABILITY_INCONSISTENT;
    case 4:
    case "UNDETERMINED":
      return ProbingDetails_ProbingResult.UNDETERMINED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProbingDetails_ProbingResult.UNRECOGNIZED;
  }
}

export function probingDetails_ProbingResultToJSON(object: ProbingDetails_ProbingResult): string {
  switch (object) {
    case ProbingDetails_ProbingResult.PROBING_RESULT_UNSPECIFIED:
      return "PROBING_RESULT_UNSPECIFIED";
    case ProbingDetails_ProbingResult.REACHABLE:
      return "REACHABLE";
    case ProbingDetails_ProbingResult.UNREACHABLE:
      return "UNREACHABLE";
    case ProbingDetails_ProbingResult.REACHABILITY_INCONSISTENT:
      return "REACHABILITY_INCONSISTENT";
    case ProbingDetails_ProbingResult.UNDETERMINED:
      return "UNDETERMINED";
    case ProbingDetails_ProbingResult.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Abort cause types. */
export enum ProbingDetails_ProbingAbortCause {
  /** PROBING_ABORT_CAUSE_UNSPECIFIED - No reason was specified. */
  PROBING_ABORT_CAUSE_UNSPECIFIED = 0,
  /**
   * PERMISSION_DENIED - The user lacks permission to access some of the
   * network resources required to run the test.
   */
  PERMISSION_DENIED = 1,
  /** NO_SOURCE_LOCATION - No valid source endpoint could be derived from the request. */
  NO_SOURCE_LOCATION = 2,
  UNRECOGNIZED = -1,
}

export function probingDetails_ProbingAbortCauseFromJSON(object: any): ProbingDetails_ProbingAbortCause {
  switch (object) {
    case 0:
    case "PROBING_ABORT_CAUSE_UNSPECIFIED":
      return ProbingDetails_ProbingAbortCause.PROBING_ABORT_CAUSE_UNSPECIFIED;
    case 1:
    case "PERMISSION_DENIED":
      return ProbingDetails_ProbingAbortCause.PERMISSION_DENIED;
    case 2:
    case "NO_SOURCE_LOCATION":
      return ProbingDetails_ProbingAbortCause.NO_SOURCE_LOCATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProbingDetails_ProbingAbortCause.UNRECOGNIZED;
  }
}

export function probingDetails_ProbingAbortCauseToJSON(object: ProbingDetails_ProbingAbortCause): string {
  switch (object) {
    case ProbingDetails_ProbingAbortCause.PROBING_ABORT_CAUSE_UNSPECIFIED:
      return "PROBING_ABORT_CAUSE_UNSPECIFIED";
    case ProbingDetails_ProbingAbortCause.PERMISSION_DENIED:
      return "PERMISSION_DENIED";
    case ProbingDetails_ProbingAbortCause.NO_SOURCE_LOCATION:
      return "NO_SOURCE_LOCATION";
    case ProbingDetails_ProbingAbortCause.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Representation of a network edge location as per
 * https://cloud.google.com/vpc/docs/edge-locations.
 */
export interface ProbingDetails_EdgeLocation {
  /** Name of the metropolitan area. */
  metropolitanArea: string;
}

function createBaseConnectivityTest(): ConnectivityTest {
  return {
    name: "",
    description: "",
    source: undefined,
    destination: undefined,
    protocol: "",
    relatedProjects: [],
    displayName: "",
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    reachabilityDetails: undefined,
    probingDetails: undefined,
    bypassFirewallChecks: false,
  };
}

export const ConnectivityTest: MessageFns<ConnectivityTest> = {
  encode(message: ConnectivityTest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.source !== undefined) {
      Endpoint.encode(message.source, writer.uint32(26).fork()).join();
    }
    if (message.destination !== undefined) {
      Endpoint.encode(message.destination, writer.uint32(34).fork()).join();
    }
    if (message.protocol !== "") {
      writer.uint32(42).string(message.protocol);
    }
    for (const v of message.relatedProjects) {
      writer.uint32(50).string(v!);
    }
    if (message.displayName !== "") {
      writer.uint32(58).string(message.displayName);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ConnectivityTest_LabelsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(82).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(90).fork()).join();
    }
    if (message.reachabilityDetails !== undefined) {
      ReachabilityDetails.encode(message.reachabilityDetails, writer.uint32(98).fork()).join();
    }
    if (message.probingDetails !== undefined) {
      ProbingDetails.encode(message.probingDetails, writer.uint32(114).fork()).join();
    }
    if (message.bypassFirewallChecks !== false) {
      writer.uint32(136).bool(message.bypassFirewallChecks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectivityTest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectivityTest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.source = Endpoint.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.destination = Endpoint.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.protocol = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.relatedProjects.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = ConnectivityTest_LabelsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.labels[entry8.key] = entry8.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.reachabilityDetails = ReachabilityDetails.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.probingDetails = ProbingDetails.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.bypassFirewallChecks = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectivityTest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      source: isSet(object.source) ? Endpoint.fromJSON(object.source) : undefined,
      destination: isSet(object.destination) ? Endpoint.fromJSON(object.destination) : undefined,
      protocol: isSet(object.protocol) ? globalThis.String(object.protocol) : "",
      relatedProjects: globalThis.Array.isArray(object?.relatedProjects)
        ? object.relatedProjects.map((e: any) => globalThis.String(e))
        : [],
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      reachabilityDetails: isSet(object.reachabilityDetails)
        ? ReachabilityDetails.fromJSON(object.reachabilityDetails)
        : undefined,
      probingDetails: isSet(object.probingDetails) ? ProbingDetails.fromJSON(object.probingDetails) : undefined,
      bypassFirewallChecks: isSet(object.bypassFirewallChecks)
        ? globalThis.Boolean(object.bypassFirewallChecks)
        : false,
    };
  },

  toJSON(message: ConnectivityTest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.source !== undefined) {
      obj.source = Endpoint.toJSON(message.source);
    }
    if (message.destination !== undefined) {
      obj.destination = Endpoint.toJSON(message.destination);
    }
    if (message.protocol !== "") {
      obj.protocol = message.protocol;
    }
    if (message.relatedProjects?.length) {
      obj.relatedProjects = message.relatedProjects;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.reachabilityDetails !== undefined) {
      obj.reachabilityDetails = ReachabilityDetails.toJSON(message.reachabilityDetails);
    }
    if (message.probingDetails !== undefined) {
      obj.probingDetails = ProbingDetails.toJSON(message.probingDetails);
    }
    if (message.bypassFirewallChecks !== false) {
      obj.bypassFirewallChecks = message.bypassFirewallChecks;
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectivityTest>): ConnectivityTest {
    return ConnectivityTest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectivityTest>): ConnectivityTest {
    const message = createBaseConnectivityTest();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.source = (object.source !== undefined && object.source !== null)
      ? Endpoint.fromPartial(object.source)
      : undefined;
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? Endpoint.fromPartial(object.destination)
      : undefined;
    message.protocol = object.protocol ?? "";
    message.relatedProjects = object.relatedProjects?.map((e) => e) || [];
    message.displayName = object.displayName ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.reachabilityDetails = (object.reachabilityDetails !== undefined && object.reachabilityDetails !== null)
      ? ReachabilityDetails.fromPartial(object.reachabilityDetails)
      : undefined;
    message.probingDetails = (object.probingDetails !== undefined && object.probingDetails !== null)
      ? ProbingDetails.fromPartial(object.probingDetails)
      : undefined;
    message.bypassFirewallChecks = object.bypassFirewallChecks ?? false;
    return message;
  },
};

function createBaseConnectivityTest_LabelsEntry(): ConnectivityTest_LabelsEntry {
  return { key: "", value: "" };
}

export const ConnectivityTest_LabelsEntry: MessageFns<ConnectivityTest_LabelsEntry> = {
  encode(message: ConnectivityTest_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectivityTest_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectivityTest_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectivityTest_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConnectivityTest_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectivityTest_LabelsEntry>): ConnectivityTest_LabelsEntry {
    return ConnectivityTest_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectivityTest_LabelsEntry>): ConnectivityTest_LabelsEntry {
    const message = createBaseConnectivityTest_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEndpoint(): Endpoint {
  return {
    ipAddress: "",
    port: 0,
    instance: "",
    forwardingRule: "",
    forwardingRuleTarget: undefined,
    loadBalancerId: undefined,
    loadBalancerType: undefined,
    gkeMasterCluster: "",
    cloudSqlInstance: "",
    cloudFunction: undefined,
    appEngineVersion: undefined,
    cloudRunRevision: undefined,
    network: "",
    networkType: 0,
    projectId: "",
  };
}

export const Endpoint: MessageFns<Endpoint> = {
  encode(message: Endpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipAddress !== "") {
      writer.uint32(10).string(message.ipAddress);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    if (message.instance !== "") {
      writer.uint32(26).string(message.instance);
    }
    if (message.forwardingRule !== "") {
      writer.uint32(106).string(message.forwardingRule);
    }
    if (message.forwardingRuleTarget !== undefined) {
      writer.uint32(112).int32(message.forwardingRuleTarget);
    }
    if (message.loadBalancerId !== undefined) {
      writer.uint32(122).string(message.loadBalancerId);
    }
    if (message.loadBalancerType !== undefined) {
      writer.uint32(128).int32(message.loadBalancerType);
    }
    if (message.gkeMasterCluster !== "") {
      writer.uint32(58).string(message.gkeMasterCluster);
    }
    if (message.cloudSqlInstance !== "") {
      writer.uint32(66).string(message.cloudSqlInstance);
    }
    if (message.cloudFunction !== undefined) {
      Endpoint_CloudFunctionEndpoint.encode(message.cloudFunction, writer.uint32(82).fork()).join();
    }
    if (message.appEngineVersion !== undefined) {
      Endpoint_AppEngineVersionEndpoint.encode(message.appEngineVersion, writer.uint32(90).fork()).join();
    }
    if (message.cloudRunRevision !== undefined) {
      Endpoint_CloudRunRevisionEndpoint.encode(message.cloudRunRevision, writer.uint32(98).fork()).join();
    }
    if (message.network !== "") {
      writer.uint32(34).string(message.network);
    }
    if (message.networkType !== 0) {
      writer.uint32(40).int32(message.networkType);
    }
    if (message.projectId !== "") {
      writer.uint32(50).string(message.projectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.forwardingRule = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.forwardingRuleTarget = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.loadBalancerId = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.loadBalancerType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.gkeMasterCluster = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cloudSqlInstance = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.cloudFunction = Endpoint_CloudFunctionEndpoint.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.appEngineVersion = Endpoint_AppEngineVersionEndpoint.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.cloudRunRevision = Endpoint_CloudRunRevisionEndpoint.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.network = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.networkType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.projectId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint {
    return {
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      forwardingRule: isSet(object.forwardingRule) ? globalThis.String(object.forwardingRule) : "",
      forwardingRuleTarget: isSet(object.forwardingRuleTarget)
        ? endpoint_ForwardingRuleTargetFromJSON(object.forwardingRuleTarget)
        : undefined,
      loadBalancerId: isSet(object.loadBalancerId) ? globalThis.String(object.loadBalancerId) : undefined,
      loadBalancerType: isSet(object.loadBalancerType) ? loadBalancerTypeFromJSON(object.loadBalancerType) : undefined,
      gkeMasterCluster: isSet(object.gkeMasterCluster) ? globalThis.String(object.gkeMasterCluster) : "",
      cloudSqlInstance: isSet(object.cloudSqlInstance) ? globalThis.String(object.cloudSqlInstance) : "",
      cloudFunction: isSet(object.cloudFunction)
        ? Endpoint_CloudFunctionEndpoint.fromJSON(object.cloudFunction)
        : undefined,
      appEngineVersion: isSet(object.appEngineVersion)
        ? Endpoint_AppEngineVersionEndpoint.fromJSON(object.appEngineVersion)
        : undefined,
      cloudRunRevision: isSet(object.cloudRunRevision)
        ? Endpoint_CloudRunRevisionEndpoint.fromJSON(object.cloudRunRevision)
        : undefined,
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      networkType: isSet(object.networkType) ? endpoint_NetworkTypeFromJSON(object.networkType) : 0,
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
    };
  },

  toJSON(message: Endpoint): unknown {
    const obj: any = {};
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.forwardingRule !== "") {
      obj.forwardingRule = message.forwardingRule;
    }
    if (message.forwardingRuleTarget !== undefined) {
      obj.forwardingRuleTarget = endpoint_ForwardingRuleTargetToJSON(message.forwardingRuleTarget);
    }
    if (message.loadBalancerId !== undefined) {
      obj.loadBalancerId = message.loadBalancerId;
    }
    if (message.loadBalancerType !== undefined) {
      obj.loadBalancerType = loadBalancerTypeToJSON(message.loadBalancerType);
    }
    if (message.gkeMasterCluster !== "") {
      obj.gkeMasterCluster = message.gkeMasterCluster;
    }
    if (message.cloudSqlInstance !== "") {
      obj.cloudSqlInstance = message.cloudSqlInstance;
    }
    if (message.cloudFunction !== undefined) {
      obj.cloudFunction = Endpoint_CloudFunctionEndpoint.toJSON(message.cloudFunction);
    }
    if (message.appEngineVersion !== undefined) {
      obj.appEngineVersion = Endpoint_AppEngineVersionEndpoint.toJSON(message.appEngineVersion);
    }
    if (message.cloudRunRevision !== undefined) {
      obj.cloudRunRevision = Endpoint_CloudRunRevisionEndpoint.toJSON(message.cloudRunRevision);
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.networkType !== 0) {
      obj.networkType = endpoint_NetworkTypeToJSON(message.networkType);
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    return obj;
  },

  create(base?: DeepPartial<Endpoint>): Endpoint {
    return Endpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Endpoint>): Endpoint {
    const message = createBaseEndpoint();
    message.ipAddress = object.ipAddress ?? "";
    message.port = object.port ?? 0;
    message.instance = object.instance ?? "";
    message.forwardingRule = object.forwardingRule ?? "";
    message.forwardingRuleTarget = object.forwardingRuleTarget ?? undefined;
    message.loadBalancerId = object.loadBalancerId ?? undefined;
    message.loadBalancerType = object.loadBalancerType ?? undefined;
    message.gkeMasterCluster = object.gkeMasterCluster ?? "";
    message.cloudSqlInstance = object.cloudSqlInstance ?? "";
    message.cloudFunction = (object.cloudFunction !== undefined && object.cloudFunction !== null)
      ? Endpoint_CloudFunctionEndpoint.fromPartial(object.cloudFunction)
      : undefined;
    message.appEngineVersion = (object.appEngineVersion !== undefined && object.appEngineVersion !== null)
      ? Endpoint_AppEngineVersionEndpoint.fromPartial(object.appEngineVersion)
      : undefined;
    message.cloudRunRevision = (object.cloudRunRevision !== undefined && object.cloudRunRevision !== null)
      ? Endpoint_CloudRunRevisionEndpoint.fromPartial(object.cloudRunRevision)
      : undefined;
    message.network = object.network ?? "";
    message.networkType = object.networkType ?? 0;
    message.projectId = object.projectId ?? "";
    return message;
  },
};

function createBaseEndpoint_CloudFunctionEndpoint(): Endpoint_CloudFunctionEndpoint {
  return { uri: "" };
}

export const Endpoint_CloudFunctionEndpoint: MessageFns<Endpoint_CloudFunctionEndpoint> = {
  encode(message: Endpoint_CloudFunctionEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint_CloudFunctionEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint_CloudFunctionEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint_CloudFunctionEndpoint {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: Endpoint_CloudFunctionEndpoint): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<Endpoint_CloudFunctionEndpoint>): Endpoint_CloudFunctionEndpoint {
    return Endpoint_CloudFunctionEndpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Endpoint_CloudFunctionEndpoint>): Endpoint_CloudFunctionEndpoint {
    const message = createBaseEndpoint_CloudFunctionEndpoint();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseEndpoint_AppEngineVersionEndpoint(): Endpoint_AppEngineVersionEndpoint {
  return { uri: "" };
}

export const Endpoint_AppEngineVersionEndpoint: MessageFns<Endpoint_AppEngineVersionEndpoint> = {
  encode(message: Endpoint_AppEngineVersionEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint_AppEngineVersionEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint_AppEngineVersionEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint_AppEngineVersionEndpoint {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: Endpoint_AppEngineVersionEndpoint): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<Endpoint_AppEngineVersionEndpoint>): Endpoint_AppEngineVersionEndpoint {
    return Endpoint_AppEngineVersionEndpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Endpoint_AppEngineVersionEndpoint>): Endpoint_AppEngineVersionEndpoint {
    const message = createBaseEndpoint_AppEngineVersionEndpoint();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseEndpoint_CloudRunRevisionEndpoint(): Endpoint_CloudRunRevisionEndpoint {
  return { uri: "" };
}

export const Endpoint_CloudRunRevisionEndpoint: MessageFns<Endpoint_CloudRunRevisionEndpoint> = {
  encode(message: Endpoint_CloudRunRevisionEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Endpoint_CloudRunRevisionEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint_CloudRunRevisionEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint_CloudRunRevisionEndpoint {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: Endpoint_CloudRunRevisionEndpoint): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<Endpoint_CloudRunRevisionEndpoint>): Endpoint_CloudRunRevisionEndpoint {
    return Endpoint_CloudRunRevisionEndpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Endpoint_CloudRunRevisionEndpoint>): Endpoint_CloudRunRevisionEndpoint {
    const message = createBaseEndpoint_CloudRunRevisionEndpoint();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseReachabilityDetails(): ReachabilityDetails {
  return { result: 0, verifyTime: undefined, error: undefined, traces: [] };
}

export const ReachabilityDetails: MessageFns<ReachabilityDetails> = {
  encode(message: ReachabilityDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.verifyTime !== undefined) {
      Timestamp.encode(toTimestamp(message.verifyTime), writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(26).fork()).join();
    }
    for (const v of message.traces) {
      Trace.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReachabilityDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReachabilityDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.verifyTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.traces.push(Trace.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReachabilityDetails {
    return {
      result: isSet(object.result) ? reachabilityDetails_ResultFromJSON(object.result) : 0,
      verifyTime: isSet(object.verifyTime) ? fromJsonTimestamp(object.verifyTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      traces: globalThis.Array.isArray(object?.traces) ? object.traces.map((e: any) => Trace.fromJSON(e)) : [],
    };
  },

  toJSON(message: ReachabilityDetails): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = reachabilityDetails_ResultToJSON(message.result);
    }
    if (message.verifyTime !== undefined) {
      obj.verifyTime = message.verifyTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.traces?.length) {
      obj.traces = message.traces.map((e) => Trace.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReachabilityDetails>): ReachabilityDetails {
    return ReachabilityDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReachabilityDetails>): ReachabilityDetails {
    const message = createBaseReachabilityDetails();
    message.result = object.result ?? 0;
    message.verifyTime = object.verifyTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.traces = object.traces?.map((e) => Trace.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLatencyPercentile(): LatencyPercentile {
  return { percent: 0, latencyMicros: Long.ZERO };
}

export const LatencyPercentile: MessageFns<LatencyPercentile> = {
  encode(message: LatencyPercentile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.percent !== 0) {
      writer.uint32(8).int32(message.percent);
    }
    if (!message.latencyMicros.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.latencyMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LatencyPercentile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLatencyPercentile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.percent = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.latencyMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LatencyPercentile {
    return {
      percent: isSet(object.percent) ? globalThis.Number(object.percent) : 0,
      latencyMicros: isSet(object.latencyMicros) ? Long.fromValue(object.latencyMicros) : Long.ZERO,
    };
  },

  toJSON(message: LatencyPercentile): unknown {
    const obj: any = {};
    if (message.percent !== 0) {
      obj.percent = Math.round(message.percent);
    }
    if (!message.latencyMicros.equals(Long.ZERO)) {
      obj.latencyMicros = (message.latencyMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<LatencyPercentile>): LatencyPercentile {
    return LatencyPercentile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LatencyPercentile>): LatencyPercentile {
    const message = createBaseLatencyPercentile();
    message.percent = object.percent ?? 0;
    message.latencyMicros = (object.latencyMicros !== undefined && object.latencyMicros !== null)
      ? Long.fromValue(object.latencyMicros)
      : Long.ZERO;
    return message;
  },
};

function createBaseLatencyDistribution(): LatencyDistribution {
  return { latencyPercentiles: [] };
}

export const LatencyDistribution: MessageFns<LatencyDistribution> = {
  encode(message: LatencyDistribution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.latencyPercentiles) {
      LatencyPercentile.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LatencyDistribution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLatencyDistribution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.latencyPercentiles.push(LatencyPercentile.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LatencyDistribution {
    return {
      latencyPercentiles: globalThis.Array.isArray(object?.latencyPercentiles)
        ? object.latencyPercentiles.map((e: any) => LatencyPercentile.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LatencyDistribution): unknown {
    const obj: any = {};
    if (message.latencyPercentiles?.length) {
      obj.latencyPercentiles = message.latencyPercentiles.map((e) => LatencyPercentile.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LatencyDistribution>): LatencyDistribution {
    return LatencyDistribution.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LatencyDistribution>): LatencyDistribution {
    const message = createBaseLatencyDistribution();
    message.latencyPercentiles = object.latencyPercentiles?.map((e) => LatencyPercentile.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProbingDetails(): ProbingDetails {
  return {
    result: 0,
    verifyTime: undefined,
    error: undefined,
    abortCause: 0,
    sentProbeCount: 0,
    successfulProbeCount: 0,
    endpointInfo: undefined,
    probingLatency: undefined,
    destinationEgressLocation: undefined,
  };
}

export const ProbingDetails: MessageFns<ProbingDetails> = {
  encode(message: ProbingDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.verifyTime !== undefined) {
      Timestamp.encode(toTimestamp(message.verifyTime), writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.abortCause !== 0) {
      writer.uint32(32).int32(message.abortCause);
    }
    if (message.sentProbeCount !== 0) {
      writer.uint32(40).int32(message.sentProbeCount);
    }
    if (message.successfulProbeCount !== 0) {
      writer.uint32(48).int32(message.successfulProbeCount);
    }
    if (message.endpointInfo !== undefined) {
      EndpointInfo.encode(message.endpointInfo, writer.uint32(58).fork()).join();
    }
    if (message.probingLatency !== undefined) {
      LatencyDistribution.encode(message.probingLatency, writer.uint32(66).fork()).join();
    }
    if (message.destinationEgressLocation !== undefined) {
      ProbingDetails_EdgeLocation.encode(message.destinationEgressLocation, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProbingDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProbingDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.verifyTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.abortCause = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.sentProbeCount = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.successfulProbeCount = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.endpointInfo = EndpointInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.probingLatency = LatencyDistribution.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.destinationEgressLocation = ProbingDetails_EdgeLocation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProbingDetails {
    return {
      result: isSet(object.result) ? probingDetails_ProbingResultFromJSON(object.result) : 0,
      verifyTime: isSet(object.verifyTime) ? fromJsonTimestamp(object.verifyTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      abortCause: isSet(object.abortCause) ? probingDetails_ProbingAbortCauseFromJSON(object.abortCause) : 0,
      sentProbeCount: isSet(object.sentProbeCount) ? globalThis.Number(object.sentProbeCount) : 0,
      successfulProbeCount: isSet(object.successfulProbeCount) ? globalThis.Number(object.successfulProbeCount) : 0,
      endpointInfo: isSet(object.endpointInfo) ? EndpointInfo.fromJSON(object.endpointInfo) : undefined,
      probingLatency: isSet(object.probingLatency) ? LatencyDistribution.fromJSON(object.probingLatency) : undefined,
      destinationEgressLocation: isSet(object.destinationEgressLocation)
        ? ProbingDetails_EdgeLocation.fromJSON(object.destinationEgressLocation)
        : undefined,
    };
  },

  toJSON(message: ProbingDetails): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = probingDetails_ProbingResultToJSON(message.result);
    }
    if (message.verifyTime !== undefined) {
      obj.verifyTime = message.verifyTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.abortCause !== 0) {
      obj.abortCause = probingDetails_ProbingAbortCauseToJSON(message.abortCause);
    }
    if (message.sentProbeCount !== 0) {
      obj.sentProbeCount = Math.round(message.sentProbeCount);
    }
    if (message.successfulProbeCount !== 0) {
      obj.successfulProbeCount = Math.round(message.successfulProbeCount);
    }
    if (message.endpointInfo !== undefined) {
      obj.endpointInfo = EndpointInfo.toJSON(message.endpointInfo);
    }
    if (message.probingLatency !== undefined) {
      obj.probingLatency = LatencyDistribution.toJSON(message.probingLatency);
    }
    if (message.destinationEgressLocation !== undefined) {
      obj.destinationEgressLocation = ProbingDetails_EdgeLocation.toJSON(message.destinationEgressLocation);
    }
    return obj;
  },

  create(base?: DeepPartial<ProbingDetails>): ProbingDetails {
    return ProbingDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProbingDetails>): ProbingDetails {
    const message = createBaseProbingDetails();
    message.result = object.result ?? 0;
    message.verifyTime = object.verifyTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.abortCause = object.abortCause ?? 0;
    message.sentProbeCount = object.sentProbeCount ?? 0;
    message.successfulProbeCount = object.successfulProbeCount ?? 0;
    message.endpointInfo = (object.endpointInfo !== undefined && object.endpointInfo !== null)
      ? EndpointInfo.fromPartial(object.endpointInfo)
      : undefined;
    message.probingLatency = (object.probingLatency !== undefined && object.probingLatency !== null)
      ? LatencyDistribution.fromPartial(object.probingLatency)
      : undefined;
    message.destinationEgressLocation =
      (object.destinationEgressLocation !== undefined && object.destinationEgressLocation !== null)
        ? ProbingDetails_EdgeLocation.fromPartial(object.destinationEgressLocation)
        : undefined;
    return message;
  },
};

function createBaseProbingDetails_EdgeLocation(): ProbingDetails_EdgeLocation {
  return { metropolitanArea: "" };
}

export const ProbingDetails_EdgeLocation: MessageFns<ProbingDetails_EdgeLocation> = {
  encode(message: ProbingDetails_EdgeLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metropolitanArea !== "") {
      writer.uint32(10).string(message.metropolitanArea);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProbingDetails_EdgeLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProbingDetails_EdgeLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metropolitanArea = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProbingDetails_EdgeLocation {
    return { metropolitanArea: isSet(object.metropolitanArea) ? globalThis.String(object.metropolitanArea) : "" };
  },

  toJSON(message: ProbingDetails_EdgeLocation): unknown {
    const obj: any = {};
    if (message.metropolitanArea !== "") {
      obj.metropolitanArea = message.metropolitanArea;
    }
    return obj;
  },

  create(base?: DeepPartial<ProbingDetails_EdgeLocation>): ProbingDetails_EdgeLocation {
    return ProbingDetails_EdgeLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProbingDetails_EdgeLocation>): ProbingDetails_EdgeLocation {
    const message = createBaseProbingDetails_EdgeLocation();
    message.metropolitanArea = object.metropolitanArea ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
