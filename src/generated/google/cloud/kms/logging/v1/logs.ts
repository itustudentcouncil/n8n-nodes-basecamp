// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/kms/logging/v1/logs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Status } from "../../../../rpc/status.js";

export const protobufPackage = "google.cloud.kms.logging.v1";

/**
 * Log message used to send to Platform Logging for asynchronous
 * CryptoKey events.
 */
export interface CryptoKeyEvent {
  /** An event for rotating the primary CryptoKeyVersion of a CryptoKey. */
  rotationEvent: CryptoKeyEvent_RotationEvent | undefined;
}

/**
 * The event emitted by KMS when performing a scheduled automatic CryptoKey
 * rotation. See https://cloud.google.com/kms/docs/rotating-keys#automatic
 */
export interface CryptoKeyEvent_RotationEvent {
  /**
   * The result of the scheduled key rotation. The 'details' field of the
   * status may contain a google.rpc.PreconditionFailure.
   */
  status: Status | undefined;
}

/**
 * Log message used to send to Platform Logging for asynchronous
 * CryptoKeyVersion events.
 */
export interface CryptoKeyVersionEvent {
  /** An event for the scheduled destruction of a CryptoKeyVersion. */
  scheduledDestructionEvent?:
    | CryptoKeyVersionEvent_ScheduledDestructionEvent
    | undefined;
  /** An event for the generation of a CryptoKeyVersion. */
  keyGenerationEvent?:
    | CryptoKeyVersionEvent_KeyGenerationEvent
    | undefined;
  /** An event for the import of key material for a CryptoKeyVersion. */
  importEvent?: CryptoKeyVersionEvent_ImportEvent | undefined;
}

/**
 * The event emitted by KMS when destroying a CryptoKeyVersion scheduled for
 * destruction. See https://cloud.google.com/kms/docs/destroy-restore#destroy
 */
export interface CryptoKeyVersionEvent_ScheduledDestructionEvent {
  /**
   * The result of the scheduled key version destruction. The 'details' field
   * of the status may contain a google.rpc.PreconditionFailure. For EKM keys,
   * the 'violations' field of a PreconditionFailure will also include EKM
   * errors.
   */
  status:
    | Status
    | undefined;
  /**
   * The Key Access Justification (KAJ) reason associated with the request.
   * This field is only populated for KAJ enrolled customers for EKM keys.
   */
  keyAccessJustificationReason: string;
}

/**
 * The event emitted by KMS when generating a CryptoKeyVersion. See
 * https://cloud.google.com/kms/docs/key-states
 */
export interface CryptoKeyVersionEvent_KeyGenerationEvent {
  /**
   * The result of the key version generation. The 'details' field of the
   * status may contain a google.rpc.PreconditionFailure. For EKM keys, the
   * 'violations' field of a PreconditionFailure will also include EKM errors.
   */
  status:
    | Status
    | undefined;
  /**
   * The Key Access Justification (KAJ) reason associated with the request.
   * This field is only populated for KAJ enrolled customers for EKM keys.
   */
  keyAccessJustificationReason: string;
}

/**
 * The event emitted by KMS when importing a CryptoKeyVersion. See
 * https://cloud.google.com/kms/docs/importing-a-key
 */
export interface CryptoKeyVersionEvent_ImportEvent {
  /**
   * The result of the key version import. The 'details' field of the status
   * may contain a google.rpc.PreconditionFailure.
   */
  status: Status | undefined;
}

function createBaseCryptoKeyEvent(): CryptoKeyEvent {
  return { rotationEvent: undefined };
}

export const CryptoKeyEvent: MessageFns<CryptoKeyEvent> = {
  encode(message: CryptoKeyEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rotationEvent !== undefined) {
      CryptoKeyEvent_RotationEvent.encode(message.rotationEvent, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoKeyEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoKeyEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rotationEvent = CryptoKeyEvent_RotationEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoKeyEvent {
    return {
      rotationEvent: isSet(object.rotationEvent)
        ? CryptoKeyEvent_RotationEvent.fromJSON(object.rotationEvent)
        : undefined,
    };
  },

  toJSON(message: CryptoKeyEvent): unknown {
    const obj: any = {};
    if (message.rotationEvent !== undefined) {
      obj.rotationEvent = CryptoKeyEvent_RotationEvent.toJSON(message.rotationEvent);
    }
    return obj;
  },

  create(base?: DeepPartial<CryptoKeyEvent>): CryptoKeyEvent {
    return CryptoKeyEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CryptoKeyEvent>): CryptoKeyEvent {
    const message = createBaseCryptoKeyEvent();
    message.rotationEvent = (object.rotationEvent !== undefined && object.rotationEvent !== null)
      ? CryptoKeyEvent_RotationEvent.fromPartial(object.rotationEvent)
      : undefined;
    return message;
  },
};

function createBaseCryptoKeyEvent_RotationEvent(): CryptoKeyEvent_RotationEvent {
  return { status: undefined };
}

export const CryptoKeyEvent_RotationEvent: MessageFns<CryptoKeyEvent_RotationEvent> = {
  encode(message: CryptoKeyEvent_RotationEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoKeyEvent_RotationEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoKeyEvent_RotationEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoKeyEvent_RotationEvent {
    return { status: isSet(object.status) ? Status.fromJSON(object.status) : undefined };
  },

  toJSON(message: CryptoKeyEvent_RotationEvent): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<CryptoKeyEvent_RotationEvent>): CryptoKeyEvent_RotationEvent {
    return CryptoKeyEvent_RotationEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CryptoKeyEvent_RotationEvent>): CryptoKeyEvent_RotationEvent {
    const message = createBaseCryptoKeyEvent_RotationEvent();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseCryptoKeyVersionEvent(): CryptoKeyVersionEvent {
  return { scheduledDestructionEvent: undefined, keyGenerationEvent: undefined, importEvent: undefined };
}

export const CryptoKeyVersionEvent: MessageFns<CryptoKeyVersionEvent> = {
  encode(message: CryptoKeyVersionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheduledDestructionEvent !== undefined) {
      CryptoKeyVersionEvent_ScheduledDestructionEvent.encode(
        message.scheduledDestructionEvent,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.keyGenerationEvent !== undefined) {
      CryptoKeyVersionEvent_KeyGenerationEvent.encode(message.keyGenerationEvent, writer.uint32(18).fork()).join();
    }
    if (message.importEvent !== undefined) {
      CryptoKeyVersionEvent_ImportEvent.encode(message.importEvent, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoKeyVersionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoKeyVersionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.scheduledDestructionEvent = CryptoKeyVersionEvent_ScheduledDestructionEvent.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyGenerationEvent = CryptoKeyVersionEvent_KeyGenerationEvent.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.importEvent = CryptoKeyVersionEvent_ImportEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoKeyVersionEvent {
    return {
      scheduledDestructionEvent: isSet(object.scheduledDestructionEvent)
        ? CryptoKeyVersionEvent_ScheduledDestructionEvent.fromJSON(object.scheduledDestructionEvent)
        : undefined,
      keyGenerationEvent: isSet(object.keyGenerationEvent)
        ? CryptoKeyVersionEvent_KeyGenerationEvent.fromJSON(object.keyGenerationEvent)
        : undefined,
      importEvent: isSet(object.importEvent)
        ? CryptoKeyVersionEvent_ImportEvent.fromJSON(object.importEvent)
        : undefined,
    };
  },

  toJSON(message: CryptoKeyVersionEvent): unknown {
    const obj: any = {};
    if (message.scheduledDestructionEvent !== undefined) {
      obj.scheduledDestructionEvent = CryptoKeyVersionEvent_ScheduledDestructionEvent.toJSON(
        message.scheduledDestructionEvent,
      );
    }
    if (message.keyGenerationEvent !== undefined) {
      obj.keyGenerationEvent = CryptoKeyVersionEvent_KeyGenerationEvent.toJSON(message.keyGenerationEvent);
    }
    if (message.importEvent !== undefined) {
      obj.importEvent = CryptoKeyVersionEvent_ImportEvent.toJSON(message.importEvent);
    }
    return obj;
  },

  create(base?: DeepPartial<CryptoKeyVersionEvent>): CryptoKeyVersionEvent {
    return CryptoKeyVersionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CryptoKeyVersionEvent>): CryptoKeyVersionEvent {
    const message = createBaseCryptoKeyVersionEvent();
    message.scheduledDestructionEvent =
      (object.scheduledDestructionEvent !== undefined && object.scheduledDestructionEvent !== null)
        ? CryptoKeyVersionEvent_ScheduledDestructionEvent.fromPartial(object.scheduledDestructionEvent)
        : undefined;
    message.keyGenerationEvent = (object.keyGenerationEvent !== undefined && object.keyGenerationEvent !== null)
      ? CryptoKeyVersionEvent_KeyGenerationEvent.fromPartial(object.keyGenerationEvent)
      : undefined;
    message.importEvent = (object.importEvent !== undefined && object.importEvent !== null)
      ? CryptoKeyVersionEvent_ImportEvent.fromPartial(object.importEvent)
      : undefined;
    return message;
  },
};

function createBaseCryptoKeyVersionEvent_ScheduledDestructionEvent(): CryptoKeyVersionEvent_ScheduledDestructionEvent {
  return { status: undefined, keyAccessJustificationReason: "" };
}

export const CryptoKeyVersionEvent_ScheduledDestructionEvent: MessageFns<
  CryptoKeyVersionEvent_ScheduledDestructionEvent
> = {
  encode(
    message: CryptoKeyVersionEvent_ScheduledDestructionEvent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.keyAccessJustificationReason !== "") {
      writer.uint32(18).string(message.keyAccessJustificationReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoKeyVersionEvent_ScheduledDestructionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoKeyVersionEvent_ScheduledDestructionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyAccessJustificationReason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoKeyVersionEvent_ScheduledDestructionEvent {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      keyAccessJustificationReason: isSet(object.keyAccessJustificationReason)
        ? globalThis.String(object.keyAccessJustificationReason)
        : "",
    };
  },

  toJSON(message: CryptoKeyVersionEvent_ScheduledDestructionEvent): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.keyAccessJustificationReason !== "") {
      obj.keyAccessJustificationReason = message.keyAccessJustificationReason;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CryptoKeyVersionEvent_ScheduledDestructionEvent>,
  ): CryptoKeyVersionEvent_ScheduledDestructionEvent {
    return CryptoKeyVersionEvent_ScheduledDestructionEvent.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CryptoKeyVersionEvent_ScheduledDestructionEvent>,
  ): CryptoKeyVersionEvent_ScheduledDestructionEvent {
    const message = createBaseCryptoKeyVersionEvent_ScheduledDestructionEvent();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.keyAccessJustificationReason = object.keyAccessJustificationReason ?? "";
    return message;
  },
};

function createBaseCryptoKeyVersionEvent_KeyGenerationEvent(): CryptoKeyVersionEvent_KeyGenerationEvent {
  return { status: undefined, keyAccessJustificationReason: "" };
}

export const CryptoKeyVersionEvent_KeyGenerationEvent: MessageFns<CryptoKeyVersionEvent_KeyGenerationEvent> = {
  encode(message: CryptoKeyVersionEvent_KeyGenerationEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.keyAccessJustificationReason !== "") {
      writer.uint32(18).string(message.keyAccessJustificationReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoKeyVersionEvent_KeyGenerationEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoKeyVersionEvent_KeyGenerationEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyAccessJustificationReason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoKeyVersionEvent_KeyGenerationEvent {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      keyAccessJustificationReason: isSet(object.keyAccessJustificationReason)
        ? globalThis.String(object.keyAccessJustificationReason)
        : "",
    };
  },

  toJSON(message: CryptoKeyVersionEvent_KeyGenerationEvent): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.keyAccessJustificationReason !== "") {
      obj.keyAccessJustificationReason = message.keyAccessJustificationReason;
    }
    return obj;
  },

  create(base?: DeepPartial<CryptoKeyVersionEvent_KeyGenerationEvent>): CryptoKeyVersionEvent_KeyGenerationEvent {
    return CryptoKeyVersionEvent_KeyGenerationEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CryptoKeyVersionEvent_KeyGenerationEvent>): CryptoKeyVersionEvent_KeyGenerationEvent {
    const message = createBaseCryptoKeyVersionEvent_KeyGenerationEvent();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.keyAccessJustificationReason = object.keyAccessJustificationReason ?? "";
    return message;
  },
};

function createBaseCryptoKeyVersionEvent_ImportEvent(): CryptoKeyVersionEvent_ImportEvent {
  return { status: undefined };
}

export const CryptoKeyVersionEvent_ImportEvent: MessageFns<CryptoKeyVersionEvent_ImportEvent> = {
  encode(message: CryptoKeyVersionEvent_ImportEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoKeyVersionEvent_ImportEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoKeyVersionEvent_ImportEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoKeyVersionEvent_ImportEvent {
    return { status: isSet(object.status) ? Status.fromJSON(object.status) : undefined };
  },

  toJSON(message: CryptoKeyVersionEvent_ImportEvent): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<CryptoKeyVersionEvent_ImportEvent>): CryptoKeyVersionEvent_ImportEvent {
    return CryptoKeyVersionEvent_ImportEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CryptoKeyVersionEvent_ImportEvent>): CryptoKeyVersionEvent_ImportEvent {
    const message = createBaseCryptoKeyVersionEvent_ImportEvent();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
