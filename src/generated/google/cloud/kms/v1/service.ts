// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/kms/v1/service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Int64Value } from "../../../protobuf/wrappers.js";
import {
  CryptoKey,
  CryptoKeyVersion,
  CryptoKeyVersion_CryptoKeyVersionAlgorithm,
  cryptoKeyVersion_CryptoKeyVersionAlgorithmFromJSON,
  cryptoKeyVersion_CryptoKeyVersionAlgorithmToJSON,
  CryptoKeyVersion_CryptoKeyVersionView,
  cryptoKeyVersion_CryptoKeyVersionViewFromJSON,
  cryptoKeyVersion_CryptoKeyVersionViewToJSON,
  ImportJob,
  KeyRing,
  ProtectionLevel,
  protectionLevelFromJSON,
  protectionLevelToJSON,
  PublicKey,
} from "./resources.js";

export const protobufPackage = "google.cloud.kms.v1";

/**
 * Request message for
 * [KeyManagementService.ListKeyRings][google.cloud.kms.v1.KeyManagementService.ListKeyRings].
 */
export interface ListKeyRingsRequest {
  /**
   * Required. The resource name of the location associated with the
   * [KeyRings][google.cloud.kms.v1.KeyRing], in the format
   * `projects/* /locations/*`.
   */
  parent: string;
  /**
   * Optional. Optional limit on the number of
   * [KeyRings][google.cloud.kms.v1.KeyRing] to include in the response. Further
   * [KeyRings][google.cloud.kms.v1.KeyRing] can subsequently be obtained by
   * including the
   * [ListKeyRingsResponse.next_page_token][google.cloud.kms.v1.ListKeyRingsResponse.next_page_token]
   * in a subsequent request.  If unspecified, the server will pick an
   * appropriate default.
   */
  pageSize: number;
  /**
   * Optional. Optional pagination token, returned earlier via
   * [ListKeyRingsResponse.next_page_token][google.cloud.kms.v1.ListKeyRingsResponse.next_page_token].
   */
  pageToken: string;
  /**
   * Optional. Only include resources that match the filter in the response. For
   * more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   */
  filter: string;
  /**
   * Optional. Specify how the results should be sorted. If not specified, the
   * results will be sorted in the default order.  For more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   */
  orderBy: string;
}

/**
 * Request message for
 * [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
 */
export interface ListCryptoKeysRequest {
  /**
   * Required. The resource name of the [KeyRing][google.cloud.kms.v1.KeyRing]
   * to list, in the format `projects/* /locations/* /keyRings/*`.
   */
  parent: string;
  /**
   * Optional. Optional limit on the number of
   * [CryptoKeys][google.cloud.kms.v1.CryptoKey] to include in the response.
   * Further [CryptoKeys][google.cloud.kms.v1.CryptoKey] can subsequently be
   * obtained by including the
   * [ListCryptoKeysResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token]
   * in a subsequent request.  If unspecified, the server will pick an
   * appropriate default.
   */
  pageSize: number;
  /**
   * Optional. Optional pagination token, returned earlier via
   * [ListCryptoKeysResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token].
   */
  pageToken: string;
  /** The fields of the primary version to include in the response. */
  versionView: CryptoKeyVersion_CryptoKeyVersionView;
  /**
   * Optional. Only include resources that match the filter in the response. For
   * more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   */
  filter: string;
  /**
   * Optional. Specify how the results should be sorted. If not specified, the
   * results will be sorted in the default order. For more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   */
  orderBy: string;
}

/**
 * Request message for
 * [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions].
 */
export interface ListCryptoKeyVersionsRequest {
  /**
   * Required. The resource name of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] to list, in the format
   * `projects/* /locations/* /keyRings/* /cryptoKeys/*`.
   */
  parent: string;
  /**
   * Optional. Optional limit on the number of
   * [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] to include in the
   * response. Further [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]
   * can subsequently be obtained by including the
   * [ListCryptoKeyVersionsResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token]
   * in a subsequent request. If unspecified, the server will pick an
   * appropriate default.
   */
  pageSize: number;
  /**
   * Optional. Optional pagination token, returned earlier via
   * [ListCryptoKeyVersionsResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token].
   */
  pageToken: string;
  /** The fields to include in the response. */
  view: CryptoKeyVersion_CryptoKeyVersionView;
  /**
   * Optional. Only include resources that match the filter in the response. For
   * more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   */
  filter: string;
  /**
   * Optional. Specify how the results should be sorted. If not specified, the
   * results will be sorted in the default order. For more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   */
  orderBy: string;
}

/**
 * Request message for
 * [KeyManagementService.ListImportJobs][google.cloud.kms.v1.KeyManagementService.ListImportJobs].
 */
export interface ListImportJobsRequest {
  /**
   * Required. The resource name of the [KeyRing][google.cloud.kms.v1.KeyRing]
   * to list, in the format `projects/* /locations/* /keyRings/*`.
   */
  parent: string;
  /**
   * Optional. Optional limit on the number of
   * [ImportJobs][google.cloud.kms.v1.ImportJob] to include in the response.
   * Further [ImportJobs][google.cloud.kms.v1.ImportJob] can subsequently be
   * obtained by including the
   * [ListImportJobsResponse.next_page_token][google.cloud.kms.v1.ListImportJobsResponse.next_page_token]
   * in a subsequent request. If unspecified, the server will pick an
   * appropriate default.
   */
  pageSize: number;
  /**
   * Optional. Optional pagination token, returned earlier via
   * [ListImportJobsResponse.next_page_token][google.cloud.kms.v1.ListImportJobsResponse.next_page_token].
   */
  pageToken: string;
  /**
   * Optional. Only include resources that match the filter in the response. For
   * more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   */
  filter: string;
  /**
   * Optional. Specify how the results should be sorted. If not specified, the
   * results will be sorted in the default order. For more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   */
  orderBy: string;
}

/**
 * Response message for
 * [KeyManagementService.ListKeyRings][google.cloud.kms.v1.KeyManagementService.ListKeyRings].
 */
export interface ListKeyRingsResponse {
  /** The list of [KeyRings][google.cloud.kms.v1.KeyRing]. */
  keyRings: KeyRing[];
  /**
   * A token to retrieve next page of results. Pass this value in
   * [ListKeyRingsRequest.page_token][google.cloud.kms.v1.ListKeyRingsRequest.page_token]
   * to retrieve the next page of results.
   */
  nextPageToken: string;
  /**
   * The total number of [KeyRings][google.cloud.kms.v1.KeyRing] that matched
   * the query.
   */
  totalSize: number;
}

/**
 * Response message for
 * [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
 */
export interface ListCryptoKeysResponse {
  /** The list of [CryptoKeys][google.cloud.kms.v1.CryptoKey]. */
  cryptoKeys: CryptoKey[];
  /**
   * A token to retrieve next page of results. Pass this value in
   * [ListCryptoKeysRequest.page_token][google.cloud.kms.v1.ListCryptoKeysRequest.page_token]
   * to retrieve the next page of results.
   */
  nextPageToken: string;
  /**
   * The total number of [CryptoKeys][google.cloud.kms.v1.CryptoKey] that
   * matched the query.
   */
  totalSize: number;
}

/**
 * Response message for
 * [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions].
 */
export interface ListCryptoKeyVersionsResponse {
  /** The list of [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]. */
  cryptoKeyVersions: CryptoKeyVersion[];
  /**
   * A token to retrieve next page of results. Pass this value in
   * [ListCryptoKeyVersionsRequest.page_token][google.cloud.kms.v1.ListCryptoKeyVersionsRequest.page_token]
   * to retrieve the next page of results.
   */
  nextPageToken: string;
  /**
   * The total number of
   * [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] that matched the
   * query.
   */
  totalSize: number;
}

/**
 * Response message for
 * [KeyManagementService.ListImportJobs][google.cloud.kms.v1.KeyManagementService.ListImportJobs].
 */
export interface ListImportJobsResponse {
  /** The list of [ImportJobs][google.cloud.kms.v1.ImportJob]. */
  importJobs: ImportJob[];
  /**
   * A token to retrieve next page of results. Pass this value in
   * [ListImportJobsRequest.page_token][google.cloud.kms.v1.ListImportJobsRequest.page_token]
   * to retrieve the next page of results.
   */
  nextPageToken: string;
  /**
   * The total number of [ImportJobs][google.cloud.kms.v1.ImportJob] that
   * matched the query.
   */
  totalSize: number;
}

/**
 * Request message for
 * [KeyManagementService.GetKeyRing][google.cloud.kms.v1.KeyManagementService.GetKeyRing].
 */
export interface GetKeyRingRequest {
  /**
   * Required. The [name][google.cloud.kms.v1.KeyRing.name] of the
   * [KeyRing][google.cloud.kms.v1.KeyRing] to get.
   */
  name: string;
}

/**
 * Request message for
 * [KeyManagementService.GetCryptoKey][google.cloud.kms.v1.KeyManagementService.GetCryptoKey].
 */
export interface GetCryptoKeyRequest {
  /**
   * Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] to get.
   */
  name: string;
}

/**
 * Request message for
 * [KeyManagementService.GetCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.GetCryptoKeyVersion].
 */
export interface GetCryptoKeyVersionRequest {
  /**
   * Required. The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to get.
   */
  name: string;
}

/**
 * Request message for
 * [KeyManagementService.GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
 */
export interface GetPublicKeyRequest {
  /**
   * Required. The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] public key to get.
   */
  name: string;
}

/**
 * Request message for
 * [KeyManagementService.GetImportJob][google.cloud.kms.v1.KeyManagementService.GetImportJob].
 */
export interface GetImportJobRequest {
  /**
   * Required. The [name][google.cloud.kms.v1.ImportJob.name] of the
   * [ImportJob][google.cloud.kms.v1.ImportJob] to get.
   */
  name: string;
}

/**
 * Request message for
 * [KeyManagementService.CreateKeyRing][google.cloud.kms.v1.KeyManagementService.CreateKeyRing].
 */
export interface CreateKeyRingRequest {
  /**
   * Required. The resource name of the location associated with the
   * [KeyRings][google.cloud.kms.v1.KeyRing], in the format
   * `projects/* /locations/*`.
   */
  parent: string;
  /**
   * Required. It must be unique within a location and match the regular
   * expression `[a-zA-Z0-9_-]{1,63}`
   */
  keyRingId: string;
  /**
   * Required. A [KeyRing][google.cloud.kms.v1.KeyRing] with initial field
   * values.
   */
  keyRing: KeyRing | undefined;
}

/**
 * Request message for
 * [KeyManagementService.CreateCryptoKey][google.cloud.kms.v1.KeyManagementService.CreateCryptoKey].
 */
export interface CreateCryptoKeyRequest {
  /**
   * Required. The [name][google.cloud.kms.v1.KeyRing.name] of the KeyRing
   * associated with the [CryptoKeys][google.cloud.kms.v1.CryptoKey].
   */
  parent: string;
  /**
   * Required. It must be unique within a KeyRing and match the regular
   * expression `[a-zA-Z0-9_-]{1,63}`
   */
  cryptoKeyId: string;
  /**
   * Required. A [CryptoKey][google.cloud.kms.v1.CryptoKey] with initial field
   * values.
   */
  cryptoKey:
    | CryptoKey
    | undefined;
  /**
   * If set to true, the request will create a
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] without any
   * [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]. You must
   * manually call
   * [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
   * or
   * [ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]
   * before you can use this [CryptoKey][google.cloud.kms.v1.CryptoKey].
   */
  skipInitialVersionCreation: boolean;
}

/**
 * Request message for
 * [KeyManagementService.CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion].
 */
export interface CreateCryptoKeyVersionRequest {
  /**
   * Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] associated with the
   * [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion].
   */
  parent: string;
  /**
   * Required. A [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
   * initial field values.
   */
  cryptoKeyVersion: CryptoKeyVersion | undefined;
}

/**
 * Request message for
 * [KeyManagementService.ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion].
 */
export interface ImportCryptoKeyVersionRequest {
  /**
   * Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] to be imported into.
   *
   * The create permission is only required on this key when creating a new
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   */
  parent: string;
  /**
   * Optional. The optional [name][google.cloud.kms.v1.CryptoKeyVersion.name] of
   * an existing [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to
   * target for an import operation. If this field is not present, a new
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] containing the
   * supplied key material is created.
   *
   * If this field is present, the supplied key material is imported into
   * the existing [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. To
   * import into an existing
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] must be a child of
   * [ImportCryptoKeyVersionRequest.parent][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.parent],
   * have been previously created via [ImportCryptoKeyVersion][], and be in
   * [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED]
   * or
   * [IMPORT_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.IMPORT_FAILED]
   * state. The key material and algorithm must match the previous
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] exactly if the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] has ever contained
   * key material.
   */
  cryptoKeyVersion: string;
  /**
   * Required. The
   * [algorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
   * of the key being imported. This does not need to match the
   * [version_template][google.cloud.kms.v1.CryptoKey.version_template] of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] this version imports into.
   */
  algorithm: CryptoKeyVersion_CryptoKeyVersionAlgorithm;
  /**
   * Required. The [name][google.cloud.kms.v1.ImportJob.name] of the
   * [ImportJob][google.cloud.kms.v1.ImportJob] that was used to wrap this key
   * material.
   */
  importJob: string;
  /**
   * Optional. The wrapped key material to import.
   *
   * Before wrapping, key material must be formatted. If importing symmetric key
   * material, the expected key material format is plain bytes. If importing
   * asymmetric key material, the expected key material format is PKCS#8-encoded
   * DER (the PrivateKeyInfo structure from RFC 5208).
   *
   * When wrapping with import methods
   * ([RSA_OAEP_3072_SHA1_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA1_AES_256]
   * or
   * [RSA_OAEP_4096_SHA1_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA1_AES_256]
   * or
   * [RSA_OAEP_3072_SHA256_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA256_AES_256]
   * or
   * [RSA_OAEP_4096_SHA256_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA256_AES_256]),
   *
   * this field must contain the concatenation of:
   * <ol>
   *   <li>An ephemeral AES-256 wrapping key wrapped with the
   *       [public_key][google.cloud.kms.v1.ImportJob.public_key] using
   *       RSAES-OAEP with SHA-1/SHA-256, MGF1 with SHA-1/SHA-256, and an empty
   *       label.
   *   </li>
   *   <li>The formatted key to be imported, wrapped with the ephemeral AES-256
   *       key using AES-KWP (RFC 5649).
   *   </li>
   * </ol>
   *
   * This format is the same as the format produced by PKCS#11 mechanism
   * CKM_RSA_AES_KEY_WRAP.
   *
   * When wrapping with import methods
   * ([RSA_OAEP_3072_SHA256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA256]
   * or
   * [RSA_OAEP_4096_SHA256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA256]),
   *
   * this field must contain the formatted key to be imported, wrapped with the
   * [public_key][google.cloud.kms.v1.ImportJob.public_key] using RSAES-OAEP
   * with SHA-256, MGF1 with SHA-256, and an empty label.
   */
  wrappedKey: Buffer;
  /**
   * Optional. This field has the same meaning as
   * [wrapped_key][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.wrapped_key].
   * Prefer to use that field in new work. Either that field or this field
   * (but not both) must be specified.
   */
  rsaAesWrappedKey?: Buffer | undefined;
}

/**
 * Request message for
 * [KeyManagementService.CreateImportJob][google.cloud.kms.v1.KeyManagementService.CreateImportJob].
 */
export interface CreateImportJobRequest {
  /**
   * Required. The [name][google.cloud.kms.v1.KeyRing.name] of the
   * [KeyRing][google.cloud.kms.v1.KeyRing] associated with the
   * [ImportJobs][google.cloud.kms.v1.ImportJob].
   */
  parent: string;
  /**
   * Required. It must be unique within a KeyRing and match the regular
   * expression `[a-zA-Z0-9_-]{1,63}`
   */
  importJobId: string;
  /**
   * Required. An [ImportJob][google.cloud.kms.v1.ImportJob] with initial field
   * values.
   */
  importJob: ImportJob | undefined;
}

/**
 * Request message for
 * [KeyManagementService.UpdateCryptoKey][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKey].
 */
export interface UpdateCryptoKeyRequest {
  /** Required. [CryptoKey][google.cloud.kms.v1.CryptoKey] with updated values. */
  cryptoKey:
    | CryptoKey
    | undefined;
  /** Required. List of fields to be updated in this request. */
  updateMask: string[] | undefined;
}

/**
 * Request message for
 * [KeyManagementService.UpdateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyVersion].
 */
export interface UpdateCryptoKeyVersionRequest {
  /**
   * Required. [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
   * updated values.
   */
  cryptoKeyVersion:
    | CryptoKeyVersion
    | undefined;
  /** Required. List of fields to be updated in this request. */
  updateMask: string[] | undefined;
}

/**
 * Request message for
 * [KeyManagementService.UpdateCryptoKeyPrimaryVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion].
 */
export interface UpdateCryptoKeyPrimaryVersionRequest {
  /**
   * Required. The resource name of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] to update.
   */
  name: string;
  /**
   * Required. The id of the child
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use as primary.
   */
  cryptoKeyVersionId: string;
}

/**
 * Request message for
 * [KeyManagementService.DestroyCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion].
 */
export interface DestroyCryptoKeyVersionRequest {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to destroy.
   */
  name: string;
}

/**
 * Request message for
 * [KeyManagementService.RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion].
 */
export interface RestoreCryptoKeyVersionRequest {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to restore.
   */
  name: string;
}

/**
 * Request message for
 * [KeyManagementService.Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
 */
export interface EncryptRequest {
  /**
   * Required. The resource name of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] or
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * encryption.
   *
   * If a [CryptoKey][google.cloud.kms.v1.CryptoKey] is specified, the server
   * will use its [primary version][google.cloud.kms.v1.CryptoKey.primary].
   */
  name: string;
  /**
   * Required. The data to encrypt. Must be no larger than 64KiB.
   *
   * The maximum size depends on the key version's
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
   * For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE],
   * [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL], and
   * [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC] keys, the
   * plaintext must be no larger than 64KiB. For
   * [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
   * the plaintext and additional_authenticated_data fields must be no larger
   * than 8KiB.
   */
  plaintext: Buffer;
  /**
   * Optional. Optional data that, if specified, must also be provided during
   * decryption through
   * [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data].
   *
   * The maximum size depends on the key version's
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
   * For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE],
   * [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL], and
   * [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC] keys the
   * AAD must be no larger than 64KiB. For
   * [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
   * the plaintext and additional_authenticated_data fields must be no larger
   * than 8KiB.
   */
  additionalAuthenticatedData: Buffer;
  /**
   * Optional. An optional CRC32C checksum of the
   * [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext])
   * is equal to
   * [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   */
  plaintextCrc32c:
    | Long
    | undefined;
  /**
   * Optional. An optional CRC32C checksum of the
   * [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data])
   * is equal to
   * [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   */
  additionalAuthenticatedDataCrc32c: Long | undefined;
}

/**
 * Request message for
 * [KeyManagementService.Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
 */
export interface DecryptRequest {
  /**
   * Required. The resource name of the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] to use for decryption. The
   * server will choose the appropriate version.
   */
  name: string;
  /**
   * Required. The encrypted data originally returned in
   * [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext].
   */
  ciphertext: Buffer;
  /**
   * Optional. Optional data that must match the data originally supplied in
   * [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data].
   */
  additionalAuthenticatedData: Buffer;
  /**
   * Optional. An optional CRC32C checksum of the
   * [DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext])
   * is equal to
   * [DecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.DecryptRequest.ciphertext_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   */
  ciphertextCrc32c:
    | Long
    | undefined;
  /**
   * Optional. An optional CRC32C checksum of the
   * [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data])
   * is equal to
   * [DecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   */
  additionalAuthenticatedDataCrc32c: Long | undefined;
}

/**
 * Request message for
 * [KeyManagementService.RawEncrypt][google.cloud.kms.v1.KeyManagementService.RawEncrypt].
 */
export interface RawEncryptRequest {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * encryption.
   */
  name: string;
  /**
   * Required. The data to encrypt. Must be no larger than 64KiB.
   *
   * The maximum size depends on the key version's
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
   * For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE] keys, the
   * plaintext must be no larger than 64KiB. For
   * [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
   * the plaintext and additional_authenticated_data fields must be no larger
   * than 8KiB.
   */
  plaintext: Buffer;
  /**
   * Optional. Optional data that, if specified, must also be provided during
   * decryption through
   * [RawDecryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data].
   *
   * This field may only be used in conjunction with an
   * [algorithm][google.cloud.kms.v1.CryptoKeyVersion.algorithm] that accepts
   * additional authenticated data (for example, AES-GCM).
   *
   * The maximum size depends on the key version's
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level].
   * For [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE] keys, the
   * plaintext must be no larger than 64KiB. For
   * [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of
   * the plaintext and additional_authenticated_data fields must be no larger
   * than 8KiB.
   */
  additionalAuthenticatedData: Buffer;
  /**
   * Optional. An optional CRC32C checksum of the
   * [RawEncryptRequest.plaintext][google.cloud.kms.v1.RawEncryptRequest.plaintext].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received plaintext using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that CRC32C(plaintext) is equal
   * to plaintext_crc32c, and if so, perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   */
  plaintextCrc32c:
    | Long
    | undefined;
  /**
   * Optional. An optional CRC32C checksum of the
   * [RawEncryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received additional_authenticated_data using
   * this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C(additional_authenticated_data) is equal to
   * additional_authenticated_data_crc32c, and if so, perform
   * a limited number of retries. A persistent mismatch may indicate an issue in
   * your computation of the CRC32C checksum.
   * Note: This field is defined as int64 for reasons of compatibility across
   * different languages. However, it is a non-negative integer, which will
   * never exceed 2^32-1, and can be safely downconverted to uint32 in languages
   * that support this type.
   */
  additionalAuthenticatedDataCrc32c:
    | Long
    | undefined;
  /**
   * Optional. A customer-supplied initialization vector that will be used for
   * encryption. If it is not provided for AES-CBC and AES-CTR, one will be
   * generated. It will be returned in
   * [RawEncryptResponse.initialization_vector][google.cloud.kms.v1.RawEncryptResponse.initialization_vector].
   */
  initializationVector: Buffer;
  /**
   * Optional. An optional CRC32C checksum of the
   * [RawEncryptRequest.initialization_vector][google.cloud.kms.v1.RawEncryptRequest.initialization_vector].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received initialization_vector using this
   * checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C(initialization_vector) is equal to
   * initialization_vector_crc32c, and if so, perform
   * a limited number of retries. A persistent mismatch may indicate an issue in
   * your computation of the CRC32C checksum.
   * Note: This field is defined as int64 for reasons of compatibility across
   * different languages. However, it is a non-negative integer, which will
   * never exceed 2^32-1, and can be safely downconverted to uint32 in languages
   * that support this type.
   */
  initializationVectorCrc32c: Long | undefined;
}

/**
 * Request message for
 * [KeyManagementService.RawDecrypt][google.cloud.kms.v1.KeyManagementService.RawDecrypt].
 */
export interface RawDecryptRequest {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * decryption.
   */
  name: string;
  /**
   * Required. The encrypted data originally returned in
   * [RawEncryptResponse.ciphertext][google.cloud.kms.v1.RawEncryptResponse.ciphertext].
   */
  ciphertext: Buffer;
  /**
   * Optional. Optional data that must match the data originally supplied in
   * [RawEncryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data].
   */
  additionalAuthenticatedData: Buffer;
  /**
   * Required. The initialization vector (IV) used during encryption, which must
   * match the data originally provided in
   * [RawEncryptResponse.initialization_vector][google.cloud.kms.v1.RawEncryptResponse.initialization_vector].
   */
  initializationVector: Buffer;
  /**
   * The length of the authentication tag that is appended to the end of
   * the ciphertext. If unspecified (0), the default value for the key's
   * algorithm will be used (for AES-GCM, the default value is 16).
   */
  tagLength: number;
  /**
   * Optional. An optional CRC32C checksum of the
   * [RawDecryptRequest.ciphertext][google.cloud.kms.v1.RawDecryptRequest.ciphertext].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received ciphertext using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that CRC32C(ciphertext) is equal
   * to ciphertext_crc32c, and if so, perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   */
  ciphertextCrc32c:
    | Long
    | undefined;
  /**
   * Optional. An optional CRC32C checksum of the
   * [RawDecryptRequest.additional_authenticated_data][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received additional_authenticated_data using
   * this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C(additional_authenticated_data) is equal to
   * additional_authenticated_data_crc32c, and if so, perform
   * a limited number of retries. A persistent mismatch may indicate an issue in
   * your computation of the CRC32C checksum.
   * Note: This field is defined as int64 for reasons of compatibility across
   * different languages. However, it is a non-negative integer, which will
   * never exceed 2^32-1, and can be safely downconverted to uint32 in languages
   * that support this type.
   */
  additionalAuthenticatedDataCrc32c:
    | Long
    | undefined;
  /**
   * Optional. An optional CRC32C checksum of the
   * [RawDecryptRequest.initialization_vector][google.cloud.kms.v1.RawDecryptRequest.initialization_vector].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received initialization_vector using this
   * checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C(initialization_vector) is equal to initialization_vector_crc32c, and
   * if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum.
   * Note: This field is defined as int64 for reasons of compatibility across
   * different languages. However, it is a non-negative integer, which will
   * never exceed 2^32-1, and can be safely downconverted to uint32 in languages
   * that support this type.
   */
  initializationVectorCrc32c: Long | undefined;
}

/**
 * Request message for
 * [KeyManagementService.AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign].
 */
export interface AsymmetricSignRequest {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * signing.
   */
  name: string;
  /**
   * Optional. The digest of the data to sign. The digest must be produced with
   * the same digest algorithm as specified by the key version's
   * [algorithm][google.cloud.kms.v1.CryptoKeyVersion.algorithm].
   *
   * This field may not be supplied if
   * [AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data]
   * is supplied.
   */
  digest:
    | Digest
    | undefined;
  /**
   * Optional. An optional CRC32C checksum of the
   * [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest])
   * is equal to
   * [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   */
  digestCrc32c:
    | Long
    | undefined;
  /**
   * Optional. The data to sign.
   * It can't be supplied if
   * [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]
   * is supplied.
   */
  data: Buffer;
  /**
   * Optional. An optional CRC32C checksum of the
   * [AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([AsymmetricSignRequest.data][google.cloud.kms.v1.AsymmetricSignRequest.data])
   * is equal to
   * [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   */
  dataCrc32c: Long | undefined;
}

/**
 * Request message for
 * [KeyManagementService.AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt].
 */
export interface AsymmetricDecryptRequest {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * decryption.
   */
  name: string;
  /**
   * Required. The data encrypted with the named
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s public key using
   * OAEP.
   */
  ciphertext: Buffer;
  /**
   * Optional. An optional CRC32C checksum of the
   * [AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext].
   * If specified,
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * verify the integrity of the received
   * [AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]
   * using this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext])
   * is equal to
   * [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   */
  ciphertextCrc32c: Long | undefined;
}

/**
 * Request message for
 * [KeyManagementService.MacSign][google.cloud.kms.v1.KeyManagementService.MacSign].
 */
export interface MacSignRequest {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * signing.
   */
  name: string;
  /**
   * Required. The data to sign. The MAC tag is computed over this data field
   * based on the specific algorithm.
   */
  data: Buffer;
  /**
   * Optional. An optional CRC32C checksum of the
   * [MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data]. If
   * specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will verify the integrity of the received
   * [MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data] using this
   * checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data]) is
   * equal to
   * [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   */
  dataCrc32c: Long | undefined;
}

/**
 * Request message for
 * [KeyManagementService.MacVerify][google.cloud.kms.v1.KeyManagementService.MacVerify].
 */
export interface MacVerifyRequest {
  /**
   * Required. The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
   * verification.
   */
  name: string;
  /**
   * Required. The data used previously as a
   * [MacSignRequest.data][google.cloud.kms.v1.MacSignRequest.data] to generate
   * the MAC tag.
   */
  data: Buffer;
  /**
   * Optional. An optional CRC32C checksum of the
   * [MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data]. If
   * specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will verify the integrity of the received
   * [MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data] using
   * this checksum.
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will
   * report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data])
   * is equal to
   * [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   */
  dataCrc32c:
    | Long
    | undefined;
  /** Required. The signature to verify. */
  mac: Buffer;
  /**
   * Optional. An optional CRC32C checksum of the
   * [MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac]. If
   * specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will verify the integrity of the received
   * [MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac] using this
   * checksum. [KeyManagementService][google.cloud.kms.v1.KeyManagementService]
   * will report an error if the checksum verification fails. If you receive a
   * checksum error, your client should verify that
   * CRC32C([MacVerifyRequest.tag][]) is equal to
   * [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c],
   * and if so, perform a limited number of retries. A persistent mismatch may
   * indicate an issue in your computation of the CRC32C checksum. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   */
  macCrc32c: Long | undefined;
}

/**
 * Request message for
 * [KeyManagementService.GenerateRandomBytes][google.cloud.kms.v1.KeyManagementService.GenerateRandomBytes].
 */
export interface GenerateRandomBytesRequest {
  /**
   * The project-specific location in which to generate random bytes.
   * For example, "projects/my-project/locations/us-central1".
   */
  location: string;
  /**
   * The length in bytes of the amount of randomness to retrieve.  Minimum 8
   * bytes, maximum 1024 bytes.
   */
  lengthBytes: number;
  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] to use when
   * generating the random data. Currently, only
   * [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] protection level is
   * supported.
   */
  protectionLevel: ProtectionLevel;
}

/**
 * Response message for
 * [KeyManagementService.Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
 */
export interface EncryptResponse {
  /**
   * The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * encryption. Check this field to verify that the intended resource was used
   * for encryption.
   */
  name: string;
  /** The encrypted data. */
  ciphertext: Buffer;
  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext].
   * An integrity check of
   * [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext]
   * can be performed by computing the CRC32C checksum of
   * [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext]
   * and comparing your results to this field. Discard the response in case of
   * non-matching checksum values, and perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   */
  ciphertextCrc32c:
    | Long
    | undefined;
  /**
   * Integrity verification field. A flag indicating whether
   * [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [plaintext][google.cloud.kms.v1.EncryptRequest.plaintext]. A false value of
   * this field indicates either that
   * [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedPlaintextCrc32c: boolean;
  /**
   * Integrity verification field. A flag indicating whether
   * [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [AAD][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]. A
   * false value of this field indicates either that
   * [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedAdditionalAuthenticatedDataCrc32c: boolean;
  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * encryption.
   */
  protectionLevel: ProtectionLevel;
}

/**
 * Response message for
 * [KeyManagementService.Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
 */
export interface DecryptResponse {
  /**
   * The decrypted data originally supplied in
   * [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext].
   */
  plaintext: Buffer;
  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext].
   * An integrity check of
   * [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext]
   * can be performed by computing the CRC32C checksum of
   * [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext]
   * and comparing your results to this field. Discard the response in case of
   * non-matching checksum values, and perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: receiving this response message indicates that
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] is able to
   * successfully decrypt the
   * [ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext]. Note: This
   * field is defined as int64 for reasons of compatibility across different
   * languages. However, it is a non-negative integer, which will never exceed
   * 2^32-1, and can be safely downconverted to uint32 in languages that support
   * this type.
   */
  plaintextCrc32c:
    | Long
    | undefined;
  /** Whether the Decryption was performed using the primary key version. */
  usedPrimary: boolean;
  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * decryption.
   */
  protectionLevel: ProtectionLevel;
}

/**
 * Response message for
 * [KeyManagementService.RawEncrypt][google.cloud.kms.v1.KeyManagementService.RawEncrypt].
 */
export interface RawEncryptResponse {
  /**
   * The encrypted data. In the case of AES-GCM, the authentication tag
   * is the [tag_length][google.cloud.kms.v1.RawEncryptResponse.tag_length]
   * bytes at the end of this field.
   */
  ciphertext: Buffer;
  /**
   * The initialization vector (IV) generated by the service during
   * encryption. This value must be stored and provided in
   * [RawDecryptRequest.initialization_vector][google.cloud.kms.v1.RawDecryptRequest.initialization_vector]
   * at decryption time.
   */
  initializationVector: Buffer;
  /**
   * The length of the authentication tag that is appended to
   * the end of the ciphertext.
   */
  tagLength: number;
  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [RawEncryptResponse.ciphertext][google.cloud.kms.v1.RawEncryptResponse.ciphertext].
   * An integrity check of ciphertext can be performed by computing the CRC32C
   * checksum of ciphertext and comparing your results to this field. Discard
   * the response in case of non-matching checksum values, and perform a limited
   * number of retries. A persistent mismatch may indicate an issue in your
   * computation of the CRC32C checksum. Note: This field is defined as int64
   * for reasons of compatibility across different languages. However, it is a
   * non-negative integer, which will never exceed 2^32-1, and can be safely
   * downconverted to uint32 in languages that support this type.
   */
  ciphertextCrc32c:
    | Long
    | undefined;
  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [RawEncryptResponse.initialization_vector][google.cloud.kms.v1.RawEncryptResponse.initialization_vector].
   * An integrity check of initialization_vector can be performed by computing
   * the CRC32C checksum of initialization_vector and comparing your results to
   * this field. Discard the response in case of non-matching checksum values,
   * and perform a limited number of retries. A persistent mismatch may indicate
   * an issue in your computation of the CRC32C checksum. Note: This field is
   * defined as int64 for reasons of compatibility across different languages.
   * However, it is a non-negative integer, which will never exceed 2^32-1, and
   * can be safely downconverted to uint32 in languages that support this type.
   */
  initializationVectorCrc32c:
    | Long
    | undefined;
  /**
   * Integrity verification field. A flag indicating whether
   * [RawEncryptRequest.plaintext_crc32c][google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the plaintext. A false value of this
   * field indicates either that
   * [RawEncryptRequest.plaintext_crc32c][google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [RawEncryptRequest.plaintext_crc32c][google.cloud.kms.v1.RawEncryptRequest.plaintext_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedPlaintextCrc32c: boolean;
  /**
   * Integrity verification field. A flag indicating whether
   * [RawEncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of additional_authenticated_data. A false
   * value of this field indicates either that //
   * [RawEncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [RawEncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawEncryptRequest.additional_authenticated_data_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedAdditionalAuthenticatedDataCrc32c: boolean;
  /**
   * Integrity verification field. A flag indicating whether
   * [RawEncryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of initialization_vector. A false value of
   * this field indicates either that
   * [RawEncryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [RawEncryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawEncryptRequest.initialization_vector_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedInitializationVectorCrc32c: boolean;
  /**
   * The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * encryption. Check this field to verify that the intended resource was used
   * for encryption.
   */
  name: string;
  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * encryption.
   */
  protectionLevel: ProtectionLevel;
}

/**
 * Response message for
 * [KeyManagementService.RawDecrypt][google.cloud.kms.v1.KeyManagementService.RawDecrypt].
 */
export interface RawDecryptResponse {
  /** The decrypted data. */
  plaintext: Buffer;
  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [RawDecryptResponse.plaintext][google.cloud.kms.v1.RawDecryptResponse.plaintext].
   * An integrity check of plaintext can be performed by computing the CRC32C
   * checksum of plaintext and comparing your results to this field. Discard the
   * response in case of non-matching checksum values, and perform a limited
   * number of retries. A persistent mismatch may indicate an issue in your
   * computation of the CRC32C checksum. Note: receiving this response message
   * indicates that
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] is able to
   * successfully decrypt the
   * [ciphertext][google.cloud.kms.v1.RawDecryptRequest.ciphertext].
   * Note: This field is defined as int64 for reasons of compatibility across
   * different languages. However, it is a non-negative integer, which will
   * never exceed 2^32-1, and can be safely downconverted to uint32 in languages
   * that support this type.
   */
  plaintextCrc32c:
    | Long
    | undefined;
  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * decryption.
   */
  protectionLevel: ProtectionLevel;
  /**
   * Integrity verification field. A flag indicating whether
   * [RawDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the ciphertext. A false value of this
   * field indicates either that
   * [RawDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [RawDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.RawDecryptRequest.ciphertext_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedCiphertextCrc32c: boolean;
  /**
   * Integrity verification field. A flag indicating whether
   * [RawDecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of additional_authenticated_data. A false
   * value of this field indicates either that //
   * [RawDecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [RawDecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.RawDecryptRequest.additional_authenticated_data_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedAdditionalAuthenticatedDataCrc32c: boolean;
  /**
   * Integrity verification field. A flag indicating whether
   * [RawDecryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of initialization_vector. A false value of
   * this field indicates either that
   * [RawDecryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [RawDecryptRequest.initialization_vector_crc32c][google.cloud.kms.v1.RawDecryptRequest.initialization_vector_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedInitializationVectorCrc32c: boolean;
}

/**
 * Response message for
 * [KeyManagementService.AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign].
 */
export interface AsymmetricSignResponse {
  /** The created signature. */
  signature: Buffer;
  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature].
   * An integrity check of
   * [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature]
   * can be performed by computing the CRC32C checksum of
   * [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature]
   * and comparing your results to this field. Discard the response in case of
   * non-matching checksum values, and perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   */
  signatureCrc32c:
    | Long
    | undefined;
  /**
   * Integrity verification field. A flag indicating whether
   * [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]. A false value
   * of this field indicates either that
   * [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedDigestCrc32c: boolean;
  /**
   * The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
   * Check this field to verify that the intended resource was used for signing.
   */
  name: string;
  /**
   * Integrity verification field. A flag indicating whether
   * [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [data][google.cloud.kms.v1.AsymmetricSignRequest.data]. A false value of
   * this field indicates either that
   * [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [AsymmetricSignRequest.data_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.data_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedDataCrc32c: boolean;
  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
   */
  protectionLevel: ProtectionLevel;
}

/**
 * Response message for
 * [KeyManagementService.AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt].
 */
export interface AsymmetricDecryptResponse {
  /** The decrypted data originally encrypted with the matching public key. */
  plaintext: Buffer;
  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext].
   * An integrity check of
   * [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext]
   * can be performed by computing the CRC32C checksum of
   * [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext]
   * and comparing your results to this field. Discard the response in case of
   * non-matching checksum values, and perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   */
  plaintextCrc32c:
    | Long
    | undefined;
  /**
   * Integrity verification field. A flag indicating whether
   * [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]. A
   * false value of this field indicates either that
   * [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedCiphertextCrc32c: boolean;
  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in
   * decryption.
   */
  protectionLevel: ProtectionLevel;
}

/**
 * Response message for
 * [KeyManagementService.MacSign][google.cloud.kms.v1.KeyManagementService.MacSign].
 */
export interface MacSignResponse {
  /**
   * The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
   * Check this field to verify that the intended resource was used for signing.
   */
  name: string;
  /** The created signature. */
  mac: Buffer;
  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [MacSignResponse.mac][google.cloud.kms.v1.MacSignResponse.mac]. An
   * integrity check of
   * [MacSignResponse.mac][google.cloud.kms.v1.MacSignResponse.mac] can be
   * performed by computing the CRC32C checksum of
   * [MacSignResponse.mac][google.cloud.kms.v1.MacSignResponse.mac] and
   * comparing your results to this field. Discard the response in case of
   * non-matching checksum values, and perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   */
  macCrc32c:
    | Long
    | undefined;
  /**
   * Integrity verification field. A flag indicating whether
   * [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [data][google.cloud.kms.v1.MacSignRequest.data]. A false value of this
   * field indicates either that
   * [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [MacSignRequest.data_crc32c][google.cloud.kms.v1.MacSignRequest.data_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedDataCrc32c: boolean;
  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing.
   */
  protectionLevel: ProtectionLevel;
}

/**
 * Response message for
 * [KeyManagementService.MacVerify][google.cloud.kms.v1.KeyManagementService.MacVerify].
 */
export interface MacVerifyResponse {
  /**
   * The resource name of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for
   * verification. Check this field to verify that the intended resource was
   * used for verification.
   */
  name: string;
  /**
   * This field indicates whether or not the verification operation for
   * [MacVerifyRequest.mac][google.cloud.kms.v1.MacVerifyRequest.mac] over
   * [MacVerifyRequest.data][google.cloud.kms.v1.MacVerifyRequest.data] was
   * successful.
   */
  success: boolean;
  /**
   * Integrity verification field. A flag indicating whether
   * [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [data][google.cloud.kms.v1.MacVerifyRequest.data]. A false value of this
   * field indicates either that
   * [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [MacVerifyRequest.data_crc32c][google.cloud.kms.v1.MacVerifyRequest.data_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedDataCrc32c: boolean;
  /**
   * Integrity verification field. A flag indicating whether
   * [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]
   * was received by
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used
   * for the integrity verification of the
   * [data][google.cloud.kms.v1.MacVerifyRequest.mac]. A false value of this
   * field indicates either that
   * [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]
   * was left unset or that it was not delivered to
   * [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
   * set
   * [MacVerifyRequest.mac_crc32c][google.cloud.kms.v1.MacVerifyRequest.mac_crc32c]
   * but this field is still false, discard the response and perform a limited
   * number of retries.
   */
  verifiedMacCrc32c: boolean;
  /**
   * Integrity verification field. This value is used for the integrity
   * verification of [MacVerifyResponse.success]. If the value of this field
   * contradicts the value of [MacVerifyResponse.success], discard the response
   * and perform a limited number of retries.
   */
  verifiedSuccessIntegrity: boolean;
  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for
   * verification.
   */
  protectionLevel: ProtectionLevel;
}

/**
 * Response message for
 * [KeyManagementService.GenerateRandomBytes][google.cloud.kms.v1.KeyManagementService.GenerateRandomBytes].
 */
export interface GenerateRandomBytesResponse {
  /** The generated data. */
  data: Buffer;
  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [GenerateRandomBytesResponse.data][google.cloud.kms.v1.GenerateRandomBytesResponse.data].
   * An integrity check of
   * [GenerateRandomBytesResponse.data][google.cloud.kms.v1.GenerateRandomBytesResponse.data]
   * can be performed by computing the CRC32C checksum of
   * [GenerateRandomBytesResponse.data][google.cloud.kms.v1.GenerateRandomBytesResponse.data]
   * and comparing your results to this field. Discard the response in case of
   * non-matching checksum values, and perform a limited number of retries. A
   * persistent mismatch may indicate an issue in your computation of the CRC32C
   * checksum. Note: This field is defined as int64 for reasons of compatibility
   * across different languages. However, it is a non-negative integer, which
   * will never exceed 2^32-1, and can be safely downconverted to uint32 in
   * languages that support this type.
   */
  dataCrc32c: Long | undefined;
}

/** A [Digest][google.cloud.kms.v1.Digest] holds a cryptographic message digest. */
export interface Digest {
  /** A message digest produced with the SHA-256 algorithm. */
  sha256?:
    | Buffer
    | undefined;
  /** A message digest produced with the SHA-384 algorithm. */
  sha384?:
    | Buffer
    | undefined;
  /** A message digest produced with the SHA-512 algorithm. */
  sha512?: Buffer | undefined;
}

/**
 * Cloud KMS metadata for the given
 * [google.cloud.location.Location][google.cloud.location.Location].
 */
export interface LocationMetadata {
  /**
   * Indicates whether [CryptoKeys][google.cloud.kms.v1.CryptoKey] with
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]
   * [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] can be created in this
   * location.
   */
  hsmAvailable: boolean;
  /**
   * Indicates whether [CryptoKeys][google.cloud.kms.v1.CryptoKey] with
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]
   * [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL] can be created in
   * this location.
   */
  ekmAvailable: boolean;
}

function createBaseListKeyRingsRequest(): ListKeyRingsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListKeyRingsRequest: MessageFns<ListKeyRingsRequest> = {
  encode(message: ListKeyRingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeyRingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeyRingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKeyRingsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListKeyRingsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListKeyRingsRequest>): ListKeyRingsRequest {
    return ListKeyRingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListKeyRingsRequest>): ListKeyRingsRequest {
    const message = createBaseListKeyRingsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListCryptoKeysRequest(): ListCryptoKeysRequest {
  return { parent: "", pageSize: 0, pageToken: "", versionView: 0, filter: "", orderBy: "" };
}

export const ListCryptoKeysRequest: MessageFns<ListCryptoKeysRequest> = {
  encode(message: ListCryptoKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.versionView !== 0) {
      writer.uint32(32).int32(message.versionView);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(50).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCryptoKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCryptoKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.versionView = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCryptoKeysRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      versionView: isSet(object.versionView) ? cryptoKeyVersion_CryptoKeyVersionViewFromJSON(object.versionView) : 0,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListCryptoKeysRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.versionView !== 0) {
      obj.versionView = cryptoKeyVersion_CryptoKeyVersionViewToJSON(message.versionView);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCryptoKeysRequest>): ListCryptoKeysRequest {
    return ListCryptoKeysRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCryptoKeysRequest>): ListCryptoKeysRequest {
    const message = createBaseListCryptoKeysRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.versionView = object.versionView ?? 0;
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListCryptoKeyVersionsRequest(): ListCryptoKeyVersionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", view: 0, filter: "", orderBy: "" };
}

export const ListCryptoKeyVersionsRequest: MessageFns<ListCryptoKeyVersionsRequest> = {
  encode(message: ListCryptoKeyVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.view !== 0) {
      writer.uint32(32).int32(message.view);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(50).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCryptoKeyVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCryptoKeyVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCryptoKeyVersionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      view: isSet(object.view) ? cryptoKeyVersion_CryptoKeyVersionViewFromJSON(object.view) : 0,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListCryptoKeyVersionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.view !== 0) {
      obj.view = cryptoKeyVersion_CryptoKeyVersionViewToJSON(message.view);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCryptoKeyVersionsRequest>): ListCryptoKeyVersionsRequest {
    return ListCryptoKeyVersionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCryptoKeyVersionsRequest>): ListCryptoKeyVersionsRequest {
    const message = createBaseListCryptoKeyVersionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.view = object.view ?? 0;
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListImportJobsRequest(): ListImportJobsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListImportJobsRequest: MessageFns<ListImportJobsRequest> = {
  encode(message: ListImportJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListImportJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListImportJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListImportJobsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListImportJobsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListImportJobsRequest>): ListImportJobsRequest {
    return ListImportJobsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListImportJobsRequest>): ListImportJobsRequest {
    const message = createBaseListImportJobsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListKeyRingsResponse(): ListKeyRingsResponse {
  return { keyRings: [], nextPageToken: "", totalSize: 0 };
}

export const ListKeyRingsResponse: MessageFns<ListKeyRingsResponse> = {
  encode(message: ListKeyRingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keyRings) {
      KeyRing.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeyRingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeyRingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyRings.push(KeyRing.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKeyRingsResponse {
    return {
      keyRings: globalThis.Array.isArray(object?.keyRings) ? object.keyRings.map((e: any) => KeyRing.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListKeyRingsResponse): unknown {
    const obj: any = {};
    if (message.keyRings?.length) {
      obj.keyRings = message.keyRings.map((e) => KeyRing.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListKeyRingsResponse>): ListKeyRingsResponse {
    return ListKeyRingsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListKeyRingsResponse>): ListKeyRingsResponse {
    const message = createBaseListKeyRingsResponse();
    message.keyRings = object.keyRings?.map((e) => KeyRing.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseListCryptoKeysResponse(): ListCryptoKeysResponse {
  return { cryptoKeys: [], nextPageToken: "", totalSize: 0 };
}

export const ListCryptoKeysResponse: MessageFns<ListCryptoKeysResponse> = {
  encode(message: ListCryptoKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cryptoKeys) {
      CryptoKey.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCryptoKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCryptoKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cryptoKeys.push(CryptoKey.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCryptoKeysResponse {
    return {
      cryptoKeys: globalThis.Array.isArray(object?.cryptoKeys)
        ? object.cryptoKeys.map((e: any) => CryptoKey.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListCryptoKeysResponse): unknown {
    const obj: any = {};
    if (message.cryptoKeys?.length) {
      obj.cryptoKeys = message.cryptoKeys.map((e) => CryptoKey.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListCryptoKeysResponse>): ListCryptoKeysResponse {
    return ListCryptoKeysResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCryptoKeysResponse>): ListCryptoKeysResponse {
    const message = createBaseListCryptoKeysResponse();
    message.cryptoKeys = object.cryptoKeys?.map((e) => CryptoKey.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseListCryptoKeyVersionsResponse(): ListCryptoKeyVersionsResponse {
  return { cryptoKeyVersions: [], nextPageToken: "", totalSize: 0 };
}

export const ListCryptoKeyVersionsResponse: MessageFns<ListCryptoKeyVersionsResponse> = {
  encode(message: ListCryptoKeyVersionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cryptoKeyVersions) {
      CryptoKeyVersion.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCryptoKeyVersionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCryptoKeyVersionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cryptoKeyVersions.push(CryptoKeyVersion.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCryptoKeyVersionsResponse {
    return {
      cryptoKeyVersions: globalThis.Array.isArray(object?.cryptoKeyVersions)
        ? object.cryptoKeyVersions.map((e: any) => CryptoKeyVersion.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListCryptoKeyVersionsResponse): unknown {
    const obj: any = {};
    if (message.cryptoKeyVersions?.length) {
      obj.cryptoKeyVersions = message.cryptoKeyVersions.map((e) => CryptoKeyVersion.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListCryptoKeyVersionsResponse>): ListCryptoKeyVersionsResponse {
    return ListCryptoKeyVersionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCryptoKeyVersionsResponse>): ListCryptoKeyVersionsResponse {
    const message = createBaseListCryptoKeyVersionsResponse();
    message.cryptoKeyVersions = object.cryptoKeyVersions?.map((e) => CryptoKeyVersion.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseListImportJobsResponse(): ListImportJobsResponse {
  return { importJobs: [], nextPageToken: "", totalSize: 0 };
}

export const ListImportJobsResponse: MessageFns<ListImportJobsResponse> = {
  encode(message: ListImportJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.importJobs) {
      ImportJob.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListImportJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListImportJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.importJobs.push(ImportJob.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListImportJobsResponse {
    return {
      importJobs: globalThis.Array.isArray(object?.importJobs)
        ? object.importJobs.map((e: any) => ImportJob.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListImportJobsResponse): unknown {
    const obj: any = {};
    if (message.importJobs?.length) {
      obj.importJobs = message.importJobs.map((e) => ImportJob.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListImportJobsResponse>): ListImportJobsResponse {
    return ListImportJobsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListImportJobsResponse>): ListImportJobsResponse {
    const message = createBaseListImportJobsResponse();
    message.importJobs = object.importJobs?.map((e) => ImportJob.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseGetKeyRingRequest(): GetKeyRingRequest {
  return { name: "" };
}

export const GetKeyRingRequest: MessageFns<GetKeyRingRequest> = {
  encode(message: GetKeyRingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKeyRingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeyRingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeyRingRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetKeyRingRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetKeyRingRequest>): GetKeyRingRequest {
    return GetKeyRingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetKeyRingRequest>): GetKeyRingRequest {
    const message = createBaseGetKeyRingRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetCryptoKeyRequest(): GetCryptoKeyRequest {
  return { name: "" };
}

export const GetCryptoKeyRequest: MessageFns<GetCryptoKeyRequest> = {
  encode(message: GetCryptoKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCryptoKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCryptoKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCryptoKeyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCryptoKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCryptoKeyRequest>): GetCryptoKeyRequest {
    return GetCryptoKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCryptoKeyRequest>): GetCryptoKeyRequest {
    const message = createBaseGetCryptoKeyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetCryptoKeyVersionRequest(): GetCryptoKeyVersionRequest {
  return { name: "" };
}

export const GetCryptoKeyVersionRequest: MessageFns<GetCryptoKeyVersionRequest> = {
  encode(message: GetCryptoKeyVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCryptoKeyVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCryptoKeyVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCryptoKeyVersionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCryptoKeyVersionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCryptoKeyVersionRequest>): GetCryptoKeyVersionRequest {
    return GetCryptoKeyVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCryptoKeyVersionRequest>): GetCryptoKeyVersionRequest {
    const message = createBaseGetCryptoKeyVersionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetPublicKeyRequest(): GetPublicKeyRequest {
  return { name: "" };
}

export const GetPublicKeyRequest: MessageFns<GetPublicKeyRequest> = {
  encode(message: GetPublicKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPublicKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPublicKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPublicKeyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetPublicKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPublicKeyRequest>): GetPublicKeyRequest {
    return GetPublicKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPublicKeyRequest>): GetPublicKeyRequest {
    const message = createBaseGetPublicKeyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetImportJobRequest(): GetImportJobRequest {
  return { name: "" };
}

export const GetImportJobRequest: MessageFns<GetImportJobRequest> = {
  encode(message: GetImportJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetImportJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetImportJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetImportJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetImportJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetImportJobRequest>): GetImportJobRequest {
    return GetImportJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetImportJobRequest>): GetImportJobRequest {
    const message = createBaseGetImportJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateKeyRingRequest(): CreateKeyRingRequest {
  return { parent: "", keyRingId: "", keyRing: undefined };
}

export const CreateKeyRingRequest: MessageFns<CreateKeyRingRequest> = {
  encode(message: CreateKeyRingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.keyRingId !== "") {
      writer.uint32(18).string(message.keyRingId);
    }
    if (message.keyRing !== undefined) {
      KeyRing.encode(message.keyRing, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateKeyRingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateKeyRingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyRingId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keyRing = KeyRing.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateKeyRingRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      keyRingId: isSet(object.keyRingId) ? globalThis.String(object.keyRingId) : "",
      keyRing: isSet(object.keyRing) ? KeyRing.fromJSON(object.keyRing) : undefined,
    };
  },

  toJSON(message: CreateKeyRingRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.keyRingId !== "") {
      obj.keyRingId = message.keyRingId;
    }
    if (message.keyRing !== undefined) {
      obj.keyRing = KeyRing.toJSON(message.keyRing);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateKeyRingRequest>): CreateKeyRingRequest {
    return CreateKeyRingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateKeyRingRequest>): CreateKeyRingRequest {
    const message = createBaseCreateKeyRingRequest();
    message.parent = object.parent ?? "";
    message.keyRingId = object.keyRingId ?? "";
    message.keyRing = (object.keyRing !== undefined && object.keyRing !== null)
      ? KeyRing.fromPartial(object.keyRing)
      : undefined;
    return message;
  },
};

function createBaseCreateCryptoKeyRequest(): CreateCryptoKeyRequest {
  return { parent: "", cryptoKeyId: "", cryptoKey: undefined, skipInitialVersionCreation: false };
}

export const CreateCryptoKeyRequest: MessageFns<CreateCryptoKeyRequest> = {
  encode(message: CreateCryptoKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.cryptoKeyId !== "") {
      writer.uint32(18).string(message.cryptoKeyId);
    }
    if (message.cryptoKey !== undefined) {
      CryptoKey.encode(message.cryptoKey, writer.uint32(26).fork()).join();
    }
    if (message.skipInitialVersionCreation !== false) {
      writer.uint32(40).bool(message.skipInitialVersionCreation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCryptoKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCryptoKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cryptoKeyId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cryptoKey = CryptoKey.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.skipInitialVersionCreation = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCryptoKeyRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      cryptoKeyId: isSet(object.cryptoKeyId) ? globalThis.String(object.cryptoKeyId) : "",
      cryptoKey: isSet(object.cryptoKey) ? CryptoKey.fromJSON(object.cryptoKey) : undefined,
      skipInitialVersionCreation: isSet(object.skipInitialVersionCreation)
        ? globalThis.Boolean(object.skipInitialVersionCreation)
        : false,
    };
  },

  toJSON(message: CreateCryptoKeyRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.cryptoKeyId !== "") {
      obj.cryptoKeyId = message.cryptoKeyId;
    }
    if (message.cryptoKey !== undefined) {
      obj.cryptoKey = CryptoKey.toJSON(message.cryptoKey);
    }
    if (message.skipInitialVersionCreation !== false) {
      obj.skipInitialVersionCreation = message.skipInitialVersionCreation;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCryptoKeyRequest>): CreateCryptoKeyRequest {
    return CreateCryptoKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCryptoKeyRequest>): CreateCryptoKeyRequest {
    const message = createBaseCreateCryptoKeyRequest();
    message.parent = object.parent ?? "";
    message.cryptoKeyId = object.cryptoKeyId ?? "";
    message.cryptoKey = (object.cryptoKey !== undefined && object.cryptoKey !== null)
      ? CryptoKey.fromPartial(object.cryptoKey)
      : undefined;
    message.skipInitialVersionCreation = object.skipInitialVersionCreation ?? false;
    return message;
  },
};

function createBaseCreateCryptoKeyVersionRequest(): CreateCryptoKeyVersionRequest {
  return { parent: "", cryptoKeyVersion: undefined };
}

export const CreateCryptoKeyVersionRequest: MessageFns<CreateCryptoKeyVersionRequest> = {
  encode(message: CreateCryptoKeyVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.cryptoKeyVersion !== undefined) {
      CryptoKeyVersion.encode(message.cryptoKeyVersion, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCryptoKeyVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCryptoKeyVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cryptoKeyVersion = CryptoKeyVersion.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCryptoKeyVersionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      cryptoKeyVersion: isSet(object.cryptoKeyVersion) ? CryptoKeyVersion.fromJSON(object.cryptoKeyVersion) : undefined,
    };
  },

  toJSON(message: CreateCryptoKeyVersionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.cryptoKeyVersion !== undefined) {
      obj.cryptoKeyVersion = CryptoKeyVersion.toJSON(message.cryptoKeyVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCryptoKeyVersionRequest>): CreateCryptoKeyVersionRequest {
    return CreateCryptoKeyVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCryptoKeyVersionRequest>): CreateCryptoKeyVersionRequest {
    const message = createBaseCreateCryptoKeyVersionRequest();
    message.parent = object.parent ?? "";
    message.cryptoKeyVersion = (object.cryptoKeyVersion !== undefined && object.cryptoKeyVersion !== null)
      ? CryptoKeyVersion.fromPartial(object.cryptoKeyVersion)
      : undefined;
    return message;
  },
};

function createBaseImportCryptoKeyVersionRequest(): ImportCryptoKeyVersionRequest {
  return {
    parent: "",
    cryptoKeyVersion: "",
    algorithm: 0,
    importJob: "",
    wrappedKey: Buffer.alloc(0),
    rsaAesWrappedKey: undefined,
  };
}

export const ImportCryptoKeyVersionRequest: MessageFns<ImportCryptoKeyVersionRequest> = {
  encode(message: ImportCryptoKeyVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.cryptoKeyVersion !== "") {
      writer.uint32(50).string(message.cryptoKeyVersion);
    }
    if (message.algorithm !== 0) {
      writer.uint32(16).int32(message.algorithm);
    }
    if (message.importJob !== "") {
      writer.uint32(34).string(message.importJob);
    }
    if (message.wrappedKey.length !== 0) {
      writer.uint32(66).bytes(message.wrappedKey);
    }
    if (message.rsaAesWrappedKey !== undefined) {
      writer.uint32(42).bytes(message.rsaAesWrappedKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportCryptoKeyVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportCryptoKeyVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.cryptoKeyVersion = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.importJob = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.wrappedKey = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rsaAesWrappedKey = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportCryptoKeyVersionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      cryptoKeyVersion: isSet(object.cryptoKeyVersion) ? globalThis.String(object.cryptoKeyVersion) : "",
      algorithm: isSet(object.algorithm) ? cryptoKeyVersion_CryptoKeyVersionAlgorithmFromJSON(object.algorithm) : 0,
      importJob: isSet(object.importJob) ? globalThis.String(object.importJob) : "",
      wrappedKey: isSet(object.wrappedKey) ? Buffer.from(bytesFromBase64(object.wrappedKey)) : Buffer.alloc(0),
      rsaAesWrappedKey: isSet(object.rsaAesWrappedKey)
        ? Buffer.from(bytesFromBase64(object.rsaAesWrappedKey))
        : undefined,
    };
  },

  toJSON(message: ImportCryptoKeyVersionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.cryptoKeyVersion !== "") {
      obj.cryptoKeyVersion = message.cryptoKeyVersion;
    }
    if (message.algorithm !== 0) {
      obj.algorithm = cryptoKeyVersion_CryptoKeyVersionAlgorithmToJSON(message.algorithm);
    }
    if (message.importJob !== "") {
      obj.importJob = message.importJob;
    }
    if (message.wrappedKey.length !== 0) {
      obj.wrappedKey = base64FromBytes(message.wrappedKey);
    }
    if (message.rsaAesWrappedKey !== undefined) {
      obj.rsaAesWrappedKey = base64FromBytes(message.rsaAesWrappedKey);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportCryptoKeyVersionRequest>): ImportCryptoKeyVersionRequest {
    return ImportCryptoKeyVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportCryptoKeyVersionRequest>): ImportCryptoKeyVersionRequest {
    const message = createBaseImportCryptoKeyVersionRequest();
    message.parent = object.parent ?? "";
    message.cryptoKeyVersion = object.cryptoKeyVersion ?? "";
    message.algorithm = object.algorithm ?? 0;
    message.importJob = object.importJob ?? "";
    message.wrappedKey = object.wrappedKey ?? Buffer.alloc(0);
    message.rsaAesWrappedKey = object.rsaAesWrappedKey ?? undefined;
    return message;
  },
};

function createBaseCreateImportJobRequest(): CreateImportJobRequest {
  return { parent: "", importJobId: "", importJob: undefined };
}

export const CreateImportJobRequest: MessageFns<CreateImportJobRequest> = {
  encode(message: CreateImportJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.importJobId !== "") {
      writer.uint32(18).string(message.importJobId);
    }
    if (message.importJob !== undefined) {
      ImportJob.encode(message.importJob, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateImportJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateImportJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.importJobId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.importJob = ImportJob.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateImportJobRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      importJobId: isSet(object.importJobId) ? globalThis.String(object.importJobId) : "",
      importJob: isSet(object.importJob) ? ImportJob.fromJSON(object.importJob) : undefined,
    };
  },

  toJSON(message: CreateImportJobRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.importJobId !== "") {
      obj.importJobId = message.importJobId;
    }
    if (message.importJob !== undefined) {
      obj.importJob = ImportJob.toJSON(message.importJob);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateImportJobRequest>): CreateImportJobRequest {
    return CreateImportJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateImportJobRequest>): CreateImportJobRequest {
    const message = createBaseCreateImportJobRequest();
    message.parent = object.parent ?? "";
    message.importJobId = object.importJobId ?? "";
    message.importJob = (object.importJob !== undefined && object.importJob !== null)
      ? ImportJob.fromPartial(object.importJob)
      : undefined;
    return message;
  },
};

function createBaseUpdateCryptoKeyRequest(): UpdateCryptoKeyRequest {
  return { cryptoKey: undefined, updateMask: undefined };
}

export const UpdateCryptoKeyRequest: MessageFns<UpdateCryptoKeyRequest> = {
  encode(message: UpdateCryptoKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cryptoKey !== undefined) {
      CryptoKey.encode(message.cryptoKey, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCryptoKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCryptoKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cryptoKey = CryptoKey.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCryptoKeyRequest {
    return {
      cryptoKey: isSet(object.cryptoKey) ? CryptoKey.fromJSON(object.cryptoKey) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateCryptoKeyRequest): unknown {
    const obj: any = {};
    if (message.cryptoKey !== undefined) {
      obj.cryptoKey = CryptoKey.toJSON(message.cryptoKey);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCryptoKeyRequest>): UpdateCryptoKeyRequest {
    return UpdateCryptoKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCryptoKeyRequest>): UpdateCryptoKeyRequest {
    const message = createBaseUpdateCryptoKeyRequest();
    message.cryptoKey = (object.cryptoKey !== undefined && object.cryptoKey !== null)
      ? CryptoKey.fromPartial(object.cryptoKey)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUpdateCryptoKeyVersionRequest(): UpdateCryptoKeyVersionRequest {
  return { cryptoKeyVersion: undefined, updateMask: undefined };
}

export const UpdateCryptoKeyVersionRequest: MessageFns<UpdateCryptoKeyVersionRequest> = {
  encode(message: UpdateCryptoKeyVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cryptoKeyVersion !== undefined) {
      CryptoKeyVersion.encode(message.cryptoKeyVersion, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCryptoKeyVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCryptoKeyVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cryptoKeyVersion = CryptoKeyVersion.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCryptoKeyVersionRequest {
    return {
      cryptoKeyVersion: isSet(object.cryptoKeyVersion) ? CryptoKeyVersion.fromJSON(object.cryptoKeyVersion) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateCryptoKeyVersionRequest): unknown {
    const obj: any = {};
    if (message.cryptoKeyVersion !== undefined) {
      obj.cryptoKeyVersion = CryptoKeyVersion.toJSON(message.cryptoKeyVersion);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCryptoKeyVersionRequest>): UpdateCryptoKeyVersionRequest {
    return UpdateCryptoKeyVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCryptoKeyVersionRequest>): UpdateCryptoKeyVersionRequest {
    const message = createBaseUpdateCryptoKeyVersionRequest();
    message.cryptoKeyVersion = (object.cryptoKeyVersion !== undefined && object.cryptoKeyVersion !== null)
      ? CryptoKeyVersion.fromPartial(object.cryptoKeyVersion)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUpdateCryptoKeyPrimaryVersionRequest(): UpdateCryptoKeyPrimaryVersionRequest {
  return { name: "", cryptoKeyVersionId: "" };
}

export const UpdateCryptoKeyPrimaryVersionRequest: MessageFns<UpdateCryptoKeyPrimaryVersionRequest> = {
  encode(message: UpdateCryptoKeyPrimaryVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.cryptoKeyVersionId !== "") {
      writer.uint32(18).string(message.cryptoKeyVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCryptoKeyPrimaryVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCryptoKeyPrimaryVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cryptoKeyVersionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCryptoKeyPrimaryVersionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cryptoKeyVersionId: isSet(object.cryptoKeyVersionId) ? globalThis.String(object.cryptoKeyVersionId) : "",
    };
  },

  toJSON(message: UpdateCryptoKeyPrimaryVersionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.cryptoKeyVersionId !== "") {
      obj.cryptoKeyVersionId = message.cryptoKeyVersionId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCryptoKeyPrimaryVersionRequest>): UpdateCryptoKeyPrimaryVersionRequest {
    return UpdateCryptoKeyPrimaryVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCryptoKeyPrimaryVersionRequest>): UpdateCryptoKeyPrimaryVersionRequest {
    const message = createBaseUpdateCryptoKeyPrimaryVersionRequest();
    message.name = object.name ?? "";
    message.cryptoKeyVersionId = object.cryptoKeyVersionId ?? "";
    return message;
  },
};

function createBaseDestroyCryptoKeyVersionRequest(): DestroyCryptoKeyVersionRequest {
  return { name: "" };
}

export const DestroyCryptoKeyVersionRequest: MessageFns<DestroyCryptoKeyVersionRequest> = {
  encode(message: DestroyCryptoKeyVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DestroyCryptoKeyVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestroyCryptoKeyVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestroyCryptoKeyVersionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DestroyCryptoKeyVersionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DestroyCryptoKeyVersionRequest>): DestroyCryptoKeyVersionRequest {
    return DestroyCryptoKeyVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DestroyCryptoKeyVersionRequest>): DestroyCryptoKeyVersionRequest {
    const message = createBaseDestroyCryptoKeyVersionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRestoreCryptoKeyVersionRequest(): RestoreCryptoKeyVersionRequest {
  return { name: "" };
}

export const RestoreCryptoKeyVersionRequest: MessageFns<RestoreCryptoKeyVersionRequest> = {
  encode(message: RestoreCryptoKeyVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestoreCryptoKeyVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestoreCryptoKeyVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestoreCryptoKeyVersionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: RestoreCryptoKeyVersionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<RestoreCryptoKeyVersionRequest>): RestoreCryptoKeyVersionRequest {
    return RestoreCryptoKeyVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RestoreCryptoKeyVersionRequest>): RestoreCryptoKeyVersionRequest {
    const message = createBaseRestoreCryptoKeyVersionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseEncryptRequest(): EncryptRequest {
  return {
    name: "",
    plaintext: Buffer.alloc(0),
    additionalAuthenticatedData: Buffer.alloc(0),
    plaintextCrc32c: undefined,
    additionalAuthenticatedDataCrc32c: undefined,
  };
}

export const EncryptRequest: MessageFns<EncryptRequest> = {
  encode(message: EncryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.plaintext.length !== 0) {
      writer.uint32(18).bytes(message.plaintext);
    }
    if (message.additionalAuthenticatedData.length !== 0) {
      writer.uint32(26).bytes(message.additionalAuthenticatedData);
    }
    if (message.plaintextCrc32c !== undefined) {
      Int64Value.encode({ value: message.plaintextCrc32c! }, writer.uint32(58).fork()).join();
    }
    if (message.additionalAuthenticatedDataCrc32c !== undefined) {
      Int64Value.encode({ value: message.additionalAuthenticatedDataCrc32c! }, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.plaintext = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.additionalAuthenticatedData = Buffer.from(reader.bytes());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.plaintextCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.additionalAuthenticatedDataCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      plaintext: isSet(object.plaintext) ? Buffer.from(bytesFromBase64(object.plaintext)) : Buffer.alloc(0),
      additionalAuthenticatedData: isSet(object.additionalAuthenticatedData)
        ? Buffer.from(bytesFromBase64(object.additionalAuthenticatedData))
        : Buffer.alloc(0),
      plaintextCrc32c: isSet(object.plaintextCrc32c) ? Long.fromValue(object.plaintextCrc32c) : undefined,
      additionalAuthenticatedDataCrc32c: isSet(object.additionalAuthenticatedDataCrc32c)
        ? Long.fromValue(object.additionalAuthenticatedDataCrc32c)
        : undefined,
    };
  },

  toJSON(message: EncryptRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.plaintext.length !== 0) {
      obj.plaintext = base64FromBytes(message.plaintext);
    }
    if (message.additionalAuthenticatedData.length !== 0) {
      obj.additionalAuthenticatedData = base64FromBytes(message.additionalAuthenticatedData);
    }
    if (message.plaintextCrc32c !== undefined) {
      obj.plaintextCrc32c = message.plaintextCrc32c;
    }
    if (message.additionalAuthenticatedDataCrc32c !== undefined) {
      obj.additionalAuthenticatedDataCrc32c = message.additionalAuthenticatedDataCrc32c;
    }
    return obj;
  },

  create(base?: DeepPartial<EncryptRequest>): EncryptRequest {
    return EncryptRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EncryptRequest>): EncryptRequest {
    const message = createBaseEncryptRequest();
    message.name = object.name ?? "";
    message.plaintext = object.plaintext ?? Buffer.alloc(0);
    message.additionalAuthenticatedData = object.additionalAuthenticatedData ?? Buffer.alloc(0);
    message.plaintextCrc32c = (object.plaintextCrc32c !== undefined && object.plaintextCrc32c !== null)
      ? Long.fromValue(object.plaintextCrc32c)
      : undefined;
    message.additionalAuthenticatedDataCrc32c =
      (object.additionalAuthenticatedDataCrc32c !== undefined && object.additionalAuthenticatedDataCrc32c !== null)
        ? Long.fromValue(object.additionalAuthenticatedDataCrc32c)
        : undefined;
    return message;
  },
};

function createBaseDecryptRequest(): DecryptRequest {
  return {
    name: "",
    ciphertext: Buffer.alloc(0),
    additionalAuthenticatedData: Buffer.alloc(0),
    ciphertextCrc32c: undefined,
    additionalAuthenticatedDataCrc32c: undefined,
  };
}

export const DecryptRequest: MessageFns<DecryptRequest> = {
  encode(message: DecryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(18).bytes(message.ciphertext);
    }
    if (message.additionalAuthenticatedData.length !== 0) {
      writer.uint32(26).bytes(message.additionalAuthenticatedData);
    }
    if (message.ciphertextCrc32c !== undefined) {
      Int64Value.encode({ value: message.ciphertextCrc32c! }, writer.uint32(42).fork()).join();
    }
    if (message.additionalAuthenticatedDataCrc32c !== undefined) {
      Int64Value.encode({ value: message.additionalAuthenticatedDataCrc32c! }, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ciphertext = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.additionalAuthenticatedData = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ciphertextCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.additionalAuthenticatedDataCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ciphertext: isSet(object.ciphertext) ? Buffer.from(bytesFromBase64(object.ciphertext)) : Buffer.alloc(0),
      additionalAuthenticatedData: isSet(object.additionalAuthenticatedData)
        ? Buffer.from(bytesFromBase64(object.additionalAuthenticatedData))
        : Buffer.alloc(0),
      ciphertextCrc32c: isSet(object.ciphertextCrc32c) ? Long.fromValue(object.ciphertextCrc32c) : undefined,
      additionalAuthenticatedDataCrc32c: isSet(object.additionalAuthenticatedDataCrc32c)
        ? Long.fromValue(object.additionalAuthenticatedDataCrc32c)
        : undefined,
    };
  },

  toJSON(message: DecryptRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.additionalAuthenticatedData.length !== 0) {
      obj.additionalAuthenticatedData = base64FromBytes(message.additionalAuthenticatedData);
    }
    if (message.ciphertextCrc32c !== undefined) {
      obj.ciphertextCrc32c = message.ciphertextCrc32c;
    }
    if (message.additionalAuthenticatedDataCrc32c !== undefined) {
      obj.additionalAuthenticatedDataCrc32c = message.additionalAuthenticatedDataCrc32c;
    }
    return obj;
  },

  create(base?: DeepPartial<DecryptRequest>): DecryptRequest {
    return DecryptRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DecryptRequest>): DecryptRequest {
    const message = createBaseDecryptRequest();
    message.name = object.name ?? "";
    message.ciphertext = object.ciphertext ?? Buffer.alloc(0);
    message.additionalAuthenticatedData = object.additionalAuthenticatedData ?? Buffer.alloc(0);
    message.ciphertextCrc32c = (object.ciphertextCrc32c !== undefined && object.ciphertextCrc32c !== null)
      ? Long.fromValue(object.ciphertextCrc32c)
      : undefined;
    message.additionalAuthenticatedDataCrc32c =
      (object.additionalAuthenticatedDataCrc32c !== undefined && object.additionalAuthenticatedDataCrc32c !== null)
        ? Long.fromValue(object.additionalAuthenticatedDataCrc32c)
        : undefined;
    return message;
  },
};

function createBaseRawEncryptRequest(): RawEncryptRequest {
  return {
    name: "",
    plaintext: Buffer.alloc(0),
    additionalAuthenticatedData: Buffer.alloc(0),
    plaintextCrc32c: undefined,
    additionalAuthenticatedDataCrc32c: undefined,
    initializationVector: Buffer.alloc(0),
    initializationVectorCrc32c: undefined,
  };
}

export const RawEncryptRequest: MessageFns<RawEncryptRequest> = {
  encode(message: RawEncryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.plaintext.length !== 0) {
      writer.uint32(18).bytes(message.plaintext);
    }
    if (message.additionalAuthenticatedData.length !== 0) {
      writer.uint32(26).bytes(message.additionalAuthenticatedData);
    }
    if (message.plaintextCrc32c !== undefined) {
      Int64Value.encode({ value: message.plaintextCrc32c! }, writer.uint32(34).fork()).join();
    }
    if (message.additionalAuthenticatedDataCrc32c !== undefined) {
      Int64Value.encode({ value: message.additionalAuthenticatedDataCrc32c! }, writer.uint32(42).fork()).join();
    }
    if (message.initializationVector.length !== 0) {
      writer.uint32(50).bytes(message.initializationVector);
    }
    if (message.initializationVectorCrc32c !== undefined) {
      Int64Value.encode({ value: message.initializationVectorCrc32c! }, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawEncryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawEncryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.plaintext = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.additionalAuthenticatedData = Buffer.from(reader.bytes());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.plaintextCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.additionalAuthenticatedDataCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.initializationVector = Buffer.from(reader.bytes());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.initializationVectorCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RawEncryptRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      plaintext: isSet(object.plaintext) ? Buffer.from(bytesFromBase64(object.plaintext)) : Buffer.alloc(0),
      additionalAuthenticatedData: isSet(object.additionalAuthenticatedData)
        ? Buffer.from(bytesFromBase64(object.additionalAuthenticatedData))
        : Buffer.alloc(0),
      plaintextCrc32c: isSet(object.plaintextCrc32c) ? Long.fromValue(object.plaintextCrc32c) : undefined,
      additionalAuthenticatedDataCrc32c: isSet(object.additionalAuthenticatedDataCrc32c)
        ? Long.fromValue(object.additionalAuthenticatedDataCrc32c)
        : undefined,
      initializationVector: isSet(object.initializationVector)
        ? Buffer.from(bytesFromBase64(object.initializationVector))
        : Buffer.alloc(0),
      initializationVectorCrc32c: isSet(object.initializationVectorCrc32c)
        ? Long.fromValue(object.initializationVectorCrc32c)
        : undefined,
    };
  },

  toJSON(message: RawEncryptRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.plaintext.length !== 0) {
      obj.plaintext = base64FromBytes(message.plaintext);
    }
    if (message.additionalAuthenticatedData.length !== 0) {
      obj.additionalAuthenticatedData = base64FromBytes(message.additionalAuthenticatedData);
    }
    if (message.plaintextCrc32c !== undefined) {
      obj.plaintextCrc32c = message.plaintextCrc32c;
    }
    if (message.additionalAuthenticatedDataCrc32c !== undefined) {
      obj.additionalAuthenticatedDataCrc32c = message.additionalAuthenticatedDataCrc32c;
    }
    if (message.initializationVector.length !== 0) {
      obj.initializationVector = base64FromBytes(message.initializationVector);
    }
    if (message.initializationVectorCrc32c !== undefined) {
      obj.initializationVectorCrc32c = message.initializationVectorCrc32c;
    }
    return obj;
  },

  create(base?: DeepPartial<RawEncryptRequest>): RawEncryptRequest {
    return RawEncryptRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RawEncryptRequest>): RawEncryptRequest {
    const message = createBaseRawEncryptRequest();
    message.name = object.name ?? "";
    message.plaintext = object.plaintext ?? Buffer.alloc(0);
    message.additionalAuthenticatedData = object.additionalAuthenticatedData ?? Buffer.alloc(0);
    message.plaintextCrc32c = (object.plaintextCrc32c !== undefined && object.plaintextCrc32c !== null)
      ? Long.fromValue(object.plaintextCrc32c)
      : undefined;
    message.additionalAuthenticatedDataCrc32c =
      (object.additionalAuthenticatedDataCrc32c !== undefined && object.additionalAuthenticatedDataCrc32c !== null)
        ? Long.fromValue(object.additionalAuthenticatedDataCrc32c)
        : undefined;
    message.initializationVector = object.initializationVector ?? Buffer.alloc(0);
    message.initializationVectorCrc32c =
      (object.initializationVectorCrc32c !== undefined && object.initializationVectorCrc32c !== null)
        ? Long.fromValue(object.initializationVectorCrc32c)
        : undefined;
    return message;
  },
};

function createBaseRawDecryptRequest(): RawDecryptRequest {
  return {
    name: "",
    ciphertext: Buffer.alloc(0),
    additionalAuthenticatedData: Buffer.alloc(0),
    initializationVector: Buffer.alloc(0),
    tagLength: 0,
    ciphertextCrc32c: undefined,
    additionalAuthenticatedDataCrc32c: undefined,
    initializationVectorCrc32c: undefined,
  };
}

export const RawDecryptRequest: MessageFns<RawDecryptRequest> = {
  encode(message: RawDecryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(18).bytes(message.ciphertext);
    }
    if (message.additionalAuthenticatedData.length !== 0) {
      writer.uint32(26).bytes(message.additionalAuthenticatedData);
    }
    if (message.initializationVector.length !== 0) {
      writer.uint32(34).bytes(message.initializationVector);
    }
    if (message.tagLength !== 0) {
      writer.uint32(40).int32(message.tagLength);
    }
    if (message.ciphertextCrc32c !== undefined) {
      Int64Value.encode({ value: message.ciphertextCrc32c! }, writer.uint32(50).fork()).join();
    }
    if (message.additionalAuthenticatedDataCrc32c !== undefined) {
      Int64Value.encode({ value: message.additionalAuthenticatedDataCrc32c! }, writer.uint32(58).fork()).join();
    }
    if (message.initializationVectorCrc32c !== undefined) {
      Int64Value.encode({ value: message.initializationVectorCrc32c! }, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawDecryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawDecryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ciphertext = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.additionalAuthenticatedData = Buffer.from(reader.bytes());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.initializationVector = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.tagLength = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.ciphertextCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.additionalAuthenticatedDataCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.initializationVectorCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RawDecryptRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ciphertext: isSet(object.ciphertext) ? Buffer.from(bytesFromBase64(object.ciphertext)) : Buffer.alloc(0),
      additionalAuthenticatedData: isSet(object.additionalAuthenticatedData)
        ? Buffer.from(bytesFromBase64(object.additionalAuthenticatedData))
        : Buffer.alloc(0),
      initializationVector: isSet(object.initializationVector)
        ? Buffer.from(bytesFromBase64(object.initializationVector))
        : Buffer.alloc(0),
      tagLength: isSet(object.tagLength) ? globalThis.Number(object.tagLength) : 0,
      ciphertextCrc32c: isSet(object.ciphertextCrc32c) ? Long.fromValue(object.ciphertextCrc32c) : undefined,
      additionalAuthenticatedDataCrc32c: isSet(object.additionalAuthenticatedDataCrc32c)
        ? Long.fromValue(object.additionalAuthenticatedDataCrc32c)
        : undefined,
      initializationVectorCrc32c: isSet(object.initializationVectorCrc32c)
        ? Long.fromValue(object.initializationVectorCrc32c)
        : undefined,
    };
  },

  toJSON(message: RawDecryptRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.additionalAuthenticatedData.length !== 0) {
      obj.additionalAuthenticatedData = base64FromBytes(message.additionalAuthenticatedData);
    }
    if (message.initializationVector.length !== 0) {
      obj.initializationVector = base64FromBytes(message.initializationVector);
    }
    if (message.tagLength !== 0) {
      obj.tagLength = Math.round(message.tagLength);
    }
    if (message.ciphertextCrc32c !== undefined) {
      obj.ciphertextCrc32c = message.ciphertextCrc32c;
    }
    if (message.additionalAuthenticatedDataCrc32c !== undefined) {
      obj.additionalAuthenticatedDataCrc32c = message.additionalAuthenticatedDataCrc32c;
    }
    if (message.initializationVectorCrc32c !== undefined) {
      obj.initializationVectorCrc32c = message.initializationVectorCrc32c;
    }
    return obj;
  },

  create(base?: DeepPartial<RawDecryptRequest>): RawDecryptRequest {
    return RawDecryptRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RawDecryptRequest>): RawDecryptRequest {
    const message = createBaseRawDecryptRequest();
    message.name = object.name ?? "";
    message.ciphertext = object.ciphertext ?? Buffer.alloc(0);
    message.additionalAuthenticatedData = object.additionalAuthenticatedData ?? Buffer.alloc(0);
    message.initializationVector = object.initializationVector ?? Buffer.alloc(0);
    message.tagLength = object.tagLength ?? 0;
    message.ciphertextCrc32c = (object.ciphertextCrc32c !== undefined && object.ciphertextCrc32c !== null)
      ? Long.fromValue(object.ciphertextCrc32c)
      : undefined;
    message.additionalAuthenticatedDataCrc32c =
      (object.additionalAuthenticatedDataCrc32c !== undefined && object.additionalAuthenticatedDataCrc32c !== null)
        ? Long.fromValue(object.additionalAuthenticatedDataCrc32c)
        : undefined;
    message.initializationVectorCrc32c =
      (object.initializationVectorCrc32c !== undefined && object.initializationVectorCrc32c !== null)
        ? Long.fromValue(object.initializationVectorCrc32c)
        : undefined;
    return message;
  },
};

function createBaseAsymmetricSignRequest(): AsymmetricSignRequest {
  return { name: "", digest: undefined, digestCrc32c: undefined, data: Buffer.alloc(0), dataCrc32c: undefined };
}

export const AsymmetricSignRequest: MessageFns<AsymmetricSignRequest> = {
  encode(message: AsymmetricSignRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.digest !== undefined) {
      Digest.encode(message.digest, writer.uint32(26).fork()).join();
    }
    if (message.digestCrc32c !== undefined) {
      Int64Value.encode({ value: message.digestCrc32c! }, writer.uint32(34).fork()).join();
    }
    if (message.data.length !== 0) {
      writer.uint32(50).bytes(message.data);
    }
    if (message.dataCrc32c !== undefined) {
      Int64Value.encode({ value: message.dataCrc32c! }, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AsymmetricSignRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsymmetricSignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.digest = Digest.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.digestCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dataCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AsymmetricSignRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      digest: isSet(object.digest) ? Digest.fromJSON(object.digest) : undefined,
      digestCrc32c: isSet(object.digestCrc32c) ? Long.fromValue(object.digestCrc32c) : undefined,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      dataCrc32c: isSet(object.dataCrc32c) ? Long.fromValue(object.dataCrc32c) : undefined,
    };
  },

  toJSON(message: AsymmetricSignRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.digest !== undefined) {
      obj.digest = Digest.toJSON(message.digest);
    }
    if (message.digestCrc32c !== undefined) {
      obj.digestCrc32c = message.digestCrc32c;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.dataCrc32c !== undefined) {
      obj.dataCrc32c = message.dataCrc32c;
    }
    return obj;
  },

  create(base?: DeepPartial<AsymmetricSignRequest>): AsymmetricSignRequest {
    return AsymmetricSignRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AsymmetricSignRequest>): AsymmetricSignRequest {
    const message = createBaseAsymmetricSignRequest();
    message.name = object.name ?? "";
    message.digest = (object.digest !== undefined && object.digest !== null)
      ? Digest.fromPartial(object.digest)
      : undefined;
    message.digestCrc32c = (object.digestCrc32c !== undefined && object.digestCrc32c !== null)
      ? Long.fromValue(object.digestCrc32c)
      : undefined;
    message.data = object.data ?? Buffer.alloc(0);
    message.dataCrc32c = (object.dataCrc32c !== undefined && object.dataCrc32c !== null)
      ? Long.fromValue(object.dataCrc32c)
      : undefined;
    return message;
  },
};

function createBaseAsymmetricDecryptRequest(): AsymmetricDecryptRequest {
  return { name: "", ciphertext: Buffer.alloc(0), ciphertextCrc32c: undefined };
}

export const AsymmetricDecryptRequest: MessageFns<AsymmetricDecryptRequest> = {
  encode(message: AsymmetricDecryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(26).bytes(message.ciphertext);
    }
    if (message.ciphertextCrc32c !== undefined) {
      Int64Value.encode({ value: message.ciphertextCrc32c! }, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AsymmetricDecryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsymmetricDecryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ciphertext = Buffer.from(reader.bytes());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ciphertextCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AsymmetricDecryptRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ciphertext: isSet(object.ciphertext) ? Buffer.from(bytesFromBase64(object.ciphertext)) : Buffer.alloc(0),
      ciphertextCrc32c: isSet(object.ciphertextCrc32c) ? Long.fromValue(object.ciphertextCrc32c) : undefined,
    };
  },

  toJSON(message: AsymmetricDecryptRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.ciphertextCrc32c !== undefined) {
      obj.ciphertextCrc32c = message.ciphertextCrc32c;
    }
    return obj;
  },

  create(base?: DeepPartial<AsymmetricDecryptRequest>): AsymmetricDecryptRequest {
    return AsymmetricDecryptRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AsymmetricDecryptRequest>): AsymmetricDecryptRequest {
    const message = createBaseAsymmetricDecryptRequest();
    message.name = object.name ?? "";
    message.ciphertext = object.ciphertext ?? Buffer.alloc(0);
    message.ciphertextCrc32c = (object.ciphertextCrc32c !== undefined && object.ciphertextCrc32c !== null)
      ? Long.fromValue(object.ciphertextCrc32c)
      : undefined;
    return message;
  },
};

function createBaseMacSignRequest(): MacSignRequest {
  return { name: "", data: Buffer.alloc(0), dataCrc32c: undefined };
}

export const MacSignRequest: MessageFns<MacSignRequest> = {
  encode(message: MacSignRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.dataCrc32c !== undefined) {
      Int64Value.encode({ value: message.dataCrc32c! }, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MacSignRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMacSignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dataCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MacSignRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      dataCrc32c: isSet(object.dataCrc32c) ? Long.fromValue(object.dataCrc32c) : undefined,
    };
  },

  toJSON(message: MacSignRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.dataCrc32c !== undefined) {
      obj.dataCrc32c = message.dataCrc32c;
    }
    return obj;
  },

  create(base?: DeepPartial<MacSignRequest>): MacSignRequest {
    return MacSignRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MacSignRequest>): MacSignRequest {
    const message = createBaseMacSignRequest();
    message.name = object.name ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    message.dataCrc32c = (object.dataCrc32c !== undefined && object.dataCrc32c !== null)
      ? Long.fromValue(object.dataCrc32c)
      : undefined;
    return message;
  },
};

function createBaseMacVerifyRequest(): MacVerifyRequest {
  return { name: "", data: Buffer.alloc(0), dataCrc32c: undefined, mac: Buffer.alloc(0), macCrc32c: undefined };
}

export const MacVerifyRequest: MessageFns<MacVerifyRequest> = {
  encode(message: MacVerifyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.dataCrc32c !== undefined) {
      Int64Value.encode({ value: message.dataCrc32c! }, writer.uint32(26).fork()).join();
    }
    if (message.mac.length !== 0) {
      writer.uint32(34).bytes(message.mac);
    }
    if (message.macCrc32c !== undefined) {
      Int64Value.encode({ value: message.macCrc32c! }, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MacVerifyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMacVerifyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dataCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mac = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.macCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MacVerifyRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      dataCrc32c: isSet(object.dataCrc32c) ? Long.fromValue(object.dataCrc32c) : undefined,
      mac: isSet(object.mac) ? Buffer.from(bytesFromBase64(object.mac)) : Buffer.alloc(0),
      macCrc32c: isSet(object.macCrc32c) ? Long.fromValue(object.macCrc32c) : undefined,
    };
  },

  toJSON(message: MacVerifyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.dataCrc32c !== undefined) {
      obj.dataCrc32c = message.dataCrc32c;
    }
    if (message.mac.length !== 0) {
      obj.mac = base64FromBytes(message.mac);
    }
    if (message.macCrc32c !== undefined) {
      obj.macCrc32c = message.macCrc32c;
    }
    return obj;
  },

  create(base?: DeepPartial<MacVerifyRequest>): MacVerifyRequest {
    return MacVerifyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MacVerifyRequest>): MacVerifyRequest {
    const message = createBaseMacVerifyRequest();
    message.name = object.name ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    message.dataCrc32c = (object.dataCrc32c !== undefined && object.dataCrc32c !== null)
      ? Long.fromValue(object.dataCrc32c)
      : undefined;
    message.mac = object.mac ?? Buffer.alloc(0);
    message.macCrc32c = (object.macCrc32c !== undefined && object.macCrc32c !== null)
      ? Long.fromValue(object.macCrc32c)
      : undefined;
    return message;
  },
};

function createBaseGenerateRandomBytesRequest(): GenerateRandomBytesRequest {
  return { location: "", lengthBytes: 0, protectionLevel: 0 };
}

export const GenerateRandomBytesRequest: MessageFns<GenerateRandomBytesRequest> = {
  encode(message: GenerateRandomBytesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    if (message.lengthBytes !== 0) {
      writer.uint32(16).int32(message.lengthBytes);
    }
    if (message.protectionLevel !== 0) {
      writer.uint32(24).int32(message.protectionLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateRandomBytesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateRandomBytesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lengthBytes = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.protectionLevel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateRandomBytesRequest {
    return {
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      lengthBytes: isSet(object.lengthBytes) ? globalThis.Number(object.lengthBytes) : 0,
      protectionLevel: isSet(object.protectionLevel) ? protectionLevelFromJSON(object.protectionLevel) : 0,
    };
  },

  toJSON(message: GenerateRandomBytesRequest): unknown {
    const obj: any = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.lengthBytes !== 0) {
      obj.lengthBytes = Math.round(message.lengthBytes);
    }
    if (message.protectionLevel !== 0) {
      obj.protectionLevel = protectionLevelToJSON(message.protectionLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateRandomBytesRequest>): GenerateRandomBytesRequest {
    return GenerateRandomBytesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateRandomBytesRequest>): GenerateRandomBytesRequest {
    const message = createBaseGenerateRandomBytesRequest();
    message.location = object.location ?? "";
    message.lengthBytes = object.lengthBytes ?? 0;
    message.protectionLevel = object.protectionLevel ?? 0;
    return message;
  },
};

function createBaseEncryptResponse(): EncryptResponse {
  return {
    name: "",
    ciphertext: Buffer.alloc(0),
    ciphertextCrc32c: undefined,
    verifiedPlaintextCrc32c: false,
    verifiedAdditionalAuthenticatedDataCrc32c: false,
    protectionLevel: 0,
  };
}

export const EncryptResponse: MessageFns<EncryptResponse> = {
  encode(message: EncryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(18).bytes(message.ciphertext);
    }
    if (message.ciphertextCrc32c !== undefined) {
      Int64Value.encode({ value: message.ciphertextCrc32c! }, writer.uint32(34).fork()).join();
    }
    if (message.verifiedPlaintextCrc32c !== false) {
      writer.uint32(40).bool(message.verifiedPlaintextCrc32c);
    }
    if (message.verifiedAdditionalAuthenticatedDataCrc32c !== false) {
      writer.uint32(48).bool(message.verifiedAdditionalAuthenticatedDataCrc32c);
    }
    if (message.protectionLevel !== 0) {
      writer.uint32(56).int32(message.protectionLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ciphertext = Buffer.from(reader.bytes());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ciphertextCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.verifiedPlaintextCrc32c = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.verifiedAdditionalAuthenticatedDataCrc32c = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.protectionLevel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ciphertext: isSet(object.ciphertext) ? Buffer.from(bytesFromBase64(object.ciphertext)) : Buffer.alloc(0),
      ciphertextCrc32c: isSet(object.ciphertextCrc32c) ? Long.fromValue(object.ciphertextCrc32c) : undefined,
      verifiedPlaintextCrc32c: isSet(object.verifiedPlaintextCrc32c)
        ? globalThis.Boolean(object.verifiedPlaintextCrc32c)
        : false,
      verifiedAdditionalAuthenticatedDataCrc32c: isSet(object.verifiedAdditionalAuthenticatedDataCrc32c)
        ? globalThis.Boolean(object.verifiedAdditionalAuthenticatedDataCrc32c)
        : false,
      protectionLevel: isSet(object.protectionLevel) ? protectionLevelFromJSON(object.protectionLevel) : 0,
    };
  },

  toJSON(message: EncryptResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.ciphertextCrc32c !== undefined) {
      obj.ciphertextCrc32c = message.ciphertextCrc32c;
    }
    if (message.verifiedPlaintextCrc32c !== false) {
      obj.verifiedPlaintextCrc32c = message.verifiedPlaintextCrc32c;
    }
    if (message.verifiedAdditionalAuthenticatedDataCrc32c !== false) {
      obj.verifiedAdditionalAuthenticatedDataCrc32c = message.verifiedAdditionalAuthenticatedDataCrc32c;
    }
    if (message.protectionLevel !== 0) {
      obj.protectionLevel = protectionLevelToJSON(message.protectionLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<EncryptResponse>): EncryptResponse {
    return EncryptResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EncryptResponse>): EncryptResponse {
    const message = createBaseEncryptResponse();
    message.name = object.name ?? "";
    message.ciphertext = object.ciphertext ?? Buffer.alloc(0);
    message.ciphertextCrc32c = (object.ciphertextCrc32c !== undefined && object.ciphertextCrc32c !== null)
      ? Long.fromValue(object.ciphertextCrc32c)
      : undefined;
    message.verifiedPlaintextCrc32c = object.verifiedPlaintextCrc32c ?? false;
    message.verifiedAdditionalAuthenticatedDataCrc32c = object.verifiedAdditionalAuthenticatedDataCrc32c ?? false;
    message.protectionLevel = object.protectionLevel ?? 0;
    return message;
  },
};

function createBaseDecryptResponse(): DecryptResponse {
  return { plaintext: Buffer.alloc(0), plaintextCrc32c: undefined, usedPrimary: false, protectionLevel: 0 };
}

export const DecryptResponse: MessageFns<DecryptResponse> = {
  encode(message: DecryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plaintext.length !== 0) {
      writer.uint32(10).bytes(message.plaintext);
    }
    if (message.plaintextCrc32c !== undefined) {
      Int64Value.encode({ value: message.plaintextCrc32c! }, writer.uint32(18).fork()).join();
    }
    if (message.usedPrimary !== false) {
      writer.uint32(24).bool(message.usedPrimary);
    }
    if (message.protectionLevel !== 0) {
      writer.uint32(32).int32(message.protectionLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.plaintext = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.plaintextCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.usedPrimary = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.protectionLevel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptResponse {
    return {
      plaintext: isSet(object.plaintext) ? Buffer.from(bytesFromBase64(object.plaintext)) : Buffer.alloc(0),
      plaintextCrc32c: isSet(object.plaintextCrc32c) ? Long.fromValue(object.plaintextCrc32c) : undefined,
      usedPrimary: isSet(object.usedPrimary) ? globalThis.Boolean(object.usedPrimary) : false,
      protectionLevel: isSet(object.protectionLevel) ? protectionLevelFromJSON(object.protectionLevel) : 0,
    };
  },

  toJSON(message: DecryptResponse): unknown {
    const obj: any = {};
    if (message.plaintext.length !== 0) {
      obj.plaintext = base64FromBytes(message.plaintext);
    }
    if (message.plaintextCrc32c !== undefined) {
      obj.plaintextCrc32c = message.plaintextCrc32c;
    }
    if (message.usedPrimary !== false) {
      obj.usedPrimary = message.usedPrimary;
    }
    if (message.protectionLevel !== 0) {
      obj.protectionLevel = protectionLevelToJSON(message.protectionLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<DecryptResponse>): DecryptResponse {
    return DecryptResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DecryptResponse>): DecryptResponse {
    const message = createBaseDecryptResponse();
    message.plaintext = object.plaintext ?? Buffer.alloc(0);
    message.plaintextCrc32c = (object.plaintextCrc32c !== undefined && object.plaintextCrc32c !== null)
      ? Long.fromValue(object.plaintextCrc32c)
      : undefined;
    message.usedPrimary = object.usedPrimary ?? false;
    message.protectionLevel = object.protectionLevel ?? 0;
    return message;
  },
};

function createBaseRawEncryptResponse(): RawEncryptResponse {
  return {
    ciphertext: Buffer.alloc(0),
    initializationVector: Buffer.alloc(0),
    tagLength: 0,
    ciphertextCrc32c: undefined,
    initializationVectorCrc32c: undefined,
    verifiedPlaintextCrc32c: false,
    verifiedAdditionalAuthenticatedDataCrc32c: false,
    verifiedInitializationVectorCrc32c: false,
    name: "",
    protectionLevel: 0,
  };
}

export const RawEncryptResponse: MessageFns<RawEncryptResponse> = {
  encode(message: RawEncryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ciphertext.length !== 0) {
      writer.uint32(10).bytes(message.ciphertext);
    }
    if (message.initializationVector.length !== 0) {
      writer.uint32(18).bytes(message.initializationVector);
    }
    if (message.tagLength !== 0) {
      writer.uint32(24).int32(message.tagLength);
    }
    if (message.ciphertextCrc32c !== undefined) {
      Int64Value.encode({ value: message.ciphertextCrc32c! }, writer.uint32(34).fork()).join();
    }
    if (message.initializationVectorCrc32c !== undefined) {
      Int64Value.encode({ value: message.initializationVectorCrc32c! }, writer.uint32(42).fork()).join();
    }
    if (message.verifiedPlaintextCrc32c !== false) {
      writer.uint32(48).bool(message.verifiedPlaintextCrc32c);
    }
    if (message.verifiedAdditionalAuthenticatedDataCrc32c !== false) {
      writer.uint32(56).bool(message.verifiedAdditionalAuthenticatedDataCrc32c);
    }
    if (message.verifiedInitializationVectorCrc32c !== false) {
      writer.uint32(80).bool(message.verifiedInitializationVectorCrc32c);
    }
    if (message.name !== "") {
      writer.uint32(66).string(message.name);
    }
    if (message.protectionLevel !== 0) {
      writer.uint32(72).int32(message.protectionLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawEncryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawEncryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ciphertext = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.initializationVector = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tagLength = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ciphertextCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.initializationVectorCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.verifiedPlaintextCrc32c = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.verifiedAdditionalAuthenticatedDataCrc32c = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.verifiedInitializationVectorCrc32c = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.name = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.protectionLevel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RawEncryptResponse {
    return {
      ciphertext: isSet(object.ciphertext) ? Buffer.from(bytesFromBase64(object.ciphertext)) : Buffer.alloc(0),
      initializationVector: isSet(object.initializationVector)
        ? Buffer.from(bytesFromBase64(object.initializationVector))
        : Buffer.alloc(0),
      tagLength: isSet(object.tagLength) ? globalThis.Number(object.tagLength) : 0,
      ciphertextCrc32c: isSet(object.ciphertextCrc32c) ? Long.fromValue(object.ciphertextCrc32c) : undefined,
      initializationVectorCrc32c: isSet(object.initializationVectorCrc32c)
        ? Long.fromValue(object.initializationVectorCrc32c)
        : undefined,
      verifiedPlaintextCrc32c: isSet(object.verifiedPlaintextCrc32c)
        ? globalThis.Boolean(object.verifiedPlaintextCrc32c)
        : false,
      verifiedAdditionalAuthenticatedDataCrc32c: isSet(object.verifiedAdditionalAuthenticatedDataCrc32c)
        ? globalThis.Boolean(object.verifiedAdditionalAuthenticatedDataCrc32c)
        : false,
      verifiedInitializationVectorCrc32c: isSet(object.verifiedInitializationVectorCrc32c)
        ? globalThis.Boolean(object.verifiedInitializationVectorCrc32c)
        : false,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      protectionLevel: isSet(object.protectionLevel) ? protectionLevelFromJSON(object.protectionLevel) : 0,
    };
  },

  toJSON(message: RawEncryptResponse): unknown {
    const obj: any = {};
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.initializationVector.length !== 0) {
      obj.initializationVector = base64FromBytes(message.initializationVector);
    }
    if (message.tagLength !== 0) {
      obj.tagLength = Math.round(message.tagLength);
    }
    if (message.ciphertextCrc32c !== undefined) {
      obj.ciphertextCrc32c = message.ciphertextCrc32c;
    }
    if (message.initializationVectorCrc32c !== undefined) {
      obj.initializationVectorCrc32c = message.initializationVectorCrc32c;
    }
    if (message.verifiedPlaintextCrc32c !== false) {
      obj.verifiedPlaintextCrc32c = message.verifiedPlaintextCrc32c;
    }
    if (message.verifiedAdditionalAuthenticatedDataCrc32c !== false) {
      obj.verifiedAdditionalAuthenticatedDataCrc32c = message.verifiedAdditionalAuthenticatedDataCrc32c;
    }
    if (message.verifiedInitializationVectorCrc32c !== false) {
      obj.verifiedInitializationVectorCrc32c = message.verifiedInitializationVectorCrc32c;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.protectionLevel !== 0) {
      obj.protectionLevel = protectionLevelToJSON(message.protectionLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<RawEncryptResponse>): RawEncryptResponse {
    return RawEncryptResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RawEncryptResponse>): RawEncryptResponse {
    const message = createBaseRawEncryptResponse();
    message.ciphertext = object.ciphertext ?? Buffer.alloc(0);
    message.initializationVector = object.initializationVector ?? Buffer.alloc(0);
    message.tagLength = object.tagLength ?? 0;
    message.ciphertextCrc32c = (object.ciphertextCrc32c !== undefined && object.ciphertextCrc32c !== null)
      ? Long.fromValue(object.ciphertextCrc32c)
      : undefined;
    message.initializationVectorCrc32c =
      (object.initializationVectorCrc32c !== undefined && object.initializationVectorCrc32c !== null)
        ? Long.fromValue(object.initializationVectorCrc32c)
        : undefined;
    message.verifiedPlaintextCrc32c = object.verifiedPlaintextCrc32c ?? false;
    message.verifiedAdditionalAuthenticatedDataCrc32c = object.verifiedAdditionalAuthenticatedDataCrc32c ?? false;
    message.verifiedInitializationVectorCrc32c = object.verifiedInitializationVectorCrc32c ?? false;
    message.name = object.name ?? "";
    message.protectionLevel = object.protectionLevel ?? 0;
    return message;
  },
};

function createBaseRawDecryptResponse(): RawDecryptResponse {
  return {
    plaintext: Buffer.alloc(0),
    plaintextCrc32c: undefined,
    protectionLevel: 0,
    verifiedCiphertextCrc32c: false,
    verifiedAdditionalAuthenticatedDataCrc32c: false,
    verifiedInitializationVectorCrc32c: false,
  };
}

export const RawDecryptResponse: MessageFns<RawDecryptResponse> = {
  encode(message: RawDecryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plaintext.length !== 0) {
      writer.uint32(10).bytes(message.plaintext);
    }
    if (message.plaintextCrc32c !== undefined) {
      Int64Value.encode({ value: message.plaintextCrc32c! }, writer.uint32(18).fork()).join();
    }
    if (message.protectionLevel !== 0) {
      writer.uint32(24).int32(message.protectionLevel);
    }
    if (message.verifiedCiphertextCrc32c !== false) {
      writer.uint32(32).bool(message.verifiedCiphertextCrc32c);
    }
    if (message.verifiedAdditionalAuthenticatedDataCrc32c !== false) {
      writer.uint32(40).bool(message.verifiedAdditionalAuthenticatedDataCrc32c);
    }
    if (message.verifiedInitializationVectorCrc32c !== false) {
      writer.uint32(48).bool(message.verifiedInitializationVectorCrc32c);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawDecryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawDecryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.plaintext = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.plaintextCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.protectionLevel = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.verifiedCiphertextCrc32c = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.verifiedAdditionalAuthenticatedDataCrc32c = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.verifiedInitializationVectorCrc32c = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RawDecryptResponse {
    return {
      plaintext: isSet(object.plaintext) ? Buffer.from(bytesFromBase64(object.plaintext)) : Buffer.alloc(0),
      plaintextCrc32c: isSet(object.plaintextCrc32c) ? Long.fromValue(object.plaintextCrc32c) : undefined,
      protectionLevel: isSet(object.protectionLevel) ? protectionLevelFromJSON(object.protectionLevel) : 0,
      verifiedCiphertextCrc32c: isSet(object.verifiedCiphertextCrc32c)
        ? globalThis.Boolean(object.verifiedCiphertextCrc32c)
        : false,
      verifiedAdditionalAuthenticatedDataCrc32c: isSet(object.verifiedAdditionalAuthenticatedDataCrc32c)
        ? globalThis.Boolean(object.verifiedAdditionalAuthenticatedDataCrc32c)
        : false,
      verifiedInitializationVectorCrc32c: isSet(object.verifiedInitializationVectorCrc32c)
        ? globalThis.Boolean(object.verifiedInitializationVectorCrc32c)
        : false,
    };
  },

  toJSON(message: RawDecryptResponse): unknown {
    const obj: any = {};
    if (message.plaintext.length !== 0) {
      obj.plaintext = base64FromBytes(message.plaintext);
    }
    if (message.plaintextCrc32c !== undefined) {
      obj.plaintextCrc32c = message.plaintextCrc32c;
    }
    if (message.protectionLevel !== 0) {
      obj.protectionLevel = protectionLevelToJSON(message.protectionLevel);
    }
    if (message.verifiedCiphertextCrc32c !== false) {
      obj.verifiedCiphertextCrc32c = message.verifiedCiphertextCrc32c;
    }
    if (message.verifiedAdditionalAuthenticatedDataCrc32c !== false) {
      obj.verifiedAdditionalAuthenticatedDataCrc32c = message.verifiedAdditionalAuthenticatedDataCrc32c;
    }
    if (message.verifiedInitializationVectorCrc32c !== false) {
      obj.verifiedInitializationVectorCrc32c = message.verifiedInitializationVectorCrc32c;
    }
    return obj;
  },

  create(base?: DeepPartial<RawDecryptResponse>): RawDecryptResponse {
    return RawDecryptResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RawDecryptResponse>): RawDecryptResponse {
    const message = createBaseRawDecryptResponse();
    message.plaintext = object.plaintext ?? Buffer.alloc(0);
    message.plaintextCrc32c = (object.plaintextCrc32c !== undefined && object.plaintextCrc32c !== null)
      ? Long.fromValue(object.plaintextCrc32c)
      : undefined;
    message.protectionLevel = object.protectionLevel ?? 0;
    message.verifiedCiphertextCrc32c = object.verifiedCiphertextCrc32c ?? false;
    message.verifiedAdditionalAuthenticatedDataCrc32c = object.verifiedAdditionalAuthenticatedDataCrc32c ?? false;
    message.verifiedInitializationVectorCrc32c = object.verifiedInitializationVectorCrc32c ?? false;
    return message;
  },
};

function createBaseAsymmetricSignResponse(): AsymmetricSignResponse {
  return {
    signature: Buffer.alloc(0),
    signatureCrc32c: undefined,
    verifiedDigestCrc32c: false,
    name: "",
    verifiedDataCrc32c: false,
    protectionLevel: 0,
  };
}

export const AsymmetricSignResponse: MessageFns<AsymmetricSignResponse> = {
  encode(message: AsymmetricSignResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    if (message.signatureCrc32c !== undefined) {
      Int64Value.encode({ value: message.signatureCrc32c! }, writer.uint32(18).fork()).join();
    }
    if (message.verifiedDigestCrc32c !== false) {
      writer.uint32(24).bool(message.verifiedDigestCrc32c);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.verifiedDataCrc32c !== false) {
      writer.uint32(40).bool(message.verifiedDataCrc32c);
    }
    if (message.protectionLevel !== 0) {
      writer.uint32(48).int32(message.protectionLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AsymmetricSignResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsymmetricSignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signatureCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.verifiedDigestCrc32c = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.verifiedDataCrc32c = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.protectionLevel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AsymmetricSignResponse {
    return {
      signature: isSet(object.signature) ? Buffer.from(bytesFromBase64(object.signature)) : Buffer.alloc(0),
      signatureCrc32c: isSet(object.signatureCrc32c) ? Long.fromValue(object.signatureCrc32c) : undefined,
      verifiedDigestCrc32c: isSet(object.verifiedDigestCrc32c)
        ? globalThis.Boolean(object.verifiedDigestCrc32c)
        : false,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      verifiedDataCrc32c: isSet(object.verifiedDataCrc32c) ? globalThis.Boolean(object.verifiedDataCrc32c) : false,
      protectionLevel: isSet(object.protectionLevel) ? protectionLevelFromJSON(object.protectionLevel) : 0,
    };
  },

  toJSON(message: AsymmetricSignResponse): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.signatureCrc32c !== undefined) {
      obj.signatureCrc32c = message.signatureCrc32c;
    }
    if (message.verifiedDigestCrc32c !== false) {
      obj.verifiedDigestCrc32c = message.verifiedDigestCrc32c;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.verifiedDataCrc32c !== false) {
      obj.verifiedDataCrc32c = message.verifiedDataCrc32c;
    }
    if (message.protectionLevel !== 0) {
      obj.protectionLevel = protectionLevelToJSON(message.protectionLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<AsymmetricSignResponse>): AsymmetricSignResponse {
    return AsymmetricSignResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AsymmetricSignResponse>): AsymmetricSignResponse {
    const message = createBaseAsymmetricSignResponse();
    message.signature = object.signature ?? Buffer.alloc(0);
    message.signatureCrc32c = (object.signatureCrc32c !== undefined && object.signatureCrc32c !== null)
      ? Long.fromValue(object.signatureCrc32c)
      : undefined;
    message.verifiedDigestCrc32c = object.verifiedDigestCrc32c ?? false;
    message.name = object.name ?? "";
    message.verifiedDataCrc32c = object.verifiedDataCrc32c ?? false;
    message.protectionLevel = object.protectionLevel ?? 0;
    return message;
  },
};

function createBaseAsymmetricDecryptResponse(): AsymmetricDecryptResponse {
  return {
    plaintext: Buffer.alloc(0),
    plaintextCrc32c: undefined,
    verifiedCiphertextCrc32c: false,
    protectionLevel: 0,
  };
}

export const AsymmetricDecryptResponse: MessageFns<AsymmetricDecryptResponse> = {
  encode(message: AsymmetricDecryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plaintext.length !== 0) {
      writer.uint32(10).bytes(message.plaintext);
    }
    if (message.plaintextCrc32c !== undefined) {
      Int64Value.encode({ value: message.plaintextCrc32c! }, writer.uint32(18).fork()).join();
    }
    if (message.verifiedCiphertextCrc32c !== false) {
      writer.uint32(24).bool(message.verifiedCiphertextCrc32c);
    }
    if (message.protectionLevel !== 0) {
      writer.uint32(32).int32(message.protectionLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AsymmetricDecryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsymmetricDecryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.plaintext = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.plaintextCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.verifiedCiphertextCrc32c = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.protectionLevel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AsymmetricDecryptResponse {
    return {
      plaintext: isSet(object.plaintext) ? Buffer.from(bytesFromBase64(object.plaintext)) : Buffer.alloc(0),
      plaintextCrc32c: isSet(object.plaintextCrc32c) ? Long.fromValue(object.plaintextCrc32c) : undefined,
      verifiedCiphertextCrc32c: isSet(object.verifiedCiphertextCrc32c)
        ? globalThis.Boolean(object.verifiedCiphertextCrc32c)
        : false,
      protectionLevel: isSet(object.protectionLevel) ? protectionLevelFromJSON(object.protectionLevel) : 0,
    };
  },

  toJSON(message: AsymmetricDecryptResponse): unknown {
    const obj: any = {};
    if (message.plaintext.length !== 0) {
      obj.plaintext = base64FromBytes(message.plaintext);
    }
    if (message.plaintextCrc32c !== undefined) {
      obj.plaintextCrc32c = message.plaintextCrc32c;
    }
    if (message.verifiedCiphertextCrc32c !== false) {
      obj.verifiedCiphertextCrc32c = message.verifiedCiphertextCrc32c;
    }
    if (message.protectionLevel !== 0) {
      obj.protectionLevel = protectionLevelToJSON(message.protectionLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<AsymmetricDecryptResponse>): AsymmetricDecryptResponse {
    return AsymmetricDecryptResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AsymmetricDecryptResponse>): AsymmetricDecryptResponse {
    const message = createBaseAsymmetricDecryptResponse();
    message.plaintext = object.plaintext ?? Buffer.alloc(0);
    message.plaintextCrc32c = (object.plaintextCrc32c !== undefined && object.plaintextCrc32c !== null)
      ? Long.fromValue(object.plaintextCrc32c)
      : undefined;
    message.verifiedCiphertextCrc32c = object.verifiedCiphertextCrc32c ?? false;
    message.protectionLevel = object.protectionLevel ?? 0;
    return message;
  },
};

function createBaseMacSignResponse(): MacSignResponse {
  return { name: "", mac: Buffer.alloc(0), macCrc32c: undefined, verifiedDataCrc32c: false, protectionLevel: 0 };
}

export const MacSignResponse: MessageFns<MacSignResponse> = {
  encode(message: MacSignResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.mac.length !== 0) {
      writer.uint32(18).bytes(message.mac);
    }
    if (message.macCrc32c !== undefined) {
      Int64Value.encode({ value: message.macCrc32c! }, writer.uint32(26).fork()).join();
    }
    if (message.verifiedDataCrc32c !== false) {
      writer.uint32(32).bool(message.verifiedDataCrc32c);
    }
    if (message.protectionLevel !== 0) {
      writer.uint32(40).int32(message.protectionLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MacSignResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMacSignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mac = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.macCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.verifiedDataCrc32c = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.protectionLevel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MacSignResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      mac: isSet(object.mac) ? Buffer.from(bytesFromBase64(object.mac)) : Buffer.alloc(0),
      macCrc32c: isSet(object.macCrc32c) ? Long.fromValue(object.macCrc32c) : undefined,
      verifiedDataCrc32c: isSet(object.verifiedDataCrc32c) ? globalThis.Boolean(object.verifiedDataCrc32c) : false,
      protectionLevel: isSet(object.protectionLevel) ? protectionLevelFromJSON(object.protectionLevel) : 0,
    };
  },

  toJSON(message: MacSignResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.mac.length !== 0) {
      obj.mac = base64FromBytes(message.mac);
    }
    if (message.macCrc32c !== undefined) {
      obj.macCrc32c = message.macCrc32c;
    }
    if (message.verifiedDataCrc32c !== false) {
      obj.verifiedDataCrc32c = message.verifiedDataCrc32c;
    }
    if (message.protectionLevel !== 0) {
      obj.protectionLevel = protectionLevelToJSON(message.protectionLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<MacSignResponse>): MacSignResponse {
    return MacSignResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MacSignResponse>): MacSignResponse {
    const message = createBaseMacSignResponse();
    message.name = object.name ?? "";
    message.mac = object.mac ?? Buffer.alloc(0);
    message.macCrc32c = (object.macCrc32c !== undefined && object.macCrc32c !== null)
      ? Long.fromValue(object.macCrc32c)
      : undefined;
    message.verifiedDataCrc32c = object.verifiedDataCrc32c ?? false;
    message.protectionLevel = object.protectionLevel ?? 0;
    return message;
  },
};

function createBaseMacVerifyResponse(): MacVerifyResponse {
  return {
    name: "",
    success: false,
    verifiedDataCrc32c: false,
    verifiedMacCrc32c: false,
    verifiedSuccessIntegrity: false,
    protectionLevel: 0,
  };
}

export const MacVerifyResponse: MessageFns<MacVerifyResponse> = {
  encode(message: MacVerifyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.verifiedDataCrc32c !== false) {
      writer.uint32(24).bool(message.verifiedDataCrc32c);
    }
    if (message.verifiedMacCrc32c !== false) {
      writer.uint32(32).bool(message.verifiedMacCrc32c);
    }
    if (message.verifiedSuccessIntegrity !== false) {
      writer.uint32(40).bool(message.verifiedSuccessIntegrity);
    }
    if (message.protectionLevel !== 0) {
      writer.uint32(48).int32(message.protectionLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MacVerifyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMacVerifyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.verifiedDataCrc32c = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.verifiedMacCrc32c = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.verifiedSuccessIntegrity = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.protectionLevel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MacVerifyResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      verifiedDataCrc32c: isSet(object.verifiedDataCrc32c) ? globalThis.Boolean(object.verifiedDataCrc32c) : false,
      verifiedMacCrc32c: isSet(object.verifiedMacCrc32c) ? globalThis.Boolean(object.verifiedMacCrc32c) : false,
      verifiedSuccessIntegrity: isSet(object.verifiedSuccessIntegrity)
        ? globalThis.Boolean(object.verifiedSuccessIntegrity)
        : false,
      protectionLevel: isSet(object.protectionLevel) ? protectionLevelFromJSON(object.protectionLevel) : 0,
    };
  },

  toJSON(message: MacVerifyResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.verifiedDataCrc32c !== false) {
      obj.verifiedDataCrc32c = message.verifiedDataCrc32c;
    }
    if (message.verifiedMacCrc32c !== false) {
      obj.verifiedMacCrc32c = message.verifiedMacCrc32c;
    }
    if (message.verifiedSuccessIntegrity !== false) {
      obj.verifiedSuccessIntegrity = message.verifiedSuccessIntegrity;
    }
    if (message.protectionLevel !== 0) {
      obj.protectionLevel = protectionLevelToJSON(message.protectionLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<MacVerifyResponse>): MacVerifyResponse {
    return MacVerifyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MacVerifyResponse>): MacVerifyResponse {
    const message = createBaseMacVerifyResponse();
    message.name = object.name ?? "";
    message.success = object.success ?? false;
    message.verifiedDataCrc32c = object.verifiedDataCrc32c ?? false;
    message.verifiedMacCrc32c = object.verifiedMacCrc32c ?? false;
    message.verifiedSuccessIntegrity = object.verifiedSuccessIntegrity ?? false;
    message.protectionLevel = object.protectionLevel ?? 0;
    return message;
  },
};

function createBaseGenerateRandomBytesResponse(): GenerateRandomBytesResponse {
  return { data: Buffer.alloc(0), dataCrc32c: undefined };
}

export const GenerateRandomBytesResponse: MessageFns<GenerateRandomBytesResponse> = {
  encode(message: GenerateRandomBytesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.dataCrc32c !== undefined) {
      Int64Value.encode({ value: message.dataCrc32c! }, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateRandomBytesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateRandomBytesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dataCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateRandomBytesResponse {
    return {
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      dataCrc32c: isSet(object.dataCrc32c) ? Long.fromValue(object.dataCrc32c) : undefined,
    };
  },

  toJSON(message: GenerateRandomBytesResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.dataCrc32c !== undefined) {
      obj.dataCrc32c = message.dataCrc32c;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateRandomBytesResponse>): GenerateRandomBytesResponse {
    return GenerateRandomBytesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateRandomBytesResponse>): GenerateRandomBytesResponse {
    const message = createBaseGenerateRandomBytesResponse();
    message.data = object.data ?? Buffer.alloc(0);
    message.dataCrc32c = (object.dataCrc32c !== undefined && object.dataCrc32c !== null)
      ? Long.fromValue(object.dataCrc32c)
      : undefined;
    return message;
  },
};

function createBaseDigest(): Digest {
  return { sha256: undefined, sha384: undefined, sha512: undefined };
}

export const Digest: MessageFns<Digest> = {
  encode(message: Digest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sha256 !== undefined) {
      writer.uint32(10).bytes(message.sha256);
    }
    if (message.sha384 !== undefined) {
      writer.uint32(18).bytes(message.sha384);
    }
    if (message.sha512 !== undefined) {
      writer.uint32(26).bytes(message.sha512);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Digest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDigest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sha256 = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sha384 = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sha512 = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Digest {
    return {
      sha256: isSet(object.sha256) ? Buffer.from(bytesFromBase64(object.sha256)) : undefined,
      sha384: isSet(object.sha384) ? Buffer.from(bytesFromBase64(object.sha384)) : undefined,
      sha512: isSet(object.sha512) ? Buffer.from(bytesFromBase64(object.sha512)) : undefined,
    };
  },

  toJSON(message: Digest): unknown {
    const obj: any = {};
    if (message.sha256 !== undefined) {
      obj.sha256 = base64FromBytes(message.sha256);
    }
    if (message.sha384 !== undefined) {
      obj.sha384 = base64FromBytes(message.sha384);
    }
    if (message.sha512 !== undefined) {
      obj.sha512 = base64FromBytes(message.sha512);
    }
    return obj;
  },

  create(base?: DeepPartial<Digest>): Digest {
    return Digest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Digest>): Digest {
    const message = createBaseDigest();
    message.sha256 = object.sha256 ?? undefined;
    message.sha384 = object.sha384 ?? undefined;
    message.sha512 = object.sha512 ?? undefined;
    return message;
  },
};

function createBaseLocationMetadata(): LocationMetadata {
  return { hsmAvailable: false, ekmAvailable: false };
}

export const LocationMetadata: MessageFns<LocationMetadata> = {
  encode(message: LocationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hsmAvailable !== false) {
      writer.uint32(8).bool(message.hsmAvailable);
    }
    if (message.ekmAvailable !== false) {
      writer.uint32(16).bool(message.ekmAvailable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.hsmAvailable = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ekmAvailable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationMetadata {
    return {
      hsmAvailable: isSet(object.hsmAvailable) ? globalThis.Boolean(object.hsmAvailable) : false,
      ekmAvailable: isSet(object.ekmAvailable) ? globalThis.Boolean(object.ekmAvailable) : false,
    };
  },

  toJSON(message: LocationMetadata): unknown {
    const obj: any = {};
    if (message.hsmAvailable !== false) {
      obj.hsmAvailable = message.hsmAvailable;
    }
    if (message.ekmAvailable !== false) {
      obj.ekmAvailable = message.ekmAvailable;
    }
    return obj;
  },

  create(base?: DeepPartial<LocationMetadata>): LocationMetadata {
    return LocationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationMetadata>): LocationMetadata {
    const message = createBaseLocationMetadata();
    message.hsmAvailable = object.hsmAvailable ?? false;
    message.ekmAvailable = object.ekmAvailable ?? false;
    return message;
  },
};

/**
 * Google Cloud Key Management Service
 *
 * Manages cryptographic keys and operations using those keys. Implements a REST
 * model with the following objects:
 *
 * * [KeyRing][google.cloud.kms.v1.KeyRing]
 * * [CryptoKey][google.cloud.kms.v1.CryptoKey]
 * * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
 * * [ImportJob][google.cloud.kms.v1.ImportJob]
 *
 * If you are using manual gRPC libraries, see
 * [Using gRPC with Cloud KMS](https://cloud.google.com/kms/docs/grpc).
 */
export type KeyManagementServiceDefinition = typeof KeyManagementServiceDefinition;
export const KeyManagementServiceDefinition = {
  name: "KeyManagementService",
  fullName: "google.cloud.kms.v1.KeyManagementService",
  methods: {
    /** Lists [KeyRings][google.cloud.kms.v1.KeyRing]. */
    listKeyRings: {
      name: "ListKeyRings",
      requestType: ListKeyRingsRequest,
      requestStream: false,
      responseType: ListKeyRingsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists [CryptoKeys][google.cloud.kms.v1.CryptoKey]. */
    listCryptoKeys: {
      name: "ListCryptoKeys",
      requestType: ListCryptoKeysRequest,
      requestStream: false,
      responseType: ListCryptoKeysResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]. */
    listCryptoKeyVersions: {
      name: "ListCryptoKeyVersions",
      requestType: ListCryptoKeyVersionsRequest,
      requestStream: false,
      responseType: ListCryptoKeyVersionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              79,
              18,
              77,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              125,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists [ImportJobs][google.cloud.kms.v1.ImportJob]. */
    listImportJobs: {
      name: "ListImportJobs",
      requestType: ListImportJobsRequest,
      requestStream: false,
      responseType: ListImportJobsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns metadata for a given [KeyRing][google.cloud.kms.v1.KeyRing]. */
    getKeyRing: {
      name: "GetKeyRing",
      requestType: GetKeyRingRequest,
      requestStream: false,
      responseType: KeyRing,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Returns metadata for a given [CryptoKey][google.cloud.kms.v1.CryptoKey], as
     * well as its [primary][google.cloud.kms.v1.CryptoKey.primary]
     * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
     */
    getCryptoKey: {
      name: "GetCryptoKey",
      requestType: GetCryptoKeyRequest,
      requestStream: false,
      responseType: CryptoKey,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Returns metadata for a given
     * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
     */
    getCryptoKeyVersion: {
      name: "GetCryptoKeyVersion",
      requestType: GetCryptoKeyVersionRequest,
      requestStream: false,
      responseType: CryptoKeyVersion,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              79,
              18,
              77,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Returns the public key for the given
     * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. The
     * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
     * [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN]
     * or
     * [ASYMMETRIC_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_DECRYPT].
     */
    getPublicKey: {
      name: "GetPublicKey",
      requestType: GetPublicKeyRequest,
      requestStream: false,
      responseType: PublicKey,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              89,
              18,
              87,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              117,
              98,
              108,
              105,
              99,
              75,
              101,
              121,
            ]),
          ],
        },
      },
    },
    /** Returns metadata for a given [ImportJob][google.cloud.kms.v1.ImportJob]. */
    getImportJob: {
      name: "GetImportJob",
      requestType: GetImportJobRequest,
      requestStream: false,
      responseType: ImportJob,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Create a new [KeyRing][google.cloud.kms.v1.KeyRing] in a given Project and
     * Location.
     */
    createKeyRing: {
      name: "CreateKeyRing",
      requestType: CreateKeyRingRequest,
      requestStream: false,
      responseType: KeyRing,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              27,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              107,
              101,
              121,
              95,
              114,
              105,
              110,
              103,
              95,
              105,
              100,
              44,
              107,
              101,
              121,
              95,
              114,
              105,
              110,
              103,
            ]),
          ],
          578365826: [
            Buffer.from([
              56,
              58,
              8,
              107,
              101,
              121,
              95,
              114,
              105,
              110,
              103,
              34,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Create a new [CryptoKey][google.cloud.kms.v1.CryptoKey] within a
     * [KeyRing][google.cloud.kms.v1.KeyRing].
     *
     * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] and
     * [CryptoKey.version_template.algorithm][google.cloud.kms.v1.CryptoKeyVersionTemplate.algorithm]
     * are required.
     */
    createCryptoKey: {
      name: "CreateCryptoKey",
      requestType: CreateCryptoKeyRequest,
      requestStream: false,
      responseType: CryptoKey,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              114,
              121,
              112,
              116,
              111,
              95,
              107,
              101,
              121,
              95,
              105,
              100,
              44,
              99,
              114,
              121,
              112,
              116,
              111,
              95,
              107,
              101,
              121,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              10,
              99,
              114,
              121,
              112,
              116,
              111,
              95,
              107,
              101,
              121,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Create a new [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in a
     * [CryptoKey][google.cloud.kms.v1.CryptoKey].
     *
     * The server will assign the next sequential id. If unset,
     * [state][google.cloud.kms.v1.CryptoKeyVersion.state] will be set to
     * [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED].
     */
    createCryptoKeyVersion: {
      name: "CreateCryptoKeyVersion",
      requestType: CreateCryptoKeyVersionRequest,
      requestStream: false,
      responseType: CryptoKeyVersion,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              25,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              114,
              121,
              112,
              116,
              111,
              95,
              107,
              101,
              121,
              95,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              99,
              58,
              18,
              99,
              114,
              121,
              112,
              116,
              111,
              95,
              107,
              101,
              121,
              95,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              34,
              77,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              125,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Import wrapped key material into a
     * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
     *
     * All requests must specify a [CryptoKey][google.cloud.kms.v1.CryptoKey]. If
     * a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] is additionally
     * specified in the request, key material will be reimported into that
     * version. Otherwise, a new version will be created, and will be assigned the
     * next sequential id within the [CryptoKey][google.cloud.kms.v1.CryptoKey].
     */
    importCryptoKeyVersion: {
      name: "ImportCryptoKeyVersion",
      requestType: ImportCryptoKeyVersionRequest,
      requestStream: false,
      responseType: CryptoKeyVersion,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              89,
              58,
              1,
              42,
              34,
              84,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              125,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              58,
              105,
              109,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Create a new [ImportJob][google.cloud.kms.v1.ImportJob] within a
     * [KeyRing][google.cloud.kms.v1.KeyRing].
     *
     * [ImportJob.import_method][google.cloud.kms.v1.ImportJob.import_method] is
     * required.
     */
    createImportJob: {
      name: "CreateImportJob",
      requestType: CreateImportJobRequest,
      requestStream: false,
      responseType: ImportJob,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              105,
              109,
              112,
              111,
              114,
              116,
              95,
              106,
              111,
              98,
              95,
              105,
              100,
              44,
              105,
              109,
              112,
              111,
              114,
              116,
              95,
              106,
              111,
              98,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              10,
              105,
              109,
              112,
              111,
              114,
              116,
              95,
              106,
              111,
              98,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
            ]),
          ],
        },
      },
    },
    /** Update a [CryptoKey][google.cloud.kms.v1.CryptoKey]. */
    updateCryptoKey: {
      name: "UpdateCryptoKey",
      requestType: UpdateCryptoKeyRequest,
      requestStream: false,
      responseType: CryptoKey,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              99,
              114,
              121,
              112,
              116,
              111,
              95,
              107,
              101,
              121,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              82,
              58,
              10,
              99,
              114,
              121,
              112,
              116,
              111,
              95,
              107,
              101,
              121,
              50,
              68,
              47,
              118,
              49,
              47,
              123,
              99,
              114,
              121,
              112,
              116,
              111,
              95,
              107,
              101,
              121,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Update a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s
     * metadata.
     *
     * [state][google.cloud.kms.v1.CryptoKeyVersion.state] may be changed between
     * [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
     * and
     * [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED]
     * using this method. See
     * [DestroyCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion]
     * and
     * [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
     * to move between other states.
     */
    updateCryptoKeyVersion: {
      name: "UpdateCryptoKeyVersion",
      requestType: UpdateCryptoKeyVersionRequest,
      requestStream: false,
      responseType: CryptoKeyVersion,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              30,
              99,
              114,
              121,
              112,
              116,
              111,
              95,
              107,
              101,
              121,
              95,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              118,
              58,
              18,
              99,
              114,
              121,
              112,
              116,
              111,
              95,
              107,
              101,
              121,
              95,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              50,
              96,
              47,
              118,
              49,
              47,
              123,
              99,
              114,
              121,
              112,
              116,
              111,
              95,
              107,
              101,
              121,
              95,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Update the version of a [CryptoKey][google.cloud.kms.v1.CryptoKey] that
     * will be used in
     * [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
     *
     * Returns an error if called on a key whose purpose is not
     * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
     */
    updateCryptoKeyPrimaryVersion: {
      name: "UpdateCryptoKeyPrimaryVersion",
      requestType: UpdateCryptoKeyPrimaryVersionRequest,
      requestStream: false,
      responseType: CryptoKey,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              26,
              110,
              97,
              109,
              101,
              44,
              99,
              114,
              121,
              112,
              116,
              111,
              95,
              107,
              101,
              121,
              95,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              83,
              58,
              1,
              42,
              34,
              78,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              125,
              58,
              117,
              112,
              100,
              97,
              116,
              101,
              80,
              114,
              105,
              109,
              97,
              114,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * Schedule a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] for
     * destruction.
     *
     * Upon calling this method,
     * [CryptoKeyVersion.state][google.cloud.kms.v1.CryptoKeyVersion.state] will
     * be set to
     * [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED],
     * and [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] will
     * be set to the time
     * [destroy_scheduled_duration][google.cloud.kms.v1.CryptoKey.destroy_scheduled_duration]
     * in the future. At that time, the
     * [state][google.cloud.kms.v1.CryptoKeyVersion.state] will automatically
     * change to
     * [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED],
     * and the key material will be irrevocably destroyed.
     *
     * Before the
     * [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] is
     * reached,
     * [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
     * may be called to reverse the process.
     */
    destroyCryptoKeyVersion: {
      name: "DestroyCryptoKeyVersion",
      requestType: DestroyCryptoKeyVersionRequest,
      requestStream: false,
      responseType: CryptoKeyVersion,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              90,
              58,
              1,
              42,
              34,
              85,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              100,
              101,
              115,
              116,
              114,
              111,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Restore a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in the
     * [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]
     * state.
     *
     * Upon restoration of the CryptoKeyVersion,
     * [state][google.cloud.kms.v1.CryptoKeyVersion.state] will be set to
     * [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED],
     * and [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] will
     * be cleared.
     */
    restoreCryptoKeyVersion: {
      name: "RestoreCryptoKeyVersion",
      requestType: RestoreCryptoKeyVersionRequest,
      requestStream: false,
      responseType: CryptoKeyVersion,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              90,
              58,
              1,
              42,
              34,
              85,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              115,
              116,
              111,
              114,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Encrypts data, so that it can only be recovered by a call to
     * [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt]. The
     * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
     * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
     */
    encrypt: {
      name: "Encrypt",
      requestType: EncryptRequest,
      requestStream: false,
      responseType: EncryptResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([14, 110, 97, 109, 101, 44, 112, 108, 97, 105, 110, 116, 101, 120, 116])],
          578365826: [
            Buffer.from([
              71,
              58,
              1,
              42,
              34,
              66,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              42,
              125,
              58,
              101,
              110,
              99,
              114,
              121,
              112,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Decrypts data that was protected by
     * [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt]. The
     * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
     * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
     */
    decrypt: {
      name: "Decrypt",
      requestType: DecryptRequest,
      requestStream: false,
      responseType: DecryptResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 110, 97, 109, 101, 44, 99, 105, 112, 104, 101, 114, 116, 101, 120, 116])],
          578365826: [
            Buffer.from([
              70,
              58,
              1,
              42,
              34,
              65,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              125,
              58,
              100,
              101,
              99,
              114,
              121,
              112,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Encrypts data using portable cryptographic primitives. Most users should
     * choose [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] and
     * [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt] rather than
     * their raw counterparts. The
     * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
     * [RAW_ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT].
     */
    rawEncrypt: {
      name: "RawEncrypt",
      requestType: RawEncryptRequest,
      requestStream: false,
      responseType: RawEncryptResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              93,
              58,
              1,
              42,
              34,
              88,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              114,
              97,
              119,
              69,
              110,
              99,
              114,
              121,
              112,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Decrypts data that was originally encrypted using a raw cryptographic
     * mechanism. The [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
     * must be
     * [RAW_ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT].
     */
    rawDecrypt: {
      name: "RawDecrypt",
      requestType: RawDecryptRequest,
      requestStream: false,
      responseType: RawDecryptResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              93,
              58,
              1,
              42,
              34,
              88,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              114,
              97,
              119,
              68,
              101,
              99,
              114,
              121,
              112,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Signs data using a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
     * with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
     * ASYMMETRIC_SIGN, producing a signature that can be verified with the public
     * key retrieved from
     * [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
     */
    asymmetricSign: {
      name: "AsymmetricSign",
      requestType: AsymmetricSignRequest,
      requestStream: false,
      responseType: AsymmetricSignResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([11, 110, 97, 109, 101, 44, 100, 105, 103, 101, 115, 116])],
          578365826: [
            Buffer.from([
              97,
              58,
              1,
              42,
              34,
              92,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              97,
              115,
              121,
              109,
              109,
              101,
              116,
              114,
              105,
              99,
              83,
              105,
              103,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * Decrypts data that was encrypted with a public key retrieved from
     * [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey]
     * corresponding to a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
     * with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
     * ASYMMETRIC_DECRYPT.
     */
    asymmetricDecrypt: {
      name: "AsymmetricDecrypt",
      requestType: AsymmetricDecryptRequest,
      requestStream: false,
      responseType: AsymmetricDecryptResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 110, 97, 109, 101, 44, 99, 105, 112, 104, 101, 114, 116, 101, 120, 116])],
          578365826: [
            Buffer.from([
              100,
              58,
              1,
              42,
              34,
              95,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              97,
              115,
              121,
              109,
              109,
              101,
              116,
              114,
              105,
              99,
              68,
              101,
              99,
              114,
              121,
              112,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Signs data using a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
     * with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] MAC,
     * producing a tag that can be verified by another source with the same key.
     */
    macSign: {
      name: "MacSign",
      requestType: MacSignRequest,
      requestStream: false,
      responseType: MacSignResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([9, 110, 97, 109, 101, 44, 100, 97, 116, 97])],
          578365826: [
            Buffer.from([
              90,
              58,
              1,
              42,
              34,
              85,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              109,
              97,
              99,
              83,
              105,
              103,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * Verifies MAC tag using a
     * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
     * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] MAC, and returns
     * a response that indicates whether or not the verification was successful.
     */
    macVerify: {
      name: "MacVerify",
      requestType: MacVerifyRequest,
      requestStream: false,
      responseType: MacVerifyResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([13, 110, 97, 109, 101, 44, 100, 97, 116, 97, 44, 109, 97, 99])],
          578365826: [
            Buffer.from([
              92,
              58,
              1,
              42,
              34,
              87,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              82,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              115,
              47,
              42,
              47,
              99,
              114,
              121,
              112,
              116,
              111,
              75,
              101,
              121,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              109,
              97,
              99,
              86,
              101,
              114,
              105,
              102,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Generate random bytes using the Cloud KMS randomness source in the provided
     * location.
     */
    generateRandomBytes: {
      name: "GenerateRandomBytes",
      requestType: GenerateRandomBytesRequest,
      requestStream: false,
      responseType: GenerateRandomBytesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              38,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              44,
              108,
              101,
              110,
              103,
              116,
              104,
              95,
              98,
              121,
              116,
              101,
              115,
              44,
              112,
              114,
              111,
              116,
              101,
              99,
              116,
              105,
              111,
              110,
              95,
              108,
              101,
              118,
              101,
              108,
            ]),
          ],
          578365826: [
            Buffer.from([
              62,
              58,
              1,
              42,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              82,
              97,
              110,
              100,
              111,
              109,
              66,
              121,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface KeyManagementServiceImplementation<CallContextExt = {}> {
  /** Lists [KeyRings][google.cloud.kms.v1.KeyRing]. */
  listKeyRings(
    request: ListKeyRingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListKeyRingsResponse>>;
  /** Lists [CryptoKeys][google.cloud.kms.v1.CryptoKey]. */
  listCryptoKeys(
    request: ListCryptoKeysRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCryptoKeysResponse>>;
  /** Lists [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]. */
  listCryptoKeyVersions(
    request: ListCryptoKeyVersionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCryptoKeyVersionsResponse>>;
  /** Lists [ImportJobs][google.cloud.kms.v1.ImportJob]. */
  listImportJobs(
    request: ListImportJobsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListImportJobsResponse>>;
  /** Returns metadata for a given [KeyRing][google.cloud.kms.v1.KeyRing]. */
  getKeyRing(request: GetKeyRingRequest, context: CallContext & CallContextExt): Promise<DeepPartial<KeyRing>>;
  /**
   * Returns metadata for a given [CryptoKey][google.cloud.kms.v1.CryptoKey], as
   * well as its [primary][google.cloud.kms.v1.CryptoKey.primary]
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   */
  getCryptoKey(request: GetCryptoKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<CryptoKey>>;
  /**
   * Returns metadata for a given
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   */
  getCryptoKeyVersion(
    request: GetCryptoKeyVersionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CryptoKeyVersion>>;
  /**
   * Returns the public key for the given
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. The
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
   * [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN]
   * or
   * [ASYMMETRIC_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_DECRYPT].
   */
  getPublicKey(request: GetPublicKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<PublicKey>>;
  /** Returns metadata for a given [ImportJob][google.cloud.kms.v1.ImportJob]. */
  getImportJob(request: GetImportJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ImportJob>>;
  /**
   * Create a new [KeyRing][google.cloud.kms.v1.KeyRing] in a given Project and
   * Location.
   */
  createKeyRing(request: CreateKeyRingRequest, context: CallContext & CallContextExt): Promise<DeepPartial<KeyRing>>;
  /**
   * Create a new [CryptoKey][google.cloud.kms.v1.CryptoKey] within a
   * [KeyRing][google.cloud.kms.v1.KeyRing].
   *
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] and
   * [CryptoKey.version_template.algorithm][google.cloud.kms.v1.CryptoKeyVersionTemplate.algorithm]
   * are required.
   */
  createCryptoKey(
    request: CreateCryptoKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CryptoKey>>;
  /**
   * Create a new [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in a
   * [CryptoKey][google.cloud.kms.v1.CryptoKey].
   *
   * The server will assign the next sequential id. If unset,
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] will be set to
   * [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED].
   */
  createCryptoKeyVersion(
    request: CreateCryptoKeyVersionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CryptoKeyVersion>>;
  /**
   * Import wrapped key material into a
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   *
   * All requests must specify a [CryptoKey][google.cloud.kms.v1.CryptoKey]. If
   * a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] is additionally
   * specified in the request, key material will be reimported into that
   * version. Otherwise, a new version will be created, and will be assigned the
   * next sequential id within the [CryptoKey][google.cloud.kms.v1.CryptoKey].
   */
  importCryptoKeyVersion(
    request: ImportCryptoKeyVersionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CryptoKeyVersion>>;
  /**
   * Create a new [ImportJob][google.cloud.kms.v1.ImportJob] within a
   * [KeyRing][google.cloud.kms.v1.KeyRing].
   *
   * [ImportJob.import_method][google.cloud.kms.v1.ImportJob.import_method] is
   * required.
   */
  createImportJob(
    request: CreateImportJobRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ImportJob>>;
  /** Update a [CryptoKey][google.cloud.kms.v1.CryptoKey]. */
  updateCryptoKey(
    request: UpdateCryptoKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CryptoKey>>;
  /**
   * Update a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s
   * metadata.
   *
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] may be changed between
   * [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
   * and
   * [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED]
   * using this method. See
   * [DestroyCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion]
   * and
   * [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
   * to move between other states.
   */
  updateCryptoKeyVersion(
    request: UpdateCryptoKeyVersionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CryptoKeyVersion>>;
  /**
   * Update the version of a [CryptoKey][google.cloud.kms.v1.CryptoKey] that
   * will be used in
   * [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
   *
   * Returns an error if called on a key whose purpose is not
   * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
   */
  updateCryptoKeyPrimaryVersion(
    request: UpdateCryptoKeyPrimaryVersionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CryptoKey>>;
  /**
   * Schedule a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] for
   * destruction.
   *
   * Upon calling this method,
   * [CryptoKeyVersion.state][google.cloud.kms.v1.CryptoKeyVersion.state] will
   * be set to
   * [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED],
   * and [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] will
   * be set to the time
   * [destroy_scheduled_duration][google.cloud.kms.v1.CryptoKey.destroy_scheduled_duration]
   * in the future. At that time, the
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] will automatically
   * change to
   * [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED],
   * and the key material will be irrevocably destroyed.
   *
   * Before the
   * [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] is
   * reached,
   * [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
   * may be called to reverse the process.
   */
  destroyCryptoKeyVersion(
    request: DestroyCryptoKeyVersionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CryptoKeyVersion>>;
  /**
   * Restore a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in the
   * [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]
   * state.
   *
   * Upon restoration of the CryptoKeyVersion,
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] will be set to
   * [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED],
   * and [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] will
   * be cleared.
   */
  restoreCryptoKeyVersion(
    request: RestoreCryptoKeyVersionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CryptoKeyVersion>>;
  /**
   * Encrypts data, so that it can only be recovered by a call to
   * [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt]. The
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
   * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
   */
  encrypt(request: EncryptRequest, context: CallContext & CallContextExt): Promise<DeepPartial<EncryptResponse>>;
  /**
   * Decrypts data that was protected by
   * [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt]. The
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
   * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
   */
  decrypt(request: DecryptRequest, context: CallContext & CallContextExt): Promise<DeepPartial<DecryptResponse>>;
  /**
   * Encrypts data using portable cryptographic primitives. Most users should
   * choose [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] and
   * [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt] rather than
   * their raw counterparts. The
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
   * [RAW_ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT].
   */
  rawEncrypt(
    request: RawEncryptRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RawEncryptResponse>>;
  /**
   * Decrypts data that was originally encrypted using a raw cryptographic
   * mechanism. The [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
   * must be
   * [RAW_ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT].
   */
  rawDecrypt(
    request: RawDecryptRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RawDecryptResponse>>;
  /**
   * Signs data using a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
   * with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
   * ASYMMETRIC_SIGN, producing a signature that can be verified with the public
   * key retrieved from
   * [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
   */
  asymmetricSign(
    request: AsymmetricSignRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AsymmetricSignResponse>>;
  /**
   * Decrypts data that was encrypted with a public key retrieved from
   * [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey]
   * corresponding to a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
   * with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
   * ASYMMETRIC_DECRYPT.
   */
  asymmetricDecrypt(
    request: AsymmetricDecryptRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AsymmetricDecryptResponse>>;
  /**
   * Signs data using a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
   * with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] MAC,
   * producing a tag that can be verified by another source with the same key.
   */
  macSign(request: MacSignRequest, context: CallContext & CallContextExt): Promise<DeepPartial<MacSignResponse>>;
  /**
   * Verifies MAC tag using a
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] MAC, and returns
   * a response that indicates whether or not the verification was successful.
   */
  macVerify(request: MacVerifyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<MacVerifyResponse>>;
  /**
   * Generate random bytes using the Cloud KMS randomness source in the provided
   * location.
   */
  generateRandomBytes(
    request: GenerateRandomBytesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateRandomBytesResponse>>;
}

export interface KeyManagementServiceClient<CallOptionsExt = {}> {
  /** Lists [KeyRings][google.cloud.kms.v1.KeyRing]. */
  listKeyRings(
    request: DeepPartial<ListKeyRingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListKeyRingsResponse>;
  /** Lists [CryptoKeys][google.cloud.kms.v1.CryptoKey]. */
  listCryptoKeys(
    request: DeepPartial<ListCryptoKeysRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCryptoKeysResponse>;
  /** Lists [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]. */
  listCryptoKeyVersions(
    request: DeepPartial<ListCryptoKeyVersionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCryptoKeyVersionsResponse>;
  /** Lists [ImportJobs][google.cloud.kms.v1.ImportJob]. */
  listImportJobs(
    request: DeepPartial<ListImportJobsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListImportJobsResponse>;
  /** Returns metadata for a given [KeyRing][google.cloud.kms.v1.KeyRing]. */
  getKeyRing(request: DeepPartial<GetKeyRingRequest>, options?: CallOptions & CallOptionsExt): Promise<KeyRing>;
  /**
   * Returns metadata for a given [CryptoKey][google.cloud.kms.v1.CryptoKey], as
   * well as its [primary][google.cloud.kms.v1.CryptoKey.primary]
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   */
  getCryptoKey(request: DeepPartial<GetCryptoKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<CryptoKey>;
  /**
   * Returns metadata for a given
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   */
  getCryptoKeyVersion(
    request: DeepPartial<GetCryptoKeyVersionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CryptoKeyVersion>;
  /**
   * Returns the public key for the given
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. The
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
   * [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN]
   * or
   * [ASYMMETRIC_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_DECRYPT].
   */
  getPublicKey(request: DeepPartial<GetPublicKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<PublicKey>;
  /** Returns metadata for a given [ImportJob][google.cloud.kms.v1.ImportJob]. */
  getImportJob(request: DeepPartial<GetImportJobRequest>, options?: CallOptions & CallOptionsExt): Promise<ImportJob>;
  /**
   * Create a new [KeyRing][google.cloud.kms.v1.KeyRing] in a given Project and
   * Location.
   */
  createKeyRing(request: DeepPartial<CreateKeyRingRequest>, options?: CallOptions & CallOptionsExt): Promise<KeyRing>;
  /**
   * Create a new [CryptoKey][google.cloud.kms.v1.CryptoKey] within a
   * [KeyRing][google.cloud.kms.v1.KeyRing].
   *
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] and
   * [CryptoKey.version_template.algorithm][google.cloud.kms.v1.CryptoKeyVersionTemplate.algorithm]
   * are required.
   */
  createCryptoKey(
    request: DeepPartial<CreateCryptoKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CryptoKey>;
  /**
   * Create a new [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in a
   * [CryptoKey][google.cloud.kms.v1.CryptoKey].
   *
   * The server will assign the next sequential id. If unset,
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] will be set to
   * [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED].
   */
  createCryptoKeyVersion(
    request: DeepPartial<CreateCryptoKeyVersionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CryptoKeyVersion>;
  /**
   * Import wrapped key material into a
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   *
   * All requests must specify a [CryptoKey][google.cloud.kms.v1.CryptoKey]. If
   * a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] is additionally
   * specified in the request, key material will be reimported into that
   * version. Otherwise, a new version will be created, and will be assigned the
   * next sequential id within the [CryptoKey][google.cloud.kms.v1.CryptoKey].
   */
  importCryptoKeyVersion(
    request: DeepPartial<ImportCryptoKeyVersionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CryptoKeyVersion>;
  /**
   * Create a new [ImportJob][google.cloud.kms.v1.ImportJob] within a
   * [KeyRing][google.cloud.kms.v1.KeyRing].
   *
   * [ImportJob.import_method][google.cloud.kms.v1.ImportJob.import_method] is
   * required.
   */
  createImportJob(
    request: DeepPartial<CreateImportJobRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ImportJob>;
  /** Update a [CryptoKey][google.cloud.kms.v1.CryptoKey]. */
  updateCryptoKey(
    request: DeepPartial<UpdateCryptoKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CryptoKey>;
  /**
   * Update a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s
   * metadata.
   *
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] may be changed between
   * [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
   * and
   * [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED]
   * using this method. See
   * [DestroyCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion]
   * and
   * [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
   * to move between other states.
   */
  updateCryptoKeyVersion(
    request: DeepPartial<UpdateCryptoKeyVersionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CryptoKeyVersion>;
  /**
   * Update the version of a [CryptoKey][google.cloud.kms.v1.CryptoKey] that
   * will be used in
   * [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
   *
   * Returns an error if called on a key whose purpose is not
   * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
   */
  updateCryptoKeyPrimaryVersion(
    request: DeepPartial<UpdateCryptoKeyPrimaryVersionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CryptoKey>;
  /**
   * Schedule a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] for
   * destruction.
   *
   * Upon calling this method,
   * [CryptoKeyVersion.state][google.cloud.kms.v1.CryptoKeyVersion.state] will
   * be set to
   * [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED],
   * and [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] will
   * be set to the time
   * [destroy_scheduled_duration][google.cloud.kms.v1.CryptoKey.destroy_scheduled_duration]
   * in the future. At that time, the
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] will automatically
   * change to
   * [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED],
   * and the key material will be irrevocably destroyed.
   *
   * Before the
   * [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] is
   * reached,
   * [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
   * may be called to reverse the process.
   */
  destroyCryptoKeyVersion(
    request: DeepPartial<DestroyCryptoKeyVersionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CryptoKeyVersion>;
  /**
   * Restore a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in the
   * [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]
   * state.
   *
   * Upon restoration of the CryptoKeyVersion,
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] will be set to
   * [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED],
   * and [destroy_time][google.cloud.kms.v1.CryptoKeyVersion.destroy_time] will
   * be cleared.
   */
  restoreCryptoKeyVersion(
    request: DeepPartial<RestoreCryptoKeyVersionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CryptoKeyVersion>;
  /**
   * Encrypts data, so that it can only be recovered by a call to
   * [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt]. The
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
   * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
   */
  encrypt(request: DeepPartial<EncryptRequest>, options?: CallOptions & CallOptionsExt): Promise<EncryptResponse>;
  /**
   * Decrypts data that was protected by
   * [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt]. The
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
   * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
   */
  decrypt(request: DeepPartial<DecryptRequest>, options?: CallOptions & CallOptionsExt): Promise<DecryptResponse>;
  /**
   * Encrypts data using portable cryptographic primitives. Most users should
   * choose [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] and
   * [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt] rather than
   * their raw counterparts. The
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] must be
   * [RAW_ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT].
   */
  rawEncrypt(
    request: DeepPartial<RawEncryptRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RawEncryptResponse>;
  /**
   * Decrypts data that was originally encrypted using a raw cryptographic
   * mechanism. The [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
   * must be
   * [RAW_ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT].
   */
  rawDecrypt(
    request: DeepPartial<RawDecryptRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RawDecryptResponse>;
  /**
   * Signs data using a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
   * with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
   * ASYMMETRIC_SIGN, producing a signature that can be verified with the public
   * key retrieved from
   * [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
   */
  asymmetricSign(
    request: DeepPartial<AsymmetricSignRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AsymmetricSignResponse>;
  /**
   * Decrypts data that was encrypted with a public key retrieved from
   * [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey]
   * corresponding to a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
   * with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
   * ASYMMETRIC_DECRYPT.
   */
  asymmetricDecrypt(
    request: DeepPartial<AsymmetricDecryptRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AsymmetricDecryptResponse>;
  /**
   * Signs data using a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
   * with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] MAC,
   * producing a tag that can be verified by another source with the same key.
   */
  macSign(request: DeepPartial<MacSignRequest>, options?: CallOptions & CallOptionsExt): Promise<MacSignResponse>;
  /**
   * Verifies MAC tag using a
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] MAC, and returns
   * a response that indicates whether or not the verification was successful.
   */
  macVerify(request: DeepPartial<MacVerifyRequest>, options?: CallOptions & CallOptionsExt): Promise<MacVerifyResponse>;
  /**
   * Generate random bytes using the Cloud KMS randomness source in the provided
   * location.
   */
  generateRandomBytes(
    request: DeepPartial<GenerateRandomBytesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateRandomBytesResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
