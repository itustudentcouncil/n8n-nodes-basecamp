// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/kms/v1/ekm_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.kms.v1";

/**
 * Request message for
 * [EkmService.ListEkmConnections][google.cloud.kms.v1.EkmService.ListEkmConnections].
 */
export interface ListEkmConnectionsRequest {
  /**
   * Required. The resource name of the location associated with the
   * [EkmConnections][google.cloud.kms.v1.EkmConnection] to list, in the format
   * `projects/* /locations/*`.
   */
  parent: string;
  /**
   * Optional. Optional limit on the number of
   * [EkmConnections][google.cloud.kms.v1.EkmConnection] to include in the
   * response. Further [EkmConnections][google.cloud.kms.v1.EkmConnection] can
   * subsequently be obtained by including the
   * [ListEkmConnectionsResponse.next_page_token][google.cloud.kms.v1.ListEkmConnectionsResponse.next_page_token]
   * in a subsequent request. If unspecified, the server will pick an
   * appropriate default.
   */
  pageSize: number;
  /**
   * Optional. Optional pagination token, returned earlier via
   * [ListEkmConnectionsResponse.next_page_token][google.cloud.kms.v1.ListEkmConnectionsResponse.next_page_token].
   */
  pageToken: string;
  /**
   * Optional. Only include resources that match the filter in the response. For
   * more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   */
  filter: string;
  /**
   * Optional. Specify how the results should be sorted. If not specified, the
   * results will be sorted in the default order.  For more information, see
   * [Sorting and filtering list
   * results](https://cloud.google.com/kms/docs/sorting-and-filtering).
   */
  orderBy: string;
}

/**
 * Response message for
 * [EkmService.ListEkmConnections][google.cloud.kms.v1.EkmService.ListEkmConnections].
 */
export interface ListEkmConnectionsResponse {
  /** The list of [EkmConnections][google.cloud.kms.v1.EkmConnection]. */
  ekmConnections: EkmConnection[];
  /**
   * A token to retrieve next page of results. Pass this value in
   * [ListEkmConnectionsRequest.page_token][google.cloud.kms.v1.ListEkmConnectionsRequest.page_token]
   * to retrieve the next page of results.
   */
  nextPageToken: string;
  /**
   * The total number of [EkmConnections][google.cloud.kms.v1.EkmConnection]
   * that matched the query.
   */
  totalSize: number;
}

/**
 * Request message for
 * [EkmService.GetEkmConnection][google.cloud.kms.v1.EkmService.GetEkmConnection].
 */
export interface GetEkmConnectionRequest {
  /**
   * Required. The [name][google.cloud.kms.v1.EkmConnection.name] of the
   * [EkmConnection][google.cloud.kms.v1.EkmConnection] to get.
   */
  name: string;
}

/**
 * Request message for
 * [EkmService.CreateEkmConnection][google.cloud.kms.v1.EkmService.CreateEkmConnection].
 */
export interface CreateEkmConnectionRequest {
  /**
   * Required. The resource name of the location associated with the
   * [EkmConnection][google.cloud.kms.v1.EkmConnection], in the format
   * `projects/* /locations/*`.
   */
  parent: string;
  /**
   * Required. It must be unique within a location and match the regular
   * expression `[a-zA-Z0-9_-]{1,63}`.
   */
  ekmConnectionId: string;
  /**
   * Required. An [EkmConnection][google.cloud.kms.v1.EkmConnection] with
   * initial field values.
   */
  ekmConnection: EkmConnection | undefined;
}

/**
 * Request message for
 * [EkmService.UpdateEkmConnection][google.cloud.kms.v1.EkmService.UpdateEkmConnection].
 */
export interface UpdateEkmConnectionRequest {
  /**
   * Required. [EkmConnection][google.cloud.kms.v1.EkmConnection] with updated
   * values.
   */
  ekmConnection:
    | EkmConnection
    | undefined;
  /** Required. List of fields to be updated in this request. */
  updateMask: string[] | undefined;
}

/**
 * Request message for
 * [EkmService.GetEkmConfig][google.cloud.kms.v1.EkmService.GetEkmConfig].
 */
export interface GetEkmConfigRequest {
  /**
   * Required. The [name][google.cloud.kms.v1.EkmConfig.name] of the
   * [EkmConfig][google.cloud.kms.v1.EkmConfig] to get.
   */
  name: string;
}

/**
 * Request message for
 * [EkmService.UpdateEkmConfig][google.cloud.kms.v1.EkmService.UpdateEkmConfig].
 */
export interface UpdateEkmConfigRequest {
  /** Required. [EkmConfig][google.cloud.kms.v1.EkmConfig] with updated values. */
  ekmConfig:
    | EkmConfig
    | undefined;
  /** Required. List of fields to be updated in this request. */
  updateMask: string[] | undefined;
}

/**
 * A [Certificate][google.cloud.kms.v1.Certificate] represents an X.509
 * certificate used to authenticate HTTPS connections to EKM replicas.
 */
export interface Certificate {
  /** Required. The raw certificate bytes in DER format. */
  rawDer: Buffer;
  /** Output only. True if the certificate was parsed successfully. */
  parsed: boolean;
  /**
   * Output only. The issuer distinguished name in RFC 2253 format. Only present
   * if [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
   */
  issuer: string;
  /**
   * Output only. The subject distinguished name in RFC 2253 format. Only
   * present if [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
   */
  subject: string;
  /**
   * Output only. The subject Alternative DNS names. Only present if
   * [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
   */
  subjectAlternativeDnsNames: string[];
  /**
   * Output only. The certificate is not valid before this time. Only present if
   * [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
   */
  notBeforeTime:
    | Date
    | undefined;
  /**
   * Output only. The certificate is not valid after this time. Only present if
   * [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
   */
  notAfterTime:
    | Date
    | undefined;
  /**
   * Output only. The certificate serial number as a hex string. Only present if
   * [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
   */
  serialNumber: string;
  /**
   * Output only. The SHA-256 certificate fingerprint as a hex string. Only
   * present if [parsed][google.cloud.kms.v1.Certificate.parsed] is true.
   */
  sha256Fingerprint: string;
}

/**
 * An [EkmConnection][google.cloud.kms.v1.EkmConnection] represents an
 * individual EKM connection. It can be used for creating
 * [CryptoKeys][google.cloud.kms.v1.CryptoKey] and
 * [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] with a
 * [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of
 * [EXTERNAL_VPC][CryptoKeyVersion.ProtectionLevel.EXTERNAL_VPC], as well as
 * performing cryptographic operations using keys created within the
 * [EkmConnection][google.cloud.kms.v1.EkmConnection].
 */
export interface EkmConnection {
  /**
   * Output only. The resource name for the
   * [EkmConnection][google.cloud.kms.v1.EkmConnection] in the format
   * `projects/* /locations/* /ekmConnections/*`.
   */
  name: string;
  /**
   * Output only. The time at which the
   * [EkmConnection][google.cloud.kms.v1.EkmConnection] was created.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Optional. A list of
   * [ServiceResolvers][google.cloud.kms.v1.EkmConnection.ServiceResolver] where
   * the EKM can be reached. There should be one ServiceResolver per EKM
   * replica. Currently, only a single
   * [ServiceResolver][google.cloud.kms.v1.EkmConnection.ServiceResolver] is
   * supported.
   */
  serviceResolvers: EkmConnection_ServiceResolver[];
  /**
   * Optional. Etag of the currently stored
   * [EkmConnection][google.cloud.kms.v1.EkmConnection].
   */
  etag: string;
  /**
   * Optional. Describes who can perform control plane operations on the EKM. If
   * unset, this defaults to
   * [MANUAL][google.cloud.kms.v1.EkmConnection.KeyManagementMode.MANUAL].
   */
  keyManagementMode: EkmConnection_KeyManagementMode;
  /**
   * Optional. Identifies the EKM Crypto Space that this
   * [EkmConnection][google.cloud.kms.v1.EkmConnection] maps to. Note: This
   * field is required if
   * [KeyManagementMode][google.cloud.kms.v1.EkmConnection.KeyManagementMode] is
   * [CLOUD_KMS][google.cloud.kms.v1.EkmConnection.KeyManagementMode.CLOUD_KMS].
   */
  cryptoSpacePath: string;
}

/**
 * [KeyManagementMode][google.cloud.kms.v1.EkmConnection.KeyManagementMode]
 * describes who can perform control plane cryptographic operations using this
 * [EkmConnection][google.cloud.kms.v1.EkmConnection].
 */
export enum EkmConnection_KeyManagementMode {
  /** KEY_MANAGEMENT_MODE_UNSPECIFIED - Not specified. */
  KEY_MANAGEMENT_MODE_UNSPECIFIED = 0,
  /**
   * MANUAL - EKM-side key management operations on
   * [CryptoKeys][google.cloud.kms.v1.CryptoKey] created with this
   * [EkmConnection][google.cloud.kms.v1.EkmConnection] must be initiated from
   * the EKM directly and cannot be performed from Cloud KMS. This means that:
   * * When creating a
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] associated with
   * this
   *   [EkmConnection][google.cloud.kms.v1.EkmConnection], the caller must
   *   supply the key path of pre-existing external key material that will be
   *   linked to the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   * * Destruction of external key material cannot be requested via the
   *   Cloud KMS API and must be performed directly in the EKM.
   * * Automatic rotation of key material is not supported.
   */
  MANUAL = 1,
  /**
   * CLOUD_KMS - All [CryptoKeys][google.cloud.kms.v1.CryptoKey] created with this
   * [EkmConnection][google.cloud.kms.v1.EkmConnection] use EKM-side key
   * management operations initiated from Cloud KMS. This means that:
   * * When a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
   * associated with this [EkmConnection][google.cloud.kms.v1.EkmConnection]
   * is
   *   created, the EKM automatically generates new key material and a new
   *   key path. The caller cannot supply the key path of pre-existing
   *   external key material.
   * * Destruction of external key material associated with this
   *   [EkmConnection][google.cloud.kms.v1.EkmConnection] can be requested by
   *   calling [DestroyCryptoKeyVersion][EkmService.DestroyCryptoKeyVersion].
   * * Automatic rotation of key material is supported.
   */
  CLOUD_KMS = 2,
  UNRECOGNIZED = -1,
}

export function ekmConnection_KeyManagementModeFromJSON(object: any): EkmConnection_KeyManagementMode {
  switch (object) {
    case 0:
    case "KEY_MANAGEMENT_MODE_UNSPECIFIED":
      return EkmConnection_KeyManagementMode.KEY_MANAGEMENT_MODE_UNSPECIFIED;
    case 1:
    case "MANUAL":
      return EkmConnection_KeyManagementMode.MANUAL;
    case 2:
    case "CLOUD_KMS":
      return EkmConnection_KeyManagementMode.CLOUD_KMS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EkmConnection_KeyManagementMode.UNRECOGNIZED;
  }
}

export function ekmConnection_KeyManagementModeToJSON(object: EkmConnection_KeyManagementMode): string {
  switch (object) {
    case EkmConnection_KeyManagementMode.KEY_MANAGEMENT_MODE_UNSPECIFIED:
      return "KEY_MANAGEMENT_MODE_UNSPECIFIED";
    case EkmConnection_KeyManagementMode.MANUAL:
      return "MANUAL";
    case EkmConnection_KeyManagementMode.CLOUD_KMS:
      return "CLOUD_KMS";
    case EkmConnection_KeyManagementMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A [ServiceResolver][google.cloud.kms.v1.EkmConnection.ServiceResolver]
 * represents an EKM replica that can be reached within an
 * [EkmConnection][google.cloud.kms.v1.EkmConnection].
 */
export interface EkmConnection_ServiceResolver {
  /**
   * Required. The resource name of the Service Directory service pointing to
   * an EKM replica, in the format
   * `projects/* /locations/* /namespaces/* /services/*`.
   */
  serviceDirectoryService: string;
  /**
   * Optional. The filter applied to the endpoints of the resolved service. If
   * no filter is specified, all endpoints will be considered. An endpoint
   * will be chosen arbitrarily from the filtered list for each request.
   *
   * For endpoint filter syntax and examples, see
   * https://cloud.google.com/service-directory/docs/reference/rpc/google.cloud.servicedirectory.v1#resolveservicerequest.
   */
  endpointFilter: string;
  /** Required. The hostname of the EKM replica used at TLS and HTTP layers. */
  hostname: string;
  /**
   * Required. A list of leaf server certificates used to authenticate HTTPS
   * connections to the EKM replica. Currently, a maximum of 10
   * [Certificate][google.cloud.kms.v1.Certificate] is supported.
   */
  serverCertificates: Certificate[];
}

/**
 * An [EkmConfig][google.cloud.kms.v1.EkmConfig] is a singleton resource that
 * represents configuration parameters that apply to all
 * [CryptoKeys][google.cloud.kms.v1.CryptoKey] and
 * [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] with a
 * [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of
 * [EXTERNAL_VPC][CryptoKeyVersion.ProtectionLevel.EXTERNAL_VPC] in a given
 * project and location.
 */
export interface EkmConfig {
  /**
   * Output only. The resource name for the
   * [EkmConfig][google.cloud.kms.v1.EkmConfig] in the format
   * `projects/* /locations/* /ekmConfig`.
   */
  name: string;
  /**
   * Optional. Resource name of the default
   * [EkmConnection][google.cloud.kms.v1.EkmConnection]. Setting this field to
   * the empty string removes the default.
   */
  defaultEkmConnection: string;
}

/**
 * Request message for
 * [EkmService.VerifyConnectivity][google.cloud.kms.v1.EkmService.VerifyConnectivity].
 */
export interface VerifyConnectivityRequest {
  /**
   * Required. The [name][google.cloud.kms.v1.EkmConnection.name] of the
   * [EkmConnection][google.cloud.kms.v1.EkmConnection] to verify.
   */
  name: string;
}

/**
 * Response message for
 * [EkmService.VerifyConnectivity][google.cloud.kms.v1.EkmService.VerifyConnectivity].
 */
export interface VerifyConnectivityResponse {
}

function createBaseListEkmConnectionsRequest(): ListEkmConnectionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListEkmConnectionsRequest: MessageFns<ListEkmConnectionsRequest> = {
  encode(message: ListEkmConnectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEkmConnectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEkmConnectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEkmConnectionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListEkmConnectionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEkmConnectionsRequest>): ListEkmConnectionsRequest {
    return ListEkmConnectionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEkmConnectionsRequest>): ListEkmConnectionsRequest {
    const message = createBaseListEkmConnectionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListEkmConnectionsResponse(): ListEkmConnectionsResponse {
  return { ekmConnections: [], nextPageToken: "", totalSize: 0 };
}

export const ListEkmConnectionsResponse: MessageFns<ListEkmConnectionsResponse> = {
  encode(message: ListEkmConnectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ekmConnections) {
      EkmConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEkmConnectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEkmConnectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ekmConnections.push(EkmConnection.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEkmConnectionsResponse {
    return {
      ekmConnections: globalThis.Array.isArray(object?.ekmConnections)
        ? object.ekmConnections.map((e: any) => EkmConnection.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListEkmConnectionsResponse): unknown {
    const obj: any = {};
    if (message.ekmConnections?.length) {
      obj.ekmConnections = message.ekmConnections.map((e) => EkmConnection.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListEkmConnectionsResponse>): ListEkmConnectionsResponse {
    return ListEkmConnectionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEkmConnectionsResponse>): ListEkmConnectionsResponse {
    const message = createBaseListEkmConnectionsResponse();
    message.ekmConnections = object.ekmConnections?.map((e) => EkmConnection.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseGetEkmConnectionRequest(): GetEkmConnectionRequest {
  return { name: "" };
}

export const GetEkmConnectionRequest: MessageFns<GetEkmConnectionRequest> = {
  encode(message: GetEkmConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEkmConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEkmConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEkmConnectionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetEkmConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetEkmConnectionRequest>): GetEkmConnectionRequest {
    return GetEkmConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEkmConnectionRequest>): GetEkmConnectionRequest {
    const message = createBaseGetEkmConnectionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateEkmConnectionRequest(): CreateEkmConnectionRequest {
  return { parent: "", ekmConnectionId: "", ekmConnection: undefined };
}

export const CreateEkmConnectionRequest: MessageFns<CreateEkmConnectionRequest> = {
  encode(message: CreateEkmConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.ekmConnectionId !== "") {
      writer.uint32(18).string(message.ekmConnectionId);
    }
    if (message.ekmConnection !== undefined) {
      EkmConnection.encode(message.ekmConnection, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEkmConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEkmConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ekmConnectionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ekmConnection = EkmConnection.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEkmConnectionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      ekmConnectionId: isSet(object.ekmConnectionId) ? globalThis.String(object.ekmConnectionId) : "",
      ekmConnection: isSet(object.ekmConnection) ? EkmConnection.fromJSON(object.ekmConnection) : undefined,
    };
  },

  toJSON(message: CreateEkmConnectionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.ekmConnectionId !== "") {
      obj.ekmConnectionId = message.ekmConnectionId;
    }
    if (message.ekmConnection !== undefined) {
      obj.ekmConnection = EkmConnection.toJSON(message.ekmConnection);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateEkmConnectionRequest>): CreateEkmConnectionRequest {
    return CreateEkmConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateEkmConnectionRequest>): CreateEkmConnectionRequest {
    const message = createBaseCreateEkmConnectionRequest();
    message.parent = object.parent ?? "";
    message.ekmConnectionId = object.ekmConnectionId ?? "";
    message.ekmConnection = (object.ekmConnection !== undefined && object.ekmConnection !== null)
      ? EkmConnection.fromPartial(object.ekmConnection)
      : undefined;
    return message;
  },
};

function createBaseUpdateEkmConnectionRequest(): UpdateEkmConnectionRequest {
  return { ekmConnection: undefined, updateMask: undefined };
}

export const UpdateEkmConnectionRequest: MessageFns<UpdateEkmConnectionRequest> = {
  encode(message: UpdateEkmConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ekmConnection !== undefined) {
      EkmConnection.encode(message.ekmConnection, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEkmConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEkmConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ekmConnection = EkmConnection.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEkmConnectionRequest {
    return {
      ekmConnection: isSet(object.ekmConnection) ? EkmConnection.fromJSON(object.ekmConnection) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateEkmConnectionRequest): unknown {
    const obj: any = {};
    if (message.ekmConnection !== undefined) {
      obj.ekmConnection = EkmConnection.toJSON(message.ekmConnection);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateEkmConnectionRequest>): UpdateEkmConnectionRequest {
    return UpdateEkmConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateEkmConnectionRequest>): UpdateEkmConnectionRequest {
    const message = createBaseUpdateEkmConnectionRequest();
    message.ekmConnection = (object.ekmConnection !== undefined && object.ekmConnection !== null)
      ? EkmConnection.fromPartial(object.ekmConnection)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetEkmConfigRequest(): GetEkmConfigRequest {
  return { name: "" };
}

export const GetEkmConfigRequest: MessageFns<GetEkmConfigRequest> = {
  encode(message: GetEkmConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEkmConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEkmConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEkmConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetEkmConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetEkmConfigRequest>): GetEkmConfigRequest {
    return GetEkmConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEkmConfigRequest>): GetEkmConfigRequest {
    const message = createBaseGetEkmConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateEkmConfigRequest(): UpdateEkmConfigRequest {
  return { ekmConfig: undefined, updateMask: undefined };
}

export const UpdateEkmConfigRequest: MessageFns<UpdateEkmConfigRequest> = {
  encode(message: UpdateEkmConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ekmConfig !== undefined) {
      EkmConfig.encode(message.ekmConfig, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEkmConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEkmConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ekmConfig = EkmConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEkmConfigRequest {
    return {
      ekmConfig: isSet(object.ekmConfig) ? EkmConfig.fromJSON(object.ekmConfig) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateEkmConfigRequest): unknown {
    const obj: any = {};
    if (message.ekmConfig !== undefined) {
      obj.ekmConfig = EkmConfig.toJSON(message.ekmConfig);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateEkmConfigRequest>): UpdateEkmConfigRequest {
    return UpdateEkmConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateEkmConfigRequest>): UpdateEkmConfigRequest {
    const message = createBaseUpdateEkmConfigRequest();
    message.ekmConfig = (object.ekmConfig !== undefined && object.ekmConfig !== null)
      ? EkmConfig.fromPartial(object.ekmConfig)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseCertificate(): Certificate {
  return {
    rawDer: Buffer.alloc(0),
    parsed: false,
    issuer: "",
    subject: "",
    subjectAlternativeDnsNames: [],
    notBeforeTime: undefined,
    notAfterTime: undefined,
    serialNumber: "",
    sha256Fingerprint: "",
  };
}

export const Certificate: MessageFns<Certificate> = {
  encode(message: Certificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rawDer.length !== 0) {
      writer.uint32(10).bytes(message.rawDer);
    }
    if (message.parsed !== false) {
      writer.uint32(16).bool(message.parsed);
    }
    if (message.issuer !== "") {
      writer.uint32(26).string(message.issuer);
    }
    if (message.subject !== "") {
      writer.uint32(34).string(message.subject);
    }
    for (const v of message.subjectAlternativeDnsNames) {
      writer.uint32(42).string(v!);
    }
    if (message.notBeforeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.notBeforeTime), writer.uint32(50).fork()).join();
    }
    if (message.notAfterTime !== undefined) {
      Timestamp.encode(toTimestamp(message.notAfterTime), writer.uint32(58).fork()).join();
    }
    if (message.serialNumber !== "") {
      writer.uint32(66).string(message.serialNumber);
    }
    if (message.sha256Fingerprint !== "") {
      writer.uint32(74).string(message.sha256Fingerprint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rawDer = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.parsed = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.issuer = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subject = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.subjectAlternativeDnsNames.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.notBeforeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.notAfterTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.serialNumber = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.sha256Fingerprint = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate {
    return {
      rawDer: isSet(object.rawDer) ? Buffer.from(bytesFromBase64(object.rawDer)) : Buffer.alloc(0),
      parsed: isSet(object.parsed) ? globalThis.Boolean(object.parsed) : false,
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      subjectAlternativeDnsNames: globalThis.Array.isArray(object?.subjectAlternativeDnsNames)
        ? object.subjectAlternativeDnsNames.map((e: any) => globalThis.String(e))
        : [],
      notBeforeTime: isSet(object.notBeforeTime) ? fromJsonTimestamp(object.notBeforeTime) : undefined,
      notAfterTime: isSet(object.notAfterTime) ? fromJsonTimestamp(object.notAfterTime) : undefined,
      serialNumber: isSet(object.serialNumber) ? globalThis.String(object.serialNumber) : "",
      sha256Fingerprint: isSet(object.sha256Fingerprint) ? globalThis.String(object.sha256Fingerprint) : "",
    };
  },

  toJSON(message: Certificate): unknown {
    const obj: any = {};
    if (message.rawDer.length !== 0) {
      obj.rawDer = base64FromBytes(message.rawDer);
    }
    if (message.parsed !== false) {
      obj.parsed = message.parsed;
    }
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.subjectAlternativeDnsNames?.length) {
      obj.subjectAlternativeDnsNames = message.subjectAlternativeDnsNames;
    }
    if (message.notBeforeTime !== undefined) {
      obj.notBeforeTime = message.notBeforeTime.toISOString();
    }
    if (message.notAfterTime !== undefined) {
      obj.notAfterTime = message.notAfterTime.toISOString();
    }
    if (message.serialNumber !== "") {
      obj.serialNumber = message.serialNumber;
    }
    if (message.sha256Fingerprint !== "") {
      obj.sha256Fingerprint = message.sha256Fingerprint;
    }
    return obj;
  },

  create(base?: DeepPartial<Certificate>): Certificate {
    return Certificate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Certificate>): Certificate {
    const message = createBaseCertificate();
    message.rawDer = object.rawDer ?? Buffer.alloc(0);
    message.parsed = object.parsed ?? false;
    message.issuer = object.issuer ?? "";
    message.subject = object.subject ?? "";
    message.subjectAlternativeDnsNames = object.subjectAlternativeDnsNames?.map((e) => e) || [];
    message.notBeforeTime = object.notBeforeTime ?? undefined;
    message.notAfterTime = object.notAfterTime ?? undefined;
    message.serialNumber = object.serialNumber ?? "";
    message.sha256Fingerprint = object.sha256Fingerprint ?? "";
    return message;
  },
};

function createBaseEkmConnection(): EkmConnection {
  return { name: "", createTime: undefined, serviceResolvers: [], etag: "", keyManagementMode: 0, cryptoSpacePath: "" };
}

export const EkmConnection: MessageFns<EkmConnection> = {
  encode(message: EkmConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    for (const v of message.serviceResolvers) {
      EkmConnection_ServiceResolver.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(42).string(message.etag);
    }
    if (message.keyManagementMode !== 0) {
      writer.uint32(48).int32(message.keyManagementMode);
    }
    if (message.cryptoSpacePath !== "") {
      writer.uint32(58).string(message.cryptoSpacePath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EkmConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEkmConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceResolvers.push(EkmConnection_ServiceResolver.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.keyManagementMode = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.cryptoSpacePath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EkmConnection {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      serviceResolvers: globalThis.Array.isArray(object?.serviceResolvers)
        ? object.serviceResolvers.map((e: any) => EkmConnection_ServiceResolver.fromJSON(e))
        : [],
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      keyManagementMode: isSet(object.keyManagementMode)
        ? ekmConnection_KeyManagementModeFromJSON(object.keyManagementMode)
        : 0,
      cryptoSpacePath: isSet(object.cryptoSpacePath) ? globalThis.String(object.cryptoSpacePath) : "",
    };
  },

  toJSON(message: EkmConnection): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.serviceResolvers?.length) {
      obj.serviceResolvers = message.serviceResolvers.map((e) => EkmConnection_ServiceResolver.toJSON(e));
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.keyManagementMode !== 0) {
      obj.keyManagementMode = ekmConnection_KeyManagementModeToJSON(message.keyManagementMode);
    }
    if (message.cryptoSpacePath !== "") {
      obj.cryptoSpacePath = message.cryptoSpacePath;
    }
    return obj;
  },

  create(base?: DeepPartial<EkmConnection>): EkmConnection {
    return EkmConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EkmConnection>): EkmConnection {
    const message = createBaseEkmConnection();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.serviceResolvers = object.serviceResolvers?.map((e) => EkmConnection_ServiceResolver.fromPartial(e)) || [];
    message.etag = object.etag ?? "";
    message.keyManagementMode = object.keyManagementMode ?? 0;
    message.cryptoSpacePath = object.cryptoSpacePath ?? "";
    return message;
  },
};

function createBaseEkmConnection_ServiceResolver(): EkmConnection_ServiceResolver {
  return { serviceDirectoryService: "", endpointFilter: "", hostname: "", serverCertificates: [] };
}

export const EkmConnection_ServiceResolver: MessageFns<EkmConnection_ServiceResolver> = {
  encode(message: EkmConnection_ServiceResolver, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceDirectoryService !== "") {
      writer.uint32(10).string(message.serviceDirectoryService);
    }
    if (message.endpointFilter !== "") {
      writer.uint32(18).string(message.endpointFilter);
    }
    if (message.hostname !== "") {
      writer.uint32(26).string(message.hostname);
    }
    for (const v of message.serverCertificates) {
      Certificate.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EkmConnection_ServiceResolver {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEkmConnection_ServiceResolver();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceDirectoryService = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endpointFilter = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.serverCertificates.push(Certificate.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EkmConnection_ServiceResolver {
    return {
      serviceDirectoryService: isSet(object.serviceDirectoryService)
        ? globalThis.String(object.serviceDirectoryService)
        : "",
      endpointFilter: isSet(object.endpointFilter) ? globalThis.String(object.endpointFilter) : "",
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      serverCertificates: globalThis.Array.isArray(object?.serverCertificates)
        ? object.serverCertificates.map((e: any) => Certificate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EkmConnection_ServiceResolver): unknown {
    const obj: any = {};
    if (message.serviceDirectoryService !== "") {
      obj.serviceDirectoryService = message.serviceDirectoryService;
    }
    if (message.endpointFilter !== "") {
      obj.endpointFilter = message.endpointFilter;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.serverCertificates?.length) {
      obj.serverCertificates = message.serverCertificates.map((e) => Certificate.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EkmConnection_ServiceResolver>): EkmConnection_ServiceResolver {
    return EkmConnection_ServiceResolver.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EkmConnection_ServiceResolver>): EkmConnection_ServiceResolver {
    const message = createBaseEkmConnection_ServiceResolver();
    message.serviceDirectoryService = object.serviceDirectoryService ?? "";
    message.endpointFilter = object.endpointFilter ?? "";
    message.hostname = object.hostname ?? "";
    message.serverCertificates = object.serverCertificates?.map((e) => Certificate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEkmConfig(): EkmConfig {
  return { name: "", defaultEkmConnection: "" };
}

export const EkmConfig: MessageFns<EkmConfig> = {
  encode(message: EkmConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.defaultEkmConnection !== "") {
      writer.uint32(18).string(message.defaultEkmConnection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EkmConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEkmConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.defaultEkmConnection = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EkmConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      defaultEkmConnection: isSet(object.defaultEkmConnection) ? globalThis.String(object.defaultEkmConnection) : "",
    };
  },

  toJSON(message: EkmConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.defaultEkmConnection !== "") {
      obj.defaultEkmConnection = message.defaultEkmConnection;
    }
    return obj;
  },

  create(base?: DeepPartial<EkmConfig>): EkmConfig {
    return EkmConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EkmConfig>): EkmConfig {
    const message = createBaseEkmConfig();
    message.name = object.name ?? "";
    message.defaultEkmConnection = object.defaultEkmConnection ?? "";
    return message;
  },
};

function createBaseVerifyConnectivityRequest(): VerifyConnectivityRequest {
  return { name: "" };
}

export const VerifyConnectivityRequest: MessageFns<VerifyConnectivityRequest> = {
  encode(message: VerifyConnectivityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyConnectivityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyConnectivityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyConnectivityRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: VerifyConnectivityRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<VerifyConnectivityRequest>): VerifyConnectivityRequest {
    return VerifyConnectivityRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VerifyConnectivityRequest>): VerifyConnectivityRequest {
    const message = createBaseVerifyConnectivityRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseVerifyConnectivityResponse(): VerifyConnectivityResponse {
  return {};
}

export const VerifyConnectivityResponse: MessageFns<VerifyConnectivityResponse> = {
  encode(_: VerifyConnectivityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyConnectivityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyConnectivityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): VerifyConnectivityResponse {
    return {};
  },

  toJSON(_: VerifyConnectivityResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<VerifyConnectivityResponse>): VerifyConnectivityResponse {
    return VerifyConnectivityResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<VerifyConnectivityResponse>): VerifyConnectivityResponse {
    const message = createBaseVerifyConnectivityResponse();
    return message;
  },
};

/**
 * Google Cloud Key Management EKM Service
 *
 * Manages external cryptographic keys and operations using those keys.
 * Implements a REST model with the following objects:
 * * [EkmConnection][google.cloud.kms.v1.EkmConnection]
 */
export type EkmServiceDefinition = typeof EkmServiceDefinition;
export const EkmServiceDefinition = {
  name: "EkmService",
  fullName: "google.cloud.kms.v1.EkmService",
  methods: {
    /** Lists [EkmConnections][google.cloud.kms.v1.EkmConnection]. */
    listEkmConnections: {
      name: "ListEkmConnections",
      requestType: ListEkmConnectionsRequest,
      requestStream: false,
      responseType: ListEkmConnectionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              101,
              107,
              109,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns metadata for a given
     * [EkmConnection][google.cloud.kms.v1.EkmConnection].
     */
    getEkmConnection: {
      name: "GetEkmConnection",
      requestType: GetEkmConnectionRequest,
      requestStream: false,
      responseType: EkmConnection,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              107,
              109,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new [EkmConnection][google.cloud.kms.v1.EkmConnection] in a given
     * Project and Location.
     */
    createEkmConnection: {
      name: "CreateEkmConnection",
      requestType: CreateEkmConnectionRequest,
      requestStream: false,
      responseType: EkmConnection,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              39,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              101,
              107,
              109,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
              44,
              101,
              107,
              109,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              14,
              101,
              107,
              109,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              34,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              101,
              107,
              109,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates an [EkmConnection][google.cloud.kms.v1.EkmConnection]'s metadata. */
    updateEkmConnection: {
      name: "UpdateEkmConnection",
      requestType: UpdateEkmConnectionRequest,
      requestStream: false,
      responseType: EkmConnection,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              26,
              101,
              107,
              109,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              83,
              58,
              14,
              101,
              107,
              109,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              50,
              65,
              47,
              118,
              49,
              47,
              123,
              101,
              107,
              109,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              107,
              109,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Returns the [EkmConfig][google.cloud.kms.v1.EkmConfig] singleton resource
     * for a given project and location.
     */
    getEkmConfig: {
      name: "GetEkmConfig",
      requestType: GetEkmConfigRequest,
      requestStream: false,
      responseType: EkmConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              107,
              109,
              67,
              111,
              110,
              102,
              105,
              103,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the [EkmConfig][google.cloud.kms.v1.EkmConfig] singleton resource
     * for a given project and location.
     */
    updateEkmConfig: {
      name: "UpdateEkmConfig",
      requestType: UpdateEkmConfigRequest,
      requestStream: false,
      responseType: EkmConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              101,
              107,
              109,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              10,
              101,
              107,
              109,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              50,
              54,
              47,
              118,
              49,
              47,
              123,
              101,
              107,
              109,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              107,
              109,
              67,
              111,
              110,
              102,
              105,
              103,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Verifies that Cloud KMS can successfully connect to the external key
     * manager specified by an [EkmConnection][google.cloud.kms.v1.EkmConnection].
     * If there is an error connecting to the EKM, this method returns a
     * FAILED_PRECONDITION status containing structured information as described
     * at https://cloud.google.com/kms/docs/reference/ekm_errors.
     */
    verifyConnectivity: {
      name: "VerifyConnectivity",
      requestType: VerifyConnectivityRequest,
      requestStream: false,
      responseType: VerifyConnectivityResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              71,
              18,
              69,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              107,
              109,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              118,
              101,
              114,
              105,
              102,
              121,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              118,
              105,
              116,
              121,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface EkmServiceImplementation<CallContextExt = {}> {
  /** Lists [EkmConnections][google.cloud.kms.v1.EkmConnection]. */
  listEkmConnections(
    request: ListEkmConnectionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListEkmConnectionsResponse>>;
  /**
   * Returns metadata for a given
   * [EkmConnection][google.cloud.kms.v1.EkmConnection].
   */
  getEkmConnection(
    request: GetEkmConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<EkmConnection>>;
  /**
   * Creates a new [EkmConnection][google.cloud.kms.v1.EkmConnection] in a given
   * Project and Location.
   */
  createEkmConnection(
    request: CreateEkmConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<EkmConnection>>;
  /** Updates an [EkmConnection][google.cloud.kms.v1.EkmConnection]'s metadata. */
  updateEkmConnection(
    request: UpdateEkmConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<EkmConnection>>;
  /**
   * Returns the [EkmConfig][google.cloud.kms.v1.EkmConfig] singleton resource
   * for a given project and location.
   */
  getEkmConfig(request: GetEkmConfigRequest, context: CallContext & CallContextExt): Promise<DeepPartial<EkmConfig>>;
  /**
   * Updates the [EkmConfig][google.cloud.kms.v1.EkmConfig] singleton resource
   * for a given project and location.
   */
  updateEkmConfig(
    request: UpdateEkmConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<EkmConfig>>;
  /**
   * Verifies that Cloud KMS can successfully connect to the external key
   * manager specified by an [EkmConnection][google.cloud.kms.v1.EkmConnection].
   * If there is an error connecting to the EKM, this method returns a
   * FAILED_PRECONDITION status containing structured information as described
   * at https://cloud.google.com/kms/docs/reference/ekm_errors.
   */
  verifyConnectivity(
    request: VerifyConnectivityRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<VerifyConnectivityResponse>>;
}

export interface EkmServiceClient<CallOptionsExt = {}> {
  /** Lists [EkmConnections][google.cloud.kms.v1.EkmConnection]. */
  listEkmConnections(
    request: DeepPartial<ListEkmConnectionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListEkmConnectionsResponse>;
  /**
   * Returns metadata for a given
   * [EkmConnection][google.cloud.kms.v1.EkmConnection].
   */
  getEkmConnection(
    request: DeepPartial<GetEkmConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EkmConnection>;
  /**
   * Creates a new [EkmConnection][google.cloud.kms.v1.EkmConnection] in a given
   * Project and Location.
   */
  createEkmConnection(
    request: DeepPartial<CreateEkmConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EkmConnection>;
  /** Updates an [EkmConnection][google.cloud.kms.v1.EkmConnection]'s metadata. */
  updateEkmConnection(
    request: DeepPartial<UpdateEkmConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EkmConnection>;
  /**
   * Returns the [EkmConfig][google.cloud.kms.v1.EkmConfig] singleton resource
   * for a given project and location.
   */
  getEkmConfig(request: DeepPartial<GetEkmConfigRequest>, options?: CallOptions & CallOptionsExt): Promise<EkmConfig>;
  /**
   * Updates the [EkmConfig][google.cloud.kms.v1.EkmConfig] singleton resource
   * for a given project and location.
   */
  updateEkmConfig(
    request: DeepPartial<UpdateEkmConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EkmConfig>;
  /**
   * Verifies that Cloud KMS can successfully connect to the external key
   * manager specified by an [EkmConnection][google.cloud.kms.v1.EkmConnection].
   * If there is an error connecting to the EKM, this method returns a
   * FAILED_PRECONDITION status containing structured information as described
   * at https://cloud.google.com/kms/docs/reference/ekm_errors.
   */
  verifyConnectivity(
    request: DeepPartial<VerifyConnectivityRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<VerifyConnectivityResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
