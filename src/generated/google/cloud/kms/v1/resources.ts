// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/kms/v1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Int64Value } from "../../../protobuf/wrappers.js";

export const protobufPackage = "google.cloud.kms.v1";

/**
 * [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] specifies how
 * cryptographic operations are performed. For more information, see [Protection
 * levels] (https://cloud.google.com/kms/docs/algorithms#protection_levels).
 */
export enum ProtectionLevel {
  /** PROTECTION_LEVEL_UNSPECIFIED - Not specified. */
  PROTECTION_LEVEL_UNSPECIFIED = 0,
  /** SOFTWARE - Crypto operations are performed in software. */
  SOFTWARE = 1,
  /** HSM - Crypto operations are performed in a Hardware Security Module. */
  HSM = 2,
  /** EXTERNAL - Crypto operations are performed by an external key manager. */
  EXTERNAL = 3,
  /** EXTERNAL_VPC - Crypto operations are performed in an EKM-over-VPC backend. */
  EXTERNAL_VPC = 4,
  UNRECOGNIZED = -1,
}

export function protectionLevelFromJSON(object: any): ProtectionLevel {
  switch (object) {
    case 0:
    case "PROTECTION_LEVEL_UNSPECIFIED":
      return ProtectionLevel.PROTECTION_LEVEL_UNSPECIFIED;
    case 1:
    case "SOFTWARE":
      return ProtectionLevel.SOFTWARE;
    case 2:
    case "HSM":
      return ProtectionLevel.HSM;
    case 3:
    case "EXTERNAL":
      return ProtectionLevel.EXTERNAL;
    case 4:
    case "EXTERNAL_VPC":
      return ProtectionLevel.EXTERNAL_VPC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProtectionLevel.UNRECOGNIZED;
  }
}

export function protectionLevelToJSON(object: ProtectionLevel): string {
  switch (object) {
    case ProtectionLevel.PROTECTION_LEVEL_UNSPECIFIED:
      return "PROTECTION_LEVEL_UNSPECIFIED";
    case ProtectionLevel.SOFTWARE:
      return "SOFTWARE";
    case ProtectionLevel.HSM:
      return "HSM";
    case ProtectionLevel.EXTERNAL:
      return "EXTERNAL";
    case ProtectionLevel.EXTERNAL_VPC:
      return "EXTERNAL_VPC";
    case ProtectionLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Describes the reason for a data access. Please refer to
 * https://cloud.google.com/assured-workloads/key-access-justifications/docs/justification-codes
 * for the detailed semantic meaning of justification reason codes.
 */
export enum AccessReason {
  /** REASON_UNSPECIFIED - Unspecified access reason. */
  REASON_UNSPECIFIED = 0,
  /** CUSTOMER_INITIATED_SUPPORT - Customer-initiated support. */
  CUSTOMER_INITIATED_SUPPORT = 1,
  /** GOOGLE_INITIATED_SERVICE - Google-initiated access for system management and troubleshooting. */
  GOOGLE_INITIATED_SERVICE = 2,
  /** THIRD_PARTY_DATA_REQUEST - Google-initiated access in response to a legal request or legal process. */
  THIRD_PARTY_DATA_REQUEST = 3,
  /** GOOGLE_INITIATED_REVIEW - Google-initiated access for security, fraud, abuse, or compliance purposes. */
  GOOGLE_INITIATED_REVIEW = 4,
  /**
   * CUSTOMER_INITIATED_ACCESS - Customer uses their account to perform any access to their own data which
   * their IAM policy authorizes.
   */
  CUSTOMER_INITIATED_ACCESS = 5,
  /**
   * GOOGLE_INITIATED_SYSTEM_OPERATION - Google systems access customer data to help optimize the structure of the
   * data or quality for future uses by the customer.
   */
  GOOGLE_INITIATED_SYSTEM_OPERATION = 6,
  /** REASON_NOT_EXPECTED - No reason is expected for this key request. */
  REASON_NOT_EXPECTED = 7,
  /**
   * MODIFIED_CUSTOMER_INITIATED_ACCESS - Customer uses their account to perform any access to their own data which
   * their IAM policy authorizes, and one of the following is true:
   *
   * * A Google administrator has reset the root-access account associated with
   *   the user's organization within the past 7 days.
   * * A Google-initiated emergency access operation has interacted with a
   *   resource in the same project or folder as the currently accessed resource
   *   within the past 7 days.
   */
  MODIFIED_CUSTOMER_INITIATED_ACCESS = 8,
  /**
   * MODIFIED_GOOGLE_INITIATED_SYSTEM_OPERATION - Google systems access customer data to help optimize the structure of the
   * data or quality for future uses by the customer, and one of the following
   * is true:
   *
   * * A Google administrator has reset the root-access account associated with
   *   the user's organization within the past 7 days.
   * * A Google-initiated emergency access operation has interacted with a
   *   resource in the same project or folder as the currently accessed resource
   *   within the past 7 days.
   */
  MODIFIED_GOOGLE_INITIATED_SYSTEM_OPERATION = 9,
  /** GOOGLE_RESPONSE_TO_PRODUCTION_ALERT - Google-initiated access to maintain system reliability. */
  GOOGLE_RESPONSE_TO_PRODUCTION_ALERT = 10,
  /**
   * CUSTOMER_AUTHORIZED_WORKFLOW_SERVICING - One of the following operations is being executed while simultaneously
   * encountering an internal technical issue which prevented a more precise
   * justification code from being generated:
   *
   * * Your account has been used to perform any access to your own data which
   *   your IAM policy authorizes.
   * * An automated Google system operates on encrypted customer data which your
   *   IAM policy authorizes.
   * * Customer-initiated Google support access.
   * * Google-initiated support access to protect system reliability.
   */
  CUSTOMER_AUTHORIZED_WORKFLOW_SERVICING = 11,
  UNRECOGNIZED = -1,
}

export function accessReasonFromJSON(object: any): AccessReason {
  switch (object) {
    case 0:
    case "REASON_UNSPECIFIED":
      return AccessReason.REASON_UNSPECIFIED;
    case 1:
    case "CUSTOMER_INITIATED_SUPPORT":
      return AccessReason.CUSTOMER_INITIATED_SUPPORT;
    case 2:
    case "GOOGLE_INITIATED_SERVICE":
      return AccessReason.GOOGLE_INITIATED_SERVICE;
    case 3:
    case "THIRD_PARTY_DATA_REQUEST":
      return AccessReason.THIRD_PARTY_DATA_REQUEST;
    case 4:
    case "GOOGLE_INITIATED_REVIEW":
      return AccessReason.GOOGLE_INITIATED_REVIEW;
    case 5:
    case "CUSTOMER_INITIATED_ACCESS":
      return AccessReason.CUSTOMER_INITIATED_ACCESS;
    case 6:
    case "GOOGLE_INITIATED_SYSTEM_OPERATION":
      return AccessReason.GOOGLE_INITIATED_SYSTEM_OPERATION;
    case 7:
    case "REASON_NOT_EXPECTED":
      return AccessReason.REASON_NOT_EXPECTED;
    case 8:
    case "MODIFIED_CUSTOMER_INITIATED_ACCESS":
      return AccessReason.MODIFIED_CUSTOMER_INITIATED_ACCESS;
    case 9:
    case "MODIFIED_GOOGLE_INITIATED_SYSTEM_OPERATION":
      return AccessReason.MODIFIED_GOOGLE_INITIATED_SYSTEM_OPERATION;
    case 10:
    case "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT":
      return AccessReason.GOOGLE_RESPONSE_TO_PRODUCTION_ALERT;
    case 11:
    case "CUSTOMER_AUTHORIZED_WORKFLOW_SERVICING":
      return AccessReason.CUSTOMER_AUTHORIZED_WORKFLOW_SERVICING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessReason.UNRECOGNIZED;
  }
}

export function accessReasonToJSON(object: AccessReason): string {
  switch (object) {
    case AccessReason.REASON_UNSPECIFIED:
      return "REASON_UNSPECIFIED";
    case AccessReason.CUSTOMER_INITIATED_SUPPORT:
      return "CUSTOMER_INITIATED_SUPPORT";
    case AccessReason.GOOGLE_INITIATED_SERVICE:
      return "GOOGLE_INITIATED_SERVICE";
    case AccessReason.THIRD_PARTY_DATA_REQUEST:
      return "THIRD_PARTY_DATA_REQUEST";
    case AccessReason.GOOGLE_INITIATED_REVIEW:
      return "GOOGLE_INITIATED_REVIEW";
    case AccessReason.CUSTOMER_INITIATED_ACCESS:
      return "CUSTOMER_INITIATED_ACCESS";
    case AccessReason.GOOGLE_INITIATED_SYSTEM_OPERATION:
      return "GOOGLE_INITIATED_SYSTEM_OPERATION";
    case AccessReason.REASON_NOT_EXPECTED:
      return "REASON_NOT_EXPECTED";
    case AccessReason.MODIFIED_CUSTOMER_INITIATED_ACCESS:
      return "MODIFIED_CUSTOMER_INITIATED_ACCESS";
    case AccessReason.MODIFIED_GOOGLE_INITIATED_SYSTEM_OPERATION:
      return "MODIFIED_GOOGLE_INITIATED_SYSTEM_OPERATION";
    case AccessReason.GOOGLE_RESPONSE_TO_PRODUCTION_ALERT:
      return "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT";
    case AccessReason.CUSTOMER_AUTHORIZED_WORKFLOW_SERVICING:
      return "CUSTOMER_AUTHORIZED_WORKFLOW_SERVICING";
    case AccessReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A [KeyRing][google.cloud.kms.v1.KeyRing] is a toplevel logical grouping of
 * [CryptoKeys][google.cloud.kms.v1.CryptoKey].
 */
export interface KeyRing {
  /**
   * Output only. The resource name for the
   * [KeyRing][google.cloud.kms.v1.KeyRing] in the format
   * `projects/* /locations/* /keyRings/*`.
   */
  name: string;
  /**
   * Output only. The time at which this [KeyRing][google.cloud.kms.v1.KeyRing]
   * was created.
   */
  createTime: Date | undefined;
}

/**
 * A [CryptoKey][google.cloud.kms.v1.CryptoKey] represents a logical key that
 * can be used for cryptographic operations.
 *
 * A [CryptoKey][google.cloud.kms.v1.CryptoKey] is made up of zero or more
 * [versions][google.cloud.kms.v1.CryptoKeyVersion], which represent the actual
 * key material used in cryptographic operations.
 */
export interface CryptoKey {
  /**
   * Output only. The resource name for this
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] in the format
   * `projects/* /locations/* /keyRings/* /cryptoKeys/*`.
   */
  name: string;
  /**
   * Output only. A copy of the "primary"
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] that will be used
   * by [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] when this
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] is given in
   * [EncryptRequest.name][google.cloud.kms.v1.EncryptRequest.name].
   *
   * The [CryptoKey][google.cloud.kms.v1.CryptoKey]'s primary version can be
   * updated via
   * [UpdateCryptoKeyPrimaryVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion].
   *
   * Keys with [purpose][google.cloud.kms.v1.CryptoKey.purpose]
   * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]
   * may have a primary. For other keys, this field will be omitted.
   */
  primary:
    | CryptoKeyVersion
    | undefined;
  /**
   * Immutable. The immutable purpose of this
   * [CryptoKey][google.cloud.kms.v1.CryptoKey].
   */
  purpose: CryptoKey_CryptoKeyPurpose;
  /**
   * Output only. The time at which this
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] was created.
   */
  createTime:
    | Date
    | undefined;
  /**
   * At [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time],
   * the Key Management Service will automatically:
   *
   * 1. Create a new version of this [CryptoKey][google.cloud.kms.v1.CryptoKey].
   * 2. Mark the new version as primary.
   *
   * Key rotations performed manually via
   * [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
   * and
   * [UpdateCryptoKeyPrimaryVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion]
   * do not affect
   * [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time].
   *
   * Keys with [purpose][google.cloud.kms.v1.CryptoKey.purpose]
   * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]
   * support automatic rotation. For other keys, this field must be omitted.
   */
  nextRotationTime:
    | Date
    | undefined;
  /**
   * [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time]
   * will be advanced by this period when the service automatically rotates a
   * key. Must be at least 24 hours and at most 876,000 hours.
   *
   * If [rotation_period][google.cloud.kms.v1.CryptoKey.rotation_period] is
   * set,
   * [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time]
   * must also be set.
   *
   * Keys with [purpose][google.cloud.kms.v1.CryptoKey.purpose]
   * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT]
   * support automatic rotation. For other keys, this field must be omitted.
   */
  rotationPeriod?:
    | Duration
    | undefined;
  /**
   * A template describing settings for new
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] instances. The
   * properties of new [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
   * instances created by either
   * [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
   * or auto-rotation are controlled by this template.
   */
  versionTemplate:
    | CryptoKeyVersionTemplate
    | undefined;
  /**
   * Labels with user-defined metadata. For more information, see
   * [Labeling Keys](https://cloud.google.com/kms/docs/labeling-keys).
   */
  labels: { [key: string]: string };
  /** Immutable. Whether this key may contain imported versions only. */
  importOnly: boolean;
  /**
   * Immutable. The period of time that versions of this key spend in the
   * [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED]
   * state before transitioning to
   * [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED].
   * If not specified at creation time, the default duration is 30 days.
   */
  destroyScheduledDuration:
    | Duration
    | undefined;
  /**
   * Immutable. The resource name of the backend environment where the key
   * material for all [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]
   * associated with this [CryptoKey][google.cloud.kms.v1.CryptoKey] reside and
   * where all related cryptographic operations are performed. Only applicable
   * if [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] have a
   * [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of
   * [EXTERNAL_VPC][CryptoKeyVersion.ProtectionLevel.EXTERNAL_VPC], with the
   * resource name in the format `projects/* /locations/* /ekmConnections/*`.
   * Note, this list is non-exhaustive and may apply to additional
   * [ProtectionLevels][google.cloud.kms.v1.ProtectionLevel] in the future.
   */
  cryptoKeyBackend: string;
  /**
   * Optional. The policy used for Key Access Justifications Policy Enforcement.
   * If this field is present and this key is enrolled in Key Access
   * Justifications Policy Enforcement, the policy will be evaluated in encrypt,
   * decrypt, and sign operations, and the operation will fail if rejected by
   * the policy. The policy is defined by specifying zero or more allowed
   * justification codes.
   * https://cloud.google.com/assured-workloads/key-access-justifications/docs/justification-codes
   * By default, this field is absent, and all justification codes are allowed.
   */
  keyAccessJustificationsPolicy: KeyAccessJustificationsPolicy | undefined;
}

/**
 * [CryptoKeyPurpose][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose]
 * describes the cryptographic capabilities of a
 * [CryptoKey][google.cloud.kms.v1.CryptoKey]. A given key can only be used
 * for the operations allowed by its purpose. For more information, see [Key
 * purposes](https://cloud.google.com/kms/docs/algorithms#key_purposes).
 */
export enum CryptoKey_CryptoKeyPurpose {
  /** CRYPTO_KEY_PURPOSE_UNSPECIFIED - Not specified. */
  CRYPTO_KEY_PURPOSE_UNSPECIFIED = 0,
  /**
   * ENCRYPT_DECRYPT - [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
   * with [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] and
   * [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
   */
  ENCRYPT_DECRYPT = 1,
  /**
   * ASYMMETRIC_SIGN - [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
   * with
   * [AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign]
   * and
   * [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
   */
  ASYMMETRIC_SIGN = 5,
  /**
   * ASYMMETRIC_DECRYPT - [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
   * with
   * [AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt]
   * and
   * [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
   */
  ASYMMETRIC_DECRYPT = 6,
  /**
   * RAW_ENCRYPT_DECRYPT - [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
   * with [RawEncrypt][google.cloud.kms.v1.KeyManagementService.RawEncrypt]
   * and [RawDecrypt][google.cloud.kms.v1.KeyManagementService.RawDecrypt].
   * This purpose is meant to be used for interoperable symmetric
   * encryption and does not support automatic CryptoKey rotation.
   */
  RAW_ENCRYPT_DECRYPT = 7,
  /**
   * MAC - [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used
   * with [MacSign][google.cloud.kms.v1.KeyManagementService.MacSign].
   */
  MAC = 9,
  UNRECOGNIZED = -1,
}

export function cryptoKey_CryptoKeyPurposeFromJSON(object: any): CryptoKey_CryptoKeyPurpose {
  switch (object) {
    case 0:
    case "CRYPTO_KEY_PURPOSE_UNSPECIFIED":
      return CryptoKey_CryptoKeyPurpose.CRYPTO_KEY_PURPOSE_UNSPECIFIED;
    case 1:
    case "ENCRYPT_DECRYPT":
      return CryptoKey_CryptoKeyPurpose.ENCRYPT_DECRYPT;
    case 5:
    case "ASYMMETRIC_SIGN":
      return CryptoKey_CryptoKeyPurpose.ASYMMETRIC_SIGN;
    case 6:
    case "ASYMMETRIC_DECRYPT":
      return CryptoKey_CryptoKeyPurpose.ASYMMETRIC_DECRYPT;
    case 7:
    case "RAW_ENCRYPT_DECRYPT":
      return CryptoKey_CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT;
    case 9:
    case "MAC":
      return CryptoKey_CryptoKeyPurpose.MAC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoKey_CryptoKeyPurpose.UNRECOGNIZED;
  }
}

export function cryptoKey_CryptoKeyPurposeToJSON(object: CryptoKey_CryptoKeyPurpose): string {
  switch (object) {
    case CryptoKey_CryptoKeyPurpose.CRYPTO_KEY_PURPOSE_UNSPECIFIED:
      return "CRYPTO_KEY_PURPOSE_UNSPECIFIED";
    case CryptoKey_CryptoKeyPurpose.ENCRYPT_DECRYPT:
      return "ENCRYPT_DECRYPT";
    case CryptoKey_CryptoKeyPurpose.ASYMMETRIC_SIGN:
      return "ASYMMETRIC_SIGN";
    case CryptoKey_CryptoKeyPurpose.ASYMMETRIC_DECRYPT:
      return "ASYMMETRIC_DECRYPT";
    case CryptoKey_CryptoKeyPurpose.RAW_ENCRYPT_DECRYPT:
      return "RAW_ENCRYPT_DECRYPT";
    case CryptoKey_CryptoKeyPurpose.MAC:
      return "MAC";
    case CryptoKey_CryptoKeyPurpose.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CryptoKey_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A [CryptoKeyVersionTemplate][google.cloud.kms.v1.CryptoKeyVersionTemplate]
 * specifies the properties to use when creating a new
 * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], either manually
 * with
 * [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
 * or automatically as a result of auto-rotation.
 */
export interface CryptoKeyVersionTemplate {
  /**
   * [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] to use when creating
   * a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] based on this
   * template. Immutable. Defaults to
   * [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE].
   */
  protectionLevel: ProtectionLevel;
  /**
   * Required.
   * [Algorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
   * to use when creating a
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] based on this
   * template.
   *
   * For backwards compatibility, GOOGLE_SYMMETRIC_ENCRYPTION is implied if both
   * this field is omitted and
   * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] is
   * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
   */
  algorithm: CryptoKeyVersion_CryptoKeyVersionAlgorithm;
}

/**
 * Contains an HSM-generated attestation about a key operation. For more
 * information, see [Verifying attestations]
 * (https://cloud.google.com/kms/docs/attest-key).
 */
export interface KeyOperationAttestation {
  /** Output only. The format of the attestation data. */
  format: KeyOperationAttestation_AttestationFormat;
  /**
   * Output only. The attestation data provided by the HSM when the key
   * operation was performed.
   */
  content: Buffer;
  /** Output only. The certificate chains needed to validate the attestation */
  certChains: KeyOperationAttestation_CertificateChains | undefined;
}

/** Attestation formats provided by the HSM. */
export enum KeyOperationAttestation_AttestationFormat {
  /** ATTESTATION_FORMAT_UNSPECIFIED - Not specified. */
  ATTESTATION_FORMAT_UNSPECIFIED = 0,
  /**
   * CAVIUM_V1_COMPRESSED - Cavium HSM attestation compressed with gzip. Note that this format is
   * defined by Cavium and subject to change at any time.
   *
   * See
   * https://www.marvell.com/products/security-solutions/nitrox-hs-adapters/software-key-attestation.html.
   */
  CAVIUM_V1_COMPRESSED = 3,
  /**
   * CAVIUM_V2_COMPRESSED - Cavium HSM attestation V2 compressed with gzip. This is a new format
   * introduced in Cavium's version 3.2-08.
   */
  CAVIUM_V2_COMPRESSED = 4,
  UNRECOGNIZED = -1,
}

export function keyOperationAttestation_AttestationFormatFromJSON(
  object: any,
): KeyOperationAttestation_AttestationFormat {
  switch (object) {
    case 0:
    case "ATTESTATION_FORMAT_UNSPECIFIED":
      return KeyOperationAttestation_AttestationFormat.ATTESTATION_FORMAT_UNSPECIFIED;
    case 3:
    case "CAVIUM_V1_COMPRESSED":
      return KeyOperationAttestation_AttestationFormat.CAVIUM_V1_COMPRESSED;
    case 4:
    case "CAVIUM_V2_COMPRESSED":
      return KeyOperationAttestation_AttestationFormat.CAVIUM_V2_COMPRESSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KeyOperationAttestation_AttestationFormat.UNRECOGNIZED;
  }
}

export function keyOperationAttestation_AttestationFormatToJSON(
  object: KeyOperationAttestation_AttestationFormat,
): string {
  switch (object) {
    case KeyOperationAttestation_AttestationFormat.ATTESTATION_FORMAT_UNSPECIFIED:
      return "ATTESTATION_FORMAT_UNSPECIFIED";
    case KeyOperationAttestation_AttestationFormat.CAVIUM_V1_COMPRESSED:
      return "CAVIUM_V1_COMPRESSED";
    case KeyOperationAttestation_AttestationFormat.CAVIUM_V2_COMPRESSED:
      return "CAVIUM_V2_COMPRESSED";
    case KeyOperationAttestation_AttestationFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Certificate chains needed to verify the attestation.
 * Certificates in chains are PEM-encoded and are ordered based on
 * https://tools.ietf.org/html/rfc5246#section-7.4.2.
 */
export interface KeyOperationAttestation_CertificateChains {
  /** Cavium certificate chain corresponding to the attestation. */
  caviumCerts: string[];
  /** Google card certificate chain corresponding to the attestation. */
  googleCardCerts: string[];
  /** Google partition certificate chain corresponding to the attestation. */
  googlePartitionCerts: string[];
}

/**
 * A [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] represents an
 * individual cryptographic key, and the associated key material.
 *
 * An
 * [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
 * version can be used for cryptographic operations.
 *
 * For security reasons, the raw cryptographic key material represented by a
 * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] can never be viewed
 * or exported. It can only be used to encrypt, decrypt, or sign data when an
 * authorized user or application invokes Cloud KMS.
 */
export interface CryptoKeyVersion {
  /**
   * Output only. The resource name for this
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in the format
   * `projects/* /locations/* /keyRings/* /cryptoKeys/* /cryptoKeyVersions/*`.
   */
  name: string;
  /**
   * The current state of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   */
  state: CryptoKeyVersion_CryptoKeyVersionState;
  /**
   * Output only. The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel]
   * describing how crypto operations are performed with this
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
   */
  protectionLevel: ProtectionLevel;
  /**
   * Output only. The
   * [CryptoKeyVersionAlgorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
   * that this [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
   * supports.
   */
  algorithm: CryptoKeyVersion_CryptoKeyVersionAlgorithm;
  /**
   * Output only. Statement that was generated and signed by the HSM at key
   * creation time. Use this statement to verify attributes of the key as stored
   * on the HSM, independently of Google. Only provided for key versions with
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersion.protection_level]
   * [HSM][google.cloud.kms.v1.ProtectionLevel.HSM].
   */
  attestation:
    | KeyOperationAttestation
    | undefined;
  /**
   * Output only. The time at which this
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] was created.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The time this
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s key material was
   * generated.
   */
  generateTime:
    | Date
    | undefined;
  /**
   * Output only. The time this
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s key material is
   * scheduled for destruction. Only present if
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
   * [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED].
   */
  destroyTime:
    | Date
    | undefined;
  /**
   * Output only. The time this CryptoKeyVersion's key material was
   * destroyed. Only present if
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
   * [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED].
   */
  destroyEventTime:
    | Date
    | undefined;
  /**
   * Output only. The name of the [ImportJob][google.cloud.kms.v1.ImportJob]
   * used in the most recent import of this
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. Only present if
   * the underlying key material was imported.
   */
  importJob: string;
  /**
   * Output only. The time at which this
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s key material was
   * most recently imported.
   */
  importTime:
    | Date
    | undefined;
  /**
   * Output only. The root cause of the most recent import failure. Only present
   * if [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
   * [IMPORT_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.IMPORT_FAILED].
   */
  importFailureReason: string;
  /**
   * Output only. The root cause of the most recent generation failure. Only
   * present if [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
   * [GENERATION_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.GENERATION_FAILED].
   */
  generationFailureReason: string;
  /**
   * Output only. The root cause of the most recent external destruction
   * failure. Only present if
   * [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
   * [EXTERNAL_DESTRUCTION_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.EXTERNAL_DESTRUCTION_FAILED].
   */
  externalDestructionFailureReason: string;
  /**
   * ExternalProtectionLevelOptions stores a group of additional fields for
   * configuring a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] that
   * are specific to the
   * [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL] protection level
   * and [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC]
   * protection levels.
   */
  externalProtectionLevelOptions:
    | ExternalProtectionLevelOptions
    | undefined;
  /**
   * Output only. Whether or not this key version is eligible for reimport, by
   * being specified as a target in
   * [ImportCryptoKeyVersionRequest.crypto_key_version][google.cloud.kms.v1.ImportCryptoKeyVersionRequest.crypto_key_version].
   */
  reimportEligible: boolean;
}

/**
 * The algorithm of the
 * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], indicating what
 * parameters must be used for each cryptographic operation.
 *
 * The
 * [GOOGLE_SYMMETRIC_ENCRYPTION][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.GOOGLE_SYMMETRIC_ENCRYPTION]
 * algorithm is usable with
 * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
 * [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
 *
 * Algorithms beginning with `RSA_SIGN_` are usable with
 * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
 * [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN].
 *
 * The fields in the name after `RSA_SIGN_` correspond to the following
 * parameters: padding algorithm, modulus bit length, and digest algorithm.
 *
 * For PSS, the salt length used is equal to the length of digest
 * algorithm. For example,
 * [RSA_SIGN_PSS_2048_SHA256][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256]
 * will use PSS with a salt length of 256 bits or 32 bytes.
 *
 * Algorithms beginning with `RSA_DECRYPT_` are usable with
 * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
 * [ASYMMETRIC_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_DECRYPT].
 *
 * The fields in the name after `RSA_DECRYPT_` correspond to the following
 * parameters: padding algorithm, modulus bit length, and digest algorithm.
 *
 * Algorithms beginning with `EC_SIGN_` are usable with
 * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
 * [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN].
 *
 * The fields in the name after `EC_SIGN_` correspond to the following
 * parameters: elliptic curve, digest algorithm.
 *
 * Algorithms beginning with `HMAC_` are usable with
 * [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
 * [MAC][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.MAC].
 *
 * The suffix following `HMAC_` corresponds to the hash algorithm being used
 * (eg. SHA256).
 *
 * For more information, see [Key purposes and algorithms]
 * (https://cloud.google.com/kms/docs/algorithms).
 */
export enum CryptoKeyVersion_CryptoKeyVersionAlgorithm {
  /** CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED - Not specified. */
  CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED = 0,
  /** GOOGLE_SYMMETRIC_ENCRYPTION - Creates symmetric encryption keys. */
  GOOGLE_SYMMETRIC_ENCRYPTION = 1,
  /** AES_128_GCM - AES-GCM (Galois Counter Mode) using 128-bit keys. */
  AES_128_GCM = 41,
  /** AES_256_GCM - AES-GCM (Galois Counter Mode) using 256-bit keys. */
  AES_256_GCM = 19,
  /** AES_128_CBC - AES-CBC (Cipher Block Chaining Mode) using 128-bit keys. */
  AES_128_CBC = 42,
  /** AES_256_CBC - AES-CBC (Cipher Block Chaining Mode) using 256-bit keys. */
  AES_256_CBC = 43,
  /** AES_128_CTR - AES-CTR (Counter Mode) using 128-bit keys. */
  AES_128_CTR = 44,
  /** AES_256_CTR - AES-CTR (Counter Mode) using 256-bit keys. */
  AES_256_CTR = 45,
  /** RSA_SIGN_PSS_2048_SHA256 - RSASSA-PSS 2048 bit key with a SHA256 digest. */
  RSA_SIGN_PSS_2048_SHA256 = 2,
  /** RSA_SIGN_PSS_3072_SHA256 - RSASSA-PSS 3072 bit key with a SHA256 digest. */
  RSA_SIGN_PSS_3072_SHA256 = 3,
  /** RSA_SIGN_PSS_4096_SHA256 - RSASSA-PSS 4096 bit key with a SHA256 digest. */
  RSA_SIGN_PSS_4096_SHA256 = 4,
  /** RSA_SIGN_PSS_4096_SHA512 - RSASSA-PSS 4096 bit key with a SHA512 digest. */
  RSA_SIGN_PSS_4096_SHA512 = 15,
  /** RSA_SIGN_PKCS1_2048_SHA256 - RSASSA-PKCS1-v1_5 with a 2048 bit key and a SHA256 digest. */
  RSA_SIGN_PKCS1_2048_SHA256 = 5,
  /** RSA_SIGN_PKCS1_3072_SHA256 - RSASSA-PKCS1-v1_5 with a 3072 bit key and a SHA256 digest. */
  RSA_SIGN_PKCS1_3072_SHA256 = 6,
  /** RSA_SIGN_PKCS1_4096_SHA256 - RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA256 digest. */
  RSA_SIGN_PKCS1_4096_SHA256 = 7,
  /** RSA_SIGN_PKCS1_4096_SHA512 - RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA512 digest. */
  RSA_SIGN_PKCS1_4096_SHA512 = 16,
  /** RSA_SIGN_RAW_PKCS1_2048 - RSASSA-PKCS1-v1_5 signing without encoding, with a 2048 bit key. */
  RSA_SIGN_RAW_PKCS1_2048 = 28,
  /** RSA_SIGN_RAW_PKCS1_3072 - RSASSA-PKCS1-v1_5 signing without encoding, with a 3072 bit key. */
  RSA_SIGN_RAW_PKCS1_3072 = 29,
  /** RSA_SIGN_RAW_PKCS1_4096 - RSASSA-PKCS1-v1_5 signing without encoding, with a 4096 bit key. */
  RSA_SIGN_RAW_PKCS1_4096 = 30,
  /** RSA_DECRYPT_OAEP_2048_SHA256 - RSAES-OAEP 2048 bit key with a SHA256 digest. */
  RSA_DECRYPT_OAEP_2048_SHA256 = 8,
  /** RSA_DECRYPT_OAEP_3072_SHA256 - RSAES-OAEP 3072 bit key with a SHA256 digest. */
  RSA_DECRYPT_OAEP_3072_SHA256 = 9,
  /** RSA_DECRYPT_OAEP_4096_SHA256 - RSAES-OAEP 4096 bit key with a SHA256 digest. */
  RSA_DECRYPT_OAEP_4096_SHA256 = 10,
  /** RSA_DECRYPT_OAEP_4096_SHA512 - RSAES-OAEP 4096 bit key with a SHA512 digest. */
  RSA_DECRYPT_OAEP_4096_SHA512 = 17,
  /** RSA_DECRYPT_OAEP_2048_SHA1 - RSAES-OAEP 2048 bit key with a SHA1 digest. */
  RSA_DECRYPT_OAEP_2048_SHA1 = 37,
  /** RSA_DECRYPT_OAEP_3072_SHA1 - RSAES-OAEP 3072 bit key with a SHA1 digest. */
  RSA_DECRYPT_OAEP_3072_SHA1 = 38,
  /** RSA_DECRYPT_OAEP_4096_SHA1 - RSAES-OAEP 4096 bit key with a SHA1 digest. */
  RSA_DECRYPT_OAEP_4096_SHA1 = 39,
  /**
   * EC_SIGN_P256_SHA256 - ECDSA on the NIST P-256 curve with a SHA256 digest.
   * Other hash functions can also be used:
   * https://cloud.google.com/kms/docs/create-validate-signatures#ecdsa_support_for_other_hash_algorithms
   */
  EC_SIGN_P256_SHA256 = 12,
  /**
   * EC_SIGN_P384_SHA384 - ECDSA on the NIST P-384 curve with a SHA384 digest.
   * Other hash functions can also be used:
   * https://cloud.google.com/kms/docs/create-validate-signatures#ecdsa_support_for_other_hash_algorithms
   */
  EC_SIGN_P384_SHA384 = 13,
  /**
   * EC_SIGN_SECP256K1_SHA256 - ECDSA on the non-NIST secp256k1 curve. This curve is only supported for
   * HSM protection level.
   * Other hash functions can also be used:
   * https://cloud.google.com/kms/docs/create-validate-signatures#ecdsa_support_for_other_hash_algorithms
   */
  EC_SIGN_SECP256K1_SHA256 = 31,
  /** EC_SIGN_ED25519 - EdDSA on the Curve25519 in pure mode (taking data as input). */
  EC_SIGN_ED25519 = 40,
  /** HMAC_SHA256 - HMAC-SHA256 signing with a 256 bit key. */
  HMAC_SHA256 = 32,
  /** HMAC_SHA1 - HMAC-SHA1 signing with a 160 bit key. */
  HMAC_SHA1 = 33,
  /** HMAC_SHA384 - HMAC-SHA384 signing with a 384 bit key. */
  HMAC_SHA384 = 34,
  /** HMAC_SHA512 - HMAC-SHA512 signing with a 512 bit key. */
  HMAC_SHA512 = 35,
  /** HMAC_SHA224 - HMAC-SHA224 signing with a 224 bit key. */
  HMAC_SHA224 = 36,
  /** EXTERNAL_SYMMETRIC_ENCRYPTION - Algorithm representing symmetric encryption by an external key manager. */
  EXTERNAL_SYMMETRIC_ENCRYPTION = 18,
  UNRECOGNIZED = -1,
}

export function cryptoKeyVersion_CryptoKeyVersionAlgorithmFromJSON(
  object: any,
): CryptoKeyVersion_CryptoKeyVersionAlgorithm {
  switch (object) {
    case 0:
    case "CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED;
    case 1:
    case "GOOGLE_SYMMETRIC_ENCRYPTION":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.GOOGLE_SYMMETRIC_ENCRYPTION;
    case 41:
    case "AES_128_GCM":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.AES_128_GCM;
    case 19:
    case "AES_256_GCM":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.AES_256_GCM;
    case 42:
    case "AES_128_CBC":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.AES_128_CBC;
    case 43:
    case "AES_256_CBC":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.AES_256_CBC;
    case 44:
    case "AES_128_CTR":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.AES_128_CTR;
    case 45:
    case "AES_256_CTR":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.AES_256_CTR;
    case 2:
    case "RSA_SIGN_PSS_2048_SHA256":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256;
    case 3:
    case "RSA_SIGN_PSS_3072_SHA256":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_3072_SHA256;
    case 4:
    case "RSA_SIGN_PSS_4096_SHA256":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_4096_SHA256;
    case 15:
    case "RSA_SIGN_PSS_4096_SHA512":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_4096_SHA512;
    case 5:
    case "RSA_SIGN_PKCS1_2048_SHA256":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_2048_SHA256;
    case 6:
    case "RSA_SIGN_PKCS1_3072_SHA256":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_3072_SHA256;
    case 7:
    case "RSA_SIGN_PKCS1_4096_SHA256":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_4096_SHA256;
    case 16:
    case "RSA_SIGN_PKCS1_4096_SHA512":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_4096_SHA512;
    case 28:
    case "RSA_SIGN_RAW_PKCS1_2048":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_RAW_PKCS1_2048;
    case 29:
    case "RSA_SIGN_RAW_PKCS1_3072":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_RAW_PKCS1_3072;
    case 30:
    case "RSA_SIGN_RAW_PKCS1_4096":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_RAW_PKCS1_4096;
    case 8:
    case "RSA_DECRYPT_OAEP_2048_SHA256":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_2048_SHA256;
    case 9:
    case "RSA_DECRYPT_OAEP_3072_SHA256":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_3072_SHA256;
    case 10:
    case "RSA_DECRYPT_OAEP_4096_SHA256":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_4096_SHA256;
    case 17:
    case "RSA_DECRYPT_OAEP_4096_SHA512":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_4096_SHA512;
    case 37:
    case "RSA_DECRYPT_OAEP_2048_SHA1":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_2048_SHA1;
    case 38:
    case "RSA_DECRYPT_OAEP_3072_SHA1":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_3072_SHA1;
    case 39:
    case "RSA_DECRYPT_OAEP_4096_SHA1":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_4096_SHA1;
    case 12:
    case "EC_SIGN_P256_SHA256":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.EC_SIGN_P256_SHA256;
    case 13:
    case "EC_SIGN_P384_SHA384":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.EC_SIGN_P384_SHA384;
    case 31:
    case "EC_SIGN_SECP256K1_SHA256":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.EC_SIGN_SECP256K1_SHA256;
    case 40:
    case "EC_SIGN_ED25519":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.EC_SIGN_ED25519;
    case 32:
    case "HMAC_SHA256":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.HMAC_SHA256;
    case 33:
    case "HMAC_SHA1":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.HMAC_SHA1;
    case 34:
    case "HMAC_SHA384":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.HMAC_SHA384;
    case 35:
    case "HMAC_SHA512":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.HMAC_SHA512;
    case 36:
    case "HMAC_SHA224":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.HMAC_SHA224;
    case 18:
    case "EXTERNAL_SYMMETRIC_ENCRYPTION":
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.EXTERNAL_SYMMETRIC_ENCRYPTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoKeyVersion_CryptoKeyVersionAlgorithm.UNRECOGNIZED;
  }
}

export function cryptoKeyVersion_CryptoKeyVersionAlgorithmToJSON(
  object: CryptoKeyVersion_CryptoKeyVersionAlgorithm,
): string {
  switch (object) {
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED:
      return "CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.GOOGLE_SYMMETRIC_ENCRYPTION:
      return "GOOGLE_SYMMETRIC_ENCRYPTION";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.AES_128_GCM:
      return "AES_128_GCM";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.AES_256_GCM:
      return "AES_256_GCM";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.AES_128_CBC:
      return "AES_128_CBC";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.AES_256_CBC:
      return "AES_256_CBC";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.AES_128_CTR:
      return "AES_128_CTR";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.AES_256_CTR:
      return "AES_256_CTR";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256:
      return "RSA_SIGN_PSS_2048_SHA256";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_3072_SHA256:
      return "RSA_SIGN_PSS_3072_SHA256";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_4096_SHA256:
      return "RSA_SIGN_PSS_4096_SHA256";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_4096_SHA512:
      return "RSA_SIGN_PSS_4096_SHA512";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_2048_SHA256:
      return "RSA_SIGN_PKCS1_2048_SHA256";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_3072_SHA256:
      return "RSA_SIGN_PKCS1_3072_SHA256";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_4096_SHA256:
      return "RSA_SIGN_PKCS1_4096_SHA256";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_4096_SHA512:
      return "RSA_SIGN_PKCS1_4096_SHA512";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_RAW_PKCS1_2048:
      return "RSA_SIGN_RAW_PKCS1_2048";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_RAW_PKCS1_3072:
      return "RSA_SIGN_RAW_PKCS1_3072";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_SIGN_RAW_PKCS1_4096:
      return "RSA_SIGN_RAW_PKCS1_4096";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_2048_SHA256:
      return "RSA_DECRYPT_OAEP_2048_SHA256";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_3072_SHA256:
      return "RSA_DECRYPT_OAEP_3072_SHA256";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_4096_SHA256:
      return "RSA_DECRYPT_OAEP_4096_SHA256";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_4096_SHA512:
      return "RSA_DECRYPT_OAEP_4096_SHA512";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_2048_SHA1:
      return "RSA_DECRYPT_OAEP_2048_SHA1";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_3072_SHA1:
      return "RSA_DECRYPT_OAEP_3072_SHA1";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.RSA_DECRYPT_OAEP_4096_SHA1:
      return "RSA_DECRYPT_OAEP_4096_SHA1";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.EC_SIGN_P256_SHA256:
      return "EC_SIGN_P256_SHA256";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.EC_SIGN_P384_SHA384:
      return "EC_SIGN_P384_SHA384";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.EC_SIGN_SECP256K1_SHA256:
      return "EC_SIGN_SECP256K1_SHA256";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.EC_SIGN_ED25519:
      return "EC_SIGN_ED25519";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.HMAC_SHA256:
      return "HMAC_SHA256";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.HMAC_SHA1:
      return "HMAC_SHA1";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.HMAC_SHA384:
      return "HMAC_SHA384";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.HMAC_SHA512:
      return "HMAC_SHA512";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.HMAC_SHA224:
      return "HMAC_SHA224";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.EXTERNAL_SYMMETRIC_ENCRYPTION:
      return "EXTERNAL_SYMMETRIC_ENCRYPTION";
    case CryptoKeyVersion_CryptoKeyVersionAlgorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The state of a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion],
 * indicating if it can be used.
 */
export enum CryptoKeyVersion_CryptoKeyVersionState {
  /** CRYPTO_KEY_VERSION_STATE_UNSPECIFIED - Not specified. */
  CRYPTO_KEY_VERSION_STATE_UNSPECIFIED = 0,
  /**
   * PENDING_GENERATION - This version is still being generated. It may not be used, enabled,
   * disabled, or destroyed yet. Cloud KMS will automatically mark this
   * version
   * [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
   * as soon as the version is ready.
   */
  PENDING_GENERATION = 5,
  /** ENABLED - This version may be used for cryptographic operations. */
  ENABLED = 1,
  /**
   * DISABLED - This version may not be used, but the key material is still available,
   * and the version can be placed back into the
   * [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
   * state.
   */
  DISABLED = 2,
  /**
   * DESTROYED - This version is destroyed, and the key material is no longer stored.
   * This version may only become
   * [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
   * again if this version is
   * [reimport_eligible][google.cloud.kms.v1.CryptoKeyVersion.reimport_eligible]
   * and the original key material is reimported with a call to
   * [KeyManagementService.ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion].
   */
  DESTROYED = 3,
  /**
   * DESTROY_SCHEDULED - This version is scheduled for destruction, and will be destroyed soon.
   * Call
   * [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
   * to put it back into the
   * [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED]
   * state.
   */
  DESTROY_SCHEDULED = 4,
  /**
   * PENDING_IMPORT - This version is still being imported. It may not be used, enabled,
   * disabled, or destroyed yet. Cloud KMS will automatically mark this
   * version
   * [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED]
   * as soon as the version is ready.
   */
  PENDING_IMPORT = 6,
  /**
   * IMPORT_FAILED - This version was not imported successfully. It may not be used, enabled,
   * disabled, or destroyed. The submitted key material has been discarded.
   * Additional details can be found in
   * [CryptoKeyVersion.import_failure_reason][google.cloud.kms.v1.CryptoKeyVersion.import_failure_reason].
   */
  IMPORT_FAILED = 7,
  /**
   * GENERATION_FAILED - This version was not generated successfully. It may not be used, enabled,
   * disabled, or destroyed. Additional details can be found in
   * [CryptoKeyVersion.generation_failure_reason][google.cloud.kms.v1.CryptoKeyVersion.generation_failure_reason].
   */
  GENERATION_FAILED = 8,
  /**
   * PENDING_EXTERNAL_DESTRUCTION - This version was destroyed, and it may not be used or enabled again.
   * Cloud KMS is waiting for the corresponding key material residing in an
   * external key manager to be destroyed.
   */
  PENDING_EXTERNAL_DESTRUCTION = 9,
  /**
   * EXTERNAL_DESTRUCTION_FAILED - This version was destroyed, and it may not be used or enabled again.
   * However, Cloud KMS could not confirm that the corresponding key material
   * residing in an external key manager was destroyed. Additional details can
   * be found in
   * [CryptoKeyVersion.external_destruction_failure_reason][google.cloud.kms.v1.CryptoKeyVersion.external_destruction_failure_reason].
   */
  EXTERNAL_DESTRUCTION_FAILED = 10,
  UNRECOGNIZED = -1,
}

export function cryptoKeyVersion_CryptoKeyVersionStateFromJSON(object: any): CryptoKeyVersion_CryptoKeyVersionState {
  switch (object) {
    case 0:
    case "CRYPTO_KEY_VERSION_STATE_UNSPECIFIED":
      return CryptoKeyVersion_CryptoKeyVersionState.CRYPTO_KEY_VERSION_STATE_UNSPECIFIED;
    case 5:
    case "PENDING_GENERATION":
      return CryptoKeyVersion_CryptoKeyVersionState.PENDING_GENERATION;
    case 1:
    case "ENABLED":
      return CryptoKeyVersion_CryptoKeyVersionState.ENABLED;
    case 2:
    case "DISABLED":
      return CryptoKeyVersion_CryptoKeyVersionState.DISABLED;
    case 3:
    case "DESTROYED":
      return CryptoKeyVersion_CryptoKeyVersionState.DESTROYED;
    case 4:
    case "DESTROY_SCHEDULED":
      return CryptoKeyVersion_CryptoKeyVersionState.DESTROY_SCHEDULED;
    case 6:
    case "PENDING_IMPORT":
      return CryptoKeyVersion_CryptoKeyVersionState.PENDING_IMPORT;
    case 7:
    case "IMPORT_FAILED":
      return CryptoKeyVersion_CryptoKeyVersionState.IMPORT_FAILED;
    case 8:
    case "GENERATION_FAILED":
      return CryptoKeyVersion_CryptoKeyVersionState.GENERATION_FAILED;
    case 9:
    case "PENDING_EXTERNAL_DESTRUCTION":
      return CryptoKeyVersion_CryptoKeyVersionState.PENDING_EXTERNAL_DESTRUCTION;
    case 10:
    case "EXTERNAL_DESTRUCTION_FAILED":
      return CryptoKeyVersion_CryptoKeyVersionState.EXTERNAL_DESTRUCTION_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoKeyVersion_CryptoKeyVersionState.UNRECOGNIZED;
  }
}

export function cryptoKeyVersion_CryptoKeyVersionStateToJSON(object: CryptoKeyVersion_CryptoKeyVersionState): string {
  switch (object) {
    case CryptoKeyVersion_CryptoKeyVersionState.CRYPTO_KEY_VERSION_STATE_UNSPECIFIED:
      return "CRYPTO_KEY_VERSION_STATE_UNSPECIFIED";
    case CryptoKeyVersion_CryptoKeyVersionState.PENDING_GENERATION:
      return "PENDING_GENERATION";
    case CryptoKeyVersion_CryptoKeyVersionState.ENABLED:
      return "ENABLED";
    case CryptoKeyVersion_CryptoKeyVersionState.DISABLED:
      return "DISABLED";
    case CryptoKeyVersion_CryptoKeyVersionState.DESTROYED:
      return "DESTROYED";
    case CryptoKeyVersion_CryptoKeyVersionState.DESTROY_SCHEDULED:
      return "DESTROY_SCHEDULED";
    case CryptoKeyVersion_CryptoKeyVersionState.PENDING_IMPORT:
      return "PENDING_IMPORT";
    case CryptoKeyVersion_CryptoKeyVersionState.IMPORT_FAILED:
      return "IMPORT_FAILED";
    case CryptoKeyVersion_CryptoKeyVersionState.GENERATION_FAILED:
      return "GENERATION_FAILED";
    case CryptoKeyVersion_CryptoKeyVersionState.PENDING_EXTERNAL_DESTRUCTION:
      return "PENDING_EXTERNAL_DESTRUCTION";
    case CryptoKeyVersion_CryptoKeyVersionState.EXTERNAL_DESTRUCTION_FAILED:
      return "EXTERNAL_DESTRUCTION_FAILED";
    case CryptoKeyVersion_CryptoKeyVersionState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A view for [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]s.
 * Controls the level of detail returned for
 * [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] in
 * [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions]
 * and
 * [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
 */
export enum CryptoKeyVersion_CryptoKeyVersionView {
  /**
   * CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED - Default view for each
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. Does not
   * include the
   * [attestation][google.cloud.kms.v1.CryptoKeyVersion.attestation] field.
   */
  CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED = 0,
  /**
   * FULL - Provides all fields in each
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], including the
   * [attestation][google.cloud.kms.v1.CryptoKeyVersion.attestation].
   */
  FULL = 1,
  UNRECOGNIZED = -1,
}

export function cryptoKeyVersion_CryptoKeyVersionViewFromJSON(object: any): CryptoKeyVersion_CryptoKeyVersionView {
  switch (object) {
    case 0:
    case "CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED":
      return CryptoKeyVersion_CryptoKeyVersionView.CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED;
    case 1:
    case "FULL":
      return CryptoKeyVersion_CryptoKeyVersionView.FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoKeyVersion_CryptoKeyVersionView.UNRECOGNIZED;
  }
}

export function cryptoKeyVersion_CryptoKeyVersionViewToJSON(object: CryptoKeyVersion_CryptoKeyVersionView): string {
  switch (object) {
    case CryptoKeyVersion_CryptoKeyVersionView.CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED:
      return "CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED";
    case CryptoKeyVersion_CryptoKeyVersionView.FULL:
      return "FULL";
    case CryptoKeyVersion_CryptoKeyVersionView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The public keys for a given
 * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. Obtained via
 * [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
 */
export interface PublicKey {
  /**
   * The public key, encoded in PEM format. For more information, see the
   * [RFC 7468](https://tools.ietf.org/html/rfc7468) sections for
   * [General Considerations](https://tools.ietf.org/html/rfc7468#section-2) and
   * [Textual Encoding of Subject Public Key Info]
   * (https://tools.ietf.org/html/rfc7468#section-13).
   */
  pem: string;
  /**
   * The
   * [Algorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
   * associated with this key.
   */
  algorithm: CryptoKeyVersion_CryptoKeyVersionAlgorithm;
  /**
   * Integrity verification field. A CRC32C checksum of the returned
   * [PublicKey.pem][google.cloud.kms.v1.PublicKey.pem]. An integrity check of
   * [PublicKey.pem][google.cloud.kms.v1.PublicKey.pem] can be performed by
   * computing the CRC32C checksum of
   * [PublicKey.pem][google.cloud.kms.v1.PublicKey.pem] and comparing your
   * results to this field. Discard the response in case of non-matching
   * checksum values, and perform a limited number of retries. A persistent
   * mismatch may indicate an issue in your computation of the CRC32C checksum.
   * Note: This field is defined as int64 for reasons of compatibility across
   * different languages. However, it is a non-negative integer, which will
   * never exceed 2^32-1, and can be safely downconverted to uint32 in languages
   * that support this type.
   *
   * NOTE: This field is in Beta.
   */
  pemCrc32c:
    | Long
    | undefined;
  /**
   * The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] public key.
   * Provided here for verification.
   *
   * NOTE: This field is in Beta.
   */
  name: string;
  /**
   * The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] of the
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] public key.
   */
  protectionLevel: ProtectionLevel;
}

/**
 * An [ImportJob][google.cloud.kms.v1.ImportJob] can be used to create
 * [CryptoKeys][google.cloud.kms.v1.CryptoKey] and
 * [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] using pre-existing
 * key material, generated outside of Cloud KMS.
 *
 * When an [ImportJob][google.cloud.kms.v1.ImportJob] is created, Cloud KMS will
 * generate a "wrapping key", which is a public/private key pair. You use the
 * wrapping key to encrypt (also known as wrap) the pre-existing key material to
 * protect it during the import process. The nature of the wrapping key depends
 * on the choice of
 * [import_method][google.cloud.kms.v1.ImportJob.import_method]. When the
 * wrapping key generation is complete, the
 * [state][google.cloud.kms.v1.ImportJob.state] will be set to
 * [ACTIVE][google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE] and the
 * [public_key][google.cloud.kms.v1.ImportJob.public_key] can be fetched. The
 * fetched public key can then be used to wrap your pre-existing key material.
 *
 * Once the key material is wrapped, it can be imported into a new
 * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in an existing
 * [CryptoKey][google.cloud.kms.v1.CryptoKey] by calling
 * [ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion].
 * Multiple [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] can be
 * imported with a single [ImportJob][google.cloud.kms.v1.ImportJob]. Cloud KMS
 * uses the private key portion of the wrapping key to unwrap the key material.
 * Only Cloud KMS has access to the private key.
 *
 * An [ImportJob][google.cloud.kms.v1.ImportJob] expires 3 days after it is
 * created. Once expired, Cloud KMS will no longer be able to import or unwrap
 * any key material that was wrapped with the
 * [ImportJob][google.cloud.kms.v1.ImportJob]'s public key.
 *
 * For more information, see
 * [Importing a key](https://cloud.google.com/kms/docs/importing-a-key).
 */
export interface ImportJob {
  /**
   * Output only. The resource name for this
   * [ImportJob][google.cloud.kms.v1.ImportJob] in the format
   * `projects/* /locations/* /keyRings/* /importJobs/*`.
   */
  name: string;
  /**
   * Required. Immutable. The wrapping method to be used for incoming key
   * material.
   */
  importMethod: ImportJob_ImportMethod;
  /**
   * Required. Immutable. The protection level of the
   * [ImportJob][google.cloud.kms.v1.ImportJob]. This must match the
   * [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]
   * of the [version_template][google.cloud.kms.v1.CryptoKey.version_template]
   * on the [CryptoKey][google.cloud.kms.v1.CryptoKey] you attempt to import
   * into.
   */
  protectionLevel: ProtectionLevel;
  /**
   * Output only. The time at which this
   * [ImportJob][google.cloud.kms.v1.ImportJob] was created.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The time this [ImportJob][google.cloud.kms.v1.ImportJob]'s key
   * material was generated.
   */
  generateTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which this
   * [ImportJob][google.cloud.kms.v1.ImportJob] is scheduled for expiration and
   * can no longer be used to import key material.
   */
  expireTime:
    | Date
    | undefined;
  /**
   * Output only. The time this [ImportJob][google.cloud.kms.v1.ImportJob]
   * expired. Only present if [state][google.cloud.kms.v1.ImportJob.state] is
   * [EXPIRED][google.cloud.kms.v1.ImportJob.ImportJobState.EXPIRED].
   */
  expireEventTime:
    | Date
    | undefined;
  /**
   * Output only. The current state of the
   * [ImportJob][google.cloud.kms.v1.ImportJob], indicating if it can be used.
   */
  state: ImportJob_ImportJobState;
  /**
   * Output only. The public key with which to wrap key material prior to
   * import. Only returned if [state][google.cloud.kms.v1.ImportJob.state] is
   * [ACTIVE][google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE].
   */
  publicKey:
    | ImportJob_WrappingPublicKey
    | undefined;
  /**
   * Output only. Statement that was generated and signed by the key creator
   * (for example, an HSM) at key creation time. Use this statement to verify
   * attributes of the key as stored on the HSM, independently of Google.
   * Only present if the chosen
   * [ImportMethod][google.cloud.kms.v1.ImportJob.ImportMethod] is one with a
   * protection level of [HSM][google.cloud.kms.v1.ProtectionLevel.HSM].
   */
  attestation: KeyOperationAttestation | undefined;
}

/**
 * [ImportMethod][google.cloud.kms.v1.ImportJob.ImportMethod] describes the
 * key wrapping method chosen for this
 * [ImportJob][google.cloud.kms.v1.ImportJob].
 */
export enum ImportJob_ImportMethod {
  /** IMPORT_METHOD_UNSPECIFIED - Not specified. */
  IMPORT_METHOD_UNSPECIFIED = 0,
  /**
   * RSA_OAEP_3072_SHA1_AES_256 - This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
   * scheme defined in the PKCS #11 standard. In summary, this involves
   * wrapping the raw key with an ephemeral AES key, and wrapping the
   * ephemeral AES key with a 3072 bit RSA key. For more details, see
   * [RSA AES key wrap
   * mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
   */
  RSA_OAEP_3072_SHA1_AES_256 = 1,
  /**
   * RSA_OAEP_4096_SHA1_AES_256 - This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
   * scheme defined in the PKCS #11 standard. In summary, this involves
   * wrapping the raw key with an ephemeral AES key, and wrapping the
   * ephemeral AES key with a 4096 bit RSA key. For more details, see
   * [RSA AES key wrap
   * mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
   */
  RSA_OAEP_4096_SHA1_AES_256 = 2,
  /**
   * RSA_OAEP_3072_SHA256_AES_256 - This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
   * scheme defined in the PKCS #11 standard. In summary, this involves
   * wrapping the raw key with an ephemeral AES key, and wrapping the
   * ephemeral AES key with a 3072 bit RSA key. For more details, see
   * [RSA AES key wrap
   * mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
   */
  RSA_OAEP_3072_SHA256_AES_256 = 3,
  /**
   * RSA_OAEP_4096_SHA256_AES_256 - This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
   * scheme defined in the PKCS #11 standard. In summary, this involves
   * wrapping the raw key with an ephemeral AES key, and wrapping the
   * ephemeral AES key with a 4096 bit RSA key. For more details, see
   * [RSA AES key wrap
   * mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
   */
  RSA_OAEP_4096_SHA256_AES_256 = 4,
  /**
   * RSA_OAEP_3072_SHA256 - This ImportMethod represents RSAES-OAEP with a 3072 bit RSA key. The
   * key material to be imported is wrapped directly with the RSA key. Due
   * to technical limitations of RSA wrapping, this method cannot be used to
   * wrap RSA keys for import.
   */
  RSA_OAEP_3072_SHA256 = 5,
  /**
   * RSA_OAEP_4096_SHA256 - This ImportMethod represents RSAES-OAEP with a 4096 bit RSA key. The
   * key material to be imported is wrapped directly with the RSA key. Due
   * to technical limitations of RSA wrapping, this method cannot be used to
   * wrap RSA keys for import.
   */
  RSA_OAEP_4096_SHA256 = 6,
  UNRECOGNIZED = -1,
}

export function importJob_ImportMethodFromJSON(object: any): ImportJob_ImportMethod {
  switch (object) {
    case 0:
    case "IMPORT_METHOD_UNSPECIFIED":
      return ImportJob_ImportMethod.IMPORT_METHOD_UNSPECIFIED;
    case 1:
    case "RSA_OAEP_3072_SHA1_AES_256":
      return ImportJob_ImportMethod.RSA_OAEP_3072_SHA1_AES_256;
    case 2:
    case "RSA_OAEP_4096_SHA1_AES_256":
      return ImportJob_ImportMethod.RSA_OAEP_4096_SHA1_AES_256;
    case 3:
    case "RSA_OAEP_3072_SHA256_AES_256":
      return ImportJob_ImportMethod.RSA_OAEP_3072_SHA256_AES_256;
    case 4:
    case "RSA_OAEP_4096_SHA256_AES_256":
      return ImportJob_ImportMethod.RSA_OAEP_4096_SHA256_AES_256;
    case 5:
    case "RSA_OAEP_3072_SHA256":
      return ImportJob_ImportMethod.RSA_OAEP_3072_SHA256;
    case 6:
    case "RSA_OAEP_4096_SHA256":
      return ImportJob_ImportMethod.RSA_OAEP_4096_SHA256;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImportJob_ImportMethod.UNRECOGNIZED;
  }
}

export function importJob_ImportMethodToJSON(object: ImportJob_ImportMethod): string {
  switch (object) {
    case ImportJob_ImportMethod.IMPORT_METHOD_UNSPECIFIED:
      return "IMPORT_METHOD_UNSPECIFIED";
    case ImportJob_ImportMethod.RSA_OAEP_3072_SHA1_AES_256:
      return "RSA_OAEP_3072_SHA1_AES_256";
    case ImportJob_ImportMethod.RSA_OAEP_4096_SHA1_AES_256:
      return "RSA_OAEP_4096_SHA1_AES_256";
    case ImportJob_ImportMethod.RSA_OAEP_3072_SHA256_AES_256:
      return "RSA_OAEP_3072_SHA256_AES_256";
    case ImportJob_ImportMethod.RSA_OAEP_4096_SHA256_AES_256:
      return "RSA_OAEP_4096_SHA256_AES_256";
    case ImportJob_ImportMethod.RSA_OAEP_3072_SHA256:
      return "RSA_OAEP_3072_SHA256";
    case ImportJob_ImportMethod.RSA_OAEP_4096_SHA256:
      return "RSA_OAEP_4096_SHA256";
    case ImportJob_ImportMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The state of the [ImportJob][google.cloud.kms.v1.ImportJob], indicating if
 * it can be used.
 */
export enum ImportJob_ImportJobState {
  /** IMPORT_JOB_STATE_UNSPECIFIED - Not specified. */
  IMPORT_JOB_STATE_UNSPECIFIED = 0,
  /**
   * PENDING_GENERATION - The wrapping key for this job is still being generated. It may not be
   * used. Cloud KMS will automatically mark this job as
   * [ACTIVE][google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE] as soon as
   * the wrapping key is generated.
   */
  PENDING_GENERATION = 1,
  /**
   * ACTIVE - This job may be used in
   * [CreateCryptoKey][google.cloud.kms.v1.KeyManagementService.CreateCryptoKey]
   * and
   * [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
   * requests.
   */
  ACTIVE = 2,
  /** EXPIRED - This job can no longer be used and may not leave this state once entered. */
  EXPIRED = 3,
  UNRECOGNIZED = -1,
}

export function importJob_ImportJobStateFromJSON(object: any): ImportJob_ImportJobState {
  switch (object) {
    case 0:
    case "IMPORT_JOB_STATE_UNSPECIFIED":
      return ImportJob_ImportJobState.IMPORT_JOB_STATE_UNSPECIFIED;
    case 1:
    case "PENDING_GENERATION":
      return ImportJob_ImportJobState.PENDING_GENERATION;
    case 2:
    case "ACTIVE":
      return ImportJob_ImportJobState.ACTIVE;
    case 3:
    case "EXPIRED":
      return ImportJob_ImportJobState.EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImportJob_ImportJobState.UNRECOGNIZED;
  }
}

export function importJob_ImportJobStateToJSON(object: ImportJob_ImportJobState): string {
  switch (object) {
    case ImportJob_ImportJobState.IMPORT_JOB_STATE_UNSPECIFIED:
      return "IMPORT_JOB_STATE_UNSPECIFIED";
    case ImportJob_ImportJobState.PENDING_GENERATION:
      return "PENDING_GENERATION";
    case ImportJob_ImportJobState.ACTIVE:
      return "ACTIVE";
    case ImportJob_ImportJobState.EXPIRED:
      return "EXPIRED";
    case ImportJob_ImportJobState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The public key component of the wrapping key. For details of the type of
 * key this public key corresponds to, see the
 * [ImportMethod][google.cloud.kms.v1.ImportJob.ImportMethod].
 */
export interface ImportJob_WrappingPublicKey {
  /**
   * The public key, encoded in PEM format. For more information, see the [RFC
   * 7468](https://tools.ietf.org/html/rfc7468) sections for [General
   * Considerations](https://tools.ietf.org/html/rfc7468#section-2) and
   * [Textual Encoding of Subject Public Key Info]
   * (https://tools.ietf.org/html/rfc7468#section-13).
   */
  pem: string;
}

/**
 * ExternalProtectionLevelOptions stores a group of additional fields for
 * configuring a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] that
 * are specific to the [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL]
 * protection level and
 * [EXTERNAL_VPC][google.cloud.kms.v1.ProtectionLevel.EXTERNAL_VPC] protection
 * levels.
 */
export interface ExternalProtectionLevelOptions {
  /**
   * The URI for an external resource that this
   * [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] represents.
   */
  externalKeyUri: string;
  /**
   * The path to the external key material on the EKM when using
   * [EkmConnection][google.cloud.kms.v1.EkmConnection] e.g., "v0/my/key". Set
   * this field instead of external_key_uri when using an
   * [EkmConnection][google.cloud.kms.v1.EkmConnection].
   */
  ekmConnectionKeyPath: string;
}

/**
 * A
 * [KeyAccessJustificationsPolicy][google.cloud.kms.v1.KeyAccessJustificationsPolicy]
 * specifies zero or more allowed
 * [AccessReason][google.cloud.kms.v1.AccessReason] values for encrypt, decrypt,
 * and sign operations on a [CryptoKey][google.cloud.kms.v1.CryptoKey].
 */
export interface KeyAccessJustificationsPolicy {
  /**
   * The list of allowed reasons for access to a
   * [CryptoKey][google.cloud.kms.v1.CryptoKey]. Zero allowed access reasons
   * means all encrypt, decrypt, and sign operations for the
   * [CryptoKey][google.cloud.kms.v1.CryptoKey] associated with this policy will
   * fail.
   */
  allowedAccessReasons: AccessReason[];
}

function createBaseKeyRing(): KeyRing {
  return { name: "", createTime: undefined };
}

export const KeyRing: MessageFns<KeyRing> = {
  encode(message: KeyRing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyRing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyRing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyRing {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: KeyRing): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<KeyRing>): KeyRing {
    return KeyRing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyRing>): KeyRing {
    const message = createBaseKeyRing();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseCryptoKey(): CryptoKey {
  return {
    name: "",
    primary: undefined,
    purpose: 0,
    createTime: undefined,
    nextRotationTime: undefined,
    rotationPeriod: undefined,
    versionTemplate: undefined,
    labels: {},
    importOnly: false,
    destroyScheduledDuration: undefined,
    cryptoKeyBackend: "",
    keyAccessJustificationsPolicy: undefined,
  };
}

export const CryptoKey: MessageFns<CryptoKey> = {
  encode(message: CryptoKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.primary !== undefined) {
      CryptoKeyVersion.encode(message.primary, writer.uint32(18).fork()).join();
    }
    if (message.purpose !== 0) {
      writer.uint32(24).int32(message.purpose);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.nextRotationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.nextRotationTime), writer.uint32(58).fork()).join();
    }
    if (message.rotationPeriod !== undefined) {
      Duration.encode(message.rotationPeriod, writer.uint32(66).fork()).join();
    }
    if (message.versionTemplate !== undefined) {
      CryptoKeyVersionTemplate.encode(message.versionTemplate, writer.uint32(90).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CryptoKey_LabelsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.importOnly !== false) {
      writer.uint32(104).bool(message.importOnly);
    }
    if (message.destroyScheduledDuration !== undefined) {
      Duration.encode(message.destroyScheduledDuration, writer.uint32(114).fork()).join();
    }
    if (message.cryptoKeyBackend !== "") {
      writer.uint32(122).string(message.cryptoKeyBackend);
    }
    if (message.keyAccessJustificationsPolicy !== undefined) {
      KeyAccessJustificationsPolicy.encode(message.keyAccessJustificationsPolicy, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.primary = CryptoKeyVersion.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.purpose = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.nextRotationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.rotationPeriod = Duration.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.versionTemplate = CryptoKeyVersionTemplate.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = CryptoKey_LabelsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.labels[entry10.key] = entry10.value;
          }
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.importOnly = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.destroyScheduledDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.cryptoKeyBackend = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.keyAccessJustificationsPolicy = KeyAccessJustificationsPolicy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoKey {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      primary: isSet(object.primary) ? CryptoKeyVersion.fromJSON(object.primary) : undefined,
      purpose: isSet(object.purpose) ? cryptoKey_CryptoKeyPurposeFromJSON(object.purpose) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      nextRotationTime: isSet(object.nextRotationTime) ? fromJsonTimestamp(object.nextRotationTime) : undefined,
      rotationPeriod: isSet(object.rotationPeriod) ? Duration.fromJSON(object.rotationPeriod) : undefined,
      versionTemplate: isSet(object.versionTemplate)
        ? CryptoKeyVersionTemplate.fromJSON(object.versionTemplate)
        : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      importOnly: isSet(object.importOnly) ? globalThis.Boolean(object.importOnly) : false,
      destroyScheduledDuration: isSet(object.destroyScheduledDuration)
        ? Duration.fromJSON(object.destroyScheduledDuration)
        : undefined,
      cryptoKeyBackend: isSet(object.cryptoKeyBackend) ? globalThis.String(object.cryptoKeyBackend) : "",
      keyAccessJustificationsPolicy: isSet(object.keyAccessJustificationsPolicy)
        ? KeyAccessJustificationsPolicy.fromJSON(object.keyAccessJustificationsPolicy)
        : undefined,
    };
  },

  toJSON(message: CryptoKey): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.primary !== undefined) {
      obj.primary = CryptoKeyVersion.toJSON(message.primary);
    }
    if (message.purpose !== 0) {
      obj.purpose = cryptoKey_CryptoKeyPurposeToJSON(message.purpose);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.nextRotationTime !== undefined) {
      obj.nextRotationTime = message.nextRotationTime.toISOString();
    }
    if (message.rotationPeriod !== undefined) {
      obj.rotationPeriod = Duration.toJSON(message.rotationPeriod);
    }
    if (message.versionTemplate !== undefined) {
      obj.versionTemplate = CryptoKeyVersionTemplate.toJSON(message.versionTemplate);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.importOnly !== false) {
      obj.importOnly = message.importOnly;
    }
    if (message.destroyScheduledDuration !== undefined) {
      obj.destroyScheduledDuration = Duration.toJSON(message.destroyScheduledDuration);
    }
    if (message.cryptoKeyBackend !== "") {
      obj.cryptoKeyBackend = message.cryptoKeyBackend;
    }
    if (message.keyAccessJustificationsPolicy !== undefined) {
      obj.keyAccessJustificationsPolicy = KeyAccessJustificationsPolicy.toJSON(message.keyAccessJustificationsPolicy);
    }
    return obj;
  },

  create(base?: DeepPartial<CryptoKey>): CryptoKey {
    return CryptoKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CryptoKey>): CryptoKey {
    const message = createBaseCryptoKey();
    message.name = object.name ?? "";
    message.primary = (object.primary !== undefined && object.primary !== null)
      ? CryptoKeyVersion.fromPartial(object.primary)
      : undefined;
    message.purpose = object.purpose ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.nextRotationTime = object.nextRotationTime ?? undefined;
    message.rotationPeriod = (object.rotationPeriod !== undefined && object.rotationPeriod !== null)
      ? Duration.fromPartial(object.rotationPeriod)
      : undefined;
    message.versionTemplate = (object.versionTemplate !== undefined && object.versionTemplate !== null)
      ? CryptoKeyVersionTemplate.fromPartial(object.versionTemplate)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.importOnly = object.importOnly ?? false;
    message.destroyScheduledDuration =
      (object.destroyScheduledDuration !== undefined && object.destroyScheduledDuration !== null)
        ? Duration.fromPartial(object.destroyScheduledDuration)
        : undefined;
    message.cryptoKeyBackend = object.cryptoKeyBackend ?? "";
    message.keyAccessJustificationsPolicy =
      (object.keyAccessJustificationsPolicy !== undefined && object.keyAccessJustificationsPolicy !== null)
        ? KeyAccessJustificationsPolicy.fromPartial(object.keyAccessJustificationsPolicy)
        : undefined;
    return message;
  },
};

function createBaseCryptoKey_LabelsEntry(): CryptoKey_LabelsEntry {
  return { key: "", value: "" };
}

export const CryptoKey_LabelsEntry: MessageFns<CryptoKey_LabelsEntry> = {
  encode(message: CryptoKey_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoKey_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoKey_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoKey_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CryptoKey_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CryptoKey_LabelsEntry>): CryptoKey_LabelsEntry {
    return CryptoKey_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CryptoKey_LabelsEntry>): CryptoKey_LabelsEntry {
    const message = createBaseCryptoKey_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCryptoKeyVersionTemplate(): CryptoKeyVersionTemplate {
  return { protectionLevel: 0, algorithm: 0 };
}

export const CryptoKeyVersionTemplate: MessageFns<CryptoKeyVersionTemplate> = {
  encode(message: CryptoKeyVersionTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protectionLevel !== 0) {
      writer.uint32(8).int32(message.protectionLevel);
    }
    if (message.algorithm !== 0) {
      writer.uint32(24).int32(message.algorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoKeyVersionTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoKeyVersionTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.protectionLevel = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoKeyVersionTemplate {
    return {
      protectionLevel: isSet(object.protectionLevel) ? protectionLevelFromJSON(object.protectionLevel) : 0,
      algorithm: isSet(object.algorithm) ? cryptoKeyVersion_CryptoKeyVersionAlgorithmFromJSON(object.algorithm) : 0,
    };
  },

  toJSON(message: CryptoKeyVersionTemplate): unknown {
    const obj: any = {};
    if (message.protectionLevel !== 0) {
      obj.protectionLevel = protectionLevelToJSON(message.protectionLevel);
    }
    if (message.algorithm !== 0) {
      obj.algorithm = cryptoKeyVersion_CryptoKeyVersionAlgorithmToJSON(message.algorithm);
    }
    return obj;
  },

  create(base?: DeepPartial<CryptoKeyVersionTemplate>): CryptoKeyVersionTemplate {
    return CryptoKeyVersionTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CryptoKeyVersionTemplate>): CryptoKeyVersionTemplate {
    const message = createBaseCryptoKeyVersionTemplate();
    message.protectionLevel = object.protectionLevel ?? 0;
    message.algorithm = object.algorithm ?? 0;
    return message;
  },
};

function createBaseKeyOperationAttestation(): KeyOperationAttestation {
  return { format: 0, content: Buffer.alloc(0), certChains: undefined };
}

export const KeyOperationAttestation: MessageFns<KeyOperationAttestation> = {
  encode(message: KeyOperationAttestation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== 0) {
      writer.uint32(32).int32(message.format);
    }
    if (message.content.length !== 0) {
      writer.uint32(42).bytes(message.content);
    }
    if (message.certChains !== undefined) {
      KeyOperationAttestation_CertificateChains.encode(message.certChains, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyOperationAttestation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyOperationAttestation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 32) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.certChains = KeyOperationAttestation_CertificateChains.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyOperationAttestation {
    return {
      format: isSet(object.format) ? keyOperationAttestation_AttestationFormatFromJSON(object.format) : 0,
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : Buffer.alloc(0),
      certChains: isSet(object.certChains)
        ? KeyOperationAttestation_CertificateChains.fromJSON(object.certChains)
        : undefined,
    };
  },

  toJSON(message: KeyOperationAttestation): unknown {
    const obj: any = {};
    if (message.format !== 0) {
      obj.format = keyOperationAttestation_AttestationFormatToJSON(message.format);
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.certChains !== undefined) {
      obj.certChains = KeyOperationAttestation_CertificateChains.toJSON(message.certChains);
    }
    return obj;
  },

  create(base?: DeepPartial<KeyOperationAttestation>): KeyOperationAttestation {
    return KeyOperationAttestation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyOperationAttestation>): KeyOperationAttestation {
    const message = createBaseKeyOperationAttestation();
    message.format = object.format ?? 0;
    message.content = object.content ?? Buffer.alloc(0);
    message.certChains = (object.certChains !== undefined && object.certChains !== null)
      ? KeyOperationAttestation_CertificateChains.fromPartial(object.certChains)
      : undefined;
    return message;
  },
};

function createBaseKeyOperationAttestation_CertificateChains(): KeyOperationAttestation_CertificateChains {
  return { caviumCerts: [], googleCardCerts: [], googlePartitionCerts: [] };
}

export const KeyOperationAttestation_CertificateChains: MessageFns<KeyOperationAttestation_CertificateChains> = {
  encode(message: KeyOperationAttestation_CertificateChains, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.caviumCerts) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.googleCardCerts) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.googlePartitionCerts) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyOperationAttestation_CertificateChains {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyOperationAttestation_CertificateChains();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.caviumCerts.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.googleCardCerts.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.googlePartitionCerts.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyOperationAttestation_CertificateChains {
    return {
      caviumCerts: globalThis.Array.isArray(object?.caviumCerts)
        ? object.caviumCerts.map((e: any) => globalThis.String(e))
        : [],
      googleCardCerts: globalThis.Array.isArray(object?.googleCardCerts)
        ? object.googleCardCerts.map((e: any) => globalThis.String(e))
        : [],
      googlePartitionCerts: globalThis.Array.isArray(object?.googlePartitionCerts)
        ? object.googlePartitionCerts.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: KeyOperationAttestation_CertificateChains): unknown {
    const obj: any = {};
    if (message.caviumCerts?.length) {
      obj.caviumCerts = message.caviumCerts;
    }
    if (message.googleCardCerts?.length) {
      obj.googleCardCerts = message.googleCardCerts;
    }
    if (message.googlePartitionCerts?.length) {
      obj.googlePartitionCerts = message.googlePartitionCerts;
    }
    return obj;
  },

  create(base?: DeepPartial<KeyOperationAttestation_CertificateChains>): KeyOperationAttestation_CertificateChains {
    return KeyOperationAttestation_CertificateChains.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<KeyOperationAttestation_CertificateChains>,
  ): KeyOperationAttestation_CertificateChains {
    const message = createBaseKeyOperationAttestation_CertificateChains();
    message.caviumCerts = object.caviumCerts?.map((e) => e) || [];
    message.googleCardCerts = object.googleCardCerts?.map((e) => e) || [];
    message.googlePartitionCerts = object.googlePartitionCerts?.map((e) => e) || [];
    return message;
  },
};

function createBaseCryptoKeyVersion(): CryptoKeyVersion {
  return {
    name: "",
    state: 0,
    protectionLevel: 0,
    algorithm: 0,
    attestation: undefined,
    createTime: undefined,
    generateTime: undefined,
    destroyTime: undefined,
    destroyEventTime: undefined,
    importJob: "",
    importTime: undefined,
    importFailureReason: "",
    generationFailureReason: "",
    externalDestructionFailureReason: "",
    externalProtectionLevelOptions: undefined,
    reimportEligible: false,
  };
}

export const CryptoKeyVersion: MessageFns<CryptoKeyVersion> = {
  encode(message: CryptoKeyVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.protectionLevel !== 0) {
      writer.uint32(56).int32(message.protectionLevel);
    }
    if (message.algorithm !== 0) {
      writer.uint32(80).int32(message.algorithm);
    }
    if (message.attestation !== undefined) {
      KeyOperationAttestation.encode(message.attestation, writer.uint32(66).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.generateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.generateTime), writer.uint32(90).fork()).join();
    }
    if (message.destroyTime !== undefined) {
      Timestamp.encode(toTimestamp(message.destroyTime), writer.uint32(42).fork()).join();
    }
    if (message.destroyEventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.destroyEventTime), writer.uint32(50).fork()).join();
    }
    if (message.importJob !== "") {
      writer.uint32(114).string(message.importJob);
    }
    if (message.importTime !== undefined) {
      Timestamp.encode(toTimestamp(message.importTime), writer.uint32(122).fork()).join();
    }
    if (message.importFailureReason !== "") {
      writer.uint32(130).string(message.importFailureReason);
    }
    if (message.generationFailureReason !== "") {
      writer.uint32(154).string(message.generationFailureReason);
    }
    if (message.externalDestructionFailureReason !== "") {
      writer.uint32(162).string(message.externalDestructionFailureReason);
    }
    if (message.externalProtectionLevelOptions !== undefined) {
      ExternalProtectionLevelOptions.encode(message.externalProtectionLevelOptions, writer.uint32(138).fork()).join();
    }
    if (message.reimportEligible !== false) {
      writer.uint32(144).bool(message.reimportEligible);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoKeyVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoKeyVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.protectionLevel = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.attestation = KeyOperationAttestation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.generateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.destroyTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.destroyEventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.importJob = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.importTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.importFailureReason = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.generationFailureReason = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.externalDestructionFailureReason = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.externalProtectionLevelOptions = ExternalProtectionLevelOptions.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.reimportEligible = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoKeyVersion {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? cryptoKeyVersion_CryptoKeyVersionStateFromJSON(object.state) : 0,
      protectionLevel: isSet(object.protectionLevel) ? protectionLevelFromJSON(object.protectionLevel) : 0,
      algorithm: isSet(object.algorithm) ? cryptoKeyVersion_CryptoKeyVersionAlgorithmFromJSON(object.algorithm) : 0,
      attestation: isSet(object.attestation) ? KeyOperationAttestation.fromJSON(object.attestation) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      generateTime: isSet(object.generateTime) ? fromJsonTimestamp(object.generateTime) : undefined,
      destroyTime: isSet(object.destroyTime) ? fromJsonTimestamp(object.destroyTime) : undefined,
      destroyEventTime: isSet(object.destroyEventTime) ? fromJsonTimestamp(object.destroyEventTime) : undefined,
      importJob: isSet(object.importJob) ? globalThis.String(object.importJob) : "",
      importTime: isSet(object.importTime) ? fromJsonTimestamp(object.importTime) : undefined,
      importFailureReason: isSet(object.importFailureReason) ? globalThis.String(object.importFailureReason) : "",
      generationFailureReason: isSet(object.generationFailureReason)
        ? globalThis.String(object.generationFailureReason)
        : "",
      externalDestructionFailureReason: isSet(object.externalDestructionFailureReason)
        ? globalThis.String(object.externalDestructionFailureReason)
        : "",
      externalProtectionLevelOptions: isSet(object.externalProtectionLevelOptions)
        ? ExternalProtectionLevelOptions.fromJSON(object.externalProtectionLevelOptions)
        : undefined,
      reimportEligible: isSet(object.reimportEligible) ? globalThis.Boolean(object.reimportEligible) : false,
    };
  },

  toJSON(message: CryptoKeyVersion): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = cryptoKeyVersion_CryptoKeyVersionStateToJSON(message.state);
    }
    if (message.protectionLevel !== 0) {
      obj.protectionLevel = protectionLevelToJSON(message.protectionLevel);
    }
    if (message.algorithm !== 0) {
      obj.algorithm = cryptoKeyVersion_CryptoKeyVersionAlgorithmToJSON(message.algorithm);
    }
    if (message.attestation !== undefined) {
      obj.attestation = KeyOperationAttestation.toJSON(message.attestation);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.generateTime !== undefined) {
      obj.generateTime = message.generateTime.toISOString();
    }
    if (message.destroyTime !== undefined) {
      obj.destroyTime = message.destroyTime.toISOString();
    }
    if (message.destroyEventTime !== undefined) {
      obj.destroyEventTime = message.destroyEventTime.toISOString();
    }
    if (message.importJob !== "") {
      obj.importJob = message.importJob;
    }
    if (message.importTime !== undefined) {
      obj.importTime = message.importTime.toISOString();
    }
    if (message.importFailureReason !== "") {
      obj.importFailureReason = message.importFailureReason;
    }
    if (message.generationFailureReason !== "") {
      obj.generationFailureReason = message.generationFailureReason;
    }
    if (message.externalDestructionFailureReason !== "") {
      obj.externalDestructionFailureReason = message.externalDestructionFailureReason;
    }
    if (message.externalProtectionLevelOptions !== undefined) {
      obj.externalProtectionLevelOptions = ExternalProtectionLevelOptions.toJSON(
        message.externalProtectionLevelOptions,
      );
    }
    if (message.reimportEligible !== false) {
      obj.reimportEligible = message.reimportEligible;
    }
    return obj;
  },

  create(base?: DeepPartial<CryptoKeyVersion>): CryptoKeyVersion {
    return CryptoKeyVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CryptoKeyVersion>): CryptoKeyVersion {
    const message = createBaseCryptoKeyVersion();
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.protectionLevel = object.protectionLevel ?? 0;
    message.algorithm = object.algorithm ?? 0;
    message.attestation = (object.attestation !== undefined && object.attestation !== null)
      ? KeyOperationAttestation.fromPartial(object.attestation)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.generateTime = object.generateTime ?? undefined;
    message.destroyTime = object.destroyTime ?? undefined;
    message.destroyEventTime = object.destroyEventTime ?? undefined;
    message.importJob = object.importJob ?? "";
    message.importTime = object.importTime ?? undefined;
    message.importFailureReason = object.importFailureReason ?? "";
    message.generationFailureReason = object.generationFailureReason ?? "";
    message.externalDestructionFailureReason = object.externalDestructionFailureReason ?? "";
    message.externalProtectionLevelOptions =
      (object.externalProtectionLevelOptions !== undefined && object.externalProtectionLevelOptions !== null)
        ? ExternalProtectionLevelOptions.fromPartial(object.externalProtectionLevelOptions)
        : undefined;
    message.reimportEligible = object.reimportEligible ?? false;
    return message;
  },
};

function createBasePublicKey(): PublicKey {
  return { pem: "", algorithm: 0, pemCrc32c: undefined, name: "", protectionLevel: 0 };
}

export const PublicKey: MessageFns<PublicKey> = {
  encode(message: PublicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pem !== "") {
      writer.uint32(10).string(message.pem);
    }
    if (message.algorithm !== 0) {
      writer.uint32(16).int32(message.algorithm);
    }
    if (message.pemCrc32c !== undefined) {
      Int64Value.encode({ value: message.pemCrc32c! }, writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.protectionLevel !== 0) {
      writer.uint32(40).int32(message.protectionLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pem = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pemCrc32c = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.protectionLevel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicKey {
    return {
      pem: isSet(object.pem) ? globalThis.String(object.pem) : "",
      algorithm: isSet(object.algorithm) ? cryptoKeyVersion_CryptoKeyVersionAlgorithmFromJSON(object.algorithm) : 0,
      pemCrc32c: isSet(object.pemCrc32c) ? Long.fromValue(object.pemCrc32c) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      protectionLevel: isSet(object.protectionLevel) ? protectionLevelFromJSON(object.protectionLevel) : 0,
    };
  },

  toJSON(message: PublicKey): unknown {
    const obj: any = {};
    if (message.pem !== "") {
      obj.pem = message.pem;
    }
    if (message.algorithm !== 0) {
      obj.algorithm = cryptoKeyVersion_CryptoKeyVersionAlgorithmToJSON(message.algorithm);
    }
    if (message.pemCrc32c !== undefined) {
      obj.pemCrc32c = message.pemCrc32c;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.protectionLevel !== 0) {
      obj.protectionLevel = protectionLevelToJSON(message.protectionLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<PublicKey>): PublicKey {
    return PublicKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublicKey>): PublicKey {
    const message = createBasePublicKey();
    message.pem = object.pem ?? "";
    message.algorithm = object.algorithm ?? 0;
    message.pemCrc32c = (object.pemCrc32c !== undefined && object.pemCrc32c !== null)
      ? Long.fromValue(object.pemCrc32c)
      : undefined;
    message.name = object.name ?? "";
    message.protectionLevel = object.protectionLevel ?? 0;
    return message;
  },
};

function createBaseImportJob(): ImportJob {
  return {
    name: "",
    importMethod: 0,
    protectionLevel: 0,
    createTime: undefined,
    generateTime: undefined,
    expireTime: undefined,
    expireEventTime: undefined,
    state: 0,
    publicKey: undefined,
    attestation: undefined,
  };
}

export const ImportJob: MessageFns<ImportJob> = {
  encode(message: ImportJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.importMethod !== 0) {
      writer.uint32(16).int32(message.importMethod);
    }
    if (message.protectionLevel !== 0) {
      writer.uint32(72).int32(message.protectionLevel);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.generateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.generateTime), writer.uint32(34).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(42).fork()).join();
    }
    if (message.expireEventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireEventTime), writer.uint32(82).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.publicKey !== undefined) {
      ImportJob_WrappingPublicKey.encode(message.publicKey, writer.uint32(58).fork()).join();
    }
    if (message.attestation !== undefined) {
      KeyOperationAttestation.encode(message.attestation, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.importMethod = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.protectionLevel = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.generateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.expireEventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.publicKey = ImportJob_WrappingPublicKey.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.attestation = KeyOperationAttestation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportJob {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      importMethod: isSet(object.importMethod) ? importJob_ImportMethodFromJSON(object.importMethod) : 0,
      protectionLevel: isSet(object.protectionLevel) ? protectionLevelFromJSON(object.protectionLevel) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      generateTime: isSet(object.generateTime) ? fromJsonTimestamp(object.generateTime) : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      expireEventTime: isSet(object.expireEventTime) ? fromJsonTimestamp(object.expireEventTime) : undefined,
      state: isSet(object.state) ? importJob_ImportJobStateFromJSON(object.state) : 0,
      publicKey: isSet(object.publicKey) ? ImportJob_WrappingPublicKey.fromJSON(object.publicKey) : undefined,
      attestation: isSet(object.attestation) ? KeyOperationAttestation.fromJSON(object.attestation) : undefined,
    };
  },

  toJSON(message: ImportJob): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.importMethod !== 0) {
      obj.importMethod = importJob_ImportMethodToJSON(message.importMethod);
    }
    if (message.protectionLevel !== 0) {
      obj.protectionLevel = protectionLevelToJSON(message.protectionLevel);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.generateTime !== undefined) {
      obj.generateTime = message.generateTime.toISOString();
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.expireEventTime !== undefined) {
      obj.expireEventTime = message.expireEventTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = importJob_ImportJobStateToJSON(message.state);
    }
    if (message.publicKey !== undefined) {
      obj.publicKey = ImportJob_WrappingPublicKey.toJSON(message.publicKey);
    }
    if (message.attestation !== undefined) {
      obj.attestation = KeyOperationAttestation.toJSON(message.attestation);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportJob>): ImportJob {
    return ImportJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportJob>): ImportJob {
    const message = createBaseImportJob();
    message.name = object.name ?? "";
    message.importMethod = object.importMethod ?? 0;
    message.protectionLevel = object.protectionLevel ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.generateTime = object.generateTime ?? undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.expireEventTime = object.expireEventTime ?? undefined;
    message.state = object.state ?? 0;
    message.publicKey = (object.publicKey !== undefined && object.publicKey !== null)
      ? ImportJob_WrappingPublicKey.fromPartial(object.publicKey)
      : undefined;
    message.attestation = (object.attestation !== undefined && object.attestation !== null)
      ? KeyOperationAttestation.fromPartial(object.attestation)
      : undefined;
    return message;
  },
};

function createBaseImportJob_WrappingPublicKey(): ImportJob_WrappingPublicKey {
  return { pem: "" };
}

export const ImportJob_WrappingPublicKey: MessageFns<ImportJob_WrappingPublicKey> = {
  encode(message: ImportJob_WrappingPublicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pem !== "") {
      writer.uint32(10).string(message.pem);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportJob_WrappingPublicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportJob_WrappingPublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pem = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportJob_WrappingPublicKey {
    return { pem: isSet(object.pem) ? globalThis.String(object.pem) : "" };
  },

  toJSON(message: ImportJob_WrappingPublicKey): unknown {
    const obj: any = {};
    if (message.pem !== "") {
      obj.pem = message.pem;
    }
    return obj;
  },

  create(base?: DeepPartial<ImportJob_WrappingPublicKey>): ImportJob_WrappingPublicKey {
    return ImportJob_WrappingPublicKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportJob_WrappingPublicKey>): ImportJob_WrappingPublicKey {
    const message = createBaseImportJob_WrappingPublicKey();
    message.pem = object.pem ?? "";
    return message;
  },
};

function createBaseExternalProtectionLevelOptions(): ExternalProtectionLevelOptions {
  return { externalKeyUri: "", ekmConnectionKeyPath: "" };
}

export const ExternalProtectionLevelOptions: MessageFns<ExternalProtectionLevelOptions> = {
  encode(message: ExternalProtectionLevelOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.externalKeyUri !== "") {
      writer.uint32(10).string(message.externalKeyUri);
    }
    if (message.ekmConnectionKeyPath !== "") {
      writer.uint32(18).string(message.ekmConnectionKeyPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalProtectionLevelOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalProtectionLevelOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalKeyUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ekmConnectionKeyPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalProtectionLevelOptions {
    return {
      externalKeyUri: isSet(object.externalKeyUri) ? globalThis.String(object.externalKeyUri) : "",
      ekmConnectionKeyPath: isSet(object.ekmConnectionKeyPath) ? globalThis.String(object.ekmConnectionKeyPath) : "",
    };
  },

  toJSON(message: ExternalProtectionLevelOptions): unknown {
    const obj: any = {};
    if (message.externalKeyUri !== "") {
      obj.externalKeyUri = message.externalKeyUri;
    }
    if (message.ekmConnectionKeyPath !== "") {
      obj.ekmConnectionKeyPath = message.ekmConnectionKeyPath;
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalProtectionLevelOptions>): ExternalProtectionLevelOptions {
    return ExternalProtectionLevelOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalProtectionLevelOptions>): ExternalProtectionLevelOptions {
    const message = createBaseExternalProtectionLevelOptions();
    message.externalKeyUri = object.externalKeyUri ?? "";
    message.ekmConnectionKeyPath = object.ekmConnectionKeyPath ?? "";
    return message;
  },
};

function createBaseKeyAccessJustificationsPolicy(): KeyAccessJustificationsPolicy {
  return { allowedAccessReasons: [] };
}

export const KeyAccessJustificationsPolicy: MessageFns<KeyAccessJustificationsPolicy> = {
  encode(message: KeyAccessJustificationsPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.allowedAccessReasons) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyAccessJustificationsPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyAccessJustificationsPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.allowedAccessReasons.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedAccessReasons.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyAccessJustificationsPolicy {
    return {
      allowedAccessReasons: globalThis.Array.isArray(object?.allowedAccessReasons)
        ? object.allowedAccessReasons.map((e: any) => accessReasonFromJSON(e))
        : [],
    };
  },

  toJSON(message: KeyAccessJustificationsPolicy): unknown {
    const obj: any = {};
    if (message.allowedAccessReasons?.length) {
      obj.allowedAccessReasons = message.allowedAccessReasons.map((e) => accessReasonToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<KeyAccessJustificationsPolicy>): KeyAccessJustificationsPolicy {
    return KeyAccessJustificationsPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyAccessJustificationsPolicy>): KeyAccessJustificationsPolicy {
    const message = createBaseKeyAccessJustificationsPolicy();
    message.allowedAccessReasons = object.allowedAccessReasons?.map((e) => e) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
