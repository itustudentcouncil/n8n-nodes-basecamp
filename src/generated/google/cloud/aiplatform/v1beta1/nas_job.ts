// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1beta1/nas_job.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { CustomJobSpec } from "./custom_job.js";
import { EncryptionSpec } from "./encryption_spec.js";
import { JobState, jobStateFromJSON, jobStateToJSON } from "./job_state.js";
import { Measurement } from "./study.js";

export const protobufPackage = "google.cloud.aiplatform.v1beta1";

/** Represents a Neural Architecture Search (NAS) job. */
export interface NasJob {
  /** Output only. Resource name of the NasJob. */
  name: string;
  /**
   * Required. The display name of the NasJob.
   * The name can be up to 128 characters long and can consist of any UTF-8
   * characters.
   */
  displayName: string;
  /** Required. The specification of a NasJob. */
  nasJobSpec:
    | NasJobSpec
    | undefined;
  /** Output only. Output of the NasJob. */
  nasJobOutput:
    | NasJobOutput
    | undefined;
  /** Output only. The detailed state of the job. */
  state: JobState;
  /** Output only. Time when the NasJob was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. Time when the NasJob for the first time entered the
   * `JOB_STATE_RUNNING` state.
   */
  startTime:
    | Date
    | undefined;
  /**
   * Output only. Time when the NasJob entered any of the following states:
   * `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
   */
  endTime:
    | Date
    | undefined;
  /** Output only. Time when the NasJob was most recently updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. Only populated when job's state is JOB_STATE_FAILED or
   * JOB_STATE_CANCELLED.
   */
  error:
    | Status
    | undefined;
  /**
   * The labels with user-defined metadata to organize NasJobs.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   */
  labels: { [key: string]: string };
  /**
   * Customer-managed encryption key options for a NasJob.
   * If this is set, then all resources created by the NasJob
   * will be encrypted with the provided encryption key.
   */
  encryptionSpec:
    | EncryptionSpec
    | undefined;
  /**
   * Optional. Enable a separation of Custom model training
   * and restricted image training for tenant project.
   *
   * @deprecated
   */
  enableRestrictedImageTraining: boolean;
  /** Output only. Reserved for future use. */
  satisfiesPzs: boolean;
  /** Output only. Reserved for future use. */
  satisfiesPzi: boolean;
}

export interface NasJob_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Represents a NasTrial details along with its parameters. If there is a
 * corresponding train NasTrial, the train NasTrial is also returned.
 */
export interface NasTrialDetail {
  /** Output only. Resource name of the NasTrialDetail. */
  name: string;
  /** The parameters for the NasJob NasTrial. */
  parameters: string;
  /** The requested search NasTrial. */
  searchTrial:
    | NasTrial
    | undefined;
  /**
   * The train NasTrial corresponding to
   * [search_trial][google.cloud.aiplatform.v1beta1.NasTrialDetail.search_trial].
   * Only populated if
   * [search_trial][google.cloud.aiplatform.v1beta1.NasTrialDetail.search_trial]
   * is used for training.
   */
  trainTrial: NasTrial | undefined;
}

/** Represents the spec of a NasJob. */
export interface NasJobSpec {
  /** The spec of multi-trial algorithms. */
  multiTrialAlgorithmSpec?:
    | NasJobSpec_MultiTrialAlgorithmSpec
    | undefined;
  /**
   * The ID of the existing NasJob in the same Project and Location
   * which will be used to resume search. search_space_spec and
   * nas_algorithm_spec are obtained from previous NasJob hence should not
   * provide them again for this NasJob.
   */
  resumeNasJobId: string;
  /** It defines the search space for Neural Architecture Search (NAS). */
  searchSpaceSpec: string;
}

/** The spec of multi-trial Neural Architecture Search (NAS). */
export interface NasJobSpec_MultiTrialAlgorithmSpec {
  /**
   * The multi-trial Neural Architecture Search (NAS) algorithm
   * type. Defaults to `REINFORCEMENT_LEARNING`.
   */
  multiTrialAlgorithm: NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm;
  /**
   * Metric specs for the NAS job.
   * Validation for this field is done at `multi_trial_algorithm_spec` field.
   */
  metric:
    | NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec
    | undefined;
  /** Required. Spec for search trials. */
  searchTrialSpec:
    | NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec
    | undefined;
  /**
   * Spec for train trials. Top N [TrainTrialSpec.max_parallel_trial_count]
   * search trials will be trained for every M
   * [TrainTrialSpec.frequency] trials searched.
   */
  trainTrialSpec: NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec | undefined;
}

/** The available types of multi-trial algorithms. */
export enum NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm {
  /** MULTI_TRIAL_ALGORITHM_UNSPECIFIED - Defaults to `REINFORCEMENT_LEARNING`. */
  MULTI_TRIAL_ALGORITHM_UNSPECIFIED = 0,
  /**
   * REINFORCEMENT_LEARNING - The Reinforcement Learning Algorithm for Multi-trial Neural
   * Architecture Search (NAS).
   */
  REINFORCEMENT_LEARNING = 1,
  /**
   * GRID_SEARCH - The Grid Search Algorithm for Multi-trial Neural
   * Architecture Search (NAS).
   */
  GRID_SEARCH = 2,
  UNRECOGNIZED = -1,
}

export function nasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithmFromJSON(
  object: any,
): NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm {
  switch (object) {
    case 0:
    case "MULTI_TRIAL_ALGORITHM_UNSPECIFIED":
      return NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.MULTI_TRIAL_ALGORITHM_UNSPECIFIED;
    case 1:
    case "REINFORCEMENT_LEARNING":
      return NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.REINFORCEMENT_LEARNING;
    case 2:
    case "GRID_SEARCH":
      return NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.GRID_SEARCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.UNRECOGNIZED;
  }
}

export function nasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithmToJSON(
  object: NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm,
): string {
  switch (object) {
    case NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.MULTI_TRIAL_ALGORITHM_UNSPECIFIED:
      return "MULTI_TRIAL_ALGORITHM_UNSPECIFIED";
    case NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.REINFORCEMENT_LEARNING:
      return "REINFORCEMENT_LEARNING";
    case NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.GRID_SEARCH:
      return "GRID_SEARCH";
    case NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents a metric to optimize. */
export interface NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec {
  /** Required. The ID of the metric. Must not contain whitespaces. */
  metricId: string;
  /** Required. The optimization goal of the metric. */
  goal: NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType;
}

/** The available types of optimization goals. */
export enum NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType {
  /** GOAL_TYPE_UNSPECIFIED - Goal Type will default to maximize. */
  GOAL_TYPE_UNSPECIFIED = 0,
  /** MAXIMIZE - Maximize the goal metric. */
  MAXIMIZE = 1,
  /** MINIMIZE - Minimize the goal metric. */
  MINIMIZE = 2,
  UNRECOGNIZED = -1,
}

export function nasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalTypeFromJSON(
  object: any,
): NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType {
  switch (object) {
    case 0:
    case "GOAL_TYPE_UNSPECIFIED":
      return NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType.GOAL_TYPE_UNSPECIFIED;
    case 1:
    case "MAXIMIZE":
      return NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType.MAXIMIZE;
    case 2:
    case "MINIMIZE":
      return NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType.MINIMIZE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType.UNRECOGNIZED;
  }
}

export function nasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalTypeToJSON(
  object: NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType,
): string {
  switch (object) {
    case NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType.GOAL_TYPE_UNSPECIFIED:
      return "GOAL_TYPE_UNSPECIFIED";
    case NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType.MAXIMIZE:
      return "MAXIMIZE";
    case NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType.MINIMIZE:
      return "MINIMIZE";
    case NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represent spec for search trials. */
export interface NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec {
  /**
   * Required. The spec of a search trial job. The same spec applies to
   * all search trials.
   */
  searchTrialJobSpec:
    | CustomJobSpec
    | undefined;
  /**
   * Required. The maximum number of Neural Architecture Search (NAS) trials
   * to run.
   */
  maxTrialCount: number;
  /** Required. The maximum number of trials to run in parallel. */
  maxParallelTrialCount: number;
  /**
   * The number of failed trials that need to be seen before failing
   * the NasJob.
   *
   * If set to 0, Vertex AI decides how many trials must fail
   * before the whole job fails.
   */
  maxFailedTrialCount: number;
}

/** Represent spec for train trials. */
export interface NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec {
  /**
   * Required. The spec of a train trial job. The same spec applies to
   * all train trials.
   */
  trainTrialJobSpec:
    | CustomJobSpec
    | undefined;
  /** Required. The maximum number of trials to run in parallel. */
  maxParallelTrialCount: number;
  /**
   * Required. Frequency of search trials to start train stage. Top N
   * [TrainTrialSpec.max_parallel_trial_count]
   * search trials will be trained for every M
   * [TrainTrialSpec.frequency] trials searched.
   */
  frequency: number;
}

/** Represents a uCAIP NasJob output. */
export interface NasJobOutput {
  /**
   * Output only. The output of this multi-trial Neural Architecture Search
   * (NAS) job.
   */
  multiTrialJobOutput?: NasJobOutput_MultiTrialJobOutput | undefined;
}

/** The output of a multi-trial Neural Architecture Search (NAS) jobs. */
export interface NasJobOutput_MultiTrialJobOutput {
  /** Output only. List of NasTrials that were started as part of search stage. */
  searchTrials: NasTrial[];
  /** Output only. List of NasTrials that were started as part of train stage. */
  trainTrials: NasTrial[];
}

/** Represents a uCAIP NasJob trial. */
export interface NasTrial {
  /** Output only. The identifier of the NasTrial assigned by the service. */
  id: string;
  /** Output only. The detailed state of the NasTrial. */
  state: NasTrial_State;
  /** Output only. The final measurement containing the objective value. */
  finalMeasurement:
    | Measurement
    | undefined;
  /** Output only. Time when the NasTrial was started. */
  startTime:
    | Date
    | undefined;
  /**
   * Output only. Time when the NasTrial's status changed to `SUCCEEDED` or
   * `INFEASIBLE`.
   */
  endTime: Date | undefined;
}

/** Describes a NasTrial state. */
export enum NasTrial_State {
  /** STATE_UNSPECIFIED - The NasTrial state is unspecified. */
  STATE_UNSPECIFIED = 0,
  /**
   * REQUESTED - Indicates that a specific NasTrial has been requested, but it has not yet
   * been suggested by the service.
   */
  REQUESTED = 1,
  /** ACTIVE - Indicates that the NasTrial has been suggested. */
  ACTIVE = 2,
  /** STOPPING - Indicates that the NasTrial should stop according to the service. */
  STOPPING = 3,
  /** SUCCEEDED - Indicates that the NasTrial is completed successfully. */
  SUCCEEDED = 4,
  /**
   * INFEASIBLE - Indicates that the NasTrial should not be attempted again.
   * The service will set a NasTrial to INFEASIBLE when it's done but missing
   * the final_measurement.
   */
  INFEASIBLE = 5,
  UNRECOGNIZED = -1,
}

export function nasTrial_StateFromJSON(object: any): NasTrial_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return NasTrial_State.STATE_UNSPECIFIED;
    case 1:
    case "REQUESTED":
      return NasTrial_State.REQUESTED;
    case 2:
    case "ACTIVE":
      return NasTrial_State.ACTIVE;
    case 3:
    case "STOPPING":
      return NasTrial_State.STOPPING;
    case 4:
    case "SUCCEEDED":
      return NasTrial_State.SUCCEEDED;
    case 5:
    case "INFEASIBLE":
      return NasTrial_State.INFEASIBLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NasTrial_State.UNRECOGNIZED;
  }
}

export function nasTrial_StateToJSON(object: NasTrial_State): string {
  switch (object) {
    case NasTrial_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case NasTrial_State.REQUESTED:
      return "REQUESTED";
    case NasTrial_State.ACTIVE:
      return "ACTIVE";
    case NasTrial_State.STOPPING:
      return "STOPPING";
    case NasTrial_State.SUCCEEDED:
      return "SUCCEEDED";
    case NasTrial_State.INFEASIBLE:
      return "INFEASIBLE";
    case NasTrial_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseNasJob(): NasJob {
  return {
    name: "",
    displayName: "",
    nasJobSpec: undefined,
    nasJobOutput: undefined,
    state: 0,
    createTime: undefined,
    startTime: undefined,
    endTime: undefined,
    updateTime: undefined,
    error: undefined,
    labels: {},
    encryptionSpec: undefined,
    enableRestrictedImageTraining: false,
    satisfiesPzs: false,
    satisfiesPzi: false,
  };
}

export const NasJob: MessageFns<NasJob> = {
  encode(message: NasJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.nasJobSpec !== undefined) {
      NasJobSpec.encode(message.nasJobSpec, writer.uint32(34).fork()).join();
    }
    if (message.nasJobOutput !== undefined) {
      NasJobOutput.encode(message.nasJobOutput, writer.uint32(42).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(66).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(90).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      NasJob_LabelsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    if (message.encryptionSpec !== undefined) {
      EncryptionSpec.encode(message.encryptionSpec, writer.uint32(106).fork()).join();
    }
    if (message.enableRestrictedImageTraining !== false) {
      writer.uint32(112).bool(message.enableRestrictedImageTraining);
    }
    if (message.satisfiesPzs !== false) {
      writer.uint32(120).bool(message.satisfiesPzs);
    }
    if (message.satisfiesPzi !== false) {
      writer.uint32(128).bool(message.satisfiesPzi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NasJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNasJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nasJobSpec = NasJobSpec.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nasJobOutput = NasJobOutput.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = NasJob_LabelsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.labels[entry12.key] = entry12.value;
          }
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.encryptionSpec = EncryptionSpec.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.enableRestrictedImageTraining = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.satisfiesPzs = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NasJob {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      nasJobSpec: isSet(object.nasJobSpec) ? NasJobSpec.fromJSON(object.nasJobSpec) : undefined,
      nasJobOutput: isSet(object.nasJobOutput) ? NasJobOutput.fromJSON(object.nasJobOutput) : undefined,
      state: isSet(object.state) ? jobStateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      encryptionSpec: isSet(object.encryptionSpec) ? EncryptionSpec.fromJSON(object.encryptionSpec) : undefined,
      enableRestrictedImageTraining: isSet(object.enableRestrictedImageTraining)
        ? globalThis.Boolean(object.enableRestrictedImageTraining)
        : false,
      satisfiesPzs: isSet(object.satisfiesPzs) ? globalThis.Boolean(object.satisfiesPzs) : false,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : false,
    };
  },

  toJSON(message: NasJob): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.nasJobSpec !== undefined) {
      obj.nasJobSpec = NasJobSpec.toJSON(message.nasJobSpec);
    }
    if (message.nasJobOutput !== undefined) {
      obj.nasJobOutput = NasJobOutput.toJSON(message.nasJobOutput);
    }
    if (message.state !== 0) {
      obj.state = jobStateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.encryptionSpec !== undefined) {
      obj.encryptionSpec = EncryptionSpec.toJSON(message.encryptionSpec);
    }
    if (message.enableRestrictedImageTraining !== false) {
      obj.enableRestrictedImageTraining = message.enableRestrictedImageTraining;
    }
    if (message.satisfiesPzs !== false) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== false) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    return obj;
  },

  create(base?: DeepPartial<NasJob>): NasJob {
    return NasJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NasJob>): NasJob {
    const message = createBaseNasJob();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.nasJobSpec = (object.nasJobSpec !== undefined && object.nasJobSpec !== null)
      ? NasJobSpec.fromPartial(object.nasJobSpec)
      : undefined;
    message.nasJobOutput = (object.nasJobOutput !== undefined && object.nasJobOutput !== null)
      ? NasJobOutput.fromPartial(object.nasJobOutput)
      : undefined;
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.encryptionSpec = (object.encryptionSpec !== undefined && object.encryptionSpec !== null)
      ? EncryptionSpec.fromPartial(object.encryptionSpec)
      : undefined;
    message.enableRestrictedImageTraining = object.enableRestrictedImageTraining ?? false;
    message.satisfiesPzs = object.satisfiesPzs ?? false;
    message.satisfiesPzi = object.satisfiesPzi ?? false;
    return message;
  },
};

function createBaseNasJob_LabelsEntry(): NasJob_LabelsEntry {
  return { key: "", value: "" };
}

export const NasJob_LabelsEntry: MessageFns<NasJob_LabelsEntry> = {
  encode(message: NasJob_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NasJob_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNasJob_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NasJob_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NasJob_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NasJob_LabelsEntry>): NasJob_LabelsEntry {
    return NasJob_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NasJob_LabelsEntry>): NasJob_LabelsEntry {
    const message = createBaseNasJob_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNasTrialDetail(): NasTrialDetail {
  return { name: "", parameters: "", searchTrial: undefined, trainTrial: undefined };
}

export const NasTrialDetail: MessageFns<NasTrialDetail> = {
  encode(message: NasTrialDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.parameters !== "") {
      writer.uint32(18).string(message.parameters);
    }
    if (message.searchTrial !== undefined) {
      NasTrial.encode(message.searchTrial, writer.uint32(26).fork()).join();
    }
    if (message.trainTrial !== undefined) {
      NasTrial.encode(message.trainTrial, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NasTrialDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNasTrialDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameters = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.searchTrial = NasTrial.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.trainTrial = NasTrial.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NasTrialDetail {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
      searchTrial: isSet(object.searchTrial) ? NasTrial.fromJSON(object.searchTrial) : undefined,
      trainTrial: isSet(object.trainTrial) ? NasTrial.fromJSON(object.trainTrial) : undefined,
    };
  },

  toJSON(message: NasTrialDetail): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parameters !== "") {
      obj.parameters = message.parameters;
    }
    if (message.searchTrial !== undefined) {
      obj.searchTrial = NasTrial.toJSON(message.searchTrial);
    }
    if (message.trainTrial !== undefined) {
      obj.trainTrial = NasTrial.toJSON(message.trainTrial);
    }
    return obj;
  },

  create(base?: DeepPartial<NasTrialDetail>): NasTrialDetail {
    return NasTrialDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NasTrialDetail>): NasTrialDetail {
    const message = createBaseNasTrialDetail();
    message.name = object.name ?? "";
    message.parameters = object.parameters ?? "";
    message.searchTrial = (object.searchTrial !== undefined && object.searchTrial !== null)
      ? NasTrial.fromPartial(object.searchTrial)
      : undefined;
    message.trainTrial = (object.trainTrial !== undefined && object.trainTrial !== null)
      ? NasTrial.fromPartial(object.trainTrial)
      : undefined;
    return message;
  },
};

function createBaseNasJobSpec(): NasJobSpec {
  return { multiTrialAlgorithmSpec: undefined, resumeNasJobId: "", searchSpaceSpec: "" };
}

export const NasJobSpec: MessageFns<NasJobSpec> = {
  encode(message: NasJobSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.multiTrialAlgorithmSpec !== undefined) {
      NasJobSpec_MultiTrialAlgorithmSpec.encode(message.multiTrialAlgorithmSpec, writer.uint32(18).fork()).join();
    }
    if (message.resumeNasJobId !== "") {
      writer.uint32(26).string(message.resumeNasJobId);
    }
    if (message.searchSpaceSpec !== "") {
      writer.uint32(10).string(message.searchSpaceSpec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NasJobSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNasJobSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.multiTrialAlgorithmSpec = NasJobSpec_MultiTrialAlgorithmSpec.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resumeNasJobId = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchSpaceSpec = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NasJobSpec {
    return {
      multiTrialAlgorithmSpec: isSet(object.multiTrialAlgorithmSpec)
        ? NasJobSpec_MultiTrialAlgorithmSpec.fromJSON(object.multiTrialAlgorithmSpec)
        : undefined,
      resumeNasJobId: isSet(object.resumeNasJobId) ? globalThis.String(object.resumeNasJobId) : "",
      searchSpaceSpec: isSet(object.searchSpaceSpec) ? globalThis.String(object.searchSpaceSpec) : "",
    };
  },

  toJSON(message: NasJobSpec): unknown {
    const obj: any = {};
    if (message.multiTrialAlgorithmSpec !== undefined) {
      obj.multiTrialAlgorithmSpec = NasJobSpec_MultiTrialAlgorithmSpec.toJSON(message.multiTrialAlgorithmSpec);
    }
    if (message.resumeNasJobId !== "") {
      obj.resumeNasJobId = message.resumeNasJobId;
    }
    if (message.searchSpaceSpec !== "") {
      obj.searchSpaceSpec = message.searchSpaceSpec;
    }
    return obj;
  },

  create(base?: DeepPartial<NasJobSpec>): NasJobSpec {
    return NasJobSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NasJobSpec>): NasJobSpec {
    const message = createBaseNasJobSpec();
    message.multiTrialAlgorithmSpec =
      (object.multiTrialAlgorithmSpec !== undefined && object.multiTrialAlgorithmSpec !== null)
        ? NasJobSpec_MultiTrialAlgorithmSpec.fromPartial(object.multiTrialAlgorithmSpec)
        : undefined;
    message.resumeNasJobId = object.resumeNasJobId ?? "";
    message.searchSpaceSpec = object.searchSpaceSpec ?? "";
    return message;
  },
};

function createBaseNasJobSpec_MultiTrialAlgorithmSpec(): NasJobSpec_MultiTrialAlgorithmSpec {
  return { multiTrialAlgorithm: 0, metric: undefined, searchTrialSpec: undefined, trainTrialSpec: undefined };
}

export const NasJobSpec_MultiTrialAlgorithmSpec: MessageFns<NasJobSpec_MultiTrialAlgorithmSpec> = {
  encode(message: NasJobSpec_MultiTrialAlgorithmSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.multiTrialAlgorithm !== 0) {
      writer.uint32(8).int32(message.multiTrialAlgorithm);
    }
    if (message.metric !== undefined) {
      NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec.encode(message.metric, writer.uint32(18).fork()).join();
    }
    if (message.searchTrialSpec !== undefined) {
      NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec.encode(message.searchTrialSpec, writer.uint32(26).fork())
        .join();
    }
    if (message.trainTrialSpec !== undefined) {
      NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec.encode(message.trainTrialSpec, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NasJobSpec_MultiTrialAlgorithmSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNasJobSpec_MultiTrialAlgorithmSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.multiTrialAlgorithm = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metric = NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.searchTrialSpec = NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.trainTrialSpec = NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NasJobSpec_MultiTrialAlgorithmSpec {
    return {
      multiTrialAlgorithm: isSet(object.multiTrialAlgorithm)
        ? nasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithmFromJSON(object.multiTrialAlgorithm)
        : 0,
      metric: isSet(object.metric) ? NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec.fromJSON(object.metric) : undefined,
      searchTrialSpec: isSet(object.searchTrialSpec)
        ? NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec.fromJSON(object.searchTrialSpec)
        : undefined,
      trainTrialSpec: isSet(object.trainTrialSpec)
        ? NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec.fromJSON(object.trainTrialSpec)
        : undefined,
    };
  },

  toJSON(message: NasJobSpec_MultiTrialAlgorithmSpec): unknown {
    const obj: any = {};
    if (message.multiTrialAlgorithm !== 0) {
      obj.multiTrialAlgorithm = nasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithmToJSON(
        message.multiTrialAlgorithm,
      );
    }
    if (message.metric !== undefined) {
      obj.metric = NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec.toJSON(message.metric);
    }
    if (message.searchTrialSpec !== undefined) {
      obj.searchTrialSpec = NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec.toJSON(message.searchTrialSpec);
    }
    if (message.trainTrialSpec !== undefined) {
      obj.trainTrialSpec = NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec.toJSON(message.trainTrialSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<NasJobSpec_MultiTrialAlgorithmSpec>): NasJobSpec_MultiTrialAlgorithmSpec {
    return NasJobSpec_MultiTrialAlgorithmSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NasJobSpec_MultiTrialAlgorithmSpec>): NasJobSpec_MultiTrialAlgorithmSpec {
    const message = createBaseNasJobSpec_MultiTrialAlgorithmSpec();
    message.multiTrialAlgorithm = object.multiTrialAlgorithm ?? 0;
    message.metric = (object.metric !== undefined && object.metric !== null)
      ? NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec.fromPartial(object.metric)
      : undefined;
    message.searchTrialSpec = (object.searchTrialSpec !== undefined && object.searchTrialSpec !== null)
      ? NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec.fromPartial(object.searchTrialSpec)
      : undefined;
    message.trainTrialSpec = (object.trainTrialSpec !== undefined && object.trainTrialSpec !== null)
      ? NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec.fromPartial(object.trainTrialSpec)
      : undefined;
    return message;
  },
};

function createBaseNasJobSpec_MultiTrialAlgorithmSpec_MetricSpec(): NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec {
  return { metricId: "", goal: 0 };
}

export const NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec: MessageFns<NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec> =
  {
    encode(
      message: NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.metricId !== "") {
        writer.uint32(10).string(message.metricId);
      }
      if (message.goal !== 0) {
        writer.uint32(16).int32(message.goal);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseNasJobSpec_MultiTrialAlgorithmSpec_MetricSpec();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.metricId = reader.string();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }

            message.goal = reader.int32() as any;
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec {
      return {
        metricId: isSet(object.metricId) ? globalThis.String(object.metricId) : "",
        goal: isSet(object.goal) ? nasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalTypeFromJSON(object.goal) : 0,
      };
    },

    toJSON(message: NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec): unknown {
      const obj: any = {};
      if (message.metricId !== "") {
        obj.metricId = message.metricId;
      }
      if (message.goal !== 0) {
        obj.goal = nasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalTypeToJSON(message.goal);
      }
      return obj;
    },

    create(
      base?: DeepPartial<NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec>,
    ): NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec {
      return NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec>,
    ): NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec {
      const message = createBaseNasJobSpec_MultiTrialAlgorithmSpec_MetricSpec();
      message.metricId = object.metricId ?? "";
      message.goal = object.goal ?? 0;
      return message;
    },
  };

function createBaseNasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec(): NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec {
  return { searchTrialJobSpec: undefined, maxTrialCount: 0, maxParallelTrialCount: 0, maxFailedTrialCount: 0 };
}

export const NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec: MessageFns<
  NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec
> = {
  encode(
    message: NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.searchTrialJobSpec !== undefined) {
      CustomJobSpec.encode(message.searchTrialJobSpec, writer.uint32(10).fork()).join();
    }
    if (message.maxTrialCount !== 0) {
      writer.uint32(16).int32(message.maxTrialCount);
    }
    if (message.maxParallelTrialCount !== 0) {
      writer.uint32(24).int32(message.maxParallelTrialCount);
    }
    if (message.maxFailedTrialCount !== 0) {
      writer.uint32(32).int32(message.maxFailedTrialCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchTrialJobSpec = CustomJobSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxTrialCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxParallelTrialCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxFailedTrialCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec {
    return {
      searchTrialJobSpec: isSet(object.searchTrialJobSpec)
        ? CustomJobSpec.fromJSON(object.searchTrialJobSpec)
        : undefined,
      maxTrialCount: isSet(object.maxTrialCount) ? globalThis.Number(object.maxTrialCount) : 0,
      maxParallelTrialCount: isSet(object.maxParallelTrialCount) ? globalThis.Number(object.maxParallelTrialCount) : 0,
      maxFailedTrialCount: isSet(object.maxFailedTrialCount) ? globalThis.Number(object.maxFailedTrialCount) : 0,
    };
  },

  toJSON(message: NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec): unknown {
    const obj: any = {};
    if (message.searchTrialJobSpec !== undefined) {
      obj.searchTrialJobSpec = CustomJobSpec.toJSON(message.searchTrialJobSpec);
    }
    if (message.maxTrialCount !== 0) {
      obj.maxTrialCount = Math.round(message.maxTrialCount);
    }
    if (message.maxParallelTrialCount !== 0) {
      obj.maxParallelTrialCount = Math.round(message.maxParallelTrialCount);
    }
    if (message.maxFailedTrialCount !== 0) {
      obj.maxFailedTrialCount = Math.round(message.maxFailedTrialCount);
    }
    return obj;
  },

  create(
    base?: DeepPartial<NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec>,
  ): NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec {
    return NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec>,
  ): NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec {
    const message = createBaseNasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec();
    message.searchTrialJobSpec = (object.searchTrialJobSpec !== undefined && object.searchTrialJobSpec !== null)
      ? CustomJobSpec.fromPartial(object.searchTrialJobSpec)
      : undefined;
    message.maxTrialCount = object.maxTrialCount ?? 0;
    message.maxParallelTrialCount = object.maxParallelTrialCount ?? 0;
    message.maxFailedTrialCount = object.maxFailedTrialCount ?? 0;
    return message;
  },
};

function createBaseNasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec(): NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec {
  return { trainTrialJobSpec: undefined, maxParallelTrialCount: 0, frequency: 0 };
}

export const NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec: MessageFns<
  NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec
> = {
  encode(
    message: NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trainTrialJobSpec !== undefined) {
      CustomJobSpec.encode(message.trainTrialJobSpec, writer.uint32(10).fork()).join();
    }
    if (message.maxParallelTrialCount !== 0) {
      writer.uint32(16).int32(message.maxParallelTrialCount);
    }
    if (message.frequency !== 0) {
      writer.uint32(24).int32(message.frequency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.trainTrialJobSpec = CustomJobSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxParallelTrialCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.frequency = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec {
    return {
      trainTrialJobSpec: isSet(object.trainTrialJobSpec) ? CustomJobSpec.fromJSON(object.trainTrialJobSpec) : undefined,
      maxParallelTrialCount: isSet(object.maxParallelTrialCount) ? globalThis.Number(object.maxParallelTrialCount) : 0,
      frequency: isSet(object.frequency) ? globalThis.Number(object.frequency) : 0,
    };
  },

  toJSON(message: NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec): unknown {
    const obj: any = {};
    if (message.trainTrialJobSpec !== undefined) {
      obj.trainTrialJobSpec = CustomJobSpec.toJSON(message.trainTrialJobSpec);
    }
    if (message.maxParallelTrialCount !== 0) {
      obj.maxParallelTrialCount = Math.round(message.maxParallelTrialCount);
    }
    if (message.frequency !== 0) {
      obj.frequency = Math.round(message.frequency);
    }
    return obj;
  },

  create(
    base?: DeepPartial<NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec>,
  ): NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec {
    return NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec>,
  ): NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec {
    const message = createBaseNasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec();
    message.trainTrialJobSpec = (object.trainTrialJobSpec !== undefined && object.trainTrialJobSpec !== null)
      ? CustomJobSpec.fromPartial(object.trainTrialJobSpec)
      : undefined;
    message.maxParallelTrialCount = object.maxParallelTrialCount ?? 0;
    message.frequency = object.frequency ?? 0;
    return message;
  },
};

function createBaseNasJobOutput(): NasJobOutput {
  return { multiTrialJobOutput: undefined };
}

export const NasJobOutput: MessageFns<NasJobOutput> = {
  encode(message: NasJobOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.multiTrialJobOutput !== undefined) {
      NasJobOutput_MultiTrialJobOutput.encode(message.multiTrialJobOutput, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NasJobOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNasJobOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.multiTrialJobOutput = NasJobOutput_MultiTrialJobOutput.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NasJobOutput {
    return {
      multiTrialJobOutput: isSet(object.multiTrialJobOutput)
        ? NasJobOutput_MultiTrialJobOutput.fromJSON(object.multiTrialJobOutput)
        : undefined,
    };
  },

  toJSON(message: NasJobOutput): unknown {
    const obj: any = {};
    if (message.multiTrialJobOutput !== undefined) {
      obj.multiTrialJobOutput = NasJobOutput_MultiTrialJobOutput.toJSON(message.multiTrialJobOutput);
    }
    return obj;
  },

  create(base?: DeepPartial<NasJobOutput>): NasJobOutput {
    return NasJobOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NasJobOutput>): NasJobOutput {
    const message = createBaseNasJobOutput();
    message.multiTrialJobOutput = (object.multiTrialJobOutput !== undefined && object.multiTrialJobOutput !== null)
      ? NasJobOutput_MultiTrialJobOutput.fromPartial(object.multiTrialJobOutput)
      : undefined;
    return message;
  },
};

function createBaseNasJobOutput_MultiTrialJobOutput(): NasJobOutput_MultiTrialJobOutput {
  return { searchTrials: [], trainTrials: [] };
}

export const NasJobOutput_MultiTrialJobOutput: MessageFns<NasJobOutput_MultiTrialJobOutput> = {
  encode(message: NasJobOutput_MultiTrialJobOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.searchTrials) {
      NasTrial.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.trainTrials) {
      NasTrial.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NasJobOutput_MultiTrialJobOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNasJobOutput_MultiTrialJobOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchTrials.push(NasTrial.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.trainTrials.push(NasTrial.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NasJobOutput_MultiTrialJobOutput {
    return {
      searchTrials: globalThis.Array.isArray(object?.searchTrials)
        ? object.searchTrials.map((e: any) => NasTrial.fromJSON(e))
        : [],
      trainTrials: globalThis.Array.isArray(object?.trainTrials)
        ? object.trainTrials.map((e: any) => NasTrial.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NasJobOutput_MultiTrialJobOutput): unknown {
    const obj: any = {};
    if (message.searchTrials?.length) {
      obj.searchTrials = message.searchTrials.map((e) => NasTrial.toJSON(e));
    }
    if (message.trainTrials?.length) {
      obj.trainTrials = message.trainTrials.map((e) => NasTrial.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NasJobOutput_MultiTrialJobOutput>): NasJobOutput_MultiTrialJobOutput {
    return NasJobOutput_MultiTrialJobOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NasJobOutput_MultiTrialJobOutput>): NasJobOutput_MultiTrialJobOutput {
    const message = createBaseNasJobOutput_MultiTrialJobOutput();
    message.searchTrials = object.searchTrials?.map((e) => NasTrial.fromPartial(e)) || [];
    message.trainTrials = object.trainTrials?.map((e) => NasTrial.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNasTrial(): NasTrial {
  return { id: "", state: 0, finalMeasurement: undefined, startTime: undefined, endTime: undefined };
}

export const NasTrial: MessageFns<NasTrial> = {
  encode(message: NasTrial, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.finalMeasurement !== undefined) {
      Measurement.encode(message.finalMeasurement, writer.uint32(26).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NasTrial {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNasTrial();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.finalMeasurement = Measurement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NasTrial {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      state: isSet(object.state) ? nasTrial_StateFromJSON(object.state) : 0,
      finalMeasurement: isSet(object.finalMeasurement) ? Measurement.fromJSON(object.finalMeasurement) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: NasTrial): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.state !== 0) {
      obj.state = nasTrial_StateToJSON(message.state);
    }
    if (message.finalMeasurement !== undefined) {
      obj.finalMeasurement = Measurement.toJSON(message.finalMeasurement);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<NasTrial>): NasTrial {
    return NasTrial.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NasTrial>): NasTrial {
    const message = createBaseNasTrial();
    message.id = object.id ?? "";
    message.state = object.state ?? 0;
    message.finalMeasurement = (object.finalMeasurement !== undefined && object.finalMeasurement !== null)
      ? Measurement.fromPartial(object.finalMeasurement)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
