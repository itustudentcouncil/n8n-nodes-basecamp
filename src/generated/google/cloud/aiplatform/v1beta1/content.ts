// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1beta1/content.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { DateMessage } from "../../../type/date.js";
import { Schema } from "./openapi.js";
import { FunctionCall, FunctionResponse } from "./tool.js";

export const protobufPackage = "google.cloud.aiplatform.v1beta1";

/** Harm categories that will block the content. */
export enum HarmCategory {
  /** HARM_CATEGORY_UNSPECIFIED - The harm category is unspecified. */
  HARM_CATEGORY_UNSPECIFIED = 0,
  /** HARM_CATEGORY_HATE_SPEECH - The harm category is hate speech. */
  HARM_CATEGORY_HATE_SPEECH = 1,
  /** HARM_CATEGORY_DANGEROUS_CONTENT - The harm category is dangerous content. */
  HARM_CATEGORY_DANGEROUS_CONTENT = 2,
  /** HARM_CATEGORY_HARASSMENT - The harm category is harassment. */
  HARM_CATEGORY_HARASSMENT = 3,
  /** HARM_CATEGORY_SEXUALLY_EXPLICIT - The harm category is sexually explicit content. */
  HARM_CATEGORY_SEXUALLY_EXPLICIT = 4,
  /** HARM_CATEGORY_CIVIC_INTEGRITY - The harm category is civic integrity. */
  HARM_CATEGORY_CIVIC_INTEGRITY = 5,
  UNRECOGNIZED = -1,
}

export function harmCategoryFromJSON(object: any): HarmCategory {
  switch (object) {
    case 0:
    case "HARM_CATEGORY_UNSPECIFIED":
      return HarmCategory.HARM_CATEGORY_UNSPECIFIED;
    case 1:
    case "HARM_CATEGORY_HATE_SPEECH":
      return HarmCategory.HARM_CATEGORY_HATE_SPEECH;
    case 2:
    case "HARM_CATEGORY_DANGEROUS_CONTENT":
      return HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT;
    case 3:
    case "HARM_CATEGORY_HARASSMENT":
      return HarmCategory.HARM_CATEGORY_HARASSMENT;
    case 4:
    case "HARM_CATEGORY_SEXUALLY_EXPLICIT":
      return HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT;
    case 5:
    case "HARM_CATEGORY_CIVIC_INTEGRITY":
      return HarmCategory.HARM_CATEGORY_CIVIC_INTEGRITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HarmCategory.UNRECOGNIZED;
  }
}

export function harmCategoryToJSON(object: HarmCategory): string {
  switch (object) {
    case HarmCategory.HARM_CATEGORY_UNSPECIFIED:
      return "HARM_CATEGORY_UNSPECIFIED";
    case HarmCategory.HARM_CATEGORY_HATE_SPEECH:
      return "HARM_CATEGORY_HATE_SPEECH";
    case HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT:
      return "HARM_CATEGORY_DANGEROUS_CONTENT";
    case HarmCategory.HARM_CATEGORY_HARASSMENT:
      return "HARM_CATEGORY_HARASSMENT";
    case HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT:
      return "HARM_CATEGORY_SEXUALLY_EXPLICIT";
    case HarmCategory.HARM_CATEGORY_CIVIC_INTEGRITY:
      return "HARM_CATEGORY_CIVIC_INTEGRITY";
    case HarmCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The base structured datatype containing multi-part content of a message.
 *
 * A `Content` includes a `role` field designating the producer of the `Content`
 * and a `parts` field containing multi-part data that contains the content of
 * the message turn.
 */
export interface Content {
  /**
   * Optional. The producer of the content. Must be either 'user' or 'model'.
   *
   * Useful to set for multi-turn conversations, otherwise can be left blank
   * or unset.
   */
  role: string;
  /**
   * Required. Ordered `Parts` that constitute a single message. Parts may have
   * different IANA MIME types.
   */
  parts: Part[];
}

/**
 * A datatype containing media that is part of a multi-part `Content` message.
 *
 * A `Part` consists of data which has an associated datatype. A `Part` can only
 * contain one of the accepted types in `Part.data`.
 *
 * A `Part` must have a fixed IANA MIME type identifying the type and subtype
 * of the media if `inline_data` or `file_data` field is filled with raw bytes.
 */
export interface Part {
  /** Optional. Text part (can be code). */
  text?:
    | string
    | undefined;
  /** Optional. Inlined bytes data. */
  inlineData?:
    | Blob
    | undefined;
  /** Optional. URI based data. */
  fileData?:
    | FileData
    | undefined;
  /**
   * Optional. A predicted [FunctionCall] returned from the model that
   * contains a string representing the [FunctionDeclaration.name] with the
   * parameters and their values.
   */
  functionCall?:
    | FunctionCall
    | undefined;
  /**
   * Optional. The result output of a [FunctionCall] that contains a string
   * representing the [FunctionDeclaration.name] and a structured JSON object
   * containing any output from the function call. It is used as context to
   * the model.
   */
  functionResponse?:
    | FunctionResponse
    | undefined;
  /**
   * Optional. Video metadata. The metadata should only be specified while the
   * video data is presented in inline_data or file_data.
   */
  videoMetadata?: VideoMetadata | undefined;
}

/**
 * Content blob.
 *
 * It's preferred to send as [text][google.cloud.aiplatform.v1beta1.Part.text]
 * directly rather than raw bytes.
 */
export interface Blob {
  /** Required. The IANA standard MIME type of the source data. */
  mimeType: string;
  /** Required. Raw bytes. */
  data: Buffer;
}

/** URI based data. */
export interface FileData {
  /** Required. The IANA standard MIME type of the source data. */
  mimeType: string;
  /** Required. URI. */
  fileUri: string;
}

/** Metadata describes the input video content. */
export interface VideoMetadata {
  /** Optional. The start offset of the video. */
  startOffset:
    | Duration
    | undefined;
  /** Optional. The end offset of the video. */
  endOffset: Duration | undefined;
}

/** Generation config. */
export interface GenerationConfig {
  /** Optional. Controls the randomness of predictions. */
  temperature?:
    | number
    | undefined;
  /** Optional. If specified, nucleus sampling will be used. */
  topP?:
    | number
    | undefined;
  /** Optional. If specified, top-k sampling will be used. */
  topK?:
    | number
    | undefined;
  /** Optional. Number of candidates to generate. */
  candidateCount?:
    | number
    | undefined;
  /** Optional. The maximum number of output tokens to generate per message. */
  maxOutputTokens?:
    | number
    | undefined;
  /** Optional. Stop sequences. */
  stopSequences: string[];
  /** Optional. If true, export the logprobs results in response. */
  responseLogprobs?:
    | boolean
    | undefined;
  /** Optional. Logit probabilities. */
  logprobs?:
    | number
    | undefined;
  /** Optional. Positive penalties. */
  presencePenalty?:
    | number
    | undefined;
  /** Optional. Frequency penalties. */
  frequencyPenalty?:
    | number
    | undefined;
  /** Optional. Seed. */
  seed?:
    | number
    | undefined;
  /**
   * Optional. Output response mimetype of the generated candidate text.
   * Supported mimetype:
   * - `text/plain`: (default) Text output.
   * - `application/json`: JSON response in the candidates.
   * The model needs to be prompted to output the appropriate response type,
   * otherwise the behavior is undefined.
   * This is a preview feature.
   */
  responseMimeType: string;
  /**
   * Optional. The `Schema` object allows the definition of input and output
   * data types. These types can be objects, but also primitives and arrays.
   * Represents a select subset of an [OpenAPI 3.0 schema
   * object](https://spec.openapis.org/oas/v3.0.3#schema).
   * If set, a compatible response_mime_type must also be set.
   * Compatible mimetypes:
   * `application/json`: Schema for JSON response.
   */
  responseSchema?:
    | Schema
    | undefined;
  /** Optional. Routing configuration. */
  routingConfig?: GenerationConfig_RoutingConfig | undefined;
}

/** The configuration for routing the request to a specific model. */
export interface GenerationConfig_RoutingConfig {
  /** Automated routing. */
  autoMode?:
    | GenerationConfig_RoutingConfig_AutoRoutingMode
    | undefined;
  /** Manual routing. */
  manualMode?: GenerationConfig_RoutingConfig_ManualRoutingMode | undefined;
}

/**
 * When automated routing is specified, the routing will be determined by
 * the pretrained routing model and customer provided model routing
 * preference.
 */
export interface GenerationConfig_RoutingConfig_AutoRoutingMode {
  /** The model routing preference. */
  modelRoutingPreference?: GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference | undefined;
}

/** The model routing preference. */
export enum GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference {
  /** UNKNOWN - Unspecified model routing preference. */
  UNKNOWN = 0,
  /** PRIORITIZE_QUALITY - Prefer higher quality over low cost. */
  PRIORITIZE_QUALITY = 1,
  /** BALANCED - Balanced model routing preference. */
  BALANCED = 2,
  /** PRIORITIZE_COST - Prefer lower cost over higher quality. */
  PRIORITIZE_COST = 3,
  UNRECOGNIZED = -1,
}

export function generationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreferenceFromJSON(
  object: any,
): GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference.UNKNOWN;
    case 1:
    case "PRIORITIZE_QUALITY":
      return GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference.PRIORITIZE_QUALITY;
    case 2:
    case "BALANCED":
      return GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference.BALANCED;
    case 3:
    case "PRIORITIZE_COST":
      return GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference.PRIORITIZE_COST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference.UNRECOGNIZED;
  }
}

export function generationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreferenceToJSON(
  object: GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference,
): string {
  switch (object) {
    case GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference.UNKNOWN:
      return "UNKNOWN";
    case GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference.PRIORITIZE_QUALITY:
      return "PRIORITIZE_QUALITY";
    case GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference.BALANCED:
      return "BALANCED";
    case GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference.PRIORITIZE_COST:
      return "PRIORITIZE_COST";
    case GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** When manual routing is set, the specified model will be used directly. */
export interface GenerationConfig_RoutingConfig_ManualRoutingMode {
  /**
   * The model name to use. Only the public LLM models are accepted. e.g.
   * 'gemini-1.5-pro-001'.
   */
  modelName?: string | undefined;
}

/** Safety settings. */
export interface SafetySetting {
  /** Required. Harm category. */
  category: HarmCategory;
  /** Required. The harm block threshold. */
  threshold: SafetySetting_HarmBlockThreshold;
  /**
   * Optional. Specify if the threshold is used for probability or severity
   * score. If not specified, the threshold is used for probability score.
   */
  method: SafetySetting_HarmBlockMethod;
}

/** Probability based thresholds levels for blocking. */
export enum SafetySetting_HarmBlockThreshold {
  /** HARM_BLOCK_THRESHOLD_UNSPECIFIED - Unspecified harm block threshold. */
  HARM_BLOCK_THRESHOLD_UNSPECIFIED = 0,
  /** BLOCK_LOW_AND_ABOVE - Block low threshold and above (i.e. block more). */
  BLOCK_LOW_AND_ABOVE = 1,
  /** BLOCK_MEDIUM_AND_ABOVE - Block medium threshold and above. */
  BLOCK_MEDIUM_AND_ABOVE = 2,
  /** BLOCK_ONLY_HIGH - Block only high threshold (i.e. block less). */
  BLOCK_ONLY_HIGH = 3,
  /** BLOCK_NONE - Block none. */
  BLOCK_NONE = 4,
  /** OFF - Turn off the safety filter. */
  OFF = 5,
  UNRECOGNIZED = -1,
}

export function safetySetting_HarmBlockThresholdFromJSON(object: any): SafetySetting_HarmBlockThreshold {
  switch (object) {
    case 0:
    case "HARM_BLOCK_THRESHOLD_UNSPECIFIED":
      return SafetySetting_HarmBlockThreshold.HARM_BLOCK_THRESHOLD_UNSPECIFIED;
    case 1:
    case "BLOCK_LOW_AND_ABOVE":
      return SafetySetting_HarmBlockThreshold.BLOCK_LOW_AND_ABOVE;
    case 2:
    case "BLOCK_MEDIUM_AND_ABOVE":
      return SafetySetting_HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE;
    case 3:
    case "BLOCK_ONLY_HIGH":
      return SafetySetting_HarmBlockThreshold.BLOCK_ONLY_HIGH;
    case 4:
    case "BLOCK_NONE":
      return SafetySetting_HarmBlockThreshold.BLOCK_NONE;
    case 5:
    case "OFF":
      return SafetySetting_HarmBlockThreshold.OFF;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SafetySetting_HarmBlockThreshold.UNRECOGNIZED;
  }
}

export function safetySetting_HarmBlockThresholdToJSON(object: SafetySetting_HarmBlockThreshold): string {
  switch (object) {
    case SafetySetting_HarmBlockThreshold.HARM_BLOCK_THRESHOLD_UNSPECIFIED:
      return "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
    case SafetySetting_HarmBlockThreshold.BLOCK_LOW_AND_ABOVE:
      return "BLOCK_LOW_AND_ABOVE";
    case SafetySetting_HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE:
      return "BLOCK_MEDIUM_AND_ABOVE";
    case SafetySetting_HarmBlockThreshold.BLOCK_ONLY_HIGH:
      return "BLOCK_ONLY_HIGH";
    case SafetySetting_HarmBlockThreshold.BLOCK_NONE:
      return "BLOCK_NONE";
    case SafetySetting_HarmBlockThreshold.OFF:
      return "OFF";
    case SafetySetting_HarmBlockThreshold.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Probability vs severity. */
export enum SafetySetting_HarmBlockMethod {
  /** HARM_BLOCK_METHOD_UNSPECIFIED - The harm block method is unspecified. */
  HARM_BLOCK_METHOD_UNSPECIFIED = 0,
  /** SEVERITY - The harm block method uses both probability and severity scores. */
  SEVERITY = 1,
  /** PROBABILITY - The harm block method uses the probability score. */
  PROBABILITY = 2,
  UNRECOGNIZED = -1,
}

export function safetySetting_HarmBlockMethodFromJSON(object: any): SafetySetting_HarmBlockMethod {
  switch (object) {
    case 0:
    case "HARM_BLOCK_METHOD_UNSPECIFIED":
      return SafetySetting_HarmBlockMethod.HARM_BLOCK_METHOD_UNSPECIFIED;
    case 1:
    case "SEVERITY":
      return SafetySetting_HarmBlockMethod.SEVERITY;
    case 2:
    case "PROBABILITY":
      return SafetySetting_HarmBlockMethod.PROBABILITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SafetySetting_HarmBlockMethod.UNRECOGNIZED;
  }
}

export function safetySetting_HarmBlockMethodToJSON(object: SafetySetting_HarmBlockMethod): string {
  switch (object) {
    case SafetySetting_HarmBlockMethod.HARM_BLOCK_METHOD_UNSPECIFIED:
      return "HARM_BLOCK_METHOD_UNSPECIFIED";
    case SafetySetting_HarmBlockMethod.SEVERITY:
      return "SEVERITY";
    case SafetySetting_HarmBlockMethod.PROBABILITY:
      return "PROBABILITY";
    case SafetySetting_HarmBlockMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Safety rating corresponding to the generated content. */
export interface SafetyRating {
  /** Output only. Harm category. */
  category: HarmCategory;
  /** Output only. Harm probability levels in the content. */
  probability: SafetyRating_HarmProbability;
  /** Output only. Harm probability score. */
  probabilityScore: number;
  /** Output only. Harm severity levels in the content. */
  severity: SafetyRating_HarmSeverity;
  /** Output only. Harm severity score. */
  severityScore: number;
  /**
   * Output only. Indicates whether the content was filtered out because of this
   * rating.
   */
  blocked: boolean;
}

/** Harm probability levels in the content. */
export enum SafetyRating_HarmProbability {
  /** HARM_PROBABILITY_UNSPECIFIED - Harm probability unspecified. */
  HARM_PROBABILITY_UNSPECIFIED = 0,
  /** NEGLIGIBLE - Negligible level of harm. */
  NEGLIGIBLE = 1,
  /** LOW - Low level of harm. */
  LOW = 2,
  /** MEDIUM - Medium level of harm. */
  MEDIUM = 3,
  /** HIGH - High level of harm. */
  HIGH = 4,
  UNRECOGNIZED = -1,
}

export function safetyRating_HarmProbabilityFromJSON(object: any): SafetyRating_HarmProbability {
  switch (object) {
    case 0:
    case "HARM_PROBABILITY_UNSPECIFIED":
      return SafetyRating_HarmProbability.HARM_PROBABILITY_UNSPECIFIED;
    case 1:
    case "NEGLIGIBLE":
      return SafetyRating_HarmProbability.NEGLIGIBLE;
    case 2:
    case "LOW":
      return SafetyRating_HarmProbability.LOW;
    case 3:
    case "MEDIUM":
      return SafetyRating_HarmProbability.MEDIUM;
    case 4:
    case "HIGH":
      return SafetyRating_HarmProbability.HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SafetyRating_HarmProbability.UNRECOGNIZED;
  }
}

export function safetyRating_HarmProbabilityToJSON(object: SafetyRating_HarmProbability): string {
  switch (object) {
    case SafetyRating_HarmProbability.HARM_PROBABILITY_UNSPECIFIED:
      return "HARM_PROBABILITY_UNSPECIFIED";
    case SafetyRating_HarmProbability.NEGLIGIBLE:
      return "NEGLIGIBLE";
    case SafetyRating_HarmProbability.LOW:
      return "LOW";
    case SafetyRating_HarmProbability.MEDIUM:
      return "MEDIUM";
    case SafetyRating_HarmProbability.HIGH:
      return "HIGH";
    case SafetyRating_HarmProbability.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Harm severity levels. */
export enum SafetyRating_HarmSeverity {
  /** HARM_SEVERITY_UNSPECIFIED - Harm severity unspecified. */
  HARM_SEVERITY_UNSPECIFIED = 0,
  /** HARM_SEVERITY_NEGLIGIBLE - Negligible level of harm severity. */
  HARM_SEVERITY_NEGLIGIBLE = 1,
  /** HARM_SEVERITY_LOW - Low level of harm severity. */
  HARM_SEVERITY_LOW = 2,
  /** HARM_SEVERITY_MEDIUM - Medium level of harm severity. */
  HARM_SEVERITY_MEDIUM = 3,
  /** HARM_SEVERITY_HIGH - High level of harm severity. */
  HARM_SEVERITY_HIGH = 4,
  UNRECOGNIZED = -1,
}

export function safetyRating_HarmSeverityFromJSON(object: any): SafetyRating_HarmSeverity {
  switch (object) {
    case 0:
    case "HARM_SEVERITY_UNSPECIFIED":
      return SafetyRating_HarmSeverity.HARM_SEVERITY_UNSPECIFIED;
    case 1:
    case "HARM_SEVERITY_NEGLIGIBLE":
      return SafetyRating_HarmSeverity.HARM_SEVERITY_NEGLIGIBLE;
    case 2:
    case "HARM_SEVERITY_LOW":
      return SafetyRating_HarmSeverity.HARM_SEVERITY_LOW;
    case 3:
    case "HARM_SEVERITY_MEDIUM":
      return SafetyRating_HarmSeverity.HARM_SEVERITY_MEDIUM;
    case 4:
    case "HARM_SEVERITY_HIGH":
      return SafetyRating_HarmSeverity.HARM_SEVERITY_HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SafetyRating_HarmSeverity.UNRECOGNIZED;
  }
}

export function safetyRating_HarmSeverityToJSON(object: SafetyRating_HarmSeverity): string {
  switch (object) {
    case SafetyRating_HarmSeverity.HARM_SEVERITY_UNSPECIFIED:
      return "HARM_SEVERITY_UNSPECIFIED";
    case SafetyRating_HarmSeverity.HARM_SEVERITY_NEGLIGIBLE:
      return "HARM_SEVERITY_NEGLIGIBLE";
    case SafetyRating_HarmSeverity.HARM_SEVERITY_LOW:
      return "HARM_SEVERITY_LOW";
    case SafetyRating_HarmSeverity.HARM_SEVERITY_MEDIUM:
      return "HARM_SEVERITY_MEDIUM";
    case SafetyRating_HarmSeverity.HARM_SEVERITY_HIGH:
      return "HARM_SEVERITY_HIGH";
    case SafetyRating_HarmSeverity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A collection of source attributions for a piece of content. */
export interface CitationMetadata {
  /** Output only. List of citations. */
  citations: Citation[];
}

/** Source attributions for content. */
export interface Citation {
  /** Output only. Start index into the content. */
  startIndex: number;
  /** Output only. End index into the content. */
  endIndex: number;
  /** Output only. Url reference of the attribution. */
  uri: string;
  /** Output only. Title of the attribution. */
  title: string;
  /** Output only. License of the attribution. */
  license: string;
  /** Output only. Publication date of the attribution. */
  publicationDate: DateMessage | undefined;
}

/** A response candidate generated from the model. */
export interface Candidate {
  /** Output only. Index of the candidate. */
  index: number;
  /** Output only. Content parts of the candidate. */
  content:
    | Content
    | undefined;
  /** Output only. Average log probability score of the candidate. */
  avgLogprobs: number;
  /** Output only. Log-likelihood scores for the response tokens and top tokens */
  logprobsResult:
    | LogprobsResult
    | undefined;
  /**
   * Output only. The reason why the model stopped generating tokens.
   * If empty, the model has not stopped generating the tokens.
   */
  finishReason: Candidate_FinishReason;
  /**
   * Output only. List of ratings for the safety of a response candidate.
   *
   * There is at most one rating per category.
   */
  safetyRatings: SafetyRating[];
  /**
   * Output only. Describes the reason the mode stopped generating tokens in
   * more detail. This is only filled when `finish_reason` is set.
   */
  finishMessage?:
    | string
    | undefined;
  /** Output only. Source attribution of the generated content. */
  citationMetadata:
    | CitationMetadata
    | undefined;
  /** Output only. Metadata specifies sources used to ground generated content. */
  groundingMetadata: GroundingMetadata | undefined;
}

/**
 * The reason why the model stopped generating tokens.
 * If empty, the model has not stopped generating the tokens.
 */
export enum Candidate_FinishReason {
  /** FINISH_REASON_UNSPECIFIED - The finish reason is unspecified. */
  FINISH_REASON_UNSPECIFIED = 0,
  /**
   * STOP - Token generation reached a natural stopping point or a configured stop
   * sequence.
   */
  STOP = 1,
  /** MAX_TOKENS - Token generation reached the configured maximum output tokens. */
  MAX_TOKENS = 2,
  /**
   * SAFETY - Token generation stopped because the content potentially contains safety
   * violations. NOTE: When streaming,
   * [content][google.cloud.aiplatform.v1beta1.Candidate.content] is empty if
   * content filters blocks the output.
   */
  SAFETY = 3,
  /**
   * RECITATION - Token generation stopped because the content potentially contains
   * copyright violations.
   */
  RECITATION = 4,
  /** OTHER - All other reasons that stopped the token generation. */
  OTHER = 5,
  /** BLOCKLIST - Token generation stopped because the content contains forbidden terms. */
  BLOCKLIST = 6,
  /** PROHIBITED_CONTENT - Token generation stopped for potentially containing prohibited content. */
  PROHIBITED_CONTENT = 7,
  /**
   * SPII - Token generation stopped because the content potentially contains
   * Sensitive Personally Identifiable Information (SPII).
   */
  SPII = 8,
  /** MALFORMED_FUNCTION_CALL - The function call generated by the model is invalid. */
  MALFORMED_FUNCTION_CALL = 9,
  UNRECOGNIZED = -1,
}

export function candidate_FinishReasonFromJSON(object: any): Candidate_FinishReason {
  switch (object) {
    case 0:
    case "FINISH_REASON_UNSPECIFIED":
      return Candidate_FinishReason.FINISH_REASON_UNSPECIFIED;
    case 1:
    case "STOP":
      return Candidate_FinishReason.STOP;
    case 2:
    case "MAX_TOKENS":
      return Candidate_FinishReason.MAX_TOKENS;
    case 3:
    case "SAFETY":
      return Candidate_FinishReason.SAFETY;
    case 4:
    case "RECITATION":
      return Candidate_FinishReason.RECITATION;
    case 5:
    case "OTHER":
      return Candidate_FinishReason.OTHER;
    case 6:
    case "BLOCKLIST":
      return Candidate_FinishReason.BLOCKLIST;
    case 7:
    case "PROHIBITED_CONTENT":
      return Candidate_FinishReason.PROHIBITED_CONTENT;
    case 8:
    case "SPII":
      return Candidate_FinishReason.SPII;
    case 9:
    case "MALFORMED_FUNCTION_CALL":
      return Candidate_FinishReason.MALFORMED_FUNCTION_CALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Candidate_FinishReason.UNRECOGNIZED;
  }
}

export function candidate_FinishReasonToJSON(object: Candidate_FinishReason): string {
  switch (object) {
    case Candidate_FinishReason.FINISH_REASON_UNSPECIFIED:
      return "FINISH_REASON_UNSPECIFIED";
    case Candidate_FinishReason.STOP:
      return "STOP";
    case Candidate_FinishReason.MAX_TOKENS:
      return "MAX_TOKENS";
    case Candidate_FinishReason.SAFETY:
      return "SAFETY";
    case Candidate_FinishReason.RECITATION:
      return "RECITATION";
    case Candidate_FinishReason.OTHER:
      return "OTHER";
    case Candidate_FinishReason.BLOCKLIST:
      return "BLOCKLIST";
    case Candidate_FinishReason.PROHIBITED_CONTENT:
      return "PROHIBITED_CONTENT";
    case Candidate_FinishReason.SPII:
      return "SPII";
    case Candidate_FinishReason.MALFORMED_FUNCTION_CALL:
      return "MALFORMED_FUNCTION_CALL";
    case Candidate_FinishReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Logprobs Result */
export interface LogprobsResult {
  /** Length = total number of decoding steps. */
  topCandidates: LogprobsResult_TopCandidates[];
  /**
   * Length = total number of decoding steps.
   * The chosen candidates may or may not be in top_candidates.
   */
  chosenCandidates: LogprobsResult_Candidate[];
}

/** Candidate for the logprobs token and score. */
export interface LogprobsResult_Candidate {
  /** The candidate’s token string value. */
  token?:
    | string
    | undefined;
  /** The candidate’s token id value. */
  tokenId?:
    | number
    | undefined;
  /** The candidate's log probability. */
  logProbability?: number | undefined;
}

/** Candidates with top log probabilities at each decoding step. */
export interface LogprobsResult_TopCandidates {
  /** Sorted by log probability in descending order. */
  candidates: LogprobsResult_Candidate[];
}

/** Segment of the content. */
export interface Segment {
  /** Output only. The index of a Part object within its parent Content object. */
  partIndex: number;
  /**
   * Output only. Start index in the given Part, measured in bytes. Offset from
   * the start of the Part, inclusive, starting at zero.
   */
  startIndex: number;
  /**
   * Output only. End index in the given Part, measured in bytes. Offset from
   * the start of the Part, exclusive, starting at zero.
   */
  endIndex: number;
  /** Output only. The text corresponding to the segment from the response. */
  text: string;
}

/** Grounding chunk. */
export interface GroundingChunk {
  /** Grounding chunk from the web. */
  web?:
    | GroundingChunk_Web
    | undefined;
  /** Grounding chunk from context retrieved by the retrieval tools. */
  retrievedContext?: GroundingChunk_RetrievedContext | undefined;
}

/** Chunk from the web. */
export interface GroundingChunk_Web {
  /** URI reference of the chunk. */
  uri?:
    | string
    | undefined;
  /** Title of the chunk. */
  title?: string | undefined;
}

/** Chunk from context retrieved by the retrieval tools. */
export interface GroundingChunk_RetrievedContext {
  /** URI reference of the attribution. */
  uri?:
    | string
    | undefined;
  /** Title of the attribution. */
  title?: string | undefined;
}

/** Grounding support. */
export interface GroundingSupport {
  /** Segment of the content this support belongs to. */
  segment?:
    | Segment
    | undefined;
  /**
   * A list of indices (into 'grounding_chunk') specifying the
   * citations associated with the claim. For instance [1,3,4] means
   * that grounding_chunk[1], grounding_chunk[3],
   * grounding_chunk[4] are the retrieved content attributed to the claim.
   */
  groundingChunkIndices: number[];
  /**
   * Confidence score of the support references. Ranges from 0 to 1. 1 is the
   * most confident. This list must have the same size as the
   * grounding_chunk_indices.
   */
  confidenceScores: number[];
}

/** Metadata returned to client when grounding is enabled. */
export interface GroundingMetadata {
  /** Optional. Web search queries for the following-up web search. */
  webSearchQueries: string[];
  /** Optional. Google search entry for the following-up web searches. */
  searchEntryPoint?:
    | SearchEntryPoint
    | undefined;
  /** Optional. Queries executed by the retrieval tools. */
  retrievalQueries: string[];
  /** List of supporting references retrieved from specified grounding source. */
  groundingChunks: GroundingChunk[];
  /** Optional. List of grounding support. */
  groundingSupports: GroundingSupport[];
}

/** Google search entry point. */
export interface SearchEntryPoint {
  /**
   * Optional. Web content snippet that can be embedded in a web page or an app
   * webview.
   */
  renderedContent: string;
  /**
   * Optional. Base64 encoded JSON representing array of <search term, search
   * url> tuple.
   */
  sdkBlob: Buffer;
}

function createBaseContent(): Content {
  return { role: "", parts: [] };
}

export const Content: MessageFns<Content> = {
  encode(message: Content, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.role !== "") {
      writer.uint32(10).string(message.role);
    }
    for (const v of message.parts) {
      Part.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Content {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parts.push(Part.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Content {
    return {
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      parts: globalThis.Array.isArray(object?.parts) ? object.parts.map((e: any) => Part.fromJSON(e)) : [],
    };
  },

  toJSON(message: Content): unknown {
    const obj: any = {};
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.parts?.length) {
      obj.parts = message.parts.map((e) => Part.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Content>): Content {
    return Content.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Content>): Content {
    const message = createBaseContent();
    message.role = object.role ?? "";
    message.parts = object.parts?.map((e) => Part.fromPartial(e)) || [];
    return message;
  },
};

function createBasePart(): Part {
  return {
    text: undefined,
    inlineData: undefined,
    fileData: undefined,
    functionCall: undefined,
    functionResponse: undefined,
    videoMetadata: undefined,
  };
}

export const Part: MessageFns<Part> = {
  encode(message: Part, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      writer.uint32(10).string(message.text);
    }
    if (message.inlineData !== undefined) {
      Blob.encode(message.inlineData, writer.uint32(18).fork()).join();
    }
    if (message.fileData !== undefined) {
      FileData.encode(message.fileData, writer.uint32(26).fork()).join();
    }
    if (message.functionCall !== undefined) {
      FunctionCall.encode(message.functionCall, writer.uint32(42).fork()).join();
    }
    if (message.functionResponse !== undefined) {
      FunctionResponse.encode(message.functionResponse, writer.uint32(50).fork()).join();
    }
    if (message.videoMetadata !== undefined) {
      VideoMetadata.encode(message.videoMetadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Part {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inlineData = Blob.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fileData = FileData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.functionCall = FunctionCall.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.functionResponse = FunctionResponse.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.videoMetadata = VideoMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Part {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      inlineData: isSet(object.inlineData) ? Blob.fromJSON(object.inlineData) : undefined,
      fileData: isSet(object.fileData) ? FileData.fromJSON(object.fileData) : undefined,
      functionCall: isSet(object.functionCall) ? FunctionCall.fromJSON(object.functionCall) : undefined,
      functionResponse: isSet(object.functionResponse) ? FunctionResponse.fromJSON(object.functionResponse) : undefined,
      videoMetadata: isSet(object.videoMetadata) ? VideoMetadata.fromJSON(object.videoMetadata) : undefined,
    };
  },

  toJSON(message: Part): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.inlineData !== undefined) {
      obj.inlineData = Blob.toJSON(message.inlineData);
    }
    if (message.fileData !== undefined) {
      obj.fileData = FileData.toJSON(message.fileData);
    }
    if (message.functionCall !== undefined) {
      obj.functionCall = FunctionCall.toJSON(message.functionCall);
    }
    if (message.functionResponse !== undefined) {
      obj.functionResponse = FunctionResponse.toJSON(message.functionResponse);
    }
    if (message.videoMetadata !== undefined) {
      obj.videoMetadata = VideoMetadata.toJSON(message.videoMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<Part>): Part {
    return Part.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Part>): Part {
    const message = createBasePart();
    message.text = object.text ?? undefined;
    message.inlineData = (object.inlineData !== undefined && object.inlineData !== null)
      ? Blob.fromPartial(object.inlineData)
      : undefined;
    message.fileData = (object.fileData !== undefined && object.fileData !== null)
      ? FileData.fromPartial(object.fileData)
      : undefined;
    message.functionCall = (object.functionCall !== undefined && object.functionCall !== null)
      ? FunctionCall.fromPartial(object.functionCall)
      : undefined;
    message.functionResponse = (object.functionResponse !== undefined && object.functionResponse !== null)
      ? FunctionResponse.fromPartial(object.functionResponse)
      : undefined;
    message.videoMetadata = (object.videoMetadata !== undefined && object.videoMetadata !== null)
      ? VideoMetadata.fromPartial(object.videoMetadata)
      : undefined;
    return message;
  },
};

function createBaseBlob(): Blob {
  return { mimeType: "", data: Buffer.alloc(0) };
}

export const Blob: MessageFns<Blob> = {
  encode(message: Blob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mimeType !== "") {
      writer.uint32(10).string(message.mimeType);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Blob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Blob {
    return {
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Blob): unknown {
    const obj: any = {};
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<Blob>): Blob {
    return Blob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Blob>): Blob {
    const message = createBaseBlob();
    message.mimeType = object.mimeType ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseFileData(): FileData {
  return { mimeType: "", fileUri: "" };
}

export const FileData: MessageFns<FileData> = {
  encode(message: FileData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mimeType !== "") {
      writer.uint32(10).string(message.mimeType);
    }
    if (message.fileUri !== "") {
      writer.uint32(18).string(message.fileUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fileUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileData {
    return {
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      fileUri: isSet(object.fileUri) ? globalThis.String(object.fileUri) : "",
    };
  },

  toJSON(message: FileData): unknown {
    const obj: any = {};
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.fileUri !== "") {
      obj.fileUri = message.fileUri;
    }
    return obj;
  },

  create(base?: DeepPartial<FileData>): FileData {
    return FileData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileData>): FileData {
    const message = createBaseFileData();
    message.mimeType = object.mimeType ?? "";
    message.fileUri = object.fileUri ?? "";
    return message;
  },
};

function createBaseVideoMetadata(): VideoMetadata {
  return { startOffset: undefined, endOffset: undefined };
}

export const VideoMetadata: MessageFns<VideoMetadata> = {
  encode(message: VideoMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startOffset !== undefined) {
      Duration.encode(message.startOffset, writer.uint32(10).fork()).join();
    }
    if (message.endOffset !== undefined) {
      Duration.encode(message.endOffset, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startOffset = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endOffset = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoMetadata {
    return {
      startOffset: isSet(object.startOffset) ? Duration.fromJSON(object.startOffset) : undefined,
      endOffset: isSet(object.endOffset) ? Duration.fromJSON(object.endOffset) : undefined,
    };
  },

  toJSON(message: VideoMetadata): unknown {
    const obj: any = {};
    if (message.startOffset !== undefined) {
      obj.startOffset = Duration.toJSON(message.startOffset);
    }
    if (message.endOffset !== undefined) {
      obj.endOffset = Duration.toJSON(message.endOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<VideoMetadata>): VideoMetadata {
    return VideoMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoMetadata>): VideoMetadata {
    const message = createBaseVideoMetadata();
    message.startOffset = (object.startOffset !== undefined && object.startOffset !== null)
      ? Duration.fromPartial(object.startOffset)
      : undefined;
    message.endOffset = (object.endOffset !== undefined && object.endOffset !== null)
      ? Duration.fromPartial(object.endOffset)
      : undefined;
    return message;
  },
};

function createBaseGenerationConfig(): GenerationConfig {
  return {
    temperature: undefined,
    topP: undefined,
    topK: undefined,
    candidateCount: undefined,
    maxOutputTokens: undefined,
    stopSequences: [],
    responseLogprobs: undefined,
    logprobs: undefined,
    presencePenalty: undefined,
    frequencyPenalty: undefined,
    seed: undefined,
    responseMimeType: "",
    responseSchema: undefined,
    routingConfig: undefined,
  };
}

export const GenerationConfig: MessageFns<GenerationConfig> = {
  encode(message: GenerationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.temperature !== undefined) {
      writer.uint32(13).float(message.temperature);
    }
    if (message.topP !== undefined) {
      writer.uint32(21).float(message.topP);
    }
    if (message.topK !== undefined) {
      writer.uint32(29).float(message.topK);
    }
    if (message.candidateCount !== undefined) {
      writer.uint32(32).int32(message.candidateCount);
    }
    if (message.maxOutputTokens !== undefined) {
      writer.uint32(40).int32(message.maxOutputTokens);
    }
    for (const v of message.stopSequences) {
      writer.uint32(50).string(v!);
    }
    if (message.responseLogprobs !== undefined) {
      writer.uint32(144).bool(message.responseLogprobs);
    }
    if (message.logprobs !== undefined) {
      writer.uint32(56).int32(message.logprobs);
    }
    if (message.presencePenalty !== undefined) {
      writer.uint32(69).float(message.presencePenalty);
    }
    if (message.frequencyPenalty !== undefined) {
      writer.uint32(77).float(message.frequencyPenalty);
    }
    if (message.seed !== undefined) {
      writer.uint32(96).int32(message.seed);
    }
    if (message.responseMimeType !== "") {
      writer.uint32(106).string(message.responseMimeType);
    }
    if (message.responseSchema !== undefined) {
      Schema.encode(message.responseSchema, writer.uint32(130).fork()).join();
    }
    if (message.routingConfig !== undefined) {
      GenerationConfig_RoutingConfig.encode(message.routingConfig, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.temperature = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.topP = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.topK = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.candidateCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxOutputTokens = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.stopSequences.push(reader.string());
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.responseLogprobs = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.logprobs = reader.int32();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.presencePenalty = reader.float();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.frequencyPenalty = reader.float();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.seed = reader.int32();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.responseMimeType = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.responseSchema = Schema.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.routingConfig = GenerationConfig_RoutingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationConfig {
    return {
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : undefined,
      topP: isSet(object.topP) ? globalThis.Number(object.topP) : undefined,
      topK: isSet(object.topK) ? globalThis.Number(object.topK) : undefined,
      candidateCount: isSet(object.candidateCount) ? globalThis.Number(object.candidateCount) : undefined,
      maxOutputTokens: isSet(object.maxOutputTokens) ? globalThis.Number(object.maxOutputTokens) : undefined,
      stopSequences: globalThis.Array.isArray(object?.stopSequences)
        ? object.stopSequences.map((e: any) => globalThis.String(e))
        : [],
      responseLogprobs: isSet(object.responseLogprobs) ? globalThis.Boolean(object.responseLogprobs) : undefined,
      logprobs: isSet(object.logprobs) ? globalThis.Number(object.logprobs) : undefined,
      presencePenalty: isSet(object.presencePenalty) ? globalThis.Number(object.presencePenalty) : undefined,
      frequencyPenalty: isSet(object.frequencyPenalty) ? globalThis.Number(object.frequencyPenalty) : undefined,
      seed: isSet(object.seed) ? globalThis.Number(object.seed) : undefined,
      responseMimeType: isSet(object.responseMimeType) ? globalThis.String(object.responseMimeType) : "",
      responseSchema: isSet(object.responseSchema) ? Schema.fromJSON(object.responseSchema) : undefined,
      routingConfig: isSet(object.routingConfig)
        ? GenerationConfig_RoutingConfig.fromJSON(object.routingConfig)
        : undefined,
    };
  },

  toJSON(message: GenerationConfig): unknown {
    const obj: any = {};
    if (message.temperature !== undefined) {
      obj.temperature = message.temperature;
    }
    if (message.topP !== undefined) {
      obj.topP = message.topP;
    }
    if (message.topK !== undefined) {
      obj.topK = message.topK;
    }
    if (message.candidateCount !== undefined) {
      obj.candidateCount = Math.round(message.candidateCount);
    }
    if (message.maxOutputTokens !== undefined) {
      obj.maxOutputTokens = Math.round(message.maxOutputTokens);
    }
    if (message.stopSequences?.length) {
      obj.stopSequences = message.stopSequences;
    }
    if (message.responseLogprobs !== undefined) {
      obj.responseLogprobs = message.responseLogprobs;
    }
    if (message.logprobs !== undefined) {
      obj.logprobs = Math.round(message.logprobs);
    }
    if (message.presencePenalty !== undefined) {
      obj.presencePenalty = message.presencePenalty;
    }
    if (message.frequencyPenalty !== undefined) {
      obj.frequencyPenalty = message.frequencyPenalty;
    }
    if (message.seed !== undefined) {
      obj.seed = Math.round(message.seed);
    }
    if (message.responseMimeType !== "") {
      obj.responseMimeType = message.responseMimeType;
    }
    if (message.responseSchema !== undefined) {
      obj.responseSchema = Schema.toJSON(message.responseSchema);
    }
    if (message.routingConfig !== undefined) {
      obj.routingConfig = GenerationConfig_RoutingConfig.toJSON(message.routingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerationConfig>): GenerationConfig {
    return GenerationConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerationConfig>): GenerationConfig {
    const message = createBaseGenerationConfig();
    message.temperature = object.temperature ?? undefined;
    message.topP = object.topP ?? undefined;
    message.topK = object.topK ?? undefined;
    message.candidateCount = object.candidateCount ?? undefined;
    message.maxOutputTokens = object.maxOutputTokens ?? undefined;
    message.stopSequences = object.stopSequences?.map((e) => e) || [];
    message.responseLogprobs = object.responseLogprobs ?? undefined;
    message.logprobs = object.logprobs ?? undefined;
    message.presencePenalty = object.presencePenalty ?? undefined;
    message.frequencyPenalty = object.frequencyPenalty ?? undefined;
    message.seed = object.seed ?? undefined;
    message.responseMimeType = object.responseMimeType ?? "";
    message.responseSchema = (object.responseSchema !== undefined && object.responseSchema !== null)
      ? Schema.fromPartial(object.responseSchema)
      : undefined;
    message.routingConfig = (object.routingConfig !== undefined && object.routingConfig !== null)
      ? GenerationConfig_RoutingConfig.fromPartial(object.routingConfig)
      : undefined;
    return message;
  },
};

function createBaseGenerationConfig_RoutingConfig(): GenerationConfig_RoutingConfig {
  return { autoMode: undefined, manualMode: undefined };
}

export const GenerationConfig_RoutingConfig: MessageFns<GenerationConfig_RoutingConfig> = {
  encode(message: GenerationConfig_RoutingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.autoMode !== undefined) {
      GenerationConfig_RoutingConfig_AutoRoutingMode.encode(message.autoMode, writer.uint32(10).fork()).join();
    }
    if (message.manualMode !== undefined) {
      GenerationConfig_RoutingConfig_ManualRoutingMode.encode(message.manualMode, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationConfig_RoutingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationConfig_RoutingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.autoMode = GenerationConfig_RoutingConfig_AutoRoutingMode.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.manualMode = GenerationConfig_RoutingConfig_ManualRoutingMode.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationConfig_RoutingConfig {
    return {
      autoMode: isSet(object.autoMode)
        ? GenerationConfig_RoutingConfig_AutoRoutingMode.fromJSON(object.autoMode)
        : undefined,
      manualMode: isSet(object.manualMode)
        ? GenerationConfig_RoutingConfig_ManualRoutingMode.fromJSON(object.manualMode)
        : undefined,
    };
  },

  toJSON(message: GenerationConfig_RoutingConfig): unknown {
    const obj: any = {};
    if (message.autoMode !== undefined) {
      obj.autoMode = GenerationConfig_RoutingConfig_AutoRoutingMode.toJSON(message.autoMode);
    }
    if (message.manualMode !== undefined) {
      obj.manualMode = GenerationConfig_RoutingConfig_ManualRoutingMode.toJSON(message.manualMode);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerationConfig_RoutingConfig>): GenerationConfig_RoutingConfig {
    return GenerationConfig_RoutingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerationConfig_RoutingConfig>): GenerationConfig_RoutingConfig {
    const message = createBaseGenerationConfig_RoutingConfig();
    message.autoMode = (object.autoMode !== undefined && object.autoMode !== null)
      ? GenerationConfig_RoutingConfig_AutoRoutingMode.fromPartial(object.autoMode)
      : undefined;
    message.manualMode = (object.manualMode !== undefined && object.manualMode !== null)
      ? GenerationConfig_RoutingConfig_ManualRoutingMode.fromPartial(object.manualMode)
      : undefined;
    return message;
  },
};

function createBaseGenerationConfig_RoutingConfig_AutoRoutingMode(): GenerationConfig_RoutingConfig_AutoRoutingMode {
  return { modelRoutingPreference: undefined };
}

export const GenerationConfig_RoutingConfig_AutoRoutingMode: MessageFns<
  GenerationConfig_RoutingConfig_AutoRoutingMode
> = {
  encode(
    message: GenerationConfig_RoutingConfig_AutoRoutingMode,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.modelRoutingPreference !== undefined) {
      writer.uint32(8).int32(message.modelRoutingPreference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationConfig_RoutingConfig_AutoRoutingMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationConfig_RoutingConfig_AutoRoutingMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.modelRoutingPreference = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationConfig_RoutingConfig_AutoRoutingMode {
    return {
      modelRoutingPreference: isSet(object.modelRoutingPreference)
        ? generationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreferenceFromJSON(object.modelRoutingPreference)
        : undefined,
    };
  },

  toJSON(message: GenerationConfig_RoutingConfig_AutoRoutingMode): unknown {
    const obj: any = {};
    if (message.modelRoutingPreference !== undefined) {
      obj.modelRoutingPreference = generationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreferenceToJSON(
        message.modelRoutingPreference,
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<GenerationConfig_RoutingConfig_AutoRoutingMode>,
  ): GenerationConfig_RoutingConfig_AutoRoutingMode {
    return GenerationConfig_RoutingConfig_AutoRoutingMode.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenerationConfig_RoutingConfig_AutoRoutingMode>,
  ): GenerationConfig_RoutingConfig_AutoRoutingMode {
    const message = createBaseGenerationConfig_RoutingConfig_AutoRoutingMode();
    message.modelRoutingPreference = object.modelRoutingPreference ?? undefined;
    return message;
  },
};

function createBaseGenerationConfig_RoutingConfig_ManualRoutingMode(): GenerationConfig_RoutingConfig_ManualRoutingMode {
  return { modelName: undefined };
}

export const GenerationConfig_RoutingConfig_ManualRoutingMode: MessageFns<
  GenerationConfig_RoutingConfig_ManualRoutingMode
> = {
  encode(
    message: GenerationConfig_RoutingConfig_ManualRoutingMode,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.modelName !== undefined) {
      writer.uint32(10).string(message.modelName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationConfig_RoutingConfig_ManualRoutingMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationConfig_RoutingConfig_ManualRoutingMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.modelName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationConfig_RoutingConfig_ManualRoutingMode {
    return { modelName: isSet(object.modelName) ? globalThis.String(object.modelName) : undefined };
  },

  toJSON(message: GenerationConfig_RoutingConfig_ManualRoutingMode): unknown {
    const obj: any = {};
    if (message.modelName !== undefined) {
      obj.modelName = message.modelName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GenerationConfig_RoutingConfig_ManualRoutingMode>,
  ): GenerationConfig_RoutingConfig_ManualRoutingMode {
    return GenerationConfig_RoutingConfig_ManualRoutingMode.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenerationConfig_RoutingConfig_ManualRoutingMode>,
  ): GenerationConfig_RoutingConfig_ManualRoutingMode {
    const message = createBaseGenerationConfig_RoutingConfig_ManualRoutingMode();
    message.modelName = object.modelName ?? undefined;
    return message;
  },
};

function createBaseSafetySetting(): SafetySetting {
  return { category: 0, threshold: 0, method: 0 };
}

export const SafetySetting: MessageFns<SafetySetting> = {
  encode(message: SafetySetting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== 0) {
      writer.uint32(8).int32(message.category);
    }
    if (message.threshold !== 0) {
      writer.uint32(16).int32(message.threshold);
    }
    if (message.method !== 0) {
      writer.uint32(32).int32(message.method);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SafetySetting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSafetySetting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.threshold = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SafetySetting {
    return {
      category: isSet(object.category) ? harmCategoryFromJSON(object.category) : 0,
      threshold: isSet(object.threshold) ? safetySetting_HarmBlockThresholdFromJSON(object.threshold) : 0,
      method: isSet(object.method) ? safetySetting_HarmBlockMethodFromJSON(object.method) : 0,
    };
  },

  toJSON(message: SafetySetting): unknown {
    const obj: any = {};
    if (message.category !== 0) {
      obj.category = harmCategoryToJSON(message.category);
    }
    if (message.threshold !== 0) {
      obj.threshold = safetySetting_HarmBlockThresholdToJSON(message.threshold);
    }
    if (message.method !== 0) {
      obj.method = safetySetting_HarmBlockMethodToJSON(message.method);
    }
    return obj;
  },

  create(base?: DeepPartial<SafetySetting>): SafetySetting {
    return SafetySetting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SafetySetting>): SafetySetting {
    const message = createBaseSafetySetting();
    message.category = object.category ?? 0;
    message.threshold = object.threshold ?? 0;
    message.method = object.method ?? 0;
    return message;
  },
};

function createBaseSafetyRating(): SafetyRating {
  return { category: 0, probability: 0, probabilityScore: 0, severity: 0, severityScore: 0, blocked: false };
}

export const SafetyRating: MessageFns<SafetyRating> = {
  encode(message: SafetyRating, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== 0) {
      writer.uint32(8).int32(message.category);
    }
    if (message.probability !== 0) {
      writer.uint32(16).int32(message.probability);
    }
    if (message.probabilityScore !== 0) {
      writer.uint32(45).float(message.probabilityScore);
    }
    if (message.severity !== 0) {
      writer.uint32(48).int32(message.severity);
    }
    if (message.severityScore !== 0) {
      writer.uint32(61).float(message.severityScore);
    }
    if (message.blocked !== false) {
      writer.uint32(24).bool(message.blocked);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SafetyRating {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSafetyRating();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.probability = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.probabilityScore = reader.float();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.severityScore = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.blocked = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SafetyRating {
    return {
      category: isSet(object.category) ? harmCategoryFromJSON(object.category) : 0,
      probability: isSet(object.probability) ? safetyRating_HarmProbabilityFromJSON(object.probability) : 0,
      probabilityScore: isSet(object.probabilityScore) ? globalThis.Number(object.probabilityScore) : 0,
      severity: isSet(object.severity) ? safetyRating_HarmSeverityFromJSON(object.severity) : 0,
      severityScore: isSet(object.severityScore) ? globalThis.Number(object.severityScore) : 0,
      blocked: isSet(object.blocked) ? globalThis.Boolean(object.blocked) : false,
    };
  },

  toJSON(message: SafetyRating): unknown {
    const obj: any = {};
    if (message.category !== 0) {
      obj.category = harmCategoryToJSON(message.category);
    }
    if (message.probability !== 0) {
      obj.probability = safetyRating_HarmProbabilityToJSON(message.probability);
    }
    if (message.probabilityScore !== 0) {
      obj.probabilityScore = message.probabilityScore;
    }
    if (message.severity !== 0) {
      obj.severity = safetyRating_HarmSeverityToJSON(message.severity);
    }
    if (message.severityScore !== 0) {
      obj.severityScore = message.severityScore;
    }
    if (message.blocked !== false) {
      obj.blocked = message.blocked;
    }
    return obj;
  },

  create(base?: DeepPartial<SafetyRating>): SafetyRating {
    return SafetyRating.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SafetyRating>): SafetyRating {
    const message = createBaseSafetyRating();
    message.category = object.category ?? 0;
    message.probability = object.probability ?? 0;
    message.probabilityScore = object.probabilityScore ?? 0;
    message.severity = object.severity ?? 0;
    message.severityScore = object.severityScore ?? 0;
    message.blocked = object.blocked ?? false;
    return message;
  },
};

function createBaseCitationMetadata(): CitationMetadata {
  return { citations: [] };
}

export const CitationMetadata: MessageFns<CitationMetadata> = {
  encode(message: CitationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.citations) {
      Citation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CitationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCitationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.citations.push(Citation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CitationMetadata {
    return {
      citations: globalThis.Array.isArray(object?.citations)
        ? object.citations.map((e: any) => Citation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CitationMetadata): unknown {
    const obj: any = {};
    if (message.citations?.length) {
      obj.citations = message.citations.map((e) => Citation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CitationMetadata>): CitationMetadata {
    return CitationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CitationMetadata>): CitationMetadata {
    const message = createBaseCitationMetadata();
    message.citations = object.citations?.map((e) => Citation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCitation(): Citation {
  return { startIndex: 0, endIndex: 0, uri: "", title: "", license: "", publicationDate: undefined };
}

export const Citation: MessageFns<Citation> = {
  encode(message: Citation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startIndex !== 0) {
      writer.uint32(8).int32(message.startIndex);
    }
    if (message.endIndex !== 0) {
      writer.uint32(16).int32(message.endIndex);
    }
    if (message.uri !== "") {
      writer.uint32(26).string(message.uri);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    if (message.license !== "") {
      writer.uint32(42).string(message.license);
    }
    if (message.publicationDate !== undefined) {
      DateMessage.encode(message.publicationDate, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Citation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCitation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.license = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.publicationDate = DateMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Citation {
    return {
      startIndex: isSet(object.startIndex) ? globalThis.Number(object.startIndex) : 0,
      endIndex: isSet(object.endIndex) ? globalThis.Number(object.endIndex) : 0,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      license: isSet(object.license) ? globalThis.String(object.license) : "",
      publicationDate: isSet(object.publicationDate) ? DateMessage.fromJSON(object.publicationDate) : undefined,
    };
  },

  toJSON(message: Citation): unknown {
    const obj: any = {};
    if (message.startIndex !== 0) {
      obj.startIndex = Math.round(message.startIndex);
    }
    if (message.endIndex !== 0) {
      obj.endIndex = Math.round(message.endIndex);
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.license !== "") {
      obj.license = message.license;
    }
    if (message.publicationDate !== undefined) {
      obj.publicationDate = DateMessage.toJSON(message.publicationDate);
    }
    return obj;
  },

  create(base?: DeepPartial<Citation>): Citation {
    return Citation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Citation>): Citation {
    const message = createBaseCitation();
    message.startIndex = object.startIndex ?? 0;
    message.endIndex = object.endIndex ?? 0;
    message.uri = object.uri ?? "";
    message.title = object.title ?? "";
    message.license = object.license ?? "";
    message.publicationDate = (object.publicationDate !== undefined && object.publicationDate !== null)
      ? DateMessage.fromPartial(object.publicationDate)
      : undefined;
    return message;
  },
};

function createBaseCandidate(): Candidate {
  return {
    index: 0,
    content: undefined,
    avgLogprobs: 0,
    logprobsResult: undefined,
    finishReason: 0,
    safetyRatings: [],
    finishMessage: undefined,
    citationMetadata: undefined,
    groundingMetadata: undefined,
  };
}

export const Candidate: MessageFns<Candidate> = {
  encode(message: Candidate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.content !== undefined) {
      Content.encode(message.content, writer.uint32(18).fork()).join();
    }
    if (message.avgLogprobs !== 0) {
      writer.uint32(73).double(message.avgLogprobs);
    }
    if (message.logprobsResult !== undefined) {
      LogprobsResult.encode(message.logprobsResult, writer.uint32(82).fork()).join();
    }
    if (message.finishReason !== 0) {
      writer.uint32(24).int32(message.finishReason);
    }
    for (const v of message.safetyRatings) {
      SafetyRating.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.finishMessage !== undefined) {
      writer.uint32(42).string(message.finishMessage);
    }
    if (message.citationMetadata !== undefined) {
      CitationMetadata.encode(message.citationMetadata, writer.uint32(50).fork()).join();
    }
    if (message.groundingMetadata !== undefined) {
      GroundingMetadata.encode(message.groundingMetadata, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Candidate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCandidate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = Content.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 73) {
            break;
          }

          message.avgLogprobs = reader.double();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.logprobsResult = LogprobsResult.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.finishReason = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.safetyRatings.push(SafetyRating.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.finishMessage = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.citationMetadata = CitationMetadata.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.groundingMetadata = GroundingMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Candidate {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      content: isSet(object.content) ? Content.fromJSON(object.content) : undefined,
      avgLogprobs: isSet(object.avgLogprobs) ? globalThis.Number(object.avgLogprobs) : 0,
      logprobsResult: isSet(object.logprobsResult) ? LogprobsResult.fromJSON(object.logprobsResult) : undefined,
      finishReason: isSet(object.finishReason) ? candidate_FinishReasonFromJSON(object.finishReason) : 0,
      safetyRatings: globalThis.Array.isArray(object?.safetyRatings)
        ? object.safetyRatings.map((e: any) => SafetyRating.fromJSON(e))
        : [],
      finishMessage: isSet(object.finishMessage) ? globalThis.String(object.finishMessage) : undefined,
      citationMetadata: isSet(object.citationMetadata) ? CitationMetadata.fromJSON(object.citationMetadata) : undefined,
      groundingMetadata: isSet(object.groundingMetadata)
        ? GroundingMetadata.fromJSON(object.groundingMetadata)
        : undefined,
    };
  },

  toJSON(message: Candidate): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.content !== undefined) {
      obj.content = Content.toJSON(message.content);
    }
    if (message.avgLogprobs !== 0) {
      obj.avgLogprobs = message.avgLogprobs;
    }
    if (message.logprobsResult !== undefined) {
      obj.logprobsResult = LogprobsResult.toJSON(message.logprobsResult);
    }
    if (message.finishReason !== 0) {
      obj.finishReason = candidate_FinishReasonToJSON(message.finishReason);
    }
    if (message.safetyRatings?.length) {
      obj.safetyRatings = message.safetyRatings.map((e) => SafetyRating.toJSON(e));
    }
    if (message.finishMessage !== undefined) {
      obj.finishMessage = message.finishMessage;
    }
    if (message.citationMetadata !== undefined) {
      obj.citationMetadata = CitationMetadata.toJSON(message.citationMetadata);
    }
    if (message.groundingMetadata !== undefined) {
      obj.groundingMetadata = GroundingMetadata.toJSON(message.groundingMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<Candidate>): Candidate {
    return Candidate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Candidate>): Candidate {
    const message = createBaseCandidate();
    message.index = object.index ?? 0;
    message.content = (object.content !== undefined && object.content !== null)
      ? Content.fromPartial(object.content)
      : undefined;
    message.avgLogprobs = object.avgLogprobs ?? 0;
    message.logprobsResult = (object.logprobsResult !== undefined && object.logprobsResult !== null)
      ? LogprobsResult.fromPartial(object.logprobsResult)
      : undefined;
    message.finishReason = object.finishReason ?? 0;
    message.safetyRatings = object.safetyRatings?.map((e) => SafetyRating.fromPartial(e)) || [];
    message.finishMessage = object.finishMessage ?? undefined;
    message.citationMetadata = (object.citationMetadata !== undefined && object.citationMetadata !== null)
      ? CitationMetadata.fromPartial(object.citationMetadata)
      : undefined;
    message.groundingMetadata = (object.groundingMetadata !== undefined && object.groundingMetadata !== null)
      ? GroundingMetadata.fromPartial(object.groundingMetadata)
      : undefined;
    return message;
  },
};

function createBaseLogprobsResult(): LogprobsResult {
  return { topCandidates: [], chosenCandidates: [] };
}

export const LogprobsResult: MessageFns<LogprobsResult> = {
  encode(message: LogprobsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topCandidates) {
      LogprobsResult_TopCandidates.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.chosenCandidates) {
      LogprobsResult_Candidate.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogprobsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogprobsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topCandidates.push(LogprobsResult_TopCandidates.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chosenCandidates.push(LogprobsResult_Candidate.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogprobsResult {
    return {
      topCandidates: globalThis.Array.isArray(object?.topCandidates)
        ? object.topCandidates.map((e: any) => LogprobsResult_TopCandidates.fromJSON(e))
        : [],
      chosenCandidates: globalThis.Array.isArray(object?.chosenCandidates)
        ? object.chosenCandidates.map((e: any) => LogprobsResult_Candidate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LogprobsResult): unknown {
    const obj: any = {};
    if (message.topCandidates?.length) {
      obj.topCandidates = message.topCandidates.map((e) => LogprobsResult_TopCandidates.toJSON(e));
    }
    if (message.chosenCandidates?.length) {
      obj.chosenCandidates = message.chosenCandidates.map((e) => LogprobsResult_Candidate.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LogprobsResult>): LogprobsResult {
    return LogprobsResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogprobsResult>): LogprobsResult {
    const message = createBaseLogprobsResult();
    message.topCandidates = object.topCandidates?.map((e) => LogprobsResult_TopCandidates.fromPartial(e)) || [];
    message.chosenCandidates = object.chosenCandidates?.map((e) => LogprobsResult_Candidate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLogprobsResult_Candidate(): LogprobsResult_Candidate {
  return { token: undefined, tokenId: undefined, logProbability: undefined };
}

export const LogprobsResult_Candidate: MessageFns<LogprobsResult_Candidate> = {
  encode(message: LogprobsResult_Candidate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== undefined) {
      writer.uint32(10).string(message.token);
    }
    if (message.tokenId !== undefined) {
      writer.uint32(24).int32(message.tokenId);
    }
    if (message.logProbability !== undefined) {
      writer.uint32(21).float(message.logProbability);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogprobsResult_Candidate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogprobsResult_Candidate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tokenId = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.logProbability = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogprobsResult_Candidate {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : undefined,
      tokenId: isSet(object.tokenId) ? globalThis.Number(object.tokenId) : undefined,
      logProbability: isSet(object.logProbability) ? globalThis.Number(object.logProbability) : undefined,
    };
  },

  toJSON(message: LogprobsResult_Candidate): unknown {
    const obj: any = {};
    if (message.token !== undefined) {
      obj.token = message.token;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = Math.round(message.tokenId);
    }
    if (message.logProbability !== undefined) {
      obj.logProbability = message.logProbability;
    }
    return obj;
  },

  create(base?: DeepPartial<LogprobsResult_Candidate>): LogprobsResult_Candidate {
    return LogprobsResult_Candidate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogprobsResult_Candidate>): LogprobsResult_Candidate {
    const message = createBaseLogprobsResult_Candidate();
    message.token = object.token ?? undefined;
    message.tokenId = object.tokenId ?? undefined;
    message.logProbability = object.logProbability ?? undefined;
    return message;
  },
};

function createBaseLogprobsResult_TopCandidates(): LogprobsResult_TopCandidates {
  return { candidates: [] };
}

export const LogprobsResult_TopCandidates: MessageFns<LogprobsResult_TopCandidates> = {
  encode(message: LogprobsResult_TopCandidates, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.candidates) {
      LogprobsResult_Candidate.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogprobsResult_TopCandidates {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogprobsResult_TopCandidates();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.candidates.push(LogprobsResult_Candidate.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogprobsResult_TopCandidates {
    return {
      candidates: globalThis.Array.isArray(object?.candidates)
        ? object.candidates.map((e: any) => LogprobsResult_Candidate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LogprobsResult_TopCandidates): unknown {
    const obj: any = {};
    if (message.candidates?.length) {
      obj.candidates = message.candidates.map((e) => LogprobsResult_Candidate.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LogprobsResult_TopCandidates>): LogprobsResult_TopCandidates {
    return LogprobsResult_TopCandidates.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogprobsResult_TopCandidates>): LogprobsResult_TopCandidates {
    const message = createBaseLogprobsResult_TopCandidates();
    message.candidates = object.candidates?.map((e) => LogprobsResult_Candidate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSegment(): Segment {
  return { partIndex: 0, startIndex: 0, endIndex: 0, text: "" };
}

export const Segment: MessageFns<Segment> = {
  encode(message: Segment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.partIndex !== 0) {
      writer.uint32(8).int32(message.partIndex);
    }
    if (message.startIndex !== 0) {
      writer.uint32(16).int32(message.startIndex);
    }
    if (message.endIndex !== 0) {
      writer.uint32(24).int32(message.endIndex);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Segment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.partIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.startIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.endIndex = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Segment {
    return {
      partIndex: isSet(object.partIndex) ? globalThis.Number(object.partIndex) : 0,
      startIndex: isSet(object.startIndex) ? globalThis.Number(object.startIndex) : 0,
      endIndex: isSet(object.endIndex) ? globalThis.Number(object.endIndex) : 0,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: Segment): unknown {
    const obj: any = {};
    if (message.partIndex !== 0) {
      obj.partIndex = Math.round(message.partIndex);
    }
    if (message.startIndex !== 0) {
      obj.startIndex = Math.round(message.startIndex);
    }
    if (message.endIndex !== 0) {
      obj.endIndex = Math.round(message.endIndex);
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<Segment>): Segment {
    return Segment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Segment>): Segment {
    const message = createBaseSegment();
    message.partIndex = object.partIndex ?? 0;
    message.startIndex = object.startIndex ?? 0;
    message.endIndex = object.endIndex ?? 0;
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseGroundingChunk(): GroundingChunk {
  return { web: undefined, retrievedContext: undefined };
}

export const GroundingChunk: MessageFns<GroundingChunk> = {
  encode(message: GroundingChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.web !== undefined) {
      GroundingChunk_Web.encode(message.web, writer.uint32(10).fork()).join();
    }
    if (message.retrievedContext !== undefined) {
      GroundingChunk_RetrievedContext.encode(message.retrievedContext, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroundingChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroundingChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.web = GroundingChunk_Web.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.retrievedContext = GroundingChunk_RetrievedContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroundingChunk {
    return {
      web: isSet(object.web) ? GroundingChunk_Web.fromJSON(object.web) : undefined,
      retrievedContext: isSet(object.retrievedContext)
        ? GroundingChunk_RetrievedContext.fromJSON(object.retrievedContext)
        : undefined,
    };
  },

  toJSON(message: GroundingChunk): unknown {
    const obj: any = {};
    if (message.web !== undefined) {
      obj.web = GroundingChunk_Web.toJSON(message.web);
    }
    if (message.retrievedContext !== undefined) {
      obj.retrievedContext = GroundingChunk_RetrievedContext.toJSON(message.retrievedContext);
    }
    return obj;
  },

  create(base?: DeepPartial<GroundingChunk>): GroundingChunk {
    return GroundingChunk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroundingChunk>): GroundingChunk {
    const message = createBaseGroundingChunk();
    message.web = (object.web !== undefined && object.web !== null)
      ? GroundingChunk_Web.fromPartial(object.web)
      : undefined;
    message.retrievedContext = (object.retrievedContext !== undefined && object.retrievedContext !== null)
      ? GroundingChunk_RetrievedContext.fromPartial(object.retrievedContext)
      : undefined;
    return message;
  },
};

function createBaseGroundingChunk_Web(): GroundingChunk_Web {
  return { uri: undefined, title: undefined };
}

export const GroundingChunk_Web: MessageFns<GroundingChunk_Web> = {
  encode(message: GroundingChunk_Web, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== undefined) {
      writer.uint32(10).string(message.uri);
    }
    if (message.title !== undefined) {
      writer.uint32(18).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroundingChunk_Web {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroundingChunk_Web();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroundingChunk_Web {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
    };
  },

  toJSON(message: GroundingChunk_Web): unknown {
    const obj: any = {};
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    return obj;
  },

  create(base?: DeepPartial<GroundingChunk_Web>): GroundingChunk_Web {
    return GroundingChunk_Web.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroundingChunk_Web>): GroundingChunk_Web {
    const message = createBaseGroundingChunk_Web();
    message.uri = object.uri ?? undefined;
    message.title = object.title ?? undefined;
    return message;
  },
};

function createBaseGroundingChunk_RetrievedContext(): GroundingChunk_RetrievedContext {
  return { uri: undefined, title: undefined };
}

export const GroundingChunk_RetrievedContext: MessageFns<GroundingChunk_RetrievedContext> = {
  encode(message: GroundingChunk_RetrievedContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== undefined) {
      writer.uint32(10).string(message.uri);
    }
    if (message.title !== undefined) {
      writer.uint32(18).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroundingChunk_RetrievedContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroundingChunk_RetrievedContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroundingChunk_RetrievedContext {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
    };
  },

  toJSON(message: GroundingChunk_RetrievedContext): unknown {
    const obj: any = {};
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    return obj;
  },

  create(base?: DeepPartial<GroundingChunk_RetrievedContext>): GroundingChunk_RetrievedContext {
    return GroundingChunk_RetrievedContext.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroundingChunk_RetrievedContext>): GroundingChunk_RetrievedContext {
    const message = createBaseGroundingChunk_RetrievedContext();
    message.uri = object.uri ?? undefined;
    message.title = object.title ?? undefined;
    return message;
  },
};

function createBaseGroundingSupport(): GroundingSupport {
  return { segment: undefined, groundingChunkIndices: [], confidenceScores: [] };
}

export const GroundingSupport: MessageFns<GroundingSupport> = {
  encode(message: GroundingSupport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.segment !== undefined) {
      Segment.encode(message.segment, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.groundingChunkIndices) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.confidenceScores) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroundingSupport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroundingSupport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.segment = Segment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag === 16) {
            message.groundingChunkIndices.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.groundingChunkIndices.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag === 29) {
            message.confidenceScores.push(reader.float());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.confidenceScores.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroundingSupport {
    return {
      segment: isSet(object.segment) ? Segment.fromJSON(object.segment) : undefined,
      groundingChunkIndices: globalThis.Array.isArray(object?.groundingChunkIndices)
        ? object.groundingChunkIndices.map((e: any) => globalThis.Number(e))
        : [],
      confidenceScores: globalThis.Array.isArray(object?.confidenceScores)
        ? object.confidenceScores.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: GroundingSupport): unknown {
    const obj: any = {};
    if (message.segment !== undefined) {
      obj.segment = Segment.toJSON(message.segment);
    }
    if (message.groundingChunkIndices?.length) {
      obj.groundingChunkIndices = message.groundingChunkIndices.map((e) => Math.round(e));
    }
    if (message.confidenceScores?.length) {
      obj.confidenceScores = message.confidenceScores;
    }
    return obj;
  },

  create(base?: DeepPartial<GroundingSupport>): GroundingSupport {
    return GroundingSupport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroundingSupport>): GroundingSupport {
    const message = createBaseGroundingSupport();
    message.segment = (object.segment !== undefined && object.segment !== null)
      ? Segment.fromPartial(object.segment)
      : undefined;
    message.groundingChunkIndices = object.groundingChunkIndices?.map((e) => e) || [];
    message.confidenceScores = object.confidenceScores?.map((e) => e) || [];
    return message;
  },
};

function createBaseGroundingMetadata(): GroundingMetadata {
  return {
    webSearchQueries: [],
    searchEntryPoint: undefined,
    retrievalQueries: [],
    groundingChunks: [],
    groundingSupports: [],
  };
}

export const GroundingMetadata: MessageFns<GroundingMetadata> = {
  encode(message: GroundingMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.webSearchQueries) {
      writer.uint32(10).string(v!);
    }
    if (message.searchEntryPoint !== undefined) {
      SearchEntryPoint.encode(message.searchEntryPoint, writer.uint32(34).fork()).join();
    }
    for (const v of message.retrievalQueries) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.groundingChunks) {
      GroundingChunk.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.groundingSupports) {
      GroundingSupport.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroundingMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroundingMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.webSearchQueries.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.searchEntryPoint = SearchEntryPoint.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.retrievalQueries.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.groundingChunks.push(GroundingChunk.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.groundingSupports.push(GroundingSupport.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroundingMetadata {
    return {
      webSearchQueries: globalThis.Array.isArray(object?.webSearchQueries)
        ? object.webSearchQueries.map((e: any) => globalThis.String(e))
        : [],
      searchEntryPoint: isSet(object.searchEntryPoint) ? SearchEntryPoint.fromJSON(object.searchEntryPoint) : undefined,
      retrievalQueries: globalThis.Array.isArray(object?.retrievalQueries)
        ? object.retrievalQueries.map((e: any) => globalThis.String(e))
        : [],
      groundingChunks: globalThis.Array.isArray(object?.groundingChunks)
        ? object.groundingChunks.map((e: any) => GroundingChunk.fromJSON(e))
        : [],
      groundingSupports: globalThis.Array.isArray(object?.groundingSupports)
        ? object.groundingSupports.map((e: any) => GroundingSupport.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GroundingMetadata): unknown {
    const obj: any = {};
    if (message.webSearchQueries?.length) {
      obj.webSearchQueries = message.webSearchQueries;
    }
    if (message.searchEntryPoint !== undefined) {
      obj.searchEntryPoint = SearchEntryPoint.toJSON(message.searchEntryPoint);
    }
    if (message.retrievalQueries?.length) {
      obj.retrievalQueries = message.retrievalQueries;
    }
    if (message.groundingChunks?.length) {
      obj.groundingChunks = message.groundingChunks.map((e) => GroundingChunk.toJSON(e));
    }
    if (message.groundingSupports?.length) {
      obj.groundingSupports = message.groundingSupports.map((e) => GroundingSupport.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GroundingMetadata>): GroundingMetadata {
    return GroundingMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroundingMetadata>): GroundingMetadata {
    const message = createBaseGroundingMetadata();
    message.webSearchQueries = object.webSearchQueries?.map((e) => e) || [];
    message.searchEntryPoint = (object.searchEntryPoint !== undefined && object.searchEntryPoint !== null)
      ? SearchEntryPoint.fromPartial(object.searchEntryPoint)
      : undefined;
    message.retrievalQueries = object.retrievalQueries?.map((e) => e) || [];
    message.groundingChunks = object.groundingChunks?.map((e) => GroundingChunk.fromPartial(e)) || [];
    message.groundingSupports = object.groundingSupports?.map((e) => GroundingSupport.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchEntryPoint(): SearchEntryPoint {
  return { renderedContent: "", sdkBlob: Buffer.alloc(0) };
}

export const SearchEntryPoint: MessageFns<SearchEntryPoint> = {
  encode(message: SearchEntryPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.renderedContent !== "") {
      writer.uint32(10).string(message.renderedContent);
    }
    if (message.sdkBlob.length !== 0) {
      writer.uint32(18).bytes(message.sdkBlob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchEntryPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchEntryPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.renderedContent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sdkBlob = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchEntryPoint {
    return {
      renderedContent: isSet(object.renderedContent) ? globalThis.String(object.renderedContent) : "",
      sdkBlob: isSet(object.sdkBlob) ? Buffer.from(bytesFromBase64(object.sdkBlob)) : Buffer.alloc(0),
    };
  },

  toJSON(message: SearchEntryPoint): unknown {
    const obj: any = {};
    if (message.renderedContent !== "") {
      obj.renderedContent = message.renderedContent;
    }
    if (message.sdkBlob.length !== 0) {
      obj.sdkBlob = base64FromBytes(message.sdkBlob);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchEntryPoint>): SearchEntryPoint {
    return SearchEntryPoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchEntryPoint>): SearchEntryPoint {
    const message = createBaseSearchEntryPoint();
    message.renderedContent = object.renderedContent ?? "";
    message.sdkBlob = object.sdkBlob ?? Buffer.alloc(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
