// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1beta1/schema/trainingjob/definition/automl_tables.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ExportEvaluatedDataItemsConfig } from "./export_evaluated_data_items_config.js";

export const protobufPackage = "google.cloud.aiplatform.v1beta1.schema.trainingjob.definition";

/** A TrainingJob that trains and uploads an AutoML Tables Model. */
export interface AutoMlTables {
  /** The input parameters of this TrainingJob. */
  inputs:
    | AutoMlTablesInputs
    | undefined;
  /** The metadata information. */
  metadata: AutoMlTablesMetadata | undefined;
}

export interface AutoMlTablesInputs {
  /**
   * Required when optimization_objective is "maximize-precision-at-recall".
   * Must be between 0 and 1, inclusive.
   */
  optimizationObjectiveRecallValue?:
    | number
    | undefined;
  /**
   * Required when optimization_objective is "maximize-recall-at-precision".
   * Must be between 0 and 1, inclusive.
   */
  optimizationObjectivePrecisionValue?:
    | number
    | undefined;
  /**
   * The type of prediction the Model is to produce.
   *   "classification" - Predict one out of multiple target values is
   *                      picked for each row.
   *   "regression" - Predict a value based on its relation to other values.
   *                  This type is available only to columns that contain
   *                  semantically numeric values, i.e. integers or floating
   *                  point number, even if stored as e.g. strings.
   */
  predictionType: string;
  /** The column name of the target column that the model is to predict. */
  targetColumn: string;
  /**
   * Each transformation will apply transform function to given input column.
   * And the result will be used for training.
   * When creating transformation for BigQuery Struct column, the column should
   * be flattened using "." as the delimiter.
   */
  transformations: AutoMlTablesInputs_Transformation[];
  /**
   * Objective function the model is optimizing towards. The training process
   * creates a model that maximizes/minimizes the value of the objective
   * function over the validation set.
   *
   * The supported optimization objectives depend on the prediction type.
   * If the field is not set, a default objective function is used.
   *
   * classification (binary):
   *   "maximize-au-roc" (default) - Maximize the area under the receiver
   *                                 operating characteristic (ROC) curve.
   *   "minimize-log-loss" - Minimize log loss.
   *   "maximize-au-prc" - Maximize the area under the precision-recall curve.
   *   "maximize-precision-at-recall" - Maximize precision for a specified
   *                                   recall value.
   *   "maximize-recall-at-precision" - Maximize recall for a specified
   *                                    precision value.
   *
   * classification (multi-class):
   *   "minimize-log-loss" (default) - Minimize log loss.
   *
   * regression:
   *   "minimize-rmse" (default) - Minimize root-mean-squared error (RMSE).
   *   "minimize-mae" - Minimize mean-absolute error (MAE).
   *   "minimize-rmsle" - Minimize root-mean-squared log error (RMSLE).
   */
  optimizationObjective: string;
  /**
   * Required. The train budget of creating this model, expressed in milli node
   * hours i.e. 1,000 value in this field means 1 node hour.
   *
   * The training cost of the model will not exceed this budget. The final cost
   * will be attempted to be close to the budget, though may end up being (even)
   * noticeably smaller - at the backend's discretion. This especially may
   * happen when further model training ceases to provide any improvements.
   *
   * If the budget is set to a value known to be insufficient to train a
   * model for the given dataset, the training won't be attempted and
   * will error.
   *
   * The train budget must be between 1,000 and 72,000 milli node hours,
   * inclusive.
   */
  trainBudgetMilliNodeHours: Long;
  /**
   * Use the entire training budget. This disables the early stopping feature.
   * By default, the early stopping feature is enabled, which means that AutoML
   * Tables might stop training before the entire training budget has been used.
   */
  disableEarlyStopping: boolean;
  /**
   * Column name that should be used as the weight column.
   * Higher values in this column give more importance to the row
   * during model training. The column must have numeric values between 0 and
   * 10000 inclusively; 0 means the row is ignored for training. If weight
   * column field is not set, then all rows are assumed to have equal weight
   * of 1.
   */
  weightColumnName: string;
  /**
   * Configuration for exporting test set predictions to a BigQuery table. If
   * this configuration is absent, then the export is not performed.
   */
  exportEvaluatedDataItemsConfig:
    | ExportEvaluatedDataItemsConfig
    | undefined;
  /** Additional experiment flags for the Tables training pipeline. */
  additionalExperiments: string[];
}

export interface AutoMlTablesInputs_Transformation {
  auto?: AutoMlTablesInputs_Transformation_AutoTransformation | undefined;
  numeric?: AutoMlTablesInputs_Transformation_NumericTransformation | undefined;
  categorical?: AutoMlTablesInputs_Transformation_CategoricalTransformation | undefined;
  timestamp?: AutoMlTablesInputs_Transformation_TimestampTransformation | undefined;
  text?: AutoMlTablesInputs_Transformation_TextTransformation | undefined;
  repeatedNumeric?: AutoMlTablesInputs_Transformation_NumericArrayTransformation | undefined;
  repeatedCategorical?: AutoMlTablesInputs_Transformation_CategoricalArrayTransformation | undefined;
  repeatedText?: AutoMlTablesInputs_Transformation_TextArrayTransformation | undefined;
}

/**
 * Training pipeline will infer the proper transformation based on the
 * statistic of dataset.
 */
export interface AutoMlTablesInputs_Transformation_AutoTransformation {
  columnName: string;
}

/**
 * Training pipeline will perform following transformation functions.
 * *  The value converted to float32.
 * *  The z_score of the value.
 * *  log(value+1) when the value is greater than or equal to 0. Otherwise,
 *    this transformation is not applied and the value is considered a
 *    missing value.
 * *  z_score of log(value+1) when the value is greater than or equal to 0.
 *    Otherwise, this transformation is not applied and the value is
 *    considered a missing value.
 * *  A boolean value that indicates whether the value is valid.
 */
export interface AutoMlTablesInputs_Transformation_NumericTransformation {
  columnName: string;
  /**
   * If invalid values is allowed, the training pipeline will create a
   * boolean feature that indicated whether the value is valid.
   * Otherwise, the training pipeline will discard the input row from
   * trainining data.
   */
  invalidValuesAllowed: boolean;
}

/**
 * Training pipeline will perform following transformation functions.
 * *  The categorical string as is--no change to case, punctuation,
 * spelling,
 *    tense, and so on.
 * *  Convert the category name to a dictionary lookup index and generate an
 *    embedding for each index.
 * *  Categories that appear less than 5 times in the training dataset are
 *    treated as the "unknown" category. The "unknown" category gets its own
 *    special lookup index and resulting embedding.
 */
export interface AutoMlTablesInputs_Transformation_CategoricalTransformation {
  columnName: string;
}

/**
 * Training pipeline will perform following transformation functions.
 * *  Apply the transformation functions for Numerical columns.
 * *  Determine the year, month, day,and weekday. Treat each value from the
 * *  timestamp as a Categorical column.
 * *  Invalid numerical values (for example, values that fall outside of a
 *    typical timestamp range, or are extreme values) receive no special
 *    treatment and are not removed.
 */
export interface AutoMlTablesInputs_Transformation_TimestampTransformation {
  columnName: string;
  /**
   * The format in which that time field is expressed. The time_format must
   * either be one of:
   * * `unix-seconds`
   * * `unix-milliseconds`
   * * `unix-microseconds`
   * * `unix-nanoseconds`
   * (for respectively number of seconds, milliseconds, microseconds and
   * nanoseconds since start of the Unix epoch);
   * or be written in `strftime` syntax. If time_format is not set, then the
   * default format is RFC 3339 `date-time` format, where
   * `time-offset` = `"Z"` (e.g. 1985-04-12T23:20:50.52Z)
   */
  timeFormat: string;
  /**
   * If invalid values is allowed, the training pipeline will create a
   * boolean feature that indicated whether the value is valid.
   * Otherwise, the training pipeline will discard the input row from
   * trainining data.
   */
  invalidValuesAllowed: boolean;
}

/**
 * Training pipeline will perform following transformation functions.
 * *  The text as is--no change to case, punctuation, spelling, tense, and
 * so
 *    on.
 * *  Tokenize text to words. Convert each words to a dictionary lookup
 * index
 *    and generate an embedding for each index. Combine the embedding of all
 *    elements into a single embedding using the mean.
 * *  Tokenization is based on unicode script boundaries.
 * *  Missing values get their own lookup index and resulting embedding.
 * *  Stop-words receive no special treatment and are not removed.
 */
export interface AutoMlTablesInputs_Transformation_TextTransformation {
  columnName: string;
}

/**
 * Treats the column as numerical array and performs following
 * transformation functions.
 * *  All transformations for Numerical types applied to the average of the
 *    all elements.
 * *  The average of empty arrays is treated as zero.
 */
export interface AutoMlTablesInputs_Transformation_NumericArrayTransformation {
  columnName: string;
  /**
   * If invalid values is allowed, the training pipeline will create a
   * boolean feature that indicated whether the value is valid.
   * Otherwise, the training pipeline will discard the input row from
   * trainining data.
   */
  invalidValuesAllowed: boolean;
}

/**
 * Treats the column as categorical array and performs following
 * transformation functions.
 * *  For each element in the array, convert the category name to a
 * dictionary
 *    lookup index and generate an embedding for each index.
 *    Combine the embedding of all elements into a single embedding using
 *    the mean.
 * *  Empty arrays treated as an embedding of zeroes.
 */
export interface AutoMlTablesInputs_Transformation_CategoricalArrayTransformation {
  columnName: string;
}

/**
 * Treats the column as text array and performs following transformation
 * functions.
 * *  Concatenate all text values in the array into a single text value
 * using
 *    a space (" ") as a delimiter, and then treat the result as a single
 *    text value. Apply the transformations for Text columns.
 * *  Empty arrays treated as an empty text.
 */
export interface AutoMlTablesInputs_Transformation_TextArrayTransformation {
  columnName: string;
}

/** Model metadata specific to AutoML Tables. */
export interface AutoMlTablesMetadata {
  /**
   * Output only. The actual training cost of the model, expressed in milli
   * node hours, i.e. 1,000 value in this field means 1 node hour. Guaranteed
   * to not exceed the train budget.
   */
  trainCostMilliNodeHours: Long;
}

function createBaseAutoMlTables(): AutoMlTables {
  return { inputs: undefined, metadata: undefined };
}

export const AutoMlTables: MessageFns<AutoMlTables> = {
  encode(message: AutoMlTables, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputs !== undefined) {
      AutoMlTablesInputs.encode(message.inputs, writer.uint32(10).fork()).join();
    }
    if (message.metadata !== undefined) {
      AutoMlTablesMetadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlTables {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlTables();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputs = AutoMlTablesInputs.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metadata = AutoMlTablesMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlTables {
    return {
      inputs: isSet(object.inputs) ? AutoMlTablesInputs.fromJSON(object.inputs) : undefined,
      metadata: isSet(object.metadata) ? AutoMlTablesMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: AutoMlTables): unknown {
    const obj: any = {};
    if (message.inputs !== undefined) {
      obj.inputs = AutoMlTablesInputs.toJSON(message.inputs);
    }
    if (message.metadata !== undefined) {
      obj.metadata = AutoMlTablesMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<AutoMlTables>): AutoMlTables {
    return AutoMlTables.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoMlTables>): AutoMlTables {
    const message = createBaseAutoMlTables();
    message.inputs = (object.inputs !== undefined && object.inputs !== null)
      ? AutoMlTablesInputs.fromPartial(object.inputs)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? AutoMlTablesMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseAutoMlTablesInputs(): AutoMlTablesInputs {
  return {
    optimizationObjectiveRecallValue: undefined,
    optimizationObjectivePrecisionValue: undefined,
    predictionType: "",
    targetColumn: "",
    transformations: [],
    optimizationObjective: "",
    trainBudgetMilliNodeHours: Long.ZERO,
    disableEarlyStopping: false,
    weightColumnName: "",
    exportEvaluatedDataItemsConfig: undefined,
    additionalExperiments: [],
  };
}

export const AutoMlTablesInputs: MessageFns<AutoMlTablesInputs> = {
  encode(message: AutoMlTablesInputs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.optimizationObjectiveRecallValue !== undefined) {
      writer.uint32(45).float(message.optimizationObjectiveRecallValue);
    }
    if (message.optimizationObjectivePrecisionValue !== undefined) {
      writer.uint32(53).float(message.optimizationObjectivePrecisionValue);
    }
    if (message.predictionType !== "") {
      writer.uint32(10).string(message.predictionType);
    }
    if (message.targetColumn !== "") {
      writer.uint32(18).string(message.targetColumn);
    }
    for (const v of message.transformations) {
      AutoMlTablesInputs_Transformation.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.optimizationObjective !== "") {
      writer.uint32(34).string(message.optimizationObjective);
    }
    if (!message.trainBudgetMilliNodeHours.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.trainBudgetMilliNodeHours.toString());
    }
    if (message.disableEarlyStopping !== false) {
      writer.uint32(64).bool(message.disableEarlyStopping);
    }
    if (message.weightColumnName !== "") {
      writer.uint32(74).string(message.weightColumnName);
    }
    if (message.exportEvaluatedDataItemsConfig !== undefined) {
      ExportEvaluatedDataItemsConfig.encode(message.exportEvaluatedDataItemsConfig, writer.uint32(82).fork()).join();
    }
    for (const v of message.additionalExperiments) {
      writer.uint32(90).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlTablesInputs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlTablesInputs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 45) {
            break;
          }

          message.optimizationObjectiveRecallValue = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.optimizationObjectivePrecisionValue = reader.float();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.predictionType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetColumn = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transformations.push(AutoMlTablesInputs_Transformation.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.optimizationObjective = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.trainBudgetMilliNodeHours = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.disableEarlyStopping = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.weightColumnName = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.exportEvaluatedDataItemsConfig = ExportEvaluatedDataItemsConfig.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.additionalExperiments.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlTablesInputs {
    return {
      optimizationObjectiveRecallValue: isSet(object.optimizationObjectiveRecallValue)
        ? globalThis.Number(object.optimizationObjectiveRecallValue)
        : undefined,
      optimizationObjectivePrecisionValue: isSet(object.optimizationObjectivePrecisionValue)
        ? globalThis.Number(object.optimizationObjectivePrecisionValue)
        : undefined,
      predictionType: isSet(object.predictionType) ? globalThis.String(object.predictionType) : "",
      targetColumn: isSet(object.targetColumn) ? globalThis.String(object.targetColumn) : "",
      transformations: globalThis.Array.isArray(object?.transformations)
        ? object.transformations.map((e: any) => AutoMlTablesInputs_Transformation.fromJSON(e))
        : [],
      optimizationObjective: isSet(object.optimizationObjective) ? globalThis.String(object.optimizationObjective) : "",
      trainBudgetMilliNodeHours: isSet(object.trainBudgetMilliNodeHours)
        ? Long.fromValue(object.trainBudgetMilliNodeHours)
        : Long.ZERO,
      disableEarlyStopping: isSet(object.disableEarlyStopping)
        ? globalThis.Boolean(object.disableEarlyStopping)
        : false,
      weightColumnName: isSet(object.weightColumnName) ? globalThis.String(object.weightColumnName) : "",
      exportEvaluatedDataItemsConfig: isSet(object.exportEvaluatedDataItemsConfig)
        ? ExportEvaluatedDataItemsConfig.fromJSON(object.exportEvaluatedDataItemsConfig)
        : undefined,
      additionalExperiments: globalThis.Array.isArray(object?.additionalExperiments)
        ? object.additionalExperiments.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AutoMlTablesInputs): unknown {
    const obj: any = {};
    if (message.optimizationObjectiveRecallValue !== undefined) {
      obj.optimizationObjectiveRecallValue = message.optimizationObjectiveRecallValue;
    }
    if (message.optimizationObjectivePrecisionValue !== undefined) {
      obj.optimizationObjectivePrecisionValue = message.optimizationObjectivePrecisionValue;
    }
    if (message.predictionType !== "") {
      obj.predictionType = message.predictionType;
    }
    if (message.targetColumn !== "") {
      obj.targetColumn = message.targetColumn;
    }
    if (message.transformations?.length) {
      obj.transformations = message.transformations.map((e) => AutoMlTablesInputs_Transformation.toJSON(e));
    }
    if (message.optimizationObjective !== "") {
      obj.optimizationObjective = message.optimizationObjective;
    }
    if (!message.trainBudgetMilliNodeHours.equals(Long.ZERO)) {
      obj.trainBudgetMilliNodeHours = (message.trainBudgetMilliNodeHours || Long.ZERO).toString();
    }
    if (message.disableEarlyStopping !== false) {
      obj.disableEarlyStopping = message.disableEarlyStopping;
    }
    if (message.weightColumnName !== "") {
      obj.weightColumnName = message.weightColumnName;
    }
    if (message.exportEvaluatedDataItemsConfig !== undefined) {
      obj.exportEvaluatedDataItemsConfig = ExportEvaluatedDataItemsConfig.toJSON(
        message.exportEvaluatedDataItemsConfig,
      );
    }
    if (message.additionalExperiments?.length) {
      obj.additionalExperiments = message.additionalExperiments;
    }
    return obj;
  },

  create(base?: DeepPartial<AutoMlTablesInputs>): AutoMlTablesInputs {
    return AutoMlTablesInputs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoMlTablesInputs>): AutoMlTablesInputs {
    const message = createBaseAutoMlTablesInputs();
    message.optimizationObjectiveRecallValue = object.optimizationObjectiveRecallValue ?? undefined;
    message.optimizationObjectivePrecisionValue = object.optimizationObjectivePrecisionValue ?? undefined;
    message.predictionType = object.predictionType ?? "";
    message.targetColumn = object.targetColumn ?? "";
    message.transformations = object.transformations?.map((e) => AutoMlTablesInputs_Transformation.fromPartial(e)) ||
      [];
    message.optimizationObjective = object.optimizationObjective ?? "";
    message.trainBudgetMilliNodeHours =
      (object.trainBudgetMilliNodeHours !== undefined && object.trainBudgetMilliNodeHours !== null)
        ? Long.fromValue(object.trainBudgetMilliNodeHours)
        : Long.ZERO;
    message.disableEarlyStopping = object.disableEarlyStopping ?? false;
    message.weightColumnName = object.weightColumnName ?? "";
    message.exportEvaluatedDataItemsConfig =
      (object.exportEvaluatedDataItemsConfig !== undefined && object.exportEvaluatedDataItemsConfig !== null)
        ? ExportEvaluatedDataItemsConfig.fromPartial(object.exportEvaluatedDataItemsConfig)
        : undefined;
    message.additionalExperiments = object.additionalExperiments?.map((e) => e) || [];
    return message;
  },
};

function createBaseAutoMlTablesInputs_Transformation(): AutoMlTablesInputs_Transformation {
  return {
    auto: undefined,
    numeric: undefined,
    categorical: undefined,
    timestamp: undefined,
    text: undefined,
    repeatedNumeric: undefined,
    repeatedCategorical: undefined,
    repeatedText: undefined,
  };
}

export const AutoMlTablesInputs_Transformation: MessageFns<AutoMlTablesInputs_Transformation> = {
  encode(message: AutoMlTablesInputs_Transformation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.auto !== undefined) {
      AutoMlTablesInputs_Transformation_AutoTransformation.encode(message.auto, writer.uint32(10).fork()).join();
    }
    if (message.numeric !== undefined) {
      AutoMlTablesInputs_Transformation_NumericTransformation.encode(message.numeric, writer.uint32(18).fork()).join();
    }
    if (message.categorical !== undefined) {
      AutoMlTablesInputs_Transformation_CategoricalTransformation.encode(message.categorical, writer.uint32(26).fork())
        .join();
    }
    if (message.timestamp !== undefined) {
      AutoMlTablesInputs_Transformation_TimestampTransformation.encode(message.timestamp, writer.uint32(34).fork())
        .join();
    }
    if (message.text !== undefined) {
      AutoMlTablesInputs_Transformation_TextTransformation.encode(message.text, writer.uint32(42).fork()).join();
    }
    if (message.repeatedNumeric !== undefined) {
      AutoMlTablesInputs_Transformation_NumericArrayTransformation.encode(
        message.repeatedNumeric,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.repeatedCategorical !== undefined) {
      AutoMlTablesInputs_Transformation_CategoricalArrayTransformation.encode(
        message.repeatedCategorical,
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.repeatedText !== undefined) {
      AutoMlTablesInputs_Transformation_TextArrayTransformation.encode(message.repeatedText, writer.uint32(66).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlTablesInputs_Transformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlTablesInputs_Transformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.auto = AutoMlTablesInputs_Transformation_AutoTransformation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.numeric = AutoMlTablesInputs_Transformation_NumericTransformation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.categorical = AutoMlTablesInputs_Transformation_CategoricalTransformation.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timestamp = AutoMlTablesInputs_Transformation_TimestampTransformation.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.text = AutoMlTablesInputs_Transformation_TextTransformation.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.repeatedNumeric = AutoMlTablesInputs_Transformation_NumericArrayTransformation.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.repeatedCategorical = AutoMlTablesInputs_Transformation_CategoricalArrayTransformation.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.repeatedText = AutoMlTablesInputs_Transformation_TextArrayTransformation.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlTablesInputs_Transformation {
    return {
      auto: isSet(object.auto) ? AutoMlTablesInputs_Transformation_AutoTransformation.fromJSON(object.auto) : undefined,
      numeric: isSet(object.numeric)
        ? AutoMlTablesInputs_Transformation_NumericTransformation.fromJSON(object.numeric)
        : undefined,
      categorical: isSet(object.categorical)
        ? AutoMlTablesInputs_Transformation_CategoricalTransformation.fromJSON(object.categorical)
        : undefined,
      timestamp: isSet(object.timestamp)
        ? AutoMlTablesInputs_Transformation_TimestampTransformation.fromJSON(object.timestamp)
        : undefined,
      text: isSet(object.text) ? AutoMlTablesInputs_Transformation_TextTransformation.fromJSON(object.text) : undefined,
      repeatedNumeric: isSet(object.repeatedNumeric)
        ? AutoMlTablesInputs_Transformation_NumericArrayTransformation.fromJSON(object.repeatedNumeric)
        : undefined,
      repeatedCategorical: isSet(object.repeatedCategorical)
        ? AutoMlTablesInputs_Transformation_CategoricalArrayTransformation.fromJSON(object.repeatedCategorical)
        : undefined,
      repeatedText: isSet(object.repeatedText)
        ? AutoMlTablesInputs_Transformation_TextArrayTransformation.fromJSON(object.repeatedText)
        : undefined,
    };
  },

  toJSON(message: AutoMlTablesInputs_Transformation): unknown {
    const obj: any = {};
    if (message.auto !== undefined) {
      obj.auto = AutoMlTablesInputs_Transformation_AutoTransformation.toJSON(message.auto);
    }
    if (message.numeric !== undefined) {
      obj.numeric = AutoMlTablesInputs_Transformation_NumericTransformation.toJSON(message.numeric);
    }
    if (message.categorical !== undefined) {
      obj.categorical = AutoMlTablesInputs_Transformation_CategoricalTransformation.toJSON(message.categorical);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = AutoMlTablesInputs_Transformation_TimestampTransformation.toJSON(message.timestamp);
    }
    if (message.text !== undefined) {
      obj.text = AutoMlTablesInputs_Transformation_TextTransformation.toJSON(message.text);
    }
    if (message.repeatedNumeric !== undefined) {
      obj.repeatedNumeric = AutoMlTablesInputs_Transformation_NumericArrayTransformation.toJSON(
        message.repeatedNumeric,
      );
    }
    if (message.repeatedCategorical !== undefined) {
      obj.repeatedCategorical = AutoMlTablesInputs_Transformation_CategoricalArrayTransformation.toJSON(
        message.repeatedCategorical,
      );
    }
    if (message.repeatedText !== undefined) {
      obj.repeatedText = AutoMlTablesInputs_Transformation_TextArrayTransformation.toJSON(message.repeatedText);
    }
    return obj;
  },

  create(base?: DeepPartial<AutoMlTablesInputs_Transformation>): AutoMlTablesInputs_Transformation {
    return AutoMlTablesInputs_Transformation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoMlTablesInputs_Transformation>): AutoMlTablesInputs_Transformation {
    const message = createBaseAutoMlTablesInputs_Transformation();
    message.auto = (object.auto !== undefined && object.auto !== null)
      ? AutoMlTablesInputs_Transformation_AutoTransformation.fromPartial(object.auto)
      : undefined;
    message.numeric = (object.numeric !== undefined && object.numeric !== null)
      ? AutoMlTablesInputs_Transformation_NumericTransformation.fromPartial(object.numeric)
      : undefined;
    message.categorical = (object.categorical !== undefined && object.categorical !== null)
      ? AutoMlTablesInputs_Transformation_CategoricalTransformation.fromPartial(object.categorical)
      : undefined;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? AutoMlTablesInputs_Transformation_TimestampTransformation.fromPartial(object.timestamp)
      : undefined;
    message.text = (object.text !== undefined && object.text !== null)
      ? AutoMlTablesInputs_Transformation_TextTransformation.fromPartial(object.text)
      : undefined;
    message.repeatedNumeric = (object.repeatedNumeric !== undefined && object.repeatedNumeric !== null)
      ? AutoMlTablesInputs_Transformation_NumericArrayTransformation.fromPartial(object.repeatedNumeric)
      : undefined;
    message.repeatedCategorical = (object.repeatedCategorical !== undefined && object.repeatedCategorical !== null)
      ? AutoMlTablesInputs_Transformation_CategoricalArrayTransformation.fromPartial(object.repeatedCategorical)
      : undefined;
    message.repeatedText = (object.repeatedText !== undefined && object.repeatedText !== null)
      ? AutoMlTablesInputs_Transformation_TextArrayTransformation.fromPartial(object.repeatedText)
      : undefined;
    return message;
  },
};

function createBaseAutoMlTablesInputs_Transformation_AutoTransformation(): AutoMlTablesInputs_Transformation_AutoTransformation {
  return { columnName: "" };
}

export const AutoMlTablesInputs_Transformation_AutoTransformation: MessageFns<
  AutoMlTablesInputs_Transformation_AutoTransformation
> = {
  encode(
    message: AutoMlTablesInputs_Transformation_AutoTransformation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlTablesInputs_Transformation_AutoTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlTablesInputs_Transformation_AutoTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlTablesInputs_Transformation_AutoTransformation {
    return { columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "" };
  },

  toJSON(message: AutoMlTablesInputs_Transformation_AutoTransformation): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoMlTablesInputs_Transformation_AutoTransformation>,
  ): AutoMlTablesInputs_Transformation_AutoTransformation {
    return AutoMlTablesInputs_Transformation_AutoTransformation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoMlTablesInputs_Transformation_AutoTransformation>,
  ): AutoMlTablesInputs_Transformation_AutoTransformation {
    const message = createBaseAutoMlTablesInputs_Transformation_AutoTransformation();
    message.columnName = object.columnName ?? "";
    return message;
  },
};

function createBaseAutoMlTablesInputs_Transformation_NumericTransformation(): AutoMlTablesInputs_Transformation_NumericTransformation {
  return { columnName: "", invalidValuesAllowed: false };
}

export const AutoMlTablesInputs_Transformation_NumericTransformation: MessageFns<
  AutoMlTablesInputs_Transformation_NumericTransformation
> = {
  encode(
    message: AutoMlTablesInputs_Transformation_NumericTransformation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    if (message.invalidValuesAllowed !== false) {
      writer.uint32(16).bool(message.invalidValuesAllowed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlTablesInputs_Transformation_NumericTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlTablesInputs_Transformation_NumericTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.invalidValuesAllowed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlTablesInputs_Transformation_NumericTransformation {
    return {
      columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "",
      invalidValuesAllowed: isSet(object.invalidValuesAllowed)
        ? globalThis.Boolean(object.invalidValuesAllowed)
        : false,
    };
  },

  toJSON(message: AutoMlTablesInputs_Transformation_NumericTransformation): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    if (message.invalidValuesAllowed !== false) {
      obj.invalidValuesAllowed = message.invalidValuesAllowed;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoMlTablesInputs_Transformation_NumericTransformation>,
  ): AutoMlTablesInputs_Transformation_NumericTransformation {
    return AutoMlTablesInputs_Transformation_NumericTransformation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoMlTablesInputs_Transformation_NumericTransformation>,
  ): AutoMlTablesInputs_Transformation_NumericTransformation {
    const message = createBaseAutoMlTablesInputs_Transformation_NumericTransformation();
    message.columnName = object.columnName ?? "";
    message.invalidValuesAllowed = object.invalidValuesAllowed ?? false;
    return message;
  },
};

function createBaseAutoMlTablesInputs_Transformation_CategoricalTransformation(): AutoMlTablesInputs_Transformation_CategoricalTransformation {
  return { columnName: "" };
}

export const AutoMlTablesInputs_Transformation_CategoricalTransformation: MessageFns<
  AutoMlTablesInputs_Transformation_CategoricalTransformation
> = {
  encode(
    message: AutoMlTablesInputs_Transformation_CategoricalTransformation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AutoMlTablesInputs_Transformation_CategoricalTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlTablesInputs_Transformation_CategoricalTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlTablesInputs_Transformation_CategoricalTransformation {
    return { columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "" };
  },

  toJSON(message: AutoMlTablesInputs_Transformation_CategoricalTransformation): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoMlTablesInputs_Transformation_CategoricalTransformation>,
  ): AutoMlTablesInputs_Transformation_CategoricalTransformation {
    return AutoMlTablesInputs_Transformation_CategoricalTransformation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoMlTablesInputs_Transformation_CategoricalTransformation>,
  ): AutoMlTablesInputs_Transformation_CategoricalTransformation {
    const message = createBaseAutoMlTablesInputs_Transformation_CategoricalTransformation();
    message.columnName = object.columnName ?? "";
    return message;
  },
};

function createBaseAutoMlTablesInputs_Transformation_TimestampTransformation(): AutoMlTablesInputs_Transformation_TimestampTransformation {
  return { columnName: "", timeFormat: "", invalidValuesAllowed: false };
}

export const AutoMlTablesInputs_Transformation_TimestampTransformation: MessageFns<
  AutoMlTablesInputs_Transformation_TimestampTransformation
> = {
  encode(
    message: AutoMlTablesInputs_Transformation_TimestampTransformation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    if (message.timeFormat !== "") {
      writer.uint32(18).string(message.timeFormat);
    }
    if (message.invalidValuesAllowed !== false) {
      writer.uint32(24).bool(message.invalidValuesAllowed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlTablesInputs_Transformation_TimestampTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlTablesInputs_Transformation_TimestampTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeFormat = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.invalidValuesAllowed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlTablesInputs_Transformation_TimestampTransformation {
    return {
      columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "",
      timeFormat: isSet(object.timeFormat) ? globalThis.String(object.timeFormat) : "",
      invalidValuesAllowed: isSet(object.invalidValuesAllowed)
        ? globalThis.Boolean(object.invalidValuesAllowed)
        : false,
    };
  },

  toJSON(message: AutoMlTablesInputs_Transformation_TimestampTransformation): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    if (message.timeFormat !== "") {
      obj.timeFormat = message.timeFormat;
    }
    if (message.invalidValuesAllowed !== false) {
      obj.invalidValuesAllowed = message.invalidValuesAllowed;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoMlTablesInputs_Transformation_TimestampTransformation>,
  ): AutoMlTablesInputs_Transformation_TimestampTransformation {
    return AutoMlTablesInputs_Transformation_TimestampTransformation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoMlTablesInputs_Transformation_TimestampTransformation>,
  ): AutoMlTablesInputs_Transformation_TimestampTransformation {
    const message = createBaseAutoMlTablesInputs_Transformation_TimestampTransformation();
    message.columnName = object.columnName ?? "";
    message.timeFormat = object.timeFormat ?? "";
    message.invalidValuesAllowed = object.invalidValuesAllowed ?? false;
    return message;
  },
};

function createBaseAutoMlTablesInputs_Transformation_TextTransformation(): AutoMlTablesInputs_Transformation_TextTransformation {
  return { columnName: "" };
}

export const AutoMlTablesInputs_Transformation_TextTransformation: MessageFns<
  AutoMlTablesInputs_Transformation_TextTransformation
> = {
  encode(
    message: AutoMlTablesInputs_Transformation_TextTransformation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlTablesInputs_Transformation_TextTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlTablesInputs_Transformation_TextTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlTablesInputs_Transformation_TextTransformation {
    return { columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "" };
  },

  toJSON(message: AutoMlTablesInputs_Transformation_TextTransformation): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoMlTablesInputs_Transformation_TextTransformation>,
  ): AutoMlTablesInputs_Transformation_TextTransformation {
    return AutoMlTablesInputs_Transformation_TextTransformation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoMlTablesInputs_Transformation_TextTransformation>,
  ): AutoMlTablesInputs_Transformation_TextTransformation {
    const message = createBaseAutoMlTablesInputs_Transformation_TextTransformation();
    message.columnName = object.columnName ?? "";
    return message;
  },
};

function createBaseAutoMlTablesInputs_Transformation_NumericArrayTransformation(): AutoMlTablesInputs_Transformation_NumericArrayTransformation {
  return { columnName: "", invalidValuesAllowed: false };
}

export const AutoMlTablesInputs_Transformation_NumericArrayTransformation: MessageFns<
  AutoMlTablesInputs_Transformation_NumericArrayTransformation
> = {
  encode(
    message: AutoMlTablesInputs_Transformation_NumericArrayTransformation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    if (message.invalidValuesAllowed !== false) {
      writer.uint32(16).bool(message.invalidValuesAllowed);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AutoMlTablesInputs_Transformation_NumericArrayTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlTablesInputs_Transformation_NumericArrayTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.invalidValuesAllowed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlTablesInputs_Transformation_NumericArrayTransformation {
    return {
      columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "",
      invalidValuesAllowed: isSet(object.invalidValuesAllowed)
        ? globalThis.Boolean(object.invalidValuesAllowed)
        : false,
    };
  },

  toJSON(message: AutoMlTablesInputs_Transformation_NumericArrayTransformation): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    if (message.invalidValuesAllowed !== false) {
      obj.invalidValuesAllowed = message.invalidValuesAllowed;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoMlTablesInputs_Transformation_NumericArrayTransformation>,
  ): AutoMlTablesInputs_Transformation_NumericArrayTransformation {
    return AutoMlTablesInputs_Transformation_NumericArrayTransformation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoMlTablesInputs_Transformation_NumericArrayTransformation>,
  ): AutoMlTablesInputs_Transformation_NumericArrayTransformation {
    const message = createBaseAutoMlTablesInputs_Transformation_NumericArrayTransformation();
    message.columnName = object.columnName ?? "";
    message.invalidValuesAllowed = object.invalidValuesAllowed ?? false;
    return message;
  },
};

function createBaseAutoMlTablesInputs_Transformation_CategoricalArrayTransformation(): AutoMlTablesInputs_Transformation_CategoricalArrayTransformation {
  return { columnName: "" };
}

export const AutoMlTablesInputs_Transformation_CategoricalArrayTransformation: MessageFns<
  AutoMlTablesInputs_Transformation_CategoricalArrayTransformation
> = {
  encode(
    message: AutoMlTablesInputs_Transformation_CategoricalArrayTransformation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AutoMlTablesInputs_Transformation_CategoricalArrayTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlTablesInputs_Transformation_CategoricalArrayTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlTablesInputs_Transformation_CategoricalArrayTransformation {
    return { columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "" };
  },

  toJSON(message: AutoMlTablesInputs_Transformation_CategoricalArrayTransformation): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoMlTablesInputs_Transformation_CategoricalArrayTransformation>,
  ): AutoMlTablesInputs_Transformation_CategoricalArrayTransformation {
    return AutoMlTablesInputs_Transformation_CategoricalArrayTransformation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoMlTablesInputs_Transformation_CategoricalArrayTransformation>,
  ): AutoMlTablesInputs_Transformation_CategoricalArrayTransformation {
    const message = createBaseAutoMlTablesInputs_Transformation_CategoricalArrayTransformation();
    message.columnName = object.columnName ?? "";
    return message;
  },
};

function createBaseAutoMlTablesInputs_Transformation_TextArrayTransformation(): AutoMlTablesInputs_Transformation_TextArrayTransformation {
  return { columnName: "" };
}

export const AutoMlTablesInputs_Transformation_TextArrayTransformation: MessageFns<
  AutoMlTablesInputs_Transformation_TextArrayTransformation
> = {
  encode(
    message: AutoMlTablesInputs_Transformation_TextArrayTransformation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlTablesInputs_Transformation_TextArrayTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlTablesInputs_Transformation_TextArrayTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlTablesInputs_Transformation_TextArrayTransformation {
    return { columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "" };
  },

  toJSON(message: AutoMlTablesInputs_Transformation_TextArrayTransformation): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoMlTablesInputs_Transformation_TextArrayTransformation>,
  ): AutoMlTablesInputs_Transformation_TextArrayTransformation {
    return AutoMlTablesInputs_Transformation_TextArrayTransformation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoMlTablesInputs_Transformation_TextArrayTransformation>,
  ): AutoMlTablesInputs_Transformation_TextArrayTransformation {
    const message = createBaseAutoMlTablesInputs_Transformation_TextArrayTransformation();
    message.columnName = object.columnName ?? "";
    return message;
  },
};

function createBaseAutoMlTablesMetadata(): AutoMlTablesMetadata {
  return { trainCostMilliNodeHours: Long.ZERO };
}

export const AutoMlTablesMetadata: MessageFns<AutoMlTablesMetadata> = {
  encode(message: AutoMlTablesMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.trainCostMilliNodeHours.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.trainCostMilliNodeHours.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoMlTablesMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoMlTablesMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.trainCostMilliNodeHours = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoMlTablesMetadata {
    return {
      trainCostMilliNodeHours: isSet(object.trainCostMilliNodeHours)
        ? Long.fromValue(object.trainCostMilliNodeHours)
        : Long.ZERO,
    };
  },

  toJSON(message: AutoMlTablesMetadata): unknown {
    const obj: any = {};
    if (!message.trainCostMilliNodeHours.equals(Long.ZERO)) {
      obj.trainCostMilliNodeHours = (message.trainCostMilliNodeHours || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<AutoMlTablesMetadata>): AutoMlTablesMetadata {
    return AutoMlTablesMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoMlTablesMetadata>): AutoMlTablesMetadata {
    const message = createBaseAutoMlTablesMetadata();
    message.trainCostMilliNodeHours =
      (object.trainCostMilliNodeHours !== undefined && object.trainCostMilliNodeHours !== null)
        ? Long.fromValue(object.trainCostMilliNodeHours)
        : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
