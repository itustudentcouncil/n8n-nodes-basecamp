// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1beta1/feature_online_store_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Struct } from "../../../protobuf/struct.js";
import { Status } from "../../../rpc/status.js";
import { FeatureValue } from "./featurestore_online_service.js";

export const protobufPackage = "google.cloud.aiplatform.v1beta1";

/** Format of the data in the Feature View. */
export enum FeatureViewDataFormat {
  /** FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED - Not set. Will be treated as the KeyValue format. */
  FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED = 0,
  /** KEY_VALUE - Return response data in key-value format. */
  KEY_VALUE = 1,
  /** PROTO_STRUCT - Return response data in proto Struct format. */
  PROTO_STRUCT = 2,
  UNRECOGNIZED = -1,
}

export function featureViewDataFormatFromJSON(object: any): FeatureViewDataFormat {
  switch (object) {
    case 0:
    case "FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED":
      return FeatureViewDataFormat.FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED;
    case 1:
    case "KEY_VALUE":
      return FeatureViewDataFormat.KEY_VALUE;
    case 2:
    case "PROTO_STRUCT":
      return FeatureViewDataFormat.PROTO_STRUCT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FeatureViewDataFormat.UNRECOGNIZED;
  }
}

export function featureViewDataFormatToJSON(object: FeatureViewDataFormat): string {
  switch (object) {
    case FeatureViewDataFormat.FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED:
      return "FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED";
    case FeatureViewDataFormat.KEY_VALUE:
      return "KEY_VALUE";
    case FeatureViewDataFormat.PROTO_STRUCT:
      return "PROTO_STRUCT";
    case FeatureViewDataFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Lookup key for a feature view. */
export interface FeatureViewDataKey {
  /** String key to use for lookup. */
  key?:
    | string
    | undefined;
  /**
   * The actual Entity ID will be composed from this struct. This should match
   * with the way ID is defined in the FeatureView spec.
   */
  compositeKey?: FeatureViewDataKey_CompositeKey | undefined;
}

/** ID that is comprised from several parts (columns). */
export interface FeatureViewDataKey_CompositeKey {
  /**
   * Parts to construct Entity ID. Should match with the same ID columns as
   * defined in FeatureView in the same order.
   */
  parts: string[];
}

/**
 * Request message for
 * [FeatureOnlineStoreService.FetchFeatureValues][google.cloud.aiplatform.v1beta1.FeatureOnlineStoreService.FetchFeatureValues].
 * All the features under the requested feature view will be returned.
 */
export interface FetchFeatureValuesRequest {
  /**
   * Simple ID. The whole string will be used as is to identify Entity to
   * fetch feature values for.
   *
   * @deprecated
   */
  id?:
    | string
    | undefined;
  /**
   * Required. FeatureView resource format
   * `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
   */
  featureView: string;
  /** Optional. The request key to fetch feature values for. */
  dataKey:
    | FeatureViewDataKey
    | undefined;
  /**
   * Optional. Response data format. If not set,
   * [FeatureViewDataFormat.KEY_VALUE][google.cloud.aiplatform.v1beta1.FeatureViewDataFormat.KEY_VALUE]
   * will be used.
   */
  dataFormat: FeatureViewDataFormat;
  /**
   * Specify response data format. If not set, KeyValue format will be used.
   * Deprecated. Use
   * [FetchFeatureValuesRequest.data_format][google.cloud.aiplatform.v1beta1.FetchFeatureValuesRequest.data_format].
   *
   * @deprecated
   */
  format: FetchFeatureValuesRequest_Format;
}

/**
 * Format of the response data.
 *
 * @deprecated
 */
export enum FetchFeatureValuesRequest_Format {
  /** FORMAT_UNSPECIFIED - Not set. Will be treated as the KeyValue format. */
  FORMAT_UNSPECIFIED = 0,
  /** KEY_VALUE - Return response data in key-value format. */
  KEY_VALUE = 1,
  /** PROTO_STRUCT - Return response data in proto Struct format. */
  PROTO_STRUCT = 2,
  UNRECOGNIZED = -1,
}

export function fetchFeatureValuesRequest_FormatFromJSON(object: any): FetchFeatureValuesRequest_Format {
  switch (object) {
    case 0:
    case "FORMAT_UNSPECIFIED":
      return FetchFeatureValuesRequest_Format.FORMAT_UNSPECIFIED;
    case 1:
    case "KEY_VALUE":
      return FetchFeatureValuesRequest_Format.KEY_VALUE;
    case 2:
    case "PROTO_STRUCT":
      return FetchFeatureValuesRequest_Format.PROTO_STRUCT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FetchFeatureValuesRequest_Format.UNRECOGNIZED;
  }
}

export function fetchFeatureValuesRequest_FormatToJSON(object: FetchFeatureValuesRequest_Format): string {
  switch (object) {
    case FetchFeatureValuesRequest_Format.FORMAT_UNSPECIFIED:
      return "FORMAT_UNSPECIFIED";
    case FetchFeatureValuesRequest_Format.KEY_VALUE:
      return "KEY_VALUE";
    case FetchFeatureValuesRequest_Format.PROTO_STRUCT:
      return "PROTO_STRUCT";
    case FetchFeatureValuesRequest_Format.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Response message for
 * [FeatureOnlineStoreService.FetchFeatureValues][google.cloud.aiplatform.v1beta1.FeatureOnlineStoreService.FetchFeatureValues]
 */
export interface FetchFeatureValuesResponse {
  /** Feature values in KeyValue format. */
  keyValues?:
    | FetchFeatureValuesResponse_FeatureNameValuePairList
    | undefined;
  /** Feature values in proto Struct format. */
  protoStruct?:
    | { [key: string]: any }
    | undefined;
  /**
   * The data key associated with this response.
   * Will only be populated for
   * [FeatureOnlineStoreService.StreamingFetchFeatureValues][google.cloud.aiplatform.v1beta1.FeatureOnlineStoreService.StreamingFetchFeatureValues]
   * RPCs.
   */
  dataKey: FeatureViewDataKey | undefined;
}

/**
 * Response structure in the format of key (feature name) and (feature) value
 * pair.
 */
export interface FetchFeatureValuesResponse_FeatureNameValuePairList {
  /** List of feature names and values. */
  features: FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair[];
}

/** Feature name & value pair. */
export interface FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair {
  /** Feature value. */
  value?:
    | FeatureValue
    | undefined;
  /** Feature short name. */
  name: string;
}

/**
 * Request message for
 * [FeatureOnlineStoreService.StreamingFetchFeatureValues][google.cloud.aiplatform.v1beta1.FeatureOnlineStoreService.StreamingFetchFeatureValues].
 * For the entities requested, all features under the requested feature view
 * will be returned.
 */
export interface StreamingFetchFeatureValuesRequest {
  /**
   * Required. FeatureView resource format
   * `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
   */
  featureView: string;
  dataKeys: FeatureViewDataKey[];
  /** Specify response data format. If not set, KeyValue format will be used. */
  dataFormat: FeatureViewDataFormat;
}

/**
 * Response message for
 * [FeatureOnlineStoreService.StreamingFetchFeatureValues][google.cloud.aiplatform.v1beta1.FeatureOnlineStoreService.StreamingFetchFeatureValues].
 */
export interface StreamingFetchFeatureValuesResponse {
  /**
   * Response status.
   * If OK, then
   * [StreamingFetchFeatureValuesResponse.data][google.cloud.aiplatform.v1beta1.StreamingFetchFeatureValuesResponse.data]
   * will be populated. Otherwise
   * [StreamingFetchFeatureValuesResponse.data_keys_with_error][google.cloud.aiplatform.v1beta1.StreamingFetchFeatureValuesResponse.data_keys_with_error]
   * will be populated with the appropriate data keys. The error only applies to
   * the listed data keys - the stream will remain open for further
   * [FeatureOnlineStoreService.StreamingFetchFeatureValuesRequest][] requests.
   */
  status: Status | undefined;
  data: FetchFeatureValuesResponse[];
  dataKeysWithError: FeatureViewDataKey[];
}

/** A query to find a number of similar entities. */
export interface NearestNeighborQuery {
  /**
   * Optional. The entity id whose similar entities should be searched for.
   * If embedding is set, search will use embedding instead of
   * entity_id.
   */
  entityId?:
    | string
    | undefined;
  /** Optional. The embedding vector that be used for similar search. */
  embedding?:
    | NearestNeighborQuery_Embedding
    | undefined;
  /**
   * Optional. The number of similar entities to be retrieved from feature view
   * for each query.
   */
  neighborCount: number;
  /** Optional. The list of string filters. */
  stringFilters: NearestNeighborQuery_StringFilter[];
  /** Optional. The list of numeric filters. */
  numericFilters: NearestNeighborQuery_NumericFilter[];
  /**
   * Optional. Crowding is a constraint on a neighbor list produced by nearest
   * neighbor search requiring that no more than
   * sper_crowding_attribute_neighbor_count of the k neighbors returned have the
   * same value of crowding_attribute. It's used for improving result diversity.
   */
  perCrowdingAttributeNeighborCount: number;
  /** Optional. Parameters that can be set to tune query on the fly. */
  parameters: NearestNeighborQuery_Parameters | undefined;
}

/** The embedding vector. */
export interface NearestNeighborQuery_Embedding {
  /** Optional. Individual value in the embedding. */
  value: number[];
}

/**
 * String filter is used to search a subset of the entities by using boolean
 * rules on string columns.
 * For example: if a query specifies string filter
 * with 'name = color, allow_tokens = {red, blue}, deny_tokens = {purple}','
 * then that query will match entities that are red or blue, but if those
 * points are also purple, then they will be excluded even if they are
 * red/blue. Only string filter is supported for now, numeric filter will be
 * supported in the near future.
 */
export interface NearestNeighborQuery_StringFilter {
  /** Required. Column names in BigQuery that used as filters. */
  name: string;
  /** Optional. The allowed tokens. */
  allowTokens: string[];
  /** Optional. The denied tokens. */
  denyTokens: string[];
}

/**
 * Numeric filter is used to search a subset of the entities by using boolean
 * rules on numeric columns.
 * For example:
 * Database Point 0: {name: “a” value_int: 42} {name: “b” value_float: 1.0}
 * Database Point 1:  {name: “a” value_int: 10} {name: “b” value_float: 2.0}
 * Database Point 2: {name: “a” value_int: -1} {name: “b” value_float: 3.0}
 * Query: {name: “a” value_int: 12 operator: LESS}    // Matches Point 1, 2
 * {name: “b” value_float: 2.0 operator: EQUAL} // Matches Point 1
 */
export interface NearestNeighborQuery_NumericFilter {
  /** int value type. */
  valueInt?:
    | Long
    | undefined;
  /** float value type. */
  valueFloat?:
    | number
    | undefined;
  /** double value type. */
  valueDouble?:
    | number
    | undefined;
  /** Required. Column name in BigQuery that used as filters. */
  name: string;
  /**
   * Optional. This MUST be specified for queries and must NOT be specified
   * for database points.
   */
  op?: NearestNeighborQuery_NumericFilter_Operator | undefined;
}

/**
 * Datapoints for which Operator is true relative to the query’s Value
 * field will be allowlisted.
 */
export enum NearestNeighborQuery_NumericFilter_Operator {
  /** OPERATOR_UNSPECIFIED - Unspecified operator. */
  OPERATOR_UNSPECIFIED = 0,
  /** LESS - Entities are eligible if their value is < the query's. */
  LESS = 1,
  /** LESS_EQUAL - Entities are eligible if their value is <= the query's. */
  LESS_EQUAL = 2,
  /** EQUAL - Entities are eligible if their value is == the query's. */
  EQUAL = 3,
  /** GREATER_EQUAL - Entities are eligible if their value is >= the query's. */
  GREATER_EQUAL = 4,
  /** GREATER - Entities are eligible if their value is > the query's. */
  GREATER = 5,
  /** NOT_EQUAL - Entities are eligible if their value is != the query's. */
  NOT_EQUAL = 6,
  UNRECOGNIZED = -1,
}

export function nearestNeighborQuery_NumericFilter_OperatorFromJSON(
  object: any,
): NearestNeighborQuery_NumericFilter_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return NearestNeighborQuery_NumericFilter_Operator.OPERATOR_UNSPECIFIED;
    case 1:
    case "LESS":
      return NearestNeighborQuery_NumericFilter_Operator.LESS;
    case 2:
    case "LESS_EQUAL":
      return NearestNeighborQuery_NumericFilter_Operator.LESS_EQUAL;
    case 3:
    case "EQUAL":
      return NearestNeighborQuery_NumericFilter_Operator.EQUAL;
    case 4:
    case "GREATER_EQUAL":
      return NearestNeighborQuery_NumericFilter_Operator.GREATER_EQUAL;
    case 5:
    case "GREATER":
      return NearestNeighborQuery_NumericFilter_Operator.GREATER;
    case 6:
    case "NOT_EQUAL":
      return NearestNeighborQuery_NumericFilter_Operator.NOT_EQUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NearestNeighborQuery_NumericFilter_Operator.UNRECOGNIZED;
  }
}

export function nearestNeighborQuery_NumericFilter_OperatorToJSON(
  object: NearestNeighborQuery_NumericFilter_Operator,
): string {
  switch (object) {
    case NearestNeighborQuery_NumericFilter_Operator.OPERATOR_UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case NearestNeighborQuery_NumericFilter_Operator.LESS:
      return "LESS";
    case NearestNeighborQuery_NumericFilter_Operator.LESS_EQUAL:
      return "LESS_EQUAL";
    case NearestNeighborQuery_NumericFilter_Operator.EQUAL:
      return "EQUAL";
    case NearestNeighborQuery_NumericFilter_Operator.GREATER_EQUAL:
      return "GREATER_EQUAL";
    case NearestNeighborQuery_NumericFilter_Operator.GREATER:
      return "GREATER";
    case NearestNeighborQuery_NumericFilter_Operator.NOT_EQUAL:
      return "NOT_EQUAL";
    case NearestNeighborQuery_NumericFilter_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Parameters that can be overrided in each query to tune query latency and
 * recall.
 */
export interface NearestNeighborQuery_Parameters {
  /**
   * Optional. The number of neighbors to find via approximate search before
   * exact reordering is performed; if set, this value must be >
   * neighbor_count.
   */
  approximateNeighborCandidates: number;
  /**
   * Optional. The fraction of the number of leaves to search, set at query
   * time allows user to tune search performance. This value increase result
   * in both search accuracy and latency increase. The value should be between
   * 0.0 and 1.0.
   */
  leafNodesSearchFraction: number;
}

/**
 * The request message for
 * [FeatureOnlineStoreService.SearchNearestEntities][google.cloud.aiplatform.v1beta1.FeatureOnlineStoreService.SearchNearestEntities].
 */
export interface SearchNearestEntitiesRequest {
  /**
   * Required. FeatureView resource format
   * `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
   */
  featureView: string;
  /** Required. The query. */
  query:
    | NearestNeighborQuery
    | undefined;
  /**
   * Optional. If set to true, the full entities (including all vector values
   * and metadata) of the nearest neighbors are returned; otherwise only entity
   * id of the nearest neighbors will be returned. Note that returning full
   * entities will significantly increase the latency and cost of the query.
   */
  returnFullEntity: boolean;
}

/** Nearest neighbors for one query. */
export interface NearestNeighbors {
  /** All its neighbors. */
  neighbors: NearestNeighbors_Neighbor[];
}

/** A neighbor of the query vector. */
export interface NearestNeighbors_Neighbor {
  /** The id of the similar entity. */
  entityId: string;
  /** The distance between the neighbor and the query vector. */
  distance: number;
  /**
   * The attributes of the neighbor, e.g. filters, crowding and metadata
   * Note that full entities are returned only when "return_full_entity"
   * is set to true. Otherwise, only the "entity_id" and "distance" fields
   * are populated.
   */
  entityKeyValues: FetchFeatureValuesResponse | undefined;
}

/**
 * Response message for
 * [FeatureOnlineStoreService.SearchNearestEntities][google.cloud.aiplatform.v1beta1.FeatureOnlineStoreService.SearchNearestEntities]
 */
export interface SearchNearestEntitiesResponse {
  /** The nearest neighbors of the query entity. */
  nearestNeighbors: NearestNeighbors | undefined;
}

function createBaseFeatureViewDataKey(): FeatureViewDataKey {
  return { key: undefined, compositeKey: undefined };
}

export const FeatureViewDataKey: MessageFns<FeatureViewDataKey> = {
  encode(message: FeatureViewDataKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      writer.uint32(10).string(message.key);
    }
    if (message.compositeKey !== undefined) {
      FeatureViewDataKey_CompositeKey.encode(message.compositeKey, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureViewDataKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureViewDataKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.compositeKey = FeatureViewDataKey_CompositeKey.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureViewDataKey {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
      compositeKey: isSet(object.compositeKey)
        ? FeatureViewDataKey_CompositeKey.fromJSON(object.compositeKey)
        : undefined,
    };
  },

  toJSON(message: FeatureViewDataKey): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.compositeKey !== undefined) {
      obj.compositeKey = FeatureViewDataKey_CompositeKey.toJSON(message.compositeKey);
    }
    return obj;
  },

  create(base?: DeepPartial<FeatureViewDataKey>): FeatureViewDataKey {
    return FeatureViewDataKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FeatureViewDataKey>): FeatureViewDataKey {
    const message = createBaseFeatureViewDataKey();
    message.key = object.key ?? undefined;
    message.compositeKey = (object.compositeKey !== undefined && object.compositeKey !== null)
      ? FeatureViewDataKey_CompositeKey.fromPartial(object.compositeKey)
      : undefined;
    return message;
  },
};

function createBaseFeatureViewDataKey_CompositeKey(): FeatureViewDataKey_CompositeKey {
  return { parts: [] };
}

export const FeatureViewDataKey_CompositeKey: MessageFns<FeatureViewDataKey_CompositeKey> = {
  encode(message: FeatureViewDataKey_CompositeKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parts) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeatureViewDataKey_CompositeKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureViewDataKey_CompositeKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parts.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeatureViewDataKey_CompositeKey {
    return { parts: globalThis.Array.isArray(object?.parts) ? object.parts.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: FeatureViewDataKey_CompositeKey): unknown {
    const obj: any = {};
    if (message.parts?.length) {
      obj.parts = message.parts;
    }
    return obj;
  },

  create(base?: DeepPartial<FeatureViewDataKey_CompositeKey>): FeatureViewDataKey_CompositeKey {
    return FeatureViewDataKey_CompositeKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FeatureViewDataKey_CompositeKey>): FeatureViewDataKey_CompositeKey {
    const message = createBaseFeatureViewDataKey_CompositeKey();
    message.parts = object.parts?.map((e) => e) || [];
    return message;
  },
};

function createBaseFetchFeatureValuesRequest(): FetchFeatureValuesRequest {
  return { id: undefined, featureView: "", dataKey: undefined, dataFormat: 0, format: 0 };
}

export const FetchFeatureValuesRequest: MessageFns<FetchFeatureValuesRequest> = {
  encode(message: FetchFeatureValuesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(26).string(message.id);
    }
    if (message.featureView !== "") {
      writer.uint32(10).string(message.featureView);
    }
    if (message.dataKey !== undefined) {
      FeatureViewDataKey.encode(message.dataKey, writer.uint32(50).fork()).join();
    }
    if (message.dataFormat !== 0) {
      writer.uint32(56).int32(message.dataFormat);
    }
    if (message.format !== 0) {
      writer.uint32(40).int32(message.format);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchFeatureValuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchFeatureValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.featureView = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dataKey = FeatureViewDataKey.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.dataFormat = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchFeatureValuesRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      featureView: isSet(object.featureView) ? globalThis.String(object.featureView) : "",
      dataKey: isSet(object.dataKey) ? FeatureViewDataKey.fromJSON(object.dataKey) : undefined,
      dataFormat: isSet(object.dataFormat) ? featureViewDataFormatFromJSON(object.dataFormat) : 0,
      format: isSet(object.format) ? fetchFeatureValuesRequest_FormatFromJSON(object.format) : 0,
    };
  },

  toJSON(message: FetchFeatureValuesRequest): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.featureView !== "") {
      obj.featureView = message.featureView;
    }
    if (message.dataKey !== undefined) {
      obj.dataKey = FeatureViewDataKey.toJSON(message.dataKey);
    }
    if (message.dataFormat !== 0) {
      obj.dataFormat = featureViewDataFormatToJSON(message.dataFormat);
    }
    if (message.format !== 0) {
      obj.format = fetchFeatureValuesRequest_FormatToJSON(message.format);
    }
    return obj;
  },

  create(base?: DeepPartial<FetchFeatureValuesRequest>): FetchFeatureValuesRequest {
    return FetchFeatureValuesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchFeatureValuesRequest>): FetchFeatureValuesRequest {
    const message = createBaseFetchFeatureValuesRequest();
    message.id = object.id ?? undefined;
    message.featureView = object.featureView ?? "";
    message.dataKey = (object.dataKey !== undefined && object.dataKey !== null)
      ? FeatureViewDataKey.fromPartial(object.dataKey)
      : undefined;
    message.dataFormat = object.dataFormat ?? 0;
    message.format = object.format ?? 0;
    return message;
  },
};

function createBaseFetchFeatureValuesResponse(): FetchFeatureValuesResponse {
  return { keyValues: undefined, protoStruct: undefined, dataKey: undefined };
}

export const FetchFeatureValuesResponse: MessageFns<FetchFeatureValuesResponse> = {
  encode(message: FetchFeatureValuesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyValues !== undefined) {
      FetchFeatureValuesResponse_FeatureNameValuePairList.encode(message.keyValues, writer.uint32(26).fork()).join();
    }
    if (message.protoStruct !== undefined) {
      Struct.encode(Struct.wrap(message.protoStruct), writer.uint32(18).fork()).join();
    }
    if (message.dataKey !== undefined) {
      FeatureViewDataKey.encode(message.dataKey, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchFeatureValuesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchFeatureValuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keyValues = FetchFeatureValuesResponse_FeatureNameValuePairList.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.protoStruct = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dataKey = FeatureViewDataKey.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchFeatureValuesResponse {
    return {
      keyValues: isSet(object.keyValues)
        ? FetchFeatureValuesResponse_FeatureNameValuePairList.fromJSON(object.keyValues)
        : undefined,
      protoStruct: isObject(object.protoStruct) ? object.protoStruct : undefined,
      dataKey: isSet(object.dataKey) ? FeatureViewDataKey.fromJSON(object.dataKey) : undefined,
    };
  },

  toJSON(message: FetchFeatureValuesResponse): unknown {
    const obj: any = {};
    if (message.keyValues !== undefined) {
      obj.keyValues = FetchFeatureValuesResponse_FeatureNameValuePairList.toJSON(message.keyValues);
    }
    if (message.protoStruct !== undefined) {
      obj.protoStruct = message.protoStruct;
    }
    if (message.dataKey !== undefined) {
      obj.dataKey = FeatureViewDataKey.toJSON(message.dataKey);
    }
    return obj;
  },

  create(base?: DeepPartial<FetchFeatureValuesResponse>): FetchFeatureValuesResponse {
    return FetchFeatureValuesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchFeatureValuesResponse>): FetchFeatureValuesResponse {
    const message = createBaseFetchFeatureValuesResponse();
    message.keyValues = (object.keyValues !== undefined && object.keyValues !== null)
      ? FetchFeatureValuesResponse_FeatureNameValuePairList.fromPartial(object.keyValues)
      : undefined;
    message.protoStruct = object.protoStruct ?? undefined;
    message.dataKey = (object.dataKey !== undefined && object.dataKey !== null)
      ? FeatureViewDataKey.fromPartial(object.dataKey)
      : undefined;
    return message;
  },
};

function createBaseFetchFeatureValuesResponse_FeatureNameValuePairList(): FetchFeatureValuesResponse_FeatureNameValuePairList {
  return { features: [] };
}

export const FetchFeatureValuesResponse_FeatureNameValuePairList: MessageFns<
  FetchFeatureValuesResponse_FeatureNameValuePairList
> = {
  encode(
    message: FetchFeatureValuesResponse_FeatureNameValuePairList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.features) {
      FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair.encode(v!, writer.uint32(10).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchFeatureValuesResponse_FeatureNameValuePairList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchFeatureValuesResponse_FeatureNameValuePairList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.features.push(
            FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchFeatureValuesResponse_FeatureNameValuePairList {
    return {
      features: globalThis.Array.isArray(object?.features)
        ? object.features.map((e: any) =>
          FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: FetchFeatureValuesResponse_FeatureNameValuePairList): unknown {
    const obj: any = {};
    if (message.features?.length) {
      obj.features = message.features.map((e) =>
        FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<FetchFeatureValuesResponse_FeatureNameValuePairList>,
  ): FetchFeatureValuesResponse_FeatureNameValuePairList {
    return FetchFeatureValuesResponse_FeatureNameValuePairList.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FetchFeatureValuesResponse_FeatureNameValuePairList>,
  ): FetchFeatureValuesResponse_FeatureNameValuePairList {
    const message = createBaseFetchFeatureValuesResponse_FeatureNameValuePairList();
    message.features =
      object.features?.map((e) =>
        FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseFetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair(): FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair {
  return { value: undefined, name: "" };
}

export const FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair: MessageFns<
  FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair
> = {
  encode(
    message: FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.value !== undefined) {
      FeatureValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = FeatureValue.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair {
    return {
      value: isSet(object.value) ? FeatureValue.fromJSON(object.value) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = FeatureValue.toJSON(message.value);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(
    base?: DeepPartial<FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair>,
  ): FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair {
    return FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair>,
  ): FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair {
    const message = createBaseFetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair();
    message.value = (object.value !== undefined && object.value !== null)
      ? FeatureValue.fromPartial(object.value)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStreamingFetchFeatureValuesRequest(): StreamingFetchFeatureValuesRequest {
  return { featureView: "", dataKeys: [], dataFormat: 0 };
}

export const StreamingFetchFeatureValuesRequest: MessageFns<StreamingFetchFeatureValuesRequest> = {
  encode(message: StreamingFetchFeatureValuesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.featureView !== "") {
      writer.uint32(10).string(message.featureView);
    }
    for (const v of message.dataKeys) {
      FeatureViewDataKey.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.dataFormat !== 0) {
      writer.uint32(24).int32(message.dataFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingFetchFeatureValuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingFetchFeatureValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.featureView = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataKeys.push(FeatureViewDataKey.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dataFormat = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingFetchFeatureValuesRequest {
    return {
      featureView: isSet(object.featureView) ? globalThis.String(object.featureView) : "",
      dataKeys: globalThis.Array.isArray(object?.dataKeys)
        ? object.dataKeys.map((e: any) => FeatureViewDataKey.fromJSON(e))
        : [],
      dataFormat: isSet(object.dataFormat) ? featureViewDataFormatFromJSON(object.dataFormat) : 0,
    };
  },

  toJSON(message: StreamingFetchFeatureValuesRequest): unknown {
    const obj: any = {};
    if (message.featureView !== "") {
      obj.featureView = message.featureView;
    }
    if (message.dataKeys?.length) {
      obj.dataKeys = message.dataKeys.map((e) => FeatureViewDataKey.toJSON(e));
    }
    if (message.dataFormat !== 0) {
      obj.dataFormat = featureViewDataFormatToJSON(message.dataFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingFetchFeatureValuesRequest>): StreamingFetchFeatureValuesRequest {
    return StreamingFetchFeatureValuesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingFetchFeatureValuesRequest>): StreamingFetchFeatureValuesRequest {
    const message = createBaseStreamingFetchFeatureValuesRequest();
    message.featureView = object.featureView ?? "";
    message.dataKeys = object.dataKeys?.map((e) => FeatureViewDataKey.fromPartial(e)) || [];
    message.dataFormat = object.dataFormat ?? 0;
    return message;
  },
};

function createBaseStreamingFetchFeatureValuesResponse(): StreamingFetchFeatureValuesResponse {
  return { status: undefined, data: [], dataKeysWithError: [] };
}

export const StreamingFetchFeatureValuesResponse: MessageFns<StreamingFetchFeatureValuesResponse> = {
  encode(message: StreamingFetchFeatureValuesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.data) {
      FetchFeatureValuesResponse.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.dataKeysWithError) {
      FeatureViewDataKey.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingFetchFeatureValuesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingFetchFeatureValuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data.push(FetchFeatureValuesResponse.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dataKeysWithError.push(FeatureViewDataKey.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingFetchFeatureValuesResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: globalThis.Array.isArray(object?.data)
        ? object.data.map((e: any) => FetchFeatureValuesResponse.fromJSON(e))
        : [],
      dataKeysWithError: globalThis.Array.isArray(object?.dataKeysWithError)
        ? object.dataKeysWithError.map((e: any) => FeatureViewDataKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamingFetchFeatureValuesResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => FetchFeatureValuesResponse.toJSON(e));
    }
    if (message.dataKeysWithError?.length) {
      obj.dataKeysWithError = message.dataKeysWithError.map((e) => FeatureViewDataKey.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingFetchFeatureValuesResponse>): StreamingFetchFeatureValuesResponse {
    return StreamingFetchFeatureValuesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingFetchFeatureValuesResponse>): StreamingFetchFeatureValuesResponse {
    const message = createBaseStreamingFetchFeatureValuesResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = object.data?.map((e) => FetchFeatureValuesResponse.fromPartial(e)) || [];
    message.dataKeysWithError = object.dataKeysWithError?.map((e) => FeatureViewDataKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNearestNeighborQuery(): NearestNeighborQuery {
  return {
    entityId: undefined,
    embedding: undefined,
    neighborCount: 0,
    stringFilters: [],
    numericFilters: [],
    perCrowdingAttributeNeighborCount: 0,
    parameters: undefined,
  };
}

export const NearestNeighborQuery: MessageFns<NearestNeighborQuery> = {
  encode(message: NearestNeighborQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityId !== undefined) {
      writer.uint32(10).string(message.entityId);
    }
    if (message.embedding !== undefined) {
      NearestNeighborQuery_Embedding.encode(message.embedding, writer.uint32(18).fork()).join();
    }
    if (message.neighborCount !== 0) {
      writer.uint32(24).int32(message.neighborCount);
    }
    for (const v of message.stringFilters) {
      NearestNeighborQuery_StringFilter.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.numericFilters) {
      NearestNeighborQuery_NumericFilter.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.perCrowdingAttributeNeighborCount !== 0) {
      writer.uint32(40).int32(message.perCrowdingAttributeNeighborCount);
    }
    if (message.parameters !== undefined) {
      NearestNeighborQuery_Parameters.encode(message.parameters, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearestNeighborQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearestNeighborQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.embedding = NearestNeighborQuery_Embedding.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.neighborCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stringFilters.push(NearestNeighborQuery_StringFilter.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.numericFilters.push(NearestNeighborQuery_NumericFilter.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.perCrowdingAttributeNeighborCount = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.parameters = NearestNeighborQuery_Parameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearestNeighborQuery {
    return {
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : undefined,
      embedding: isSet(object.embedding) ? NearestNeighborQuery_Embedding.fromJSON(object.embedding) : undefined,
      neighborCount: isSet(object.neighborCount) ? globalThis.Number(object.neighborCount) : 0,
      stringFilters: globalThis.Array.isArray(object?.stringFilters)
        ? object.stringFilters.map((e: any) => NearestNeighborQuery_StringFilter.fromJSON(e))
        : [],
      numericFilters: globalThis.Array.isArray(object?.numericFilters)
        ? object.numericFilters.map((e: any) => NearestNeighborQuery_NumericFilter.fromJSON(e))
        : [],
      perCrowdingAttributeNeighborCount: isSet(object.perCrowdingAttributeNeighborCount)
        ? globalThis.Number(object.perCrowdingAttributeNeighborCount)
        : 0,
      parameters: isSet(object.parameters) ? NearestNeighborQuery_Parameters.fromJSON(object.parameters) : undefined,
    };
  },

  toJSON(message: NearestNeighborQuery): unknown {
    const obj: any = {};
    if (message.entityId !== undefined) {
      obj.entityId = message.entityId;
    }
    if (message.embedding !== undefined) {
      obj.embedding = NearestNeighborQuery_Embedding.toJSON(message.embedding);
    }
    if (message.neighborCount !== 0) {
      obj.neighborCount = Math.round(message.neighborCount);
    }
    if (message.stringFilters?.length) {
      obj.stringFilters = message.stringFilters.map((e) => NearestNeighborQuery_StringFilter.toJSON(e));
    }
    if (message.numericFilters?.length) {
      obj.numericFilters = message.numericFilters.map((e) => NearestNeighborQuery_NumericFilter.toJSON(e));
    }
    if (message.perCrowdingAttributeNeighborCount !== 0) {
      obj.perCrowdingAttributeNeighborCount = Math.round(message.perCrowdingAttributeNeighborCount);
    }
    if (message.parameters !== undefined) {
      obj.parameters = NearestNeighborQuery_Parameters.toJSON(message.parameters);
    }
    return obj;
  },

  create(base?: DeepPartial<NearestNeighborQuery>): NearestNeighborQuery {
    return NearestNeighborQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearestNeighborQuery>): NearestNeighborQuery {
    const message = createBaseNearestNeighborQuery();
    message.entityId = object.entityId ?? undefined;
    message.embedding = (object.embedding !== undefined && object.embedding !== null)
      ? NearestNeighborQuery_Embedding.fromPartial(object.embedding)
      : undefined;
    message.neighborCount = object.neighborCount ?? 0;
    message.stringFilters = object.stringFilters?.map((e) => NearestNeighborQuery_StringFilter.fromPartial(e)) || [];
    message.numericFilters = object.numericFilters?.map((e) => NearestNeighborQuery_NumericFilter.fromPartial(e)) || [];
    message.perCrowdingAttributeNeighborCount = object.perCrowdingAttributeNeighborCount ?? 0;
    message.parameters = (object.parameters !== undefined && object.parameters !== null)
      ? NearestNeighborQuery_Parameters.fromPartial(object.parameters)
      : undefined;
    return message;
  },
};

function createBaseNearestNeighborQuery_Embedding(): NearestNeighborQuery_Embedding {
  return { value: [] };
}

export const NearestNeighborQuery_Embedding: MessageFns<NearestNeighborQuery_Embedding> = {
  encode(message: NearestNeighborQuery_Embedding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.value) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearestNeighborQuery_Embedding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearestNeighborQuery_Embedding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 13) {
            message.value.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.value.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearestNeighborQuery_Embedding {
    return { value: globalThis.Array.isArray(object?.value) ? object.value.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: NearestNeighborQuery_Embedding): unknown {
    const obj: any = {};
    if (message.value?.length) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NearestNeighborQuery_Embedding>): NearestNeighborQuery_Embedding {
    return NearestNeighborQuery_Embedding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearestNeighborQuery_Embedding>): NearestNeighborQuery_Embedding {
    const message = createBaseNearestNeighborQuery_Embedding();
    message.value = object.value?.map((e) => e) || [];
    return message;
  },
};

function createBaseNearestNeighborQuery_StringFilter(): NearestNeighborQuery_StringFilter {
  return { name: "", allowTokens: [], denyTokens: [] };
}

export const NearestNeighborQuery_StringFilter: MessageFns<NearestNeighborQuery_StringFilter> = {
  encode(message: NearestNeighborQuery_StringFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.allowTokens) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.denyTokens) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearestNeighborQuery_StringFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearestNeighborQuery_StringFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.allowTokens.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.denyTokens.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearestNeighborQuery_StringFilter {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      allowTokens: globalThis.Array.isArray(object?.allowTokens)
        ? object.allowTokens.map((e: any) => globalThis.String(e))
        : [],
      denyTokens: globalThis.Array.isArray(object?.denyTokens)
        ? object.denyTokens.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: NearestNeighborQuery_StringFilter): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.allowTokens?.length) {
      obj.allowTokens = message.allowTokens;
    }
    if (message.denyTokens?.length) {
      obj.denyTokens = message.denyTokens;
    }
    return obj;
  },

  create(base?: DeepPartial<NearestNeighborQuery_StringFilter>): NearestNeighborQuery_StringFilter {
    return NearestNeighborQuery_StringFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearestNeighborQuery_StringFilter>): NearestNeighborQuery_StringFilter {
    const message = createBaseNearestNeighborQuery_StringFilter();
    message.name = object.name ?? "";
    message.allowTokens = object.allowTokens?.map((e) => e) || [];
    message.denyTokens = object.denyTokens?.map((e) => e) || [];
    return message;
  },
};

function createBaseNearestNeighborQuery_NumericFilter(): NearestNeighborQuery_NumericFilter {
  return { valueInt: undefined, valueFloat: undefined, valueDouble: undefined, name: "", op: undefined };
}

export const NearestNeighborQuery_NumericFilter: MessageFns<NearestNeighborQuery_NumericFilter> = {
  encode(message: NearestNeighborQuery_NumericFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valueInt !== undefined) {
      writer.uint32(16).int64(message.valueInt.toString());
    }
    if (message.valueFloat !== undefined) {
      writer.uint32(29).float(message.valueFloat);
    }
    if (message.valueDouble !== undefined) {
      writer.uint32(33).double(message.valueDouble);
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.op !== undefined) {
      writer.uint32(40).int32(message.op);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearestNeighborQuery_NumericFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearestNeighborQuery_NumericFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.valueInt = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.valueFloat = reader.float();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.valueDouble = reader.double();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearestNeighborQuery_NumericFilter {
    return {
      valueInt: isSet(object.valueInt) ? Long.fromValue(object.valueInt) : undefined,
      valueFloat: isSet(object.valueFloat) ? globalThis.Number(object.valueFloat) : undefined,
      valueDouble: isSet(object.valueDouble) ? globalThis.Number(object.valueDouble) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      op: isSet(object.op) ? nearestNeighborQuery_NumericFilter_OperatorFromJSON(object.op) : undefined,
    };
  },

  toJSON(message: NearestNeighborQuery_NumericFilter): unknown {
    const obj: any = {};
    if (message.valueInt !== undefined) {
      obj.valueInt = (message.valueInt || Long.ZERO).toString();
    }
    if (message.valueFloat !== undefined) {
      obj.valueFloat = message.valueFloat;
    }
    if (message.valueDouble !== undefined) {
      obj.valueDouble = message.valueDouble;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.op !== undefined) {
      obj.op = nearestNeighborQuery_NumericFilter_OperatorToJSON(message.op);
    }
    return obj;
  },

  create(base?: DeepPartial<NearestNeighborQuery_NumericFilter>): NearestNeighborQuery_NumericFilter {
    return NearestNeighborQuery_NumericFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearestNeighborQuery_NumericFilter>): NearestNeighborQuery_NumericFilter {
    const message = createBaseNearestNeighborQuery_NumericFilter();
    message.valueInt = (object.valueInt !== undefined && object.valueInt !== null)
      ? Long.fromValue(object.valueInt)
      : undefined;
    message.valueFloat = object.valueFloat ?? undefined;
    message.valueDouble = object.valueDouble ?? undefined;
    message.name = object.name ?? "";
    message.op = object.op ?? undefined;
    return message;
  },
};

function createBaseNearestNeighborQuery_Parameters(): NearestNeighborQuery_Parameters {
  return { approximateNeighborCandidates: 0, leafNodesSearchFraction: 0 };
}

export const NearestNeighborQuery_Parameters: MessageFns<NearestNeighborQuery_Parameters> = {
  encode(message: NearestNeighborQuery_Parameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.approximateNeighborCandidates !== 0) {
      writer.uint32(8).int32(message.approximateNeighborCandidates);
    }
    if (message.leafNodesSearchFraction !== 0) {
      writer.uint32(17).double(message.leafNodesSearchFraction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearestNeighborQuery_Parameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearestNeighborQuery_Parameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.approximateNeighborCandidates = reader.int32();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.leafNodesSearchFraction = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearestNeighborQuery_Parameters {
    return {
      approximateNeighborCandidates: isSet(object.approximateNeighborCandidates)
        ? globalThis.Number(object.approximateNeighborCandidates)
        : 0,
      leafNodesSearchFraction: isSet(object.leafNodesSearchFraction)
        ? globalThis.Number(object.leafNodesSearchFraction)
        : 0,
    };
  },

  toJSON(message: NearestNeighborQuery_Parameters): unknown {
    const obj: any = {};
    if (message.approximateNeighborCandidates !== 0) {
      obj.approximateNeighborCandidates = Math.round(message.approximateNeighborCandidates);
    }
    if (message.leafNodesSearchFraction !== 0) {
      obj.leafNodesSearchFraction = message.leafNodesSearchFraction;
    }
    return obj;
  },

  create(base?: DeepPartial<NearestNeighborQuery_Parameters>): NearestNeighborQuery_Parameters {
    return NearestNeighborQuery_Parameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearestNeighborQuery_Parameters>): NearestNeighborQuery_Parameters {
    const message = createBaseNearestNeighborQuery_Parameters();
    message.approximateNeighborCandidates = object.approximateNeighborCandidates ?? 0;
    message.leafNodesSearchFraction = object.leafNodesSearchFraction ?? 0;
    return message;
  },
};

function createBaseSearchNearestEntitiesRequest(): SearchNearestEntitiesRequest {
  return { featureView: "", query: undefined, returnFullEntity: false };
}

export const SearchNearestEntitiesRequest: MessageFns<SearchNearestEntitiesRequest> = {
  encode(message: SearchNearestEntitiesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.featureView !== "") {
      writer.uint32(10).string(message.featureView);
    }
    if (message.query !== undefined) {
      NearestNeighborQuery.encode(message.query, writer.uint32(18).fork()).join();
    }
    if (message.returnFullEntity !== false) {
      writer.uint32(24).bool(message.returnFullEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchNearestEntitiesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchNearestEntitiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.featureView = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = NearestNeighborQuery.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.returnFullEntity = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchNearestEntitiesRequest {
    return {
      featureView: isSet(object.featureView) ? globalThis.String(object.featureView) : "",
      query: isSet(object.query) ? NearestNeighborQuery.fromJSON(object.query) : undefined,
      returnFullEntity: isSet(object.returnFullEntity) ? globalThis.Boolean(object.returnFullEntity) : false,
    };
  },

  toJSON(message: SearchNearestEntitiesRequest): unknown {
    const obj: any = {};
    if (message.featureView !== "") {
      obj.featureView = message.featureView;
    }
    if (message.query !== undefined) {
      obj.query = NearestNeighborQuery.toJSON(message.query);
    }
    if (message.returnFullEntity !== false) {
      obj.returnFullEntity = message.returnFullEntity;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchNearestEntitiesRequest>): SearchNearestEntitiesRequest {
    return SearchNearestEntitiesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchNearestEntitiesRequest>): SearchNearestEntitiesRequest {
    const message = createBaseSearchNearestEntitiesRequest();
    message.featureView = object.featureView ?? "";
    message.query = (object.query !== undefined && object.query !== null)
      ? NearestNeighborQuery.fromPartial(object.query)
      : undefined;
    message.returnFullEntity = object.returnFullEntity ?? false;
    return message;
  },
};

function createBaseNearestNeighbors(): NearestNeighbors {
  return { neighbors: [] };
}

export const NearestNeighbors: MessageFns<NearestNeighbors> = {
  encode(message: NearestNeighbors, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.neighbors) {
      NearestNeighbors_Neighbor.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearestNeighbors {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearestNeighbors();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.neighbors.push(NearestNeighbors_Neighbor.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearestNeighbors {
    return {
      neighbors: globalThis.Array.isArray(object?.neighbors)
        ? object.neighbors.map((e: any) => NearestNeighbors_Neighbor.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NearestNeighbors): unknown {
    const obj: any = {};
    if (message.neighbors?.length) {
      obj.neighbors = message.neighbors.map((e) => NearestNeighbors_Neighbor.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NearestNeighbors>): NearestNeighbors {
    return NearestNeighbors.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearestNeighbors>): NearestNeighbors {
    const message = createBaseNearestNeighbors();
    message.neighbors = object.neighbors?.map((e) => NearestNeighbors_Neighbor.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNearestNeighbors_Neighbor(): NearestNeighbors_Neighbor {
  return { entityId: "", distance: 0, entityKeyValues: undefined };
}

export const NearestNeighbors_Neighbor: MessageFns<NearestNeighbors_Neighbor> = {
  encode(message: NearestNeighbors_Neighbor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityId !== "") {
      writer.uint32(10).string(message.entityId);
    }
    if (message.distance !== 0) {
      writer.uint32(17).double(message.distance);
    }
    if (message.entityKeyValues !== undefined) {
      FetchFeatureValuesResponse.encode(message.entityKeyValues, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearestNeighbors_Neighbor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearestNeighbors_Neighbor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityId = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entityKeyValues = FetchFeatureValuesResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearestNeighbors_Neighbor {
    return {
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
      entityKeyValues: isSet(object.entityKeyValues)
        ? FetchFeatureValuesResponse.fromJSON(object.entityKeyValues)
        : undefined,
    };
  },

  toJSON(message: NearestNeighbors_Neighbor): unknown {
    const obj: any = {};
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.distance !== 0) {
      obj.distance = message.distance;
    }
    if (message.entityKeyValues !== undefined) {
      obj.entityKeyValues = FetchFeatureValuesResponse.toJSON(message.entityKeyValues);
    }
    return obj;
  },

  create(base?: DeepPartial<NearestNeighbors_Neighbor>): NearestNeighbors_Neighbor {
    return NearestNeighbors_Neighbor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearestNeighbors_Neighbor>): NearestNeighbors_Neighbor {
    const message = createBaseNearestNeighbors_Neighbor();
    message.entityId = object.entityId ?? "";
    message.distance = object.distance ?? 0;
    message.entityKeyValues = (object.entityKeyValues !== undefined && object.entityKeyValues !== null)
      ? FetchFeatureValuesResponse.fromPartial(object.entityKeyValues)
      : undefined;
    return message;
  },
};

function createBaseSearchNearestEntitiesResponse(): SearchNearestEntitiesResponse {
  return { nearestNeighbors: undefined };
}

export const SearchNearestEntitiesResponse: MessageFns<SearchNearestEntitiesResponse> = {
  encode(message: SearchNearestEntitiesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nearestNeighbors !== undefined) {
      NearestNeighbors.encode(message.nearestNeighbors, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchNearestEntitiesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchNearestEntitiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nearestNeighbors = NearestNeighbors.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchNearestEntitiesResponse {
    return {
      nearestNeighbors: isSet(object.nearestNeighbors) ? NearestNeighbors.fromJSON(object.nearestNeighbors) : undefined,
    };
  },

  toJSON(message: SearchNearestEntitiesResponse): unknown {
    const obj: any = {};
    if (message.nearestNeighbors !== undefined) {
      obj.nearestNeighbors = NearestNeighbors.toJSON(message.nearestNeighbors);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchNearestEntitiesResponse>): SearchNearestEntitiesResponse {
    return SearchNearestEntitiesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchNearestEntitiesResponse>): SearchNearestEntitiesResponse {
    const message = createBaseSearchNearestEntitiesResponse();
    message.nearestNeighbors = (object.nearestNeighbors !== undefined && object.nearestNeighbors !== null)
      ? NearestNeighbors.fromPartial(object.nearestNeighbors)
      : undefined;
    return message;
  },
};

/** A service for fetching feature values from the online store. */
export type FeatureOnlineStoreServiceDefinition = typeof FeatureOnlineStoreServiceDefinition;
export const FeatureOnlineStoreServiceDefinition = {
  name: "FeatureOnlineStoreService",
  fullName: "google.cloud.aiplatform.v1beta1.FeatureOnlineStoreService",
  methods: {
    /** Fetch feature values under a FeatureView. */
    fetchFeatureValues: {
      name: "FetchFeatureValues",
      requestType: FetchFeatureValuesRequest,
      requestStream: false,
      responseType: FetchFeatureValuesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              102,
              101,
              97,
              116,
              117,
              114,
              101,
              95,
              118,
              105,
              101,
              119,
              44,
              32,
              100,
              97,
              116,
              97,
              95,
              107,
              101,
              121,
            ]),
          ],
          578365826: [
            Buffer.from([
              107,
              58,
              1,
              42,
              34,
              102,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              102,
              101,
              97,
              116,
              117,
              114,
              101,
              95,
              118,
              105,
              101,
              119,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              102,
              101,
              97,
              116,
              117,
              114,
              101,
              79,
              110,
              108,
              105,
              110,
              101,
              83,
              116,
              111,
              114,
              101,
              115,
              47,
              42,
              47,
              102,
              101,
              97,
              116,
              117,
              114,
              101,
              86,
              105,
              101,
              119,
              115,
              47,
              42,
              125,
              58,
              102,
              101,
              116,
              99,
              104,
              70,
              101,
              97,
              116,
              117,
              114,
              101,
              86,
              97,
              108,
              117,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Bidirectional streaming RPC to fetch feature values under a FeatureView.
     * Requests may not have a one-to-one mapping to responses and responses may
     * be returned out-of-order to reduce latency.
     */
    streamingFetchFeatureValues: {
      name: "StreamingFetchFeatureValues",
      requestType: StreamingFetchFeatureValuesRequest,
      requestStream: true,
      responseType: StreamingFetchFeatureValuesResponse,
      responseStream: true,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              102,
              101,
              97,
              116,
              117,
              114,
              101,
              95,
              118,
              105,
              101,
              119,
              44,
              32,
              100,
              97,
              116,
              97,
              95,
              107,
              101,
              121,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              116,
              58,
              1,
              42,
              34,
              111,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              102,
              101,
              97,
              116,
              117,
              114,
              101,
              95,
              118,
              105,
              101,
              119,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              102,
              101,
              97,
              116,
              117,
              114,
              101,
              79,
              110,
              108,
              105,
              110,
              101,
              83,
              116,
              111,
              114,
              101,
              115,
              47,
              42,
              47,
              102,
              101,
              97,
              116,
              117,
              114,
              101,
              86,
              105,
              101,
              119,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              114,
              101,
              97,
              109,
              105,
              110,
              103,
              70,
              101,
              116,
              99,
              104,
              70,
              101,
              97,
              116,
              117,
              114,
              101,
              86,
              97,
              108,
              117,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Search the nearest entities under a FeatureView.
     * Search only works for indexable feature view; if a feature view isn't
     * indexable, returns Invalid argument response.
     */
    searchNearestEntities: {
      name: "SearchNearestEntities",
      requestType: SearchNearestEntitiesRequest,
      requestStream: false,
      responseType: SearchNearestEntitiesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              110,
              58,
              1,
              42,
              34,
              105,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              102,
              101,
              97,
              116,
              117,
              114,
              101,
              95,
              118,
              105,
              101,
              119,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              102,
              101,
              97,
              116,
              117,
              114,
              101,
              79,
              110,
              108,
              105,
              110,
              101,
              83,
              116,
              111,
              114,
              101,
              115,
              47,
              42,
              47,
              102,
              101,
              97,
              116,
              117,
              114,
              101,
              86,
              105,
              101,
              119,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              78,
              101,
              97,
              114,
              101,
              115,
              116,
              69,
              110,
              116,
              105,
              116,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface FeatureOnlineStoreServiceImplementation<CallContextExt = {}> {
  /** Fetch feature values under a FeatureView. */
  fetchFeatureValues(
    request: FetchFeatureValuesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FetchFeatureValuesResponse>>;
  /**
   * Bidirectional streaming RPC to fetch feature values under a FeatureView.
   * Requests may not have a one-to-one mapping to responses and responses may
   * be returned out-of-order to reduce latency.
   */
  streamingFetchFeatureValues(
    request: AsyncIterable<StreamingFetchFeatureValuesRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<StreamingFetchFeatureValuesResponse>>;
  /**
   * Search the nearest entities under a FeatureView.
   * Search only works for indexable feature view; if a feature view isn't
   * indexable, returns Invalid argument response.
   */
  searchNearestEntities(
    request: SearchNearestEntitiesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchNearestEntitiesResponse>>;
}

export interface FeatureOnlineStoreServiceClient<CallOptionsExt = {}> {
  /** Fetch feature values under a FeatureView. */
  fetchFeatureValues(
    request: DeepPartial<FetchFeatureValuesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FetchFeatureValuesResponse>;
  /**
   * Bidirectional streaming RPC to fetch feature values under a FeatureView.
   * Requests may not have a one-to-one mapping to responses and responses may
   * be returned out-of-order to reduce latency.
   */
  streamingFetchFeatureValues(
    request: AsyncIterable<DeepPartial<StreamingFetchFeatureValuesRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<StreamingFetchFeatureValuesResponse>;
  /**
   * Search the nearest entities under a FeatureView.
   * Search only works for indexable feature view; if a feature view isn't
   * indexable, returns Invalid argument response.
   */
  searchNearestEntities(
    request: DeepPartial<SearchNearestEntitiesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchNearestEntitiesResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
