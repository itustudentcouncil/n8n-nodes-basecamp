// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1beta1/openapi.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Value } from "../../../protobuf/struct.js";

export const protobufPackage = "google.cloud.aiplatform.v1beta1";

/**
 * Type contains the list of OpenAPI data types as defined by
 * https://swagger.io/docs/specification/data-models/data-types/
 */
export enum Type {
  /** TYPE_UNSPECIFIED - Not specified, should not be used. */
  TYPE_UNSPECIFIED = 0,
  /** STRING - OpenAPI string type */
  STRING = 1,
  /** NUMBER - OpenAPI number type */
  NUMBER = 2,
  /** INTEGER - OpenAPI integer type */
  INTEGER = 3,
  /** BOOLEAN - OpenAPI boolean type */
  BOOLEAN = 4,
  /** ARRAY - OpenAPI array type */
  ARRAY = 5,
  /** OBJECT - OpenAPI object type */
  OBJECT = 6,
  UNRECOGNIZED = -1,
}

export function typeFromJSON(object: any): Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Type.TYPE_UNSPECIFIED;
    case 1:
    case "STRING":
      return Type.STRING;
    case 2:
    case "NUMBER":
      return Type.NUMBER;
    case 3:
    case "INTEGER":
      return Type.INTEGER;
    case 4:
    case "BOOLEAN":
      return Type.BOOLEAN;
    case 5:
    case "ARRAY":
      return Type.ARRAY;
    case 6:
    case "OBJECT":
      return Type.OBJECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Type.UNRECOGNIZED;
  }
}

export function typeToJSON(object: Type): string {
  switch (object) {
    case Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Type.STRING:
      return "STRING";
    case Type.NUMBER:
      return "NUMBER";
    case Type.INTEGER:
      return "INTEGER";
    case Type.BOOLEAN:
      return "BOOLEAN";
    case Type.ARRAY:
      return "ARRAY";
    case Type.OBJECT:
      return "OBJECT";
    case Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Schema is used to define the format of input/output data. Represents a select
 * subset of an [OpenAPI 3.0 schema
 * object](https://spec.openapis.org/oas/v3.0.3#schema-object). More fields may
 * be added in the future as needed.
 */
export interface Schema {
  /** Optional. The type of the data. */
  type: Type;
  /**
   * Optional. The format of the data.
   * Supported formats:
   *  for NUMBER type: "float", "double"
   *  for INTEGER type: "int32", "int64"
   *  for STRING type: "email", "byte", etc
   */
  format: string;
  /** Optional. The title of the Schema. */
  title: string;
  /** Optional. The description of the data. */
  description: string;
  /** Optional. Indicates if the value may be null. */
  nullable: boolean;
  /** Optional. Default value of the data. */
  default:
    | any
    | undefined;
  /**
   * Optional. SCHEMA FIELDS FOR TYPE ARRAY
   * Schema of the elements of Type.ARRAY.
   */
  items:
    | Schema
    | undefined;
  /** Optional. Minimum number of the elements for Type.ARRAY. */
  minItems: Long;
  /** Optional. Maximum number of the elements for Type.ARRAY. */
  maxItems: Long;
  /**
   * Optional. Possible values of the element of Type.STRING with enum format.
   * For example we can define an Enum Direction as :
   * {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
   */
  enum: string[];
  /**
   * Optional. SCHEMA FIELDS FOR TYPE OBJECT
   * Properties of Type.OBJECT.
   */
  properties: { [key: string]: Schema };
  /**
   * Optional. The order of the properties.
   * Not a standard field in open api spec. Only used to support the order of
   * the properties.
   */
  propertyOrdering: string[];
  /** Optional. Required properties of Type.OBJECT. */
  required: string[];
  /** Optional. Minimum number of the properties for Type.OBJECT. */
  minProperties: Long;
  /** Optional. Maximum number of the properties for Type.OBJECT. */
  maxProperties: Long;
  /**
   * Optional. SCHEMA FIELDS FOR TYPE INTEGER and NUMBER
   * Minimum value of the Type.INTEGER and Type.NUMBER
   */
  minimum: number;
  /** Optional. Maximum value of the Type.INTEGER and Type.NUMBER */
  maximum: number;
  /**
   * Optional. SCHEMA FIELDS FOR TYPE STRING
   * Minimum length of the Type.STRING
   */
  minLength: Long;
  /** Optional. Maximum length of the Type.STRING */
  maxLength: Long;
  /**
   * Optional. Pattern of the Type.STRING to restrict a string to a regular
   * expression.
   */
  pattern: string;
  /**
   * Optional. Example of the object. Will only populated when the object is the
   * root.
   */
  example:
    | any
    | undefined;
  /**
   * Optional. The value should be validated against any (one or more) of the
   * subschemas in the list.
   */
  anyOf: Schema[];
}

export interface Schema_PropertiesEntry {
  key: string;
  value: Schema | undefined;
}

function createBaseSchema(): Schema {
  return {
    type: 0,
    format: "",
    title: "",
    description: "",
    nullable: false,
    default: undefined,
    items: undefined,
    minItems: Long.ZERO,
    maxItems: Long.ZERO,
    enum: [],
    properties: {},
    propertyOrdering: [],
    required: [],
    minProperties: Long.ZERO,
    maxProperties: Long.ZERO,
    minimum: 0,
    maximum: 0,
    minLength: Long.ZERO,
    maxLength: Long.ZERO,
    pattern: "",
    example: undefined,
    anyOf: [],
  };
}

export const Schema: MessageFns<Schema> = {
  encode(message: Schema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.format !== "") {
      writer.uint32(58).string(message.format);
    }
    if (message.title !== "") {
      writer.uint32(194).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.nullable !== false) {
      writer.uint32(48).bool(message.nullable);
    }
    if (message.default !== undefined) {
      Value.encode(Value.wrap(message.default), writer.uint32(186).fork()).join();
    }
    if (message.items !== undefined) {
      Schema.encode(message.items, writer.uint32(18).fork()).join();
    }
    if (!message.minItems.equals(Long.ZERO)) {
      writer.uint32(168).int64(message.minItems.toString());
    }
    if (!message.maxItems.equals(Long.ZERO)) {
      writer.uint32(176).int64(message.maxItems.toString());
    }
    for (const v of message.enum) {
      writer.uint32(74).string(v!);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      Schema_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    for (const v of message.propertyOrdering) {
      writer.uint32(202).string(v!);
    }
    for (const v of message.required) {
      writer.uint32(42).string(v!);
    }
    if (!message.minProperties.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.minProperties.toString());
    }
    if (!message.maxProperties.equals(Long.ZERO)) {
      writer.uint32(120).int64(message.maxProperties.toString());
    }
    if (message.minimum !== 0) {
      writer.uint32(129).double(message.minimum);
    }
    if (message.maximum !== 0) {
      writer.uint32(137).double(message.maximum);
    }
    if (!message.minLength.equals(Long.ZERO)) {
      writer.uint32(144).int64(message.minLength.toString());
    }
    if (!message.maxLength.equals(Long.ZERO)) {
      writer.uint32(152).int64(message.maxLength.toString());
    }
    if (message.pattern !== "") {
      writer.uint32(162).string(message.pattern);
    }
    if (message.example !== undefined) {
      Value.encode(Value.wrap(message.example), writer.uint32(34).fork()).join();
    }
    for (const v of message.anyOf) {
      Schema.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.format = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.title = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.default = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.items = Schema.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.minItems = Long.fromString(reader.int64().toString());
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.maxItems = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.enum.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Schema_PropertiesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.properties[entry3.key] = entry3.value;
          }
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.propertyOrdering.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.required.push(reader.string());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.minProperties = Long.fromString(reader.int64().toString());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.maxProperties = Long.fromString(reader.int64().toString());
          continue;
        case 16:
          if (tag !== 129) {
            break;
          }

          message.minimum = reader.double();
          continue;
        case 17:
          if (tag !== 137) {
            break;
          }

          message.maximum = reader.double();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.minLength = Long.fromString(reader.int64().toString());
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.maxLength = Long.fromString(reader.int64().toString());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.pattern = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.example = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.anyOf.push(Schema.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema {
    return {
      type: isSet(object.type) ? typeFromJSON(object.type) : 0,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      default: isSet(object?.default) ? object.default : undefined,
      items: isSet(object.items) ? Schema.fromJSON(object.items) : undefined,
      minItems: isSet(object.minItems) ? Long.fromValue(object.minItems) : Long.ZERO,
      maxItems: isSet(object.maxItems) ? Long.fromValue(object.maxItems) : Long.ZERO,
      enum: globalThis.Array.isArray(object?.enum) ? object.enum.map((e: any) => globalThis.String(e)) : [],
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: Schema }>((acc, [key, value]) => {
          acc[key] = Schema.fromJSON(value);
          return acc;
        }, {})
        : {},
      propertyOrdering: globalThis.Array.isArray(object?.propertyOrdering)
        ? object.propertyOrdering.map((e: any) => globalThis.String(e))
        : [],
      required: globalThis.Array.isArray(object?.required) ? object.required.map((e: any) => globalThis.String(e)) : [],
      minProperties: isSet(object.minProperties) ? Long.fromValue(object.minProperties) : Long.ZERO,
      maxProperties: isSet(object.maxProperties) ? Long.fromValue(object.maxProperties) : Long.ZERO,
      minimum: isSet(object.minimum) ? globalThis.Number(object.minimum) : 0,
      maximum: isSet(object.maximum) ? globalThis.Number(object.maximum) : 0,
      minLength: isSet(object.minLength) ? Long.fromValue(object.minLength) : Long.ZERO,
      maxLength: isSet(object.maxLength) ? Long.fromValue(object.maxLength) : Long.ZERO,
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
      example: isSet(object?.example) ? object.example : undefined,
      anyOf: globalThis.Array.isArray(object?.anyOf) ? object.anyOf.map((e: any) => Schema.fromJSON(e)) : [],
    };
  },

  toJSON(message: Schema): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = typeToJSON(message.type);
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.default !== undefined) {
      obj.default = message.default;
    }
    if (message.items !== undefined) {
      obj.items = Schema.toJSON(message.items);
    }
    if (!message.minItems.equals(Long.ZERO)) {
      obj.minItems = (message.minItems || Long.ZERO).toString();
    }
    if (!message.maxItems.equals(Long.ZERO)) {
      obj.maxItems = (message.maxItems || Long.ZERO).toString();
    }
    if (message.enum?.length) {
      obj.enum = message.enum;
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = Schema.toJSON(v);
        });
      }
    }
    if (message.propertyOrdering?.length) {
      obj.propertyOrdering = message.propertyOrdering;
    }
    if (message.required?.length) {
      obj.required = message.required;
    }
    if (!message.minProperties.equals(Long.ZERO)) {
      obj.minProperties = (message.minProperties || Long.ZERO).toString();
    }
    if (!message.maxProperties.equals(Long.ZERO)) {
      obj.maxProperties = (message.maxProperties || Long.ZERO).toString();
    }
    if (message.minimum !== 0) {
      obj.minimum = message.minimum;
    }
    if (message.maximum !== 0) {
      obj.maximum = message.maximum;
    }
    if (!message.minLength.equals(Long.ZERO)) {
      obj.minLength = (message.minLength || Long.ZERO).toString();
    }
    if (!message.maxLength.equals(Long.ZERO)) {
      obj.maxLength = (message.maxLength || Long.ZERO).toString();
    }
    if (message.pattern !== "") {
      obj.pattern = message.pattern;
    }
    if (message.example !== undefined) {
      obj.example = message.example;
    }
    if (message.anyOf?.length) {
      obj.anyOf = message.anyOf.map((e) => Schema.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Schema>): Schema {
    return Schema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Schema>): Schema {
    const message = createBaseSchema();
    message.type = object.type ?? 0;
    message.format = object.format ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.nullable = object.nullable ?? false;
    message.default = object.default ?? undefined;
    message.items = (object.items !== undefined && object.items !== null)
      ? Schema.fromPartial(object.items)
      : undefined;
    message.minItems = (object.minItems !== undefined && object.minItems !== null)
      ? Long.fromValue(object.minItems)
      : Long.ZERO;
    message.maxItems = (object.maxItems !== undefined && object.maxItems !== null)
      ? Long.fromValue(object.maxItems)
      : Long.ZERO;
    message.enum = object.enum?.map((e) => e) || [];
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: Schema }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Schema.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.propertyOrdering = object.propertyOrdering?.map((e) => e) || [];
    message.required = object.required?.map((e) => e) || [];
    message.minProperties = (object.minProperties !== undefined && object.minProperties !== null)
      ? Long.fromValue(object.minProperties)
      : Long.ZERO;
    message.maxProperties = (object.maxProperties !== undefined && object.maxProperties !== null)
      ? Long.fromValue(object.maxProperties)
      : Long.ZERO;
    message.minimum = object.minimum ?? 0;
    message.maximum = object.maximum ?? 0;
    message.minLength = (object.minLength !== undefined && object.minLength !== null)
      ? Long.fromValue(object.minLength)
      : Long.ZERO;
    message.maxLength = (object.maxLength !== undefined && object.maxLength !== null)
      ? Long.fromValue(object.maxLength)
      : Long.ZERO;
    message.pattern = object.pattern ?? "";
    message.example = object.example ?? undefined;
    message.anyOf = object.anyOf?.map((e) => Schema.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSchema_PropertiesEntry(): Schema_PropertiesEntry {
  return { key: "", value: undefined };
}

export const Schema_PropertiesEntry: MessageFns<Schema_PropertiesEntry> = {
  encode(message: Schema_PropertiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Schema.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schema_PropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Schema.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Schema.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Schema_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Schema.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Schema_PropertiesEntry>): Schema_PropertiesEntry {
    return Schema_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Schema_PropertiesEntry>): Schema_PropertiesEntry {
    const message = createBaseSchema_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Schema.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
