// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1beta1/evaluated_annotation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Value } from "../../../protobuf/struct.js";
import { Explanation } from "./explanation.js";

export const protobufPackage = "google.cloud.aiplatform.v1beta1";

/**
 * True positive, false positive, or false negative.
 *
 * EvaluatedAnnotation is only available under ModelEvaluationSlice with slice
 * of `annotationSpec` dimension.
 */
export interface EvaluatedAnnotation {
  /** Output only. Type of the EvaluatedAnnotation. */
  type: EvaluatedAnnotation_EvaluatedAnnotationType;
  /**
   * Output only. The model predicted annotations.
   *
   * For true positive, there is one and only one prediction, which matches the
   * only one ground truth annotation in
   * [ground_truths][google.cloud.aiplatform.v1beta1.EvaluatedAnnotation.ground_truths].
   *
   * For false positive, there is one and only one prediction, which doesn't
   * match any ground truth annotation of the corresponding
   * [data_item_view_id][EvaluatedAnnotation.data_item_view_id].
   *
   * For false negative, there are zero or more predictions which are similar to
   * the only ground truth annotation in
   * [ground_truths][google.cloud.aiplatform.v1beta1.EvaluatedAnnotation.ground_truths]
   * but not enough for a match.
   *
   * The schema of the prediction is stored in
   * [ModelEvaluation.annotation_schema_uri][]
   */
  predictions: any[];
  /**
   * Output only. The ground truth Annotations, i.e. the Annotations that exist
   * in the test data the Model is evaluated on.
   *
   * For true positive, there is one and only one ground truth annotation, which
   * matches the only prediction in
   * [predictions][google.cloud.aiplatform.v1beta1.EvaluatedAnnotation.predictions].
   *
   * For false positive, there are zero or more ground truth annotations that
   * are similar to the only prediction in
   * [predictions][google.cloud.aiplatform.v1beta1.EvaluatedAnnotation.predictions],
   * but not enough for a match.
   *
   * For false negative, there is one and only one ground truth annotation,
   * which doesn't match any predictions created by the model.
   *
   * The schema of the ground truth is stored in
   * [ModelEvaluation.annotation_schema_uri][]
   */
  groundTruths: any[];
  /**
   * Output only. The data item payload that the Model predicted this
   * EvaluatedAnnotation on.
   */
  dataItemPayload:
    | any
    | undefined;
  /**
   * Output only. ID of the EvaluatedDataItemView under the same ancestor
   * ModelEvaluation. The EvaluatedDataItemView consists of all ground truths
   * and predictions on
   * [data_item_payload][google.cloud.aiplatform.v1beta1.EvaluatedAnnotation.data_item_payload].
   */
  evaluatedDataItemViewId: string;
  /**
   * Explanations of
   * [predictions][google.cloud.aiplatform.v1beta1.EvaluatedAnnotation.predictions].
   * Each element of the explanations indicates the explanation for one
   * explanation Method.
   *
   * The attributions list in the
   * [EvaluatedAnnotationExplanation.explanation][google.cloud.aiplatform.v1beta1.EvaluatedAnnotationExplanation.explanation]
   * object corresponds to the
   * [predictions][google.cloud.aiplatform.v1beta1.EvaluatedAnnotation.predictions]
   * list. For example, the second element in the attributions list explains the
   * second element in the predictions list.
   */
  explanations: EvaluatedAnnotationExplanation[];
  /** Annotations of model error analysis results. */
  errorAnalysisAnnotations: ErrorAnalysisAnnotation[];
}

/** Describes the type of the EvaluatedAnnotation. The type is determined */
export enum EvaluatedAnnotation_EvaluatedAnnotationType {
  /** EVALUATED_ANNOTATION_TYPE_UNSPECIFIED - Invalid value. */
  EVALUATED_ANNOTATION_TYPE_UNSPECIFIED = 0,
  /**
   * TRUE_POSITIVE - The EvaluatedAnnotation is a true positive. It has a prediction created
   * by the Model and a ground truth Annotation which the prediction matches.
   */
  TRUE_POSITIVE = 1,
  /**
   * FALSE_POSITIVE - The EvaluatedAnnotation is false positive. It has a prediction created by
   * the Model which does not match any ground truth annotation.
   */
  FALSE_POSITIVE = 2,
  /**
   * FALSE_NEGATIVE - The EvaluatedAnnotation is false negative. It has a ground truth
   * annotation which is not matched by any of the model created predictions.
   */
  FALSE_NEGATIVE = 3,
  UNRECOGNIZED = -1,
}

export function evaluatedAnnotation_EvaluatedAnnotationTypeFromJSON(
  object: any,
): EvaluatedAnnotation_EvaluatedAnnotationType {
  switch (object) {
    case 0:
    case "EVALUATED_ANNOTATION_TYPE_UNSPECIFIED":
      return EvaluatedAnnotation_EvaluatedAnnotationType.EVALUATED_ANNOTATION_TYPE_UNSPECIFIED;
    case 1:
    case "TRUE_POSITIVE":
      return EvaluatedAnnotation_EvaluatedAnnotationType.TRUE_POSITIVE;
    case 2:
    case "FALSE_POSITIVE":
      return EvaluatedAnnotation_EvaluatedAnnotationType.FALSE_POSITIVE;
    case 3:
    case "FALSE_NEGATIVE":
      return EvaluatedAnnotation_EvaluatedAnnotationType.FALSE_NEGATIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EvaluatedAnnotation_EvaluatedAnnotationType.UNRECOGNIZED;
  }
}

export function evaluatedAnnotation_EvaluatedAnnotationTypeToJSON(
  object: EvaluatedAnnotation_EvaluatedAnnotationType,
): string {
  switch (object) {
    case EvaluatedAnnotation_EvaluatedAnnotationType.EVALUATED_ANNOTATION_TYPE_UNSPECIFIED:
      return "EVALUATED_ANNOTATION_TYPE_UNSPECIFIED";
    case EvaluatedAnnotation_EvaluatedAnnotationType.TRUE_POSITIVE:
      return "TRUE_POSITIVE";
    case EvaluatedAnnotation_EvaluatedAnnotationType.FALSE_POSITIVE:
      return "FALSE_POSITIVE";
    case EvaluatedAnnotation_EvaluatedAnnotationType.FALSE_NEGATIVE:
      return "FALSE_NEGATIVE";
    case EvaluatedAnnotation_EvaluatedAnnotationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Explanation result of the prediction produced by the Model. */
export interface EvaluatedAnnotationExplanation {
  /**
   * Explanation type.
   *
   * For AutoML Image Classification models, possible values are:
   *
   *   * `image-integrated-gradients`
   *   * `image-xrai`
   */
  explanationType: string;
  /** Explanation attribution response details. */
  explanation: Explanation | undefined;
}

/** Model error analysis for each annotation. */
export interface ErrorAnalysisAnnotation {
  /**
   * Attributed items for a given annotation, typically representing neighbors
   * from the training sets constrained by the query type.
   */
  attributedItems: ErrorAnalysisAnnotation_AttributedItem[];
  /** The query type used for finding the attributed items. */
  queryType: ErrorAnalysisAnnotation_QueryType;
  /**
   * The outlier score of this annotated item. Usually defined as the min of all
   * distances from attributed items.
   */
  outlierScore: number;
  /** The threshold used to determine if this annotation is an outlier or not. */
  outlierThreshold: number;
}

/** The query type used for finding the attributed items. */
export enum ErrorAnalysisAnnotation_QueryType {
  /** QUERY_TYPE_UNSPECIFIED - Unspecified query type for model error analysis. */
  QUERY_TYPE_UNSPECIFIED = 0,
  /** ALL_SIMILAR - Query similar samples across all classes in the dataset. */
  ALL_SIMILAR = 1,
  /** SAME_CLASS_SIMILAR - Query similar samples from the same class of the input sample. */
  SAME_CLASS_SIMILAR = 2,
  /** SAME_CLASS_DISSIMILAR - Query dissimilar samples from the same class of the input sample. */
  SAME_CLASS_DISSIMILAR = 3,
  UNRECOGNIZED = -1,
}

export function errorAnalysisAnnotation_QueryTypeFromJSON(object: any): ErrorAnalysisAnnotation_QueryType {
  switch (object) {
    case 0:
    case "QUERY_TYPE_UNSPECIFIED":
      return ErrorAnalysisAnnotation_QueryType.QUERY_TYPE_UNSPECIFIED;
    case 1:
    case "ALL_SIMILAR":
      return ErrorAnalysisAnnotation_QueryType.ALL_SIMILAR;
    case 2:
    case "SAME_CLASS_SIMILAR":
      return ErrorAnalysisAnnotation_QueryType.SAME_CLASS_SIMILAR;
    case 3:
    case "SAME_CLASS_DISSIMILAR":
      return ErrorAnalysisAnnotation_QueryType.SAME_CLASS_DISSIMILAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorAnalysisAnnotation_QueryType.UNRECOGNIZED;
  }
}

export function errorAnalysisAnnotation_QueryTypeToJSON(object: ErrorAnalysisAnnotation_QueryType): string {
  switch (object) {
    case ErrorAnalysisAnnotation_QueryType.QUERY_TYPE_UNSPECIFIED:
      return "QUERY_TYPE_UNSPECIFIED";
    case ErrorAnalysisAnnotation_QueryType.ALL_SIMILAR:
      return "ALL_SIMILAR";
    case ErrorAnalysisAnnotation_QueryType.SAME_CLASS_SIMILAR:
      return "SAME_CLASS_SIMILAR";
    case ErrorAnalysisAnnotation_QueryType.SAME_CLASS_DISSIMILAR:
      return "SAME_CLASS_DISSIMILAR";
    case ErrorAnalysisAnnotation_QueryType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Attributed items for a given annotation, typically representing neighbors
 * from the training sets constrained by the query type.
 */
export interface ErrorAnalysisAnnotation_AttributedItem {
  /**
   * The unique ID for each annotation. Used by FE to allocate the annotation
   * in DB.
   */
  annotationResourceName: string;
  /** The distance of this item to the annotation. */
  distance: number;
}

function createBaseEvaluatedAnnotation(): EvaluatedAnnotation {
  return {
    type: 0,
    predictions: [],
    groundTruths: [],
    dataItemPayload: undefined,
    evaluatedDataItemViewId: "",
    explanations: [],
    errorAnalysisAnnotations: [],
  };
}

export const EvaluatedAnnotation: MessageFns<EvaluatedAnnotation> = {
  encode(message: EvaluatedAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.predictions) {
      Value.encode(Value.wrap(v!), writer.uint32(18).fork()).join();
    }
    for (const v of message.groundTruths) {
      Value.encode(Value.wrap(v!), writer.uint32(26).fork()).join();
    }
    if (message.dataItemPayload !== undefined) {
      Value.encode(Value.wrap(message.dataItemPayload), writer.uint32(42).fork()).join();
    }
    if (message.evaluatedDataItemViewId !== "") {
      writer.uint32(50).string(message.evaluatedDataItemViewId);
    }
    for (const v of message.explanations) {
      EvaluatedAnnotationExplanation.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.errorAnalysisAnnotations) {
      ErrorAnalysisAnnotation.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluatedAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluatedAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.predictions.push(Value.unwrap(Value.decode(reader, reader.uint32())));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.groundTruths.push(Value.unwrap(Value.decode(reader, reader.uint32())));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dataItemPayload = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.evaluatedDataItemViewId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.explanations.push(EvaluatedAnnotationExplanation.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.errorAnalysisAnnotations.push(ErrorAnalysisAnnotation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluatedAnnotation {
    return {
      type: isSet(object.type) ? evaluatedAnnotation_EvaluatedAnnotationTypeFromJSON(object.type) : 0,
      predictions: globalThis.Array.isArray(object?.predictions) ? [...object.predictions] : [],
      groundTruths: globalThis.Array.isArray(object?.groundTruths) ? [...object.groundTruths] : [],
      dataItemPayload: isSet(object?.dataItemPayload) ? object.dataItemPayload : undefined,
      evaluatedDataItemViewId: isSet(object.evaluatedDataItemViewId)
        ? globalThis.String(object.evaluatedDataItemViewId)
        : "",
      explanations: globalThis.Array.isArray(object?.explanations)
        ? object.explanations.map((e: any) => EvaluatedAnnotationExplanation.fromJSON(e))
        : [],
      errorAnalysisAnnotations: globalThis.Array.isArray(object?.errorAnalysisAnnotations)
        ? object.errorAnalysisAnnotations.map((e: any) => ErrorAnalysisAnnotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EvaluatedAnnotation): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = evaluatedAnnotation_EvaluatedAnnotationTypeToJSON(message.type);
    }
    if (message.predictions?.length) {
      obj.predictions = message.predictions;
    }
    if (message.groundTruths?.length) {
      obj.groundTruths = message.groundTruths;
    }
    if (message.dataItemPayload !== undefined) {
      obj.dataItemPayload = message.dataItemPayload;
    }
    if (message.evaluatedDataItemViewId !== "") {
      obj.evaluatedDataItemViewId = message.evaluatedDataItemViewId;
    }
    if (message.explanations?.length) {
      obj.explanations = message.explanations.map((e) => EvaluatedAnnotationExplanation.toJSON(e));
    }
    if (message.errorAnalysisAnnotations?.length) {
      obj.errorAnalysisAnnotations = message.errorAnalysisAnnotations.map((e) => ErrorAnalysisAnnotation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EvaluatedAnnotation>): EvaluatedAnnotation {
    return EvaluatedAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EvaluatedAnnotation>): EvaluatedAnnotation {
    const message = createBaseEvaluatedAnnotation();
    message.type = object.type ?? 0;
    message.predictions = object.predictions?.map((e) => e) || [];
    message.groundTruths = object.groundTruths?.map((e) => e) || [];
    message.dataItemPayload = object.dataItemPayload ?? undefined;
    message.evaluatedDataItemViewId = object.evaluatedDataItemViewId ?? "";
    message.explanations = object.explanations?.map((e) => EvaluatedAnnotationExplanation.fromPartial(e)) || [];
    message.errorAnalysisAnnotations =
      object.errorAnalysisAnnotations?.map((e) => ErrorAnalysisAnnotation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEvaluatedAnnotationExplanation(): EvaluatedAnnotationExplanation {
  return { explanationType: "", explanation: undefined };
}

export const EvaluatedAnnotationExplanation: MessageFns<EvaluatedAnnotationExplanation> = {
  encode(message: EvaluatedAnnotationExplanation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.explanationType !== "") {
      writer.uint32(10).string(message.explanationType);
    }
    if (message.explanation !== undefined) {
      Explanation.encode(message.explanation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluatedAnnotationExplanation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluatedAnnotationExplanation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.explanationType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explanation = Explanation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluatedAnnotationExplanation {
    return {
      explanationType: isSet(object.explanationType) ? globalThis.String(object.explanationType) : "",
      explanation: isSet(object.explanation) ? Explanation.fromJSON(object.explanation) : undefined,
    };
  },

  toJSON(message: EvaluatedAnnotationExplanation): unknown {
    const obj: any = {};
    if (message.explanationType !== "") {
      obj.explanationType = message.explanationType;
    }
    if (message.explanation !== undefined) {
      obj.explanation = Explanation.toJSON(message.explanation);
    }
    return obj;
  },

  create(base?: DeepPartial<EvaluatedAnnotationExplanation>): EvaluatedAnnotationExplanation {
    return EvaluatedAnnotationExplanation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EvaluatedAnnotationExplanation>): EvaluatedAnnotationExplanation {
    const message = createBaseEvaluatedAnnotationExplanation();
    message.explanationType = object.explanationType ?? "";
    message.explanation = (object.explanation !== undefined && object.explanation !== null)
      ? Explanation.fromPartial(object.explanation)
      : undefined;
    return message;
  },
};

function createBaseErrorAnalysisAnnotation(): ErrorAnalysisAnnotation {
  return { attributedItems: [], queryType: 0, outlierScore: 0, outlierThreshold: 0 };
}

export const ErrorAnalysisAnnotation: MessageFns<ErrorAnalysisAnnotation> = {
  encode(message: ErrorAnalysisAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attributedItems) {
      ErrorAnalysisAnnotation_AttributedItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.queryType !== 0) {
      writer.uint32(16).int32(message.queryType);
    }
    if (message.outlierScore !== 0) {
      writer.uint32(25).double(message.outlierScore);
    }
    if (message.outlierThreshold !== 0) {
      writer.uint32(33).double(message.outlierThreshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorAnalysisAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorAnalysisAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributedItems.push(ErrorAnalysisAnnotation_AttributedItem.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.queryType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.outlierScore = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.outlierThreshold = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorAnalysisAnnotation {
    return {
      attributedItems: globalThis.Array.isArray(object?.attributedItems)
        ? object.attributedItems.map((e: any) => ErrorAnalysisAnnotation_AttributedItem.fromJSON(e))
        : [],
      queryType: isSet(object.queryType) ? errorAnalysisAnnotation_QueryTypeFromJSON(object.queryType) : 0,
      outlierScore: isSet(object.outlierScore) ? globalThis.Number(object.outlierScore) : 0,
      outlierThreshold: isSet(object.outlierThreshold) ? globalThis.Number(object.outlierThreshold) : 0,
    };
  },

  toJSON(message: ErrorAnalysisAnnotation): unknown {
    const obj: any = {};
    if (message.attributedItems?.length) {
      obj.attributedItems = message.attributedItems.map((e) => ErrorAnalysisAnnotation_AttributedItem.toJSON(e));
    }
    if (message.queryType !== 0) {
      obj.queryType = errorAnalysisAnnotation_QueryTypeToJSON(message.queryType);
    }
    if (message.outlierScore !== 0) {
      obj.outlierScore = message.outlierScore;
    }
    if (message.outlierThreshold !== 0) {
      obj.outlierThreshold = message.outlierThreshold;
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorAnalysisAnnotation>): ErrorAnalysisAnnotation {
    return ErrorAnalysisAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorAnalysisAnnotation>): ErrorAnalysisAnnotation {
    const message = createBaseErrorAnalysisAnnotation();
    message.attributedItems =
      object.attributedItems?.map((e) => ErrorAnalysisAnnotation_AttributedItem.fromPartial(e)) || [];
    message.queryType = object.queryType ?? 0;
    message.outlierScore = object.outlierScore ?? 0;
    message.outlierThreshold = object.outlierThreshold ?? 0;
    return message;
  },
};

function createBaseErrorAnalysisAnnotation_AttributedItem(): ErrorAnalysisAnnotation_AttributedItem {
  return { annotationResourceName: "", distance: 0 };
}

export const ErrorAnalysisAnnotation_AttributedItem: MessageFns<ErrorAnalysisAnnotation_AttributedItem> = {
  encode(message: ErrorAnalysisAnnotation_AttributedItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationResourceName !== "") {
      writer.uint32(10).string(message.annotationResourceName);
    }
    if (message.distance !== 0) {
      writer.uint32(17).double(message.distance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorAnalysisAnnotation_AttributedItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorAnalysisAnnotation_AttributedItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationResourceName = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.distance = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorAnalysisAnnotation_AttributedItem {
    return {
      annotationResourceName: isSet(object.annotationResourceName)
        ? globalThis.String(object.annotationResourceName)
        : "",
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
    };
  },

  toJSON(message: ErrorAnalysisAnnotation_AttributedItem): unknown {
    const obj: any = {};
    if (message.annotationResourceName !== "") {
      obj.annotationResourceName = message.annotationResourceName;
    }
    if (message.distance !== 0) {
      obj.distance = message.distance;
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorAnalysisAnnotation_AttributedItem>): ErrorAnalysisAnnotation_AttributedItem {
    return ErrorAnalysisAnnotation_AttributedItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorAnalysisAnnotation_AttributedItem>): ErrorAnalysisAnnotation_AttributedItem {
    const message = createBaseErrorAnalysisAnnotation_AttributedItem();
    message.annotationResourceName = object.annotationResourceName ?? "";
    message.distance = object.distance ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
