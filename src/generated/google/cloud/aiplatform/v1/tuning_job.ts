// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1/tuning_job.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { Content } from "./content.js";
import { EncryptionSpec } from "./encryption_spec.js";
import { JobState, jobStateFromJSON, jobStateToJSON } from "./job_state.js";

export const protobufPackage = "google.cloud.aiplatform.v1";

/** Represents a TuningJob that runs with Google owned models. */
export interface TuningJob {
  /** The base model that is being tuned, e.g., "gemini-1.0-pro-002". */
  baseModel?:
    | string
    | undefined;
  /** Tuning Spec for Supervised Fine Tuning. */
  supervisedTuningSpec?:
    | SupervisedTuningSpec
    | undefined;
  /**
   * Output only. Identifier. Resource name of a TuningJob. Format:
   * `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
   */
  name: string;
  /**
   * Optional. The display name of the
   * [TunedModel][google.cloud.aiplatform.v1.Model]. The name can be up to 128
   * characters long and can consist of any UTF-8 characters.
   */
  tunedModelDisplayName: string;
  /**
   * Optional. The description of the
   * [TuningJob][google.cloud.aiplatform.v1.TuningJob].
   */
  description: string;
  /** Output only. The detailed state of the job. */
  state: JobState;
  /**
   * Output only. Time when the
   * [TuningJob][google.cloud.aiplatform.v1.TuningJob] was created.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. Time when the
   * [TuningJob][google.cloud.aiplatform.v1.TuningJob] for the first time
   * entered the `JOB_STATE_RUNNING` state.
   */
  startTime:
    | Date
    | undefined;
  /**
   * Output only. Time when the TuningJob entered any of the following
   * [JobStates][google.cloud.aiplatform.v1.JobState]: `JOB_STATE_SUCCEEDED`,
   * `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`, `JOB_STATE_EXPIRED`.
   */
  endTime:
    | Date
    | undefined;
  /**
   * Output only. Time when the
   * [TuningJob][google.cloud.aiplatform.v1.TuningJob] was most recently
   * updated.
   */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. Only populated when job's state is `JOB_STATE_FAILED` or
   * `JOB_STATE_CANCELLED`.
   */
  error:
    | Status
    | undefined;
  /**
   * Optional. The labels with user-defined metadata to organize
   * [TuningJob][google.cloud.aiplatform.v1.TuningJob] and generated resources
   * such as [Model][google.cloud.aiplatform.v1.Model] and
   * [Endpoint][google.cloud.aiplatform.v1.Endpoint].
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   */
  labels: { [key: string]: string };
  /**
   * Output only. The Experiment associated with this
   * [TuningJob][google.cloud.aiplatform.v1.TuningJob].
   */
  experiment: string;
  /**
   * Output only. The tuned model resources assiociated with this
   * [TuningJob][google.cloud.aiplatform.v1.TuningJob].
   */
  tunedModel:
    | TunedModel
    | undefined;
  /**
   * Output only. The tuning data statistics associated with this
   * [TuningJob][google.cloud.aiplatform.v1.TuningJob].
   */
  tuningDataStats:
    | TuningDataStats
    | undefined;
  /**
   * Customer-managed encryption key options for a TuningJob. If this is set,
   * then all resources created by the TuningJob will be encrypted with the
   * provided encryption key.
   */
  encryptionSpec: EncryptionSpec | undefined;
}

export interface TuningJob_LabelsEntry {
  key: string;
  value: string;
}

/**
 * The Model Registry Model and Online Prediction Endpoint assiociated with
 * this [TuningJob][google.cloud.aiplatform.v1.TuningJob].
 */
export interface TunedModel {
  /**
   * Output only. The resource name of the TunedModel. Format:
   * `projects/{project}/locations/{location}/models/{model}`.
   */
  model: string;
  /**
   * Output only. A resource name of an Endpoint. Format:
   * `projects/{project}/locations/{location}/endpoints/{endpoint}`.
   */
  endpoint: string;
}

/** Dataset distribution for Supervised Tuning. */
export interface SupervisedTuningDatasetDistribution {
  /** Output only. Sum of a given population of values. */
  sum: Long;
  /** Output only. Sum of a given population of values that are billable. */
  billableSum: Long;
  /** Output only. The minimum of the population values. */
  min: number;
  /** Output only. The maximum of the population values. */
  max: number;
  /** Output only. The arithmetic mean of the values in the population. */
  mean: number;
  /** Output only. The median of the values in the population. */
  median: number;
  /** Output only. The 5th percentile of the values in the population. */
  p5: number;
  /** Output only. The 95th percentile of the values in the population. */
  p95: number;
  /** Output only. Defines the histogram bucket. */
  buckets: SupervisedTuningDatasetDistribution_DatasetBucket[];
}

/**
 * Dataset bucket used to create a histogram for the distribution given a
 * population of values.
 */
export interface SupervisedTuningDatasetDistribution_DatasetBucket {
  /** Output only. Number of values in the bucket. */
  count: number;
  /** Output only. Left bound of the bucket. */
  left: number;
  /** Output only. Right bound of the bucket. */
  right: number;
}

/** Tuning data statistics for Supervised Tuning. */
export interface SupervisedTuningDataStats {
  /** Output only. Number of examples in the tuning dataset. */
  tuningDatasetExampleCount: Long;
  /** Output only. Number of tuning characters in the tuning dataset. */
  totalTuningCharacterCount: Long;
  /**
   * Output only. Number of billable characters in the tuning dataset.
   *
   * @deprecated
   */
  totalBillableCharacterCount: Long;
  /** Output only. Number of billable tokens in the tuning dataset. */
  totalBillableTokenCount: Long;
  /** Output only. Number of tuning steps for this Tuning Job. */
  tuningStepCount: Long;
  /** Output only. Dataset distributions for the user input tokens. */
  userInputTokenDistribution:
    | SupervisedTuningDatasetDistribution
    | undefined;
  /** Output only. Dataset distributions for the user output tokens. */
  userOutputTokenDistribution:
    | SupervisedTuningDatasetDistribution
    | undefined;
  /** Output only. Dataset distributions for the messages per example. */
  userMessagePerExampleDistribution:
    | SupervisedTuningDatasetDistribution
    | undefined;
  /** Output only. Sample user messages in the training dataset uri. */
  userDatasetExamples: Content[];
  /**
   * The number of examples in the dataset that have been truncated by any
   * amount.
   */
  totalTruncatedExampleCount: Long;
  /**
   * A partial sample of the indices (starting from 1) of the truncated
   * examples.
   */
  truncatedExampleIndices: Long[];
}

/**
 * The tuning data statistic values for
 * [TuningJob][google.cloud.aiplatform.v1.TuningJob].
 */
export interface TuningDataStats {
  /** The SFT Tuning data stats. */
  supervisedTuningDataStats?: SupervisedTuningDataStats | undefined;
}

/** Hyperparameters for SFT. */
export interface SupervisedHyperParameters {
  /**
   * Optional. Number of complete passes the model makes over the entire
   * training dataset during training.
   */
  epochCount: Long;
  /** Optional. Multiplier for adjusting the default learning rate. */
  learningRateMultiplier: number;
  /** Optional. Adapter size for tuning. */
  adapterSize: SupervisedHyperParameters_AdapterSize;
}

/** Supported adapter sizes for tuning. */
export enum SupervisedHyperParameters_AdapterSize {
  /** ADAPTER_SIZE_UNSPECIFIED - Adapter size is unspecified. */
  ADAPTER_SIZE_UNSPECIFIED = 0,
  /** ADAPTER_SIZE_ONE - Adapter size 1. */
  ADAPTER_SIZE_ONE = 1,
  /** ADAPTER_SIZE_FOUR - Adapter size 4. */
  ADAPTER_SIZE_FOUR = 2,
  /** ADAPTER_SIZE_EIGHT - Adapter size 8. */
  ADAPTER_SIZE_EIGHT = 3,
  /** ADAPTER_SIZE_SIXTEEN - Adapter size 16. */
  ADAPTER_SIZE_SIXTEEN = 4,
  UNRECOGNIZED = -1,
}

export function supervisedHyperParameters_AdapterSizeFromJSON(object: any): SupervisedHyperParameters_AdapterSize {
  switch (object) {
    case 0:
    case "ADAPTER_SIZE_UNSPECIFIED":
      return SupervisedHyperParameters_AdapterSize.ADAPTER_SIZE_UNSPECIFIED;
    case 1:
    case "ADAPTER_SIZE_ONE":
      return SupervisedHyperParameters_AdapterSize.ADAPTER_SIZE_ONE;
    case 2:
    case "ADAPTER_SIZE_FOUR":
      return SupervisedHyperParameters_AdapterSize.ADAPTER_SIZE_FOUR;
    case 3:
    case "ADAPTER_SIZE_EIGHT":
      return SupervisedHyperParameters_AdapterSize.ADAPTER_SIZE_EIGHT;
    case 4:
    case "ADAPTER_SIZE_SIXTEEN":
      return SupervisedHyperParameters_AdapterSize.ADAPTER_SIZE_SIXTEEN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SupervisedHyperParameters_AdapterSize.UNRECOGNIZED;
  }
}

export function supervisedHyperParameters_AdapterSizeToJSON(object: SupervisedHyperParameters_AdapterSize): string {
  switch (object) {
    case SupervisedHyperParameters_AdapterSize.ADAPTER_SIZE_UNSPECIFIED:
      return "ADAPTER_SIZE_UNSPECIFIED";
    case SupervisedHyperParameters_AdapterSize.ADAPTER_SIZE_ONE:
      return "ADAPTER_SIZE_ONE";
    case SupervisedHyperParameters_AdapterSize.ADAPTER_SIZE_FOUR:
      return "ADAPTER_SIZE_FOUR";
    case SupervisedHyperParameters_AdapterSize.ADAPTER_SIZE_EIGHT:
      return "ADAPTER_SIZE_EIGHT";
    case SupervisedHyperParameters_AdapterSize.ADAPTER_SIZE_SIXTEEN:
      return "ADAPTER_SIZE_SIXTEEN";
    case SupervisedHyperParameters_AdapterSize.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Tuning Spec for Supervised Tuning for first party models. */
export interface SupervisedTuningSpec {
  /**
   * Required. Cloud Storage path to file containing training dataset for
   * tuning. The dataset must be formatted as a JSONL file.
   */
  trainingDatasetUri: string;
  /**
   * Optional. Cloud Storage path to file containing validation dataset for
   * tuning. The dataset must be formatted as a JSONL file.
   */
  validationDatasetUri: string;
  /** Optional. Hyperparameters for SFT. */
  hyperParameters: SupervisedHyperParameters | undefined;
}

/** TunedModel Reference for legacy model migration. */
export interface TunedModelRef {
  /** Support migration from model registry. */
  tunedModel?:
    | string
    | undefined;
  /**
   * Support migration from tuning job list page, from gemini-1.0-pro-002
   * to 1.5 and above.
   */
  tuningJob?:
    | string
    | undefined;
  /**
   * Support migration from tuning job list page, from bison model to gemini
   * model.
   */
  pipelineJob?: string | undefined;
}

function createBaseTuningJob(): TuningJob {
  return {
    baseModel: undefined,
    supervisedTuningSpec: undefined,
    name: "",
    tunedModelDisplayName: "",
    description: "",
    state: 0,
    createTime: undefined,
    startTime: undefined,
    endTime: undefined,
    updateTime: undefined,
    error: undefined,
    labels: {},
    experiment: "",
    tunedModel: undefined,
    tuningDataStats: undefined,
    encryptionSpec: undefined,
  };
}

export const TuningJob: MessageFns<TuningJob> = {
  encode(message: TuningJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseModel !== undefined) {
      writer.uint32(34).string(message.baseModel);
    }
    if (message.supervisedTuningSpec !== undefined) {
      SupervisedTuningSpec.encode(message.supervisedTuningSpec, writer.uint32(42).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.tunedModelDisplayName !== "") {
      writer.uint32(18).string(message.tunedModelDisplayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(66).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(90).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      TuningJob_LabelsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    if (message.experiment !== "") {
      writer.uint32(106).string(message.experiment);
    }
    if (message.tunedModel !== undefined) {
      TunedModel.encode(message.tunedModel, writer.uint32(114).fork()).join();
    }
    if (message.tuningDataStats !== undefined) {
      TuningDataStats.encode(message.tuningDataStats, writer.uint32(122).fork()).join();
    }
    if (message.encryptionSpec !== undefined) {
      EncryptionSpec.encode(message.encryptionSpec, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TuningJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuningJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.baseModel = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.supervisedTuningSpec = SupervisedTuningSpec.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tunedModelDisplayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = TuningJob_LabelsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.labels[entry12.key] = entry12.value;
          }
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.experiment = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.tunedModel = TunedModel.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.tuningDataStats = TuningDataStats.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.encryptionSpec = EncryptionSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TuningJob {
    return {
      baseModel: isSet(object.baseModel) ? globalThis.String(object.baseModel) : undefined,
      supervisedTuningSpec: isSet(object.supervisedTuningSpec)
        ? SupervisedTuningSpec.fromJSON(object.supervisedTuningSpec)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tunedModelDisplayName: isSet(object.tunedModelDisplayName) ? globalThis.String(object.tunedModelDisplayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? jobStateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      experiment: isSet(object.experiment) ? globalThis.String(object.experiment) : "",
      tunedModel: isSet(object.tunedModel) ? TunedModel.fromJSON(object.tunedModel) : undefined,
      tuningDataStats: isSet(object.tuningDataStats) ? TuningDataStats.fromJSON(object.tuningDataStats) : undefined,
      encryptionSpec: isSet(object.encryptionSpec) ? EncryptionSpec.fromJSON(object.encryptionSpec) : undefined,
    };
  },

  toJSON(message: TuningJob): unknown {
    const obj: any = {};
    if (message.baseModel !== undefined) {
      obj.baseModel = message.baseModel;
    }
    if (message.supervisedTuningSpec !== undefined) {
      obj.supervisedTuningSpec = SupervisedTuningSpec.toJSON(message.supervisedTuningSpec);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tunedModelDisplayName !== "") {
      obj.tunedModelDisplayName = message.tunedModelDisplayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== 0) {
      obj.state = jobStateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.experiment !== "") {
      obj.experiment = message.experiment;
    }
    if (message.tunedModel !== undefined) {
      obj.tunedModel = TunedModel.toJSON(message.tunedModel);
    }
    if (message.tuningDataStats !== undefined) {
      obj.tuningDataStats = TuningDataStats.toJSON(message.tuningDataStats);
    }
    if (message.encryptionSpec !== undefined) {
      obj.encryptionSpec = EncryptionSpec.toJSON(message.encryptionSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<TuningJob>): TuningJob {
    return TuningJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TuningJob>): TuningJob {
    const message = createBaseTuningJob();
    message.baseModel = object.baseModel ?? undefined;
    message.supervisedTuningSpec = (object.supervisedTuningSpec !== undefined && object.supervisedTuningSpec !== null)
      ? SupervisedTuningSpec.fromPartial(object.supervisedTuningSpec)
      : undefined;
    message.name = object.name ?? "";
    message.tunedModelDisplayName = object.tunedModelDisplayName ?? "";
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.experiment = object.experiment ?? "";
    message.tunedModel = (object.tunedModel !== undefined && object.tunedModel !== null)
      ? TunedModel.fromPartial(object.tunedModel)
      : undefined;
    message.tuningDataStats = (object.tuningDataStats !== undefined && object.tuningDataStats !== null)
      ? TuningDataStats.fromPartial(object.tuningDataStats)
      : undefined;
    message.encryptionSpec = (object.encryptionSpec !== undefined && object.encryptionSpec !== null)
      ? EncryptionSpec.fromPartial(object.encryptionSpec)
      : undefined;
    return message;
  },
};

function createBaseTuningJob_LabelsEntry(): TuningJob_LabelsEntry {
  return { key: "", value: "" };
}

export const TuningJob_LabelsEntry: MessageFns<TuningJob_LabelsEntry> = {
  encode(message: TuningJob_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TuningJob_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuningJob_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TuningJob_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TuningJob_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TuningJob_LabelsEntry>): TuningJob_LabelsEntry {
    return TuningJob_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TuningJob_LabelsEntry>): TuningJob_LabelsEntry {
    const message = createBaseTuningJob_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTunedModel(): TunedModel {
  return { model: "", endpoint: "" };
}

export const TunedModel: MessageFns<TunedModel> = {
  encode(message: TunedModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    if (message.endpoint !== "") {
      writer.uint32(18).string(message.endpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunedModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunedModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endpoint = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunedModel {
    return {
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
    };
  },

  toJSON(message: TunedModel): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    return obj;
  },

  create(base?: DeepPartial<TunedModel>): TunedModel {
    return TunedModel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunedModel>): TunedModel {
    const message = createBaseTunedModel();
    message.model = object.model ?? "";
    message.endpoint = object.endpoint ?? "";
    return message;
  },
};

function createBaseSupervisedTuningDatasetDistribution(): SupervisedTuningDatasetDistribution {
  return { sum: Long.ZERO, billableSum: Long.ZERO, min: 0, max: 0, mean: 0, median: 0, p5: 0, p95: 0, buckets: [] };
}

export const SupervisedTuningDatasetDistribution: MessageFns<SupervisedTuningDatasetDistribution> = {
  encode(message: SupervisedTuningDatasetDistribution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.sum.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.sum.toString());
    }
    if (!message.billableSum.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.billableSum.toString());
    }
    if (message.min !== 0) {
      writer.uint32(17).double(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(25).double(message.max);
    }
    if (message.mean !== 0) {
      writer.uint32(33).double(message.mean);
    }
    if (message.median !== 0) {
      writer.uint32(41).double(message.median);
    }
    if (message.p5 !== 0) {
      writer.uint32(49).double(message.p5);
    }
    if (message.p95 !== 0) {
      writer.uint32(57).double(message.p95);
    }
    for (const v of message.buckets) {
      SupervisedTuningDatasetDistribution_DatasetBucket.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SupervisedTuningDatasetDistribution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupervisedTuningDatasetDistribution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sum = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.billableSum = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.min = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.max = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.mean = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.median = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.p5 = reader.double();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.p95 = reader.double();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.buckets.push(SupervisedTuningDatasetDistribution_DatasetBucket.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupervisedTuningDatasetDistribution {
    return {
      sum: isSet(object.sum) ? Long.fromValue(object.sum) : Long.ZERO,
      billableSum: isSet(object.billableSum) ? Long.fromValue(object.billableSum) : Long.ZERO,
      min: isSet(object.min) ? globalThis.Number(object.min) : 0,
      max: isSet(object.max) ? globalThis.Number(object.max) : 0,
      mean: isSet(object.mean) ? globalThis.Number(object.mean) : 0,
      median: isSet(object.median) ? globalThis.Number(object.median) : 0,
      p5: isSet(object.p5) ? globalThis.Number(object.p5) : 0,
      p95: isSet(object.p95) ? globalThis.Number(object.p95) : 0,
      buckets: globalThis.Array.isArray(object?.buckets)
        ? object.buckets.map((e: any) => SupervisedTuningDatasetDistribution_DatasetBucket.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SupervisedTuningDatasetDistribution): unknown {
    const obj: any = {};
    if (!message.sum.equals(Long.ZERO)) {
      obj.sum = (message.sum || Long.ZERO).toString();
    }
    if (!message.billableSum.equals(Long.ZERO)) {
      obj.billableSum = (message.billableSum || Long.ZERO).toString();
    }
    if (message.min !== 0) {
      obj.min = message.min;
    }
    if (message.max !== 0) {
      obj.max = message.max;
    }
    if (message.mean !== 0) {
      obj.mean = message.mean;
    }
    if (message.median !== 0) {
      obj.median = message.median;
    }
    if (message.p5 !== 0) {
      obj.p5 = message.p5;
    }
    if (message.p95 !== 0) {
      obj.p95 = message.p95;
    }
    if (message.buckets?.length) {
      obj.buckets = message.buckets.map((e) => SupervisedTuningDatasetDistribution_DatasetBucket.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SupervisedTuningDatasetDistribution>): SupervisedTuningDatasetDistribution {
    return SupervisedTuningDatasetDistribution.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SupervisedTuningDatasetDistribution>): SupervisedTuningDatasetDistribution {
    const message = createBaseSupervisedTuningDatasetDistribution();
    message.sum = (object.sum !== undefined && object.sum !== null) ? Long.fromValue(object.sum) : Long.ZERO;
    message.billableSum = (object.billableSum !== undefined && object.billableSum !== null)
      ? Long.fromValue(object.billableSum)
      : Long.ZERO;
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    message.mean = object.mean ?? 0;
    message.median = object.median ?? 0;
    message.p5 = object.p5 ?? 0;
    message.p95 = object.p95 ?? 0;
    message.buckets = object.buckets?.map((e) => SupervisedTuningDatasetDistribution_DatasetBucket.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseSupervisedTuningDatasetDistribution_DatasetBucket(): SupervisedTuningDatasetDistribution_DatasetBucket {
  return { count: 0, left: 0, right: 0 };
}

export const SupervisedTuningDatasetDistribution_DatasetBucket: MessageFns<
  SupervisedTuningDatasetDistribution_DatasetBucket
> = {
  encode(
    message: SupervisedTuningDatasetDistribution_DatasetBucket,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.count !== 0) {
      writer.uint32(9).double(message.count);
    }
    if (message.left !== 0) {
      writer.uint32(17).double(message.left);
    }
    if (message.right !== 0) {
      writer.uint32(25).double(message.right);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SupervisedTuningDatasetDistribution_DatasetBucket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupervisedTuningDatasetDistribution_DatasetBucket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.count = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.left = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.right = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupervisedTuningDatasetDistribution_DatasetBucket {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      left: isSet(object.left) ? globalThis.Number(object.left) : 0,
      right: isSet(object.right) ? globalThis.Number(object.right) : 0,
    };
  },

  toJSON(message: SupervisedTuningDatasetDistribution_DatasetBucket): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = message.count;
    }
    if (message.left !== 0) {
      obj.left = message.left;
    }
    if (message.right !== 0) {
      obj.right = message.right;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SupervisedTuningDatasetDistribution_DatasetBucket>,
  ): SupervisedTuningDatasetDistribution_DatasetBucket {
    return SupervisedTuningDatasetDistribution_DatasetBucket.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SupervisedTuningDatasetDistribution_DatasetBucket>,
  ): SupervisedTuningDatasetDistribution_DatasetBucket {
    const message = createBaseSupervisedTuningDatasetDistribution_DatasetBucket();
    message.count = object.count ?? 0;
    message.left = object.left ?? 0;
    message.right = object.right ?? 0;
    return message;
  },
};

function createBaseSupervisedTuningDataStats(): SupervisedTuningDataStats {
  return {
    tuningDatasetExampleCount: Long.ZERO,
    totalTuningCharacterCount: Long.ZERO,
    totalBillableCharacterCount: Long.ZERO,
    totalBillableTokenCount: Long.ZERO,
    tuningStepCount: Long.ZERO,
    userInputTokenDistribution: undefined,
    userOutputTokenDistribution: undefined,
    userMessagePerExampleDistribution: undefined,
    userDatasetExamples: [],
    totalTruncatedExampleCount: Long.ZERO,
    truncatedExampleIndices: [],
  };
}

export const SupervisedTuningDataStats: MessageFns<SupervisedTuningDataStats> = {
  encode(message: SupervisedTuningDataStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.tuningDatasetExampleCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.tuningDatasetExampleCount.toString());
    }
    if (!message.totalTuningCharacterCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.totalTuningCharacterCount.toString());
    }
    if (!message.totalBillableCharacterCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.totalBillableCharacterCount.toString());
    }
    if (!message.totalBillableTokenCount.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.totalBillableTokenCount.toString());
    }
    if (!message.tuningStepCount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.tuningStepCount.toString());
    }
    if (message.userInputTokenDistribution !== undefined) {
      SupervisedTuningDatasetDistribution.encode(message.userInputTokenDistribution, writer.uint32(42).fork()).join();
    }
    if (message.userOutputTokenDistribution !== undefined) {
      SupervisedTuningDatasetDistribution.encode(message.userOutputTokenDistribution, writer.uint32(50).fork()).join();
    }
    if (message.userMessagePerExampleDistribution !== undefined) {
      SupervisedTuningDatasetDistribution.encode(message.userMessagePerExampleDistribution, writer.uint32(58).fork())
        .join();
    }
    for (const v of message.userDatasetExamples) {
      Content.encode(v!, writer.uint32(66).fork()).join();
    }
    if (!message.totalTruncatedExampleCount.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.totalTruncatedExampleCount.toString());
    }
    writer.uint32(90).fork();
    for (const v of message.truncatedExampleIndices) {
      writer.int64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SupervisedTuningDataStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupervisedTuningDataStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tuningDatasetExampleCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalTuningCharacterCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalBillableCharacterCount = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.totalBillableTokenCount = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.tuningStepCount = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.userInputTokenDistribution = SupervisedTuningDatasetDistribution.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.userOutputTokenDistribution = SupervisedTuningDatasetDistribution.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.userMessagePerExampleDistribution = SupervisedTuningDatasetDistribution.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.userDatasetExamples.push(Content.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.totalTruncatedExampleCount = Long.fromString(reader.int64().toString());
          continue;
        case 11:
          if (tag === 88) {
            message.truncatedExampleIndices.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.truncatedExampleIndices.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupervisedTuningDataStats {
    return {
      tuningDatasetExampleCount: isSet(object.tuningDatasetExampleCount)
        ? Long.fromValue(object.tuningDatasetExampleCount)
        : Long.ZERO,
      totalTuningCharacterCount: isSet(object.totalTuningCharacterCount)
        ? Long.fromValue(object.totalTuningCharacterCount)
        : Long.ZERO,
      totalBillableCharacterCount: isSet(object.totalBillableCharacterCount)
        ? Long.fromValue(object.totalBillableCharacterCount)
        : Long.ZERO,
      totalBillableTokenCount: isSet(object.totalBillableTokenCount)
        ? Long.fromValue(object.totalBillableTokenCount)
        : Long.ZERO,
      tuningStepCount: isSet(object.tuningStepCount) ? Long.fromValue(object.tuningStepCount) : Long.ZERO,
      userInputTokenDistribution: isSet(object.userInputTokenDistribution)
        ? SupervisedTuningDatasetDistribution.fromJSON(object.userInputTokenDistribution)
        : undefined,
      userOutputTokenDistribution: isSet(object.userOutputTokenDistribution)
        ? SupervisedTuningDatasetDistribution.fromJSON(object.userOutputTokenDistribution)
        : undefined,
      userMessagePerExampleDistribution: isSet(object.userMessagePerExampleDistribution)
        ? SupervisedTuningDatasetDistribution.fromJSON(object.userMessagePerExampleDistribution)
        : undefined,
      userDatasetExamples: globalThis.Array.isArray(object?.userDatasetExamples)
        ? object.userDatasetExamples.map((e: any) => Content.fromJSON(e))
        : [],
      totalTruncatedExampleCount: isSet(object.totalTruncatedExampleCount)
        ? Long.fromValue(object.totalTruncatedExampleCount)
        : Long.ZERO,
      truncatedExampleIndices: globalThis.Array.isArray(object?.truncatedExampleIndices)
        ? object.truncatedExampleIndices.map((e: any) => Long.fromValue(e))
        : [],
    };
  },

  toJSON(message: SupervisedTuningDataStats): unknown {
    const obj: any = {};
    if (!message.tuningDatasetExampleCount.equals(Long.ZERO)) {
      obj.tuningDatasetExampleCount = (message.tuningDatasetExampleCount || Long.ZERO).toString();
    }
    if (!message.totalTuningCharacterCount.equals(Long.ZERO)) {
      obj.totalTuningCharacterCount = (message.totalTuningCharacterCount || Long.ZERO).toString();
    }
    if (!message.totalBillableCharacterCount.equals(Long.ZERO)) {
      obj.totalBillableCharacterCount = (message.totalBillableCharacterCount || Long.ZERO).toString();
    }
    if (!message.totalBillableTokenCount.equals(Long.ZERO)) {
      obj.totalBillableTokenCount = (message.totalBillableTokenCount || Long.ZERO).toString();
    }
    if (!message.tuningStepCount.equals(Long.ZERO)) {
      obj.tuningStepCount = (message.tuningStepCount || Long.ZERO).toString();
    }
    if (message.userInputTokenDistribution !== undefined) {
      obj.userInputTokenDistribution = SupervisedTuningDatasetDistribution.toJSON(message.userInputTokenDistribution);
    }
    if (message.userOutputTokenDistribution !== undefined) {
      obj.userOutputTokenDistribution = SupervisedTuningDatasetDistribution.toJSON(message.userOutputTokenDistribution);
    }
    if (message.userMessagePerExampleDistribution !== undefined) {
      obj.userMessagePerExampleDistribution = SupervisedTuningDatasetDistribution.toJSON(
        message.userMessagePerExampleDistribution,
      );
    }
    if (message.userDatasetExamples?.length) {
      obj.userDatasetExamples = message.userDatasetExamples.map((e) => Content.toJSON(e));
    }
    if (!message.totalTruncatedExampleCount.equals(Long.ZERO)) {
      obj.totalTruncatedExampleCount = (message.totalTruncatedExampleCount || Long.ZERO).toString();
    }
    if (message.truncatedExampleIndices?.length) {
      obj.truncatedExampleIndices = message.truncatedExampleIndices.map((e) => (e || Long.ZERO).toString());
    }
    return obj;
  },

  create(base?: DeepPartial<SupervisedTuningDataStats>): SupervisedTuningDataStats {
    return SupervisedTuningDataStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SupervisedTuningDataStats>): SupervisedTuningDataStats {
    const message = createBaseSupervisedTuningDataStats();
    message.tuningDatasetExampleCount =
      (object.tuningDatasetExampleCount !== undefined && object.tuningDatasetExampleCount !== null)
        ? Long.fromValue(object.tuningDatasetExampleCount)
        : Long.ZERO;
    message.totalTuningCharacterCount =
      (object.totalTuningCharacterCount !== undefined && object.totalTuningCharacterCount !== null)
        ? Long.fromValue(object.totalTuningCharacterCount)
        : Long.ZERO;
    message.totalBillableCharacterCount =
      (object.totalBillableCharacterCount !== undefined && object.totalBillableCharacterCount !== null)
        ? Long.fromValue(object.totalBillableCharacterCount)
        : Long.ZERO;
    message.totalBillableTokenCount =
      (object.totalBillableTokenCount !== undefined && object.totalBillableTokenCount !== null)
        ? Long.fromValue(object.totalBillableTokenCount)
        : Long.ZERO;
    message.tuningStepCount = (object.tuningStepCount !== undefined && object.tuningStepCount !== null)
      ? Long.fromValue(object.tuningStepCount)
      : Long.ZERO;
    message.userInputTokenDistribution =
      (object.userInputTokenDistribution !== undefined && object.userInputTokenDistribution !== null)
        ? SupervisedTuningDatasetDistribution.fromPartial(object.userInputTokenDistribution)
        : undefined;
    message.userOutputTokenDistribution =
      (object.userOutputTokenDistribution !== undefined && object.userOutputTokenDistribution !== null)
        ? SupervisedTuningDatasetDistribution.fromPartial(object.userOutputTokenDistribution)
        : undefined;
    message.userMessagePerExampleDistribution =
      (object.userMessagePerExampleDistribution !== undefined && object.userMessagePerExampleDistribution !== null)
        ? SupervisedTuningDatasetDistribution.fromPartial(object.userMessagePerExampleDistribution)
        : undefined;
    message.userDatasetExamples = object.userDatasetExamples?.map((e) => Content.fromPartial(e)) || [];
    message.totalTruncatedExampleCount =
      (object.totalTruncatedExampleCount !== undefined && object.totalTruncatedExampleCount !== null)
        ? Long.fromValue(object.totalTruncatedExampleCount)
        : Long.ZERO;
    message.truncatedExampleIndices = object.truncatedExampleIndices?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseTuningDataStats(): TuningDataStats {
  return { supervisedTuningDataStats: undefined };
}

export const TuningDataStats: MessageFns<TuningDataStats> = {
  encode(message: TuningDataStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.supervisedTuningDataStats !== undefined) {
      SupervisedTuningDataStats.encode(message.supervisedTuningDataStats, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TuningDataStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuningDataStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.supervisedTuningDataStats = SupervisedTuningDataStats.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TuningDataStats {
    return {
      supervisedTuningDataStats: isSet(object.supervisedTuningDataStats)
        ? SupervisedTuningDataStats.fromJSON(object.supervisedTuningDataStats)
        : undefined,
    };
  },

  toJSON(message: TuningDataStats): unknown {
    const obj: any = {};
    if (message.supervisedTuningDataStats !== undefined) {
      obj.supervisedTuningDataStats = SupervisedTuningDataStats.toJSON(message.supervisedTuningDataStats);
    }
    return obj;
  },

  create(base?: DeepPartial<TuningDataStats>): TuningDataStats {
    return TuningDataStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TuningDataStats>): TuningDataStats {
    const message = createBaseTuningDataStats();
    message.supervisedTuningDataStats =
      (object.supervisedTuningDataStats !== undefined && object.supervisedTuningDataStats !== null)
        ? SupervisedTuningDataStats.fromPartial(object.supervisedTuningDataStats)
        : undefined;
    return message;
  },
};

function createBaseSupervisedHyperParameters(): SupervisedHyperParameters {
  return { epochCount: Long.ZERO, learningRateMultiplier: 0, adapterSize: 0 };
}

export const SupervisedHyperParameters: MessageFns<SupervisedHyperParameters> = {
  encode(message: SupervisedHyperParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.epochCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.epochCount.toString());
    }
    if (message.learningRateMultiplier !== 0) {
      writer.uint32(17).double(message.learningRateMultiplier);
    }
    if (message.adapterSize !== 0) {
      writer.uint32(24).int32(message.adapterSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SupervisedHyperParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupervisedHyperParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.epochCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.learningRateMultiplier = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.adapterSize = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupervisedHyperParameters {
    return {
      epochCount: isSet(object.epochCount) ? Long.fromValue(object.epochCount) : Long.ZERO,
      learningRateMultiplier: isSet(object.learningRateMultiplier)
        ? globalThis.Number(object.learningRateMultiplier)
        : 0,
      adapterSize: isSet(object.adapterSize) ? supervisedHyperParameters_AdapterSizeFromJSON(object.adapterSize) : 0,
    };
  },

  toJSON(message: SupervisedHyperParameters): unknown {
    const obj: any = {};
    if (!message.epochCount.equals(Long.ZERO)) {
      obj.epochCount = (message.epochCount || Long.ZERO).toString();
    }
    if (message.learningRateMultiplier !== 0) {
      obj.learningRateMultiplier = message.learningRateMultiplier;
    }
    if (message.adapterSize !== 0) {
      obj.adapterSize = supervisedHyperParameters_AdapterSizeToJSON(message.adapterSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SupervisedHyperParameters>): SupervisedHyperParameters {
    return SupervisedHyperParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SupervisedHyperParameters>): SupervisedHyperParameters {
    const message = createBaseSupervisedHyperParameters();
    message.epochCount = (object.epochCount !== undefined && object.epochCount !== null)
      ? Long.fromValue(object.epochCount)
      : Long.ZERO;
    message.learningRateMultiplier = object.learningRateMultiplier ?? 0;
    message.adapterSize = object.adapterSize ?? 0;
    return message;
  },
};

function createBaseSupervisedTuningSpec(): SupervisedTuningSpec {
  return { trainingDatasetUri: "", validationDatasetUri: "", hyperParameters: undefined };
}

export const SupervisedTuningSpec: MessageFns<SupervisedTuningSpec> = {
  encode(message: SupervisedTuningSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trainingDatasetUri !== "") {
      writer.uint32(10).string(message.trainingDatasetUri);
    }
    if (message.validationDatasetUri !== "") {
      writer.uint32(18).string(message.validationDatasetUri);
    }
    if (message.hyperParameters !== undefined) {
      SupervisedHyperParameters.encode(message.hyperParameters, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SupervisedTuningSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupervisedTuningSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.trainingDatasetUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.validationDatasetUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hyperParameters = SupervisedHyperParameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupervisedTuningSpec {
    return {
      trainingDatasetUri: isSet(object.trainingDatasetUri) ? globalThis.String(object.trainingDatasetUri) : "",
      validationDatasetUri: isSet(object.validationDatasetUri) ? globalThis.String(object.validationDatasetUri) : "",
      hyperParameters: isSet(object.hyperParameters)
        ? SupervisedHyperParameters.fromJSON(object.hyperParameters)
        : undefined,
    };
  },

  toJSON(message: SupervisedTuningSpec): unknown {
    const obj: any = {};
    if (message.trainingDatasetUri !== "") {
      obj.trainingDatasetUri = message.trainingDatasetUri;
    }
    if (message.validationDatasetUri !== "") {
      obj.validationDatasetUri = message.validationDatasetUri;
    }
    if (message.hyperParameters !== undefined) {
      obj.hyperParameters = SupervisedHyperParameters.toJSON(message.hyperParameters);
    }
    return obj;
  },

  create(base?: DeepPartial<SupervisedTuningSpec>): SupervisedTuningSpec {
    return SupervisedTuningSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SupervisedTuningSpec>): SupervisedTuningSpec {
    const message = createBaseSupervisedTuningSpec();
    message.trainingDatasetUri = object.trainingDatasetUri ?? "";
    message.validationDatasetUri = object.validationDatasetUri ?? "";
    message.hyperParameters = (object.hyperParameters !== undefined && object.hyperParameters !== null)
      ? SupervisedHyperParameters.fromPartial(object.hyperParameters)
      : undefined;
    return message;
  },
};

function createBaseTunedModelRef(): TunedModelRef {
  return { tunedModel: undefined, tuningJob: undefined, pipelineJob: undefined };
}

export const TunedModelRef: MessageFns<TunedModelRef> = {
  encode(message: TunedModelRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tunedModel !== undefined) {
      writer.uint32(10).string(message.tunedModel);
    }
    if (message.tuningJob !== undefined) {
      writer.uint32(18).string(message.tuningJob);
    }
    if (message.pipelineJob !== undefined) {
      writer.uint32(26).string(message.pipelineJob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunedModelRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunedModelRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tunedModel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tuningJob = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pipelineJob = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunedModelRef {
    return {
      tunedModel: isSet(object.tunedModel) ? globalThis.String(object.tunedModel) : undefined,
      tuningJob: isSet(object.tuningJob) ? globalThis.String(object.tuningJob) : undefined,
      pipelineJob: isSet(object.pipelineJob) ? globalThis.String(object.pipelineJob) : undefined,
    };
  },

  toJSON(message: TunedModelRef): unknown {
    const obj: any = {};
    if (message.tunedModel !== undefined) {
      obj.tunedModel = message.tunedModel;
    }
    if (message.tuningJob !== undefined) {
      obj.tuningJob = message.tuningJob;
    }
    if (message.pipelineJob !== undefined) {
      obj.pipelineJob = message.pipelineJob;
    }
    return obj;
  },

  create(base?: DeepPartial<TunedModelRef>): TunedModelRef {
    return TunedModelRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunedModelRef>): TunedModelRef {
    const message = createBaseTunedModelRef();
    message.tunedModel = object.tunedModel ?? undefined;
    message.tuningJob = object.tuningJob ?? undefined;
    message.pipelineJob = object.pipelineJob ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
