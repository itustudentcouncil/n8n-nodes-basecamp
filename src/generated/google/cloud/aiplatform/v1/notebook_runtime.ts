// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1/notebook_runtime.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { EncryptionSpec } from "./encryption_spec.js";
import { MachineSpec, PersistentDiskSpec, ShieldedVmConfig } from "./machine_resources.js";
import { NetworkSpec } from "./network_spec.js";
import { NotebookEucConfig } from "./notebook_euc_config.js";
import { NotebookIdleShutdownConfig } from "./notebook_idle_shutdown_config.js";
import { NotebookRuntimeTemplateRef } from "./notebook_runtime_template_ref.js";

export const protobufPackage = "google.cloud.aiplatform.v1";

/** Represents a notebook runtime type. */
export enum NotebookRuntimeType {
  /**
   * NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED - Unspecified notebook runtime type, NotebookRuntimeType will default to
   * USER_DEFINED.
   */
  NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED = 0,
  /** USER_DEFINED - runtime or template with coustomized configurations from user. */
  USER_DEFINED = 1,
  /** ONE_CLICK - runtime or template with system defined configurations. */
  ONE_CLICK = 2,
  UNRECOGNIZED = -1,
}

export function notebookRuntimeTypeFromJSON(object: any): NotebookRuntimeType {
  switch (object) {
    case 0:
    case "NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED":
      return NotebookRuntimeType.NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED;
    case 1:
    case "USER_DEFINED":
      return NotebookRuntimeType.USER_DEFINED;
    case 2:
    case "ONE_CLICK":
      return NotebookRuntimeType.ONE_CLICK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotebookRuntimeType.UNRECOGNIZED;
  }
}

export function notebookRuntimeTypeToJSON(object: NotebookRuntimeType): string {
  switch (object) {
    case NotebookRuntimeType.NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED:
      return "NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED";
    case NotebookRuntimeType.USER_DEFINED:
      return "USER_DEFINED";
    case NotebookRuntimeType.ONE_CLICK:
      return "ONE_CLICK";
    case NotebookRuntimeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A template that specifies runtime configurations such as machine type,
 * runtime version, network configurations, etc.
 * Multiple runtimes can be created from a runtime template.
 */
export interface NotebookRuntimeTemplate {
  /** The resource name of the NotebookRuntimeTemplate. */
  name: string;
  /**
   * Required. The display name of the NotebookRuntimeTemplate.
   * The name can be up to 128 characters long and can consist of any UTF-8
   * characters.
   */
  displayName: string;
  /** The description of the NotebookRuntimeTemplate. */
  description: string;
  /** Output only. The default template to use if not specified. */
  isDefault: boolean;
  /**
   * Optional. Immutable. The specification of a single machine for the
   * template.
   */
  machineSpec:
    | MachineSpec
    | undefined;
  /**
   * Optional. The specification of [persistent
   * disk][https://cloud.google.com/compute/docs/disks/persistent-disks]
   * attached to the runtime as data disk storage.
   */
  dataPersistentDiskSpec:
    | PersistentDiskSpec
    | undefined;
  /** Optional. Network spec. */
  networkSpec:
    | NetworkSpec
    | undefined;
  /**
   * The service account that the runtime workload runs as.
   * You can use any service account within the same project, but you
   * must have the service account user permission to use the instance.
   *
   * If not specified, the [Compute Engine default service
   * account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account)
   * is used.
   */
  serviceAccount: string;
  /**
   * Used to perform consistent read-modify-write updates. If not set, a blind
   * "overwrite" update happens.
   */
  etag: string;
  /**
   * The labels with user-defined metadata to organize the
   * NotebookRuntimeTemplates.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   */
  labels: { [key: string]: string };
  /**
   * The idle shutdown configuration of NotebookRuntimeTemplate. This config
   * will only be set when idle shutdown is enabled.
   */
  idleShutdownConfig:
    | NotebookIdleShutdownConfig
    | undefined;
  /** EUC configuration of the NotebookRuntimeTemplate. */
  eucConfig:
    | NotebookEucConfig
    | undefined;
  /** Output only. Timestamp when this NotebookRuntimeTemplate was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. Timestamp when this NotebookRuntimeTemplate was most recently
   * updated.
   */
  updateTime:
    | Date
    | undefined;
  /** Optional. Immutable. The type of the notebook runtime template. */
  notebookRuntimeType: NotebookRuntimeType;
  /** Optional. Immutable. Runtime Shielded VM spec. */
  shieldedVmConfig:
    | ShieldedVmConfig
    | undefined;
  /**
   * Optional. The Compute Engine tags to add to runtime (see [Tagging
   * instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
   */
  networkTags: string[];
  /** Customer-managed encryption key spec for the notebook runtime. */
  encryptionSpec: EncryptionSpec | undefined;
}

export interface NotebookRuntimeTemplate_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A runtime is a virtual machine allocated to a particular user for a
 * particular Notebook file on temporary basis with lifetime limited to 24
 * hours.
 */
export interface NotebookRuntime {
  /** Output only. The resource name of the NotebookRuntime. */
  name: string;
  /** Required. The user email of the NotebookRuntime. */
  runtimeUser: string;
  /**
   * Output only. The pointer to NotebookRuntimeTemplate this NotebookRuntime is
   * created from.
   */
  notebookRuntimeTemplateRef:
    | NotebookRuntimeTemplateRef
    | undefined;
  /** Output only. The proxy endpoint used to access the NotebookRuntime. */
  proxyUri: string;
  /** Output only. Timestamp when this NotebookRuntime was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Timestamp when this NotebookRuntime was most recently updated. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The health state of the NotebookRuntime. */
  healthState: NotebookRuntime_HealthState;
  /**
   * Required. The display name of the NotebookRuntime.
   * The name can be up to 128 characters long and can consist of any UTF-8
   * characters.
   */
  displayName: string;
  /** The description of the NotebookRuntime. */
  description: string;
  /** Output only. The service account that the NotebookRuntime workload runs as. */
  serviceAccount: string;
  /** Output only. The runtime (instance) state of the NotebookRuntime. */
  runtimeState: NotebookRuntime_RuntimeState;
  /** Output only. Whether NotebookRuntime is upgradable. */
  isUpgradable: boolean;
  /**
   * The labels with user-defined metadata to organize your
   * NotebookRuntime.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   * No more than 64 user labels can be associated with one NotebookRuntime
   * (System labels are excluded).
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   * System reserved label keys are prefixed with "aiplatform.googleapis.com/"
   * and are immutable. Following system labels exist for NotebookRuntime:
   *
   * * "aiplatform.googleapis.com/notebook_runtime_gce_instance_id": output
   * only, its value is the Compute Engine instance id.
   * * "aiplatform.googleapis.com/colab_enterprise_entry_service": its value is
   * either "bigquery" or "vertex"; if absent, it should be "vertex". This is to
   * describe the entry service, either BigQuery or Vertex.
   */
  labels: { [key: string]: string };
  /**
   * Output only. Timestamp when this NotebookRuntime will be expired:
   * 1. System Predefined NotebookRuntime: 24 hours after creation. After
   * expiration, system predifined runtime will be deleted.
   * 2. User created NotebookRuntime: 6 months after last upgrade. After
   * expiration, user created runtime will be stopped and allowed for upgrade.
   */
  expirationTime:
    | Date
    | undefined;
  /** Output only. The VM os image version of NotebookRuntime. */
  version: string;
  /** Output only. The type of the notebook runtime. */
  notebookRuntimeType: NotebookRuntimeType;
  /** Output only. The idle shutdown configuration of the notebook runtime. */
  idleShutdownConfig:
    | NotebookIdleShutdownConfig
    | undefined;
  /**
   * Optional. The Compute Engine tags to add to runtime (see [Tagging
   * instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
   */
  networkTags: string[];
  /** Output only. Customer-managed encryption key spec for the notebook runtime. */
  encryptionSpec:
    | EncryptionSpec
    | undefined;
  /** Output only. Reserved for future use. */
  satisfiesPzs: boolean;
  /** Output only. Reserved for future use. */
  satisfiesPzi: boolean;
}

/** The substate of the NotebookRuntime to display health information. */
export enum NotebookRuntime_HealthState {
  /** HEALTH_STATE_UNSPECIFIED - Unspecified health state. */
  HEALTH_STATE_UNSPECIFIED = 0,
  /** HEALTHY - NotebookRuntime is in healthy state. Applies to ACTIVE state. */
  HEALTHY = 1,
  /** UNHEALTHY - NotebookRuntime is in unhealthy state. Applies to ACTIVE state. */
  UNHEALTHY = 2,
  UNRECOGNIZED = -1,
}

export function notebookRuntime_HealthStateFromJSON(object: any): NotebookRuntime_HealthState {
  switch (object) {
    case 0:
    case "HEALTH_STATE_UNSPECIFIED":
      return NotebookRuntime_HealthState.HEALTH_STATE_UNSPECIFIED;
    case 1:
    case "HEALTHY":
      return NotebookRuntime_HealthState.HEALTHY;
    case 2:
    case "UNHEALTHY":
      return NotebookRuntime_HealthState.UNHEALTHY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotebookRuntime_HealthState.UNRECOGNIZED;
  }
}

export function notebookRuntime_HealthStateToJSON(object: NotebookRuntime_HealthState): string {
  switch (object) {
    case NotebookRuntime_HealthState.HEALTH_STATE_UNSPECIFIED:
      return "HEALTH_STATE_UNSPECIFIED";
    case NotebookRuntime_HealthState.HEALTHY:
      return "HEALTHY";
    case NotebookRuntime_HealthState.UNHEALTHY:
      return "UNHEALTHY";
    case NotebookRuntime_HealthState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The substate of the NotebookRuntime to display state of runtime.
 * The resource of NotebookRuntime is in ACTIVE state for these sub state.
 */
export enum NotebookRuntime_RuntimeState {
  /** RUNTIME_STATE_UNSPECIFIED - Unspecified runtime state. */
  RUNTIME_STATE_UNSPECIFIED = 0,
  /** RUNNING - NotebookRuntime is in running state. */
  RUNNING = 1,
  /** BEING_STARTED - NotebookRuntime is in starting state. */
  BEING_STARTED = 2,
  /** BEING_STOPPED - NotebookRuntime is in stopping state. */
  BEING_STOPPED = 3,
  /** STOPPED - NotebookRuntime is in stopped state. */
  STOPPED = 4,
  /**
   * BEING_UPGRADED - NotebookRuntime is in upgrading state. It is in the middle of upgrading
   * process.
   */
  BEING_UPGRADED = 5,
  /** ERROR - NotebookRuntime was unable to start/stop properly. */
  ERROR = 100,
  /** INVALID - NotebookRuntime is in invalid state. Cannot be recovered. */
  INVALID = 101,
  UNRECOGNIZED = -1,
}

export function notebookRuntime_RuntimeStateFromJSON(object: any): NotebookRuntime_RuntimeState {
  switch (object) {
    case 0:
    case "RUNTIME_STATE_UNSPECIFIED":
      return NotebookRuntime_RuntimeState.RUNTIME_STATE_UNSPECIFIED;
    case 1:
    case "RUNNING":
      return NotebookRuntime_RuntimeState.RUNNING;
    case 2:
    case "BEING_STARTED":
      return NotebookRuntime_RuntimeState.BEING_STARTED;
    case 3:
    case "BEING_STOPPED":
      return NotebookRuntime_RuntimeState.BEING_STOPPED;
    case 4:
    case "STOPPED":
      return NotebookRuntime_RuntimeState.STOPPED;
    case 5:
    case "BEING_UPGRADED":
      return NotebookRuntime_RuntimeState.BEING_UPGRADED;
    case 100:
    case "ERROR":
      return NotebookRuntime_RuntimeState.ERROR;
    case 101:
    case "INVALID":
      return NotebookRuntime_RuntimeState.INVALID;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotebookRuntime_RuntimeState.UNRECOGNIZED;
  }
}

export function notebookRuntime_RuntimeStateToJSON(object: NotebookRuntime_RuntimeState): string {
  switch (object) {
    case NotebookRuntime_RuntimeState.RUNTIME_STATE_UNSPECIFIED:
      return "RUNTIME_STATE_UNSPECIFIED";
    case NotebookRuntime_RuntimeState.RUNNING:
      return "RUNNING";
    case NotebookRuntime_RuntimeState.BEING_STARTED:
      return "BEING_STARTED";
    case NotebookRuntime_RuntimeState.BEING_STOPPED:
      return "BEING_STOPPED";
    case NotebookRuntime_RuntimeState.STOPPED:
      return "STOPPED";
    case NotebookRuntime_RuntimeState.BEING_UPGRADED:
      return "BEING_UPGRADED";
    case NotebookRuntime_RuntimeState.ERROR:
      return "ERROR";
    case NotebookRuntime_RuntimeState.INVALID:
      return "INVALID";
    case NotebookRuntime_RuntimeState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface NotebookRuntime_LabelsEntry {
  key: string;
  value: string;
}

function createBaseNotebookRuntimeTemplate(): NotebookRuntimeTemplate {
  return {
    name: "",
    displayName: "",
    description: "",
    isDefault: false,
    machineSpec: undefined,
    dataPersistentDiskSpec: undefined,
    networkSpec: undefined,
    serviceAccount: "",
    etag: "",
    labels: {},
    idleShutdownConfig: undefined,
    eucConfig: undefined,
    createTime: undefined,
    updateTime: undefined,
    notebookRuntimeType: 0,
    shieldedVmConfig: undefined,
    networkTags: [],
    encryptionSpec: undefined,
  };
}

export const NotebookRuntimeTemplate: MessageFns<NotebookRuntimeTemplate> = {
  encode(message: NotebookRuntimeTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.isDefault !== false) {
      writer.uint32(32).bool(message.isDefault);
    }
    if (message.machineSpec !== undefined) {
      MachineSpec.encode(message.machineSpec, writer.uint32(42).fork()).join();
    }
    if (message.dataPersistentDiskSpec !== undefined) {
      PersistentDiskSpec.encode(message.dataPersistentDiskSpec, writer.uint32(66).fork()).join();
    }
    if (message.networkSpec !== undefined) {
      NetworkSpec.encode(message.networkSpec, writer.uint32(98).fork()).join();
    }
    if (message.serviceAccount !== "") {
      writer.uint32(106).string(message.serviceAccount);
    }
    if (message.etag !== "") {
      writer.uint32(114).string(message.etag);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      NotebookRuntimeTemplate_LabelsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.idleShutdownConfig !== undefined) {
      NotebookIdleShutdownConfig.encode(message.idleShutdownConfig, writer.uint32(138).fork()).join();
    }
    if (message.eucConfig !== undefined) {
      NotebookEucConfig.encode(message.eucConfig, writer.uint32(146).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(82).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(90).fork()).join();
    }
    if (message.notebookRuntimeType !== 0) {
      writer.uint32(152).int32(message.notebookRuntimeType);
    }
    if (message.shieldedVmConfig !== undefined) {
      ShieldedVmConfig.encode(message.shieldedVmConfig, writer.uint32(162).fork()).join();
    }
    for (const v of message.networkTags) {
      writer.uint32(170).string(v!);
    }
    if (message.encryptionSpec !== undefined) {
      EncryptionSpec.encode(message.encryptionSpec, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotebookRuntimeTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotebookRuntimeTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.machineSpec = MachineSpec.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.dataPersistentDiskSpec = PersistentDiskSpec.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.networkSpec = NetworkSpec.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = NotebookRuntimeTemplate_LabelsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.labels[entry15.key] = entry15.value;
          }
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.idleShutdownConfig = NotebookIdleShutdownConfig.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.eucConfig = NotebookEucConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.notebookRuntimeType = reader.int32() as any;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.shieldedVmConfig = ShieldedVmConfig.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.networkTags.push(reader.string());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.encryptionSpec = EncryptionSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotebookRuntimeTemplate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : false,
      machineSpec: isSet(object.machineSpec) ? MachineSpec.fromJSON(object.machineSpec) : undefined,
      dataPersistentDiskSpec: isSet(object.dataPersistentDiskSpec)
        ? PersistentDiskSpec.fromJSON(object.dataPersistentDiskSpec)
        : undefined,
      networkSpec: isSet(object.networkSpec) ? NetworkSpec.fromJSON(object.networkSpec) : undefined,
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      idleShutdownConfig: isSet(object.idleShutdownConfig)
        ? NotebookIdleShutdownConfig.fromJSON(object.idleShutdownConfig)
        : undefined,
      eucConfig: isSet(object.eucConfig) ? NotebookEucConfig.fromJSON(object.eucConfig) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      notebookRuntimeType: isSet(object.notebookRuntimeType)
        ? notebookRuntimeTypeFromJSON(object.notebookRuntimeType)
        : 0,
      shieldedVmConfig: isSet(object.shieldedVmConfig) ? ShieldedVmConfig.fromJSON(object.shieldedVmConfig) : undefined,
      networkTags: globalThis.Array.isArray(object?.networkTags)
        ? object.networkTags.map((e: any) => globalThis.String(e))
        : [],
      encryptionSpec: isSet(object.encryptionSpec) ? EncryptionSpec.fromJSON(object.encryptionSpec) : undefined,
    };
  },

  toJSON(message: NotebookRuntimeTemplate): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    if (message.machineSpec !== undefined) {
      obj.machineSpec = MachineSpec.toJSON(message.machineSpec);
    }
    if (message.dataPersistentDiskSpec !== undefined) {
      obj.dataPersistentDiskSpec = PersistentDiskSpec.toJSON(message.dataPersistentDiskSpec);
    }
    if (message.networkSpec !== undefined) {
      obj.networkSpec = NetworkSpec.toJSON(message.networkSpec);
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.idleShutdownConfig !== undefined) {
      obj.idleShutdownConfig = NotebookIdleShutdownConfig.toJSON(message.idleShutdownConfig);
    }
    if (message.eucConfig !== undefined) {
      obj.eucConfig = NotebookEucConfig.toJSON(message.eucConfig);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.notebookRuntimeType !== 0) {
      obj.notebookRuntimeType = notebookRuntimeTypeToJSON(message.notebookRuntimeType);
    }
    if (message.shieldedVmConfig !== undefined) {
      obj.shieldedVmConfig = ShieldedVmConfig.toJSON(message.shieldedVmConfig);
    }
    if (message.networkTags?.length) {
      obj.networkTags = message.networkTags;
    }
    if (message.encryptionSpec !== undefined) {
      obj.encryptionSpec = EncryptionSpec.toJSON(message.encryptionSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<NotebookRuntimeTemplate>): NotebookRuntimeTemplate {
    return NotebookRuntimeTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotebookRuntimeTemplate>): NotebookRuntimeTemplate {
    const message = createBaseNotebookRuntimeTemplate();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.isDefault = object.isDefault ?? false;
    message.machineSpec = (object.machineSpec !== undefined && object.machineSpec !== null)
      ? MachineSpec.fromPartial(object.machineSpec)
      : undefined;
    message.dataPersistentDiskSpec =
      (object.dataPersistentDiskSpec !== undefined && object.dataPersistentDiskSpec !== null)
        ? PersistentDiskSpec.fromPartial(object.dataPersistentDiskSpec)
        : undefined;
    message.networkSpec = (object.networkSpec !== undefined && object.networkSpec !== null)
      ? NetworkSpec.fromPartial(object.networkSpec)
      : undefined;
    message.serviceAccount = object.serviceAccount ?? "";
    message.etag = object.etag ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.idleShutdownConfig = (object.idleShutdownConfig !== undefined && object.idleShutdownConfig !== null)
      ? NotebookIdleShutdownConfig.fromPartial(object.idleShutdownConfig)
      : undefined;
    message.eucConfig = (object.eucConfig !== undefined && object.eucConfig !== null)
      ? NotebookEucConfig.fromPartial(object.eucConfig)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.notebookRuntimeType = object.notebookRuntimeType ?? 0;
    message.shieldedVmConfig = (object.shieldedVmConfig !== undefined && object.shieldedVmConfig !== null)
      ? ShieldedVmConfig.fromPartial(object.shieldedVmConfig)
      : undefined;
    message.networkTags = object.networkTags?.map((e) => e) || [];
    message.encryptionSpec = (object.encryptionSpec !== undefined && object.encryptionSpec !== null)
      ? EncryptionSpec.fromPartial(object.encryptionSpec)
      : undefined;
    return message;
  },
};

function createBaseNotebookRuntimeTemplate_LabelsEntry(): NotebookRuntimeTemplate_LabelsEntry {
  return { key: "", value: "" };
}

export const NotebookRuntimeTemplate_LabelsEntry: MessageFns<NotebookRuntimeTemplate_LabelsEntry> = {
  encode(message: NotebookRuntimeTemplate_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotebookRuntimeTemplate_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotebookRuntimeTemplate_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotebookRuntimeTemplate_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NotebookRuntimeTemplate_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NotebookRuntimeTemplate_LabelsEntry>): NotebookRuntimeTemplate_LabelsEntry {
    return NotebookRuntimeTemplate_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotebookRuntimeTemplate_LabelsEntry>): NotebookRuntimeTemplate_LabelsEntry {
    const message = createBaseNotebookRuntimeTemplate_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNotebookRuntime(): NotebookRuntime {
  return {
    name: "",
    runtimeUser: "",
    notebookRuntimeTemplateRef: undefined,
    proxyUri: "",
    createTime: undefined,
    updateTime: undefined,
    healthState: 0,
    displayName: "",
    description: "",
    serviceAccount: "",
    runtimeState: 0,
    isUpgradable: false,
    labels: {},
    expirationTime: undefined,
    version: "",
    notebookRuntimeType: 0,
    idleShutdownConfig: undefined,
    networkTags: [],
    encryptionSpec: undefined,
    satisfiesPzs: false,
    satisfiesPzi: false,
  };
}

export const NotebookRuntime: MessageFns<NotebookRuntime> = {
  encode(message: NotebookRuntime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.runtimeUser !== "") {
      writer.uint32(18).string(message.runtimeUser);
    }
    if (message.notebookRuntimeTemplateRef !== undefined) {
      NotebookRuntimeTemplateRef.encode(message.notebookRuntimeTemplateRef, writer.uint32(26).fork()).join();
    }
    if (message.proxyUri !== "") {
      writer.uint32(42).string(message.proxyUri);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    if (message.healthState !== 0) {
      writer.uint32(64).int32(message.healthState);
    }
    if (message.displayName !== "") {
      writer.uint32(82).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(106).string(message.serviceAccount);
    }
    if (message.runtimeState !== 0) {
      writer.uint32(112).int32(message.runtimeState);
    }
    if (message.isUpgradable !== false) {
      writer.uint32(120).bool(message.isUpgradable);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      NotebookRuntime_LabelsEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    if (message.expirationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expirationTime), writer.uint32(138).fork()).join();
    }
    if (message.version !== "") {
      writer.uint32(146).string(message.version);
    }
    if (message.notebookRuntimeType !== 0) {
      writer.uint32(152).int32(message.notebookRuntimeType);
    }
    if (message.idleShutdownConfig !== undefined) {
      NotebookIdleShutdownConfig.encode(message.idleShutdownConfig, writer.uint32(186).fork()).join();
    }
    for (const v of message.networkTags) {
      writer.uint32(202).string(v!);
    }
    if (message.encryptionSpec !== undefined) {
      EncryptionSpec.encode(message.encryptionSpec, writer.uint32(226).fork()).join();
    }
    if (message.satisfiesPzs !== false) {
      writer.uint32(232).bool(message.satisfiesPzs);
    }
    if (message.satisfiesPzi !== false) {
      writer.uint32(240).bool(message.satisfiesPzi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotebookRuntime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotebookRuntime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.runtimeUser = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notebookRuntimeTemplateRef = NotebookRuntimeTemplateRef.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.proxyUri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.healthState = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.runtimeState = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.isUpgradable = reader.bool();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          const entry16 = NotebookRuntime_LabelsEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.labels[entry16.key] = entry16.value;
          }
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.expirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.version = reader.string();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.notebookRuntimeType = reader.int32() as any;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.idleShutdownConfig = NotebookIdleShutdownConfig.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.networkTags.push(reader.string());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.encryptionSpec = EncryptionSpec.decode(reader, reader.uint32());
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.satisfiesPzs = reader.bool();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotebookRuntime {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      runtimeUser: isSet(object.runtimeUser) ? globalThis.String(object.runtimeUser) : "",
      notebookRuntimeTemplateRef: isSet(object.notebookRuntimeTemplateRef)
        ? NotebookRuntimeTemplateRef.fromJSON(object.notebookRuntimeTemplateRef)
        : undefined,
      proxyUri: isSet(object.proxyUri) ? globalThis.String(object.proxyUri) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      healthState: isSet(object.healthState) ? notebookRuntime_HealthStateFromJSON(object.healthState) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      runtimeState: isSet(object.runtimeState) ? notebookRuntime_RuntimeStateFromJSON(object.runtimeState) : 0,
      isUpgradable: isSet(object.isUpgradable) ? globalThis.Boolean(object.isUpgradable) : false,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      expirationTime: isSet(object.expirationTime) ? fromJsonTimestamp(object.expirationTime) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      notebookRuntimeType: isSet(object.notebookRuntimeType)
        ? notebookRuntimeTypeFromJSON(object.notebookRuntimeType)
        : 0,
      idleShutdownConfig: isSet(object.idleShutdownConfig)
        ? NotebookIdleShutdownConfig.fromJSON(object.idleShutdownConfig)
        : undefined,
      networkTags: globalThis.Array.isArray(object?.networkTags)
        ? object.networkTags.map((e: any) => globalThis.String(e))
        : [],
      encryptionSpec: isSet(object.encryptionSpec) ? EncryptionSpec.fromJSON(object.encryptionSpec) : undefined,
      satisfiesPzs: isSet(object.satisfiesPzs) ? globalThis.Boolean(object.satisfiesPzs) : false,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : false,
    };
  },

  toJSON(message: NotebookRuntime): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.runtimeUser !== "") {
      obj.runtimeUser = message.runtimeUser;
    }
    if (message.notebookRuntimeTemplateRef !== undefined) {
      obj.notebookRuntimeTemplateRef = NotebookRuntimeTemplateRef.toJSON(message.notebookRuntimeTemplateRef);
    }
    if (message.proxyUri !== "") {
      obj.proxyUri = message.proxyUri;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.healthState !== 0) {
      obj.healthState = notebookRuntime_HealthStateToJSON(message.healthState);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.runtimeState !== 0) {
      obj.runtimeState = notebookRuntime_RuntimeStateToJSON(message.runtimeState);
    }
    if (message.isUpgradable !== false) {
      obj.isUpgradable = message.isUpgradable;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.expirationTime !== undefined) {
      obj.expirationTime = message.expirationTime.toISOString();
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.notebookRuntimeType !== 0) {
      obj.notebookRuntimeType = notebookRuntimeTypeToJSON(message.notebookRuntimeType);
    }
    if (message.idleShutdownConfig !== undefined) {
      obj.idleShutdownConfig = NotebookIdleShutdownConfig.toJSON(message.idleShutdownConfig);
    }
    if (message.networkTags?.length) {
      obj.networkTags = message.networkTags;
    }
    if (message.encryptionSpec !== undefined) {
      obj.encryptionSpec = EncryptionSpec.toJSON(message.encryptionSpec);
    }
    if (message.satisfiesPzs !== false) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== false) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    return obj;
  },

  create(base?: DeepPartial<NotebookRuntime>): NotebookRuntime {
    return NotebookRuntime.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotebookRuntime>): NotebookRuntime {
    const message = createBaseNotebookRuntime();
    message.name = object.name ?? "";
    message.runtimeUser = object.runtimeUser ?? "";
    message.notebookRuntimeTemplateRef =
      (object.notebookRuntimeTemplateRef !== undefined && object.notebookRuntimeTemplateRef !== null)
        ? NotebookRuntimeTemplateRef.fromPartial(object.notebookRuntimeTemplateRef)
        : undefined;
    message.proxyUri = object.proxyUri ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.healthState = object.healthState ?? 0;
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    message.runtimeState = object.runtimeState ?? 0;
    message.isUpgradable = object.isUpgradable ?? false;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.expirationTime = object.expirationTime ?? undefined;
    message.version = object.version ?? "";
    message.notebookRuntimeType = object.notebookRuntimeType ?? 0;
    message.idleShutdownConfig = (object.idleShutdownConfig !== undefined && object.idleShutdownConfig !== null)
      ? NotebookIdleShutdownConfig.fromPartial(object.idleShutdownConfig)
      : undefined;
    message.networkTags = object.networkTags?.map((e) => e) || [];
    message.encryptionSpec = (object.encryptionSpec !== undefined && object.encryptionSpec !== null)
      ? EncryptionSpec.fromPartial(object.encryptionSpec)
      : undefined;
    message.satisfiesPzs = object.satisfiesPzs ?? false;
    message.satisfiesPzi = object.satisfiesPzi ?? false;
    return message;
  },
};

function createBaseNotebookRuntime_LabelsEntry(): NotebookRuntime_LabelsEntry {
  return { key: "", value: "" };
}

export const NotebookRuntime_LabelsEntry: MessageFns<NotebookRuntime_LabelsEntry> = {
  encode(message: NotebookRuntime_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotebookRuntime_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotebookRuntime_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotebookRuntime_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NotebookRuntime_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NotebookRuntime_LabelsEntry>): NotebookRuntime_LabelsEntry {
    return NotebookRuntime_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotebookRuntime_LabelsEntry>): NotebookRuntime_LabelsEntry {
    const message = createBaseNotebookRuntime_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
