// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1/match_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { IndexDatapoint } from "./index.js";

export const protobufPackage = "google.cloud.aiplatform.v1";

/**
 * The request message for
 * [MatchService.FindNeighbors][google.cloud.aiplatform.v1.MatchService.FindNeighbors].
 */
export interface FindNeighborsRequest {
  /**
   * Required. The name of the index endpoint.
   * Format:
   * `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
   */
  indexEndpoint: string;
  /**
   * The ID of the DeployedIndex that will serve the request. This request is
   * sent to a specific IndexEndpoint, as per the IndexEndpoint.network. That
   * IndexEndpoint also has IndexEndpoint.deployed_indexes, and each such index
   * has a DeployedIndex.id field.
   * The value of the field below must equal one of the DeployedIndex.id
   * fields of the IndexEndpoint that is being called for this request.
   */
  deployedIndexId: string;
  /** The list of queries. */
  queries: FindNeighborsRequest_Query[];
  /**
   * If set to true, the full datapoints (including all vector values and
   * restricts) of the nearest neighbors are returned.
   * Note that returning full datapoint will significantly increase the
   * latency and cost of the query.
   */
  returnFullDatapoint: boolean;
}

/**
 * A query to find a number of the nearest neighbors (most similar vectors)
 * of a vector.
 */
export interface FindNeighborsRequest_Query {
  /** Optional. Represents RRF algorithm that combines search results. */
  rrf?:
    | FindNeighborsRequest_Query_RRF
    | undefined;
  /**
   * Required. The datapoint/vector whose nearest neighbors should be searched
   * for.
   */
  datapoint:
    | IndexDatapoint
    | undefined;
  /**
   * The number of nearest neighbors to be retrieved from database for each
   * query. If not set, will use the default from the service configuration
   * (https://cloud.google.com/vertex-ai/docs/matching-engine/configuring-indexes#nearest-neighbor-search-config).
   */
  neighborCount: number;
  /**
   * Crowding is a constraint on a neighbor list produced by nearest neighbor
   * search requiring that no more than some value k' of the k neighbors
   * returned have the same value of crowding_attribute.
   * It's used for improving result diversity.
   * This field is the maximum number of matches with the same crowding tag.
   */
  perCrowdingAttributeNeighborCount: number;
  /**
   * The number of neighbors to find via approximate search before
   * exact reordering is performed. If not set, the default value from scam
   * config is used; if set, this value must be > 0.
   */
  approximateNeighborCount: number;
  /**
   * The fraction of the number of leaves to search, set at query time allows
   * user to tune search performance. This value increase result in both
   * search accuracy and latency increase. The value should be between 0.0
   * and 1.0. If not set or set to 0.0, query uses the default value specified
   * in
   * NearestNeighborSearchConfig.TreeAHConfig.fraction_leaf_nodes_to_search.
   */
  fractionLeafNodesToSearchOverride: number;
}

/** Parameters for RRF algorithm that combines search results. */
export interface FindNeighborsRequest_Query_RRF {
  /**
   * Required. Users can provide an alpha value to give more weight to dense
   * vs sparse results. For example, if the alpha is 0, we only return
   * sparse and if the alpha is 1, we only return dense.
   */
  alpha: number;
}

/**
 * The response message for
 * [MatchService.FindNeighbors][google.cloud.aiplatform.v1.MatchService.FindNeighbors].
 */
export interface FindNeighborsResponse {
  /** The nearest neighbors of the query datapoints. */
  nearestNeighbors: FindNeighborsResponse_NearestNeighbors[];
}

/** A neighbor of the query vector. */
export interface FindNeighborsResponse_Neighbor {
  /**
   * The datapoint of the neighbor.
   * Note that full datapoints are returned only when "return_full_datapoint"
   * is set to true. Otherwise, only the "datapoint_id" and "crowding_tag"
   * fields are populated.
   */
  datapoint:
    | IndexDatapoint
    | undefined;
  /** The distance between the neighbor and the dense embedding query. */
  distance: number;
  /** The distance between the neighbor and the query sparse_embedding. */
  sparseDistance: number;
}

/** Nearest neighbors for one query. */
export interface FindNeighborsResponse_NearestNeighbors {
  /** The ID of the query datapoint. */
  id: string;
  /** All its neighbors. */
  neighbors: FindNeighborsResponse_Neighbor[];
}

/**
 * The request message for
 * [MatchService.ReadIndexDatapoints][google.cloud.aiplatform.v1.MatchService.ReadIndexDatapoints].
 */
export interface ReadIndexDatapointsRequest {
  /**
   * Required. The name of the index endpoint.
   * Format:
   * `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
   */
  indexEndpoint: string;
  /** The ID of the DeployedIndex that will serve the request. */
  deployedIndexId: string;
  /** IDs of the datapoints to be searched for. */
  ids: string[];
}

/**
 * The response message for
 * [MatchService.ReadIndexDatapoints][google.cloud.aiplatform.v1.MatchService.ReadIndexDatapoints].
 */
export interface ReadIndexDatapointsResponse {
  /** The result list of datapoints. */
  datapoints: IndexDatapoint[];
}

function createBaseFindNeighborsRequest(): FindNeighborsRequest {
  return { indexEndpoint: "", deployedIndexId: "", queries: [], returnFullDatapoint: false };
}

export const FindNeighborsRequest: MessageFns<FindNeighborsRequest> = {
  encode(message: FindNeighborsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexEndpoint !== "") {
      writer.uint32(10).string(message.indexEndpoint);
    }
    if (message.deployedIndexId !== "") {
      writer.uint32(18).string(message.deployedIndexId);
    }
    for (const v of message.queries) {
      FindNeighborsRequest_Query.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.returnFullDatapoint !== false) {
      writer.uint32(32).bool(message.returnFullDatapoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindNeighborsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindNeighborsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.indexEndpoint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deployedIndexId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.queries.push(FindNeighborsRequest_Query.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.returnFullDatapoint = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindNeighborsRequest {
    return {
      indexEndpoint: isSet(object.indexEndpoint) ? globalThis.String(object.indexEndpoint) : "",
      deployedIndexId: isSet(object.deployedIndexId) ? globalThis.String(object.deployedIndexId) : "",
      queries: globalThis.Array.isArray(object?.queries)
        ? object.queries.map((e: any) => FindNeighborsRequest_Query.fromJSON(e))
        : [],
      returnFullDatapoint: isSet(object.returnFullDatapoint) ? globalThis.Boolean(object.returnFullDatapoint) : false,
    };
  },

  toJSON(message: FindNeighborsRequest): unknown {
    const obj: any = {};
    if (message.indexEndpoint !== "") {
      obj.indexEndpoint = message.indexEndpoint;
    }
    if (message.deployedIndexId !== "") {
      obj.deployedIndexId = message.deployedIndexId;
    }
    if (message.queries?.length) {
      obj.queries = message.queries.map((e) => FindNeighborsRequest_Query.toJSON(e));
    }
    if (message.returnFullDatapoint !== false) {
      obj.returnFullDatapoint = message.returnFullDatapoint;
    }
    return obj;
  },

  create(base?: DeepPartial<FindNeighborsRequest>): FindNeighborsRequest {
    return FindNeighborsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FindNeighborsRequest>): FindNeighborsRequest {
    const message = createBaseFindNeighborsRequest();
    message.indexEndpoint = object.indexEndpoint ?? "";
    message.deployedIndexId = object.deployedIndexId ?? "";
    message.queries = object.queries?.map((e) => FindNeighborsRequest_Query.fromPartial(e)) || [];
    message.returnFullDatapoint = object.returnFullDatapoint ?? false;
    return message;
  },
};

function createBaseFindNeighborsRequest_Query(): FindNeighborsRequest_Query {
  return {
    rrf: undefined,
    datapoint: undefined,
    neighborCount: 0,
    perCrowdingAttributeNeighborCount: 0,
    approximateNeighborCount: 0,
    fractionLeafNodesToSearchOverride: 0,
  };
}

export const FindNeighborsRequest_Query: MessageFns<FindNeighborsRequest_Query> = {
  encode(message: FindNeighborsRequest_Query, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rrf !== undefined) {
      FindNeighborsRequest_Query_RRF.encode(message.rrf, writer.uint32(50).fork()).join();
    }
    if (message.datapoint !== undefined) {
      IndexDatapoint.encode(message.datapoint, writer.uint32(10).fork()).join();
    }
    if (message.neighborCount !== 0) {
      writer.uint32(16).int32(message.neighborCount);
    }
    if (message.perCrowdingAttributeNeighborCount !== 0) {
      writer.uint32(24).int32(message.perCrowdingAttributeNeighborCount);
    }
    if (message.approximateNeighborCount !== 0) {
      writer.uint32(32).int32(message.approximateNeighborCount);
    }
    if (message.fractionLeafNodesToSearchOverride !== 0) {
      writer.uint32(41).double(message.fractionLeafNodesToSearchOverride);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindNeighborsRequest_Query {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindNeighborsRequest_Query();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rrf = FindNeighborsRequest_Query_RRF.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datapoint = IndexDatapoint.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.neighborCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.perCrowdingAttributeNeighborCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.approximateNeighborCount = reader.int32();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.fractionLeafNodesToSearchOverride = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindNeighborsRequest_Query {
    return {
      rrf: isSet(object.rrf) ? FindNeighborsRequest_Query_RRF.fromJSON(object.rrf) : undefined,
      datapoint: isSet(object.datapoint) ? IndexDatapoint.fromJSON(object.datapoint) : undefined,
      neighborCount: isSet(object.neighborCount) ? globalThis.Number(object.neighborCount) : 0,
      perCrowdingAttributeNeighborCount: isSet(object.perCrowdingAttributeNeighborCount)
        ? globalThis.Number(object.perCrowdingAttributeNeighborCount)
        : 0,
      approximateNeighborCount: isSet(object.approximateNeighborCount)
        ? globalThis.Number(object.approximateNeighborCount)
        : 0,
      fractionLeafNodesToSearchOverride: isSet(object.fractionLeafNodesToSearchOverride)
        ? globalThis.Number(object.fractionLeafNodesToSearchOverride)
        : 0,
    };
  },

  toJSON(message: FindNeighborsRequest_Query): unknown {
    const obj: any = {};
    if (message.rrf !== undefined) {
      obj.rrf = FindNeighborsRequest_Query_RRF.toJSON(message.rrf);
    }
    if (message.datapoint !== undefined) {
      obj.datapoint = IndexDatapoint.toJSON(message.datapoint);
    }
    if (message.neighborCount !== 0) {
      obj.neighborCount = Math.round(message.neighborCount);
    }
    if (message.perCrowdingAttributeNeighborCount !== 0) {
      obj.perCrowdingAttributeNeighborCount = Math.round(message.perCrowdingAttributeNeighborCount);
    }
    if (message.approximateNeighborCount !== 0) {
      obj.approximateNeighborCount = Math.round(message.approximateNeighborCount);
    }
    if (message.fractionLeafNodesToSearchOverride !== 0) {
      obj.fractionLeafNodesToSearchOverride = message.fractionLeafNodesToSearchOverride;
    }
    return obj;
  },

  create(base?: DeepPartial<FindNeighborsRequest_Query>): FindNeighborsRequest_Query {
    return FindNeighborsRequest_Query.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FindNeighborsRequest_Query>): FindNeighborsRequest_Query {
    const message = createBaseFindNeighborsRequest_Query();
    message.rrf = (object.rrf !== undefined && object.rrf !== null)
      ? FindNeighborsRequest_Query_RRF.fromPartial(object.rrf)
      : undefined;
    message.datapoint = (object.datapoint !== undefined && object.datapoint !== null)
      ? IndexDatapoint.fromPartial(object.datapoint)
      : undefined;
    message.neighborCount = object.neighborCount ?? 0;
    message.perCrowdingAttributeNeighborCount = object.perCrowdingAttributeNeighborCount ?? 0;
    message.approximateNeighborCount = object.approximateNeighborCount ?? 0;
    message.fractionLeafNodesToSearchOverride = object.fractionLeafNodesToSearchOverride ?? 0;
    return message;
  },
};

function createBaseFindNeighborsRequest_Query_RRF(): FindNeighborsRequest_Query_RRF {
  return { alpha: 0 };
}

export const FindNeighborsRequest_Query_RRF: MessageFns<FindNeighborsRequest_Query_RRF> = {
  encode(message: FindNeighborsRequest_Query_RRF, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alpha !== 0) {
      writer.uint32(13).float(message.alpha);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindNeighborsRequest_Query_RRF {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindNeighborsRequest_Query_RRF();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.alpha = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindNeighborsRequest_Query_RRF {
    return { alpha: isSet(object.alpha) ? globalThis.Number(object.alpha) : 0 };
  },

  toJSON(message: FindNeighborsRequest_Query_RRF): unknown {
    const obj: any = {};
    if (message.alpha !== 0) {
      obj.alpha = message.alpha;
    }
    return obj;
  },

  create(base?: DeepPartial<FindNeighborsRequest_Query_RRF>): FindNeighborsRequest_Query_RRF {
    return FindNeighborsRequest_Query_RRF.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FindNeighborsRequest_Query_RRF>): FindNeighborsRequest_Query_RRF {
    const message = createBaseFindNeighborsRequest_Query_RRF();
    message.alpha = object.alpha ?? 0;
    return message;
  },
};

function createBaseFindNeighborsResponse(): FindNeighborsResponse {
  return { nearestNeighbors: [] };
}

export const FindNeighborsResponse: MessageFns<FindNeighborsResponse> = {
  encode(message: FindNeighborsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nearestNeighbors) {
      FindNeighborsResponse_NearestNeighbors.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindNeighborsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindNeighborsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nearestNeighbors.push(FindNeighborsResponse_NearestNeighbors.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindNeighborsResponse {
    return {
      nearestNeighbors: globalThis.Array.isArray(object?.nearestNeighbors)
        ? object.nearestNeighbors.map((e: any) => FindNeighborsResponse_NearestNeighbors.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FindNeighborsResponse): unknown {
    const obj: any = {};
    if (message.nearestNeighbors?.length) {
      obj.nearestNeighbors = message.nearestNeighbors.map((e) => FindNeighborsResponse_NearestNeighbors.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FindNeighborsResponse>): FindNeighborsResponse {
    return FindNeighborsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FindNeighborsResponse>): FindNeighborsResponse {
    const message = createBaseFindNeighborsResponse();
    message.nearestNeighbors =
      object.nearestNeighbors?.map((e) => FindNeighborsResponse_NearestNeighbors.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFindNeighborsResponse_Neighbor(): FindNeighborsResponse_Neighbor {
  return { datapoint: undefined, distance: 0, sparseDistance: 0 };
}

export const FindNeighborsResponse_Neighbor: MessageFns<FindNeighborsResponse_Neighbor> = {
  encode(message: FindNeighborsResponse_Neighbor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datapoint !== undefined) {
      IndexDatapoint.encode(message.datapoint, writer.uint32(10).fork()).join();
    }
    if (message.distance !== 0) {
      writer.uint32(17).double(message.distance);
    }
    if (message.sparseDistance !== 0) {
      writer.uint32(25).double(message.sparseDistance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindNeighborsResponse_Neighbor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindNeighborsResponse_Neighbor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datapoint = IndexDatapoint.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.sparseDistance = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindNeighborsResponse_Neighbor {
    return {
      datapoint: isSet(object.datapoint) ? IndexDatapoint.fromJSON(object.datapoint) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
      sparseDistance: isSet(object.sparseDistance) ? globalThis.Number(object.sparseDistance) : 0,
    };
  },

  toJSON(message: FindNeighborsResponse_Neighbor): unknown {
    const obj: any = {};
    if (message.datapoint !== undefined) {
      obj.datapoint = IndexDatapoint.toJSON(message.datapoint);
    }
    if (message.distance !== 0) {
      obj.distance = message.distance;
    }
    if (message.sparseDistance !== 0) {
      obj.sparseDistance = message.sparseDistance;
    }
    return obj;
  },

  create(base?: DeepPartial<FindNeighborsResponse_Neighbor>): FindNeighborsResponse_Neighbor {
    return FindNeighborsResponse_Neighbor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FindNeighborsResponse_Neighbor>): FindNeighborsResponse_Neighbor {
    const message = createBaseFindNeighborsResponse_Neighbor();
    message.datapoint = (object.datapoint !== undefined && object.datapoint !== null)
      ? IndexDatapoint.fromPartial(object.datapoint)
      : undefined;
    message.distance = object.distance ?? 0;
    message.sparseDistance = object.sparseDistance ?? 0;
    return message;
  },
};

function createBaseFindNeighborsResponse_NearestNeighbors(): FindNeighborsResponse_NearestNeighbors {
  return { id: "", neighbors: [] };
}

export const FindNeighborsResponse_NearestNeighbors: MessageFns<FindNeighborsResponse_NearestNeighbors> = {
  encode(message: FindNeighborsResponse_NearestNeighbors, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.neighbors) {
      FindNeighborsResponse_Neighbor.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindNeighborsResponse_NearestNeighbors {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindNeighborsResponse_NearestNeighbors();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.neighbors.push(FindNeighborsResponse_Neighbor.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindNeighborsResponse_NearestNeighbors {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      neighbors: globalThis.Array.isArray(object?.neighbors)
        ? object.neighbors.map((e: any) => FindNeighborsResponse_Neighbor.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FindNeighborsResponse_NearestNeighbors): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.neighbors?.length) {
      obj.neighbors = message.neighbors.map((e) => FindNeighborsResponse_Neighbor.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FindNeighborsResponse_NearestNeighbors>): FindNeighborsResponse_NearestNeighbors {
    return FindNeighborsResponse_NearestNeighbors.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FindNeighborsResponse_NearestNeighbors>): FindNeighborsResponse_NearestNeighbors {
    const message = createBaseFindNeighborsResponse_NearestNeighbors();
    message.id = object.id ?? "";
    message.neighbors = object.neighbors?.map((e) => FindNeighborsResponse_Neighbor.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReadIndexDatapointsRequest(): ReadIndexDatapointsRequest {
  return { indexEndpoint: "", deployedIndexId: "", ids: [] };
}

export const ReadIndexDatapointsRequest: MessageFns<ReadIndexDatapointsRequest> = {
  encode(message: ReadIndexDatapointsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexEndpoint !== "") {
      writer.uint32(10).string(message.indexEndpoint);
    }
    if (message.deployedIndexId !== "") {
      writer.uint32(18).string(message.deployedIndexId);
    }
    for (const v of message.ids) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadIndexDatapointsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadIndexDatapointsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.indexEndpoint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deployedIndexId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadIndexDatapointsRequest {
    return {
      indexEndpoint: isSet(object.indexEndpoint) ? globalThis.String(object.indexEndpoint) : "",
      deployedIndexId: isSet(object.deployedIndexId) ? globalThis.String(object.deployedIndexId) : "",
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ReadIndexDatapointsRequest): unknown {
    const obj: any = {};
    if (message.indexEndpoint !== "") {
      obj.indexEndpoint = message.indexEndpoint;
    }
    if (message.deployedIndexId !== "") {
      obj.deployedIndexId = message.deployedIndexId;
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create(base?: DeepPartial<ReadIndexDatapointsRequest>): ReadIndexDatapointsRequest {
    return ReadIndexDatapointsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadIndexDatapointsRequest>): ReadIndexDatapointsRequest {
    const message = createBaseReadIndexDatapointsRequest();
    message.indexEndpoint = object.indexEndpoint ?? "";
    message.deployedIndexId = object.deployedIndexId ?? "";
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseReadIndexDatapointsResponse(): ReadIndexDatapointsResponse {
  return { datapoints: [] };
}

export const ReadIndexDatapointsResponse: MessageFns<ReadIndexDatapointsResponse> = {
  encode(message: ReadIndexDatapointsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.datapoints) {
      IndexDatapoint.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadIndexDatapointsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadIndexDatapointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datapoints.push(IndexDatapoint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadIndexDatapointsResponse {
    return {
      datapoints: globalThis.Array.isArray(object?.datapoints)
        ? object.datapoints.map((e: any) => IndexDatapoint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReadIndexDatapointsResponse): unknown {
    const obj: any = {};
    if (message.datapoints?.length) {
      obj.datapoints = message.datapoints.map((e) => IndexDatapoint.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReadIndexDatapointsResponse>): ReadIndexDatapointsResponse {
    return ReadIndexDatapointsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReadIndexDatapointsResponse>): ReadIndexDatapointsResponse {
    const message = createBaseReadIndexDatapointsResponse();
    message.datapoints = object.datapoints?.map((e) => IndexDatapoint.fromPartial(e)) || [];
    return message;
  },
};

/**
 * MatchService is a Google managed service for efficient vector similarity
 * search at scale.
 */
export type MatchServiceDefinition = typeof MatchServiceDefinition;
export const MatchServiceDefinition = {
  name: "MatchService",
  fullName: "google.cloud.aiplatform.v1.MatchService",
  methods: {
    /** Finds the nearest neighbors of each vector within the request. */
    findNeighbors: {
      name: "FindNeighbors",
      requestType: FindNeighborsRequest,
      requestStream: false,
      responseType: FindNeighborsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              79,
              58,
              1,
              42,
              34,
              74,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              100,
              101,
              120,
              95,
              101,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              102,
              105,
              110,
              100,
              78,
              101,
              105,
              103,
              104,
              98,
              111,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Reads the datapoints/vectors of the given IDs.
     * A maximum of 1000 datapoints can be retrieved in a batch.
     */
    readIndexDatapoints: {
      name: "ReadIndexDatapoints",
      requestType: ReadIndexDatapointsRequest,
      requestStream: false,
      responseType: ReadIndexDatapointsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              85,
              58,
              1,
              42,
              34,
              80,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              100,
              101,
              120,
              95,
              101,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              97,
              100,
              73,
              110,
              100,
              101,
              120,
              68,
              97,
              116,
              97,
              112,
              111,
              105,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface MatchServiceImplementation<CallContextExt = {}> {
  /** Finds the nearest neighbors of each vector within the request. */
  findNeighbors(
    request: FindNeighborsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FindNeighborsResponse>>;
  /**
   * Reads the datapoints/vectors of the given IDs.
   * A maximum of 1000 datapoints can be retrieved in a batch.
   */
  readIndexDatapoints(
    request: ReadIndexDatapointsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReadIndexDatapointsResponse>>;
}

export interface MatchServiceClient<CallOptionsExt = {}> {
  /** Finds the nearest neighbors of each vector within the request. */
  findNeighbors(
    request: DeepPartial<FindNeighborsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FindNeighborsResponse>;
  /**
   * Reads the datapoints/vectors of the given IDs.
   * A maximum of 1000 datapoints can be retrieved in a batch.
   */
  readIndexDatapoints(
    request: DeepPartial<ReadIndexDatapointsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReadIndexDatapointsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
