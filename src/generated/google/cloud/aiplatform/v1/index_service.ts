// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/aiplatform/v1/index_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Index, IndexDatapoint } from "./index.js";
import { GenericOperationMetadata } from "./operation.js";

export const protobufPackage = "google.cloud.aiplatform.v1";

/**
 * Request message for
 * [IndexService.CreateIndex][google.cloud.aiplatform.v1.IndexService.CreateIndex].
 */
export interface CreateIndexRequest {
  /**
   * Required. The resource name of the Location to create the Index in.
   * Format: `projects/{project}/locations/{location}`
   */
  parent: string;
  /** Required. The Index to create. */
  index: Index | undefined;
}

/**
 * Runtime operation information for
 * [IndexService.CreateIndex][google.cloud.aiplatform.v1.IndexService.CreateIndex].
 */
export interface CreateIndexOperationMetadata {
  /** The operation generic information. */
  genericMetadata:
    | GenericOperationMetadata
    | undefined;
  /** The operation metadata with regard to Matching Engine Index operation. */
  nearestNeighborSearchOperationMetadata: NearestNeighborSearchOperationMetadata | undefined;
}

/**
 * Request message for
 * [IndexService.GetIndex][google.cloud.aiplatform.v1.IndexService.GetIndex]
 */
export interface GetIndexRequest {
  /**
   * Required. The name of the Index resource.
   * Format:
   * `projects/{project}/locations/{location}/indexes/{index}`
   */
  name: string;
}

/**
 * Request message for
 * [IndexService.ListIndexes][google.cloud.aiplatform.v1.IndexService.ListIndexes].
 */
export interface ListIndexesRequest {
  /**
   * Required. The resource name of the Location from which to list the Indexes.
   * Format: `projects/{project}/locations/{location}`
   */
  parent: string;
  /** The standard list filter. */
  filter: string;
  /** The standard list page size. */
  pageSize: number;
  /**
   * The standard list page token.
   * Typically obtained via
   * [ListIndexesResponse.next_page_token][google.cloud.aiplatform.v1.ListIndexesResponse.next_page_token]
   * of the previous
   * [IndexService.ListIndexes][google.cloud.aiplatform.v1.IndexService.ListIndexes]
   * call.
   */
  pageToken: string;
  /** Mask specifying which fields to read. */
  readMask: string[] | undefined;
}

/**
 * Response message for
 * [IndexService.ListIndexes][google.cloud.aiplatform.v1.IndexService.ListIndexes].
 */
export interface ListIndexesResponse {
  /** List of indexes in the requested page. */
  indexes: Index[];
  /**
   * A token to retrieve next page of results.
   * Pass to
   * [ListIndexesRequest.page_token][google.cloud.aiplatform.v1.ListIndexesRequest.page_token]
   * to obtain that page.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [IndexService.UpdateIndex][google.cloud.aiplatform.v1.IndexService.UpdateIndex].
 */
export interface UpdateIndexRequest {
  /** Required. The Index which updates the resource on the server. */
  index:
    | Index
    | undefined;
  /**
   * The update mask applies to the resource.
   * For the `FieldMask` definition, see
   * [google.protobuf.FieldMask][google.protobuf.FieldMask].
   */
  updateMask: string[] | undefined;
}

/**
 * Runtime operation information for
 * [IndexService.UpdateIndex][google.cloud.aiplatform.v1.IndexService.UpdateIndex].
 */
export interface UpdateIndexOperationMetadata {
  /** The operation generic information. */
  genericMetadata:
    | GenericOperationMetadata
    | undefined;
  /** The operation metadata with regard to Matching Engine Index operation. */
  nearestNeighborSearchOperationMetadata: NearestNeighborSearchOperationMetadata | undefined;
}

/**
 * Request message for
 * [IndexService.DeleteIndex][google.cloud.aiplatform.v1.IndexService.DeleteIndex].
 */
export interface DeleteIndexRequest {
  /**
   * Required. The name of the Index resource to be deleted.
   * Format:
   * `projects/{project}/locations/{location}/indexes/{index}`
   */
  name: string;
}

/**
 * Request message for
 * [IndexService.UpsertDatapoints][google.cloud.aiplatform.v1.IndexService.UpsertDatapoints]
 */
export interface UpsertDatapointsRequest {
  /**
   * Required. The name of the Index resource to be updated.
   * Format:
   * `projects/{project}/locations/{location}/indexes/{index}`
   */
  index: string;
  /** A list of datapoints to be created/updated. */
  datapoints: IndexDatapoint[];
  /**
   * Optional. Update mask is used to specify the fields to be overwritten in
   * the datapoints by the update. The fields specified in the update_mask are
   * relative to each IndexDatapoint inside datapoints, not the full request.
   *
   * Updatable fields:
   *
   *   * Use `all_restricts` to update both restricts and numeric_restricts.
   */
  updateMask: string[] | undefined;
}

/**
 * Response message for
 * [IndexService.UpsertDatapoints][google.cloud.aiplatform.v1.IndexService.UpsertDatapoints]
 */
export interface UpsertDatapointsResponse {
}

/**
 * Request message for
 * [IndexService.RemoveDatapoints][google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]
 */
export interface RemoveDatapointsRequest {
  /**
   * Required. The name of the Index resource to be updated.
   * Format:
   * `projects/{project}/locations/{location}/indexes/{index}`
   */
  index: string;
  /** A list of datapoint ids to be deleted. */
  datapointIds: string[];
}

/**
 * Response message for
 * [IndexService.RemoveDatapoints][google.cloud.aiplatform.v1.IndexService.RemoveDatapoints]
 */
export interface RemoveDatapointsResponse {
}

/** Runtime operation metadata with regard to Matching Engine Index. */
export interface NearestNeighborSearchOperationMetadata {
  /**
   * The validation stats of the content (per file) to be inserted or
   * updated on the Matching Engine Index resource. Populated if
   * contentsDeltaUri is provided as part of
   * [Index.metadata][google.cloud.aiplatform.v1.Index.metadata]. Please note
   * that, currently for those files that are broken or has unsupported file
   * format, we will not have the stats for those files.
   */
  contentValidationStats: NearestNeighborSearchOperationMetadata_ContentValidationStats[];
  /** The ingested data size in bytes. */
  dataBytesCount: Long;
}

export interface NearestNeighborSearchOperationMetadata_RecordError {
  /** The error type of this record. */
  errorType: NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType;
  /**
   * A human-readable message that is shown to the user to help them fix the
   * error. Note that this message may change from time to time, your code
   * should check against error_type as the source of truth.
   */
  errorMessage: string;
  /** Cloud Storage URI pointing to the original file in user's bucket. */
  sourceGcsUri: string;
  /** Empty if the embedding id is failed to parse. */
  embeddingId: string;
  /** The original content of this record. */
  rawRecord: string;
}

export enum NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType {
  /** ERROR_TYPE_UNSPECIFIED - Default, shall not be used. */
  ERROR_TYPE_UNSPECIFIED = 0,
  /** EMPTY_LINE - The record is empty. */
  EMPTY_LINE = 1,
  /** INVALID_JSON_SYNTAX - Invalid json format. */
  INVALID_JSON_SYNTAX = 2,
  /** INVALID_CSV_SYNTAX - Invalid csv format. */
  INVALID_CSV_SYNTAX = 3,
  /** INVALID_AVRO_SYNTAX - Invalid avro format. */
  INVALID_AVRO_SYNTAX = 4,
  /** INVALID_EMBEDDING_ID - The embedding id is not valid. */
  INVALID_EMBEDDING_ID = 5,
  /**
   * EMBEDDING_SIZE_MISMATCH - The size of the dense embedding vectors does not match with the
   * specified dimension.
   */
  EMBEDDING_SIZE_MISMATCH = 6,
  /** NAMESPACE_MISSING - The `namespace` field is missing. */
  NAMESPACE_MISSING = 7,
  /**
   * PARSING_ERROR - Generic catch-all error. Only used for validation failure where the
   * root cause cannot be easily retrieved programmatically.
   */
  PARSING_ERROR = 8,
  /** DUPLICATE_NAMESPACE - There are multiple restricts with the same `namespace` value. */
  DUPLICATE_NAMESPACE = 9,
  /** OP_IN_DATAPOINT - Numeric restrict has operator specified in datapoint. */
  OP_IN_DATAPOINT = 10,
  /** MULTIPLE_VALUES - Numeric restrict has multiple values specified. */
  MULTIPLE_VALUES = 11,
  /** INVALID_NUMERIC_VALUE - Numeric restrict has invalid numeric value specified. */
  INVALID_NUMERIC_VALUE = 12,
  /** INVALID_ENCODING - File is not in UTF_8 format. */
  INVALID_ENCODING = 13,
  /** INVALID_SPARSE_DIMENSIONS - Error parsing sparse dimensions field. */
  INVALID_SPARSE_DIMENSIONS = 14,
  /** INVALID_TOKEN_VALUE - Token restrict value is invalid. */
  INVALID_TOKEN_VALUE = 15,
  /** INVALID_SPARSE_EMBEDDING - Invalid sparse embedding. */
  INVALID_SPARSE_EMBEDDING = 16,
  /** INVALID_EMBEDDING - Invalid dense embedding. */
  INVALID_EMBEDDING = 17,
  UNRECOGNIZED = -1,
}

export function nearestNeighborSearchOperationMetadata_RecordError_RecordErrorTypeFromJSON(
  object: any,
): NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType {
  switch (object) {
    case 0:
    case "ERROR_TYPE_UNSPECIFIED":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.ERROR_TYPE_UNSPECIFIED;
    case 1:
    case "EMPTY_LINE":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.EMPTY_LINE;
    case 2:
    case "INVALID_JSON_SYNTAX":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_JSON_SYNTAX;
    case 3:
    case "INVALID_CSV_SYNTAX":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_CSV_SYNTAX;
    case 4:
    case "INVALID_AVRO_SYNTAX":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_AVRO_SYNTAX;
    case 5:
    case "INVALID_EMBEDDING_ID":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_EMBEDDING_ID;
    case 6:
    case "EMBEDDING_SIZE_MISMATCH":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.EMBEDDING_SIZE_MISMATCH;
    case 7:
    case "NAMESPACE_MISSING":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.NAMESPACE_MISSING;
    case 8:
    case "PARSING_ERROR":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.PARSING_ERROR;
    case 9:
    case "DUPLICATE_NAMESPACE":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.DUPLICATE_NAMESPACE;
    case 10:
    case "OP_IN_DATAPOINT":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.OP_IN_DATAPOINT;
    case 11:
    case "MULTIPLE_VALUES":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.MULTIPLE_VALUES;
    case 12:
    case "INVALID_NUMERIC_VALUE":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_NUMERIC_VALUE;
    case 13:
    case "INVALID_ENCODING":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_ENCODING;
    case 14:
    case "INVALID_SPARSE_DIMENSIONS":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_SPARSE_DIMENSIONS;
    case 15:
    case "INVALID_TOKEN_VALUE":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_TOKEN_VALUE;
    case 16:
    case "INVALID_SPARSE_EMBEDDING":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_SPARSE_EMBEDDING;
    case 17:
    case "INVALID_EMBEDDING":
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_EMBEDDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.UNRECOGNIZED;
  }
}

export function nearestNeighborSearchOperationMetadata_RecordError_RecordErrorTypeToJSON(
  object: NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType,
): string {
  switch (object) {
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.ERROR_TYPE_UNSPECIFIED:
      return "ERROR_TYPE_UNSPECIFIED";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.EMPTY_LINE:
      return "EMPTY_LINE";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_JSON_SYNTAX:
      return "INVALID_JSON_SYNTAX";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_CSV_SYNTAX:
      return "INVALID_CSV_SYNTAX";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_AVRO_SYNTAX:
      return "INVALID_AVRO_SYNTAX";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_EMBEDDING_ID:
      return "INVALID_EMBEDDING_ID";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.EMBEDDING_SIZE_MISMATCH:
      return "EMBEDDING_SIZE_MISMATCH";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.NAMESPACE_MISSING:
      return "NAMESPACE_MISSING";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.PARSING_ERROR:
      return "PARSING_ERROR";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.DUPLICATE_NAMESPACE:
      return "DUPLICATE_NAMESPACE";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.OP_IN_DATAPOINT:
      return "OP_IN_DATAPOINT";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.MULTIPLE_VALUES:
      return "MULTIPLE_VALUES";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_NUMERIC_VALUE:
      return "INVALID_NUMERIC_VALUE";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_ENCODING:
      return "INVALID_ENCODING";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_SPARSE_DIMENSIONS:
      return "INVALID_SPARSE_DIMENSIONS";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_TOKEN_VALUE:
      return "INVALID_TOKEN_VALUE";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_SPARSE_EMBEDDING:
      return "INVALID_SPARSE_EMBEDDING";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.INVALID_EMBEDDING:
      return "INVALID_EMBEDDING";
    case NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface NearestNeighborSearchOperationMetadata_ContentValidationStats {
  /** Cloud Storage URI pointing to the original file in user's bucket. */
  sourceGcsUri: string;
  /** Number of records in this file that were successfully processed. */
  validRecordCount: Long;
  /** Number of records in this file we skipped due to validate errors. */
  invalidRecordCount: Long;
  /**
   * The detail information of the partial failures encountered for those
   * invalid records that couldn't be parsed.
   * Up to 50 partial errors will be reported.
   */
  partialErrors: NearestNeighborSearchOperationMetadata_RecordError[];
  /** Number of sparse records in this file that were successfully processed. */
  validSparseRecordCount: Long;
  /** Number of sparse records in this file we skipped due to validate errors. */
  invalidSparseRecordCount: Long;
}

function createBaseCreateIndexRequest(): CreateIndexRequest {
  return { parent: "", index: undefined };
}

export const CreateIndexRequest: MessageFns<CreateIndexRequest> = {
  encode(message: CreateIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.index !== undefined) {
      Index.encode(message.index, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.index = Index.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIndexRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      index: isSet(object.index) ? Index.fromJSON(object.index) : undefined,
    };
  },

  toJSON(message: CreateIndexRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.index !== undefined) {
      obj.index = Index.toJSON(message.index);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateIndexRequest>): CreateIndexRequest {
    return CreateIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateIndexRequest>): CreateIndexRequest {
    const message = createBaseCreateIndexRequest();
    message.parent = object.parent ?? "";
    message.index = (object.index !== undefined && object.index !== null) ? Index.fromPartial(object.index) : undefined;
    return message;
  },
};

function createBaseCreateIndexOperationMetadata(): CreateIndexOperationMetadata {
  return { genericMetadata: undefined, nearestNeighborSearchOperationMetadata: undefined };
}

export const CreateIndexOperationMetadata: MessageFns<CreateIndexOperationMetadata> = {
  encode(message: CreateIndexOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.genericMetadata !== undefined) {
      GenericOperationMetadata.encode(message.genericMetadata, writer.uint32(10).fork()).join();
    }
    if (message.nearestNeighborSearchOperationMetadata !== undefined) {
      NearestNeighborSearchOperationMetadata.encode(
        message.nearestNeighborSearchOperationMetadata,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateIndexOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIndexOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.genericMetadata = GenericOperationMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nearestNeighborSearchOperationMetadata = NearestNeighborSearchOperationMetadata.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIndexOperationMetadata {
    return {
      genericMetadata: isSet(object.genericMetadata)
        ? GenericOperationMetadata.fromJSON(object.genericMetadata)
        : undefined,
      nearestNeighborSearchOperationMetadata: isSet(object.nearestNeighborSearchOperationMetadata)
        ? NearestNeighborSearchOperationMetadata.fromJSON(object.nearestNeighborSearchOperationMetadata)
        : undefined,
    };
  },

  toJSON(message: CreateIndexOperationMetadata): unknown {
    const obj: any = {};
    if (message.genericMetadata !== undefined) {
      obj.genericMetadata = GenericOperationMetadata.toJSON(message.genericMetadata);
    }
    if (message.nearestNeighborSearchOperationMetadata !== undefined) {
      obj.nearestNeighborSearchOperationMetadata = NearestNeighborSearchOperationMetadata.toJSON(
        message.nearestNeighborSearchOperationMetadata,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CreateIndexOperationMetadata>): CreateIndexOperationMetadata {
    return CreateIndexOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateIndexOperationMetadata>): CreateIndexOperationMetadata {
    const message = createBaseCreateIndexOperationMetadata();
    message.genericMetadata = (object.genericMetadata !== undefined && object.genericMetadata !== null)
      ? GenericOperationMetadata.fromPartial(object.genericMetadata)
      : undefined;
    message.nearestNeighborSearchOperationMetadata =
      (object.nearestNeighborSearchOperationMetadata !== undefined &&
          object.nearestNeighborSearchOperationMetadata !== null)
        ? NearestNeighborSearchOperationMetadata.fromPartial(object.nearestNeighborSearchOperationMetadata)
        : undefined;
    return message;
  },
};

function createBaseGetIndexRequest(): GetIndexRequest {
  return { name: "" };
}

export const GetIndexRequest: MessageFns<GetIndexRequest> = {
  encode(message: GetIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIndexRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetIndexRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetIndexRequest>): GetIndexRequest {
    return GetIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetIndexRequest>): GetIndexRequest {
    const message = createBaseGetIndexRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListIndexesRequest(): ListIndexesRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "", readMask: undefined };
}

export const ListIndexesRequest: MessageFns<ListIndexesRequest> = {
  encode(message: ListIndexesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.readMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.readMask), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIndexesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIndexesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.readMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIndexesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      readMask: isSet(object.readMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.readMask)) : undefined,
    };
  },

  toJSON(message: ListIndexesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.readMask !== undefined) {
      obj.readMask = FieldMask.toJSON(FieldMask.wrap(message.readMask));
    }
    return obj;
  },

  create(base?: DeepPartial<ListIndexesRequest>): ListIndexesRequest {
    return ListIndexesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIndexesRequest>): ListIndexesRequest {
    const message = createBaseListIndexesRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.readMask = object.readMask ?? undefined;
    return message;
  },
};

function createBaseListIndexesResponse(): ListIndexesResponse {
  return { indexes: [], nextPageToken: "" };
}

export const ListIndexesResponse: MessageFns<ListIndexesResponse> = {
  encode(message: ListIndexesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.indexes) {
      Index.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIndexesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIndexesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.indexes.push(Index.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIndexesResponse {
    return {
      indexes: globalThis.Array.isArray(object?.indexes) ? object.indexes.map((e: any) => Index.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListIndexesResponse): unknown {
    const obj: any = {};
    if (message.indexes?.length) {
      obj.indexes = message.indexes.map((e) => Index.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIndexesResponse>): ListIndexesResponse {
    return ListIndexesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIndexesResponse>): ListIndexesResponse {
    const message = createBaseListIndexesResponse();
    message.indexes = object.indexes?.map((e) => Index.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateIndexRequest(): UpdateIndexRequest {
  return { index: undefined, updateMask: undefined };
}

export const UpdateIndexRequest: MessageFns<UpdateIndexRequest> = {
  encode(message: UpdateIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== undefined) {
      Index.encode(message.index, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.index = Index.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateIndexRequest {
    return {
      index: isSet(object.index) ? Index.fromJSON(object.index) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateIndexRequest): unknown {
    const obj: any = {};
    if (message.index !== undefined) {
      obj.index = Index.toJSON(message.index);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateIndexRequest>): UpdateIndexRequest {
    return UpdateIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateIndexRequest>): UpdateIndexRequest {
    const message = createBaseUpdateIndexRequest();
    message.index = (object.index !== undefined && object.index !== null) ? Index.fromPartial(object.index) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUpdateIndexOperationMetadata(): UpdateIndexOperationMetadata {
  return { genericMetadata: undefined, nearestNeighborSearchOperationMetadata: undefined };
}

export const UpdateIndexOperationMetadata: MessageFns<UpdateIndexOperationMetadata> = {
  encode(message: UpdateIndexOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.genericMetadata !== undefined) {
      GenericOperationMetadata.encode(message.genericMetadata, writer.uint32(10).fork()).join();
    }
    if (message.nearestNeighborSearchOperationMetadata !== undefined) {
      NearestNeighborSearchOperationMetadata.encode(
        message.nearestNeighborSearchOperationMetadata,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateIndexOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateIndexOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.genericMetadata = GenericOperationMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nearestNeighborSearchOperationMetadata = NearestNeighborSearchOperationMetadata.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateIndexOperationMetadata {
    return {
      genericMetadata: isSet(object.genericMetadata)
        ? GenericOperationMetadata.fromJSON(object.genericMetadata)
        : undefined,
      nearestNeighborSearchOperationMetadata: isSet(object.nearestNeighborSearchOperationMetadata)
        ? NearestNeighborSearchOperationMetadata.fromJSON(object.nearestNeighborSearchOperationMetadata)
        : undefined,
    };
  },

  toJSON(message: UpdateIndexOperationMetadata): unknown {
    const obj: any = {};
    if (message.genericMetadata !== undefined) {
      obj.genericMetadata = GenericOperationMetadata.toJSON(message.genericMetadata);
    }
    if (message.nearestNeighborSearchOperationMetadata !== undefined) {
      obj.nearestNeighborSearchOperationMetadata = NearestNeighborSearchOperationMetadata.toJSON(
        message.nearestNeighborSearchOperationMetadata,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateIndexOperationMetadata>): UpdateIndexOperationMetadata {
    return UpdateIndexOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateIndexOperationMetadata>): UpdateIndexOperationMetadata {
    const message = createBaseUpdateIndexOperationMetadata();
    message.genericMetadata = (object.genericMetadata !== undefined && object.genericMetadata !== null)
      ? GenericOperationMetadata.fromPartial(object.genericMetadata)
      : undefined;
    message.nearestNeighborSearchOperationMetadata =
      (object.nearestNeighborSearchOperationMetadata !== undefined &&
          object.nearestNeighborSearchOperationMetadata !== null)
        ? NearestNeighborSearchOperationMetadata.fromPartial(object.nearestNeighborSearchOperationMetadata)
        : undefined;
    return message;
  },
};

function createBaseDeleteIndexRequest(): DeleteIndexRequest {
  return { name: "" };
}

export const DeleteIndexRequest: MessageFns<DeleteIndexRequest> = {
  encode(message: DeleteIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteIndexRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteIndexRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteIndexRequest>): DeleteIndexRequest {
    return DeleteIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteIndexRequest>): DeleteIndexRequest {
    const message = createBaseDeleteIndexRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpsertDatapointsRequest(): UpsertDatapointsRequest {
  return { index: "", datapoints: [], updateMask: undefined };
}

export const UpsertDatapointsRequest: MessageFns<UpsertDatapointsRequest> = {
  encode(message: UpsertDatapointsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== "") {
      writer.uint32(10).string(message.index);
    }
    for (const v of message.datapoints) {
      IndexDatapoint.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertDatapointsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertDatapointsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.index = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.datapoints.push(IndexDatapoint.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertDatapointsRequest {
    return {
      index: isSet(object.index) ? globalThis.String(object.index) : "",
      datapoints: globalThis.Array.isArray(object?.datapoints)
        ? object.datapoints.map((e: any) => IndexDatapoint.fromJSON(e))
        : [],
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpsertDatapointsRequest): unknown {
    const obj: any = {};
    if (message.index !== "") {
      obj.index = message.index;
    }
    if (message.datapoints?.length) {
      obj.datapoints = message.datapoints.map((e) => IndexDatapoint.toJSON(e));
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpsertDatapointsRequest>): UpsertDatapointsRequest {
    return UpsertDatapointsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpsertDatapointsRequest>): UpsertDatapointsRequest {
    const message = createBaseUpsertDatapointsRequest();
    message.index = object.index ?? "";
    message.datapoints = object.datapoints?.map((e) => IndexDatapoint.fromPartial(e)) || [];
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUpsertDatapointsResponse(): UpsertDatapointsResponse {
  return {};
}

export const UpsertDatapointsResponse: MessageFns<UpsertDatapointsResponse> = {
  encode(_: UpsertDatapointsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertDatapointsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertDatapointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpsertDatapointsResponse {
    return {};
  },

  toJSON(_: UpsertDatapointsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UpsertDatapointsResponse>): UpsertDatapointsResponse {
    return UpsertDatapointsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UpsertDatapointsResponse>): UpsertDatapointsResponse {
    const message = createBaseUpsertDatapointsResponse();
    return message;
  },
};

function createBaseRemoveDatapointsRequest(): RemoveDatapointsRequest {
  return { index: "", datapointIds: [] };
}

export const RemoveDatapointsRequest: MessageFns<RemoveDatapointsRequest> = {
  encode(message: RemoveDatapointsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== "") {
      writer.uint32(10).string(message.index);
    }
    for (const v of message.datapointIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveDatapointsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveDatapointsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.index = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.datapointIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveDatapointsRequest {
    return {
      index: isSet(object.index) ? globalThis.String(object.index) : "",
      datapointIds: globalThis.Array.isArray(object?.datapointIds)
        ? object.datapointIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: RemoveDatapointsRequest): unknown {
    const obj: any = {};
    if (message.index !== "") {
      obj.index = message.index;
    }
    if (message.datapointIds?.length) {
      obj.datapointIds = message.datapointIds;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveDatapointsRequest>): RemoveDatapointsRequest {
    return RemoveDatapointsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveDatapointsRequest>): RemoveDatapointsRequest {
    const message = createBaseRemoveDatapointsRequest();
    message.index = object.index ?? "";
    message.datapointIds = object.datapointIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseRemoveDatapointsResponse(): RemoveDatapointsResponse {
  return {};
}

export const RemoveDatapointsResponse: MessageFns<RemoveDatapointsResponse> = {
  encode(_: RemoveDatapointsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveDatapointsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveDatapointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveDatapointsResponse {
    return {};
  },

  toJSON(_: RemoveDatapointsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RemoveDatapointsResponse>): RemoveDatapointsResponse {
    return RemoveDatapointsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RemoveDatapointsResponse>): RemoveDatapointsResponse {
    const message = createBaseRemoveDatapointsResponse();
    return message;
  },
};

function createBaseNearestNeighborSearchOperationMetadata(): NearestNeighborSearchOperationMetadata {
  return { contentValidationStats: [], dataBytesCount: Long.ZERO };
}

export const NearestNeighborSearchOperationMetadata: MessageFns<NearestNeighborSearchOperationMetadata> = {
  encode(message: NearestNeighborSearchOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.contentValidationStats) {
      NearestNeighborSearchOperationMetadata_ContentValidationStats.encode(v!, writer.uint32(10).fork()).join();
    }
    if (!message.dataBytesCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.dataBytesCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearestNeighborSearchOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearestNeighborSearchOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contentValidationStats.push(
            NearestNeighborSearchOperationMetadata_ContentValidationStats.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dataBytesCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearestNeighborSearchOperationMetadata {
    return {
      contentValidationStats: globalThis.Array.isArray(object?.contentValidationStats)
        ? object.contentValidationStats.map((e: any) =>
          NearestNeighborSearchOperationMetadata_ContentValidationStats.fromJSON(e)
        )
        : [],
      dataBytesCount: isSet(object.dataBytesCount) ? Long.fromValue(object.dataBytesCount) : Long.ZERO,
    };
  },

  toJSON(message: NearestNeighborSearchOperationMetadata): unknown {
    const obj: any = {};
    if (message.contentValidationStats?.length) {
      obj.contentValidationStats = message.contentValidationStats.map((e) =>
        NearestNeighborSearchOperationMetadata_ContentValidationStats.toJSON(e)
      );
    }
    if (!message.dataBytesCount.equals(Long.ZERO)) {
      obj.dataBytesCount = (message.dataBytesCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<NearestNeighborSearchOperationMetadata>): NearestNeighborSearchOperationMetadata {
    return NearestNeighborSearchOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearestNeighborSearchOperationMetadata>): NearestNeighborSearchOperationMetadata {
    const message = createBaseNearestNeighborSearchOperationMetadata();
    message.contentValidationStats =
      object.contentValidationStats?.map((e) =>
        NearestNeighborSearchOperationMetadata_ContentValidationStats.fromPartial(e)
      ) || [];
    message.dataBytesCount = (object.dataBytesCount !== undefined && object.dataBytesCount !== null)
      ? Long.fromValue(object.dataBytesCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseNearestNeighborSearchOperationMetadata_RecordError(): NearestNeighborSearchOperationMetadata_RecordError {
  return { errorType: 0, errorMessage: "", sourceGcsUri: "", embeddingId: "", rawRecord: "" };
}

export const NearestNeighborSearchOperationMetadata_RecordError: MessageFns<
  NearestNeighborSearchOperationMetadata_RecordError
> = {
  encode(
    message: NearestNeighborSearchOperationMetadata_RecordError,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorType !== 0) {
      writer.uint32(8).int32(message.errorType);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.sourceGcsUri !== "") {
      writer.uint32(26).string(message.sourceGcsUri);
    }
    if (message.embeddingId !== "") {
      writer.uint32(34).string(message.embeddingId);
    }
    if (message.rawRecord !== "") {
      writer.uint32(42).string(message.rawRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NearestNeighborSearchOperationMetadata_RecordError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearestNeighborSearchOperationMetadata_RecordError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.errorType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceGcsUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.embeddingId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rawRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearestNeighborSearchOperationMetadata_RecordError {
    return {
      errorType: isSet(object.errorType)
        ? nearestNeighborSearchOperationMetadata_RecordError_RecordErrorTypeFromJSON(object.errorType)
        : 0,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      sourceGcsUri: isSet(object.sourceGcsUri) ? globalThis.String(object.sourceGcsUri) : "",
      embeddingId: isSet(object.embeddingId) ? globalThis.String(object.embeddingId) : "",
      rawRecord: isSet(object.rawRecord) ? globalThis.String(object.rawRecord) : "",
    };
  },

  toJSON(message: NearestNeighborSearchOperationMetadata_RecordError): unknown {
    const obj: any = {};
    if (message.errorType !== 0) {
      obj.errorType = nearestNeighborSearchOperationMetadata_RecordError_RecordErrorTypeToJSON(message.errorType);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.sourceGcsUri !== "") {
      obj.sourceGcsUri = message.sourceGcsUri;
    }
    if (message.embeddingId !== "") {
      obj.embeddingId = message.embeddingId;
    }
    if (message.rawRecord !== "") {
      obj.rawRecord = message.rawRecord;
    }
    return obj;
  },

  create(
    base?: DeepPartial<NearestNeighborSearchOperationMetadata_RecordError>,
  ): NearestNeighborSearchOperationMetadata_RecordError {
    return NearestNeighborSearchOperationMetadata_RecordError.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<NearestNeighborSearchOperationMetadata_RecordError>,
  ): NearestNeighborSearchOperationMetadata_RecordError {
    const message = createBaseNearestNeighborSearchOperationMetadata_RecordError();
    message.errorType = object.errorType ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    message.sourceGcsUri = object.sourceGcsUri ?? "";
    message.embeddingId = object.embeddingId ?? "";
    message.rawRecord = object.rawRecord ?? "";
    return message;
  },
};

function createBaseNearestNeighborSearchOperationMetadata_ContentValidationStats(): NearestNeighborSearchOperationMetadata_ContentValidationStats {
  return {
    sourceGcsUri: "",
    validRecordCount: Long.ZERO,
    invalidRecordCount: Long.ZERO,
    partialErrors: [],
    validSparseRecordCount: Long.ZERO,
    invalidSparseRecordCount: Long.ZERO,
  };
}

export const NearestNeighborSearchOperationMetadata_ContentValidationStats: MessageFns<
  NearestNeighborSearchOperationMetadata_ContentValidationStats
> = {
  encode(
    message: NearestNeighborSearchOperationMetadata_ContentValidationStats,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sourceGcsUri !== "") {
      writer.uint32(10).string(message.sourceGcsUri);
    }
    if (!message.validRecordCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.validRecordCount.toString());
    }
    if (!message.invalidRecordCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.invalidRecordCount.toString());
    }
    for (const v of message.partialErrors) {
      NearestNeighborSearchOperationMetadata_RecordError.encode(v!, writer.uint32(34).fork()).join();
    }
    if (!message.validSparseRecordCount.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.validSparseRecordCount.toString());
    }
    if (!message.invalidSparseRecordCount.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.invalidSparseRecordCount.toString());
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): NearestNeighborSearchOperationMetadata_ContentValidationStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearestNeighborSearchOperationMetadata_ContentValidationStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceGcsUri = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validRecordCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.invalidRecordCount = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.partialErrors.push(
            NearestNeighborSearchOperationMetadata_RecordError.decode(reader, reader.uint32()),
          );
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validSparseRecordCount = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.invalidSparseRecordCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearestNeighborSearchOperationMetadata_ContentValidationStats {
    return {
      sourceGcsUri: isSet(object.sourceGcsUri) ? globalThis.String(object.sourceGcsUri) : "",
      validRecordCount: isSet(object.validRecordCount) ? Long.fromValue(object.validRecordCount) : Long.ZERO,
      invalidRecordCount: isSet(object.invalidRecordCount) ? Long.fromValue(object.invalidRecordCount) : Long.ZERO,
      partialErrors: globalThis.Array.isArray(object?.partialErrors)
        ? object.partialErrors.map((e: any) => NearestNeighborSearchOperationMetadata_RecordError.fromJSON(e))
        : [],
      validSparseRecordCount: isSet(object.validSparseRecordCount)
        ? Long.fromValue(object.validSparseRecordCount)
        : Long.ZERO,
      invalidSparseRecordCount: isSet(object.invalidSparseRecordCount)
        ? Long.fromValue(object.invalidSparseRecordCount)
        : Long.ZERO,
    };
  },

  toJSON(message: NearestNeighborSearchOperationMetadata_ContentValidationStats): unknown {
    const obj: any = {};
    if (message.sourceGcsUri !== "") {
      obj.sourceGcsUri = message.sourceGcsUri;
    }
    if (!message.validRecordCount.equals(Long.ZERO)) {
      obj.validRecordCount = (message.validRecordCount || Long.ZERO).toString();
    }
    if (!message.invalidRecordCount.equals(Long.ZERO)) {
      obj.invalidRecordCount = (message.invalidRecordCount || Long.ZERO).toString();
    }
    if (message.partialErrors?.length) {
      obj.partialErrors = message.partialErrors.map((e) =>
        NearestNeighborSearchOperationMetadata_RecordError.toJSON(e)
      );
    }
    if (!message.validSparseRecordCount.equals(Long.ZERO)) {
      obj.validSparseRecordCount = (message.validSparseRecordCount || Long.ZERO).toString();
    }
    if (!message.invalidSparseRecordCount.equals(Long.ZERO)) {
      obj.invalidSparseRecordCount = (message.invalidSparseRecordCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(
    base?: DeepPartial<NearestNeighborSearchOperationMetadata_ContentValidationStats>,
  ): NearestNeighborSearchOperationMetadata_ContentValidationStats {
    return NearestNeighborSearchOperationMetadata_ContentValidationStats.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<NearestNeighborSearchOperationMetadata_ContentValidationStats>,
  ): NearestNeighborSearchOperationMetadata_ContentValidationStats {
    const message = createBaseNearestNeighborSearchOperationMetadata_ContentValidationStats();
    message.sourceGcsUri = object.sourceGcsUri ?? "";
    message.validRecordCount = (object.validRecordCount !== undefined && object.validRecordCount !== null)
      ? Long.fromValue(object.validRecordCount)
      : Long.ZERO;
    message.invalidRecordCount = (object.invalidRecordCount !== undefined && object.invalidRecordCount !== null)
      ? Long.fromValue(object.invalidRecordCount)
      : Long.ZERO;
    message.partialErrors =
      object.partialErrors?.map((e) => NearestNeighborSearchOperationMetadata_RecordError.fromPartial(e)) || [];
    message.validSparseRecordCount =
      (object.validSparseRecordCount !== undefined && object.validSparseRecordCount !== null)
        ? Long.fromValue(object.validSparseRecordCount)
        : Long.ZERO;
    message.invalidSparseRecordCount =
      (object.invalidSparseRecordCount !== undefined && object.invalidSparseRecordCount !== null)
        ? Long.fromValue(object.invalidSparseRecordCount)
        : Long.ZERO;
    return message;
  },
};

/** A service for creating and managing Vertex AI's Index resources. */
export type IndexServiceDefinition = typeof IndexServiceDefinition;
export const IndexServiceDefinition = {
  name: "IndexService",
  fullName: "google.cloud.aiplatform.v1.IndexService",
  methods: {
    /** Creates an Index. */
    createIndex: {
      name: "CreateIndex",
      requestType: CreateIndexRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              37,
              10,
              5,
              73,
              110,
              100,
              101,
              120,
              18,
              28,
              67,
              114,
              101,
              97,
              116,
              101,
              73,
              110,
              100,
              101,
              120,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([12, 112, 97, 114, 101, 110, 116, 44, 105, 110, 100, 101, 120])],
          578365826: [
            Buffer.from([
              52,
              58,
              5,
              105,
              110,
              100,
              101,
              120,
              34,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets an Index. */
    getIndex: {
      name: "GetIndex",
      requestType: GetIndexRequest,
      requestStream: false,
      responseType: Index,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Indexes in a Location. */
    listIndexes: {
      name: "ListIndexes",
      requestType: ListIndexesRequest,
      requestStream: false,
      responseType: ListIndexesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates an Index. */
    updateIndex: {
      name: "UpdateIndex",
      requestType: UpdateIndexRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              37,
              10,
              5,
              73,
              110,
              100,
              101,
              120,
              18,
              28,
              85,
              112,
              100,
              97,
              116,
              101,
              73,
              110,
              100,
              101,
              120,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([17, 105, 110, 100, 101, 120, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              58,
              58,
              5,
              105,
              110,
              100,
              101,
              120,
              50,
              49,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              100,
              101,
              120,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes an Index.
     * An Index can only be deleted when all its
     * [DeployedIndexes][google.cloud.aiplatform.v1.Index.deployed_indexes] had
     * been undeployed.
     */
    deleteIndex: {
      name: "DeleteIndex",
      requestType: DeleteIndexRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              48,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              23,
              68,
              101,
              108,
              101,
              116,
              101,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              42,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Add/update Datapoints into an Index. */
    upsertDatapoints: {
      name: "UpsertDatapoints",
      requestType: UpsertDatapointsRequest,
      requestStream: false,
      responseType: UpsertDatapointsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              100,
              101,
              120,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
              47,
              42,
              125,
              58,
              117,
              112,
              115,
              101,
              114,
              116,
              68,
              97,
              116,
              97,
              112,
              111,
              105,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Remove Datapoints from an Index. */
    removeDatapoints: {
      name: "RemoveDatapoints",
      requestType: RemoveDatapointsRequest,
      requestStream: false,
      responseType: RemoveDatapointsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              100,
              101,
              120,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              109,
              111,
              118,
              101,
              68,
              97,
              116,
              97,
              112,
              111,
              105,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface IndexServiceImplementation<CallContextExt = {}> {
  /** Creates an Index. */
  createIndex(request: CreateIndexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Gets an Index. */
  getIndex(request: GetIndexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Index>>;
  /** Lists Indexes in a Location. */
  listIndexes(
    request: ListIndexesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListIndexesResponse>>;
  /** Updates an Index. */
  updateIndex(request: UpdateIndexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Deletes an Index.
   * An Index can only be deleted when all its
   * [DeployedIndexes][google.cloud.aiplatform.v1.Index.deployed_indexes] had
   * been undeployed.
   */
  deleteIndex(request: DeleteIndexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Add/update Datapoints into an Index. */
  upsertDatapoints(
    request: UpsertDatapointsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UpsertDatapointsResponse>>;
  /** Remove Datapoints from an Index. */
  removeDatapoints(
    request: RemoveDatapointsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RemoveDatapointsResponse>>;
}

export interface IndexServiceClient<CallOptionsExt = {}> {
  /** Creates an Index. */
  createIndex(request: DeepPartial<CreateIndexRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Gets an Index. */
  getIndex(request: DeepPartial<GetIndexRequest>, options?: CallOptions & CallOptionsExt): Promise<Index>;
  /** Lists Indexes in a Location. */
  listIndexes(
    request: DeepPartial<ListIndexesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListIndexesResponse>;
  /** Updates an Index. */
  updateIndex(request: DeepPartial<UpdateIndexRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Deletes an Index.
   * An Index can only be deleted when all its
   * [DeployedIndexes][google.cloud.aiplatform.v1.Index.deployed_indexes] had
   * been undeployed.
   */
  deleteIndex(request: DeepPartial<DeleteIndexRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Add/update Datapoints into an Index. */
  upsertDatapoints(
    request: DeepPartial<UpsertDatapointsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UpsertDatapointsResponse>;
  /** Remove Datapoints from an Index. */
  removeDatapoints(
    request: DeepPartial<RemoveDatapointsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RemoveDatapointsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
