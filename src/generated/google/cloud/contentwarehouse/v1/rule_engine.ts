// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/contentwarehouse/v1/rule_engine.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Policy } from "../../../iam/v1/policy.js";

export const protobufPackage = "google.cloud.contentwarehouse.v1";

/** Represents a set of rules from a single customer. */
export interface RuleSet {
  /**
   * The resource name of the rule set. Managed internally.
   * Format:
   * projects/{project_number}/locations/{location}/ruleSet/{rule_set_id}.
   *
   * The name is ignored when creating a rule set.
   */
  name: string;
  /** Short description of the rule-set. */
  description: string;
  /** Source of the rules i.e., customer name. */
  source: string;
  /** List of rules given by the customer. */
  rules: Rule[];
}

/** Represents the rule for a content warehouse trigger. */
export interface Rule {
  /** Short description of the rule and its context. */
  description: string;
  /**
   * ID of the rule. It has to be unique across all the examples.
   * This is managed internally.
   */
  ruleId: string;
  /** Identifies the trigger type for running the policy. */
  triggerType: Rule_TriggerType;
  /**
   * Represents the conditional expression to be evaluated.
   * Expression should evaluate to a boolean result.
   * When the condition is true actions are executed.
   * Example: user_role = "hsbc_role_1" AND doc.salary > 20000
   */
  condition: string;
  /** List of actions that are executed when the rule is satisfied. */
  actions: Action[];
}

/** The trigger types for actions. */
export enum Rule_TriggerType {
  /** UNKNOWN - Trigger for unknown action. */
  UNKNOWN = 0,
  /** ON_CREATE - Trigger for create document action. */
  ON_CREATE = 1,
  /** ON_UPDATE - Trigger for update document action. */
  ON_UPDATE = 4,
  /** ON_CREATE_LINK - Trigger for create link action. */
  ON_CREATE_LINK = 7,
  /** ON_DELETE_LINK - Trigger for delete link action. */
  ON_DELETE_LINK = 8,
  UNRECOGNIZED = -1,
}

export function rule_TriggerTypeFromJSON(object: any): Rule_TriggerType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Rule_TriggerType.UNKNOWN;
    case 1:
    case "ON_CREATE":
      return Rule_TriggerType.ON_CREATE;
    case 4:
    case "ON_UPDATE":
      return Rule_TriggerType.ON_UPDATE;
    case 7:
    case "ON_CREATE_LINK":
      return Rule_TriggerType.ON_CREATE_LINK;
    case 8:
    case "ON_DELETE_LINK":
      return Rule_TriggerType.ON_DELETE_LINK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Rule_TriggerType.UNRECOGNIZED;
  }
}

export function rule_TriggerTypeToJSON(object: Rule_TriggerType): string {
  switch (object) {
    case Rule_TriggerType.UNKNOWN:
      return "UNKNOWN";
    case Rule_TriggerType.ON_CREATE:
      return "ON_CREATE";
    case Rule_TriggerType.ON_UPDATE:
      return "ON_UPDATE";
    case Rule_TriggerType.ON_CREATE_LINK:
      return "ON_CREATE_LINK";
    case Rule_TriggerType.ON_DELETE_LINK:
      return "ON_DELETE_LINK";
    case Rule_TriggerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents the action triggered by Rule Engine when the rule is true. */
export interface Action {
  /** ID of the action. Managed internally. */
  actionId: string;
  /** Action triggering access control operations. */
  accessControl?:
    | AccessControlAction
    | undefined;
  /** Action triggering data validation operations. */
  dataValidation?:
    | DataValidationAction
    | undefined;
  /** Action triggering data update operations. */
  dataUpdate?:
    | DataUpdateAction
    | undefined;
  /** Action triggering create document link operation. */
  addToFolder?:
    | AddToFolderAction
    | undefined;
  /** Action publish to Pub/Sub operation. */
  publishToPubSub?:
    | PublishAction
    | undefined;
  /** Action removing a document from a folder. */
  removeFromFolderAction?:
    | RemoveFromFolderAction
    | undefined;
  /** Action deleting the document. */
  deleteDocumentAction?: DeleteDocumentAction | undefined;
}

/**
 * Represents the action responsible for access control list management
 * operations.
 */
export interface AccessControlAction {
  /** Identifies the type of operation. */
  operationType: AccessControlAction_OperationType;
  /**
   * Represents the new policy from which bindings are added, removed or
   * replaced based on the type of the operation. the policy is limited to a few
   * 10s of KB.
   */
  policy: Policy | undefined;
}

/** Type of ACL modification operation. */
export enum AccessControlAction_OperationType {
  /** UNKNOWN - The unknown operation type. */
  UNKNOWN = 0,
  /** ADD_POLICY_BINDING - Adds newly given policy bindings in the existing bindings list. */
  ADD_POLICY_BINDING = 1,
  /** REMOVE_POLICY_BINDING - Removes newly given policy bindings from the existing bindings list. */
  REMOVE_POLICY_BINDING = 2,
  /** REPLACE_POLICY_BINDING - Replaces existing policy bindings with the given policy binding list */
  REPLACE_POLICY_BINDING = 3,
  UNRECOGNIZED = -1,
}

export function accessControlAction_OperationTypeFromJSON(object: any): AccessControlAction_OperationType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return AccessControlAction_OperationType.UNKNOWN;
    case 1:
    case "ADD_POLICY_BINDING":
      return AccessControlAction_OperationType.ADD_POLICY_BINDING;
    case 2:
    case "REMOVE_POLICY_BINDING":
      return AccessControlAction_OperationType.REMOVE_POLICY_BINDING;
    case 3:
    case "REPLACE_POLICY_BINDING":
      return AccessControlAction_OperationType.REPLACE_POLICY_BINDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessControlAction_OperationType.UNRECOGNIZED;
  }
}

export function accessControlAction_OperationTypeToJSON(object: AccessControlAction_OperationType): string {
  switch (object) {
    case AccessControlAction_OperationType.UNKNOWN:
      return "UNKNOWN";
    case AccessControlAction_OperationType.ADD_POLICY_BINDING:
      return "ADD_POLICY_BINDING";
    case AccessControlAction_OperationType.REMOVE_POLICY_BINDING:
      return "REMOVE_POLICY_BINDING";
    case AccessControlAction_OperationType.REPLACE_POLICY_BINDING:
      return "REPLACE_POLICY_BINDING";
    case AccessControlAction_OperationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents the action responsible for data validation operations. */
export interface DataValidationAction {
  /**
   * Map of (K, V) -> (field, string condition to be evaluated on the field)
   * E.g., ("age", "age > 18  && age < 60") entry triggers validation of field
   * age with the given condition. Map entries will be ANDed during validation.
   */
  conditions: { [key: string]: string };
}

export interface DataValidationAction_ConditionsEntry {
  key: string;
  value: string;
}

/** Represents the action responsible for properties update operations. */
export interface DataUpdateAction {
  /**
   * Map of (K, V) -> (valid name of the field, new value of the field)
   * E.g., ("age", "60") entry triggers update of field age with a value of 60.
   * If the field is not present then new entry is added.
   * During update action execution, value strings will be casted to
   * appropriate types.
   */
  entries: { [key: string]: string };
}

export interface DataUpdateAction_EntriesEntry {
  key: string;
  value: string;
}

/** Represents the action responsible for adding document under a folder. */
export interface AddToFolderAction {
  /**
   * Names of the folder under which new document is to be added.
   * Format:
   * projects/{project_number}/locations/{location}/documents/{document_id}.
   */
  folders: string[];
}

/**
 * Represents the action responsible for remove a document from a specific
 * folder.
 */
export interface RemoveFromFolderAction {
  /** Condition of the action to be executed. */
  condition: string;
  /**
   * Name of the folder under which new document is to be added.
   * Format:
   * projects/{project_number}/locations/{location}/documents/{document_id}.
   */
  folder: string;
}

/** Represents the action responsible for publishing messages to a Pub/Sub topic. */
export interface PublishAction {
  /**
   * The topic id in the Pub/Sub service for which messages will be published
   * to.
   */
  topicId: string;
  /** Messages to be published. */
  messages: string[];
}

/** Represents the action responsible for deleting the document. */
export interface DeleteDocumentAction {
  /**
   * Boolean field to select between hard vs soft delete options.
   * Set 'true' for 'hard delete' and 'false' for 'soft delete'.
   */
  enableHardDelete: boolean;
}

/**
 * Records the output of Rule Engine including rule evaluation and actions
 * result.
 */
export interface RuleEngineOutput {
  /** Name of the document against which the rules and actions were evaluated. */
  documentName: string;
  /** Output from Rule Evaluator containing matched, unmatched and invalid rules. */
  ruleEvaluatorOutput:
    | RuleEvaluatorOutput
    | undefined;
  /**
   * Output from Action Executor containing rule and corresponding actions
   * execution result.
   */
  actionExecutorOutput: ActionExecutorOutput | undefined;
}

/** Represents the output of the Rule Evaluator. */
export interface RuleEvaluatorOutput {
  /** List of rules fetched from database for the given request trigger type. */
  triggeredRules: Rule[];
  /** A subset of triggered rules that are evaluated true for a given request. */
  matchedRules: Rule[];
  /**
   * A subset of triggered rules that failed the validation check(s) after
   * parsing.
   */
  invalidRules: InvalidRule[];
}

/** A triggered rule that failed the validation check(s) after parsing. */
export interface InvalidRule {
  /** Triggered rule. */
  rule:
    | Rule
    | undefined;
  /** Validation error on a parsed expression. */
  error: string;
}

/** Represents the output of the Action Executor. */
export interface ActionExecutorOutput {
  /** List of rule and corresponding actions result. */
  ruleActionsPairs: RuleActionsPair[];
}

/** Represents a rule and outputs of associated actions. */
export interface RuleActionsPair {
  /** Represents the rule. */
  rule:
    | Rule
    | undefined;
  /** Outputs of executing the actions associated with the above rule. */
  actionOutputs: ActionOutput[];
}

/** Represents the result of executing an action. */
export interface ActionOutput {
  /** ID of the action. */
  actionId: string;
  /** State of an action. */
  actionState: ActionOutput_State;
  /** Action execution output message. */
  outputMessage: string;
}

/** Represents execution state of the action. */
export enum ActionOutput_State {
  /** UNKNOWN - The unknown state. */
  UNKNOWN = 0,
  /** ACTION_SUCCEEDED - State indicating action executed successfully. */
  ACTION_SUCCEEDED = 1,
  /** ACTION_FAILED - State indicating action failed. */
  ACTION_FAILED = 2,
  /** ACTION_TIMED_OUT - State indicating action timed out. */
  ACTION_TIMED_OUT = 3,
  /** ACTION_PENDING - State indicating action is pending. */
  ACTION_PENDING = 4,
  UNRECOGNIZED = -1,
}

export function actionOutput_StateFromJSON(object: any): ActionOutput_State {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return ActionOutput_State.UNKNOWN;
    case 1:
    case "ACTION_SUCCEEDED":
      return ActionOutput_State.ACTION_SUCCEEDED;
    case 2:
    case "ACTION_FAILED":
      return ActionOutput_State.ACTION_FAILED;
    case 3:
    case "ACTION_TIMED_OUT":
      return ActionOutput_State.ACTION_TIMED_OUT;
    case 4:
    case "ACTION_PENDING":
      return ActionOutput_State.ACTION_PENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActionOutput_State.UNRECOGNIZED;
  }
}

export function actionOutput_StateToJSON(object: ActionOutput_State): string {
  switch (object) {
    case ActionOutput_State.UNKNOWN:
      return "UNKNOWN";
    case ActionOutput_State.ACTION_SUCCEEDED:
      return "ACTION_SUCCEEDED";
    case ActionOutput_State.ACTION_FAILED:
      return "ACTION_FAILED";
    case ActionOutput_State.ACTION_TIMED_OUT:
      return "ACTION_TIMED_OUT";
    case ActionOutput_State.ACTION_PENDING:
      return "ACTION_PENDING";
    case ActionOutput_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseRuleSet(): RuleSet {
  return { name: "", description: "", source: "", rules: [] };
}

export const RuleSet: MessageFns<RuleSet> = {
  encode(message: RuleSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    for (const v of message.rules) {
      Rule.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuleSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rules.push(Rule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleSet {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => Rule.fromJSON(e)) : [],
    };
  },

  toJSON(message: RuleSet): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => Rule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RuleSet>): RuleSet {
    return RuleSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleSet>): RuleSet {
    const message = createBaseRuleSet();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.source = object.source ?? "";
    message.rules = object.rules?.map((e) => Rule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRule(): Rule {
  return { description: "", ruleId: "", triggerType: 0, condition: "", actions: [] };
}

export const Rule: MessageFns<Rule> = {
  encode(message: Rule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.ruleId !== "") {
      writer.uint32(18).string(message.ruleId);
    }
    if (message.triggerType !== 0) {
      writer.uint32(24).int32(message.triggerType);
    }
    if (message.condition !== "") {
      writer.uint32(34).string(message.condition);
    }
    for (const v of message.actions) {
      Action.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ruleId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.triggerType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.actions.push(Action.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      ruleId: isSet(object.ruleId) ? globalThis.String(object.ruleId) : "",
      triggerType: isSet(object.triggerType) ? rule_TriggerTypeFromJSON(object.triggerType) : 0,
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => Action.fromJSON(e)) : [],
    };
  },

  toJSON(message: Rule): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.ruleId !== "") {
      obj.ruleId = message.ruleId;
    }
    if (message.triggerType !== 0) {
      obj.triggerType = rule_TriggerTypeToJSON(message.triggerType);
    }
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => Action.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Rule>): Rule {
    return Rule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rule>): Rule {
    const message = createBaseRule();
    message.description = object.description ?? "";
    message.ruleId = object.ruleId ?? "";
    message.triggerType = object.triggerType ?? 0;
    message.condition = object.condition ?? "";
    message.actions = object.actions?.map((e) => Action.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAction(): Action {
  return {
    actionId: "",
    accessControl: undefined,
    dataValidation: undefined,
    dataUpdate: undefined,
    addToFolder: undefined,
    publishToPubSub: undefined,
    removeFromFolderAction: undefined,
    deleteDocumentAction: undefined,
  };
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionId !== "") {
      writer.uint32(10).string(message.actionId);
    }
    if (message.accessControl !== undefined) {
      AccessControlAction.encode(message.accessControl, writer.uint32(18).fork()).join();
    }
    if (message.dataValidation !== undefined) {
      DataValidationAction.encode(message.dataValidation, writer.uint32(26).fork()).join();
    }
    if (message.dataUpdate !== undefined) {
      DataUpdateAction.encode(message.dataUpdate, writer.uint32(34).fork()).join();
    }
    if (message.addToFolder !== undefined) {
      AddToFolderAction.encode(message.addToFolder, writer.uint32(42).fork()).join();
    }
    if (message.publishToPubSub !== undefined) {
      PublishAction.encode(message.publishToPubSub, writer.uint32(50).fork()).join();
    }
    if (message.removeFromFolderAction !== undefined) {
      RemoveFromFolderAction.encode(message.removeFromFolderAction, writer.uint32(74).fork()).join();
    }
    if (message.deleteDocumentAction !== undefined) {
      DeleteDocumentAction.encode(message.deleteDocumentAction, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessControl = AccessControlAction.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dataValidation = DataValidationAction.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dataUpdate = DataUpdateAction.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.addToFolder = AddToFolderAction.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.publishToPubSub = PublishAction.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.removeFromFolderAction = RemoveFromFolderAction.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.deleteDocumentAction = DeleteDocumentAction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      actionId: isSet(object.actionId) ? globalThis.String(object.actionId) : "",
      accessControl: isSet(object.accessControl) ? AccessControlAction.fromJSON(object.accessControl) : undefined,
      dataValidation: isSet(object.dataValidation) ? DataValidationAction.fromJSON(object.dataValidation) : undefined,
      dataUpdate: isSet(object.dataUpdate) ? DataUpdateAction.fromJSON(object.dataUpdate) : undefined,
      addToFolder: isSet(object.addToFolder) ? AddToFolderAction.fromJSON(object.addToFolder) : undefined,
      publishToPubSub: isSet(object.publishToPubSub) ? PublishAction.fromJSON(object.publishToPubSub) : undefined,
      removeFromFolderAction: isSet(object.removeFromFolderAction)
        ? RemoveFromFolderAction.fromJSON(object.removeFromFolderAction)
        : undefined,
      deleteDocumentAction: isSet(object.deleteDocumentAction)
        ? DeleteDocumentAction.fromJSON(object.deleteDocumentAction)
        : undefined,
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.actionId !== "") {
      obj.actionId = message.actionId;
    }
    if (message.accessControl !== undefined) {
      obj.accessControl = AccessControlAction.toJSON(message.accessControl);
    }
    if (message.dataValidation !== undefined) {
      obj.dataValidation = DataValidationAction.toJSON(message.dataValidation);
    }
    if (message.dataUpdate !== undefined) {
      obj.dataUpdate = DataUpdateAction.toJSON(message.dataUpdate);
    }
    if (message.addToFolder !== undefined) {
      obj.addToFolder = AddToFolderAction.toJSON(message.addToFolder);
    }
    if (message.publishToPubSub !== undefined) {
      obj.publishToPubSub = PublishAction.toJSON(message.publishToPubSub);
    }
    if (message.removeFromFolderAction !== undefined) {
      obj.removeFromFolderAction = RemoveFromFolderAction.toJSON(message.removeFromFolderAction);
    }
    if (message.deleteDocumentAction !== undefined) {
      obj.deleteDocumentAction = DeleteDocumentAction.toJSON(message.deleteDocumentAction);
    }
    return obj;
  },

  create(base?: DeepPartial<Action>): Action {
    return Action.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Action>): Action {
    const message = createBaseAction();
    message.actionId = object.actionId ?? "";
    message.accessControl = (object.accessControl !== undefined && object.accessControl !== null)
      ? AccessControlAction.fromPartial(object.accessControl)
      : undefined;
    message.dataValidation = (object.dataValidation !== undefined && object.dataValidation !== null)
      ? DataValidationAction.fromPartial(object.dataValidation)
      : undefined;
    message.dataUpdate = (object.dataUpdate !== undefined && object.dataUpdate !== null)
      ? DataUpdateAction.fromPartial(object.dataUpdate)
      : undefined;
    message.addToFolder = (object.addToFolder !== undefined && object.addToFolder !== null)
      ? AddToFolderAction.fromPartial(object.addToFolder)
      : undefined;
    message.publishToPubSub = (object.publishToPubSub !== undefined && object.publishToPubSub !== null)
      ? PublishAction.fromPartial(object.publishToPubSub)
      : undefined;
    message.removeFromFolderAction =
      (object.removeFromFolderAction !== undefined && object.removeFromFolderAction !== null)
        ? RemoveFromFolderAction.fromPartial(object.removeFromFolderAction)
        : undefined;
    message.deleteDocumentAction = (object.deleteDocumentAction !== undefined && object.deleteDocumentAction !== null)
      ? DeleteDocumentAction.fromPartial(object.deleteDocumentAction)
      : undefined;
    return message;
  },
};

function createBaseAccessControlAction(): AccessControlAction {
  return { operationType: 0, policy: undefined };
}

export const AccessControlAction: MessageFns<AccessControlAction> = {
  encode(message: AccessControlAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationType !== 0) {
      writer.uint32(8).int32(message.operationType);
    }
    if (message.policy !== undefined) {
      Policy.encode(message.policy, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessControlAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessControlAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operationType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.policy = Policy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessControlAction {
    return {
      operationType: isSet(object.operationType) ? accessControlAction_OperationTypeFromJSON(object.operationType) : 0,
      policy: isSet(object.policy) ? Policy.fromJSON(object.policy) : undefined,
    };
  },

  toJSON(message: AccessControlAction): unknown {
    const obj: any = {};
    if (message.operationType !== 0) {
      obj.operationType = accessControlAction_OperationTypeToJSON(message.operationType);
    }
    if (message.policy !== undefined) {
      obj.policy = Policy.toJSON(message.policy);
    }
    return obj;
  },

  create(base?: DeepPartial<AccessControlAction>): AccessControlAction {
    return AccessControlAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessControlAction>): AccessControlAction {
    const message = createBaseAccessControlAction();
    message.operationType = object.operationType ?? 0;
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? Policy.fromPartial(object.policy)
      : undefined;
    return message;
  },
};

function createBaseDataValidationAction(): DataValidationAction {
  return { conditions: {} };
}

export const DataValidationAction: MessageFns<DataValidationAction> = {
  encode(message: DataValidationAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.conditions).forEach(([key, value]) => {
      DataValidationAction_ConditionsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataValidationAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataValidationAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = DataValidationAction_ConditionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.conditions[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataValidationAction {
    return {
      conditions: isObject(object.conditions)
        ? Object.entries(object.conditions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DataValidationAction): unknown {
    const obj: any = {};
    if (message.conditions) {
      const entries = Object.entries(message.conditions);
      if (entries.length > 0) {
        obj.conditions = {};
        entries.forEach(([k, v]) => {
          obj.conditions[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<DataValidationAction>): DataValidationAction {
    return DataValidationAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataValidationAction>): DataValidationAction {
    const message = createBaseDataValidationAction();
    message.conditions = Object.entries(object.conditions ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDataValidationAction_ConditionsEntry(): DataValidationAction_ConditionsEntry {
  return { key: "", value: "" };
}

export const DataValidationAction_ConditionsEntry: MessageFns<DataValidationAction_ConditionsEntry> = {
  encode(message: DataValidationAction_ConditionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataValidationAction_ConditionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataValidationAction_ConditionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataValidationAction_ConditionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DataValidationAction_ConditionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DataValidationAction_ConditionsEntry>): DataValidationAction_ConditionsEntry {
    return DataValidationAction_ConditionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataValidationAction_ConditionsEntry>): DataValidationAction_ConditionsEntry {
    const message = createBaseDataValidationAction_ConditionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDataUpdateAction(): DataUpdateAction {
  return { entries: {} };
}

export const DataUpdateAction: MessageFns<DataUpdateAction> = {
  encode(message: DataUpdateAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.entries).forEach(([key, value]) => {
      DataUpdateAction_EntriesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataUpdateAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataUpdateAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = DataUpdateAction_EntriesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.entries[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataUpdateAction {
    return {
      entries: isObject(object.entries)
        ? Object.entries(object.entries).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DataUpdateAction): unknown {
    const obj: any = {};
    if (message.entries) {
      const entries = Object.entries(message.entries);
      if (entries.length > 0) {
        obj.entries = {};
        entries.forEach(([k, v]) => {
          obj.entries[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<DataUpdateAction>): DataUpdateAction {
    return DataUpdateAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataUpdateAction>): DataUpdateAction {
    const message = createBaseDataUpdateAction();
    message.entries = Object.entries(object.entries ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseDataUpdateAction_EntriesEntry(): DataUpdateAction_EntriesEntry {
  return { key: "", value: "" };
}

export const DataUpdateAction_EntriesEntry: MessageFns<DataUpdateAction_EntriesEntry> = {
  encode(message: DataUpdateAction_EntriesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataUpdateAction_EntriesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataUpdateAction_EntriesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataUpdateAction_EntriesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DataUpdateAction_EntriesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DataUpdateAction_EntriesEntry>): DataUpdateAction_EntriesEntry {
    return DataUpdateAction_EntriesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataUpdateAction_EntriesEntry>): DataUpdateAction_EntriesEntry {
    const message = createBaseDataUpdateAction_EntriesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAddToFolderAction(): AddToFolderAction {
  return { folders: [] };
}

export const AddToFolderAction: MessageFns<AddToFolderAction> = {
  encode(message: AddToFolderAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.folders) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddToFolderAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddToFolderAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.folders.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddToFolderAction {
    return {
      folders: globalThis.Array.isArray(object?.folders) ? object.folders.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AddToFolderAction): unknown {
    const obj: any = {};
    if (message.folders?.length) {
      obj.folders = message.folders;
    }
    return obj;
  },

  create(base?: DeepPartial<AddToFolderAction>): AddToFolderAction {
    return AddToFolderAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddToFolderAction>): AddToFolderAction {
    const message = createBaseAddToFolderAction();
    message.folders = object.folders?.map((e) => e) || [];
    return message;
  },
};

function createBaseRemoveFromFolderAction(): RemoveFromFolderAction {
  return { condition: "", folder: "" };
}

export const RemoveFromFolderAction: MessageFns<RemoveFromFolderAction> = {
  encode(message: RemoveFromFolderAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condition !== "") {
      writer.uint32(10).string(message.condition);
    }
    if (message.folder !== "") {
      writer.uint32(18).string(message.folder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveFromFolderAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveFromFolderAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.folder = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveFromFolderAction {
    return {
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      folder: isSet(object.folder) ? globalThis.String(object.folder) : "",
    };
  },

  toJSON(message: RemoveFromFolderAction): unknown {
    const obj: any = {};
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.folder !== "") {
      obj.folder = message.folder;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveFromFolderAction>): RemoveFromFolderAction {
    return RemoveFromFolderAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveFromFolderAction>): RemoveFromFolderAction {
    const message = createBaseRemoveFromFolderAction();
    message.condition = object.condition ?? "";
    message.folder = object.folder ?? "";
    return message;
  },
};

function createBasePublishAction(): PublishAction {
  return { topicId: "", messages: [] };
}

export const PublishAction: MessageFns<PublishAction> = {
  encode(message: PublishAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicId !== "") {
      writer.uint32(10).string(message.topicId);
    }
    for (const v of message.messages) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topicId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messages.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishAction {
    return {
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "",
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: PublishAction): unknown {
    const obj: any = {};
    if (message.topicId !== "") {
      obj.topicId = message.topicId;
    }
    if (message.messages?.length) {
      obj.messages = message.messages;
    }
    return obj;
  },

  create(base?: DeepPartial<PublishAction>): PublishAction {
    return PublishAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublishAction>): PublishAction {
    const message = createBasePublishAction();
    message.topicId = object.topicId ?? "";
    message.messages = object.messages?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeleteDocumentAction(): DeleteDocumentAction {
  return { enableHardDelete: false };
}

export const DeleteDocumentAction: MessageFns<DeleteDocumentAction> = {
  encode(message: DeleteDocumentAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableHardDelete !== false) {
      writer.uint32(8).bool(message.enableHardDelete);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDocumentAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDocumentAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableHardDelete = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDocumentAction {
    return { enableHardDelete: isSet(object.enableHardDelete) ? globalThis.Boolean(object.enableHardDelete) : false };
  },

  toJSON(message: DeleteDocumentAction): unknown {
    const obj: any = {};
    if (message.enableHardDelete !== false) {
      obj.enableHardDelete = message.enableHardDelete;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDocumentAction>): DeleteDocumentAction {
    return DeleteDocumentAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDocumentAction>): DeleteDocumentAction {
    const message = createBaseDeleteDocumentAction();
    message.enableHardDelete = object.enableHardDelete ?? false;
    return message;
  },
};

function createBaseRuleEngineOutput(): RuleEngineOutput {
  return { documentName: "", ruleEvaluatorOutput: undefined, actionExecutorOutput: undefined };
}

export const RuleEngineOutput: MessageFns<RuleEngineOutput> = {
  encode(message: RuleEngineOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.documentName !== "") {
      writer.uint32(26).string(message.documentName);
    }
    if (message.ruleEvaluatorOutput !== undefined) {
      RuleEvaluatorOutput.encode(message.ruleEvaluatorOutput, writer.uint32(10).fork()).join();
    }
    if (message.actionExecutorOutput !== undefined) {
      ActionExecutorOutput.encode(message.actionExecutorOutput, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuleEngineOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleEngineOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.documentName = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ruleEvaluatorOutput = RuleEvaluatorOutput.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actionExecutorOutput = ActionExecutorOutput.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleEngineOutput {
    return {
      documentName: isSet(object.documentName) ? globalThis.String(object.documentName) : "",
      ruleEvaluatorOutput: isSet(object.ruleEvaluatorOutput)
        ? RuleEvaluatorOutput.fromJSON(object.ruleEvaluatorOutput)
        : undefined,
      actionExecutorOutput: isSet(object.actionExecutorOutput)
        ? ActionExecutorOutput.fromJSON(object.actionExecutorOutput)
        : undefined,
    };
  },

  toJSON(message: RuleEngineOutput): unknown {
    const obj: any = {};
    if (message.documentName !== "") {
      obj.documentName = message.documentName;
    }
    if (message.ruleEvaluatorOutput !== undefined) {
      obj.ruleEvaluatorOutput = RuleEvaluatorOutput.toJSON(message.ruleEvaluatorOutput);
    }
    if (message.actionExecutorOutput !== undefined) {
      obj.actionExecutorOutput = ActionExecutorOutput.toJSON(message.actionExecutorOutput);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleEngineOutput>): RuleEngineOutput {
    return RuleEngineOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleEngineOutput>): RuleEngineOutput {
    const message = createBaseRuleEngineOutput();
    message.documentName = object.documentName ?? "";
    message.ruleEvaluatorOutput = (object.ruleEvaluatorOutput !== undefined && object.ruleEvaluatorOutput !== null)
      ? RuleEvaluatorOutput.fromPartial(object.ruleEvaluatorOutput)
      : undefined;
    message.actionExecutorOutput = (object.actionExecutorOutput !== undefined && object.actionExecutorOutput !== null)
      ? ActionExecutorOutput.fromPartial(object.actionExecutorOutput)
      : undefined;
    return message;
  },
};

function createBaseRuleEvaluatorOutput(): RuleEvaluatorOutput {
  return { triggeredRules: [], matchedRules: [], invalidRules: [] };
}

export const RuleEvaluatorOutput: MessageFns<RuleEvaluatorOutput> = {
  encode(message: RuleEvaluatorOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.triggeredRules) {
      Rule.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.matchedRules) {
      Rule.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.invalidRules) {
      InvalidRule.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuleEvaluatorOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleEvaluatorOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.triggeredRules.push(Rule.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.matchedRules.push(Rule.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.invalidRules.push(InvalidRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleEvaluatorOutput {
    return {
      triggeredRules: globalThis.Array.isArray(object?.triggeredRules)
        ? object.triggeredRules.map((e: any) => Rule.fromJSON(e))
        : [],
      matchedRules: globalThis.Array.isArray(object?.matchedRules)
        ? object.matchedRules.map((e: any) => Rule.fromJSON(e))
        : [],
      invalidRules: globalThis.Array.isArray(object?.invalidRules)
        ? object.invalidRules.map((e: any) => InvalidRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RuleEvaluatorOutput): unknown {
    const obj: any = {};
    if (message.triggeredRules?.length) {
      obj.triggeredRules = message.triggeredRules.map((e) => Rule.toJSON(e));
    }
    if (message.matchedRules?.length) {
      obj.matchedRules = message.matchedRules.map((e) => Rule.toJSON(e));
    }
    if (message.invalidRules?.length) {
      obj.invalidRules = message.invalidRules.map((e) => InvalidRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RuleEvaluatorOutput>): RuleEvaluatorOutput {
    return RuleEvaluatorOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleEvaluatorOutput>): RuleEvaluatorOutput {
    const message = createBaseRuleEvaluatorOutput();
    message.triggeredRules = object.triggeredRules?.map((e) => Rule.fromPartial(e)) || [];
    message.matchedRules = object.matchedRules?.map((e) => Rule.fromPartial(e)) || [];
    message.invalidRules = object.invalidRules?.map((e) => InvalidRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInvalidRule(): InvalidRule {
  return { rule: undefined, error: "" };
}

export const InvalidRule: MessageFns<InvalidRule> = {
  encode(message: InvalidRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rule !== undefined) {
      Rule.encode(message.rule, writer.uint32(10).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvalidRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvalidRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rule = Rule.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvalidRule {
    return {
      rule: isSet(object.rule) ? Rule.fromJSON(object.rule) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: InvalidRule): unknown {
    const obj: any = {};
    if (message.rule !== undefined) {
      obj.rule = Rule.toJSON(message.rule);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<InvalidRule>): InvalidRule {
    return InvalidRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvalidRule>): InvalidRule {
    const message = createBaseInvalidRule();
    message.rule = (object.rule !== undefined && object.rule !== null) ? Rule.fromPartial(object.rule) : undefined;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseActionExecutorOutput(): ActionExecutorOutput {
  return { ruleActionsPairs: [] };
}

export const ActionExecutorOutput: MessageFns<ActionExecutorOutput> = {
  encode(message: ActionExecutorOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ruleActionsPairs) {
      RuleActionsPair.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionExecutorOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionExecutorOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ruleActionsPairs.push(RuleActionsPair.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionExecutorOutput {
    return {
      ruleActionsPairs: globalThis.Array.isArray(object?.ruleActionsPairs)
        ? object.ruleActionsPairs.map((e: any) => RuleActionsPair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ActionExecutorOutput): unknown {
    const obj: any = {};
    if (message.ruleActionsPairs?.length) {
      obj.ruleActionsPairs = message.ruleActionsPairs.map((e) => RuleActionsPair.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ActionExecutorOutput>): ActionExecutorOutput {
    return ActionExecutorOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActionExecutorOutput>): ActionExecutorOutput {
    const message = createBaseActionExecutorOutput();
    message.ruleActionsPairs = object.ruleActionsPairs?.map((e) => RuleActionsPair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRuleActionsPair(): RuleActionsPair {
  return { rule: undefined, actionOutputs: [] };
}

export const RuleActionsPair: MessageFns<RuleActionsPair> = {
  encode(message: RuleActionsPair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rule !== undefined) {
      Rule.encode(message.rule, writer.uint32(10).fork()).join();
    }
    for (const v of message.actionOutputs) {
      ActionOutput.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuleActionsPair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleActionsPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rule = Rule.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actionOutputs.push(ActionOutput.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleActionsPair {
    return {
      rule: isSet(object.rule) ? Rule.fromJSON(object.rule) : undefined,
      actionOutputs: globalThis.Array.isArray(object?.actionOutputs)
        ? object.actionOutputs.map((e: any) => ActionOutput.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RuleActionsPair): unknown {
    const obj: any = {};
    if (message.rule !== undefined) {
      obj.rule = Rule.toJSON(message.rule);
    }
    if (message.actionOutputs?.length) {
      obj.actionOutputs = message.actionOutputs.map((e) => ActionOutput.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RuleActionsPair>): RuleActionsPair {
    return RuleActionsPair.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleActionsPair>): RuleActionsPair {
    const message = createBaseRuleActionsPair();
    message.rule = (object.rule !== undefined && object.rule !== null) ? Rule.fromPartial(object.rule) : undefined;
    message.actionOutputs = object.actionOutputs?.map((e) => ActionOutput.fromPartial(e)) || [];
    return message;
  },
};

function createBaseActionOutput(): ActionOutput {
  return { actionId: "", actionState: 0, outputMessage: "" };
}

export const ActionOutput: MessageFns<ActionOutput> = {
  encode(message: ActionOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionId !== "") {
      writer.uint32(10).string(message.actionId);
    }
    if (message.actionState !== 0) {
      writer.uint32(16).int32(message.actionState);
    }
    if (message.outputMessage !== "") {
      writer.uint32(26).string(message.outputMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actionId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.actionState = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outputMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionOutput {
    return {
      actionId: isSet(object.actionId) ? globalThis.String(object.actionId) : "",
      actionState: isSet(object.actionState) ? actionOutput_StateFromJSON(object.actionState) : 0,
      outputMessage: isSet(object.outputMessage) ? globalThis.String(object.outputMessage) : "",
    };
  },

  toJSON(message: ActionOutput): unknown {
    const obj: any = {};
    if (message.actionId !== "") {
      obj.actionId = message.actionId;
    }
    if (message.actionState !== 0) {
      obj.actionState = actionOutput_StateToJSON(message.actionState);
    }
    if (message.outputMessage !== "") {
      obj.outputMessage = message.outputMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<ActionOutput>): ActionOutput {
    return ActionOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActionOutput>): ActionOutput {
    const message = createBaseActionOutput();
    message.actionId = object.actionId ?? "";
    message.actionState = object.actionState ?? 0;
    message.outputMessage = object.outputMessage ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
