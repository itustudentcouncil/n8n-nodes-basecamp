// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/contentwarehouse/v1/filters.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Interval } from "../../../type/interval.js";

export const protobufPackage = "google.cloud.contentwarehouse.v1";

export interface DocumentQuery {
  /**
   * The query string that matches against the full text of the document and
   * the searchable properties.
   *
   * The query partially supports [Google AIP style
   * syntax](https://google.aip.dev/160). Specifically, the query supports
   * literals, logical operators, negation operators, comparison operators, and
   * functions.
   *
   * Literals: A bare literal value (examples: "42", "Hugo") is a value to be
   * matched against. It searches over the full text of the document and the
   * searchable properties.
   *
   * Logical operators: "AND", "and", "OR", and "or" are binary logical
   * operators (example: "engineer OR developer").
   *
   * Negation operators: "NOT" and "!" are negation operators (example: "NOT
   * software").
   *
   * Comparison operators: support the binary comparison operators =, !=, <, >,
   * <= and >= for string, numeric, enum, boolean. Also support like operator
   * `~~` for string. It provides semantic search functionality by parsing,
   * stemming and doing synonyms expansion against the input query.
   *
   * To specify a property in the query, the left hand side expression in the
   * comparison must be the property ID including the parent. The right hand
   * side must be literals. For example:
   * "\"projects/123/locations/us\".property_a < 1" matches results whose
   * "property_a" is less than 1 in project 123 and us location.
   * The literals and comparison expression can be connected in a single query
   * (example: "software engineer \"projects/123/locations/us\".salary > 100").
   *
   * Functions: supported functions are `LOWER([property_name])` to perform a
   * case insensitive match and `EMPTY([property_name])` to filter on the
   * existence of a key.
   *
   * Support nested expressions connected using parenthesis and logical
   * operators. The default logical operators is `AND` if there is no operators
   * between expressions.
   *
   * The query can be used with other filters e.g. `time_filters` and
   * `folder_name_filter`. They are connected with `AND` operator under the
   * hood.
   *
   * The maximum number of allowed characters is 255.
   */
  query: string;
  /**
   * Experimental, do not use.
   * If the query is a natural language question. False by default. If true,
   * then the question-answering feature will be used instead of search, and
   * `result_count` in
   * [SearchDocumentsRequest][google.cloud.contentwarehouse.v1.SearchDocumentsRequest]
   * must be set. In addition, all other input fields related to search
   * (pagination, histograms, etc.) will be ignored.
   */
  isNlQuery: boolean;
  /**
   * This filter specifies a structured syntax to match against the
   * [PropertyDefinition].[is_filterable][] marked as `true`. The syntax for
   * this expression is a subset of SQL syntax.
   *
   * Supported operators are: `=`, `!=`, `<`, `<=`, `>`, and `>=` where the left
   * of the operator is a property name and the right of the operator is a
   * number or a quoted string. You must escape backslash (\\) and quote (\")
   * characters. Supported functions are `LOWER([property_name])` to perform a
   * case insensitive match and `EMPTY([property_name])` to filter on the
   * existence of a key.
   *
   * Boolean expressions (AND/OR/NOT) are supported up to 3 levels of nesting
   * (for example, "((A AND B AND C) OR NOT D) AND E"), a maximum of 100
   * comparisons or functions are allowed in the expression. The expression must
   * be < 6000 bytes in length.
   *
   * Sample Query:
   * `(LOWER(driving_license)="class \"a\"" OR EMPTY(driving_license)) AND
   * driving_years > 10`
   *
   * @deprecated
   */
  customPropertyFilter: string;
  /**
   * Documents created/updated within a range specified by this filter are
   * searched against.
   */
  timeFilters: TimeFilter[];
  /**
   * This filter specifies the exact document schema
   * [Document.document_schema_name][google.cloud.contentwarehouse.v1.Document.document_schema_name]
   * of the documents to search against.
   *
   * If a value isn't specified, documents within the search results are
   * associated with any schema. If multiple values are specified, documents
   * within the search results may be associated with any of the specified
   * schemas.
   *
   * At most 20 document schema names are allowed.
   */
  documentSchemaNames: string[];
  /**
   * This filter specifies a structured syntax to match against the
   * [PropertyDefinition.is_filterable][google.cloud.contentwarehouse.v1.PropertyDefinition.is_filterable]
   * marked as `true`. The relationship between the PropertyFilters is OR.
   */
  propertyFilter: PropertyFilter[];
  /**
   * This filter specifies the types of files to return: ALL, FOLDER, or FILE.
   * If FOLDER or FILE is specified, then only either folders or files will be
   * returned, respectively. If ALL is specified, both folders and files will be
   * returned.
   *
   * If no value is specified, ALL files will be returned.
   */
  fileTypeFilter:
    | FileTypeFilter
    | undefined;
  /**
   * Search all the documents under this specified folder.
   * Format:
   * projects/{project_number}/locations/{location}/documents/{document_id}.
   */
  folderNameFilter: string;
  /**
   * Search the documents in the list.
   * Format:
   * projects/{project_number}/locations/{location}/documents/{document_id}.
   */
  documentNameFilter: string[];
  /**
   * For custom synonyms.
   * Customers provide the synonyms based on context. One customer can provide
   * multiple set of synonyms based on different context. The search query will
   * be expanded based on the custom synonyms of the query context set.
   * By default, no custom synonyms wll be applied if no query context is
   * provided.
   * It is not supported for CMEK compliant deployment.
   */
  queryContext: string[];
  /**
   * The exact creator(s) of the documents to search against.
   *
   * If a value isn't specified, documents within the search results are
   * associated with any creator. If multiple values are specified, documents
   * within the search results may be associated with any of the specified
   * creators.
   */
  documentCreatorFilter: string[];
  /**
   * To support the custom weighting across document schemas, customers need to
   * provide the properties to be used to boost the ranking in the search
   * request. For a search query with CustomWeightsMetadata specified, only the
   * RetrievalImportance for the properties in the CustomWeightsMetadata will
   * be honored.
   */
  customWeightsMetadata: CustomWeightsMetadata | undefined;
}

/** Filter on create timestamp or update timestamp of documents. */
export interface TimeFilter {
  timeRange:
    | Interval
    | undefined;
  /**
   * Specifies which time field to filter documents on.
   *
   * Defaults to [TimeField.UPLOAD_TIME][].
   */
  timeField: TimeFilter_TimeField;
}

/** Time field used in TimeFilter. */
export enum TimeFilter_TimeField {
  /** TIME_FIELD_UNSPECIFIED - Default value. */
  TIME_FIELD_UNSPECIFIED = 0,
  /** CREATE_TIME - Earliest document create time. */
  CREATE_TIME = 1,
  /** UPDATE_TIME - Latest document update time. */
  UPDATE_TIME = 2,
  /** DISPOSITION_TIME - Time when document becomes mutable again. */
  DISPOSITION_TIME = 3,
  UNRECOGNIZED = -1,
}

export function timeFilter_TimeFieldFromJSON(object: any): TimeFilter_TimeField {
  switch (object) {
    case 0:
    case "TIME_FIELD_UNSPECIFIED":
      return TimeFilter_TimeField.TIME_FIELD_UNSPECIFIED;
    case 1:
    case "CREATE_TIME":
      return TimeFilter_TimeField.CREATE_TIME;
    case 2:
    case "UPDATE_TIME":
      return TimeFilter_TimeField.UPDATE_TIME;
    case 3:
    case "DISPOSITION_TIME":
      return TimeFilter_TimeField.DISPOSITION_TIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TimeFilter_TimeField.UNRECOGNIZED;
  }
}

export function timeFilter_TimeFieldToJSON(object: TimeFilter_TimeField): string {
  switch (object) {
    case TimeFilter_TimeField.TIME_FIELD_UNSPECIFIED:
      return "TIME_FIELD_UNSPECIFIED";
    case TimeFilter_TimeField.CREATE_TIME:
      return "CREATE_TIME";
    case TimeFilter_TimeField.UPDATE_TIME:
      return "UPDATE_TIME";
    case TimeFilter_TimeField.DISPOSITION_TIME:
      return "DISPOSITION_TIME";
    case TimeFilter_TimeField.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PropertyFilter {
  /**
   * The Document schema name
   * [Document.document_schema_name][google.cloud.contentwarehouse.v1.Document.document_schema_name].
   * Format:
   * projects/{project_number}/locations/{location}/documentSchemas/{document_schema_id}.
   */
  documentSchemaName: string;
  /**
   * The filter condition.
   * The syntax for this expression is a subset of SQL syntax.
   *
   * Supported operators are: `=`, `!=`, `<`, `<=`, `>`, `>=`, and `~~` where
   * the left of the operator is a property name and the right of the operator
   * is a number or a quoted string. You must escape backslash (\\) and quote
   * (\") characters.
   *
   * `~~` is the LIKE operator. The right of the operator must be a string. The
   * only supported property data type for LIKE is text_values. It provides
   * semantic search functionality by parsing, stemming and doing synonyms
   * expansion against the input query. It matches if the property contains
   * semantic similar content to the query. It is not regex matching or wildcard
   * matching. For example, "property.company ~~ \"google\"" will match records
   * whose property `property.compnay` have values like "Google Inc.", "Google
   * LLC" or "Google Company".
   *
   * Supported functions are `LOWER([property_name])` to perform a
   * case insensitive match and `EMPTY([property_name])` to filter on the
   * existence of a key.
   *
   * Boolean expressions (AND/OR/NOT) are supported up to 3 levels of nesting
   * (for example, "((A AND B AND C) OR NOT D) AND E"), a maximum of 100
   * comparisons or functions are allowed in the expression. The expression must
   * be < 6000 bytes in length.
   *
   * Only properties that are marked filterable are allowed
   * ([PropertyDefinition.is_filterable][google.cloud.contentwarehouse.v1.PropertyDefinition.is_filterable]).
   * Property names do not need to be prefixed by the document schema id (as is
   * the case with histograms), however property names will need to be prefixed
   * by its parent hierarchy, if any.  For example:
   * top_property_name.sub_property_name.
   *
   * Sample Query:
   * `(LOWER(driving_license)="class \"a\"" OR EMPTY(driving_license)) AND
   * driving_years > 10`
   *
   * CMEK compliant deployment only supports:
   *
   * * Operators: `=`, `<`, `<=`, `>`, and `>=`.
   * * Boolean expressions: AND and OR.
   */
  condition: string;
}

/** Filter for the specific types of documents returned. */
export interface FileTypeFilter {
  /** The type of files to return. */
  fileType: FileTypeFilter_FileType;
}

/** Representation of the types of files. */
export enum FileTypeFilter_FileType {
  /** FILE_TYPE_UNSPECIFIED - Default document type. If set, disables the filter. */
  FILE_TYPE_UNSPECIFIED = 0,
  /** ALL - Returns all document types, including folders. */
  ALL = 1,
  /** FOLDER - Returns only folders. */
  FOLDER = 2,
  /** DOCUMENT - Returns only non-folder documents. */
  DOCUMENT = 3,
  /** ROOT_FOLDER - Returns only root folders */
  ROOT_FOLDER = 4,
  UNRECOGNIZED = -1,
}

export function fileTypeFilter_FileTypeFromJSON(object: any): FileTypeFilter_FileType {
  switch (object) {
    case 0:
    case "FILE_TYPE_UNSPECIFIED":
      return FileTypeFilter_FileType.FILE_TYPE_UNSPECIFIED;
    case 1:
    case "ALL":
      return FileTypeFilter_FileType.ALL;
    case 2:
    case "FOLDER":
      return FileTypeFilter_FileType.FOLDER;
    case 3:
    case "DOCUMENT":
      return FileTypeFilter_FileType.DOCUMENT;
    case 4:
    case "ROOT_FOLDER":
      return FileTypeFilter_FileType.ROOT_FOLDER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileTypeFilter_FileType.UNRECOGNIZED;
  }
}

export function fileTypeFilter_FileTypeToJSON(object: FileTypeFilter_FileType): string {
  switch (object) {
    case FileTypeFilter_FileType.FILE_TYPE_UNSPECIFIED:
      return "FILE_TYPE_UNSPECIFIED";
    case FileTypeFilter_FileType.ALL:
      return "ALL";
    case FileTypeFilter_FileType.FOLDER:
      return "FOLDER";
    case FileTypeFilter_FileType.DOCUMENT:
      return "DOCUMENT";
    case FileTypeFilter_FileType.ROOT_FOLDER:
      return "ROOT_FOLDER";
    case FileTypeFilter_FileType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** To support the custom weighting across document schemas. */
export interface CustomWeightsMetadata {
  /**
   * List of schema and property name. Allows a maximum of 10 schemas to be
   * specified for relevance boosting.
   */
  weightedSchemaProperties: WeightedSchemaProperty[];
}

/** Specifies the schema property name. */
export interface WeightedSchemaProperty {
  /** The document schema name. */
  documentSchemaName: string;
  /** The property definition names in the schema. */
  propertyNames: string[];
}

function createBaseDocumentQuery(): DocumentQuery {
  return {
    query: "",
    isNlQuery: false,
    customPropertyFilter: "",
    timeFilters: [],
    documentSchemaNames: [],
    propertyFilter: [],
    fileTypeFilter: undefined,
    folderNameFilter: "",
    documentNameFilter: [],
    queryContext: [],
    documentCreatorFilter: [],
    customWeightsMetadata: undefined,
  };
}

export const DocumentQuery: MessageFns<DocumentQuery> = {
  encode(message: DocumentQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.isNlQuery !== false) {
      writer.uint32(96).bool(message.isNlQuery);
    }
    if (message.customPropertyFilter !== "") {
      writer.uint32(34).string(message.customPropertyFilter);
    }
    for (const v of message.timeFilters) {
      TimeFilter.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.documentSchemaNames) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.propertyFilter) {
      PropertyFilter.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.fileTypeFilter !== undefined) {
      FileTypeFilter.encode(message.fileTypeFilter, writer.uint32(66).fork()).join();
    }
    if (message.folderNameFilter !== "") {
      writer.uint32(74).string(message.folderNameFilter);
    }
    for (const v of message.documentNameFilter) {
      writer.uint32(114).string(v!);
    }
    for (const v of message.queryContext) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.documentCreatorFilter) {
      writer.uint32(90).string(v!);
    }
    if (message.customWeightsMetadata !== undefined) {
      CustomWeightsMetadata.encode(message.customWeightsMetadata, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.isNlQuery = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.customPropertyFilter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.timeFilters.push(TimeFilter.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.documentSchemaNames.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.propertyFilter.push(PropertyFilter.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.fileTypeFilter = FileTypeFilter.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.folderNameFilter = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.documentNameFilter.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.queryContext.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.documentCreatorFilter.push(reader.string());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.customWeightsMetadata = CustomWeightsMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentQuery {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      isNlQuery: isSet(object.isNlQuery) ? globalThis.Boolean(object.isNlQuery) : false,
      customPropertyFilter: isSet(object.customPropertyFilter) ? globalThis.String(object.customPropertyFilter) : "",
      timeFilters: globalThis.Array.isArray(object?.timeFilters)
        ? object.timeFilters.map((e: any) => TimeFilter.fromJSON(e))
        : [],
      documentSchemaNames: globalThis.Array.isArray(object?.documentSchemaNames)
        ? object.documentSchemaNames.map((e: any) => globalThis.String(e))
        : [],
      propertyFilter: globalThis.Array.isArray(object?.propertyFilter)
        ? object.propertyFilter.map((e: any) => PropertyFilter.fromJSON(e))
        : [],
      fileTypeFilter: isSet(object.fileTypeFilter) ? FileTypeFilter.fromJSON(object.fileTypeFilter) : undefined,
      folderNameFilter: isSet(object.folderNameFilter) ? globalThis.String(object.folderNameFilter) : "",
      documentNameFilter: globalThis.Array.isArray(object?.documentNameFilter)
        ? object.documentNameFilter.map((e: any) => globalThis.String(e))
        : [],
      queryContext: globalThis.Array.isArray(object?.queryContext)
        ? object.queryContext.map((e: any) => globalThis.String(e))
        : [],
      documentCreatorFilter: globalThis.Array.isArray(object?.documentCreatorFilter)
        ? object.documentCreatorFilter.map((e: any) => globalThis.String(e))
        : [],
      customWeightsMetadata: isSet(object.customWeightsMetadata)
        ? CustomWeightsMetadata.fromJSON(object.customWeightsMetadata)
        : undefined,
    };
  },

  toJSON(message: DocumentQuery): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.isNlQuery !== false) {
      obj.isNlQuery = message.isNlQuery;
    }
    if (message.customPropertyFilter !== "") {
      obj.customPropertyFilter = message.customPropertyFilter;
    }
    if (message.timeFilters?.length) {
      obj.timeFilters = message.timeFilters.map((e) => TimeFilter.toJSON(e));
    }
    if (message.documentSchemaNames?.length) {
      obj.documentSchemaNames = message.documentSchemaNames;
    }
    if (message.propertyFilter?.length) {
      obj.propertyFilter = message.propertyFilter.map((e) => PropertyFilter.toJSON(e));
    }
    if (message.fileTypeFilter !== undefined) {
      obj.fileTypeFilter = FileTypeFilter.toJSON(message.fileTypeFilter);
    }
    if (message.folderNameFilter !== "") {
      obj.folderNameFilter = message.folderNameFilter;
    }
    if (message.documentNameFilter?.length) {
      obj.documentNameFilter = message.documentNameFilter;
    }
    if (message.queryContext?.length) {
      obj.queryContext = message.queryContext;
    }
    if (message.documentCreatorFilter?.length) {
      obj.documentCreatorFilter = message.documentCreatorFilter;
    }
    if (message.customWeightsMetadata !== undefined) {
      obj.customWeightsMetadata = CustomWeightsMetadata.toJSON(message.customWeightsMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentQuery>): DocumentQuery {
    return DocumentQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentQuery>): DocumentQuery {
    const message = createBaseDocumentQuery();
    message.query = object.query ?? "";
    message.isNlQuery = object.isNlQuery ?? false;
    message.customPropertyFilter = object.customPropertyFilter ?? "";
    message.timeFilters = object.timeFilters?.map((e) => TimeFilter.fromPartial(e)) || [];
    message.documentSchemaNames = object.documentSchemaNames?.map((e) => e) || [];
    message.propertyFilter = object.propertyFilter?.map((e) => PropertyFilter.fromPartial(e)) || [];
    message.fileTypeFilter = (object.fileTypeFilter !== undefined && object.fileTypeFilter !== null)
      ? FileTypeFilter.fromPartial(object.fileTypeFilter)
      : undefined;
    message.folderNameFilter = object.folderNameFilter ?? "";
    message.documentNameFilter = object.documentNameFilter?.map((e) => e) || [];
    message.queryContext = object.queryContext?.map((e) => e) || [];
    message.documentCreatorFilter = object.documentCreatorFilter?.map((e) => e) || [];
    message.customWeightsMetadata =
      (object.customWeightsMetadata !== undefined && object.customWeightsMetadata !== null)
        ? CustomWeightsMetadata.fromPartial(object.customWeightsMetadata)
        : undefined;
    return message;
  },
};

function createBaseTimeFilter(): TimeFilter {
  return { timeRange: undefined, timeField: 0 };
}

export const TimeFilter: MessageFns<TimeFilter> = {
  encode(message: TimeFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeRange !== undefined) {
      Interval.encode(message.timeRange, writer.uint32(10).fork()).join();
    }
    if (message.timeField !== 0) {
      writer.uint32(16).int32(message.timeField);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeRange = Interval.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeField = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeFilter {
    return {
      timeRange: isSet(object.timeRange) ? Interval.fromJSON(object.timeRange) : undefined,
      timeField: isSet(object.timeField) ? timeFilter_TimeFieldFromJSON(object.timeField) : 0,
    };
  },

  toJSON(message: TimeFilter): unknown {
    const obj: any = {};
    if (message.timeRange !== undefined) {
      obj.timeRange = Interval.toJSON(message.timeRange);
    }
    if (message.timeField !== 0) {
      obj.timeField = timeFilter_TimeFieldToJSON(message.timeField);
    }
    return obj;
  },

  create(base?: DeepPartial<TimeFilter>): TimeFilter {
    return TimeFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeFilter>): TimeFilter {
    const message = createBaseTimeFilter();
    message.timeRange = (object.timeRange !== undefined && object.timeRange !== null)
      ? Interval.fromPartial(object.timeRange)
      : undefined;
    message.timeField = object.timeField ?? 0;
    return message;
  },
};

function createBasePropertyFilter(): PropertyFilter {
  return { documentSchemaName: "", condition: "" };
}

export const PropertyFilter: MessageFns<PropertyFilter> = {
  encode(message: PropertyFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.documentSchemaName !== "") {
      writer.uint32(10).string(message.documentSchemaName);
    }
    if (message.condition !== "") {
      writer.uint32(18).string(message.condition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentSchemaName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.condition = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyFilter {
    return {
      documentSchemaName: isSet(object.documentSchemaName) ? globalThis.String(object.documentSchemaName) : "",
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
    };
  },

  toJSON(message: PropertyFilter): unknown {
    const obj: any = {};
    if (message.documentSchemaName !== "") {
      obj.documentSchemaName = message.documentSchemaName;
    }
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyFilter>): PropertyFilter {
    return PropertyFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyFilter>): PropertyFilter {
    const message = createBasePropertyFilter();
    message.documentSchemaName = object.documentSchemaName ?? "";
    message.condition = object.condition ?? "";
    return message;
  },
};

function createBaseFileTypeFilter(): FileTypeFilter {
  return { fileType: 0 };
}

export const FileTypeFilter: MessageFns<FileTypeFilter> = {
  encode(message: FileTypeFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileType !== 0) {
      writer.uint32(8).int32(message.fileType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileTypeFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileTypeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fileType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileTypeFilter {
    return { fileType: isSet(object.fileType) ? fileTypeFilter_FileTypeFromJSON(object.fileType) : 0 };
  },

  toJSON(message: FileTypeFilter): unknown {
    const obj: any = {};
    if (message.fileType !== 0) {
      obj.fileType = fileTypeFilter_FileTypeToJSON(message.fileType);
    }
    return obj;
  },

  create(base?: DeepPartial<FileTypeFilter>): FileTypeFilter {
    return FileTypeFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileTypeFilter>): FileTypeFilter {
    const message = createBaseFileTypeFilter();
    message.fileType = object.fileType ?? 0;
    return message;
  },
};

function createBaseCustomWeightsMetadata(): CustomWeightsMetadata {
  return { weightedSchemaProperties: [] };
}

export const CustomWeightsMetadata: MessageFns<CustomWeightsMetadata> = {
  encode(message: CustomWeightsMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.weightedSchemaProperties) {
      WeightedSchemaProperty.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomWeightsMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomWeightsMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.weightedSchemaProperties.push(WeightedSchemaProperty.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomWeightsMetadata {
    return {
      weightedSchemaProperties: globalThis.Array.isArray(object?.weightedSchemaProperties)
        ? object.weightedSchemaProperties.map((e: any) => WeightedSchemaProperty.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CustomWeightsMetadata): unknown {
    const obj: any = {};
    if (message.weightedSchemaProperties?.length) {
      obj.weightedSchemaProperties = message.weightedSchemaProperties.map((e) => WeightedSchemaProperty.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CustomWeightsMetadata>): CustomWeightsMetadata {
    return CustomWeightsMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomWeightsMetadata>): CustomWeightsMetadata {
    const message = createBaseCustomWeightsMetadata();
    message.weightedSchemaProperties =
      object.weightedSchemaProperties?.map((e) => WeightedSchemaProperty.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWeightedSchemaProperty(): WeightedSchemaProperty {
  return { documentSchemaName: "", propertyNames: [] };
}

export const WeightedSchemaProperty: MessageFns<WeightedSchemaProperty> = {
  encode(message: WeightedSchemaProperty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.documentSchemaName !== "") {
      writer.uint32(10).string(message.documentSchemaName);
    }
    for (const v of message.propertyNames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeightedSchemaProperty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeightedSchemaProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentSchemaName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.propertyNames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeightedSchemaProperty {
    return {
      documentSchemaName: isSet(object.documentSchemaName) ? globalThis.String(object.documentSchemaName) : "",
      propertyNames: globalThis.Array.isArray(object?.propertyNames)
        ? object.propertyNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: WeightedSchemaProperty): unknown {
    const obj: any = {};
    if (message.documentSchemaName !== "") {
      obj.documentSchemaName = message.documentSchemaName;
    }
    if (message.propertyNames?.length) {
      obj.propertyNames = message.propertyNames;
    }
    return obj;
  },

  create(base?: DeepPartial<WeightedSchemaProperty>): WeightedSchemaProperty {
    return WeightedSchemaProperty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WeightedSchemaProperty>): WeightedSchemaProperty {
    const message = createBaseWeightedSchemaProperty();
    message.documentSchemaName = object.documentSchemaName ?? "";
    message.propertyNames = object.propertyNames?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
