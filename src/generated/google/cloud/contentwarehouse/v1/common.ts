// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/contentwarehouse/v1/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { FieldMask } from "../../../protobuf/field_mask.js";

export const protobufPackage = "google.cloud.contentwarehouse.v1";

/** Update type of the requests. */
export enum UpdateType {
  /** UPDATE_TYPE_UNSPECIFIED - Defaults to full replace behavior, ie. FULL_REPLACE. */
  UPDATE_TYPE_UNSPECIFIED = 0,
  /**
   * UPDATE_TYPE_REPLACE - Fully replace all the fields (including previously linked raw document).
   * Any field masks will be ignored.
   */
  UPDATE_TYPE_REPLACE = 1,
  /** UPDATE_TYPE_MERGE - Merge the fields into the existing entities. */
  UPDATE_TYPE_MERGE = 2,
  /** UPDATE_TYPE_INSERT_PROPERTIES_BY_NAMES - Inserts the properties by names. */
  UPDATE_TYPE_INSERT_PROPERTIES_BY_NAMES = 3,
  /** UPDATE_TYPE_REPLACE_PROPERTIES_BY_NAMES - Replace the properties by names. */
  UPDATE_TYPE_REPLACE_PROPERTIES_BY_NAMES = 4,
  /** UPDATE_TYPE_DELETE_PROPERTIES_BY_NAMES - Delete the properties by names. */
  UPDATE_TYPE_DELETE_PROPERTIES_BY_NAMES = 5,
  /**
   * UPDATE_TYPE_MERGE_AND_REPLACE_OR_INSERT_PROPERTIES_BY_NAMES - For each of the property, replaces the property if the it exists, otherwise
   * inserts a new property. And for the rest of the fields, merge them based on
   * update mask and merge fields options.
   */
  UPDATE_TYPE_MERGE_AND_REPLACE_OR_INSERT_PROPERTIES_BY_NAMES = 6,
  UNRECOGNIZED = -1,
}

export function updateTypeFromJSON(object: any): UpdateType {
  switch (object) {
    case 0:
    case "UPDATE_TYPE_UNSPECIFIED":
      return UpdateType.UPDATE_TYPE_UNSPECIFIED;
    case 1:
    case "UPDATE_TYPE_REPLACE":
      return UpdateType.UPDATE_TYPE_REPLACE;
    case 2:
    case "UPDATE_TYPE_MERGE":
      return UpdateType.UPDATE_TYPE_MERGE;
    case 3:
    case "UPDATE_TYPE_INSERT_PROPERTIES_BY_NAMES":
      return UpdateType.UPDATE_TYPE_INSERT_PROPERTIES_BY_NAMES;
    case 4:
    case "UPDATE_TYPE_REPLACE_PROPERTIES_BY_NAMES":
      return UpdateType.UPDATE_TYPE_REPLACE_PROPERTIES_BY_NAMES;
    case 5:
    case "UPDATE_TYPE_DELETE_PROPERTIES_BY_NAMES":
      return UpdateType.UPDATE_TYPE_DELETE_PROPERTIES_BY_NAMES;
    case 6:
    case "UPDATE_TYPE_MERGE_AND_REPLACE_OR_INSERT_PROPERTIES_BY_NAMES":
      return UpdateType.UPDATE_TYPE_MERGE_AND_REPLACE_OR_INSERT_PROPERTIES_BY_NAMES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UpdateType.UNRECOGNIZED;
  }
}

export function updateTypeToJSON(object: UpdateType): string {
  switch (object) {
    case UpdateType.UPDATE_TYPE_UNSPECIFIED:
      return "UPDATE_TYPE_UNSPECIFIED";
    case UpdateType.UPDATE_TYPE_REPLACE:
      return "UPDATE_TYPE_REPLACE";
    case UpdateType.UPDATE_TYPE_MERGE:
      return "UPDATE_TYPE_MERGE";
    case UpdateType.UPDATE_TYPE_INSERT_PROPERTIES_BY_NAMES:
      return "UPDATE_TYPE_INSERT_PROPERTIES_BY_NAMES";
    case UpdateType.UPDATE_TYPE_REPLACE_PROPERTIES_BY_NAMES:
      return "UPDATE_TYPE_REPLACE_PROPERTIES_BY_NAMES";
    case UpdateType.UPDATE_TYPE_DELETE_PROPERTIES_BY_NAMES:
      return "UPDATE_TYPE_DELETE_PROPERTIES_BY_NAMES";
    case UpdateType.UPDATE_TYPE_MERGE_AND_REPLACE_OR_INSERT_PROPERTIES_BY_NAMES:
      return "UPDATE_TYPE_MERGE_AND_REPLACE_OR_INSERT_PROPERTIES_BY_NAMES";
    case UpdateType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of database used by the customer */
export enum DatabaseType {
  /** DB_UNKNOWN - This value is required by protobuf best practices */
  DB_UNKNOWN = 0,
  /** DB_INFRA_SPANNER - Internal Spanner */
  DB_INFRA_SPANNER = 1,
  /**
   * DB_CLOUD_SQL_POSTGRES - Cloud Sql with a Postgres Sql instance
   *
   * @deprecated
   */
  DB_CLOUD_SQL_POSTGRES = 2,
  UNRECOGNIZED = -1,
}

export function databaseTypeFromJSON(object: any): DatabaseType {
  switch (object) {
    case 0:
    case "DB_UNKNOWN":
      return DatabaseType.DB_UNKNOWN;
    case 1:
    case "DB_INFRA_SPANNER":
      return DatabaseType.DB_INFRA_SPANNER;
    case 2:
    case "DB_CLOUD_SQL_POSTGRES":
      return DatabaseType.DB_CLOUD_SQL_POSTGRES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatabaseType.UNRECOGNIZED;
  }
}

export function databaseTypeToJSON(object: DatabaseType): string {
  switch (object) {
    case DatabaseType.DB_UNKNOWN:
      return "DB_UNKNOWN";
    case DatabaseType.DB_INFRA_SPANNER:
      return "DB_INFRA_SPANNER";
    case DatabaseType.DB_CLOUD_SQL_POSTGRES:
      return "DB_CLOUD_SQL_POSTGRES";
    case DatabaseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Access Control Mode. */
export enum AccessControlMode {
  /** ACL_MODE_UNKNOWN - This value is required by protobuf best practices */
  ACL_MODE_UNKNOWN = 0,
  /** ACL_MODE_UNIVERSAL_ACCESS - Universal Access: No document level access control. */
  ACL_MODE_UNIVERSAL_ACCESS = 1,
  /** ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_BYOID - Document level access control with customer own Identity Service. */
  ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_BYOID = 2,
  /** ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_GCI - Document level access control using Google Cloud Identity. */
  ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_GCI = 3,
  UNRECOGNIZED = -1,
}

export function accessControlModeFromJSON(object: any): AccessControlMode {
  switch (object) {
    case 0:
    case "ACL_MODE_UNKNOWN":
      return AccessControlMode.ACL_MODE_UNKNOWN;
    case 1:
    case "ACL_MODE_UNIVERSAL_ACCESS":
      return AccessControlMode.ACL_MODE_UNIVERSAL_ACCESS;
    case 2:
    case "ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_BYOID":
      return AccessControlMode.ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_BYOID;
    case 3:
    case "ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_GCI":
      return AccessControlMode.ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_GCI;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessControlMode.UNRECOGNIZED;
  }
}

export function accessControlModeToJSON(object: AccessControlMode): string {
  switch (object) {
    case AccessControlMode.ACL_MODE_UNKNOWN:
      return "ACL_MODE_UNKNOWN";
    case AccessControlMode.ACL_MODE_UNIVERSAL_ACCESS:
      return "ACL_MODE_UNIVERSAL_ACCESS";
    case AccessControlMode.ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_BYOID:
      return "ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_BYOID";
    case AccessControlMode.ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_GCI:
      return "ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_GCI";
    case AccessControlMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The default role of the document creator. */
export enum DocumentCreatorDefaultRole {
  /** DOCUMENT_CREATOR_DEFAULT_ROLE_UNSPECIFIED - Unspecified, will be default to document admin role. */
  DOCUMENT_CREATOR_DEFAULT_ROLE_UNSPECIFIED = 0,
  /** DOCUMENT_ADMIN - Document Admin, same as contentwarehouse.googleapis.com/documentAdmin. */
  DOCUMENT_ADMIN = 1,
  /** DOCUMENT_EDITOR - Document Editor, same as contentwarehouse.googleapis.com/documentEditor. */
  DOCUMENT_EDITOR = 2,
  /** DOCUMENT_VIEWER - Document Viewer, same as contentwarehouse.googleapis.com/documentViewer. */
  DOCUMENT_VIEWER = 3,
  UNRECOGNIZED = -1,
}

export function documentCreatorDefaultRoleFromJSON(object: any): DocumentCreatorDefaultRole {
  switch (object) {
    case 0:
    case "DOCUMENT_CREATOR_DEFAULT_ROLE_UNSPECIFIED":
      return DocumentCreatorDefaultRole.DOCUMENT_CREATOR_DEFAULT_ROLE_UNSPECIFIED;
    case 1:
    case "DOCUMENT_ADMIN":
      return DocumentCreatorDefaultRole.DOCUMENT_ADMIN;
    case 2:
    case "DOCUMENT_EDITOR":
      return DocumentCreatorDefaultRole.DOCUMENT_EDITOR;
    case 3:
    case "DOCUMENT_VIEWER":
      return DocumentCreatorDefaultRole.DOCUMENT_VIEWER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DocumentCreatorDefaultRole.UNRECOGNIZED;
  }
}

export function documentCreatorDefaultRoleToJSON(object: DocumentCreatorDefaultRole): string {
  switch (object) {
    case DocumentCreatorDefaultRole.DOCUMENT_CREATOR_DEFAULT_ROLE_UNSPECIFIED:
      return "DOCUMENT_CREATOR_DEFAULT_ROLE_UNSPECIFIED";
    case DocumentCreatorDefaultRole.DOCUMENT_ADMIN:
      return "DOCUMENT_ADMIN";
    case DocumentCreatorDefaultRole.DOCUMENT_EDITOR:
      return "DOCUMENT_EDITOR";
    case DocumentCreatorDefaultRole.DOCUMENT_VIEWER:
      return "DOCUMENT_VIEWER";
    case DocumentCreatorDefaultRole.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Meta information is used to improve the performance of the service. */
export interface RequestMetadata {
  /** Provides user unique identification and groups information. */
  userInfo: UserInfo | undefined;
}

/** Additional information returned to client, such as debugging information. */
export interface ResponseMetadata {
  /**
   * A unique id associated with this call. This id is logged for tracking
   * purpose.
   */
  requestId: string;
}

/** The user information. */
export interface UserInfo {
  /**
   * A unique user identification string, as determined by the client.
   * The maximum number of allowed characters is 255.
   * Allowed characters include numbers 0 to 9, uppercase and lowercase letters,
   * and restricted special symbols (:, @, +, -, _, ~)
   * The format is "user:xxxx@example.com";
   */
  id: string;
  /**
   * The unique group identifications which the user is belong to.
   * The format is "group:yyyy@example.com";
   */
  groupIds: string[];
}

/** Options for Update operations. */
export interface UpdateOptions {
  /** Type for update. */
  updateType: UpdateType;
  /**
   * Field mask for merging Document fields.
   * For the `FieldMask` definition,
   * see
   * https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask
   */
  updateMask:
    | string[]
    | undefined;
  /** Options for merging. */
  mergeFieldsOptions: MergeFieldsOptions | undefined;
}

/** Options for merging updated fields. */
export interface MergeFieldsOptions {
  /**
   * When merging message fields, the default behavior is to merge
   * the content of two message fields together. If you instead want to use
   * the field from the source message to replace the corresponding field in
   * the destination message, set this flag to true. When this flag is set,
   * specified submessage fields that are missing in source will be cleared in
   * destination.
   */
  replaceMessageFields?:
    | boolean
    | undefined;
  /**
   * When merging repeated fields, the default behavior is to append
   * entries from the source repeated field to the destination repeated field.
   * If you instead want to keep only the entries from the source repeated
   * field, set this flag to true.
   *
   * If you want to replace a repeated field within a message field on the
   * destination message, you must set both replace_repeated_fields and
   * replace_message_fields to true, otherwise the repeated fields will be
   * appended.
   */
  replaceRepeatedFields?: boolean | undefined;
}

function createBaseRequestMetadata(): RequestMetadata {
  return { userInfo: undefined };
}

export const RequestMetadata: MessageFns<RequestMetadata> = {
  encode(message: RequestMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMetadata {
    return { userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined };
  },

  toJSON(message: RequestMetadata): unknown {
    const obj: any = {};
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<RequestMetadata>): RequestMetadata {
    return RequestMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestMetadata>): RequestMetadata {
    const message = createBaseRequestMetadata();
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    return message;
  },
};

function createBaseResponseMetadata(): ResponseMetadata {
  return { requestId: "" };
}

export const ResponseMetadata: MessageFns<ResponseMetadata> = {
  encode(message: ResponseMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMetadata {
    return { requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "" };
  },

  toJSON(message: ResponseMetadata): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<ResponseMetadata>): ResponseMetadata {
    return ResponseMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResponseMetadata>): ResponseMetadata {
    const message = createBaseResponseMetadata();
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUserInfo(): UserInfo {
  return { id: "", groupIds: [] };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.groupIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groupIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      groupIds: globalThis.Array.isArray(object?.groupIds) ? object.groupIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.groupIds?.length) {
      obj.groupIds = message.groupIds;
    }
    return obj;
  },

  create(base?: DeepPartial<UserInfo>): UserInfo {
    return UserInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserInfo>): UserInfo {
    const message = createBaseUserInfo();
    message.id = object.id ?? "";
    message.groupIds = object.groupIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateOptions(): UpdateOptions {
  return { updateType: 0, updateMask: undefined, mergeFieldsOptions: undefined };
}

export const UpdateOptions: MessageFns<UpdateOptions> = {
  encode(message: UpdateOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateType !== 0) {
      writer.uint32(8).int32(message.updateType);
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.mergeFieldsOptions !== undefined) {
      MergeFieldsOptions.encode(message.mergeFieldsOptions, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.updateType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mergeFieldsOptions = MergeFieldsOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOptions {
    return {
      updateType: isSet(object.updateType) ? updateTypeFromJSON(object.updateType) : 0,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      mergeFieldsOptions: isSet(object.mergeFieldsOptions)
        ? MergeFieldsOptions.fromJSON(object.mergeFieldsOptions)
        : undefined,
    };
  },

  toJSON(message: UpdateOptions): unknown {
    const obj: any = {};
    if (message.updateType !== 0) {
      obj.updateType = updateTypeToJSON(message.updateType);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.mergeFieldsOptions !== undefined) {
      obj.mergeFieldsOptions = MergeFieldsOptions.toJSON(message.mergeFieldsOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateOptions>): UpdateOptions {
    return UpdateOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateOptions>): UpdateOptions {
    const message = createBaseUpdateOptions();
    message.updateType = object.updateType ?? 0;
    message.updateMask = object.updateMask ?? undefined;
    message.mergeFieldsOptions = (object.mergeFieldsOptions !== undefined && object.mergeFieldsOptions !== null)
      ? MergeFieldsOptions.fromPartial(object.mergeFieldsOptions)
      : undefined;
    return message;
  },
};

function createBaseMergeFieldsOptions(): MergeFieldsOptions {
  return { replaceMessageFields: undefined, replaceRepeatedFields: undefined };
}

export const MergeFieldsOptions: MessageFns<MergeFieldsOptions> = {
  encode(message: MergeFieldsOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.replaceMessageFields !== undefined) {
      writer.uint32(8).bool(message.replaceMessageFields);
    }
    if (message.replaceRepeatedFields !== undefined) {
      writer.uint32(16).bool(message.replaceRepeatedFields);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeFieldsOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeFieldsOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.replaceMessageFields = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.replaceRepeatedFields = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeFieldsOptions {
    return {
      replaceMessageFields: isSet(object.replaceMessageFields)
        ? globalThis.Boolean(object.replaceMessageFields)
        : undefined,
      replaceRepeatedFields: isSet(object.replaceRepeatedFields)
        ? globalThis.Boolean(object.replaceRepeatedFields)
        : undefined,
    };
  },

  toJSON(message: MergeFieldsOptions): unknown {
    const obj: any = {};
    if (message.replaceMessageFields !== undefined) {
      obj.replaceMessageFields = message.replaceMessageFields;
    }
    if (message.replaceRepeatedFields !== undefined) {
      obj.replaceRepeatedFields = message.replaceRepeatedFields;
    }
    return obj;
  },

  create(base?: DeepPartial<MergeFieldsOptions>): MergeFieldsOptions {
    return MergeFieldsOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MergeFieldsOptions>): MergeFieldsOptions {
    const message = createBaseMergeFieldsOptions();
    message.replaceMessageFields = object.replaceMessageFields ?? undefined;
    message.replaceRepeatedFields = object.replaceRepeatedFields ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
