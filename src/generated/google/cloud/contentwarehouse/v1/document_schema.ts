// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/contentwarehouse/v1/document_schema.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.contentwarehouse.v1";

/** A document schema used to define document structure. */
export interface DocumentSchema {
  /**
   * The resource name of the document schema.
   * Format:
   * projects/{project_number}/locations/{location}/documentSchemas/{document_schema_id}.
   *
   * The name is ignored when creating a document schema.
   */
  name: string;
  /** Required. Name of the schema given by the user. Must be unique per project. */
  displayName: string;
  /** Document details. */
  propertyDefinitions: PropertyDefinition[];
  /**
   * Document Type, true refers the document is a folder, otherwise it is
   * a typical document.
   */
  documentIsFolder: boolean;
  /** Output only. The time when the document schema is last updated. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The time when the document schema is created. */
  createTime:
    | Date
    | undefined;
  /** Schema description. */
  description: string;
}

/** Defines the metadata for a schema property. */
export interface PropertyDefinition {
  /**
   * Required. The name of the metadata property.
   * Must be unique within a document schema and is case insensitive.
   * Names must be non-blank, start with a letter, and can contain alphanumeric
   * characters and: /, :, -, _, and .
   */
  name: string;
  /** The display-name for the property, used for front-end. */
  displayName: string;
  /** Whether the property can have multiple values. */
  isRepeatable: boolean;
  /**
   * Whether the property can be filtered. If this is a sub-property, all the
   * parent properties must be marked filterable.
   */
  isFilterable: boolean;
  /** Indicates that the property should be included in a global search. */
  isSearchable: boolean;
  /**
   * Whether the property is user supplied metadata.
   * This out-of-the box placeholder setting can be used to tag derived
   * properties. Its value and interpretation logic should be implemented by API
   * user.
   */
  isMetadata: boolean;
  /**
   * Whether the property is mandatory.
   * Default is 'false', i.e. populating property value can be skipped.
   * If 'true' then user must populate the value for this property.
   */
  isRequired: boolean;
  /** The retrieval importance of the property during search. */
  retrievalImportance: PropertyDefinition_RetrievalImportance;
  /** Integer property. */
  integerTypeOptions?:
    | IntegerTypeOptions
    | undefined;
  /** Float property. */
  floatTypeOptions?:
    | FloatTypeOptions
    | undefined;
  /** Text/string property. */
  textTypeOptions?:
    | TextTypeOptions
    | undefined;
  /** Nested structured data property. */
  propertyTypeOptions?:
    | PropertyTypeOptions
    | undefined;
  /** Enum/categorical property. */
  enumTypeOptions?:
    | EnumTypeOptions
    | undefined;
  /**
   * Date time property.
   * It is not supported by CMEK compliant deployment.
   */
  dateTimeTypeOptions?:
    | DateTimeTypeOptions
    | undefined;
  /** Map property. */
  mapTypeOptions?:
    | MapTypeOptions
    | undefined;
  /**
   * Timestamp property.
   * It is not supported by CMEK compliant deployment.
   */
  timestampTypeOptions?:
    | TimestampTypeOptions
    | undefined;
  /** The mapping information between this property to another schema source. */
  schemaSources: PropertyDefinition_SchemaSource[];
}

/** Stores the retrieval importance. */
export enum PropertyDefinition_RetrievalImportance {
  /** RETRIEVAL_IMPORTANCE_UNSPECIFIED - No importance specified. Default medium importance. */
  RETRIEVAL_IMPORTANCE_UNSPECIFIED = 0,
  /** HIGHEST - Highest importance. */
  HIGHEST = 1,
  /** HIGHER - Higher importance. */
  HIGHER = 2,
  /** HIGH - High importance. */
  HIGH = 3,
  /** MEDIUM - Medium importance. */
  MEDIUM = 4,
  /** LOW - Low importance (negative). */
  LOW = 5,
  /** LOWEST - Lowest importance (negative). */
  LOWEST = 6,
  UNRECOGNIZED = -1,
}

export function propertyDefinition_RetrievalImportanceFromJSON(object: any): PropertyDefinition_RetrievalImportance {
  switch (object) {
    case 0:
    case "RETRIEVAL_IMPORTANCE_UNSPECIFIED":
      return PropertyDefinition_RetrievalImportance.RETRIEVAL_IMPORTANCE_UNSPECIFIED;
    case 1:
    case "HIGHEST":
      return PropertyDefinition_RetrievalImportance.HIGHEST;
    case 2:
    case "HIGHER":
      return PropertyDefinition_RetrievalImportance.HIGHER;
    case 3:
    case "HIGH":
      return PropertyDefinition_RetrievalImportance.HIGH;
    case 4:
    case "MEDIUM":
      return PropertyDefinition_RetrievalImportance.MEDIUM;
    case 5:
    case "LOW":
      return PropertyDefinition_RetrievalImportance.LOW;
    case 6:
    case "LOWEST":
      return PropertyDefinition_RetrievalImportance.LOWEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PropertyDefinition_RetrievalImportance.UNRECOGNIZED;
  }
}

export function propertyDefinition_RetrievalImportanceToJSON(object: PropertyDefinition_RetrievalImportance): string {
  switch (object) {
    case PropertyDefinition_RetrievalImportance.RETRIEVAL_IMPORTANCE_UNSPECIFIED:
      return "RETRIEVAL_IMPORTANCE_UNSPECIFIED";
    case PropertyDefinition_RetrievalImportance.HIGHEST:
      return "HIGHEST";
    case PropertyDefinition_RetrievalImportance.HIGHER:
      return "HIGHER";
    case PropertyDefinition_RetrievalImportance.HIGH:
      return "HIGH";
    case PropertyDefinition_RetrievalImportance.MEDIUM:
      return "MEDIUM";
    case PropertyDefinition_RetrievalImportance.LOW:
      return "LOW";
    case PropertyDefinition_RetrievalImportance.LOWEST:
      return "LOWEST";
    case PropertyDefinition_RetrievalImportance.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The schema source information. */
export interface PropertyDefinition_SchemaSource {
  /** The schema name in the source. */
  name: string;
  /** The Doc AI processor type name. */
  processorType: string;
}

/** Configurations for an integer property. */
export interface IntegerTypeOptions {
}

/** Configurations for a float property. */
export interface FloatTypeOptions {
}

/** Configurations for a text property. */
export interface TextTypeOptions {
}

/** Configurations for a date time property. */
export interface DateTimeTypeOptions {
}

/** Configurations for a Map property. */
export interface MapTypeOptions {
}

/** Configurations for a timestamp property. */
export interface TimestampTypeOptions {
}

/** Configurations for a nested structured data property. */
export interface PropertyTypeOptions {
  /** Required. List of property definitions. */
  propertyDefinitions: PropertyDefinition[];
}

/** Configurations for an enum/categorical property. */
export interface EnumTypeOptions {
  /** Required. List of possible enum values. */
  possibleValues: string[];
  /**
   * Make sure the Enum property value provided in the document is in the
   * possile value list during document creation. The validation check runs by
   * default.
   */
  validationCheckDisabled: boolean;
}

function createBaseDocumentSchema(): DocumentSchema {
  return {
    name: "",
    displayName: "",
    propertyDefinitions: [],
    documentIsFolder: false,
    updateTime: undefined,
    createTime: undefined,
    description: "",
  };
}

export const DocumentSchema: MessageFns<DocumentSchema> = {
  encode(message: DocumentSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.propertyDefinitions) {
      PropertyDefinition.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.documentIsFolder !== false) {
      writer.uint32(32).bool(message.documentIsFolder);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.propertyDefinitions.push(PropertyDefinition.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.documentIsFolder = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentSchema {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      propertyDefinitions: globalThis.Array.isArray(object?.propertyDefinitions)
        ? object.propertyDefinitions.map((e: any) => PropertyDefinition.fromJSON(e))
        : [],
      documentIsFolder: isSet(object.documentIsFolder) ? globalThis.Boolean(object.documentIsFolder) : false,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: DocumentSchema): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.propertyDefinitions?.length) {
      obj.propertyDefinitions = message.propertyDefinitions.map((e) => PropertyDefinition.toJSON(e));
    }
    if (message.documentIsFolder !== false) {
      obj.documentIsFolder = message.documentIsFolder;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentSchema>): DocumentSchema {
    return DocumentSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentSchema>): DocumentSchema {
    const message = createBaseDocumentSchema();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.propertyDefinitions = object.propertyDefinitions?.map((e) => PropertyDefinition.fromPartial(e)) || [];
    message.documentIsFolder = object.documentIsFolder ?? false;
    message.updateTime = object.updateTime ?? undefined;
    message.createTime = object.createTime ?? undefined;
    message.description = object.description ?? "";
    return message;
  },
};

function createBasePropertyDefinition(): PropertyDefinition {
  return {
    name: "",
    displayName: "",
    isRepeatable: false,
    isFilterable: false,
    isSearchable: false,
    isMetadata: false,
    isRequired: false,
    retrievalImportance: 0,
    integerTypeOptions: undefined,
    floatTypeOptions: undefined,
    textTypeOptions: undefined,
    propertyTypeOptions: undefined,
    enumTypeOptions: undefined,
    dateTimeTypeOptions: undefined,
    mapTypeOptions: undefined,
    timestampTypeOptions: undefined,
    schemaSources: [],
  };
}

export const PropertyDefinition: MessageFns<PropertyDefinition> = {
  encode(message: PropertyDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(98).string(message.displayName);
    }
    if (message.isRepeatable !== false) {
      writer.uint32(16).bool(message.isRepeatable);
    }
    if (message.isFilterable !== false) {
      writer.uint32(24).bool(message.isFilterable);
    }
    if (message.isSearchable !== false) {
      writer.uint32(32).bool(message.isSearchable);
    }
    if (message.isMetadata !== false) {
      writer.uint32(40).bool(message.isMetadata);
    }
    if (message.isRequired !== false) {
      writer.uint32(112).bool(message.isRequired);
    }
    if (message.retrievalImportance !== 0) {
      writer.uint32(144).int32(message.retrievalImportance);
    }
    if (message.integerTypeOptions !== undefined) {
      IntegerTypeOptions.encode(message.integerTypeOptions, writer.uint32(58).fork()).join();
    }
    if (message.floatTypeOptions !== undefined) {
      FloatTypeOptions.encode(message.floatTypeOptions, writer.uint32(66).fork()).join();
    }
    if (message.textTypeOptions !== undefined) {
      TextTypeOptions.encode(message.textTypeOptions, writer.uint32(74).fork()).join();
    }
    if (message.propertyTypeOptions !== undefined) {
      PropertyTypeOptions.encode(message.propertyTypeOptions, writer.uint32(82).fork()).join();
    }
    if (message.enumTypeOptions !== undefined) {
      EnumTypeOptions.encode(message.enumTypeOptions, writer.uint32(90).fork()).join();
    }
    if (message.dateTimeTypeOptions !== undefined) {
      DateTimeTypeOptions.encode(message.dateTimeTypeOptions, writer.uint32(106).fork()).join();
    }
    if (message.mapTypeOptions !== undefined) {
      MapTypeOptions.encode(message.mapTypeOptions, writer.uint32(122).fork()).join();
    }
    if (message.timestampTypeOptions !== undefined) {
      TimestampTypeOptions.encode(message.timestampTypeOptions, writer.uint32(130).fork()).join();
    }
    for (const v of message.schemaSources) {
      PropertyDefinition_SchemaSource.encode(v!, writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isRepeatable = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isFilterable = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isSearchable = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isMetadata = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.isRequired = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.retrievalImportance = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.integerTypeOptions = IntegerTypeOptions.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.floatTypeOptions = FloatTypeOptions.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.textTypeOptions = TextTypeOptions.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.propertyTypeOptions = PropertyTypeOptions.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.enumTypeOptions = EnumTypeOptions.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.dateTimeTypeOptions = DateTimeTypeOptions.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.mapTypeOptions = MapTypeOptions.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.timestampTypeOptions = TimestampTypeOptions.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.schemaSources.push(PropertyDefinition_SchemaSource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      isRepeatable: isSet(object.isRepeatable) ? globalThis.Boolean(object.isRepeatable) : false,
      isFilterable: isSet(object.isFilterable) ? globalThis.Boolean(object.isFilterable) : false,
      isSearchable: isSet(object.isSearchable) ? globalThis.Boolean(object.isSearchable) : false,
      isMetadata: isSet(object.isMetadata) ? globalThis.Boolean(object.isMetadata) : false,
      isRequired: isSet(object.isRequired) ? globalThis.Boolean(object.isRequired) : false,
      retrievalImportance: isSet(object.retrievalImportance)
        ? propertyDefinition_RetrievalImportanceFromJSON(object.retrievalImportance)
        : 0,
      integerTypeOptions: isSet(object.integerTypeOptions)
        ? IntegerTypeOptions.fromJSON(object.integerTypeOptions)
        : undefined,
      floatTypeOptions: isSet(object.floatTypeOptions) ? FloatTypeOptions.fromJSON(object.floatTypeOptions) : undefined,
      textTypeOptions: isSet(object.textTypeOptions) ? TextTypeOptions.fromJSON(object.textTypeOptions) : undefined,
      propertyTypeOptions: isSet(object.propertyTypeOptions)
        ? PropertyTypeOptions.fromJSON(object.propertyTypeOptions)
        : undefined,
      enumTypeOptions: isSet(object.enumTypeOptions) ? EnumTypeOptions.fromJSON(object.enumTypeOptions) : undefined,
      dateTimeTypeOptions: isSet(object.dateTimeTypeOptions)
        ? DateTimeTypeOptions.fromJSON(object.dateTimeTypeOptions)
        : undefined,
      mapTypeOptions: isSet(object.mapTypeOptions) ? MapTypeOptions.fromJSON(object.mapTypeOptions) : undefined,
      timestampTypeOptions: isSet(object.timestampTypeOptions)
        ? TimestampTypeOptions.fromJSON(object.timestampTypeOptions)
        : undefined,
      schemaSources: globalThis.Array.isArray(object?.schemaSources)
        ? object.schemaSources.map((e: any) => PropertyDefinition_SchemaSource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PropertyDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.isRepeatable !== false) {
      obj.isRepeatable = message.isRepeatable;
    }
    if (message.isFilterable !== false) {
      obj.isFilterable = message.isFilterable;
    }
    if (message.isSearchable !== false) {
      obj.isSearchable = message.isSearchable;
    }
    if (message.isMetadata !== false) {
      obj.isMetadata = message.isMetadata;
    }
    if (message.isRequired !== false) {
      obj.isRequired = message.isRequired;
    }
    if (message.retrievalImportance !== 0) {
      obj.retrievalImportance = propertyDefinition_RetrievalImportanceToJSON(message.retrievalImportance);
    }
    if (message.integerTypeOptions !== undefined) {
      obj.integerTypeOptions = IntegerTypeOptions.toJSON(message.integerTypeOptions);
    }
    if (message.floatTypeOptions !== undefined) {
      obj.floatTypeOptions = FloatTypeOptions.toJSON(message.floatTypeOptions);
    }
    if (message.textTypeOptions !== undefined) {
      obj.textTypeOptions = TextTypeOptions.toJSON(message.textTypeOptions);
    }
    if (message.propertyTypeOptions !== undefined) {
      obj.propertyTypeOptions = PropertyTypeOptions.toJSON(message.propertyTypeOptions);
    }
    if (message.enumTypeOptions !== undefined) {
      obj.enumTypeOptions = EnumTypeOptions.toJSON(message.enumTypeOptions);
    }
    if (message.dateTimeTypeOptions !== undefined) {
      obj.dateTimeTypeOptions = DateTimeTypeOptions.toJSON(message.dateTimeTypeOptions);
    }
    if (message.mapTypeOptions !== undefined) {
      obj.mapTypeOptions = MapTypeOptions.toJSON(message.mapTypeOptions);
    }
    if (message.timestampTypeOptions !== undefined) {
      obj.timestampTypeOptions = TimestampTypeOptions.toJSON(message.timestampTypeOptions);
    }
    if (message.schemaSources?.length) {
      obj.schemaSources = message.schemaSources.map((e) => PropertyDefinition_SchemaSource.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyDefinition>): PropertyDefinition {
    return PropertyDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyDefinition>): PropertyDefinition {
    const message = createBasePropertyDefinition();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.isRepeatable = object.isRepeatable ?? false;
    message.isFilterable = object.isFilterable ?? false;
    message.isSearchable = object.isSearchable ?? false;
    message.isMetadata = object.isMetadata ?? false;
    message.isRequired = object.isRequired ?? false;
    message.retrievalImportance = object.retrievalImportance ?? 0;
    message.integerTypeOptions = (object.integerTypeOptions !== undefined && object.integerTypeOptions !== null)
      ? IntegerTypeOptions.fromPartial(object.integerTypeOptions)
      : undefined;
    message.floatTypeOptions = (object.floatTypeOptions !== undefined && object.floatTypeOptions !== null)
      ? FloatTypeOptions.fromPartial(object.floatTypeOptions)
      : undefined;
    message.textTypeOptions = (object.textTypeOptions !== undefined && object.textTypeOptions !== null)
      ? TextTypeOptions.fromPartial(object.textTypeOptions)
      : undefined;
    message.propertyTypeOptions = (object.propertyTypeOptions !== undefined && object.propertyTypeOptions !== null)
      ? PropertyTypeOptions.fromPartial(object.propertyTypeOptions)
      : undefined;
    message.enumTypeOptions = (object.enumTypeOptions !== undefined && object.enumTypeOptions !== null)
      ? EnumTypeOptions.fromPartial(object.enumTypeOptions)
      : undefined;
    message.dateTimeTypeOptions = (object.dateTimeTypeOptions !== undefined && object.dateTimeTypeOptions !== null)
      ? DateTimeTypeOptions.fromPartial(object.dateTimeTypeOptions)
      : undefined;
    message.mapTypeOptions = (object.mapTypeOptions !== undefined && object.mapTypeOptions !== null)
      ? MapTypeOptions.fromPartial(object.mapTypeOptions)
      : undefined;
    message.timestampTypeOptions = (object.timestampTypeOptions !== undefined && object.timestampTypeOptions !== null)
      ? TimestampTypeOptions.fromPartial(object.timestampTypeOptions)
      : undefined;
    message.schemaSources = object.schemaSources?.map((e) => PropertyDefinition_SchemaSource.fromPartial(e)) || [];
    return message;
  },
};

function createBasePropertyDefinition_SchemaSource(): PropertyDefinition_SchemaSource {
  return { name: "", processorType: "" };
}

export const PropertyDefinition_SchemaSource: MessageFns<PropertyDefinition_SchemaSource> = {
  encode(message: PropertyDefinition_SchemaSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.processorType !== "") {
      writer.uint32(18).string(message.processorType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyDefinition_SchemaSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyDefinition_SchemaSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.processorType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyDefinition_SchemaSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      processorType: isSet(object.processorType) ? globalThis.String(object.processorType) : "",
    };
  },

  toJSON(message: PropertyDefinition_SchemaSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.processorType !== "") {
      obj.processorType = message.processorType;
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyDefinition_SchemaSource>): PropertyDefinition_SchemaSource {
    return PropertyDefinition_SchemaSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyDefinition_SchemaSource>): PropertyDefinition_SchemaSource {
    const message = createBasePropertyDefinition_SchemaSource();
    message.name = object.name ?? "";
    message.processorType = object.processorType ?? "";
    return message;
  },
};

function createBaseIntegerTypeOptions(): IntegerTypeOptions {
  return {};
}

export const IntegerTypeOptions: MessageFns<IntegerTypeOptions> = {
  encode(_: IntegerTypeOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntegerTypeOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegerTypeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IntegerTypeOptions {
    return {};
  },

  toJSON(_: IntegerTypeOptions): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<IntegerTypeOptions>): IntegerTypeOptions {
    return IntegerTypeOptions.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<IntegerTypeOptions>): IntegerTypeOptions {
    const message = createBaseIntegerTypeOptions();
    return message;
  },
};

function createBaseFloatTypeOptions(): FloatTypeOptions {
  return {};
}

export const FloatTypeOptions: MessageFns<FloatTypeOptions> = {
  encode(_: FloatTypeOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatTypeOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatTypeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FloatTypeOptions {
    return {};
  },

  toJSON(_: FloatTypeOptions): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<FloatTypeOptions>): FloatTypeOptions {
    return FloatTypeOptions.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<FloatTypeOptions>): FloatTypeOptions {
    const message = createBaseFloatTypeOptions();
    return message;
  },
};

function createBaseTextTypeOptions(): TextTypeOptions {
  return {};
}

export const TextTypeOptions: MessageFns<TextTypeOptions> = {
  encode(_: TextTypeOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextTypeOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextTypeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TextTypeOptions {
    return {};
  },

  toJSON(_: TextTypeOptions): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<TextTypeOptions>): TextTypeOptions {
    return TextTypeOptions.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<TextTypeOptions>): TextTypeOptions {
    const message = createBaseTextTypeOptions();
    return message;
  },
};

function createBaseDateTimeTypeOptions(): DateTimeTypeOptions {
  return {};
}

export const DateTimeTypeOptions: MessageFns<DateTimeTypeOptions> = {
  encode(_: DateTimeTypeOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateTimeTypeOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateTimeTypeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DateTimeTypeOptions {
    return {};
  },

  toJSON(_: DateTimeTypeOptions): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DateTimeTypeOptions>): DateTimeTypeOptions {
    return DateTimeTypeOptions.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DateTimeTypeOptions>): DateTimeTypeOptions {
    const message = createBaseDateTimeTypeOptions();
    return message;
  },
};

function createBaseMapTypeOptions(): MapTypeOptions {
  return {};
}

export const MapTypeOptions: MessageFns<MapTypeOptions> = {
  encode(_: MapTypeOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapTypeOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapTypeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MapTypeOptions {
    return {};
  },

  toJSON(_: MapTypeOptions): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MapTypeOptions>): MapTypeOptions {
    return MapTypeOptions.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MapTypeOptions>): MapTypeOptions {
    const message = createBaseMapTypeOptions();
    return message;
  },
};

function createBaseTimestampTypeOptions(): TimestampTypeOptions {
  return {};
}

export const TimestampTypeOptions: MessageFns<TimestampTypeOptions> = {
  encode(_: TimestampTypeOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimestampTypeOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestampTypeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TimestampTypeOptions {
    return {};
  },

  toJSON(_: TimestampTypeOptions): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<TimestampTypeOptions>): TimestampTypeOptions {
    return TimestampTypeOptions.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<TimestampTypeOptions>): TimestampTypeOptions {
    const message = createBaseTimestampTypeOptions();
    return message;
  },
};

function createBasePropertyTypeOptions(): PropertyTypeOptions {
  return { propertyDefinitions: [] };
}

export const PropertyTypeOptions: MessageFns<PropertyTypeOptions> = {
  encode(message: PropertyTypeOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.propertyDefinitions) {
      PropertyDefinition.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyTypeOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyTypeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.propertyDefinitions.push(PropertyDefinition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyTypeOptions {
    return {
      propertyDefinitions: globalThis.Array.isArray(object?.propertyDefinitions)
        ? object.propertyDefinitions.map((e: any) => PropertyDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PropertyTypeOptions): unknown {
    const obj: any = {};
    if (message.propertyDefinitions?.length) {
      obj.propertyDefinitions = message.propertyDefinitions.map((e) => PropertyDefinition.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyTypeOptions>): PropertyTypeOptions {
    return PropertyTypeOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyTypeOptions>): PropertyTypeOptions {
    const message = createBasePropertyTypeOptions();
    message.propertyDefinitions = object.propertyDefinitions?.map((e) => PropertyDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEnumTypeOptions(): EnumTypeOptions {
  return { possibleValues: [], validationCheckDisabled: false };
}

export const EnumTypeOptions: MessageFns<EnumTypeOptions> = {
  encode(message: EnumTypeOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.possibleValues) {
      writer.uint32(10).string(v!);
    }
    if (message.validationCheckDisabled !== false) {
      writer.uint32(16).bool(message.validationCheckDisabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumTypeOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumTypeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.possibleValues.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validationCheckDisabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumTypeOptions {
    return {
      possibleValues: globalThis.Array.isArray(object?.possibleValues)
        ? object.possibleValues.map((e: any) => globalThis.String(e))
        : [],
      validationCheckDisabled: isSet(object.validationCheckDisabled)
        ? globalThis.Boolean(object.validationCheckDisabled)
        : false,
    };
  },

  toJSON(message: EnumTypeOptions): unknown {
    const obj: any = {};
    if (message.possibleValues?.length) {
      obj.possibleValues = message.possibleValues;
    }
    if (message.validationCheckDisabled !== false) {
      obj.validationCheckDisabled = message.validationCheckDisabled;
    }
    return obj;
  },

  create(base?: DeepPartial<EnumTypeOptions>): EnumTypeOptions {
    return EnumTypeOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumTypeOptions>): EnumTypeOptions {
    const message = createBaseEnumTypeOptions();
    message.possibleValues = object.possibleValues?.map((e) => e) || [];
    message.validationCheckDisabled = object.validationCheckDisabled ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
