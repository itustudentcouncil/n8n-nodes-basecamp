// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/contentwarehouse/v1/histogram.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.contentwarehouse.v1";

/** The histogram request. */
export interface HistogramQuery {
  /**
   * An expression specifies a histogram request against matching documents for
   * searches.
   *
   * See
   * [SearchDocumentsRequest.histogram_queries][google.cloud.contentwarehouse.v1.SearchDocumentsRequest.histogram_queries]
   * for details about syntax.
   */
  histogramQuery: string;
  /**
   * Controls if the histogram query requires the return of a precise count.
   * Enable this flag may adversely impact performance.
   *
   * Defaults to true.
   */
  requirePreciseResultSize: boolean;
  /**
   * Optional. Filter the result of histogram query by the property names. It
   * only works with histogram query count('FilterableProperties'). It is an
   * optional. It will perform histogram on all the property names for all the
   * document schemas. Setting this field will have a better performance.
   */
  filters: HistogramQueryPropertyNameFilter | undefined;
}

export interface HistogramQueryPropertyNameFilter {
  /**
   * This filter specifies the exact document schema(s)
   * [Document.document_schema_name][google.cloud.contentwarehouse.v1.Document.document_schema_name]
   * to run histogram query against. It is optional. It will perform histogram
   * for property names for all the document schemas if it is not set.
   *
   * At most 10 document schema names are allowed.
   * Format:
   * projects/{project_number}/locations/{location}/documentSchemas/{document_schema_id}.
   */
  documentSchemas: string[];
  /**
   * It is optional. It will perform histogram for all the property names if it
   * is not set.
   * The properties need to be defined with the is_filterable flag set to
   * true and the name of the property should be in the format:
   * "schemaId.propertyName". The property needs to be defined in the schema.
   * Example: the schema id is abc. Then the name of property for property
   * MORTGAGE_TYPE will be "abc.MORTGAGE_TYPE".
   */
  propertyNames: string[];
  /**
   * By default, the y_axis is HISTOGRAM_YAXIS_DOCUMENT if this field is not
   * set.
   */
  yAxis: HistogramQueryPropertyNameFilter_HistogramYAxis;
}

/**
 * The result of the histogram query count('FilterableProperties') using
 * HISTOGRAM_YAXIS_DOCUMENT will be:
 * invoice_id: 2
 * address: 1
 * payment_method: 2
 * line_item_description: 1
 */
export enum HistogramQueryPropertyNameFilter_HistogramYAxis {
  /** HISTOGRAM_YAXIS_DOCUMENT - Count the documents per property name. */
  HISTOGRAM_YAXIS_DOCUMENT = 0,
  /** HISTOGRAM_YAXIS_PROPERTY - Count the properties per property name. */
  HISTOGRAM_YAXIS_PROPERTY = 1,
  UNRECOGNIZED = -1,
}

export function histogramQueryPropertyNameFilter_HistogramYAxisFromJSON(
  object: any,
): HistogramQueryPropertyNameFilter_HistogramYAxis {
  switch (object) {
    case 0:
    case "HISTOGRAM_YAXIS_DOCUMENT":
      return HistogramQueryPropertyNameFilter_HistogramYAxis.HISTOGRAM_YAXIS_DOCUMENT;
    case 1:
    case "HISTOGRAM_YAXIS_PROPERTY":
      return HistogramQueryPropertyNameFilter_HistogramYAxis.HISTOGRAM_YAXIS_PROPERTY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HistogramQueryPropertyNameFilter_HistogramYAxis.UNRECOGNIZED;
  }
}

export function histogramQueryPropertyNameFilter_HistogramYAxisToJSON(
  object: HistogramQueryPropertyNameFilter_HistogramYAxis,
): string {
  switch (object) {
    case HistogramQueryPropertyNameFilter_HistogramYAxis.HISTOGRAM_YAXIS_DOCUMENT:
      return "HISTOGRAM_YAXIS_DOCUMENT";
    case HistogramQueryPropertyNameFilter_HistogramYAxis.HISTOGRAM_YAXIS_PROPERTY:
      return "HISTOGRAM_YAXIS_PROPERTY";
    case HistogramQueryPropertyNameFilter_HistogramYAxis.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Histogram result that matches
 * [HistogramQuery][google.cloud.contentwarehouse.v1.HistogramQuery] specified
 * in searches.
 */
export interface HistogramQueryResult {
  /** Requested histogram expression. */
  histogramQuery: string;
  /**
   * A map from the values of the facet associated with distinct values to the
   * number of matching entries with corresponding value.
   *
   * The key format is:
   *
   * * (for string histogram) string values stored in the field.
   */
  histogram: { [key: string]: Long };
}

export interface HistogramQueryResult_HistogramEntry {
  key: string;
  value: Long;
}

function createBaseHistogramQuery(): HistogramQuery {
  return { histogramQuery: "", requirePreciseResultSize: false, filters: undefined };
}

export const HistogramQuery: MessageFns<HistogramQuery> = {
  encode(message: HistogramQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.histogramQuery !== "") {
      writer.uint32(10).string(message.histogramQuery);
    }
    if (message.requirePreciseResultSize !== false) {
      writer.uint32(16).bool(message.requirePreciseResultSize);
    }
    if (message.filters !== undefined) {
      HistogramQueryPropertyNameFilter.encode(message.filters, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HistogramQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistogramQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.histogramQuery = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.requirePreciseResultSize = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filters = HistogramQueryPropertyNameFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HistogramQuery {
    return {
      histogramQuery: isSet(object.histogramQuery) ? globalThis.String(object.histogramQuery) : "",
      requirePreciseResultSize: isSet(object.requirePreciseResultSize)
        ? globalThis.Boolean(object.requirePreciseResultSize)
        : false,
      filters: isSet(object.filters) ? HistogramQueryPropertyNameFilter.fromJSON(object.filters) : undefined,
    };
  },

  toJSON(message: HistogramQuery): unknown {
    const obj: any = {};
    if (message.histogramQuery !== "") {
      obj.histogramQuery = message.histogramQuery;
    }
    if (message.requirePreciseResultSize !== false) {
      obj.requirePreciseResultSize = message.requirePreciseResultSize;
    }
    if (message.filters !== undefined) {
      obj.filters = HistogramQueryPropertyNameFilter.toJSON(message.filters);
    }
    return obj;
  },

  create(base?: DeepPartial<HistogramQuery>): HistogramQuery {
    return HistogramQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HistogramQuery>): HistogramQuery {
    const message = createBaseHistogramQuery();
    message.histogramQuery = object.histogramQuery ?? "";
    message.requirePreciseResultSize = object.requirePreciseResultSize ?? false;
    message.filters = (object.filters !== undefined && object.filters !== null)
      ? HistogramQueryPropertyNameFilter.fromPartial(object.filters)
      : undefined;
    return message;
  },
};

function createBaseHistogramQueryPropertyNameFilter(): HistogramQueryPropertyNameFilter {
  return { documentSchemas: [], propertyNames: [], yAxis: 0 };
}

export const HistogramQueryPropertyNameFilter: MessageFns<HistogramQueryPropertyNameFilter> = {
  encode(message: HistogramQueryPropertyNameFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.documentSchemas) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.propertyNames) {
      writer.uint32(18).string(v!);
    }
    if (message.yAxis !== 0) {
      writer.uint32(24).int32(message.yAxis);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HistogramQueryPropertyNameFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistogramQueryPropertyNameFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentSchemas.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.propertyNames.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.yAxis = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HistogramQueryPropertyNameFilter {
    return {
      documentSchemas: globalThis.Array.isArray(object?.documentSchemas)
        ? object.documentSchemas.map((e: any) => globalThis.String(e))
        : [],
      propertyNames: globalThis.Array.isArray(object?.propertyNames)
        ? object.propertyNames.map((e: any) => globalThis.String(e))
        : [],
      yAxis: isSet(object.yAxis) ? histogramQueryPropertyNameFilter_HistogramYAxisFromJSON(object.yAxis) : 0,
    };
  },

  toJSON(message: HistogramQueryPropertyNameFilter): unknown {
    const obj: any = {};
    if (message.documentSchemas?.length) {
      obj.documentSchemas = message.documentSchemas;
    }
    if (message.propertyNames?.length) {
      obj.propertyNames = message.propertyNames;
    }
    if (message.yAxis !== 0) {
      obj.yAxis = histogramQueryPropertyNameFilter_HistogramYAxisToJSON(message.yAxis);
    }
    return obj;
  },

  create(base?: DeepPartial<HistogramQueryPropertyNameFilter>): HistogramQueryPropertyNameFilter {
    return HistogramQueryPropertyNameFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HistogramQueryPropertyNameFilter>): HistogramQueryPropertyNameFilter {
    const message = createBaseHistogramQueryPropertyNameFilter();
    message.documentSchemas = object.documentSchemas?.map((e) => e) || [];
    message.propertyNames = object.propertyNames?.map((e) => e) || [];
    message.yAxis = object.yAxis ?? 0;
    return message;
  },
};

function createBaseHistogramQueryResult(): HistogramQueryResult {
  return { histogramQuery: "", histogram: {} };
}

export const HistogramQueryResult: MessageFns<HistogramQueryResult> = {
  encode(message: HistogramQueryResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.histogramQuery !== "") {
      writer.uint32(10).string(message.histogramQuery);
    }
    Object.entries(message.histogram).forEach(([key, value]) => {
      HistogramQueryResult_HistogramEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HistogramQueryResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistogramQueryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.histogramQuery = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = HistogramQueryResult_HistogramEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.histogram[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HistogramQueryResult {
    return {
      histogramQuery: isSet(object.histogramQuery) ? globalThis.String(object.histogramQuery) : "",
      histogram: isObject(object.histogram)
        ? Object.entries(object.histogram).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: HistogramQueryResult): unknown {
    const obj: any = {};
    if (message.histogramQuery !== "") {
      obj.histogramQuery = message.histogramQuery;
    }
    if (message.histogram) {
      const entries = Object.entries(message.histogram);
      if (entries.length > 0) {
        obj.histogram = {};
        entries.forEach(([k, v]) => {
          obj.histogram[k] = v.toString();
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<HistogramQueryResult>): HistogramQueryResult {
    return HistogramQueryResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HistogramQueryResult>): HistogramQueryResult {
    const message = createBaseHistogramQueryResult();
    message.histogramQuery = object.histogramQuery ?? "";
    message.histogram = Object.entries(object.histogram ?? {}).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Long.fromValue(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseHistogramQueryResult_HistogramEntry(): HistogramQueryResult_HistogramEntry {
  return { key: "", value: Long.ZERO };
}

export const HistogramQueryResult_HistogramEntry: MessageFns<HistogramQueryResult_HistogramEntry> = {
  encode(message: HistogramQueryResult_HistogramEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HistogramQueryResult_HistogramEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistogramQueryResult_HistogramEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HistogramQueryResult_HistogramEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: HistogramQueryResult_HistogramEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<HistogramQueryResult_HistogramEntry>): HistogramQueryResult_HistogramEntry {
    return HistogramQueryResult_HistogramEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HistogramQueryResult_HistogramEntry>): HistogramQueryResult_HistogramEntry {
    const message = createBaseHistogramQueryResult_HistogramEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
