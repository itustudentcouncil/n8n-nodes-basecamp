// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/contentwarehouse/v1/document_service_request.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Policy } from "../../../iam/v1/policy.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { RequestMetadata, UpdateOptions, UserInfo } from "./common.js";
import { Document } from "./document.js";
import { DocumentQuery } from "./filters.js";
import { HistogramQuery } from "./histogram.js";

export const protobufPackage = "google.cloud.contentwarehouse.v1";

/** Request Option for processing Cloud AI Document in CW Document. */
export interface CloudAIDocumentOption {
  /** Whether to convert all the entities to properties. */
  enableEntitiesConversions: boolean;
  /** If set, only selected entities will be converted to properties. */
  customizedEntitiesPropertiesConversions: { [key: string]: string };
}

export interface CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry {
  key: string;
  value: string;
}

/** Request message for DocumentService.CreateDocument. */
export interface CreateDocumentRequest {
  /**
   * Required. The parent name.
   * Format: projects/{project_number}/locations/{location}.
   */
  parent: string;
  /** Required. The document to create. */
  document:
    | Document
    | undefined;
  /**
   * The meta information collected about the end user, used to enforce access
   * control for the service.
   */
  requestMetadata:
    | RequestMetadata
    | undefined;
  /**
   * Default document policy during creation.
   * This refers to an Identity and Access (IAM) policy, which specifies access
   * controls for the Document.
   * Conditions defined in the policy will be ignored.
   */
  policy:
    | Policy
    | undefined;
  /**
   * Request Option for processing Cloud AI Document in Document Warehouse.
   * This field offers limited support for mapping entities from Cloud AI
   * Document to Warehouse Document. Please consult with product team before
   * using this field and other available options.
   */
  cloudAiDocumentOption:
    | CloudAIDocumentOption
    | undefined;
  /**
   * Field mask for creating Document fields. If mask path is empty,
   * it means all fields are masked.
   * For the `FieldMask` definition,
   * see
   * https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask.
   */
  createMask: string[] | undefined;
}

/** Request message for DocumentService.GetDocument. */
export interface GetDocumentRequest {
  /**
   * Required. The name of the document to retrieve.
   * Format:
   * projects/{project_number}/locations/{location}/documents/{document_id} or
   * projects/{project_number}/locations/{location}/documents/referenceId/{reference_id}.
   */
  name: string;
  /**
   * The meta information collected about the end user, used to enforce access
   * control for the service.
   */
  requestMetadata: RequestMetadata | undefined;
}

/** Request message for DocumentService.UpdateDocument. */
export interface UpdateDocumentRequest {
  /**
   * Required. The name of the document to update.
   * Format:
   * projects/{project_number}/locations/{location}/documents/{document_id}
   * or
   * projects/{project_number}/locations/{location}/documents/referenceId/{reference_id}.
   */
  name: string;
  /** Required. The document to update. */
  document:
    | Document
    | undefined;
  /**
   * The meta information collected about the end user, used to enforce access
   * control for the service.
   */
  requestMetadata:
    | RequestMetadata
    | undefined;
  /**
   * Request Option for processing Cloud AI Document in Document Warehouse.
   * This field offers limited support for mapping entities from Cloud AI
   * Document to Warehouse Document. Please consult with product team before
   * using this field and other available options.
   */
  cloudAiDocumentOption:
    | CloudAIDocumentOption
    | undefined;
  /** Options for the update operation. */
  updateOptions: UpdateOptions | undefined;
}

/** Request message for DocumentService.DeleteDocument. */
export interface DeleteDocumentRequest {
  /**
   * Required. The name of the document to delete.
   * Format:
   * projects/{project_number}/locations/{location}/documents/{document_id}
   * or
   * projects/{project_number}/locations/{location}/documents/referenceId/{reference_id}.
   */
  name: string;
  /**
   * The meta information collected about the end user, used to enforce access
   * control for the service.
   */
  requestMetadata: RequestMetadata | undefined;
}

/** Request message for DocumentService.SearchDocuments. */
export interface SearchDocumentsRequest {
  /**
   * Required. The parent, which owns this collection of documents.
   * Format: projects/{project_number}/locations/{location}.
   */
  parent: string;
  /**
   * The meta information collected about the end user, used to enforce access
   * control and improve the search quality of the service.
   */
  requestMetadata:
    | RequestMetadata
    | undefined;
  /** Query used to search against documents (keyword, filters, etc.). */
  documentQuery:
    | DocumentQuery
    | undefined;
  /**
   * An integer that specifies the current offset (that is, starting result
   * location, amongst the documents deemed by the API as relevant) in search
   * results. This field is only considered if
   * [page_token][google.cloud.contentwarehouse.v1.SearchDocumentsRequest.page_token]
   * is unset.
   *
   * The maximum allowed value is 5000. Otherwise an error is thrown.
   *
   * For example, 0 means to  return results starting from the first matching
   * document, and 10 means to return from the 11th document. This can be used
   * for pagination, (for example, pageSize = 10 and offset = 10 means to return
   * from the second page).
   */
  offset: number;
  /**
   * A limit on the number of documents returned in the search results.
   * Increasing this value above the default value of 10 can increase search
   * response time. The value can be between 1 and 100.
   */
  pageSize: number;
  /**
   * The token specifying the current offset within search results.
   * See
   * [SearchDocumentsResponse.next_page_token][google.cloud.contentwarehouse.v1.SearchDocumentsResponse.next_page_token]
   * for an explanation of how to obtain the next set of query results.
   */
  pageToken: string;
  /**
   * The criteria determining how search results are sorted. For non-empty
   * query, default is `"relevance desc"`. For empty query, default is
   * `"upload_date desc"`.
   *
   * Supported options are:
   *
   * * `"relevance desc"`: By relevance descending, as determined by the API
   *   algorithms.
   * * `"upload_date desc"`: By upload date descending.
   * * `"upload_date"`: By upload date ascending.
   * * `"update_date desc"`: By last updated date descending.
   * * `"update_date"`: By last updated date ascending.
   * * `"retrieval_importance desc"`: By retrieval importance of properties
   *   descending. This feature is still under development, please do not use
   *   unless otherwise instructed to do so.
   */
  orderBy: string;
  /**
   * An expression specifying a histogram request against matching
   * documents. Expression syntax is an aggregation function call with
   * histogram facets and other options.
   *
   * The following aggregation functions are supported:
   *
   * * `count(string_histogram_facet)`: Count the number of matching entities
   * for each distinct attribute value.
   *
   * Data types:
   *
   * * Histogram facet (aka filterable properties): Facet names with format
   * &lt;schema id&gt;.&lt;facet&gt;. Facets will have the
   * format of: `[a-zA-Z][a-zA-Z0-9_:/-.]`. If the facet is a child
   * facet, then the parent hierarchy needs to be specified separated by
   * dots in the prefix after the schema id. Thus, the format for a multi-
   * level facet is: &lt;schema id&gt;.&lt;parent facet name&gt;.
   * &lt;child facet name&gt;. Example:
   * schema123.root_parent_facet.middle_facet.child_facet
   * * DocumentSchemaId: (with no schema id prefix) to get
   * histograms for each document type (returns the schema id path, e.g.
   * projects/12345/locations/us-west/documentSchemas/abc123).
   *
   * Example expression:
   *
   * * Document type counts:
   *   count('DocumentSchemaId')
   *
   * * For schema id, abc123, get the counts for MORTGAGE_TYPE:
   *   count('abc123.MORTGAGE_TYPE')
   */
  histogramQueries: HistogramQuery[];
  /**
   * Controls if the search document request requires the return of a total size
   * of matched documents. See
   * [SearchDocumentsResponse.total_size][google.cloud.contentwarehouse.v1.SearchDocumentsResponse.total_size].
   *
   * Enabling this flag may adversely impact performance. Hint: If this is
   * used with pagination, set this flag on the initial query but set this
   * to false on subsequent page calls (keep the total count locally).
   *
   * Defaults to false.
   */
  requireTotalSize: boolean;
  /**
   * Controls if the search document request requires the return of a total size
   * of matched documents. See
   * [SearchDocumentsResponse.total_size][google.cloud.contentwarehouse.v1.SearchDocumentsResponse.total_size].
   */
  totalResultSize: SearchDocumentsRequest_TotalResultSize;
  /**
   * Experimental, do not use.
   * The limit on the number of documents returned for the question-answering
   * feature. To enable the question-answering feature, set
   * [DocumentQuery].[is_nl_query][] to true.
   */
  qaSizeLimit: number;
}

/** The total number of matching documents. */
export enum SearchDocumentsRequest_TotalResultSize {
  /** TOTAL_RESULT_SIZE_UNSPECIFIED - Total number calculation will be skipped. */
  TOTAL_RESULT_SIZE_UNSPECIFIED = 0,
  /**
   * ESTIMATED_SIZE - Estimate total number. The total result size will be accurated up to
   * 10,000. This option will add cost and latency to your request.
   */
  ESTIMATED_SIZE = 1,
  /** ACTUAL_SIZE - It may adversely impact performance. The limit is 1000,000. */
  ACTUAL_SIZE = 2,
  UNRECOGNIZED = -1,
}

export function searchDocumentsRequest_TotalResultSizeFromJSON(object: any): SearchDocumentsRequest_TotalResultSize {
  switch (object) {
    case 0:
    case "TOTAL_RESULT_SIZE_UNSPECIFIED":
      return SearchDocumentsRequest_TotalResultSize.TOTAL_RESULT_SIZE_UNSPECIFIED;
    case 1:
    case "ESTIMATED_SIZE":
      return SearchDocumentsRequest_TotalResultSize.ESTIMATED_SIZE;
    case 2:
    case "ACTUAL_SIZE":
      return SearchDocumentsRequest_TotalResultSize.ACTUAL_SIZE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchDocumentsRequest_TotalResultSize.UNRECOGNIZED;
  }
}

export function searchDocumentsRequest_TotalResultSizeToJSON(object: SearchDocumentsRequest_TotalResultSize): string {
  switch (object) {
    case SearchDocumentsRequest_TotalResultSize.TOTAL_RESULT_SIZE_UNSPECIFIED:
      return "TOTAL_RESULT_SIZE_UNSPECIFIED";
    case SearchDocumentsRequest_TotalResultSize.ESTIMATED_SIZE:
      return "ESTIMATED_SIZE";
    case SearchDocumentsRequest_TotalResultSize.ACTUAL_SIZE:
      return "ACTUAL_SIZE";
    case SearchDocumentsRequest_TotalResultSize.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for DocumentService.LockDocument. */
export interface LockDocumentRequest {
  /**
   * Required. The name of the document to lock.
   * Format:
   * projects/{project_number}/locations/{location}/documents/{document}.
   */
  name: string;
  /** The collection the document connects to. */
  collectionId: string;
  /** The user information who locks the document. */
  lockingUser: UserInfo | undefined;
}

/** Request message for DocumentService.FetchAcl */
export interface FetchAclRequest {
  /**
   * Required. REQUIRED: The resource for which the policy is being requested.
   * Format for document:
   * projects/{project_number}/locations/{location}/documents/{document_id}.
   * Format for collection:
   * projects/{project_number}/locations/{location}/collections/{collection_id}.
   * Format for project: projects/{project_number}.
   */
  resource: string;
  /**
   * The meta information collected about the end user, used to enforce access
   * control for the service.
   */
  requestMetadata:
    | RequestMetadata
    | undefined;
  /**
   * For Get Project ACL only. Authorization check for end user will be ignored
   * when project_owner=true.
   */
  projectOwner: boolean;
}

/** Request message for DocumentService.SetAcl. */
export interface SetAclRequest {
  /**
   * Required. REQUIRED: The resource for which the policy is being requested.
   * Format for document:
   * projects/{project_number}/locations/{location}/documents/{document_id}.
   * Format for collection:
   * projects/{project_number}/locations/{location}/collections/{collection_id}.
   * Format for project: projects/{project_number}.
   */
  resource: string;
  /**
   * Required. REQUIRED: The complete policy to be applied to the `resource`.
   * The size of the policy is limited to a few 10s of KB. This refers to an
   * Identity and Access (IAM) policy, which specifies access controls for the
   * Document.
   *
   * You can set ACL with condition for projects only.
   *
   * Supported operators are: `=`, `!=`, `<`, `<=`, `>`, and `>=` where
   * the left of the operator is `DocumentSchemaId` or property name and the
   * right of the operator is a number or a quoted string. You must escape
   * backslash (\\) and quote (\") characters.
   *
   * Boolean expressions (AND/OR) are supported up to 3 levels of nesting (for
   * example, "((A AND B AND C) OR D) AND E"), a maximum of 10 comparisons are
   * allowed in the expression. The expression must be < 6000 bytes in length.
   *
   * Sample condition:
   *     `"DocumentSchemaId = \"some schema id\" OR SchemaId.floatPropertyName
   *     >= 10"`
   */
  policy:
    | Policy
    | undefined;
  /**
   * The meta information collected about the end user, used to enforce access
   * control for the service.
   */
  requestMetadata:
    | RequestMetadata
    | undefined;
  /**
   * For Set Project ACL only. Authorization check for end user will be ignored
   * when project_owner=true.
   */
  projectOwner: boolean;
}

function createBaseCloudAIDocumentOption(): CloudAIDocumentOption {
  return { enableEntitiesConversions: false, customizedEntitiesPropertiesConversions: {} };
}

export const CloudAIDocumentOption: MessageFns<CloudAIDocumentOption> = {
  encode(message: CloudAIDocumentOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableEntitiesConversions !== false) {
      writer.uint32(8).bool(message.enableEntitiesConversions);
    }
    Object.entries(message.customizedEntitiesPropertiesConversions).forEach(([key, value]) => {
      CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudAIDocumentOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudAIDocumentOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableEntitiesConversions = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry2.value !== undefined) {
            message.customizedEntitiesPropertiesConversions[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudAIDocumentOption {
    return {
      enableEntitiesConversions: isSet(object.enableEntitiesConversions)
        ? globalThis.Boolean(object.enableEntitiesConversions)
        : false,
      customizedEntitiesPropertiesConversions: isObject(object.customizedEntitiesPropertiesConversions)
        ? Object.entries(object.customizedEntitiesPropertiesConversions).reduce<{ [key: string]: string }>(
          (acc, [key, value]) => {
            acc[key] = String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CloudAIDocumentOption): unknown {
    const obj: any = {};
    if (message.enableEntitiesConversions !== false) {
      obj.enableEntitiesConversions = message.enableEntitiesConversions;
    }
    if (message.customizedEntitiesPropertiesConversions) {
      const entries = Object.entries(message.customizedEntitiesPropertiesConversions);
      if (entries.length > 0) {
        obj.customizedEntitiesPropertiesConversions = {};
        entries.forEach(([k, v]) => {
          obj.customizedEntitiesPropertiesConversions[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CloudAIDocumentOption>): CloudAIDocumentOption {
    return CloudAIDocumentOption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudAIDocumentOption>): CloudAIDocumentOption {
    const message = createBaseCloudAIDocumentOption();
    message.enableEntitiesConversions = object.enableEntitiesConversions ?? false;
    message.customizedEntitiesPropertiesConversions = Object.entries(
      object.customizedEntitiesPropertiesConversions ?? {},
    ).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry(): CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry {
  return { key: "", value: "" };
}

export const CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry: MessageFns<
  CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry
> = {
  encode(
    message: CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry>,
  ): CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry {
    return CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry>,
  ): CloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry {
    const message = createBaseCloudAIDocumentOption_CustomizedEntitiesPropertiesConversionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateDocumentRequest(): CreateDocumentRequest {
  return {
    parent: "",
    document: undefined,
    requestMetadata: undefined,
    policy: undefined,
    cloudAiDocumentOption: undefined,
    createMask: undefined,
  };
}

export const CreateDocumentRequest: MessageFns<CreateDocumentRequest> = {
  encode(message: CreateDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.document !== undefined) {
      Document.encode(message.document, writer.uint32(18).fork()).join();
    }
    if (message.requestMetadata !== undefined) {
      RequestMetadata.encode(message.requestMetadata, writer.uint32(26).fork()).join();
    }
    if (message.policy !== undefined) {
      Policy.encode(message.policy, writer.uint32(34).fork()).join();
    }
    if (message.cloudAiDocumentOption !== undefined) {
      CloudAIDocumentOption.encode(message.cloudAiDocumentOption, writer.uint32(42).fork()).join();
    }
    if (message.createMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.createMask), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.document = Document.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestMetadata = RequestMetadata.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.policy = Policy.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cloudAiDocumentOption = CloudAIDocumentOption.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDocumentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      document: isSet(object.document) ? Document.fromJSON(object.document) : undefined,
      requestMetadata: isSet(object.requestMetadata) ? RequestMetadata.fromJSON(object.requestMetadata) : undefined,
      policy: isSet(object.policy) ? Policy.fromJSON(object.policy) : undefined,
      cloudAiDocumentOption: isSet(object.cloudAiDocumentOption)
        ? CloudAIDocumentOption.fromJSON(object.cloudAiDocumentOption)
        : undefined,
      createMask: isSet(object.createMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.createMask)) : undefined,
    };
  },

  toJSON(message: CreateDocumentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.document !== undefined) {
      obj.document = Document.toJSON(message.document);
    }
    if (message.requestMetadata !== undefined) {
      obj.requestMetadata = RequestMetadata.toJSON(message.requestMetadata);
    }
    if (message.policy !== undefined) {
      obj.policy = Policy.toJSON(message.policy);
    }
    if (message.cloudAiDocumentOption !== undefined) {
      obj.cloudAiDocumentOption = CloudAIDocumentOption.toJSON(message.cloudAiDocumentOption);
    }
    if (message.createMask !== undefined) {
      obj.createMask = FieldMask.toJSON(FieldMask.wrap(message.createMask));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDocumentRequest>): CreateDocumentRequest {
    return CreateDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDocumentRequest>): CreateDocumentRequest {
    const message = createBaseCreateDocumentRequest();
    message.parent = object.parent ?? "";
    message.document = (object.document !== undefined && object.document !== null)
      ? Document.fromPartial(object.document)
      : undefined;
    message.requestMetadata = (object.requestMetadata !== undefined && object.requestMetadata !== null)
      ? RequestMetadata.fromPartial(object.requestMetadata)
      : undefined;
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? Policy.fromPartial(object.policy)
      : undefined;
    message.cloudAiDocumentOption =
      (object.cloudAiDocumentOption !== undefined && object.cloudAiDocumentOption !== null)
        ? CloudAIDocumentOption.fromPartial(object.cloudAiDocumentOption)
        : undefined;
    message.createMask = object.createMask ?? undefined;
    return message;
  },
};

function createBaseGetDocumentRequest(): GetDocumentRequest {
  return { name: "", requestMetadata: undefined };
}

export const GetDocumentRequest: MessageFns<GetDocumentRequest> = {
  encode(message: GetDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestMetadata !== undefined) {
      RequestMetadata.encode(message.requestMetadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestMetadata = RequestMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDocumentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestMetadata: isSet(object.requestMetadata) ? RequestMetadata.fromJSON(object.requestMetadata) : undefined,
    };
  },

  toJSON(message: GetDocumentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestMetadata !== undefined) {
      obj.requestMetadata = RequestMetadata.toJSON(message.requestMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<GetDocumentRequest>): GetDocumentRequest {
    return GetDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDocumentRequest>): GetDocumentRequest {
    const message = createBaseGetDocumentRequest();
    message.name = object.name ?? "";
    message.requestMetadata = (object.requestMetadata !== undefined && object.requestMetadata !== null)
      ? RequestMetadata.fromPartial(object.requestMetadata)
      : undefined;
    return message;
  },
};

function createBaseUpdateDocumentRequest(): UpdateDocumentRequest {
  return {
    name: "",
    document: undefined,
    requestMetadata: undefined,
    cloudAiDocumentOption: undefined,
    updateOptions: undefined,
  };
}

export const UpdateDocumentRequest: MessageFns<UpdateDocumentRequest> = {
  encode(message: UpdateDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.document !== undefined) {
      Document.encode(message.document, writer.uint32(18).fork()).join();
    }
    if (message.requestMetadata !== undefined) {
      RequestMetadata.encode(message.requestMetadata, writer.uint32(26).fork()).join();
    }
    if (message.cloudAiDocumentOption !== undefined) {
      CloudAIDocumentOption.encode(message.cloudAiDocumentOption, writer.uint32(42).fork()).join();
    }
    if (message.updateOptions !== undefined) {
      UpdateOptions.encode(message.updateOptions, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.document = Document.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestMetadata = RequestMetadata.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cloudAiDocumentOption = CloudAIDocumentOption.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateOptions = UpdateOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDocumentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      document: isSet(object.document) ? Document.fromJSON(object.document) : undefined,
      requestMetadata: isSet(object.requestMetadata) ? RequestMetadata.fromJSON(object.requestMetadata) : undefined,
      cloudAiDocumentOption: isSet(object.cloudAiDocumentOption)
        ? CloudAIDocumentOption.fromJSON(object.cloudAiDocumentOption)
        : undefined,
      updateOptions: isSet(object.updateOptions) ? UpdateOptions.fromJSON(object.updateOptions) : undefined,
    };
  },

  toJSON(message: UpdateDocumentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.document !== undefined) {
      obj.document = Document.toJSON(message.document);
    }
    if (message.requestMetadata !== undefined) {
      obj.requestMetadata = RequestMetadata.toJSON(message.requestMetadata);
    }
    if (message.cloudAiDocumentOption !== undefined) {
      obj.cloudAiDocumentOption = CloudAIDocumentOption.toJSON(message.cloudAiDocumentOption);
    }
    if (message.updateOptions !== undefined) {
      obj.updateOptions = UpdateOptions.toJSON(message.updateOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDocumentRequest>): UpdateDocumentRequest {
    return UpdateDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDocumentRequest>): UpdateDocumentRequest {
    const message = createBaseUpdateDocumentRequest();
    message.name = object.name ?? "";
    message.document = (object.document !== undefined && object.document !== null)
      ? Document.fromPartial(object.document)
      : undefined;
    message.requestMetadata = (object.requestMetadata !== undefined && object.requestMetadata !== null)
      ? RequestMetadata.fromPartial(object.requestMetadata)
      : undefined;
    message.cloudAiDocumentOption =
      (object.cloudAiDocumentOption !== undefined && object.cloudAiDocumentOption !== null)
        ? CloudAIDocumentOption.fromPartial(object.cloudAiDocumentOption)
        : undefined;
    message.updateOptions = (object.updateOptions !== undefined && object.updateOptions !== null)
      ? UpdateOptions.fromPartial(object.updateOptions)
      : undefined;
    return message;
  },
};

function createBaseDeleteDocumentRequest(): DeleteDocumentRequest {
  return { name: "", requestMetadata: undefined };
}

export const DeleteDocumentRequest: MessageFns<DeleteDocumentRequest> = {
  encode(message: DeleteDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestMetadata !== undefined) {
      RequestMetadata.encode(message.requestMetadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestMetadata = RequestMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDocumentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestMetadata: isSet(object.requestMetadata) ? RequestMetadata.fromJSON(object.requestMetadata) : undefined,
    };
  },

  toJSON(message: DeleteDocumentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestMetadata !== undefined) {
      obj.requestMetadata = RequestMetadata.toJSON(message.requestMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDocumentRequest>): DeleteDocumentRequest {
    return DeleteDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDocumentRequest>): DeleteDocumentRequest {
    const message = createBaseDeleteDocumentRequest();
    message.name = object.name ?? "";
    message.requestMetadata = (object.requestMetadata !== undefined && object.requestMetadata !== null)
      ? RequestMetadata.fromPartial(object.requestMetadata)
      : undefined;
    return message;
  },
};

function createBaseSearchDocumentsRequest(): SearchDocumentsRequest {
  return {
    parent: "",
    requestMetadata: undefined,
    documentQuery: undefined,
    offset: 0,
    pageSize: 0,
    pageToken: "",
    orderBy: "",
    histogramQueries: [],
    requireTotalSize: false,
    totalResultSize: 0,
    qaSizeLimit: 0,
  };
}

export const SearchDocumentsRequest: MessageFns<SearchDocumentsRequest> = {
  encode(message: SearchDocumentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.requestMetadata !== undefined) {
      RequestMetadata.encode(message.requestMetadata, writer.uint32(26).fork()).join();
    }
    if (message.documentQuery !== undefined) {
      DocumentQuery.encode(message.documentQuery, writer.uint32(34).fork()).join();
    }
    if (message.offset !== 0) {
      writer.uint32(40).int32(message.offset);
    }
    if (message.pageSize !== 0) {
      writer.uint32(48).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(58).string(message.pageToken);
    }
    if (message.orderBy !== "") {
      writer.uint32(66).string(message.orderBy);
    }
    for (const v of message.histogramQueries) {
      HistogramQuery.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.requireTotalSize !== false) {
      writer.uint32(80).bool(message.requireTotalSize);
    }
    if (message.totalResultSize !== 0) {
      writer.uint32(96).int32(message.totalResultSize);
    }
    if (message.qaSizeLimit !== 0) {
      writer.uint32(88).int32(message.qaSizeLimit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchDocumentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchDocumentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestMetadata = RequestMetadata.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.documentQuery = DocumentQuery.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.offset = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.histogramQueries.push(HistogramQuery.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.requireTotalSize = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.totalResultSize = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.qaSizeLimit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchDocumentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      requestMetadata: isSet(object.requestMetadata) ? RequestMetadata.fromJSON(object.requestMetadata) : undefined,
      documentQuery: isSet(object.documentQuery) ? DocumentQuery.fromJSON(object.documentQuery) : undefined,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      histogramQueries: globalThis.Array.isArray(object?.histogramQueries)
        ? object.histogramQueries.map((e: any) => HistogramQuery.fromJSON(e))
        : [],
      requireTotalSize: isSet(object.requireTotalSize) ? globalThis.Boolean(object.requireTotalSize) : false,
      totalResultSize: isSet(object.totalResultSize)
        ? searchDocumentsRequest_TotalResultSizeFromJSON(object.totalResultSize)
        : 0,
      qaSizeLimit: isSet(object.qaSizeLimit) ? globalThis.Number(object.qaSizeLimit) : 0,
    };
  },

  toJSON(message: SearchDocumentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.requestMetadata !== undefined) {
      obj.requestMetadata = RequestMetadata.toJSON(message.requestMetadata);
    }
    if (message.documentQuery !== undefined) {
      obj.documentQuery = DocumentQuery.toJSON(message.documentQuery);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.histogramQueries?.length) {
      obj.histogramQueries = message.histogramQueries.map((e) => HistogramQuery.toJSON(e));
    }
    if (message.requireTotalSize !== false) {
      obj.requireTotalSize = message.requireTotalSize;
    }
    if (message.totalResultSize !== 0) {
      obj.totalResultSize = searchDocumentsRequest_TotalResultSizeToJSON(message.totalResultSize);
    }
    if (message.qaSizeLimit !== 0) {
      obj.qaSizeLimit = Math.round(message.qaSizeLimit);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchDocumentsRequest>): SearchDocumentsRequest {
    return SearchDocumentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchDocumentsRequest>): SearchDocumentsRequest {
    const message = createBaseSearchDocumentsRequest();
    message.parent = object.parent ?? "";
    message.requestMetadata = (object.requestMetadata !== undefined && object.requestMetadata !== null)
      ? RequestMetadata.fromPartial(object.requestMetadata)
      : undefined;
    message.documentQuery = (object.documentQuery !== undefined && object.documentQuery !== null)
      ? DocumentQuery.fromPartial(object.documentQuery)
      : undefined;
    message.offset = object.offset ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.orderBy = object.orderBy ?? "";
    message.histogramQueries = object.histogramQueries?.map((e) => HistogramQuery.fromPartial(e)) || [];
    message.requireTotalSize = object.requireTotalSize ?? false;
    message.totalResultSize = object.totalResultSize ?? 0;
    message.qaSizeLimit = object.qaSizeLimit ?? 0;
    return message;
  },
};

function createBaseLockDocumentRequest(): LockDocumentRequest {
  return { name: "", collectionId: "", lockingUser: undefined };
}

export const LockDocumentRequest: MessageFns<LockDocumentRequest> = {
  encode(message: LockDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.collectionId !== "") {
      writer.uint32(18).string(message.collectionId);
    }
    if (message.lockingUser !== undefined) {
      UserInfo.encode(message.lockingUser, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LockDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.collectionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lockingUser = UserInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LockDocumentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      collectionId: isSet(object.collectionId) ? globalThis.String(object.collectionId) : "",
      lockingUser: isSet(object.lockingUser) ? UserInfo.fromJSON(object.lockingUser) : undefined,
    };
  },

  toJSON(message: LockDocumentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.collectionId !== "") {
      obj.collectionId = message.collectionId;
    }
    if (message.lockingUser !== undefined) {
      obj.lockingUser = UserInfo.toJSON(message.lockingUser);
    }
    return obj;
  },

  create(base?: DeepPartial<LockDocumentRequest>): LockDocumentRequest {
    return LockDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LockDocumentRequest>): LockDocumentRequest {
    const message = createBaseLockDocumentRequest();
    message.name = object.name ?? "";
    message.collectionId = object.collectionId ?? "";
    message.lockingUser = (object.lockingUser !== undefined && object.lockingUser !== null)
      ? UserInfo.fromPartial(object.lockingUser)
      : undefined;
    return message;
  },
};

function createBaseFetchAclRequest(): FetchAclRequest {
  return { resource: "", requestMetadata: undefined, projectOwner: false };
}

export const FetchAclRequest: MessageFns<FetchAclRequest> = {
  encode(message: FetchAclRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    if (message.requestMetadata !== undefined) {
      RequestMetadata.encode(message.requestMetadata, writer.uint32(18).fork()).join();
    }
    if (message.projectOwner !== false) {
      writer.uint32(24).bool(message.projectOwner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchAclRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchAclRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestMetadata = RequestMetadata.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.projectOwner = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchAclRequest {
    return {
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      requestMetadata: isSet(object.requestMetadata) ? RequestMetadata.fromJSON(object.requestMetadata) : undefined,
      projectOwner: isSet(object.projectOwner) ? globalThis.Boolean(object.projectOwner) : false,
    };
  },

  toJSON(message: FetchAclRequest): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.requestMetadata !== undefined) {
      obj.requestMetadata = RequestMetadata.toJSON(message.requestMetadata);
    }
    if (message.projectOwner !== false) {
      obj.projectOwner = message.projectOwner;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchAclRequest>): FetchAclRequest {
    return FetchAclRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchAclRequest>): FetchAclRequest {
    const message = createBaseFetchAclRequest();
    message.resource = object.resource ?? "";
    message.requestMetadata = (object.requestMetadata !== undefined && object.requestMetadata !== null)
      ? RequestMetadata.fromPartial(object.requestMetadata)
      : undefined;
    message.projectOwner = object.projectOwner ?? false;
    return message;
  },
};

function createBaseSetAclRequest(): SetAclRequest {
  return { resource: "", policy: undefined, requestMetadata: undefined, projectOwner: false };
}

export const SetAclRequest: MessageFns<SetAclRequest> = {
  encode(message: SetAclRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    if (message.policy !== undefined) {
      Policy.encode(message.policy, writer.uint32(18).fork()).join();
    }
    if (message.requestMetadata !== undefined) {
      RequestMetadata.encode(message.requestMetadata, writer.uint32(26).fork()).join();
    }
    if (message.projectOwner !== false) {
      writer.uint32(32).bool(message.projectOwner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetAclRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetAclRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.policy = Policy.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestMetadata = RequestMetadata.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.projectOwner = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetAclRequest {
    return {
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      policy: isSet(object.policy) ? Policy.fromJSON(object.policy) : undefined,
      requestMetadata: isSet(object.requestMetadata) ? RequestMetadata.fromJSON(object.requestMetadata) : undefined,
      projectOwner: isSet(object.projectOwner) ? globalThis.Boolean(object.projectOwner) : false,
    };
  },

  toJSON(message: SetAclRequest): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.policy !== undefined) {
      obj.policy = Policy.toJSON(message.policy);
    }
    if (message.requestMetadata !== undefined) {
      obj.requestMetadata = RequestMetadata.toJSON(message.requestMetadata);
    }
    if (message.projectOwner !== false) {
      obj.projectOwner = message.projectOwner;
    }
    return obj;
  },

  create(base?: DeepPartial<SetAclRequest>): SetAclRequest {
    return SetAclRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetAclRequest>): SetAclRequest {
    const message = createBaseSetAclRequest();
    message.resource = object.resource ?? "";
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? Policy.fromPartial(object.policy)
      : undefined;
    message.requestMetadata = (object.requestMetadata !== undefined && object.requestMetadata !== null)
      ? RequestMetadata.fromPartial(object.requestMetadata)
      : undefined;
    message.projectOwner = object.projectOwner ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
