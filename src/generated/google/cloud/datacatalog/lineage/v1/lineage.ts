// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/datacatalog/lineage/v1/lineage.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../../longrunning/operations.js";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { Struct, Value } from "../../../../protobuf/struct.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.datacatalog.lineage.v1";

/** A process is the definition of a data transformation operation. */
export interface Process {
  /**
   * Immutable. The resource name of the lineage process. Format:
   * `projects/{project}/locations/{location}/processes/{process}`.
   * Can be specified or auto-assigned.
   * {process} must be not longer than 200 characters and only
   * contain characters in a set: `a-zA-Z0-9_-:.`
   */
  name: string;
  /**
   * Optional. A human-readable name you can set to display in a user interface.
   * Must be not longer than 200 characters and only contain UTF-8 letters
   * or numbers, spaces or characters like `_-:&.`
   */
  displayName: string;
  /**
   * Optional. The attributes of the process. Should only be used for the
   * purpose of non-semantic management (classifying, describing or labeling the
   * process).
   *
   * Up to 100 attributes are allowed.
   */
  attributes: { [key: string]: any | undefined };
  /** Optional. The origin of this process and its runs and lineage events. */
  origin: Origin | undefined;
}

export interface Process_AttributesEntry {
  key: string;
  value: any | undefined;
}

/**
 * A lineage run represents an execution of a process that creates
 * lineage events.
 */
export interface Run {
  /**
   * Immutable. The resource name of the run. Format:
   * `projects/{project}/locations/{location}/processes/{process}/runs/{run}`.
   * Can be specified or auto-assigned.
   * {run} must be not longer than 200 characters and only
   * contain characters in a set: `a-zA-Z0-9_-:.`
   */
  name: string;
  /**
   * Optional. A human-readable name you can set to display in a user interface.
   * Must be not longer than 1024 characters and only contain UTF-8 letters
   * or numbers, spaces or characters like `_-:&.`
   */
  displayName: string;
  /**
   * Optional. The attributes of the run. Should only be used for the purpose of
   * non-semantic management (classifying, describing or labeling the run).
   *
   * Up to 100 attributes are allowed.
   */
  attributes: { [key: string]: any | undefined };
  /** Required. The timestamp of the start of the run. */
  startTime:
    | Date
    | undefined;
  /** Optional. The timestamp of the end of the run. */
  endTime:
    | Date
    | undefined;
  /** Required. The state of the run. */
  state: Run_State;
}

/** The current state of the run. */
export enum Run_State {
  /**
   * UNKNOWN - The state is unknown. The true state may be any of the below or a
   * different state that is not supported here explicitly.
   */
  UNKNOWN = 0,
  /** STARTED - The run is still executing. */
  STARTED = 1,
  /** COMPLETED - The run completed. */
  COMPLETED = 2,
  /** FAILED - The run failed. */
  FAILED = 3,
  /** ABORTED - The run aborted. */
  ABORTED = 4,
  UNRECOGNIZED = -1,
}

export function run_StateFromJSON(object: any): Run_State {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Run_State.UNKNOWN;
    case 1:
    case "STARTED":
      return Run_State.STARTED;
    case 2:
    case "COMPLETED":
      return Run_State.COMPLETED;
    case 3:
    case "FAILED":
      return Run_State.FAILED;
    case 4:
    case "ABORTED":
      return Run_State.ABORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Run_State.UNRECOGNIZED;
  }
}

export function run_StateToJSON(object: Run_State): string {
  switch (object) {
    case Run_State.UNKNOWN:
      return "UNKNOWN";
    case Run_State.STARTED:
      return "STARTED";
    case Run_State.COMPLETED:
      return "COMPLETED";
    case Run_State.FAILED:
      return "FAILED";
    case Run_State.ABORTED:
      return "ABORTED";
    case Run_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Run_AttributesEntry {
  key: string;
  value: any | undefined;
}

/**
 * A lineage event represents an operation on assets. Within the operation, the
 * data flows from the source to the target defined in the links field.
 */
export interface LineageEvent {
  /**
   * Immutable. The resource name of the lineage event.
   * Format:
   * `projects/{project}/locations/{location}/processes/{process}/runs/{run}/lineageEvents/{lineage_event}`.
   * Can be specified or auto-assigned.
   * {lineage_event} must be not longer than 200 characters and only
   * contain characters in a set: `a-zA-Z0-9_-:.`
   */
  name: string;
  /** Optional. List of source-target pairs. Can't contain more than 100 tuples. */
  links: EventLink[];
  /**
   * Required. The beginning of the transformation which resulted in this
   * lineage event. For streaming scenarios, it should be the beginning of the
   * period from which the lineage is being reported.
   */
  startTime:
    | Date
    | undefined;
  /**
   * Optional. The end of the transformation which resulted in this lineage
   * event.  For streaming scenarios, it should be the end of the period from
   * which the lineage is being reported.
   */
  endTime: Date | undefined;
}

/** A lineage between source and target entities. */
export interface EventLink {
  /** Required. Reference to the source entity */
  source:
    | EntityReference
    | undefined;
  /** Required. Reference to the target entity */
  target: EntityReference | undefined;
}

/** The soft reference to everything you can attach a lineage event to. */
export interface EntityReference {
  /**
   * Required. [Fully Qualified Name
   * (FQN)](https://cloud.google.com/data-catalog/docs/fully-qualified-names)
   * of the entity.
   */
  fullyQualifiedName: string;
}

/** Metadata describing the operation. */
export interface OperationMetadata {
  /** Output only. The current operation state. */
  state: OperationMetadata_State;
  /** Output only. The type of the operation being performed. */
  operationType: OperationMetadata_Type;
  /**
   * Output only. The [relative name]
   * (https://cloud.google.com//apis/design/resource_names#relative_resource_name)
   * of the resource being operated on.
   */
  resource: string;
  /** Output only. The UUID of the resource being operated on. */
  resourceUuid: string;
  /** Output only. The timestamp of the operation submission to the server. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The timestamp of the operation termination, regardless of its
   * success. This field is unset if the operation is still ongoing.
   */
  endTime: Date | undefined;
}

/** An enum with the state of the operation. */
export enum OperationMetadata_State {
  /** STATE_UNSPECIFIED - Unused. */
  STATE_UNSPECIFIED = 0,
  /** PENDING - The operation has been created but is not yet started. */
  PENDING = 1,
  /** RUNNING - The operation is underway. */
  RUNNING = 2,
  /** SUCCEEDED - The operation completed successfully. */
  SUCCEEDED = 3,
  /** FAILED - The operation is no longer running and did not succeed. */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function operationMetadata_StateFromJSON(object: any): OperationMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return OperationMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return OperationMetadata_State.PENDING;
    case 2:
    case "RUNNING":
      return OperationMetadata_State.RUNNING;
    case 3:
    case "SUCCEEDED":
      return OperationMetadata_State.SUCCEEDED;
    case 4:
    case "FAILED":
      return OperationMetadata_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperationMetadata_State.UNRECOGNIZED;
  }
}

export function operationMetadata_StateToJSON(object: OperationMetadata_State): string {
  switch (object) {
    case OperationMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case OperationMetadata_State.PENDING:
      return "PENDING";
    case OperationMetadata_State.RUNNING:
      return "RUNNING";
    case OperationMetadata_State.SUCCEEDED:
      return "SUCCEEDED";
    case OperationMetadata_State.FAILED:
      return "FAILED";
    case OperationMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of the long running operation. */
export enum OperationMetadata_Type {
  /** TYPE_UNSPECIFIED - Unused. */
  TYPE_UNSPECIFIED = 0,
  /** DELETE - The resource deletion operation. */
  DELETE = 1,
  /** CREATE - The resource creation operation. */
  CREATE = 2,
  UNRECOGNIZED = -1,
}

export function operationMetadata_TypeFromJSON(object: any): OperationMetadata_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return OperationMetadata_Type.TYPE_UNSPECIFIED;
    case 1:
    case "DELETE":
      return OperationMetadata_Type.DELETE;
    case 2:
    case "CREATE":
      return OperationMetadata_Type.CREATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperationMetadata_Type.UNRECOGNIZED;
  }
}

export function operationMetadata_TypeToJSON(object: OperationMetadata_Type): string {
  switch (object) {
    case OperationMetadata_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case OperationMetadata_Type.DELETE:
      return "DELETE";
    case OperationMetadata_Type.CREATE:
      return "CREATE";
    case OperationMetadata_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Request message for
 * [ProcessOpenLineageRunEvent][google.cloud.datacatalog.lineage.v1.ProcessOpenLineageRunEvent].
 */
export interface ProcessOpenLineageRunEventRequest {
  /**
   * Required. The name of the project and its location that should own the
   * process, run, and lineage event.
   */
  parent: string;
  /**
   * Required. OpenLineage message following OpenLineage format:
   * https://github.com/OpenLineage/OpenLineage/blob/main/spec/OpenLineage.json
   */
  openLineage:
    | { [key: string]: any }
    | undefined;
  /**
   * A unique identifier for this request. Restricted to 36 ASCII characters.
   * A random UUID is recommended. This request is idempotent only if a
   * `request_id` is provided.
   */
  requestId: string;
}

/**
 * Response message for
 * [ProcessOpenLineageRunEvent][google.cloud.datacatalog.lineage.v1.ProcessOpenLineageRunEvent].
 */
export interface ProcessOpenLineageRunEventResponse {
  /**
   * Created process name.
   * Format: `projects/{project}/locations/{location}/processes/{process}`.
   */
  process: string;
  /**
   * Created run name.
   * Format:
   * `projects/{project}/locations/{location}/processes/{process}/runs/{run}`.
   */
  run: string;
  /**
   * Created lineage event names.
   * Format:
   * `projects/{project}/locations/{location}/processes/{process}/runs/{run}/lineageEvents/{lineage_event}`.
   */
  lineageEvents: string[];
}

/**
 * Request message for
 * [CreateProcess][google.cloud.datacatalog.lineage.v1.CreateProcess].
 */
export interface CreateProcessRequest {
  /**
   * Required. The name of the project and its location that should own the
   * process.
   */
  parent: string;
  /** Required. The process to create. */
  process:
    | Process
    | undefined;
  /**
   * A unique identifier for this request. Restricted to 36 ASCII characters.
   * A random UUID is recommended. This request is idempotent only if a
   * `request_id` is provided.
   */
  requestId: string;
}

/**
 * Request message for
 * [UpdateProcess][google.cloud.datacatalog.lineage.v1.UpdateProcess].
 */
export interface UpdateProcessRequest {
  /**
   * Required. The lineage process to update.
   *
   * The process's `name` field is used to identify the process to update.
   */
  process:
    | Process
    | undefined;
  /**
   * The list of fields to update. Currently not used. The whole message is
   * updated.
   */
  updateMask:
    | string[]
    | undefined;
  /** If set to true and the process is not found, the request inserts it. */
  allowMissing: boolean;
}

/**
 * Request message for
 * [GetProcess][google.cloud.datacatalog.lineage.v1.GetProcess].
 */
export interface GetProcessRequest {
  /** Required. The name of the process to get. */
  name: string;
}

/**
 * Request message for
 * [ListProcesses][google.cloud.datacatalog.lineage.v1.ListProcesses].
 */
export interface ListProcessesRequest {
  /**
   * Required. The name of the project and its location that owns this
   * collection of processes.
   */
  parent: string;
  /**
   * The maximum number of processes to return. The service may return
   * fewer than this value. If unspecified, at most 50 processes are
   * returned. The maximum value is 100; values greater than 100 are cut to
   * 100.
   */
  pageSize: number;
  /**
   * The page token received from a previous `ListProcesses` call. Specify
   * it to get the next page.
   *
   * When paginating, all other parameters specified in this call must
   * match the parameters of the call that provided the page token.
   */
  pageToken: string;
}

/**
 * Response message for
 * [ListProcesses][google.cloud.datacatalog.lineage.v1.ListProcesses].
 */
export interface ListProcessesResponse {
  /** The processes from the specified project and location. */
  processes: Process[];
  /**
   * The token to specify as `page_token` in the next call to get the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [DeleteProcess][google.cloud.datacatalog.lineage.v1.DeleteProcess].
 */
export interface DeleteProcessRequest {
  /** Required. The name of the process to delete. */
  name: string;
  /**
   * If set to true and the process is not found, the request
   * succeeds but the server doesn't perform any actions.
   */
  allowMissing: boolean;
}

/**
 * Request message for
 * [CreateRun][google.cloud.datacatalog.lineage.v1.CreateRun].
 */
export interface CreateRunRequest {
  /** Required. The name of the process that should own the run. */
  parent: string;
  /** Required. The run to create. */
  run:
    | Run
    | undefined;
  /**
   * A unique identifier for this request. Restricted to 36 ASCII characters.
   * A random UUID is recommended. This request is idempotent only if a
   * `request_id` is provided.
   */
  requestId: string;
}

/**
 * Request message for
 * [UpdateRun][google.cloud.datacatalog.lineage.v1.UpdateRun].
 */
export interface UpdateRunRequest {
  /**
   * Required. The lineage run to update.
   *
   * The run's `name` field is used to identify the run to update.
   *
   * Format:
   * `projects/{project}/locations/{location}/processes/{process}/runs/{run}`.
   */
  run:
    | Run
    | undefined;
  /**
   * The list of fields to update. Currently not used. The whole message is
   * updated.
   */
  updateMask:
    | string[]
    | undefined;
  /** If set to true and the run is not found, the request creates it. */
  allowMissing: boolean;
}

/**
 * Request message for
 * [GetRun][google.cloud.datacatalog.lineage.v1.GetRun].
 */
export interface GetRunRequest {
  /** Required. The name of the run to get. */
  name: string;
}

/**
 * Request message for
 * [ListRuns][google.cloud.datacatalog.lineage.v1.ListRuns].
 */
export interface ListRunsRequest {
  /** Required. The name of process that owns this collection of runs. */
  parent: string;
  /**
   * The maximum number of runs to return. The service may return
   * fewer than this value. If unspecified, at most 50 runs are
   * returned. The maximum value is 100; values greater than 100 are cut to
   * 100.
   */
  pageSize: number;
  /**
   * The page token received from a previous `ListRuns` call. Specify
   * it to get the next page.
   *
   * When paginating, all other parameters specified in this call must
   * match the parameters of the call that provided the page token.
   */
  pageToken: string;
}

/**
 * Response message for
 * [ListRuns][google.cloud.datacatalog.lineage.v1.ListRuns].
 */
export interface ListRunsResponse {
  /** The runs from the specified project and location. */
  runs: Run[];
  /**
   * The token to specify as `page_token` in the next call to get the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [DeleteRun][google.cloud.datacatalog.lineage.v1.DeleteRun].
 */
export interface DeleteRunRequest {
  /** Required. The name of the run to delete. */
  name: string;
  /**
   * If set to true and the run is not found, the request
   * succeeds but the server doesn't perform any actions.
   */
  allowMissing: boolean;
}

/**
 * Request message for
 * [CreateLineageEvent][google.cloud.datacatalog.lineage.v1.CreateLineageEvent].
 */
export interface CreateLineageEventRequest {
  /** Required. The name of the run that should own the lineage event. */
  parent: string;
  /** Required. The lineage event to create. */
  lineageEvent:
    | LineageEvent
    | undefined;
  /**
   * A unique identifier for this request. Restricted to 36 ASCII characters.
   * A random UUID is recommended. This request is idempotent only if a
   * `request_id` is provided.
   */
  requestId: string;
}

/**
 * Request message for
 * [GetLineageEvent][google.cloud.datacatalog.lineage.v1.GetLineageEvent].
 */
export interface GetLineageEventRequest {
  /** Required. The name of the lineage event to get. */
  name: string;
}

/**
 * Request message for
 * [ListLineageEvents][google.cloud.datacatalog.lineage.v1.ListLineageEvents].
 */
export interface ListLineageEventsRequest {
  /**
   * Required. The name of the run that owns the collection of lineage events to
   * get.
   */
  parent: string;
  /**
   * The maximum number of lineage events to return.
   *
   * The service may return fewer events than this value.
   * If unspecified, at most 50 events are returned. The maximum value is 100;
   * values greater than 100 are cut to 100.
   */
  pageSize: number;
  /**
   * The page token received from a previous `ListLineageEvents` call. Specify
   * it to get the next page.
   *
   * When paginating, all other parameters specified in this call must
   * match the parameters of the call that provided the page token.
   */
  pageToken: string;
}

/**
 * Response message for
 * [ListLineageEvents][google.cloud.datacatalog.lineage.v1.ListLineageEvents].
 */
export interface ListLineageEventsResponse {
  /** Lineage events from the specified project and location. */
  lineageEvents: LineageEvent[];
  /**
   * The token to specify as `page_token` in the next call to get the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [DeleteLineageEvent][google.cloud.datacatalog.lineage.v1.DeleteLineageEvent].
 */
export interface DeleteLineageEventRequest {
  /** Required. The name of the lineage event to delete. */
  name: string;
  /**
   * If set to true and the lineage event is not found, the request
   * succeeds but the server doesn't perform any actions.
   */
  allowMissing: boolean;
}

/**
 * Request message for
 * [SearchLinks][google.cloud.datacatalog.lineage.v1.Lineage.SearchLinks].
 */
export interface SearchLinksRequest {
  /** Required. The project and location you want search in. */
  parent: string;
  /**
   * Optional. Send asset information in the **source** field to retrieve all
   * links that lead from the specified asset to downstream assets.
   */
  source?:
    | EntityReference
    | undefined;
  /**
   * Optional. Send asset information in the **target** field to retrieve all
   * links that lead from upstream assets to the specified asset.
   */
  target?:
    | EntityReference
    | undefined;
  /**
   * Optional. The maximum number of links to return in a single page of the
   * response. A page may contain fewer links than this value. If unspecified,
   * at most 10 links are returned.
   *
   * Maximum value is 100; values greater than 100 are reduced to 100.
   */
  pageSize: number;
  /**
   * Optional. The page token received from a previous `SearchLinksRequest`
   * call. Use it to get the next page.
   *
   * When requesting subsequent pages of a response, remember that
   * all parameters must match the values you provided
   * in the original request.
   */
  pageToken: string;
}

/**
 * Response message for
 * [SearchLinks][google.cloud.datacatalog.lineage.v1.Lineage.SearchLinks].
 */
export interface SearchLinksResponse {
  /**
   * The list of links for a given asset. Can be empty if the asset has no
   * relations of requested type (source or target).
   */
  links: Link[];
  /**
   * The token to specify as `page_token` in the subsequent call to get the next
   * page. Omitted if there are no more pages in the response.
   */
  nextPageToken: string;
}

/**
 * Links represent the data flow between **source** (upstream)
 * and **target** (downstream) assets in transformation pipelines.
 *
 * Links are created when LineageEvents record data transformation between
 * related assets.
 */
export interface Link {
  /**
   * Output only. Immutable. The name of the link. Format:
   * `projects/{project}/locations/{location}/links/{link}`.
   */
  name: string;
  /** The pointer to the entity that is the **source** of this link. */
  source:
    | EntityReference
    | undefined;
  /** The pointer to the entity that is the **target** of this link. */
  target:
    | EntityReference
    | undefined;
  /** The start of the first event establishing this link. */
  startTime:
    | Date
    | undefined;
  /** The end of the last event establishing this link. */
  endTime: Date | undefined;
}

/**
 * Request message for
 * [BatchSearchLinkProcesses][google.cloud.datacatalog.lineage.v1.Lineage.BatchSearchLinkProcesses].
 */
export interface BatchSearchLinkProcessesRequest {
  /** Required. The project and location where you want to search. */
  parent: string;
  /**
   * Required. An array of links to check for their associated LineageProcesses.
   *
   * The maximum number of items in this array is 100.
   * If the request contains more than 100 links, it returns the
   * `INVALID_ARGUMENT` error.
   *
   * Format: `projects/{project}/locations/{location}/links/{link}`.
   */
  links: string[];
  /**
   * The maximum number of processes to return in a single page of the response.
   * A page may contain fewer results than this value.
   */
  pageSize: number;
  /**
   * The page token received from a previous `BatchSearchLinkProcesses` call.
   * Use it to get the next page.
   *
   * When requesting subsequent pages of a response, remember that
   * all parameters must match the values you provided
   * in the original request.
   */
  pageToken: string;
}

/**
 * Response message for
 * [BatchSearchLinkProcesses][google.cloud.datacatalog.lineage.v1.Lineage.BatchSearchLinkProcesses].
 */
export interface BatchSearchLinkProcessesResponse {
  /** An array of processes associated with the specified links. */
  processLinks: ProcessLinks[];
  /**
   * The token to specify as `page_token` in the subsequent call to get the next
   * page. Omitted if there are no more pages in the response.
   */
  nextPageToken: string;
}

/** Links associated with a specific process. */
export interface ProcessLinks {
  /**
   * The process name in the format of
   * `projects/{project}/locations/{location}/processes/{process}`.
   */
  process: string;
  /**
   * An array containing link details objects of the links provided in
   * the original request.
   *
   * A single process can result in creating multiple links.
   * If any of the links you provide in the request are created by
   * the same process, they all are included in this array.
   */
  links: ProcessLinkInfo[];
}

/** Link details. */
export interface ProcessLinkInfo {
  /**
   * The name of the link in the format of
   * `projects/{project}/locations/{location}/links/{link}`.
   */
  link: string;
  /** The start of the first event establishing this link-process tuple. */
  startTime:
    | Date
    | undefined;
  /** The end of the last event establishing this link-process tuple. */
  endTime: Date | undefined;
}

/** Origin of a process. */
export interface Origin {
  /**
   * Type of the source.
   *
   * Use of a source_type other than `CUSTOM` for process creation
   * or updating is highly discouraged, and may be restricted in the future
   * without notice.
   */
  sourceType: Origin_SourceType;
  /**
   * If the source_type isn't CUSTOM, the value of this field should be a GCP
   * resource name of the system, which reports lineage. The project and
   * location parts of the resource name must match the project and location of
   * the lineage resource being created. Examples:
   *
   * - `{source_type: COMPOSER, name:
   *   "projects/foo/locations/us/environments/bar"}`
   * - `{source_type: BIGQUERY, name: "projects/foo/locations/eu"}`
   * - `{source_type: CUSTOM,   name: "myCustomIntegration"}`
   */
  name: string;
}

/** Type of the source of a process. */
export enum Origin_SourceType {
  /** SOURCE_TYPE_UNSPECIFIED - Source is Unspecified */
  SOURCE_TYPE_UNSPECIFIED = 0,
  /** CUSTOM - A custom source */
  CUSTOM = 1,
  /** BIGQUERY - BigQuery */
  BIGQUERY = 2,
  /** DATA_FUSION - Data Fusion */
  DATA_FUSION = 3,
  /** COMPOSER - Composer */
  COMPOSER = 4,
  /** LOOKER_STUDIO - Looker Studio */
  LOOKER_STUDIO = 5,
  /** DATAPROC - Dataproc */
  DATAPROC = 6,
  UNRECOGNIZED = -1,
}

export function origin_SourceTypeFromJSON(object: any): Origin_SourceType {
  switch (object) {
    case 0:
    case "SOURCE_TYPE_UNSPECIFIED":
      return Origin_SourceType.SOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "CUSTOM":
      return Origin_SourceType.CUSTOM;
    case 2:
    case "BIGQUERY":
      return Origin_SourceType.BIGQUERY;
    case 3:
    case "DATA_FUSION":
      return Origin_SourceType.DATA_FUSION;
    case 4:
    case "COMPOSER":
      return Origin_SourceType.COMPOSER;
    case 5:
    case "LOOKER_STUDIO":
      return Origin_SourceType.LOOKER_STUDIO;
    case 6:
    case "DATAPROC":
      return Origin_SourceType.DATAPROC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Origin_SourceType.UNRECOGNIZED;
  }
}

export function origin_SourceTypeToJSON(object: Origin_SourceType): string {
  switch (object) {
    case Origin_SourceType.SOURCE_TYPE_UNSPECIFIED:
      return "SOURCE_TYPE_UNSPECIFIED";
    case Origin_SourceType.CUSTOM:
      return "CUSTOM";
    case Origin_SourceType.BIGQUERY:
      return "BIGQUERY";
    case Origin_SourceType.DATA_FUSION:
      return "DATA_FUSION";
    case Origin_SourceType.COMPOSER:
      return "COMPOSER";
    case Origin_SourceType.LOOKER_STUDIO:
      return "LOOKER_STUDIO";
    case Origin_SourceType.DATAPROC:
      return "DATAPROC";
    case Origin_SourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseProcess(): Process {
  return { name: "", displayName: "", attributes: {}, origin: undefined };
}

export const Process: MessageFns<Process> = {
  encode(message: Process, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      if (value !== undefined) {
        Process_AttributesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
      }
    });
    if (message.origin !== undefined) {
      Origin.encode(message.origin, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Process {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Process_AttributesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.attributes[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.origin = Origin.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Process {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      origin: isSet(object.origin) ? Origin.fromJSON(object.origin) : undefined,
    };
  },

  toJSON(message: Process): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.origin !== undefined) {
      obj.origin = Origin.toJSON(message.origin);
    }
    return obj;
  },

  create(base?: DeepPartial<Process>): Process {
    return Process.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Process>): Process {
    const message = createBaseProcess();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: any | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.origin = (object.origin !== undefined && object.origin !== null)
      ? Origin.fromPartial(object.origin)
      : undefined;
    return message;
  },
};

function createBaseProcess_AttributesEntry(): Process_AttributesEntry {
  return { key: "", value: undefined };
}

export const Process_AttributesEntry: MessageFns<Process_AttributesEntry> = {
  encode(message: Process_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Process_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcess_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Process_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: Process_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Process_AttributesEntry>): Process_AttributesEntry {
    return Process_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Process_AttributesEntry>): Process_AttributesEntry {
    const message = createBaseProcess_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseRun(): Run {
  return { name: "", displayName: "", attributes: {}, startTime: undefined, endTime: undefined, state: 0 };
}

export const Run: MessageFns<Run> = {
  encode(message: Run, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      if (value !== undefined) {
        Run_AttributesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
      }
    });
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Run {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Run_AttributesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.attributes[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Run {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      state: isSet(object.state) ? run_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: Run): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = run_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<Run>): Run {
    return Run.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Run>): Run {
    const message = createBaseRun();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: any | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseRun_AttributesEntry(): Run_AttributesEntry {
  return { key: "", value: undefined };
}

export const Run_AttributesEntry: MessageFns<Run_AttributesEntry> = {
  encode(message: Run_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Run_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRun_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Run_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: Run_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Run_AttributesEntry>): Run_AttributesEntry {
    return Run_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Run_AttributesEntry>): Run_AttributesEntry {
    const message = createBaseRun_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseLineageEvent(): LineageEvent {
  return { name: "", links: [], startTime: undefined, endTime: undefined };
}

export const LineageEvent: MessageFns<LineageEvent> = {
  encode(message: LineageEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.links) {
      EventLink.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(50).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LineageEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineageEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.links.push(EventLink.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineageEvent {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      links: globalThis.Array.isArray(object?.links) ? object.links.map((e: any) => EventLink.fromJSON(e)) : [],
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: LineageEvent): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.links?.length) {
      obj.links = message.links.map((e) => EventLink.toJSON(e));
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<LineageEvent>): LineageEvent {
    return LineageEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LineageEvent>): LineageEvent {
    const message = createBaseLineageEvent();
    message.name = object.name ?? "";
    message.links = object.links?.map((e) => EventLink.fromPartial(e)) || [];
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseEventLink(): EventLink {
  return { source: undefined, target: undefined };
}

export const EventLink: MessageFns<EventLink> = {
  encode(message: EventLink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      EntityReference.encode(message.source, writer.uint32(10).fork()).join();
    }
    if (message.target !== undefined) {
      EntityReference.encode(message.target, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventLink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = EntityReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.target = EntityReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventLink {
    return {
      source: isSet(object.source) ? EntityReference.fromJSON(object.source) : undefined,
      target: isSet(object.target) ? EntityReference.fromJSON(object.target) : undefined,
    };
  },

  toJSON(message: EventLink): unknown {
    const obj: any = {};
    if (message.source !== undefined) {
      obj.source = EntityReference.toJSON(message.source);
    }
    if (message.target !== undefined) {
      obj.target = EntityReference.toJSON(message.target);
    }
    return obj;
  },

  create(base?: DeepPartial<EventLink>): EventLink {
    return EventLink.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventLink>): EventLink {
    const message = createBaseEventLink();
    message.source = (object.source !== undefined && object.source !== null)
      ? EntityReference.fromPartial(object.source)
      : undefined;
    message.target = (object.target !== undefined && object.target !== null)
      ? EntityReference.fromPartial(object.target)
      : undefined;
    return message;
  },
};

function createBaseEntityReference(): EntityReference {
  return { fullyQualifiedName: "" };
}

export const EntityReference: MessageFns<EntityReference> = {
  encode(message: EntityReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fullyQualifiedName !== "") {
      writer.uint32(10).string(message.fullyQualifiedName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fullyQualifiedName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityReference {
    return { fullyQualifiedName: isSet(object.fullyQualifiedName) ? globalThis.String(object.fullyQualifiedName) : "" };
  },

  toJSON(message: EntityReference): unknown {
    const obj: any = {};
    if (message.fullyQualifiedName !== "") {
      obj.fullyQualifiedName = message.fullyQualifiedName;
    }
    return obj;
  },

  create(base?: DeepPartial<EntityReference>): EntityReference {
    return EntityReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityReference>): EntityReference {
    const message = createBaseEntityReference();
    message.fullyQualifiedName = object.fullyQualifiedName ?? "";
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return { state: 0, operationType: 0, resource: "", resourceUuid: "", createTime: undefined, endTime: undefined };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.operationType !== 0) {
      writer.uint32(16).int32(message.operationType);
    }
    if (message.resource !== "") {
      writer.uint32(26).string(message.resource);
    }
    if (message.resourceUuid !== "") {
      writer.uint32(34).string(message.resourceUuid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.operationType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resourceUuid = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      state: isSet(object.state) ? operationMetadata_StateFromJSON(object.state) : 0,
      operationType: isSet(object.operationType) ? operationMetadata_TypeFromJSON(object.operationType) : 0,
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      resourceUuid: isSet(object.resourceUuid) ? globalThis.String(object.resourceUuid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = operationMetadata_StateToJSON(message.state);
    }
    if (message.operationType !== 0) {
      obj.operationType = operationMetadata_TypeToJSON(message.operationType);
    }
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.resourceUuid !== "") {
      obj.resourceUuid = message.resourceUuid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.state = object.state ?? 0;
    message.operationType = object.operationType ?? 0;
    message.resource = object.resource ?? "";
    message.resourceUuid = object.resourceUuid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseProcessOpenLineageRunEventRequest(): ProcessOpenLineageRunEventRequest {
  return { parent: "", openLineage: undefined, requestId: "" };
}

export const ProcessOpenLineageRunEventRequest: MessageFns<ProcessOpenLineageRunEventRequest> = {
  encode(message: ProcessOpenLineageRunEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.openLineage !== undefined) {
      Struct.encode(Struct.wrap(message.openLineage), writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessOpenLineageRunEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessOpenLineageRunEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.openLineage = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessOpenLineageRunEventRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      openLineage: isObject(object.openLineage) ? object.openLineage : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: ProcessOpenLineageRunEventRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.openLineage !== undefined) {
      obj.openLineage = message.openLineage;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessOpenLineageRunEventRequest>): ProcessOpenLineageRunEventRequest {
    return ProcessOpenLineageRunEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessOpenLineageRunEventRequest>): ProcessOpenLineageRunEventRequest {
    const message = createBaseProcessOpenLineageRunEventRequest();
    message.parent = object.parent ?? "";
    message.openLineage = object.openLineage ?? undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseProcessOpenLineageRunEventResponse(): ProcessOpenLineageRunEventResponse {
  return { process: "", run: "", lineageEvents: [] };
}

export const ProcessOpenLineageRunEventResponse: MessageFns<ProcessOpenLineageRunEventResponse> = {
  encode(message: ProcessOpenLineageRunEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.process !== "") {
      writer.uint32(10).string(message.process);
    }
    if (message.run !== "") {
      writer.uint32(18).string(message.run);
    }
    for (const v of message.lineageEvents) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessOpenLineageRunEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessOpenLineageRunEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.process = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.run = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lineageEvents.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessOpenLineageRunEventResponse {
    return {
      process: isSet(object.process) ? globalThis.String(object.process) : "",
      run: isSet(object.run) ? globalThis.String(object.run) : "",
      lineageEvents: globalThis.Array.isArray(object?.lineageEvents)
        ? object.lineageEvents.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ProcessOpenLineageRunEventResponse): unknown {
    const obj: any = {};
    if (message.process !== "") {
      obj.process = message.process;
    }
    if (message.run !== "") {
      obj.run = message.run;
    }
    if (message.lineageEvents?.length) {
      obj.lineageEvents = message.lineageEvents;
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessOpenLineageRunEventResponse>): ProcessOpenLineageRunEventResponse {
    return ProcessOpenLineageRunEventResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessOpenLineageRunEventResponse>): ProcessOpenLineageRunEventResponse {
    const message = createBaseProcessOpenLineageRunEventResponse();
    message.process = object.process ?? "";
    message.run = object.run ?? "";
    message.lineageEvents = object.lineageEvents?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateProcessRequest(): CreateProcessRequest {
  return { parent: "", process: undefined, requestId: "" };
}

export const CreateProcessRequest: MessageFns<CreateProcessRequest> = {
  encode(message: CreateProcessRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.process !== undefined) {
      Process.encode(message.process, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProcessRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProcessRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.process = Process.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProcessRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      process: isSet(object.process) ? Process.fromJSON(object.process) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateProcessRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.process !== undefined) {
      obj.process = Process.toJSON(message.process);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateProcessRequest>): CreateProcessRequest {
    return CreateProcessRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateProcessRequest>): CreateProcessRequest {
    const message = createBaseCreateProcessRequest();
    message.parent = object.parent ?? "";
    message.process = (object.process !== undefined && object.process !== null)
      ? Process.fromPartial(object.process)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateProcessRequest(): UpdateProcessRequest {
  return { process: undefined, updateMask: undefined, allowMissing: false };
}

export const UpdateProcessRequest: MessageFns<UpdateProcessRequest> = {
  encode(message: UpdateProcessRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.process !== undefined) {
      Process.encode(message.process, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProcessRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProcessRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.process = Process.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProcessRequest {
    return {
      process: isSet(object.process) ? Process.fromJSON(object.process) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: UpdateProcessRequest): unknown {
    const obj: any = {};
    if (message.process !== undefined) {
      obj.process = Process.toJSON(message.process);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateProcessRequest>): UpdateProcessRequest {
    return UpdateProcessRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateProcessRequest>): UpdateProcessRequest {
    const message = createBaseUpdateProcessRequest();
    message.process = (object.process !== undefined && object.process !== null)
      ? Process.fromPartial(object.process)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseGetProcessRequest(): GetProcessRequest {
  return { name: "" };
}

export const GetProcessRequest: MessageFns<GetProcessRequest> = {
  encode(message: GetProcessRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProcessRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProcessRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProcessRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetProcessRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetProcessRequest>): GetProcessRequest {
    return GetProcessRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetProcessRequest>): GetProcessRequest {
    const message = createBaseGetProcessRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListProcessesRequest(): ListProcessesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListProcessesRequest: MessageFns<ListProcessesRequest> = {
  encode(message: ListProcessesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProcessesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProcessesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProcessesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListProcessesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProcessesRequest>): ListProcessesRequest {
    return ListProcessesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProcessesRequest>): ListProcessesRequest {
    const message = createBaseListProcessesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListProcessesResponse(): ListProcessesResponse {
  return { processes: [], nextPageToken: "" };
}

export const ListProcessesResponse: MessageFns<ListProcessesResponse> = {
  encode(message: ListProcessesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.processes) {
      Process.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProcessesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProcessesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.processes.push(Process.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProcessesResponse {
    return {
      processes: globalThis.Array.isArray(object?.processes)
        ? object.processes.map((e: any) => Process.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListProcessesResponse): unknown {
    const obj: any = {};
    if (message.processes?.length) {
      obj.processes = message.processes.map((e) => Process.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProcessesResponse>): ListProcessesResponse {
    return ListProcessesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProcessesResponse>): ListProcessesResponse {
    const message = createBaseListProcessesResponse();
    message.processes = object.processes?.map((e) => Process.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteProcessRequest(): DeleteProcessRequest {
  return { name: "", allowMissing: false };
}

export const DeleteProcessRequest: MessageFns<DeleteProcessRequest> = {
  encode(message: DeleteProcessRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.allowMissing !== false) {
      writer.uint32(16).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProcessRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProcessRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProcessRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: DeleteProcessRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteProcessRequest>): DeleteProcessRequest {
    return DeleteProcessRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteProcessRequest>): DeleteProcessRequest {
    const message = createBaseDeleteProcessRequest();
    message.name = object.name ?? "";
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseCreateRunRequest(): CreateRunRequest {
  return { parent: "", run: undefined, requestId: "" };
}

export const CreateRunRequest: MessageFns<CreateRunRequest> = {
  encode(message: CreateRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.run !== undefined) {
      Run.encode(message.run, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.run = Run.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRunRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      run: isSet(object.run) ? Run.fromJSON(object.run) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateRunRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.run !== undefined) {
      obj.run = Run.toJSON(message.run);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRunRequest>): CreateRunRequest {
    return CreateRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRunRequest>): CreateRunRequest {
    const message = createBaseCreateRunRequest();
    message.parent = object.parent ?? "";
    message.run = (object.run !== undefined && object.run !== null) ? Run.fromPartial(object.run) : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateRunRequest(): UpdateRunRequest {
  return { run: undefined, updateMask: undefined, allowMissing: false };
}

export const UpdateRunRequest: MessageFns<UpdateRunRequest> = {
  encode(message: UpdateRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.run !== undefined) {
      Run.encode(message.run, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.run = Run.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRunRequest {
    return {
      run: isSet(object.run) ? Run.fromJSON(object.run) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: UpdateRunRequest): unknown {
    const obj: any = {};
    if (message.run !== undefined) {
      obj.run = Run.toJSON(message.run);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateRunRequest>): UpdateRunRequest {
    return UpdateRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateRunRequest>): UpdateRunRequest {
    const message = createBaseUpdateRunRequest();
    message.run = (object.run !== undefined && object.run !== null) ? Run.fromPartial(object.run) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseGetRunRequest(): GetRunRequest {
  return { name: "" };
}

export const GetRunRequest: MessageFns<GetRunRequest> = {
  encode(message: GetRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRunRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetRunRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRunRequest>): GetRunRequest {
    return GetRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRunRequest>): GetRunRequest {
    const message = createBaseGetRunRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListRunsRequest(): ListRunsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListRunsRequest: MessageFns<ListRunsRequest> = {
  encode(message: ListRunsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRunsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRunsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListRunsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRunsRequest>): ListRunsRequest {
    return ListRunsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRunsRequest>): ListRunsRequest {
    const message = createBaseListRunsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListRunsResponse(): ListRunsResponse {
  return { runs: [], nextPageToken: "" };
}

export const ListRunsResponse: MessageFns<ListRunsResponse> = {
  encode(message: ListRunsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.runs) {
      Run.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRunsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRunsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.runs.push(Run.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRunsResponse {
    return {
      runs: globalThis.Array.isArray(object?.runs) ? object.runs.map((e: any) => Run.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRunsResponse): unknown {
    const obj: any = {};
    if (message.runs?.length) {
      obj.runs = message.runs.map((e) => Run.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRunsResponse>): ListRunsResponse {
    return ListRunsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRunsResponse>): ListRunsResponse {
    const message = createBaseListRunsResponse();
    message.runs = object.runs?.map((e) => Run.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteRunRequest(): DeleteRunRequest {
  return { name: "", allowMissing: false };
}

export const DeleteRunRequest: MessageFns<DeleteRunRequest> = {
  encode(message: DeleteRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.allowMissing !== false) {
      writer.uint32(16).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRunRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: DeleteRunRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteRunRequest>): DeleteRunRequest {
    return DeleteRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteRunRequest>): DeleteRunRequest {
    const message = createBaseDeleteRunRequest();
    message.name = object.name ?? "";
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseCreateLineageEventRequest(): CreateLineageEventRequest {
  return { parent: "", lineageEvent: undefined, requestId: "" };
}

export const CreateLineageEventRequest: MessageFns<CreateLineageEventRequest> = {
  encode(message: CreateLineageEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.lineageEvent !== undefined) {
      LineageEvent.encode(message.lineageEvent, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateLineageEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateLineageEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lineageEvent = LineageEvent.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateLineageEventRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      lineageEvent: isSet(object.lineageEvent) ? LineageEvent.fromJSON(object.lineageEvent) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateLineageEventRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.lineageEvent !== undefined) {
      obj.lineageEvent = LineageEvent.toJSON(message.lineageEvent);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateLineageEventRequest>): CreateLineageEventRequest {
    return CreateLineageEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateLineageEventRequest>): CreateLineageEventRequest {
    const message = createBaseCreateLineageEventRequest();
    message.parent = object.parent ?? "";
    message.lineageEvent = (object.lineageEvent !== undefined && object.lineageEvent !== null)
      ? LineageEvent.fromPartial(object.lineageEvent)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseGetLineageEventRequest(): GetLineageEventRequest {
  return { name: "" };
}

export const GetLineageEventRequest: MessageFns<GetLineageEventRequest> = {
  encode(message: GetLineageEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLineageEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLineageEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLineageEventRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetLineageEventRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLineageEventRequest>): GetLineageEventRequest {
    return GetLineageEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLineageEventRequest>): GetLineageEventRequest {
    const message = createBaseGetLineageEventRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListLineageEventsRequest(): ListLineageEventsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListLineageEventsRequest: MessageFns<ListLineageEventsRequest> = {
  encode(message: ListLineageEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLineageEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLineageEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLineageEventsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListLineageEventsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListLineageEventsRequest>): ListLineageEventsRequest {
    return ListLineageEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListLineageEventsRequest>): ListLineageEventsRequest {
    const message = createBaseListLineageEventsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListLineageEventsResponse(): ListLineageEventsResponse {
  return { lineageEvents: [], nextPageToken: "" };
}

export const ListLineageEventsResponse: MessageFns<ListLineageEventsResponse> = {
  encode(message: ListLineageEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lineageEvents) {
      LineageEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLineageEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLineageEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lineageEvents.push(LineageEvent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLineageEventsResponse {
    return {
      lineageEvents: globalThis.Array.isArray(object?.lineageEvents)
        ? object.lineageEvents.map((e: any) => LineageEvent.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListLineageEventsResponse): unknown {
    const obj: any = {};
    if (message.lineageEvents?.length) {
      obj.lineageEvents = message.lineageEvents.map((e) => LineageEvent.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListLineageEventsResponse>): ListLineageEventsResponse {
    return ListLineageEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListLineageEventsResponse>): ListLineageEventsResponse {
    const message = createBaseListLineageEventsResponse();
    message.lineageEvents = object.lineageEvents?.map((e) => LineageEvent.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteLineageEventRequest(): DeleteLineageEventRequest {
  return { name: "", allowMissing: false };
}

export const DeleteLineageEventRequest: MessageFns<DeleteLineageEventRequest> = {
  encode(message: DeleteLineageEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.allowMissing !== false) {
      writer.uint32(16).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteLineageEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteLineageEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteLineageEventRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: DeleteLineageEventRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteLineageEventRequest>): DeleteLineageEventRequest {
    return DeleteLineageEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteLineageEventRequest>): DeleteLineageEventRequest {
    const message = createBaseDeleteLineageEventRequest();
    message.name = object.name ?? "";
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseSearchLinksRequest(): SearchLinksRequest {
  return { parent: "", source: undefined, target: undefined, pageSize: 0, pageToken: "" };
}

export const SearchLinksRequest: MessageFns<SearchLinksRequest> = {
  encode(message: SearchLinksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.source !== undefined) {
      EntityReference.encode(message.source, writer.uint32(34).fork()).join();
    }
    if (message.target !== undefined) {
      EntityReference.encode(message.target, writer.uint32(42).fork()).join();
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchLinksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchLinksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.source = EntityReference.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.target = EntityReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchLinksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      source: isSet(object.source) ? EntityReference.fromJSON(object.source) : undefined,
      target: isSet(object.target) ? EntityReference.fromJSON(object.target) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: SearchLinksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.source !== undefined) {
      obj.source = EntityReference.toJSON(message.source);
    }
    if (message.target !== undefined) {
      obj.target = EntityReference.toJSON(message.target);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchLinksRequest>): SearchLinksRequest {
    return SearchLinksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchLinksRequest>): SearchLinksRequest {
    const message = createBaseSearchLinksRequest();
    message.parent = object.parent ?? "";
    message.source = (object.source !== undefined && object.source !== null)
      ? EntityReference.fromPartial(object.source)
      : undefined;
    message.target = (object.target !== undefined && object.target !== null)
      ? EntityReference.fromPartial(object.target)
      : undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseSearchLinksResponse(): SearchLinksResponse {
  return { links: [], nextPageToken: "" };
}

export const SearchLinksResponse: MessageFns<SearchLinksResponse> = {
  encode(message: SearchLinksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.links) {
      Link.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchLinksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchLinksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.links.push(Link.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchLinksResponse {
    return {
      links: globalThis.Array.isArray(object?.links) ? object.links.map((e: any) => Link.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchLinksResponse): unknown {
    const obj: any = {};
    if (message.links?.length) {
      obj.links = message.links.map((e) => Link.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchLinksResponse>): SearchLinksResponse {
    return SearchLinksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchLinksResponse>): SearchLinksResponse {
    const message = createBaseSearchLinksResponse();
    message.links = object.links?.map((e) => Link.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseLink(): Link {
  return { name: "", source: undefined, target: undefined, startTime: undefined, endTime: undefined };
}

export const Link: MessageFns<Link> = {
  encode(message: Link, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.source !== undefined) {
      EntityReference.encode(message.source, writer.uint32(18).fork()).join();
    }
    if (message.target !== undefined) {
      EntityReference.encode(message.target, writer.uint32(26).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Link {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = EntityReference.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = EntityReference.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Link {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      source: isSet(object.source) ? EntityReference.fromJSON(object.source) : undefined,
      target: isSet(object.target) ? EntityReference.fromJSON(object.target) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: Link): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.source !== undefined) {
      obj.source = EntityReference.toJSON(message.source);
    }
    if (message.target !== undefined) {
      obj.target = EntityReference.toJSON(message.target);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Link>): Link {
    return Link.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Link>): Link {
    const message = createBaseLink();
    message.name = object.name ?? "";
    message.source = (object.source !== undefined && object.source !== null)
      ? EntityReference.fromPartial(object.source)
      : undefined;
    message.target = (object.target !== undefined && object.target !== null)
      ? EntityReference.fromPartial(object.target)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseBatchSearchLinkProcessesRequest(): BatchSearchLinkProcessesRequest {
  return { parent: "", links: [], pageSize: 0, pageToken: "" };
}

export const BatchSearchLinkProcessesRequest: MessageFns<BatchSearchLinkProcessesRequest> = {
  encode(message: BatchSearchLinkProcessesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.links) {
      writer.uint32(18).string(v!);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchSearchLinkProcessesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchSearchLinkProcessesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.links.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchSearchLinkProcessesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      links: globalThis.Array.isArray(object?.links) ? object.links.map((e: any) => globalThis.String(e)) : [],
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: BatchSearchLinkProcessesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.links?.length) {
      obj.links = message.links;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchSearchLinkProcessesRequest>): BatchSearchLinkProcessesRequest {
    return BatchSearchLinkProcessesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchSearchLinkProcessesRequest>): BatchSearchLinkProcessesRequest {
    const message = createBaseBatchSearchLinkProcessesRequest();
    message.parent = object.parent ?? "";
    message.links = object.links?.map((e) => e) || [];
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseBatchSearchLinkProcessesResponse(): BatchSearchLinkProcessesResponse {
  return { processLinks: [], nextPageToken: "" };
}

export const BatchSearchLinkProcessesResponse: MessageFns<BatchSearchLinkProcessesResponse> = {
  encode(message: BatchSearchLinkProcessesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.processLinks) {
      ProcessLinks.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchSearchLinkProcessesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchSearchLinkProcessesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.processLinks.push(ProcessLinks.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchSearchLinkProcessesResponse {
    return {
      processLinks: globalThis.Array.isArray(object?.processLinks)
        ? object.processLinks.map((e: any) => ProcessLinks.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: BatchSearchLinkProcessesResponse): unknown {
    const obj: any = {};
    if (message.processLinks?.length) {
      obj.processLinks = message.processLinks.map((e) => ProcessLinks.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchSearchLinkProcessesResponse>): BatchSearchLinkProcessesResponse {
    return BatchSearchLinkProcessesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchSearchLinkProcessesResponse>): BatchSearchLinkProcessesResponse {
    const message = createBaseBatchSearchLinkProcessesResponse();
    message.processLinks = object.processLinks?.map((e) => ProcessLinks.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseProcessLinks(): ProcessLinks {
  return { process: "", links: [] };
}

export const ProcessLinks: MessageFns<ProcessLinks> = {
  encode(message: ProcessLinks, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.process !== "") {
      writer.uint32(10).string(message.process);
    }
    for (const v of message.links) {
      ProcessLinkInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessLinks {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessLinks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.process = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.links.push(ProcessLinkInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessLinks {
    return {
      process: isSet(object.process) ? globalThis.String(object.process) : "",
      links: globalThis.Array.isArray(object?.links) ? object.links.map((e: any) => ProcessLinkInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: ProcessLinks): unknown {
    const obj: any = {};
    if (message.process !== "") {
      obj.process = message.process;
    }
    if (message.links?.length) {
      obj.links = message.links.map((e) => ProcessLinkInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessLinks>): ProcessLinks {
    return ProcessLinks.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessLinks>): ProcessLinks {
    const message = createBaseProcessLinks();
    message.process = object.process ?? "";
    message.links = object.links?.map((e) => ProcessLinkInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessLinkInfo(): ProcessLinkInfo {
  return { link: "", startTime: undefined, endTime: undefined };
}

export const ProcessLinkInfo: MessageFns<ProcessLinkInfo> = {
  encode(message: ProcessLinkInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.link !== "") {
      writer.uint32(10).string(message.link);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessLinkInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessLinkInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.link = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessLinkInfo {
    return {
      link: isSet(object.link) ? globalThis.String(object.link) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: ProcessLinkInfo): unknown {
    const obj: any = {};
    if (message.link !== "") {
      obj.link = message.link;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessLinkInfo>): ProcessLinkInfo {
    return ProcessLinkInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessLinkInfo>): ProcessLinkInfo {
    const message = createBaseProcessLinkInfo();
    message.link = object.link ?? "";
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseOrigin(): Origin {
  return { sourceType: 0, name: "" };
}

export const Origin: MessageFns<Origin> = {
  encode(message: Origin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceType !== 0) {
      writer.uint32(8).int32(message.sourceType);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Origin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrigin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourceType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Origin {
    return {
      sourceType: isSet(object.sourceType) ? origin_SourceTypeFromJSON(object.sourceType) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: Origin): unknown {
    const obj: any = {};
    if (message.sourceType !== 0) {
      obj.sourceType = origin_SourceTypeToJSON(message.sourceType);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<Origin>): Origin {
    return Origin.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Origin>): Origin {
    const message = createBaseOrigin();
    message.sourceType = object.sourceType ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

/**
 * Lineage is used to track data flows between assets over time. You can
 * create [LineageEvents][google.cloud.datacatalog.lineage.v1.LineageEvent]
 * to record lineage between multiple sources and a single target, for
 * example, when table data is based on data from multiple tables.
 */
export type LineageDefinition = typeof LineageDefinition;
export const LineageDefinition = {
  name: "Lineage",
  fullName: "google.cloud.datacatalog.lineage.v1.Lineage",
  methods: {
    /**
     * Creates new lineage events together with their parents: process and run.
     * Updates the process and run if they already exist.
     * Mapped from Open Lineage specification:
     * https://github.com/OpenLineage/OpenLineage/blob/main/spec/OpenLineage.json.
     */
    processOpenLineageRunEvent: {
      name: "ProcessOpenLineageRunEvent",
      requestType: ProcessOpenLineageRunEventRequest,
      requestStream: false,
      responseType: ProcessOpenLineageRunEventResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              19,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              111,
              112,
              101,
              110,
              95,
              108,
              105,
              110,
              101,
              97,
              103,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              78,
              58,
              12,
              111,
              112,
              101,
              110,
              95,
              108,
              105,
              110,
              101,
              97,
              103,
              101,
              34,
              62,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              79,
              112,
              101,
              110,
              76,
              105,
              110,
              101,
              97,
              103,
              101,
              82,
              117,
              110,
              69,
              118,
              101,
              110,
              116,
            ]),
          ],
        },
      },
    },
    /** Creates a new process. */
    createProcess: {
      name: "CreateProcess",
      requestType: CreateProcessRequest,
      requestStream: false,
      responseType: Process,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([14, 112, 97, 114, 101, 110, 116, 44, 112, 114, 111, 99, 101, 115, 115])],
          578365826: [
            Buffer.from([
              56,
              58,
              7,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              34,
              45,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a process. */
    updateProcess: {
      name: "UpdateProcess",
      requestType: UpdateProcessRequest,
      requestStream: false,
      responseType: Process,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([19, 112, 114, 111, 99, 101, 115, 115, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              64,
              58,
              7,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              50,
              53,
              47,
              118,
              49,
              47,
              123,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets the details of the specified process. */
    getProcess: {
      name: "GetProcess",
      requestType: GetProcessRequest,
      requestStream: false,
      responseType: Process,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * List processes in the given project and location. List order is descending
     * by insertion time.
     */
    listProcesses: {
      name: "ListProcesses",
      requestType: ListProcessesRequest,
      requestStream: false,
      responseType: ListProcessesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes the process with the specified name. */
    deleteProcess: {
      name: "DeleteProcess",
      requestType: DeleteProcessRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              78,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              53,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              100,
              97,
              116,
              97,
              99,
              97,
              116,
              97,
              108,
              111,
              103,
              46,
              108,
              105,
              110,
              101,
              97,
              103,
              101,
              46,
              118,
              49,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              47,
              42,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new run. */
    createRun: {
      name: "CreateRun",
      requestType: CreateRunRequest,
      requestStream: false,
      responseType: Run,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([10, 112, 97, 114, 101, 110, 116, 44, 114, 117, 110])],
          578365826: [
            Buffer.from([
              59,
              58,
              3,
              114,
              117,
              110,
              34,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              117,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a run. */
    updateRun: {
      name: "UpdateRun",
      requestType: UpdateRunRequest,
      requestStream: false,
      responseType: Run,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 114, 117, 110, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              63,
              58,
              3,
              114,
              117,
              110,
              50,
              56,
              47,
              118,
              49,
              47,
              123,
              114,
              117,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              117,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets the details of the specified run. */
    getRun: {
      name: "GetRun",
      requestType: GetRunRequest,
      requestStream: false,
      responseType: Run,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              117,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists runs in the given project and location. List order is descending by
     * `start_time`.
     */
    listRuns: {
      name: "ListRuns",
      requestType: ListRunsRequest,
      requestStream: false,
      responseType: ListRunsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              117,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes the run with the specified name. */
    deleteRun: {
      name: "DeleteRun",
      requestType: DeleteRunRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              78,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              53,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              100,
              97,
              116,
              97,
              99,
              97,
              116,
              97,
              108,
              111,
              103,
              46,
              108,
              105,
              110,
              101,
              97,
              103,
              101,
              46,
              118,
              49,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              42,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              117,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new lineage event. */
    createLineageEvent: {
      name: "CreateLineageEvent",
      requestType: CreateLineageEventRequest,
      requestStream: false,
      responseType: LineageEvent,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              108,
              105,
              110,
              101,
              97,
              103,
              101,
              95,
              101,
              118,
              101,
              110,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              85,
              58,
              13,
              108,
              105,
              110,
              101,
              97,
              103,
              101,
              95,
              101,
              118,
              101,
              110,
              116,
              34,
              68,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              117,
              110,
              115,
              47,
              42,
              125,
              47,
              108,
              105,
              110,
              101,
              97,
              103,
              101,
              69,
              118,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a specified lineage event. */
    getLineageEvent: {
      name: "GetLineageEvent",
      requestType: GetLineageEventRequest,
      requestStream: false,
      responseType: LineageEvent,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              70,
              18,
              68,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              117,
              110,
              115,
              47,
              42,
              47,
              108,
              105,
              110,
              101,
              97,
              103,
              101,
              69,
              118,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists lineage events in the given project and location. The list order is
     * not defined.
     */
    listLineageEvents: {
      name: "ListLineageEvents",
      requestType: ListLineageEventsRequest,
      requestStream: false,
      responseType: ListLineageEventsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              70,
              18,
              68,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              117,
              110,
              115,
              47,
              42,
              125,
              47,
              108,
              105,
              110,
              101,
              97,
              103,
              101,
              69,
              118,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes the lineage event with the specified name. */
    deleteLineageEvent: {
      name: "DeleteLineageEvent",
      requestType: DeleteLineageEventRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              70,
              42,
              68,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              117,
              110,
              115,
              47,
              42,
              47,
              108,
              105,
              110,
              101,
              97,
              103,
              101,
              69,
              118,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieve a list of links connected to a specific asset.
     * Links represent the data flow between **source** (upstream)
     * and **target** (downstream) assets in transformation pipelines.
     * Links are stored in the same project as the Lineage Events that create
     * them.
     *
     * You can retrieve links in every project where you have the
     * `datalineage.events.get` permission. The project provided in the URL
     * is used for Billing and Quota.
     */
    searchLinks: {
      name: "SearchLinks",
      requestType: SearchLinksRequest,
      requestStream: false,
      responseType: SearchLinksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              76,
              105,
              110,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieve information about LineageProcesses associated with specific
     * links. LineageProcesses are transformation pipelines that result in data
     * flowing from **source** to **target** assets. Links between assets
     * represent this operation.
     *
     * If you have specific link names, you can use this method to
     * verify which LineageProcesses contribute to creating those links.
     * See the
     * [SearchLinks][google.cloud.datacatalog.lineage.v1.Lineage.SearchLinks]
     * method for more information on how to retrieve link name.
     *
     * You can retrieve the LineageProcess information in every project where you
     * have the `datalineage.events.get` permission. The project provided in the
     * URL is used for Billing and Quota.
     */
    batchSearchLinkProcesses: {
      name: "BatchSearchLinkProcesses",
      requestType: BatchSearchLinkProcessesRequest,
      requestStream: false,
      responseType: BatchSearchLinkProcessesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              65,
              58,
              1,
              42,
              34,
              60,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              98,
              97,
              116,
              99,
              104,
              83,
              101,
              97,
              114,
              99,
              104,
              76,
              105,
              110,
              107,
              80,
              114,
              111,
              99,
              101,
              115,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface LineageServiceImplementation<CallContextExt = {}> {
  /**
   * Creates new lineage events together with their parents: process and run.
   * Updates the process and run if they already exist.
   * Mapped from Open Lineage specification:
   * https://github.com/OpenLineage/OpenLineage/blob/main/spec/OpenLineage.json.
   */
  processOpenLineageRunEvent(
    request: ProcessOpenLineageRunEventRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ProcessOpenLineageRunEventResponse>>;
  /** Creates a new process. */
  createProcess(request: CreateProcessRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Process>>;
  /** Updates a process. */
  updateProcess(request: UpdateProcessRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Process>>;
  /** Gets the details of the specified process. */
  getProcess(request: GetProcessRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Process>>;
  /**
   * List processes in the given project and location. List order is descending
   * by insertion time.
   */
  listProcesses(
    request: ListProcessesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListProcessesResponse>>;
  /** Deletes the process with the specified name. */
  deleteProcess(request: DeleteProcessRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Creates a new run. */
  createRun(request: CreateRunRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Run>>;
  /** Updates a run. */
  updateRun(request: UpdateRunRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Run>>;
  /** Gets the details of the specified run. */
  getRun(request: GetRunRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Run>>;
  /**
   * Lists runs in the given project and location. List order is descending by
   * `start_time`.
   */
  listRuns(request: ListRunsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListRunsResponse>>;
  /** Deletes the run with the specified name. */
  deleteRun(request: DeleteRunRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Creates a new lineage event. */
  createLineageEvent(
    request: CreateLineageEventRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<LineageEvent>>;
  /** Gets details of a specified lineage event. */
  getLineageEvent(
    request: GetLineageEventRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<LineageEvent>>;
  /**
   * Lists lineage events in the given project and location. The list order is
   * not defined.
   */
  listLineageEvents(
    request: ListLineageEventsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListLineageEventsResponse>>;
  /** Deletes the lineage event with the specified name. */
  deleteLineageEvent(
    request: DeleteLineageEventRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Retrieve a list of links connected to a specific asset.
   * Links represent the data flow between **source** (upstream)
   * and **target** (downstream) assets in transformation pipelines.
   * Links are stored in the same project as the Lineage Events that create
   * them.
   *
   * You can retrieve links in every project where you have the
   * `datalineage.events.get` permission. The project provided in the URL
   * is used for Billing and Quota.
   */
  searchLinks(
    request: SearchLinksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchLinksResponse>>;
  /**
   * Retrieve information about LineageProcesses associated with specific
   * links. LineageProcesses are transformation pipelines that result in data
   * flowing from **source** to **target** assets. Links between assets
   * represent this operation.
   *
   * If you have specific link names, you can use this method to
   * verify which LineageProcesses contribute to creating those links.
   * See the
   * [SearchLinks][google.cloud.datacatalog.lineage.v1.Lineage.SearchLinks]
   * method for more information on how to retrieve link name.
   *
   * You can retrieve the LineageProcess information in every project where you
   * have the `datalineage.events.get` permission. The project provided in the
   * URL is used for Billing and Quota.
   */
  batchSearchLinkProcesses(
    request: BatchSearchLinkProcessesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchSearchLinkProcessesResponse>>;
}

export interface LineageClient<CallOptionsExt = {}> {
  /**
   * Creates new lineage events together with their parents: process and run.
   * Updates the process and run if they already exist.
   * Mapped from Open Lineage specification:
   * https://github.com/OpenLineage/OpenLineage/blob/main/spec/OpenLineage.json.
   */
  processOpenLineageRunEvent(
    request: DeepPartial<ProcessOpenLineageRunEventRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ProcessOpenLineageRunEventResponse>;
  /** Creates a new process. */
  createProcess(request: DeepPartial<CreateProcessRequest>, options?: CallOptions & CallOptionsExt): Promise<Process>;
  /** Updates a process. */
  updateProcess(request: DeepPartial<UpdateProcessRequest>, options?: CallOptions & CallOptionsExt): Promise<Process>;
  /** Gets the details of the specified process. */
  getProcess(request: DeepPartial<GetProcessRequest>, options?: CallOptions & CallOptionsExt): Promise<Process>;
  /**
   * List processes in the given project and location. List order is descending
   * by insertion time.
   */
  listProcesses(
    request: DeepPartial<ListProcessesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListProcessesResponse>;
  /** Deletes the process with the specified name. */
  deleteProcess(request: DeepPartial<DeleteProcessRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Creates a new run. */
  createRun(request: DeepPartial<CreateRunRequest>, options?: CallOptions & CallOptionsExt): Promise<Run>;
  /** Updates a run. */
  updateRun(request: DeepPartial<UpdateRunRequest>, options?: CallOptions & CallOptionsExt): Promise<Run>;
  /** Gets the details of the specified run. */
  getRun(request: DeepPartial<GetRunRequest>, options?: CallOptions & CallOptionsExt): Promise<Run>;
  /**
   * Lists runs in the given project and location. List order is descending by
   * `start_time`.
   */
  listRuns(request: DeepPartial<ListRunsRequest>, options?: CallOptions & CallOptionsExt): Promise<ListRunsResponse>;
  /** Deletes the run with the specified name. */
  deleteRun(request: DeepPartial<DeleteRunRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Creates a new lineage event. */
  createLineageEvent(
    request: DeepPartial<CreateLineageEventRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<LineageEvent>;
  /** Gets details of a specified lineage event. */
  getLineageEvent(
    request: DeepPartial<GetLineageEventRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<LineageEvent>;
  /**
   * Lists lineage events in the given project and location. The list order is
   * not defined.
   */
  listLineageEvents(
    request: DeepPartial<ListLineageEventsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListLineageEventsResponse>;
  /** Deletes the lineage event with the specified name. */
  deleteLineageEvent(
    request: DeepPartial<DeleteLineageEventRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Retrieve a list of links connected to a specific asset.
   * Links represent the data flow between **source** (upstream)
   * and **target** (downstream) assets in transformation pipelines.
   * Links are stored in the same project as the Lineage Events that create
   * them.
   *
   * You can retrieve links in every project where you have the
   * `datalineage.events.get` permission. The project provided in the URL
   * is used for Billing and Quota.
   */
  searchLinks(
    request: DeepPartial<SearchLinksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchLinksResponse>;
  /**
   * Retrieve information about LineageProcesses associated with specific
   * links. LineageProcesses are transformation pipelines that result in data
   * flowing from **source** to **target** assets. Links between assets
   * represent this operation.
   *
   * If you have specific link names, you can use this method to
   * verify which LineageProcesses contribute to creating those links.
   * See the
   * [SearchLinks][google.cloud.datacatalog.lineage.v1.Lineage.SearchLinks]
   * method for more information on how to retrieve link name.
   *
   * You can retrieve the LineageProcess information in every project where you
   * have the `datalineage.events.get` permission. The project provided in the
   * URL is used for Billing and Quota.
   */
  batchSearchLinkProcesses(
    request: DeepPartial<BatchSearchLinkProcessesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchSearchLinkProcessesResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
