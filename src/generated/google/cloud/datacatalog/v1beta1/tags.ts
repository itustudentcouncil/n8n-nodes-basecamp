// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/datacatalog/v1beta1/tags.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.datacatalog.v1beta1";

/**
 * Tags are used to attach custom metadata to Data Catalog resources. Tags
 * conform to the specifications within their tag template.
 *
 * See [Data Catalog
 * IAM](https://cloud.google.com/data-catalog/docs/concepts/iam) for information
 * on the permissions needed to create or view tags.
 */
export interface Tag {
  /**
   * Identifier. The resource name of the tag in URL format. Example:
   *
   * * projects/{project_id}/locations/{location}/entrygroups/{entry_group_id}/entries/{entry_id}/tags/{tag_id}
   *
   * where `tag_id` is a system-generated identifier.
   * Note that this Tag may not actually be stored in the location in this name.
   */
  name: string;
  /**
   * Required. The resource name of the tag template that this tag uses.
   * Example:
   *
   * * projects/{project_id}/locations/{location}/tagTemplates/{tag_template_id}
   *
   * This field cannot be modified after creation.
   */
  template: string;
  /** Output only. The display name of the tag template. */
  templateDisplayName: string;
  /**
   * Resources like Entry can have schemas associated with them. This scope
   * allows users to attach tags to an individual column based on that schema.
   *
   * For attaching a tag to a nested column, use `.` to separate the column
   * names. Example:
   *
   * * `outer_column.inner_column`
   */
  column?:
    | string
    | undefined;
  /**
   * Required. This maps the ID of a tag field to the value of and additional
   * information about that field. Valid field IDs are defined by the tag's
   * template. A tag must have at least 1 field and at most 500 fields.
   */
  fields: { [key: string]: TagField };
}

export interface Tag_FieldsEntry {
  key: string;
  value: TagField | undefined;
}

/**
 * Contains the value and supporting information for a field within
 * a [Tag][google.cloud.datacatalog.v1beta1.Tag].
 */
export interface TagField {
  /** Output only. The display name of this field. */
  displayName: string;
  /** Holds the value for a tag field with double type. */
  doubleValue?:
    | number
    | undefined;
  /** Holds the value for a tag field with string type. */
  stringValue?:
    | string
    | undefined;
  /** Holds the value for a tag field with boolean type. */
  boolValue?:
    | boolean
    | undefined;
  /** Holds the value for a tag field with timestamp type. */
  timestampValue?:
    | Date
    | undefined;
  /**
   * Holds the value for a tag field with enum type. This value must be
   * one of the allowed values in the definition of this enum.
   */
  enumValue?:
    | TagField_EnumValue
    | undefined;
  /**
   * Output only. The order of this field with respect to other fields in this
   * tag. It can be set in
   * [Tag][google.cloud.datacatalog.v1beta1.TagTemplateField.order]. For
   * example, a higher value can indicate a more important field. The value can
   * be negative. Multiple fields can have the same order, and field orders
   * within a tag do not have to be sequential.
   */
  order: number;
}

/** Holds an enum value. */
export interface TagField_EnumValue {
  /** The display name of the enum value. */
  displayName: string;
}

/**
 * A tag template defines a tag, which can have one or more typed fields.
 * The template is used to create and attach the tag to Google Cloud resources.
 * [Tag template
 * roles](https://cloud.google.com/iam/docs/understanding-roles#data-catalog-roles)
 * provide permissions to create, edit, and use the template. See, for example,
 * the [TagTemplate
 * User](https://cloud.google.com/data-catalog/docs/how-to/template-user) role,
 * which includes permission to use the tag template to tag resources.
 */
export interface TagTemplate {
  /**
   * Identifier. The resource name of the tag template in URL format. Example:
   *
   * * projects/{project_id}/locations/{location}/tagTemplates/{tag_template_id}
   *
   * Note that this TagTemplate and its child resources may not actually be
   * stored in the location in this name.
   */
  name: string;
  /** The display name for this template. Defaults to an empty string. */
  displayName: string;
  /**
   * Required. Map of tag template field IDs to the settings for the field.
   * This map is an exhaustive list of the allowed fields. This map must contain
   * at least one field and at most 500 fields.
   *
   * The keys to this map are tag template field IDs. Field IDs can contain
   * letters (both uppercase and lowercase), numbers (0-9) and underscores (_).
   * Field IDs must be at least 1 character long and at most
   * 64 characters long. Field IDs must start with a letter or underscore.
   */
  fields: { [key: string]: TagTemplateField };
  /** Output only. Transfer status of the TagTemplate */
  dataplexTransferStatus: TagTemplate_DataplexTransferStatus;
}

/** This enum describes TagTemplate transfer status to Dataplex service. */
export enum TagTemplate_DataplexTransferStatus {
  /**
   * DATAPLEX_TRANSFER_STATUS_UNSPECIFIED - Default value. TagTemplate and its tags are only visible and editable in
   * DataCatalog.
   */
  DATAPLEX_TRANSFER_STATUS_UNSPECIFIED = 0,
  /**
   * MIGRATED - TagTemplate and its tags are auto-copied to Dataplex service.
   * Visible in both services. Editable in DataCatalog, read-only in Dataplex.
   * Deprecated: Individual TagTemplate migration is deprecated in favor of
   * organization or project wide TagTemplate migration opt-in.
   *
   * @deprecated
   */
  MIGRATED = 1,
  UNRECOGNIZED = -1,
}

export function tagTemplate_DataplexTransferStatusFromJSON(object: any): TagTemplate_DataplexTransferStatus {
  switch (object) {
    case 0:
    case "DATAPLEX_TRANSFER_STATUS_UNSPECIFIED":
      return TagTemplate_DataplexTransferStatus.DATAPLEX_TRANSFER_STATUS_UNSPECIFIED;
    case 1:
    case "MIGRATED":
      return TagTemplate_DataplexTransferStatus.MIGRATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TagTemplate_DataplexTransferStatus.UNRECOGNIZED;
  }
}

export function tagTemplate_DataplexTransferStatusToJSON(object: TagTemplate_DataplexTransferStatus): string {
  switch (object) {
    case TagTemplate_DataplexTransferStatus.DATAPLEX_TRANSFER_STATUS_UNSPECIFIED:
      return "DATAPLEX_TRANSFER_STATUS_UNSPECIFIED";
    case TagTemplate_DataplexTransferStatus.MIGRATED:
      return "MIGRATED";
    case TagTemplate_DataplexTransferStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TagTemplate_FieldsEntry {
  key: string;
  value: TagTemplateField | undefined;
}

/** The template for an individual field within a tag template. */
export interface TagTemplateField {
  /**
   * Output only. Identifier. The resource name of the tag template field in URL
   * format. Example:
   *
   * * projects/{project_id}/locations/{location}/tagTemplates/{tag_template}/fields/{field}
   *
   * Note that this TagTemplateField may not actually be stored in the location
   * in this name.
   */
  name: string;
  /** The display name for this field. Defaults to an empty string. */
  displayName: string;
  /** Required. The type of value this tag field can contain. */
  type:
    | FieldType
    | undefined;
  /** Whether this is a required field. Defaults to false. */
  isRequired: boolean;
  /** The description for this field. Defaults to an empty string. */
  description: string;
  /**
   * The order of this field with respect to other fields in this tag
   * template.  A higher value indicates a more important field. The value can
   * be negative. Multiple fields can have the same order, and field orders
   * within a tag do not have to be sequential.
   */
  order: number;
}

export interface FieldType {
  /** Represents primitive types - string, bool etc. */
  primitiveType?:
    | FieldType_PrimitiveType
    | undefined;
  /** Represents an enum type. */
  enumType?: FieldType_EnumType | undefined;
}

export enum FieldType_PrimitiveType {
  /** PRIMITIVE_TYPE_UNSPECIFIED - This is the default invalid value for a type. */
  PRIMITIVE_TYPE_UNSPECIFIED = 0,
  /** DOUBLE - A double precision number. */
  DOUBLE = 1,
  /** STRING - An UTF-8 string. */
  STRING = 2,
  /** BOOL - A boolean value. */
  BOOL = 3,
  /** TIMESTAMP - A timestamp. */
  TIMESTAMP = 4,
  UNRECOGNIZED = -1,
}

export function fieldType_PrimitiveTypeFromJSON(object: any): FieldType_PrimitiveType {
  switch (object) {
    case 0:
    case "PRIMITIVE_TYPE_UNSPECIFIED":
      return FieldType_PrimitiveType.PRIMITIVE_TYPE_UNSPECIFIED;
    case 1:
    case "DOUBLE":
      return FieldType_PrimitiveType.DOUBLE;
    case 2:
    case "STRING":
      return FieldType_PrimitiveType.STRING;
    case 3:
    case "BOOL":
      return FieldType_PrimitiveType.BOOL;
    case 4:
    case "TIMESTAMP":
      return FieldType_PrimitiveType.TIMESTAMP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldType_PrimitiveType.UNRECOGNIZED;
  }
}

export function fieldType_PrimitiveTypeToJSON(object: FieldType_PrimitiveType): string {
  switch (object) {
    case FieldType_PrimitiveType.PRIMITIVE_TYPE_UNSPECIFIED:
      return "PRIMITIVE_TYPE_UNSPECIFIED";
    case FieldType_PrimitiveType.DOUBLE:
      return "DOUBLE";
    case FieldType_PrimitiveType.STRING:
      return "STRING";
    case FieldType_PrimitiveType.BOOL:
      return "BOOL";
    case FieldType_PrimitiveType.TIMESTAMP:
      return "TIMESTAMP";
    case FieldType_PrimitiveType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface FieldType_EnumType {
  allowedValues: FieldType_EnumType_EnumValue[];
}

export interface FieldType_EnumType_EnumValue {
  /**
   * Required. The display name of the enum value. Must not be an empty
   * string.
   */
  displayName: string;
}

function createBaseTag(): Tag {
  return { name: "", template: "", templateDisplayName: "", column: undefined, fields: {} };
}

export const Tag: MessageFns<Tag> = {
  encode(message: Tag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.template !== "") {
      writer.uint32(18).string(message.template);
    }
    if (message.templateDisplayName !== "") {
      writer.uint32(42).string(message.templateDisplayName);
    }
    if (message.column !== undefined) {
      writer.uint32(34).string(message.column);
    }
    Object.entries(message.fields).forEach(([key, value]) => {
      Tag_FieldsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.template = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.templateDisplayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.column = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Tag_FieldsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.fields[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tag {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      template: isSet(object.template) ? globalThis.String(object.template) : "",
      templateDisplayName: isSet(object.templateDisplayName) ? globalThis.String(object.templateDisplayName) : "",
      column: isSet(object.column) ? globalThis.String(object.column) : undefined,
      fields: isObject(object.fields)
        ? Object.entries(object.fields).reduce<{ [key: string]: TagField }>((acc, [key, value]) => {
          acc[key] = TagField.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Tag): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.template !== "") {
      obj.template = message.template;
    }
    if (message.templateDisplayName !== "") {
      obj.templateDisplayName = message.templateDisplayName;
    }
    if (message.column !== undefined) {
      obj.column = message.column;
    }
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = TagField.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Tag>): Tag {
    return Tag.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tag>): Tag {
    const message = createBaseTag();
    message.name = object.name ?? "";
    message.template = object.template ?? "";
    message.templateDisplayName = object.templateDisplayName ?? "";
    message.column = object.column ?? undefined;
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: TagField }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = TagField.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTag_FieldsEntry(): Tag_FieldsEntry {
  return { key: "", value: undefined };
}

export const Tag_FieldsEntry: MessageFns<Tag_FieldsEntry> = {
  encode(message: Tag_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TagField.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tag_FieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = TagField.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tag_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TagField.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Tag_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TagField.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Tag_FieldsEntry>): Tag_FieldsEntry {
    return Tag_FieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tag_FieldsEntry>): Tag_FieldsEntry {
    const message = createBaseTag_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TagField.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTagField(): TagField {
  return {
    displayName: "",
    doubleValue: undefined,
    stringValue: undefined,
    boolValue: undefined,
    timestampValue: undefined,
    enumValue: undefined,
    order: 0,
  };
}

export const TagField: MessageFns<TagField> = {
  encode(message: TagField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(17).double(message.doubleValue);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(26).string(message.stringValue);
    }
    if (message.boolValue !== undefined) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.timestampValue !== undefined) {
      Timestamp.encode(toTimestamp(message.timestampValue), writer.uint32(42).fork()).join();
    }
    if (message.enumValue !== undefined) {
      TagField_EnumValue.encode(message.enumValue, writer.uint32(50).fork()).join();
    }
    if (message.order !== 0) {
      writer.uint32(56).int32(message.order);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.timestampValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.enumValue = TagField_EnumValue.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.order = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagField {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      timestampValue: isSet(object.timestampValue) ? fromJsonTimestamp(object.timestampValue) : undefined,
      enumValue: isSet(object.enumValue) ? TagField_EnumValue.fromJSON(object.enumValue) : undefined,
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
    };
  },

  toJSON(message: TagField): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.timestampValue !== undefined) {
      obj.timestampValue = message.timestampValue.toISOString();
    }
    if (message.enumValue !== undefined) {
      obj.enumValue = TagField_EnumValue.toJSON(message.enumValue);
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    return obj;
  },

  create(base?: DeepPartial<TagField>): TagField {
    return TagField.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagField>): TagField {
    const message = createBaseTagField();
    message.displayName = object.displayName ?? "";
    message.doubleValue = object.doubleValue ?? undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.timestampValue = object.timestampValue ?? undefined;
    message.enumValue = (object.enumValue !== undefined && object.enumValue !== null)
      ? TagField_EnumValue.fromPartial(object.enumValue)
      : undefined;
    message.order = object.order ?? 0;
    return message;
  },
};

function createBaseTagField_EnumValue(): TagField_EnumValue {
  return { displayName: "" };
}

export const TagField_EnumValue: MessageFns<TagField_EnumValue> = {
  encode(message: TagField_EnumValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagField_EnumValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagField_EnumValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagField_EnumValue {
    return { displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "" };
  },

  toJSON(message: TagField_EnumValue): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<TagField_EnumValue>): TagField_EnumValue {
    return TagField_EnumValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagField_EnumValue>): TagField_EnumValue {
    const message = createBaseTagField_EnumValue();
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseTagTemplate(): TagTemplate {
  return { name: "", displayName: "", fields: {}, dataplexTransferStatus: 0 };
}

export const TagTemplate: MessageFns<TagTemplate> = {
  encode(message: TagTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    Object.entries(message.fields).forEach(([key, value]) => {
      TagTemplate_FieldsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.dataplexTransferStatus !== 0) {
      writer.uint32(56).int32(message.dataplexTransferStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = TagTemplate_FieldsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.fields[entry3.key] = entry3.value;
          }
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.dataplexTransferStatus = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagTemplate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      fields: isObject(object.fields)
        ? Object.entries(object.fields).reduce<{ [key: string]: TagTemplateField }>((acc, [key, value]) => {
          acc[key] = TagTemplateField.fromJSON(value);
          return acc;
        }, {})
        : {},
      dataplexTransferStatus: isSet(object.dataplexTransferStatus)
        ? tagTemplate_DataplexTransferStatusFromJSON(object.dataplexTransferStatus)
        : 0,
    };
  },

  toJSON(message: TagTemplate): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = TagTemplateField.toJSON(v);
        });
      }
    }
    if (message.dataplexTransferStatus !== 0) {
      obj.dataplexTransferStatus = tagTemplate_DataplexTransferStatusToJSON(message.dataplexTransferStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<TagTemplate>): TagTemplate {
    return TagTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagTemplate>): TagTemplate {
    const message = createBaseTagTemplate();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: TagTemplateField }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = TagTemplateField.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.dataplexTransferStatus = object.dataplexTransferStatus ?? 0;
    return message;
  },
};

function createBaseTagTemplate_FieldsEntry(): TagTemplate_FieldsEntry {
  return { key: "", value: undefined };
}

export const TagTemplate_FieldsEntry: MessageFns<TagTemplate_FieldsEntry> = {
  encode(message: TagTemplate_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TagTemplateField.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagTemplate_FieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagTemplate_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = TagTemplateField.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagTemplate_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TagTemplateField.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: TagTemplate_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TagTemplateField.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<TagTemplate_FieldsEntry>): TagTemplate_FieldsEntry {
    return TagTemplate_FieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagTemplate_FieldsEntry>): TagTemplate_FieldsEntry {
    const message = createBaseTagTemplate_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TagTemplateField.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTagTemplateField(): TagTemplateField {
  return { name: "", displayName: "", type: undefined, isRequired: false, description: "", order: 0 };
}

export const TagTemplateField: MessageFns<TagTemplateField> = {
  encode(message: TagTemplateField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.type !== undefined) {
      FieldType.encode(message.type, writer.uint32(18).fork()).join();
    }
    if (message.isRequired !== false) {
      writer.uint32(24).bool(message.isRequired);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.order !== 0) {
      writer.uint32(40).int32(message.order);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagTemplateField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagTemplateField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = FieldType.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isRequired = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.order = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagTemplateField {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      type: isSet(object.type) ? FieldType.fromJSON(object.type) : undefined,
      isRequired: isSet(object.isRequired) ? globalThis.Boolean(object.isRequired) : false,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
    };
  },

  toJSON(message: TagTemplateField): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.type !== undefined) {
      obj.type = FieldType.toJSON(message.type);
    }
    if (message.isRequired !== false) {
      obj.isRequired = message.isRequired;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    return obj;
  },

  create(base?: DeepPartial<TagTemplateField>): TagTemplateField {
    return TagTemplateField.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagTemplateField>): TagTemplateField {
    const message = createBaseTagTemplateField();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.type = (object.type !== undefined && object.type !== null) ? FieldType.fromPartial(object.type) : undefined;
    message.isRequired = object.isRequired ?? false;
    message.description = object.description ?? "";
    message.order = object.order ?? 0;
    return message;
  },
};

function createBaseFieldType(): FieldType {
  return { primitiveType: undefined, enumType: undefined };
}

export const FieldType: MessageFns<FieldType> = {
  encode(message: FieldType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primitiveType !== undefined) {
      writer.uint32(8).int32(message.primitiveType);
    }
    if (message.enumType !== undefined) {
      FieldType_EnumType.encode(message.enumType, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.primitiveType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.enumType = FieldType_EnumType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldType {
    return {
      primitiveType: isSet(object.primitiveType) ? fieldType_PrimitiveTypeFromJSON(object.primitiveType) : undefined,
      enumType: isSet(object.enumType) ? FieldType_EnumType.fromJSON(object.enumType) : undefined,
    };
  },

  toJSON(message: FieldType): unknown {
    const obj: any = {};
    if (message.primitiveType !== undefined) {
      obj.primitiveType = fieldType_PrimitiveTypeToJSON(message.primitiveType);
    }
    if (message.enumType !== undefined) {
      obj.enumType = FieldType_EnumType.toJSON(message.enumType);
    }
    return obj;
  },

  create(base?: DeepPartial<FieldType>): FieldType {
    return FieldType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FieldType>): FieldType {
    const message = createBaseFieldType();
    message.primitiveType = object.primitiveType ?? undefined;
    message.enumType = (object.enumType !== undefined && object.enumType !== null)
      ? FieldType_EnumType.fromPartial(object.enumType)
      : undefined;
    return message;
  },
};

function createBaseFieldType_EnumType(): FieldType_EnumType {
  return { allowedValues: [] };
}

export const FieldType_EnumType: MessageFns<FieldType_EnumType> = {
  encode(message: FieldType_EnumType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allowedValues) {
      FieldType_EnumType_EnumValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldType_EnumType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldType_EnumType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedValues.push(FieldType_EnumType_EnumValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldType_EnumType {
    return {
      allowedValues: globalThis.Array.isArray(object?.allowedValues)
        ? object.allowedValues.map((e: any) => FieldType_EnumType_EnumValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FieldType_EnumType): unknown {
    const obj: any = {};
    if (message.allowedValues?.length) {
      obj.allowedValues = message.allowedValues.map((e) => FieldType_EnumType_EnumValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FieldType_EnumType>): FieldType_EnumType {
    return FieldType_EnumType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FieldType_EnumType>): FieldType_EnumType {
    const message = createBaseFieldType_EnumType();
    message.allowedValues = object.allowedValues?.map((e) => FieldType_EnumType_EnumValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFieldType_EnumType_EnumValue(): FieldType_EnumType_EnumValue {
  return { displayName: "" };
}

export const FieldType_EnumType_EnumValue: MessageFns<FieldType_EnumType_EnumValue> = {
  encode(message: FieldType_EnumType_EnumValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldType_EnumType_EnumValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldType_EnumType_EnumValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldType_EnumType_EnumValue {
    return { displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "" };
  },

  toJSON(message: FieldType_EnumType_EnumValue): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<FieldType_EnumType_EnumValue>): FieldType_EnumType_EnumValue {
    return FieldType_EnumType_EnumValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FieldType_EnumType_EnumValue>): FieldType_EnumType_EnumValue {
    const message = createBaseFieldType_EnumType_EnumValue();
    message.displayName = object.displayName ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
