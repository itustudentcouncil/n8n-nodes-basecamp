// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/discoveryengine/v1/grounded_generation_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { FactChunk, GroundingFact } from "./grounding.js";

export const protobufPackage = "google.cloud.discoveryengine.v1";

/** Specification for the grounding check. */
export interface CheckGroundingSpec {
  /**
   * The threshold (in [0,1]) used for determining whether a fact must be
   * cited for a claim in the answer candidate. Choosing a higher threshold
   * will lead to fewer but very strong citations, while choosing a lower
   * threshold may lead to more but somewhat weaker citations. If unset, the
   * threshold will default to 0.6.
   */
  citationThreshold?: number | undefined;
}

/**
 * Request message for
 * [GroundedGenerationService.CheckGrounding][google.cloud.discoveryengine.v1.GroundedGenerationService.CheckGrounding]
 * method.
 */
export interface CheckGroundingRequest {
  /**
   * Required. The resource name of the grounding config, such as
   * `projects/* /locations/global/groundingConfigs/default_grounding_config`.
   */
  groundingConfig: string;
  /** Answer candidate to check. Can have a maximum length of 1024 characters. */
  answerCandidate: string;
  /**
   * List of facts for the grounding check.
   * We support up to 200 facts.
   */
  facts: GroundingFact[];
  /** Configuration of the grounding check. */
  groundingSpec:
    | CheckGroundingSpec
    | undefined;
  /**
   * The user labels applied to a resource must meet the following requirements:
   *
   * * Each resource can have multiple labels, up to a maximum of 64.
   * * Each label must be a key-value pair.
   * * Keys have a minimum length of 1 character and a maximum length of 63
   *   characters and cannot be empty. Values can be empty and have a maximum
   *   length of 63 characters.
   * * Keys and values can contain only lowercase letters, numeric characters,
   *   underscores, and dashes. All characters must use UTF-8 encoding, and
   *   international characters are allowed.
   * * The key portion of a label must be unique. However, you can use the same
   *   key with multiple resources.
   * * Keys must start with a lowercase letter or international character.
   *
   * See [Google Cloud
   * Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
   * for more details.
   */
  userLabels: { [key: string]: string };
}

export interface CheckGroundingRequest_UserLabelsEntry {
  key: string;
  value: string;
}

/**
 * Response message for the
 * [GroundedGenerationService.CheckGrounding][google.cloud.discoveryengine.v1.GroundedGenerationService.CheckGrounding]
 * method.
 */
export interface CheckGroundingResponse {
  /**
   * The support score for the input answer candidate.
   * Higher the score, higher is the fraction of claims that are supported by
   * the provided facts. This is always set when a response is returned.
   */
  supportScore?:
    | number
    | undefined;
  /**
   * List of facts cited across all claims in the answer candidate.
   * These are derived from the facts supplied in the request.
   */
  citedChunks: FactChunk[];
  /** Claim texts and citation info across all claims in the answer candidate. */
  claims: CheckGroundingResponse_Claim[];
}

/** Text and citation info for a claim in the answer candidate. */
export interface CheckGroundingResponse_Claim {
  /**
   * Position indicating the start of the claim in the answer candidate,
   * measured in bytes.
   */
  startPos?:
    | number
    | undefined;
  /**
   * Position indicating the end of the claim in the answer candidate,
   * exclusive.
   */
  endPos?:
    | number
    | undefined;
  /**
   * Text for the claim in the answer candidate. Always provided regardless of
   * whether citations or anti-citations are found.
   */
  claimText: string;
  /**
   * A list of indices (into 'cited_chunks') specifying the citations
   * associated with the claim. For instance [1,3,4] means that
   * cited_chunks[1], cited_chunks[3], cited_chunks[4] are the facts cited
   * supporting for the claim. A citation to a fact indicates that the claim
   * is supported by the fact.
   */
  citationIndices: number[];
  /**
   * Indicates that this claim required grounding check. When the system
   * decided this claim doesn't require attribution/grounding check, this
   * field will be set to false. In that case, no grounding check was done for
   * the claim and therefore
   * [citation_indices][google.cloud.discoveryengine.v1.CheckGroundingResponse.Claim.citation_indices],
   * [anti_citation_indices][google.cloud.discoveryengine.v1.CheckGroundingResponse.Claim.anti_citation_indices],
   * and
   * [score][google.cloud.discoveryengine.v1.CheckGroundingResponse.Claim.score]
   * should not be returned.
   */
  groundingCheckRequired?: boolean | undefined;
}

function createBaseCheckGroundingSpec(): CheckGroundingSpec {
  return { citationThreshold: undefined };
}

export const CheckGroundingSpec: MessageFns<CheckGroundingSpec> = {
  encode(message: CheckGroundingSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.citationThreshold !== undefined) {
      writer.uint32(9).double(message.citationThreshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckGroundingSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckGroundingSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.citationThreshold = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckGroundingSpec {
    return {
      citationThreshold: isSet(object.citationThreshold) ? globalThis.Number(object.citationThreshold) : undefined,
    };
  },

  toJSON(message: CheckGroundingSpec): unknown {
    const obj: any = {};
    if (message.citationThreshold !== undefined) {
      obj.citationThreshold = message.citationThreshold;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckGroundingSpec>): CheckGroundingSpec {
    return CheckGroundingSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckGroundingSpec>): CheckGroundingSpec {
    const message = createBaseCheckGroundingSpec();
    message.citationThreshold = object.citationThreshold ?? undefined;
    return message;
  },
};

function createBaseCheckGroundingRequest(): CheckGroundingRequest {
  return { groundingConfig: "", answerCandidate: "", facts: [], groundingSpec: undefined, userLabels: {} };
}

export const CheckGroundingRequest: MessageFns<CheckGroundingRequest> = {
  encode(message: CheckGroundingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groundingConfig !== "") {
      writer.uint32(10).string(message.groundingConfig);
    }
    if (message.answerCandidate !== "") {
      writer.uint32(18).string(message.answerCandidate);
    }
    for (const v of message.facts) {
      GroundingFact.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.groundingSpec !== undefined) {
      CheckGroundingSpec.encode(message.groundingSpec, writer.uint32(34).fork()).join();
    }
    Object.entries(message.userLabels).forEach(([key, value]) => {
      CheckGroundingRequest_UserLabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckGroundingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckGroundingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.groundingConfig = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.answerCandidate = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.facts.push(GroundingFact.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.groundingSpec = CheckGroundingSpec.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = CheckGroundingRequest_UserLabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.userLabels[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckGroundingRequest {
    return {
      groundingConfig: isSet(object.groundingConfig) ? globalThis.String(object.groundingConfig) : "",
      answerCandidate: isSet(object.answerCandidate) ? globalThis.String(object.answerCandidate) : "",
      facts: globalThis.Array.isArray(object?.facts) ? object.facts.map((e: any) => GroundingFact.fromJSON(e)) : [],
      groundingSpec: isSet(object.groundingSpec) ? CheckGroundingSpec.fromJSON(object.groundingSpec) : undefined,
      userLabels: isObject(object.userLabels)
        ? Object.entries(object.userLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CheckGroundingRequest): unknown {
    const obj: any = {};
    if (message.groundingConfig !== "") {
      obj.groundingConfig = message.groundingConfig;
    }
    if (message.answerCandidate !== "") {
      obj.answerCandidate = message.answerCandidate;
    }
    if (message.facts?.length) {
      obj.facts = message.facts.map((e) => GroundingFact.toJSON(e));
    }
    if (message.groundingSpec !== undefined) {
      obj.groundingSpec = CheckGroundingSpec.toJSON(message.groundingSpec);
    }
    if (message.userLabels) {
      const entries = Object.entries(message.userLabels);
      if (entries.length > 0) {
        obj.userLabels = {};
        entries.forEach(([k, v]) => {
          obj.userLabels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CheckGroundingRequest>): CheckGroundingRequest {
    return CheckGroundingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckGroundingRequest>): CheckGroundingRequest {
    const message = createBaseCheckGroundingRequest();
    message.groundingConfig = object.groundingConfig ?? "";
    message.answerCandidate = object.answerCandidate ?? "";
    message.facts = object.facts?.map((e) => GroundingFact.fromPartial(e)) || [];
    message.groundingSpec = (object.groundingSpec !== undefined && object.groundingSpec !== null)
      ? CheckGroundingSpec.fromPartial(object.groundingSpec)
      : undefined;
    message.userLabels = Object.entries(object.userLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCheckGroundingRequest_UserLabelsEntry(): CheckGroundingRequest_UserLabelsEntry {
  return { key: "", value: "" };
}

export const CheckGroundingRequest_UserLabelsEntry: MessageFns<CheckGroundingRequest_UserLabelsEntry> = {
  encode(message: CheckGroundingRequest_UserLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckGroundingRequest_UserLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckGroundingRequest_UserLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckGroundingRequest_UserLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CheckGroundingRequest_UserLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckGroundingRequest_UserLabelsEntry>): CheckGroundingRequest_UserLabelsEntry {
    return CheckGroundingRequest_UserLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckGroundingRequest_UserLabelsEntry>): CheckGroundingRequest_UserLabelsEntry {
    const message = createBaseCheckGroundingRequest_UserLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCheckGroundingResponse(): CheckGroundingResponse {
  return { supportScore: undefined, citedChunks: [], claims: [] };
}

export const CheckGroundingResponse: MessageFns<CheckGroundingResponse> = {
  encode(message: CheckGroundingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.supportScore !== undefined) {
      writer.uint32(13).float(message.supportScore);
    }
    for (const v of message.citedChunks) {
      FactChunk.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.claims) {
      CheckGroundingResponse_Claim.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckGroundingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckGroundingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.supportScore = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.citedChunks.push(FactChunk.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.claims.push(CheckGroundingResponse_Claim.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckGroundingResponse {
    return {
      supportScore: isSet(object.supportScore) ? globalThis.Number(object.supportScore) : undefined,
      citedChunks: globalThis.Array.isArray(object?.citedChunks)
        ? object.citedChunks.map((e: any) => FactChunk.fromJSON(e))
        : [],
      claims: globalThis.Array.isArray(object?.claims)
        ? object.claims.map((e: any) => CheckGroundingResponse_Claim.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CheckGroundingResponse): unknown {
    const obj: any = {};
    if (message.supportScore !== undefined) {
      obj.supportScore = message.supportScore;
    }
    if (message.citedChunks?.length) {
      obj.citedChunks = message.citedChunks.map((e) => FactChunk.toJSON(e));
    }
    if (message.claims?.length) {
      obj.claims = message.claims.map((e) => CheckGroundingResponse_Claim.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CheckGroundingResponse>): CheckGroundingResponse {
    return CheckGroundingResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckGroundingResponse>): CheckGroundingResponse {
    const message = createBaseCheckGroundingResponse();
    message.supportScore = object.supportScore ?? undefined;
    message.citedChunks = object.citedChunks?.map((e) => FactChunk.fromPartial(e)) || [];
    message.claims = object.claims?.map((e) => CheckGroundingResponse_Claim.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCheckGroundingResponse_Claim(): CheckGroundingResponse_Claim {
  return {
    startPos: undefined,
    endPos: undefined,
    claimText: "",
    citationIndices: [],
    groundingCheckRequired: undefined,
  };
}

export const CheckGroundingResponse_Claim: MessageFns<CheckGroundingResponse_Claim> = {
  encode(message: CheckGroundingResponse_Claim, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startPos !== undefined) {
      writer.uint32(8).int32(message.startPos);
    }
    if (message.endPos !== undefined) {
      writer.uint32(16).int32(message.endPos);
    }
    if (message.claimText !== "") {
      writer.uint32(26).string(message.claimText);
    }
    writer.uint32(34).fork();
    for (const v of message.citationIndices) {
      writer.int32(v);
    }
    writer.join();
    if (message.groundingCheckRequired !== undefined) {
      writer.uint32(48).bool(message.groundingCheckRequired);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckGroundingResponse_Claim {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckGroundingResponse_Claim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startPos = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endPos = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.claimText = reader.string();
          continue;
        case 4:
          if (tag === 32) {
            message.citationIndices.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.citationIndices.push(reader.int32());
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.groundingCheckRequired = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckGroundingResponse_Claim {
    return {
      startPos: isSet(object.startPos) ? globalThis.Number(object.startPos) : undefined,
      endPos: isSet(object.endPos) ? globalThis.Number(object.endPos) : undefined,
      claimText: isSet(object.claimText) ? globalThis.String(object.claimText) : "",
      citationIndices: globalThis.Array.isArray(object?.citationIndices)
        ? object.citationIndices.map((e: any) => globalThis.Number(e))
        : [],
      groundingCheckRequired: isSet(object.groundingCheckRequired)
        ? globalThis.Boolean(object.groundingCheckRequired)
        : undefined,
    };
  },

  toJSON(message: CheckGroundingResponse_Claim): unknown {
    const obj: any = {};
    if (message.startPos !== undefined) {
      obj.startPos = Math.round(message.startPos);
    }
    if (message.endPos !== undefined) {
      obj.endPos = Math.round(message.endPos);
    }
    if (message.claimText !== "") {
      obj.claimText = message.claimText;
    }
    if (message.citationIndices?.length) {
      obj.citationIndices = message.citationIndices.map((e) => Math.round(e));
    }
    if (message.groundingCheckRequired !== undefined) {
      obj.groundingCheckRequired = message.groundingCheckRequired;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckGroundingResponse_Claim>): CheckGroundingResponse_Claim {
    return CheckGroundingResponse_Claim.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckGroundingResponse_Claim>): CheckGroundingResponse_Claim {
    const message = createBaseCheckGroundingResponse_Claim();
    message.startPos = object.startPos ?? undefined;
    message.endPos = object.endPos ?? undefined;
    message.claimText = object.claimText ?? "";
    message.citationIndices = object.citationIndices?.map((e) => e) || [];
    message.groundingCheckRequired = object.groundingCheckRequired ?? undefined;
    return message;
  },
};

/** Service for grounded generation. */
export type GroundedGenerationServiceDefinition = typeof GroundedGenerationServiceDefinition;
export const GroundedGenerationServiceDefinition = {
  name: "GroundedGenerationService",
  fullName: "google.cloud.discoveryengine.v1.GroundedGenerationService",
  methods: {
    /** Performs a grounding check. */
    checkGrounding: {
      name: "CheckGrounding",
      requestType: CheckGroundingRequest,
      requestStream: false,
      responseType: CheckGroundingResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              75,
              58,
              1,
              42,
              34,
              70,
              47,
              118,
              49,
              47,
              123,
              103,
              114,
              111,
              117,
              110,
              100,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              110,
              100,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
              58,
              99,
              104,
              101,
              99,
              107,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface GroundedGenerationServiceImplementation<CallContextExt = {}> {
  /** Performs a grounding check. */
  checkGrounding(
    request: CheckGroundingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CheckGroundingResponse>>;
}

export interface GroundedGenerationServiceClient<CallOptionsExt = {}> {
  /** Performs a grounding check. */
  checkGrounding(
    request: DeepPartial<CheckGroundingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CheckGroundingResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
