// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/discoveryengine/v1/search_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Value } from "../../../protobuf/struct.js";
import { Chunk } from "./chunk.js";
import { Interval, UserInfo } from "./common.js";
import { Document } from "./document.js";

export const protobufPackage = "google.cloud.discoveryengine.v1";

/**
 * Request message for
 * [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search]
 * method.
 */
export interface SearchRequest {
  /**
   * Required. The resource name of the Search serving config, such as
   * `projects/* /locations/global/collections/default_collection/engines/* /servingConfigs/default_serving_config`,
   * or
   * `projects/* /locations/global/collections/default_collection/dataStores/default_data_store/servingConfigs/default_serving_config`.
   * This field is used to identify the serving configuration name, set
   * of models used to make the search.
   */
  servingConfig: string;
  /**
   * The branch resource name, such as
   * `projects/* /locations/global/collections/default_collection/dataStores/default_data_store/branches/0`.
   *
   * Use `default_branch` as the branch ID or leave this field empty, to search
   * documents under the default branch.
   */
  branch: string;
  /** Raw search query. */
  query: string;
  /** Raw image query. */
  imageQuery:
    | SearchRequest_ImageQuery
    | undefined;
  /**
   * Maximum number of [Document][google.cloud.discoveryengine.v1.Document]s to
   * return. The maximum allowed value depends on the data type. Values above
   * the maximum value are coerced to the maximum value.
   *
   * * Websites with basic indexing: Default `10`, Maximum `25`.
   * * Websites with advanced indexing: Default `25`, Maximum `50`.
   * * Other: Default `50`, Maximum `100`.
   *
   * If this field is negative, an  `INVALID_ARGUMENT` is returned.
   */
  pageSize: number;
  /**
   * A page token received from a previous
   * [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search]
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search]
   * must match the call that provided the page token. Otherwise, an
   *  `INVALID_ARGUMENT`  error is returned.
   */
  pageToken: string;
  /**
   * A 0-indexed integer that specifies the current offset (that is, starting
   * result location, amongst the
   * [Document][google.cloud.discoveryengine.v1.Document]s deemed by the API as
   * relevant) in search results. This field is only considered if
   * [page_token][google.cloud.discoveryengine.v1.SearchRequest.page_token] is
   * unset.
   *
   * If this field is negative, an  `INVALID_ARGUMENT`  is returned.
   */
  offset: number;
  /**
   * Specs defining dataStores to filter on in a search call and configurations
   * for those dataStores. This is only considered for engines with multiple
   * dataStores use case. For single dataStore within an engine, they should
   * use the specs at the top level.
   */
  dataStoreSpecs: SearchRequest_DataStoreSpec[];
  /**
   * The filter syntax consists of an expression language for constructing a
   * predicate from one or more fields of the documents being filtered. Filter
   * expression is case-sensitive.
   *
   * If this field is unrecognizable, an  `INVALID_ARGUMENT`  is returned.
   *
   * Filtering in Vertex AI Search is done by mapping the LHS filter key to a
   * key property defined in the Vertex AI Search backend -- this mapping is
   * defined by the customer in their schema. For example a media customer might
   * have a field 'name' in their schema. In this case the filter would look
   * like this: filter --> name:'ANY("king kong")'
   *
   * For more information about filtering including syntax and filter
   * operators, see
   * [Filter](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
   */
  filter: string;
  /**
   * The default filter that is applied when a user performs a search without
   * checking any filters on the search page.
   *
   * The filter applied to every search request when quality improvement such as
   * query expansion is needed. In the case a query does not have a sufficient
   * amount of results this filter will be used to determine whether or not to
   * enable the query expansion flow. The original filter will still be used for
   * the query expanded search.
   * This field is strongly recommended to achieve high search quality.
   *
   * For more information about filter syntax, see
   * [SearchRequest.filter][google.cloud.discoveryengine.v1.SearchRequest.filter].
   */
  canonicalFilter: string;
  /**
   * The order in which documents are returned. Documents can be ordered by
   * a field in an [Document][google.cloud.discoveryengine.v1.Document] object.
   * Leave it unset if ordered by relevance. `order_by` expression is
   * case-sensitive.
   *
   * For more information on ordering the website search results, see
   * [Order web search
   * results](https://cloud.google.com/generative-ai-app-builder/docs/order-web-search-results).
   * For more information on ordering the healthcare search results, see
   * [Order healthcare search
   * results](https://cloud.google.com/generative-ai-app-builder/docs/order-hc-results).
   * If this field is unrecognizable, an `INVALID_ARGUMENT` is returned.
   */
  orderBy: string;
  /**
   * Information about the end user.
   * Highly recommended for analytics.
   * [UserInfo.user_agent][google.cloud.discoveryengine.v1.UserInfo.user_agent]
   * is used to deduce `device_type` for analytics.
   */
  userInfo:
    | UserInfo
    | undefined;
  /**
   * The BCP-47 language code, such as "en-US" or "sr-Latn". For more
   * information, see [Standard
   * fields](https://cloud.google.com/apis/design/standard_fields). This field
   * helps to better interpret the query. If a value isn't specified, the query
   * language code is automatically detected, which may not be accurate.
   */
  languageCode: string;
  /**
   * Facet specifications for faceted search. If empty, no facets are returned.
   *
   * A maximum of 100 values are allowed. Otherwise, an  `INVALID_ARGUMENT`
   * error is returned.
   */
  facetSpecs: SearchRequest_FacetSpec[];
  /**
   * Boost specification to boost certain documents.
   * For more information on boosting, see
   * [Boosting](https://cloud.google.com/generative-ai-app-builder/docs/boost-search-results)
   */
  boostSpec:
    | SearchRequest_BoostSpec
    | undefined;
  /**
   * Additional search parameters.
   *
   * For public website search only, supported values are:
   *
   * * `user_country_code`: string. Default empty. If set to non-empty, results
   *    are restricted or boosted based on the location provided.
   *    For example, `user_country_code: "au"`
   *
   *    For available codes see [Country
   *    Codes](https://developers.google.com/custom-search/docs/json_api_reference#countryCodes)
   *
   * * `search_type`: double. Default empty. Enables non-webpage searching
   *    depending on the value. The only valid non-default value is 1,
   *    which enables image searching.
   *    For example, `search_type: 1`
   */
  params: { [key: string]: any | undefined };
  /**
   * The query expansion specification that specifies the conditions under which
   * query expansion occurs.
   */
  queryExpansionSpec:
    | SearchRequest_QueryExpansionSpec
    | undefined;
  /**
   * The spell correction specification that specifies the mode under
   * which spell correction takes effect.
   */
  spellCorrectionSpec:
    | SearchRequest_SpellCorrectionSpec
    | undefined;
  /**
   * A unique identifier for tracking visitors. For example, this could be
   * implemented with an HTTP cookie, which should be able to uniquely identify
   * a visitor on a single device. This unique identifier should not change if
   * the visitor logs in or out of the website.
   *
   * This field should NOT have a fixed value such as `unknown_visitor`.
   *
   * This should be the same identifier as
   * [UserEvent.user_pseudo_id][google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id]
   * and
   * [CompleteQueryRequest.user_pseudo_id][google.cloud.discoveryengine.v1.CompleteQueryRequest.user_pseudo_id]
   *
   * The field must be a UTF-8 encoded string with a length limit of 128
   * characters. Otherwise, an  `INVALID_ARGUMENT`  error is returned.
   */
  userPseudoId: string;
  /** A specification for configuring the behavior of content search. */
  contentSearchSpec:
    | SearchRequest_ContentSearchSpec
    | undefined;
  /**
   * Whether to turn on safe search. This is only supported for
   * website search.
   */
  safeSearch: boolean;
  /**
   * The user labels applied to a resource must meet the following requirements:
   *
   * * Each resource can have multiple labels, up to a maximum of 64.
   * * Each label must be a key-value pair.
   * * Keys have a minimum length of 1 character and a maximum length of 63
   *   characters and cannot be empty. Values can be empty and have a maximum
   *   length of 63 characters.
   * * Keys and values can contain only lowercase letters, numeric characters,
   *   underscores, and dashes. All characters must use UTF-8 encoding, and
   *   international characters are allowed.
   * * The key portion of a label must be unique. However, you can use the same
   *   key with multiple resources.
   * * Keys must start with a lowercase letter or international character.
   *
   * See [Google Cloud
   * Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
   * for more details.
   */
  userLabels: { [key: string]: string };
  /**
   * Search as you type configuration. Only supported for the
   * [IndustryVertical.MEDIA][google.cloud.discoveryengine.v1.IndustryVertical.MEDIA]
   * vertical.
   */
  searchAsYouTypeSpec:
    | SearchRequest_SearchAsYouTypeSpec
    | undefined;
  /**
   * The session resource name. Optional.
   *
   * Session allows users to do multi-turn /search API calls or coordination
   * between /search API calls and /answer API calls.
   *
   * Example #1 (multi-turn /search API calls):
   *   1. Call /search API with the auto-session mode (see below).
   *   2. Call /search API with the session ID generated in the first call.
   *      Here, the previous search query gets considered in query
   *      standing. I.e., if the first query is "How did Alphabet do in 2022?"
   *      and the current query is "How about 2023?", the current query will
   *      be interpreted as "How did Alphabet do in 2023?".
   *
   * Example #2 (coordination between /search API calls and /answer API calls):
   *   1. Call /search API with the auto-session mode (see below).
   *   2. Call /answer API with the session ID generated in the first call.
   *      Here, the answer generation happens in the context of the search
   *      results from the first search call.
   *
   * Auto-session mode: when `projects/.../sessions/-` is used, a new session
   * gets automatically created. Otherwise, users can use the create-session API
   * to create a session manually.
   *
   * Multi-turn Search feature is currently at private GA stage. Please use
   * v1alpha or v1beta version instead before we launch this feature to public
   * GA. Or ask for allowlisting through Google Support team.
   */
  session: string;
  /**
   * Session specification.
   *
   * Can be used only when `session` is set.
   */
  sessionSpec: SearchRequest_SessionSpec | undefined;
}

/** Specifies the image query input. */
export interface SearchRequest_ImageQuery {
  /**
   * Base64 encoded image bytes. Supported image formats: JPEG, PNG, and
   * BMP.
   */
  imageBytes?: string | undefined;
}

/**
 * A struct to define data stores to filter on in a search call and
 * configurations for those data stores. Otherwise, an `INVALID_ARGUMENT`
 * error is returned.
 */
export interface SearchRequest_DataStoreSpec {
  /**
   * Required. Full resource name of
   * [DataStore][google.cloud.discoveryengine.v1.DataStore], such as
   * `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
   */
  dataStore: string;
}

/** A facet specification to perform faceted search. */
export interface SearchRequest_FacetSpec {
  /** Required. The facet key specification. */
  facetKey:
    | SearchRequest_FacetSpec_FacetKey
    | undefined;
  /**
   * Maximum facet values that are returned for this facet. If
   * unspecified, defaults to 20. The maximum allowed value is 300. Values
   * above 300 are coerced to 300.
   * For aggregation in healthcare search, when the [FacetKey.key] is
   * "healthcare_aggregation_key", the limit will be overridden to
   * 10,000 internally, regardless of the value set here.
   *
   * If this field is negative, an  `INVALID_ARGUMENT`  is returned.
   */
  limit: number;
  /**
   * List of keys to exclude when faceting.
   *
   * By default,
   * [FacetKey.key][google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.key]
   * is not excluded from the filter unless it is listed in this field.
   *
   * Listing a facet key in this field allows its values to appear as facet
   * results, even when they are filtered out of search results. Using this
   * field does not affect what search results are returned.
   *
   * For example, suppose there are 100 documents with the color facet "Red"
   * and 200 documents with the color facet "Blue". A query containing the
   * filter "color:ANY("Red")" and having "color" as
   * [FacetKey.key][google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.key]
   * would by default return only "Red" documents in the search results, and
   * also return "Red" with count 100 as the only color facet. Although there
   * are also blue documents available, "Blue" would not be shown as an
   * available facet value.
   *
   * If "color" is listed in "excludedFilterKeys", then the query returns the
   * facet values "Red" with count 100 and "Blue" with count 200, because the
   * "color" key is now excluded from the filter. Because this field doesn't
   * affect search results, the search results are still correctly filtered to
   * return only "Red" documents.
   *
   * A maximum of 100 values are allowed. Otherwise, an  `INVALID_ARGUMENT`
   * error is returned.
   */
  excludedFilterKeys: string[];
  /**
   * Enables dynamic position for this facet. If set to true, the position of
   * this facet among all facets in the response is determined automatically.
   * If dynamic facets are enabled, it is ordered together.
   * If set to false, the position of this facet in the
   * response is the same as in the request, and it is ranked before
   * the facets with dynamic position enable and all dynamic facets.
   *
   * For example, you may always want to have rating facet returned in
   * the response, but it's not necessarily to always display the rating facet
   * at the top. In that case, you can set enable_dynamic_position to true so
   * that the position of rating facet in response is determined
   * automatically.
   *
   * Another example, assuming you have the following facets in the request:
   *
   * * "rating", enable_dynamic_position = true
   *
   * * "price", enable_dynamic_position = false
   *
   * * "brands", enable_dynamic_position = false
   *
   * And also you have a dynamic facets enabled, which generates a facet
   * `gender`. Then the final order of the facets in the response can be
   * ("price", "brands", "rating", "gender") or ("price", "brands", "gender",
   * "rating") depends on how API orders "gender" and "rating" facets.
   * However, notice that "price" and "brands" are always
   * ranked at first and second position because their enable_dynamic_position
   * is false.
   */
  enableDynamicPosition: boolean;
}

/** Specifies how a facet is computed. */
export interface SearchRequest_FacetSpec_FacetKey {
  /**
   * Required. Supported textual and numerical facet keys in
   * [Document][google.cloud.discoveryengine.v1.Document] object, over which
   * the facet values are computed. Facet key is case-sensitive.
   */
  key: string;
  /**
   * Set only if values should be bucketed into intervals. Must be set
   * for facets with numerical values. Must not be set for facet with text
   * values. Maximum number of intervals is 30.
   */
  intervals: Interval[];
  /**
   * Only get facet for the given restricted values. Only supported on
   * textual fields. For example, suppose "category" has three values
   * "Action > 2022", "Action > 2021" and "Sci-Fi > 2022". If set
   * "restricted_values" to "Action > 2022", the "category" facet only
   * contains "Action > 2022". Only supported on textual fields. Maximum
   * is 10.
   */
  restrictedValues: string[];
  /**
   * Only get facet values that start with the given string prefix. For
   * example, suppose "category" has three values "Action > 2022",
   * "Action > 2021" and "Sci-Fi > 2022". If set "prefixes" to "Action", the
   * "category" facet only contains "Action > 2022" and "Action > 2021".
   * Only supported on textual fields. Maximum is 10.
   */
  prefixes: string[];
  /**
   * Only get facet values that contain the given strings. For example,
   * suppose "category" has three values "Action > 2022",
   * "Action > 2021" and "Sci-Fi > 2022". If set "contains" to "2022", the
   * "category" facet only contains "Action > 2022" and "Sci-Fi > 2022".
   * Only supported on textual fields. Maximum is 10.
   */
  contains: string[];
  /**
   * True to make facet keys case insensitive when getting faceting
   * values with prefixes or contains; false otherwise.
   */
  caseInsensitive: boolean;
  /**
   * The order in which documents are returned.
   *
   * Allowed values are:
   *
   * * "count desc", which means order by
   * [SearchResponse.Facet.values.count][google.cloud.discoveryengine.v1.SearchResponse.Facet.FacetValue.count]
   * descending.
   *
   * * "value desc", which means order by
   * [SearchResponse.Facet.values.value][google.cloud.discoveryengine.v1.SearchResponse.Facet.FacetValue.value]
   * descending.
   *   Only applies to textual facets.
   *
   * If not set, textual values are sorted in [natural
   * order](https://en.wikipedia.org/wiki/Natural_sort_order); numerical
   * intervals are sorted in the order given by
   * [FacetSpec.FacetKey.intervals][google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.intervals].
   */
  orderBy: string;
}

/** Boost specification to boost certain documents. */
export interface SearchRequest_BoostSpec {
  /**
   * Condition boost specifications. If a document matches multiple conditions
   * in the specifictions, boost scores from these specifications are all
   * applied and combined in a non-linear way. Maximum number of
   * specifications is 20.
   */
  conditionBoostSpecs: SearchRequest_BoostSpec_ConditionBoostSpec[];
}

/** Boost applies to documents which match a condition. */
export interface SearchRequest_BoostSpec_ConditionBoostSpec {
  /**
   * An expression which specifies a boost condition. The syntax and
   * supported fields are the same as a filter expression. See
   * [SearchRequest.filter][google.cloud.discoveryengine.v1.SearchRequest.filter]
   * for detail syntax and limitations.
   *
   * Examples:
   *
   * * To boost documents with document ID "doc_1" or "doc_2", and
   * color "Red" or "Blue":
   * `(document_id: ANY("doc_1", "doc_2")) AND (color: ANY("Red", "Blue"))`
   */
  condition: string;
  /**
   * Strength of the condition boost, which should be in [-1, 1]. Negative
   * boost means demotion. Default is 0.0.
   *
   * Setting to 1.0 gives the document a big promotion. However, it does
   * not necessarily mean that the boosted document will be the top result
   * at all times, nor that other documents will be excluded. Results
   * could still be shown even when none of them matches the condition.
   * And results that are significantly more relevant to the search query
   * can still trump your heavily favored but irrelevant documents.
   *
   * Setting to -1.0 gives the document a big demotion. However, results
   * that are deeply relevant might still be shown. The document will have
   * an upstream battle to get a fairly high ranking, but it is not
   * blocked out completely.
   *
   * Setting to 0.0 means no boost applied. The boosting condition is
   * ignored. Only one of the (condition, boost) combination or the
   * boost_control_spec below are set. If both are set then the global boost
   * is ignored and the more fine-grained boost_control_spec is applied.
   */
  boost: number;
}

/**
 * Specification to determine under which conditions query expansion should
 * occur.
 */
export interface SearchRequest_QueryExpansionSpec {
  /**
   * The condition under which query expansion should occur. Default to
   * [Condition.DISABLED][google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec.Condition.DISABLED].
   */
  condition: SearchRequest_QueryExpansionSpec_Condition;
  /**
   * Whether to pin unexpanded results. If this field is set to true,
   * unexpanded products are always at the top of the search results, followed
   * by the expanded results.
   */
  pinUnexpandedResults: boolean;
}

/** Enum describing under which condition query expansion should occur. */
export enum SearchRequest_QueryExpansionSpec_Condition {
  /**
   * CONDITION_UNSPECIFIED - Unspecified query expansion condition. In this case, server behavior
   * defaults to
   * [Condition.DISABLED][google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec.Condition.DISABLED].
   */
  CONDITION_UNSPECIFIED = 0,
  /**
   * DISABLED - Disabled query expansion. Only the exact search query is used, even if
   * [SearchResponse.total_size][google.cloud.discoveryengine.v1.SearchResponse.total_size]
   * is zero.
   */
  DISABLED = 1,
  /** AUTO - Automatic query expansion built by the Search API. */
  AUTO = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_QueryExpansionSpec_ConditionFromJSON(
  object: any,
): SearchRequest_QueryExpansionSpec_Condition {
  switch (object) {
    case 0:
    case "CONDITION_UNSPECIFIED":
      return SearchRequest_QueryExpansionSpec_Condition.CONDITION_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return SearchRequest_QueryExpansionSpec_Condition.DISABLED;
    case 2:
    case "AUTO":
      return SearchRequest_QueryExpansionSpec_Condition.AUTO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_QueryExpansionSpec_Condition.UNRECOGNIZED;
  }
}

export function searchRequest_QueryExpansionSpec_ConditionToJSON(
  object: SearchRequest_QueryExpansionSpec_Condition,
): string {
  switch (object) {
    case SearchRequest_QueryExpansionSpec_Condition.CONDITION_UNSPECIFIED:
      return "CONDITION_UNSPECIFIED";
    case SearchRequest_QueryExpansionSpec_Condition.DISABLED:
      return "DISABLED";
    case SearchRequest_QueryExpansionSpec_Condition.AUTO:
      return "AUTO";
    case SearchRequest_QueryExpansionSpec_Condition.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The specification for query spell correction. */
export interface SearchRequest_SpellCorrectionSpec {
  /**
   * The mode under which spell correction
   * replaces the original search query. Defaults to
   * [Mode.AUTO][google.cloud.discoveryengine.v1.SearchRequest.SpellCorrectionSpec.Mode.AUTO].
   */
  mode: SearchRequest_SpellCorrectionSpec_Mode;
}

/** Enum describing under which mode spell correction should occur. */
export enum SearchRequest_SpellCorrectionSpec_Mode {
  /**
   * MODE_UNSPECIFIED - Unspecified spell correction mode. In this case, server behavior
   * defaults to
   * [Mode.AUTO][google.cloud.discoveryengine.v1.SearchRequest.SpellCorrectionSpec.Mode.AUTO].
   */
  MODE_UNSPECIFIED = 0,
  /**
   * SUGGESTION_ONLY - Search API tries to find a spelling suggestion. If a suggestion is
   * found, it is put in the
   * [SearchResponse.corrected_query][google.cloud.discoveryengine.v1.SearchResponse.corrected_query].
   * The spelling suggestion won't be used as the search query.
   */
  SUGGESTION_ONLY = 1,
  /**
   * AUTO - Automatic spell correction built by the Search API. Search will
   * be based on the corrected query if found.
   */
  AUTO = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_SpellCorrectionSpec_ModeFromJSON(object: any): SearchRequest_SpellCorrectionSpec_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return SearchRequest_SpellCorrectionSpec_Mode.MODE_UNSPECIFIED;
    case 1:
    case "SUGGESTION_ONLY":
      return SearchRequest_SpellCorrectionSpec_Mode.SUGGESTION_ONLY;
    case 2:
    case "AUTO":
      return SearchRequest_SpellCorrectionSpec_Mode.AUTO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_SpellCorrectionSpec_Mode.UNRECOGNIZED;
  }
}

export function searchRequest_SpellCorrectionSpec_ModeToJSON(object: SearchRequest_SpellCorrectionSpec_Mode): string {
  switch (object) {
    case SearchRequest_SpellCorrectionSpec_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case SearchRequest_SpellCorrectionSpec_Mode.SUGGESTION_ONLY:
      return "SUGGESTION_ONLY";
    case SearchRequest_SpellCorrectionSpec_Mode.AUTO:
      return "AUTO";
    case SearchRequest_SpellCorrectionSpec_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A specification for configuring the behavior of content search. */
export interface SearchRequest_ContentSearchSpec {
  /**
   * If `snippetSpec` is not specified, snippets are not included in the
   * search response.
   */
  snippetSpec:
    | SearchRequest_ContentSearchSpec_SnippetSpec
    | undefined;
  /**
   * If `summarySpec` is not specified, summaries are not included in the
   * search response.
   */
  summarySpec:
    | SearchRequest_ContentSearchSpec_SummarySpec
    | undefined;
  /**
   * If there is no extractive_content_spec provided, there will be no
   * extractive answer in the search response.
   */
  extractiveContentSpec:
    | SearchRequest_ContentSearchSpec_ExtractiveContentSpec
    | undefined;
  /**
   * Specifies the search result mode. If unspecified, the
   * search result mode defaults to `DOCUMENTS`.
   */
  searchResultMode: SearchRequest_ContentSearchSpec_SearchResultMode;
  /**
   * Specifies the chunk spec to be returned from the search response.
   * Only available if the
   * [SearchRequest.ContentSearchSpec.search_result_mode][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode]
   * is set to
   * [CHUNKS][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS]
   */
  chunkSpec: SearchRequest_ContentSearchSpec_ChunkSpec | undefined;
}

/**
 * Specifies the search result mode. If unspecified, the
 * search result mode defaults to `DOCUMENTS`.
 */
export enum SearchRequest_ContentSearchSpec_SearchResultMode {
  /** SEARCH_RESULT_MODE_UNSPECIFIED - Default value. */
  SEARCH_RESULT_MODE_UNSPECIFIED = 0,
  /** DOCUMENTS - Returns documents in the search result. */
  DOCUMENTS = 1,
  /**
   * CHUNKS - Returns chunks in the search result. Only available if the
   * [DataStore.DocumentProcessingConfig.chunking_config][] is specified.
   */
  CHUNKS = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_ContentSearchSpec_SearchResultModeFromJSON(
  object: any,
): SearchRequest_ContentSearchSpec_SearchResultMode {
  switch (object) {
    case 0:
    case "SEARCH_RESULT_MODE_UNSPECIFIED":
      return SearchRequest_ContentSearchSpec_SearchResultMode.SEARCH_RESULT_MODE_UNSPECIFIED;
    case 1:
    case "DOCUMENTS":
      return SearchRequest_ContentSearchSpec_SearchResultMode.DOCUMENTS;
    case 2:
    case "CHUNKS":
      return SearchRequest_ContentSearchSpec_SearchResultMode.CHUNKS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_ContentSearchSpec_SearchResultMode.UNRECOGNIZED;
  }
}

export function searchRequest_ContentSearchSpec_SearchResultModeToJSON(
  object: SearchRequest_ContentSearchSpec_SearchResultMode,
): string {
  switch (object) {
    case SearchRequest_ContentSearchSpec_SearchResultMode.SEARCH_RESULT_MODE_UNSPECIFIED:
      return "SEARCH_RESULT_MODE_UNSPECIFIED";
    case SearchRequest_ContentSearchSpec_SearchResultMode.DOCUMENTS:
      return "DOCUMENTS";
    case SearchRequest_ContentSearchSpec_SearchResultMode.CHUNKS:
      return "CHUNKS";
    case SearchRequest_ContentSearchSpec_SearchResultMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A specification for configuring snippets in a search response. */
export interface SearchRequest_ContentSearchSpec_SnippetSpec {
  /**
   * [DEPRECATED] This field is deprecated. To control snippet return, use
   * `return_snippet` field. For backwards compatibility, we will return
   * snippet if max_snippet_count > 0.
   *
   * @deprecated
   */
  maxSnippetCount: number;
  /**
   * [DEPRECATED] This field is deprecated and will have no affect on the
   * snippet.
   *
   * @deprecated
   */
  referenceOnly: boolean;
  /**
   * If `true`, then return snippet. If no snippet can be generated, we
   * return "No snippet is available for this page." A `snippet_status` with
   * `SUCCESS` or `NO_SNIPPET_AVAILABLE` will also be returned.
   */
  returnSnippet: boolean;
}

/**
 * A specification for configuring a summary returned in a search
 * response.
 */
export interface SearchRequest_ContentSearchSpec_SummarySpec {
  /**
   * The number of top results to generate the summary from. If the number
   * of results returned is less than `summaryResultCount`, the summary is
   * generated from all of the results.
   *
   * At most 10 results for documents mode, or 50 for chunks mode, can be
   * used to generate a summary. The chunks mode is used when
   * [SearchRequest.ContentSearchSpec.search_result_mode][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode]
   * is set to
   * [CHUNKS][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS].
   */
  summaryResultCount: number;
  /**
   * Specifies whether to include citations in the summary. The default
   * value is `false`.
   *
   * When this field is set to `true`, summaries include in-line citation
   * numbers.
   *
   * Example summary including citations:
   *
   * BigQuery is Google Cloud's fully managed and completely serverless
   * enterprise data warehouse [1]. BigQuery supports all data types, works
   * across clouds, and has built-in machine learning and business
   * intelligence, all within a unified platform [2, 3].
   *
   * The citation numbers refer to the returned search results and are
   * 1-indexed. For example, [1] means that the sentence is attributed to
   * the first search result. [2, 3] means that the sentence is attributed
   * to both the second and third search results.
   */
  includeCitations: boolean;
  /**
   * Specifies whether to filter out adversarial queries. The default value
   * is `false`.
   *
   * Google employs search-query classification to detect adversarial
   * queries. No summary is returned if the search query is classified as an
   * adversarial query. For example, a user might ask a question regarding
   * negative comments about the company or submit a query designed to
   * generate unsafe, policy-violating output. If this field is set to
   * `true`, we skip generating summaries for adversarial queries and return
   * fallback messages instead.
   */
  ignoreAdversarialQuery: boolean;
  /**
   * Specifies whether to filter out queries that are not summary-seeking.
   * The default value is `false`.
   *
   * Google employs search-query classification to detect summary-seeking
   * queries. No summary is returned if the search query is classified as a
   * non-summary seeking query. For example, `why is the sky blue` and `Who
   * is the best soccer player in the world?` are summary-seeking queries,
   * but `SFO airport` and `world cup 2026` are not. They are most likely
   * navigational queries. If this field is set to `true`, we skip
   * generating summaries for non-summary seeking queries and return
   * fallback messages instead.
   */
  ignoreNonSummarySeekingQuery: boolean;
  /**
   * Specifies whether to filter out queries that have low relevance. The
   * default value is `false`.
   *
   * If this field is set to `false`, all search results are used regardless
   * of relevance to generate answers. If set to `true`, only queries with
   * high relevance search results will generate answers.
   */
  ignoreLowRelevantContent: boolean;
  /**
   * If specified, the spec will be used to modify the prompt provided to
   * the LLM.
   */
  modelPromptSpec:
    | SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec
    | undefined;
  /**
   * Language code for Summary. Use language tags defined by
   * [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt).
   * Note: This is an experimental feature.
   */
  languageCode: string;
  /**
   * If specified, the spec will be used to modify the model specification
   * provided to the LLM.
   */
  modelSpec:
    | SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec
    | undefined;
  /**
   * If true, answer will be generated from most relevant chunks from top
   * search results. This feature will improve summary quality.
   * Note that with this feature enabled, not all top search results
   * will be referenced and included in the reference list, so the citation
   * source index only points to the search results listed in the reference
   * list.
   */
  useSemanticChunks: boolean;
}

/** Specification of the prompt to use with the model. */
export interface SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec {
  /**
   * Text at the beginning of the prompt that instructs the assistant.
   * Examples are available in the user guide.
   */
  preamble: string;
}

/** Specification of the model. */
export interface SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec {
  /**
   * The model version used to generate the summary.
   *
   * Supported values are:
   *
   * * `stable`: string. Default value when no value is specified. Uses a
   *    generally available, fine-tuned model. For more information, see
   *    [Answer generation model versions and
   *    lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models).
   * * `preview`: string. (Public preview) Uses a preview model. For more
   *    information, see
   *    [Answer generation model versions and
   *    lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models).
   */
  version: string;
}

/**
 * A specification for configuring the extractive content in a search
 * response.
 */
export interface SearchRequest_ContentSearchSpec_ExtractiveContentSpec {
  /**
   * The maximum number of extractive answers returned in each search
   * result.
   *
   * An extractive answer is a verbatim answer extracted from the original
   * document, which provides a precise and contextually relevant answer to
   * the search query.
   *
   * If the number of matching answers is less than the
   * `max_extractive_answer_count`, return all of the answers. Otherwise,
   * return the `max_extractive_answer_count`.
   *
   * At most five answers are returned for each
   * [SearchResult][google.cloud.discoveryengine.v1.SearchResponse.SearchResult].
   */
  maxExtractiveAnswerCount: number;
  /**
   * The max number of extractive segments returned in each search result.
   * Only applied if the
   * [DataStore][google.cloud.discoveryengine.v1.DataStore] is set to
   * [DataStore.ContentConfig.CONTENT_REQUIRED][google.cloud.discoveryengine.v1.DataStore.ContentConfig.CONTENT_REQUIRED]
   * or
   * [DataStore.solution_types][google.cloud.discoveryengine.v1.DataStore.solution_types]
   * is
   * [SOLUTION_TYPE_CHAT][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_CHAT].
   *
   * An extractive segment is a text segment extracted from the original
   * document that is relevant to the search query, and, in general, more
   * verbose than an extractive answer. The segment could then be used as
   * input for LLMs to generate summaries and answers.
   *
   * If the number of matching segments is less than
   * `max_extractive_segment_count`, return all of the segments. Otherwise,
   * return the `max_extractive_segment_count`.
   */
  maxExtractiveSegmentCount: number;
  /**
   * Specifies whether to return the confidence score from the extractive
   * segments in each search result. This feature is available only for new
   * or allowlisted data stores. To allowlist your data store,
   * contact your Customer Engineer. The default value is `false`.
   */
  returnExtractiveSegmentScore: boolean;
  /**
   * Specifies whether to also include the adjacent from each selected
   * segments.
   * Return at most `num_previous_segments` segments before each selected
   * segments.
   */
  numPreviousSegments: number;
  /**
   * Return at most `num_next_segments` segments after each selected
   * segments.
   */
  numNextSegments: number;
}

/**
 * Specifies the chunk spec to be returned from the search response.
 * Only available if the
 * [SearchRequest.ContentSearchSpec.search_result_mode][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode]
 * is set to
 * [CHUNKS][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS]
 */
export interface SearchRequest_ContentSearchSpec_ChunkSpec {
  /**
   * The number of previous chunks to be returned of the current chunk. The
   * maximum allowed value is 3.
   * If not specified, no previous chunks will be returned.
   */
  numPreviousChunks: number;
  /**
   * The number of next chunks to be returned of the current chunk. The
   * maximum allowed value is 3.
   * If not specified, no next chunks will be returned.
   */
  numNextChunks: number;
}

/** Specification for search as you type in search requests. */
export interface SearchRequest_SearchAsYouTypeSpec {
  /**
   * The condition under which search as you type should occur.
   * Default to
   * [Condition.DISABLED][google.cloud.discoveryengine.v1.SearchRequest.SearchAsYouTypeSpec.Condition.DISABLED].
   */
  condition: SearchRequest_SearchAsYouTypeSpec_Condition;
}

/** Enum describing under which condition search as you type should occur. */
export enum SearchRequest_SearchAsYouTypeSpec_Condition {
  /**
   * CONDITION_UNSPECIFIED - Server behavior defaults to
   * [Condition.DISABLED][google.cloud.discoveryengine.v1.SearchRequest.SearchAsYouTypeSpec.Condition.DISABLED].
   */
  CONDITION_UNSPECIFIED = 0,
  /** DISABLED - Disables Search As You Type. */
  DISABLED = 1,
  /** ENABLED - Enables Search As You Type. */
  ENABLED = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_SearchAsYouTypeSpec_ConditionFromJSON(
  object: any,
): SearchRequest_SearchAsYouTypeSpec_Condition {
  switch (object) {
    case 0:
    case "CONDITION_UNSPECIFIED":
      return SearchRequest_SearchAsYouTypeSpec_Condition.CONDITION_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return SearchRequest_SearchAsYouTypeSpec_Condition.DISABLED;
    case 2:
    case "ENABLED":
      return SearchRequest_SearchAsYouTypeSpec_Condition.ENABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_SearchAsYouTypeSpec_Condition.UNRECOGNIZED;
  }
}

export function searchRequest_SearchAsYouTypeSpec_ConditionToJSON(
  object: SearchRequest_SearchAsYouTypeSpec_Condition,
): string {
  switch (object) {
    case SearchRequest_SearchAsYouTypeSpec_Condition.CONDITION_UNSPECIFIED:
      return "CONDITION_UNSPECIFIED";
    case SearchRequest_SearchAsYouTypeSpec_Condition.DISABLED:
      return "DISABLED";
    case SearchRequest_SearchAsYouTypeSpec_Condition.ENABLED:
      return "ENABLED";
    case SearchRequest_SearchAsYouTypeSpec_Condition.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Session specification.
 *
 * Multi-turn Search feature is currently at private GA stage. Please use
 * v1alpha or v1beta version instead before we launch this feature to public
 * GA. Or ask for allowlisting through Google Support team.
 */
export interface SearchRequest_SessionSpec {
  /**
   * If set, the search result gets stored to the "turn" specified by this
   * query ID.
   *
   * Example: Let's say the session looks like this:
   *   session {
   *     name: ".../sessions/xxx"
   *     turns {
   *       query { text: "What is foo?" query_id: ".../questions/yyy" }
   *       answer: "Foo is ..."
   *     }
   *     turns {
   *       query { text: "How about bar then?" query_id: ".../questions/zzz" }
   *     }
   *   }
   *
   * The user can call /search API with a request like this:
   *
   *    session: ".../sessions/xxx"
   *    session_spec { query_id: ".../questions/zzz" }
   *
   * Then, the API stores the search result, associated with the last turn.
   * The stored search result can be used by a subsequent /answer API call
   * (with the session ID and the query ID specified). Also, it is possible
   * to call /search and /answer in parallel with the same session ID & query
   * ID.
   */
  queryId: string;
  /**
   * The number of top search results to persist. The persisted search results
   * can be used for the subsequent /answer api call.
   *
   * This field is simliar to the `summary_result_count` field in
   * [SearchRequest.ContentSearchSpec.SummarySpec.summary_result_count][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.summary_result_count].
   *
   * At most 10 results for documents mode, or 50 for chunks mode.
   */
  searchResultPersistenceCount?: number | undefined;
}

export interface SearchRequest_ParamsEntry {
  key: string;
  value: any | undefined;
}

export interface SearchRequest_UserLabelsEntry {
  key: string;
  value: string;
}

/**
 * Response message for
 * [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search]
 * method.
 */
export interface SearchResponse {
  /** A list of matched documents. The order represents the ranking. */
  results: SearchResponse_SearchResult[];
  /** Results of facets requested by user. */
  facets: SearchResponse_Facet[];
  /**
   * The estimated total count of matched items irrespective of pagination. The
   * count of [results][google.cloud.discoveryengine.v1.SearchResponse.results]
   * returned by pagination may be less than the
   * [total_size][google.cloud.discoveryengine.v1.SearchResponse.total_size]
   * that matches.
   */
  totalSize: number;
  /**
   * A unique search token. This should be included in the
   * [UserEvent][google.cloud.discoveryengine.v1.UserEvent] logs resulting from
   * this search, which enables accurate attribution of search model
   * performance. This also helps to identify a request during the customer
   * support scenarios.
   */
  attributionToken: string;
  /**
   * The URI of a customer-defined redirect page. If redirect action is
   * triggered, no search is performed, and only
   * [redirect_uri][google.cloud.discoveryengine.v1.SearchResponse.redirect_uri]
   * and
   * [attribution_token][google.cloud.discoveryengine.v1.SearchResponse.attribution_token]
   * are set in the response.
   */
  redirectUri: string;
  /**
   * A token that can be sent as
   * [SearchRequest.page_token][google.cloud.discoveryengine.v1.SearchRequest.page_token]
   * to retrieve the next page. If this field is omitted, there are no
   * subsequent pages.
   */
  nextPageToken: string;
  /**
   * Contains the spell corrected query, if found. If the spell correction type
   * is AUTOMATIC, then the search results are based on corrected_query.
   * Otherwise the original query is used for search.
   */
  correctedQuery: string;
  /**
   * A summary as part of the search results.
   * This field is only returned if
   * [SearchRequest.ContentSearchSpec.summary_spec][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.summary_spec]
   * is set.
   */
  summary:
    | SearchResponse_Summary
    | undefined;
  /** Query expansion information for the returned results. */
  queryExpansionInfo:
    | SearchResponse_QueryExpansionInfo
    | undefined;
  /**
   * Session information.
   *
   * Only set if
   * [SearchRequest.session][google.cloud.discoveryengine.v1.SearchRequest.session]
   * is provided. See its description for more details.
   */
  sessionInfo: SearchResponse_SessionInfo | undefined;
}

/** Represents the search results. */
export interface SearchResponse_SearchResult {
  /**
   * [Document.id][google.cloud.discoveryengine.v1.Document.id] of the
   * searched [Document][google.cloud.discoveryengine.v1.Document].
   */
  id: string;
  /**
   * The document data snippet in the search response. Only fields that are
   * marked as `retrievable` are populated.
   */
  document:
    | Document
    | undefined;
  /**
   * The chunk data in the search response if the
   * [SearchRequest.ContentSearchSpec.search_result_mode][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode]
   * is set to
   * [CHUNKS][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS].
   */
  chunk: Chunk | undefined;
}

/** A facet result. */
export interface SearchResponse_Facet {
  /**
   * The key for this facet. For example, `"colors"` or `"price"`. It matches
   * [SearchRequest.FacetSpec.FacetKey.key][google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.key].
   */
  key: string;
  /** The facet values for this field. */
  values: SearchResponse_Facet_FacetValue[];
  /** Whether the facet is dynamically generated. */
  dynamicFacet: boolean;
}

/** A facet value which contains value names and their count. */
export interface SearchResponse_Facet_FacetValue {
  /** Text value of a facet, such as "Black" for facet "colors". */
  value?:
    | string
    | undefined;
  /**
   * Interval value for a facet, such as [10, 20) for facet "price". It
   * matches
   * [SearchRequest.FacetSpec.FacetKey.intervals][google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.intervals].
   */
  interval?:
    | Interval
    | undefined;
  /** Number of items that have this facet value. */
  count: Long;
}

/** Summary of the top N search results specified by the summary spec. */
export interface SearchResponse_Summary {
  /** The summary content. */
  summaryText: string;
  /**
   * Additional summary-skipped reasons. This provides the reason for ignored
   * cases. If nothing is skipped, this field is not set.
   */
  summarySkippedReasons: SearchResponse_Summary_SummarySkippedReason[];
  /**
   * A collection of Safety Attribute categories and their associated
   * confidence scores.
   */
  safetyAttributes:
    | SearchResponse_Summary_SafetyAttributes
    | undefined;
  /** Summary with metadata information. */
  summaryWithMetadata: SearchResponse_Summary_SummaryWithMetadata | undefined;
}

/** An Enum for summary-skipped reasons. */
export enum SearchResponse_Summary_SummarySkippedReason {
  /** SUMMARY_SKIPPED_REASON_UNSPECIFIED - Default value. The summary skipped reason is not specified. */
  SUMMARY_SKIPPED_REASON_UNSPECIFIED = 0,
  /**
   * ADVERSARIAL_QUERY_IGNORED - The adversarial query ignored case.
   *
   * Only used when
   * [SummarySpec.ignore_adversarial_query][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.ignore_adversarial_query]
   * is set to `true`.
   */
  ADVERSARIAL_QUERY_IGNORED = 1,
  /**
   * NON_SUMMARY_SEEKING_QUERY_IGNORED - The non-summary seeking query ignored case.
   *
   * Only used when
   * [SummarySpec.ignore_non_summary_seeking_query][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.ignore_non_summary_seeking_query]
   * is set to `true`.
   */
  NON_SUMMARY_SEEKING_QUERY_IGNORED = 2,
  /**
   * OUT_OF_DOMAIN_QUERY_IGNORED - The out-of-domain query ignored case.
   *
   * Google skips the summary if there are no high-relevance search results.
   * For example, the data store contains facts about company A but the
   * user query is asking questions about company B.
   */
  OUT_OF_DOMAIN_QUERY_IGNORED = 3,
  /**
   * POTENTIAL_POLICY_VIOLATION - The potential policy violation case.
   *
   * Google skips the summary if there is a potential policy violation
   * detected. This includes content that may be violent or toxic.
   */
  POTENTIAL_POLICY_VIOLATION = 4,
  /**
   * LLM_ADDON_NOT_ENABLED - The LLM addon not enabled case.
   *
   * Google skips the summary if the LLM addon is not enabled.
   */
  LLM_ADDON_NOT_ENABLED = 5,
  /**
   * NO_RELEVANT_CONTENT - The no relevant content case.
   *
   * Google skips the summary if there is no relevant content in the
   * retrieved search results.
   */
  NO_RELEVANT_CONTENT = 6,
  /**
   * JAIL_BREAKING_QUERY_IGNORED - The jail-breaking query ignored case.
   *
   * For example, "Reply in the tone of a competing company's CEO".
   * Only used when
   * [SearchRequest.ContentSearchSpec.SummarySpec.ignore_jail_breaking_query]
   * is set to `true`.
   */
  JAIL_BREAKING_QUERY_IGNORED = 7,
  /**
   * CUSTOMER_POLICY_VIOLATION - The customer policy violation case.
   *
   * Google skips the summary if there is a customer policy violation
   * detected. The policy is defined by the customer.
   */
  CUSTOMER_POLICY_VIOLATION = 8,
  UNRECOGNIZED = -1,
}

export function searchResponse_Summary_SummarySkippedReasonFromJSON(
  object: any,
): SearchResponse_Summary_SummarySkippedReason {
  switch (object) {
    case 0:
    case "SUMMARY_SKIPPED_REASON_UNSPECIFIED":
      return SearchResponse_Summary_SummarySkippedReason.SUMMARY_SKIPPED_REASON_UNSPECIFIED;
    case 1:
    case "ADVERSARIAL_QUERY_IGNORED":
      return SearchResponse_Summary_SummarySkippedReason.ADVERSARIAL_QUERY_IGNORED;
    case 2:
    case "NON_SUMMARY_SEEKING_QUERY_IGNORED":
      return SearchResponse_Summary_SummarySkippedReason.NON_SUMMARY_SEEKING_QUERY_IGNORED;
    case 3:
    case "OUT_OF_DOMAIN_QUERY_IGNORED":
      return SearchResponse_Summary_SummarySkippedReason.OUT_OF_DOMAIN_QUERY_IGNORED;
    case 4:
    case "POTENTIAL_POLICY_VIOLATION":
      return SearchResponse_Summary_SummarySkippedReason.POTENTIAL_POLICY_VIOLATION;
    case 5:
    case "LLM_ADDON_NOT_ENABLED":
      return SearchResponse_Summary_SummarySkippedReason.LLM_ADDON_NOT_ENABLED;
    case 6:
    case "NO_RELEVANT_CONTENT":
      return SearchResponse_Summary_SummarySkippedReason.NO_RELEVANT_CONTENT;
    case 7:
    case "JAIL_BREAKING_QUERY_IGNORED":
      return SearchResponse_Summary_SummarySkippedReason.JAIL_BREAKING_QUERY_IGNORED;
    case 8:
    case "CUSTOMER_POLICY_VIOLATION":
      return SearchResponse_Summary_SummarySkippedReason.CUSTOMER_POLICY_VIOLATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchResponse_Summary_SummarySkippedReason.UNRECOGNIZED;
  }
}

export function searchResponse_Summary_SummarySkippedReasonToJSON(
  object: SearchResponse_Summary_SummarySkippedReason,
): string {
  switch (object) {
    case SearchResponse_Summary_SummarySkippedReason.SUMMARY_SKIPPED_REASON_UNSPECIFIED:
      return "SUMMARY_SKIPPED_REASON_UNSPECIFIED";
    case SearchResponse_Summary_SummarySkippedReason.ADVERSARIAL_QUERY_IGNORED:
      return "ADVERSARIAL_QUERY_IGNORED";
    case SearchResponse_Summary_SummarySkippedReason.NON_SUMMARY_SEEKING_QUERY_IGNORED:
      return "NON_SUMMARY_SEEKING_QUERY_IGNORED";
    case SearchResponse_Summary_SummarySkippedReason.OUT_OF_DOMAIN_QUERY_IGNORED:
      return "OUT_OF_DOMAIN_QUERY_IGNORED";
    case SearchResponse_Summary_SummarySkippedReason.POTENTIAL_POLICY_VIOLATION:
      return "POTENTIAL_POLICY_VIOLATION";
    case SearchResponse_Summary_SummarySkippedReason.LLM_ADDON_NOT_ENABLED:
      return "LLM_ADDON_NOT_ENABLED";
    case SearchResponse_Summary_SummarySkippedReason.NO_RELEVANT_CONTENT:
      return "NO_RELEVANT_CONTENT";
    case SearchResponse_Summary_SummarySkippedReason.JAIL_BREAKING_QUERY_IGNORED:
      return "JAIL_BREAKING_QUERY_IGNORED";
    case SearchResponse_Summary_SummarySkippedReason.CUSTOMER_POLICY_VIOLATION:
      return "CUSTOMER_POLICY_VIOLATION";
    case SearchResponse_Summary_SummarySkippedReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Safety Attribute categories and their associated confidence scores. */
export interface SearchResponse_Summary_SafetyAttributes {
  /**
   * The display names of Safety Attribute categories associated with the
   * generated content. Order matches the Scores.
   */
  categories: string[];
  /**
   * The confidence scores of the each category, higher
   * value means higher confidence. Order matches the Categories.
   */
  scores: number[];
}

/** Citation metadata. */
export interface SearchResponse_Summary_CitationMetadata {
  /** Citations for segments. */
  citations: SearchResponse_Summary_Citation[];
}

/** Citation info for a segment. */
export interface SearchResponse_Summary_Citation {
  /** Index indicates the start of the segment, measured in bytes/unicode. */
  startIndex: Long;
  /** End of the attributed segment, exclusive. */
  endIndex: Long;
  /** Citation sources for the attributed segment. */
  sources: SearchResponse_Summary_CitationSource[];
}

/** Citation source. */
export interface SearchResponse_Summary_CitationSource {
  /**
   * Document reference index from SummaryWithMetadata.references.
   * It is 0-indexed and the value will be zero if the reference_index is
   * not set explicitly.
   */
  referenceIndex: Long;
}

/** Document reference. */
export interface SearchResponse_Summary_Reference {
  /** Title of the document. */
  title: string;
  /**
   * Required.
   * [Document.name][google.cloud.discoveryengine.v1.Document.name] of the
   * document. Full resource name of the referenced document, in the format
   * `projects/* /locations/* /collections/* /dataStores/* /branches/* /documents/*`.
   */
  document: string;
  /** Cloud Storage or HTTP uri for the document. */
  uri: string;
  /** List of cited chunk contents derived from document content. */
  chunkContents: SearchResponse_Summary_Reference_ChunkContent[];
}

/** Chunk content. */
export interface SearchResponse_Summary_Reference_ChunkContent {
  /** Chunk textual content. */
  content: string;
  /** Page identifier. */
  pageIdentifier: string;
}

/** Summary with metadata information. */
export interface SearchResponse_Summary_SummaryWithMetadata {
  /** Summary text with no citation information. */
  summary: string;
  /** Citation metadata for given summary. */
  citationMetadata:
    | SearchResponse_Summary_CitationMetadata
    | undefined;
  /** Document References. */
  references: SearchResponse_Summary_Reference[];
}

/**
 * Information describing query expansion including whether expansion has
 * occurred.
 */
export interface SearchResponse_QueryExpansionInfo {
  /** Bool describing whether query expansion has occurred. */
  expandedQuery: boolean;
  /**
   * Number of pinned results. This field will only be set when expansion
   * happens and
   * [SearchRequest.QueryExpansionSpec.pin_unexpanded_results][google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec.pin_unexpanded_results]
   * is set to true.
   */
  pinnedResultCount: Long;
}

/** Information about the session. */
export interface SearchResponse_SessionInfo {
  /**
   * Name of the session.
   * If the auto-session mode is used (when
   * [SearchRequest.session][google.cloud.discoveryengine.v1.SearchRequest.session]
   * ends with "-"), this field holds the newly generated session name.
   */
  name: string;
  /**
   * Query ID that corresponds to this search API call.
   * One session can have multiple turns, each with a unique query ID.
   *
   * By specifying the session name and this query ID in the Answer API call,
   * the answer generation happens in the context of the search results from
   * this search call.
   */
  queryId: string;
}

function createBaseSearchRequest(): SearchRequest {
  return {
    servingConfig: "",
    branch: "",
    query: "",
    imageQuery: undefined,
    pageSize: 0,
    pageToken: "",
    offset: 0,
    dataStoreSpecs: [],
    filter: "",
    canonicalFilter: "",
    orderBy: "",
    userInfo: undefined,
    languageCode: "",
    facetSpecs: [],
    boostSpec: undefined,
    params: {},
    queryExpansionSpec: undefined,
    spellCorrectionSpec: undefined,
    userPseudoId: "",
    contentSearchSpec: undefined,
    safeSearch: false,
    userLabels: {},
    searchAsYouTypeSpec: undefined,
    session: "",
    sessionSpec: undefined,
  };
}

export const SearchRequest: MessageFns<SearchRequest> = {
  encode(message: SearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.servingConfig !== "") {
      writer.uint32(10).string(message.servingConfig);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.query !== "") {
      writer.uint32(26).string(message.query);
    }
    if (message.imageQuery !== undefined) {
      SearchRequest_ImageQuery.encode(message.imageQuery, writer.uint32(154).fork()).join();
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    if (message.offset !== 0) {
      writer.uint32(48).int32(message.offset);
    }
    for (const v of message.dataStoreSpecs) {
      SearchRequest_DataStoreSpec.encode(v!, writer.uint32(258).fork()).join();
    }
    if (message.filter !== "") {
      writer.uint32(58).string(message.filter);
    }
    if (message.canonicalFilter !== "") {
      writer.uint32(234).string(message.canonicalFilter);
    }
    if (message.orderBy !== "") {
      writer.uint32(66).string(message.orderBy);
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(170).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(282).string(message.languageCode);
    }
    for (const v of message.facetSpecs) {
      SearchRequest_FacetSpec.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.boostSpec !== undefined) {
      SearchRequest_BoostSpec.encode(message.boostSpec, writer.uint32(82).fork()).join();
    }
    Object.entries(message.params).forEach(([key, value]) => {
      if (value !== undefined) {
        SearchRequest_ParamsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
      }
    });
    if (message.queryExpansionSpec !== undefined) {
      SearchRequest_QueryExpansionSpec.encode(message.queryExpansionSpec, writer.uint32(106).fork()).join();
    }
    if (message.spellCorrectionSpec !== undefined) {
      SearchRequest_SpellCorrectionSpec.encode(message.spellCorrectionSpec, writer.uint32(114).fork()).join();
    }
    if (message.userPseudoId !== "") {
      writer.uint32(122).string(message.userPseudoId);
    }
    if (message.contentSearchSpec !== undefined) {
      SearchRequest_ContentSearchSpec.encode(message.contentSearchSpec, writer.uint32(194).fork()).join();
    }
    if (message.safeSearch !== false) {
      writer.uint32(160).bool(message.safeSearch);
    }
    Object.entries(message.userLabels).forEach(([key, value]) => {
      SearchRequest_UserLabelsEntry.encode({ key: key as any, value }, writer.uint32(178).fork()).join();
    });
    if (message.searchAsYouTypeSpec !== undefined) {
      SearchRequest_SearchAsYouTypeSpec.encode(message.searchAsYouTypeSpec, writer.uint32(250).fork()).join();
    }
    if (message.session !== "") {
      writer.uint32(330).string(message.session);
    }
    if (message.sessionSpec !== undefined) {
      SearchRequest_SessionSpec.encode(message.sessionSpec, writer.uint32(338).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.servingConfig = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.imageQuery = SearchRequest_ImageQuery.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.offset = reader.int32();
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.dataStoreSpecs.push(SearchRequest_DataStoreSpec.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.canonicalFilter = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.facetSpecs.push(SearchRequest_FacetSpec.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.boostSpec = SearchRequest_BoostSpec.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = SearchRequest_ParamsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.params[entry11.key] = entry11.value;
          }
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.queryExpansionSpec = SearchRequest_QueryExpansionSpec.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.spellCorrectionSpec = SearchRequest_SpellCorrectionSpec.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.userPseudoId = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.contentSearchSpec = SearchRequest_ContentSearchSpec.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.safeSearch = reader.bool();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          const entry22 = SearchRequest_UserLabelsEntry.decode(reader, reader.uint32());
          if (entry22.value !== undefined) {
            message.userLabels[entry22.key] = entry22.value;
          }
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.searchAsYouTypeSpec = SearchRequest_SearchAsYouTypeSpec.decode(reader, reader.uint32());
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.session = reader.string();
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.sessionSpec = SearchRequest_SessionSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest {
    return {
      servingConfig: isSet(object.servingConfig) ? globalThis.String(object.servingConfig) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      imageQuery: isSet(object.imageQuery) ? SearchRequest_ImageQuery.fromJSON(object.imageQuery) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      dataStoreSpecs: globalThis.Array.isArray(object?.dataStoreSpecs)
        ? object.dataStoreSpecs.map((e: any) => SearchRequest_DataStoreSpec.fromJSON(e))
        : [],
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      canonicalFilter: isSet(object.canonicalFilter) ? globalThis.String(object.canonicalFilter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      facetSpecs: globalThis.Array.isArray(object?.facetSpecs)
        ? object.facetSpecs.map((e: any) => SearchRequest_FacetSpec.fromJSON(e))
        : [],
      boostSpec: isSet(object.boostSpec) ? SearchRequest_BoostSpec.fromJSON(object.boostSpec) : undefined,
      params: isObject(object.params)
        ? Object.entries(object.params).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      queryExpansionSpec: isSet(object.queryExpansionSpec)
        ? SearchRequest_QueryExpansionSpec.fromJSON(object.queryExpansionSpec)
        : undefined,
      spellCorrectionSpec: isSet(object.spellCorrectionSpec)
        ? SearchRequest_SpellCorrectionSpec.fromJSON(object.spellCorrectionSpec)
        : undefined,
      userPseudoId: isSet(object.userPseudoId) ? globalThis.String(object.userPseudoId) : "",
      contentSearchSpec: isSet(object.contentSearchSpec)
        ? SearchRequest_ContentSearchSpec.fromJSON(object.contentSearchSpec)
        : undefined,
      safeSearch: isSet(object.safeSearch) ? globalThis.Boolean(object.safeSearch) : false,
      userLabels: isObject(object.userLabels)
        ? Object.entries(object.userLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      searchAsYouTypeSpec: isSet(object.searchAsYouTypeSpec)
        ? SearchRequest_SearchAsYouTypeSpec.fromJSON(object.searchAsYouTypeSpec)
        : undefined,
      session: isSet(object.session) ? globalThis.String(object.session) : "",
      sessionSpec: isSet(object.sessionSpec) ? SearchRequest_SessionSpec.fromJSON(object.sessionSpec) : undefined,
    };
  },

  toJSON(message: SearchRequest): unknown {
    const obj: any = {};
    if (message.servingConfig !== "") {
      obj.servingConfig = message.servingConfig;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.imageQuery !== undefined) {
      obj.imageQuery = SearchRequest_ImageQuery.toJSON(message.imageQuery);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.dataStoreSpecs?.length) {
      obj.dataStoreSpecs = message.dataStoreSpecs.map((e) => SearchRequest_DataStoreSpec.toJSON(e));
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.canonicalFilter !== "") {
      obj.canonicalFilter = message.canonicalFilter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.facetSpecs?.length) {
      obj.facetSpecs = message.facetSpecs.map((e) => SearchRequest_FacetSpec.toJSON(e));
    }
    if (message.boostSpec !== undefined) {
      obj.boostSpec = SearchRequest_BoostSpec.toJSON(message.boostSpec);
    }
    if (message.params) {
      const entries = Object.entries(message.params);
      if (entries.length > 0) {
        obj.params = {};
        entries.forEach(([k, v]) => {
          obj.params[k] = v;
        });
      }
    }
    if (message.queryExpansionSpec !== undefined) {
      obj.queryExpansionSpec = SearchRequest_QueryExpansionSpec.toJSON(message.queryExpansionSpec);
    }
    if (message.spellCorrectionSpec !== undefined) {
      obj.spellCorrectionSpec = SearchRequest_SpellCorrectionSpec.toJSON(message.spellCorrectionSpec);
    }
    if (message.userPseudoId !== "") {
      obj.userPseudoId = message.userPseudoId;
    }
    if (message.contentSearchSpec !== undefined) {
      obj.contentSearchSpec = SearchRequest_ContentSearchSpec.toJSON(message.contentSearchSpec);
    }
    if (message.safeSearch !== false) {
      obj.safeSearch = message.safeSearch;
    }
    if (message.userLabels) {
      const entries = Object.entries(message.userLabels);
      if (entries.length > 0) {
        obj.userLabels = {};
        entries.forEach(([k, v]) => {
          obj.userLabels[k] = v;
        });
      }
    }
    if (message.searchAsYouTypeSpec !== undefined) {
      obj.searchAsYouTypeSpec = SearchRequest_SearchAsYouTypeSpec.toJSON(message.searchAsYouTypeSpec);
    }
    if (message.session !== "") {
      obj.session = message.session;
    }
    if (message.sessionSpec !== undefined) {
      obj.sessionSpec = SearchRequest_SessionSpec.toJSON(message.sessionSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest>): SearchRequest {
    return SearchRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest>): SearchRequest {
    const message = createBaseSearchRequest();
    message.servingConfig = object.servingConfig ?? "";
    message.branch = object.branch ?? "";
    message.query = object.query ?? "";
    message.imageQuery = (object.imageQuery !== undefined && object.imageQuery !== null)
      ? SearchRequest_ImageQuery.fromPartial(object.imageQuery)
      : undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.offset = object.offset ?? 0;
    message.dataStoreSpecs = object.dataStoreSpecs?.map((e) => SearchRequest_DataStoreSpec.fromPartial(e)) || [];
    message.filter = object.filter ?? "";
    message.canonicalFilter = object.canonicalFilter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    message.languageCode = object.languageCode ?? "";
    message.facetSpecs = object.facetSpecs?.map((e) => SearchRequest_FacetSpec.fromPartial(e)) || [];
    message.boostSpec = (object.boostSpec !== undefined && object.boostSpec !== null)
      ? SearchRequest_BoostSpec.fromPartial(object.boostSpec)
      : undefined;
    message.params = Object.entries(object.params ?? {}).reduce<{ [key: string]: any | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.queryExpansionSpec = (object.queryExpansionSpec !== undefined && object.queryExpansionSpec !== null)
      ? SearchRequest_QueryExpansionSpec.fromPartial(object.queryExpansionSpec)
      : undefined;
    message.spellCorrectionSpec = (object.spellCorrectionSpec !== undefined && object.spellCorrectionSpec !== null)
      ? SearchRequest_SpellCorrectionSpec.fromPartial(object.spellCorrectionSpec)
      : undefined;
    message.userPseudoId = object.userPseudoId ?? "";
    message.contentSearchSpec = (object.contentSearchSpec !== undefined && object.contentSearchSpec !== null)
      ? SearchRequest_ContentSearchSpec.fromPartial(object.contentSearchSpec)
      : undefined;
    message.safeSearch = object.safeSearch ?? false;
    message.userLabels = Object.entries(object.userLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.searchAsYouTypeSpec = (object.searchAsYouTypeSpec !== undefined && object.searchAsYouTypeSpec !== null)
      ? SearchRequest_SearchAsYouTypeSpec.fromPartial(object.searchAsYouTypeSpec)
      : undefined;
    message.session = object.session ?? "";
    message.sessionSpec = (object.sessionSpec !== undefined && object.sessionSpec !== null)
      ? SearchRequest_SessionSpec.fromPartial(object.sessionSpec)
      : undefined;
    return message;
  },
};

function createBaseSearchRequest_ImageQuery(): SearchRequest_ImageQuery {
  return { imageBytes: undefined };
}

export const SearchRequest_ImageQuery: MessageFns<SearchRequest_ImageQuery> = {
  encode(message: SearchRequest_ImageQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageBytes !== undefined) {
      writer.uint32(10).string(message.imageBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ImageQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ImageQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imageBytes = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ImageQuery {
    return { imageBytes: isSet(object.imageBytes) ? globalThis.String(object.imageBytes) : undefined };
  },

  toJSON(message: SearchRequest_ImageQuery): unknown {
    const obj: any = {};
    if (message.imageBytes !== undefined) {
      obj.imageBytes = message.imageBytes;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_ImageQuery>): SearchRequest_ImageQuery {
    return SearchRequest_ImageQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_ImageQuery>): SearchRequest_ImageQuery {
    const message = createBaseSearchRequest_ImageQuery();
    message.imageBytes = object.imageBytes ?? undefined;
    return message;
  },
};

function createBaseSearchRequest_DataStoreSpec(): SearchRequest_DataStoreSpec {
  return { dataStore: "" };
}

export const SearchRequest_DataStoreSpec: MessageFns<SearchRequest_DataStoreSpec> = {
  encode(message: SearchRequest_DataStoreSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataStore !== "") {
      writer.uint32(10).string(message.dataStore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_DataStoreSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_DataStoreSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataStore = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_DataStoreSpec {
    return { dataStore: isSet(object.dataStore) ? globalThis.String(object.dataStore) : "" };
  },

  toJSON(message: SearchRequest_DataStoreSpec): unknown {
    const obj: any = {};
    if (message.dataStore !== "") {
      obj.dataStore = message.dataStore;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_DataStoreSpec>): SearchRequest_DataStoreSpec {
    return SearchRequest_DataStoreSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_DataStoreSpec>): SearchRequest_DataStoreSpec {
    const message = createBaseSearchRequest_DataStoreSpec();
    message.dataStore = object.dataStore ?? "";
    return message;
  },
};

function createBaseSearchRequest_FacetSpec(): SearchRequest_FacetSpec {
  return { facetKey: undefined, limit: 0, excludedFilterKeys: [], enableDynamicPosition: false };
}

export const SearchRequest_FacetSpec: MessageFns<SearchRequest_FacetSpec> = {
  encode(message: SearchRequest_FacetSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.facetKey !== undefined) {
      SearchRequest_FacetSpec_FacetKey.encode(message.facetKey, writer.uint32(10).fork()).join();
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    for (const v of message.excludedFilterKeys) {
      writer.uint32(26).string(v!);
    }
    if (message.enableDynamicPosition !== false) {
      writer.uint32(32).bool(message.enableDynamicPosition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_FacetSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_FacetSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.facetKey = SearchRequest_FacetSpec_FacetKey.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.excludedFilterKeys.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enableDynamicPosition = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_FacetSpec {
    return {
      facetKey: isSet(object.facetKey) ? SearchRequest_FacetSpec_FacetKey.fromJSON(object.facetKey) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      excludedFilterKeys: globalThis.Array.isArray(object?.excludedFilterKeys)
        ? object.excludedFilterKeys.map((e: any) => globalThis.String(e))
        : [],
      enableDynamicPosition: isSet(object.enableDynamicPosition)
        ? globalThis.Boolean(object.enableDynamicPosition)
        : false,
    };
  },

  toJSON(message: SearchRequest_FacetSpec): unknown {
    const obj: any = {};
    if (message.facetKey !== undefined) {
      obj.facetKey = SearchRequest_FacetSpec_FacetKey.toJSON(message.facetKey);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.excludedFilterKeys?.length) {
      obj.excludedFilterKeys = message.excludedFilterKeys;
    }
    if (message.enableDynamicPosition !== false) {
      obj.enableDynamicPosition = message.enableDynamicPosition;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_FacetSpec>): SearchRequest_FacetSpec {
    return SearchRequest_FacetSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_FacetSpec>): SearchRequest_FacetSpec {
    const message = createBaseSearchRequest_FacetSpec();
    message.facetKey = (object.facetKey !== undefined && object.facetKey !== null)
      ? SearchRequest_FacetSpec_FacetKey.fromPartial(object.facetKey)
      : undefined;
    message.limit = object.limit ?? 0;
    message.excludedFilterKeys = object.excludedFilterKeys?.map((e) => e) || [];
    message.enableDynamicPosition = object.enableDynamicPosition ?? false;
    return message;
  },
};

function createBaseSearchRequest_FacetSpec_FacetKey(): SearchRequest_FacetSpec_FacetKey {
  return {
    key: "",
    intervals: [],
    restrictedValues: [],
    prefixes: [],
    contains: [],
    caseInsensitive: false,
    orderBy: "",
  };
}

export const SearchRequest_FacetSpec_FacetKey: MessageFns<SearchRequest_FacetSpec_FacetKey> = {
  encode(message: SearchRequest_FacetSpec_FacetKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    for (const v of message.intervals) {
      Interval.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.restrictedValues) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.prefixes) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.contains) {
      writer.uint32(42).string(v!);
    }
    if (message.caseInsensitive !== false) {
      writer.uint32(48).bool(message.caseInsensitive);
    }
    if (message.orderBy !== "") {
      writer.uint32(58).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_FacetSpec_FacetKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_FacetSpec_FacetKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.intervals.push(Interval.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.restrictedValues.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.prefixes.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contains.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.caseInsensitive = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_FacetSpec_FacetKey {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      intervals: globalThis.Array.isArray(object?.intervals)
        ? object.intervals.map((e: any) => Interval.fromJSON(e))
        : [],
      restrictedValues: globalThis.Array.isArray(object?.restrictedValues)
        ? object.restrictedValues.map((e: any) => globalThis.String(e))
        : [],
      prefixes: globalThis.Array.isArray(object?.prefixes) ? object.prefixes.map((e: any) => globalThis.String(e)) : [],
      contains: globalThis.Array.isArray(object?.contains) ? object.contains.map((e: any) => globalThis.String(e)) : [],
      caseInsensitive: isSet(object.caseInsensitive) ? globalThis.Boolean(object.caseInsensitive) : false,
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: SearchRequest_FacetSpec_FacetKey): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.intervals?.length) {
      obj.intervals = message.intervals.map((e) => Interval.toJSON(e));
    }
    if (message.restrictedValues?.length) {
      obj.restrictedValues = message.restrictedValues;
    }
    if (message.prefixes?.length) {
      obj.prefixes = message.prefixes;
    }
    if (message.contains?.length) {
      obj.contains = message.contains;
    }
    if (message.caseInsensitive !== false) {
      obj.caseInsensitive = message.caseInsensitive;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_FacetSpec_FacetKey>): SearchRequest_FacetSpec_FacetKey {
    return SearchRequest_FacetSpec_FacetKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_FacetSpec_FacetKey>): SearchRequest_FacetSpec_FacetKey {
    const message = createBaseSearchRequest_FacetSpec_FacetKey();
    message.key = object.key ?? "";
    message.intervals = object.intervals?.map((e) => Interval.fromPartial(e)) || [];
    message.restrictedValues = object.restrictedValues?.map((e) => e) || [];
    message.prefixes = object.prefixes?.map((e) => e) || [];
    message.contains = object.contains?.map((e) => e) || [];
    message.caseInsensitive = object.caseInsensitive ?? false;
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseSearchRequest_BoostSpec(): SearchRequest_BoostSpec {
  return { conditionBoostSpecs: [] };
}

export const SearchRequest_BoostSpec: MessageFns<SearchRequest_BoostSpec> = {
  encode(message: SearchRequest_BoostSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conditionBoostSpecs) {
      SearchRequest_BoostSpec_ConditionBoostSpec.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_BoostSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_BoostSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conditionBoostSpecs.push(SearchRequest_BoostSpec_ConditionBoostSpec.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_BoostSpec {
    return {
      conditionBoostSpecs: globalThis.Array.isArray(object?.conditionBoostSpecs)
        ? object.conditionBoostSpecs.map((e: any) => SearchRequest_BoostSpec_ConditionBoostSpec.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchRequest_BoostSpec): unknown {
    const obj: any = {};
    if (message.conditionBoostSpecs?.length) {
      obj.conditionBoostSpecs = message.conditionBoostSpecs.map((e) =>
        SearchRequest_BoostSpec_ConditionBoostSpec.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_BoostSpec>): SearchRequest_BoostSpec {
    return SearchRequest_BoostSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_BoostSpec>): SearchRequest_BoostSpec {
    const message = createBaseSearchRequest_BoostSpec();
    message.conditionBoostSpecs =
      object.conditionBoostSpecs?.map((e) => SearchRequest_BoostSpec_ConditionBoostSpec.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchRequest_BoostSpec_ConditionBoostSpec(): SearchRequest_BoostSpec_ConditionBoostSpec {
  return { condition: "", boost: 0 };
}

export const SearchRequest_BoostSpec_ConditionBoostSpec: MessageFns<SearchRequest_BoostSpec_ConditionBoostSpec> = {
  encode(message: SearchRequest_BoostSpec_ConditionBoostSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condition !== "") {
      writer.uint32(10).string(message.condition);
    }
    if (message.boost !== 0) {
      writer.uint32(21).float(message.boost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_BoostSpec_ConditionBoostSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_BoostSpec_ConditionBoostSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.boost = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_BoostSpec_ConditionBoostSpec {
    return {
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      boost: isSet(object.boost) ? globalThis.Number(object.boost) : 0,
    };
  },

  toJSON(message: SearchRequest_BoostSpec_ConditionBoostSpec): unknown {
    const obj: any = {};
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.boost !== 0) {
      obj.boost = message.boost;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_BoostSpec_ConditionBoostSpec>): SearchRequest_BoostSpec_ConditionBoostSpec {
    return SearchRequest_BoostSpec_ConditionBoostSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_BoostSpec_ConditionBoostSpec>,
  ): SearchRequest_BoostSpec_ConditionBoostSpec {
    const message = createBaseSearchRequest_BoostSpec_ConditionBoostSpec();
    message.condition = object.condition ?? "";
    message.boost = object.boost ?? 0;
    return message;
  },
};

function createBaseSearchRequest_QueryExpansionSpec(): SearchRequest_QueryExpansionSpec {
  return { condition: 0, pinUnexpandedResults: false };
}

export const SearchRequest_QueryExpansionSpec: MessageFns<SearchRequest_QueryExpansionSpec> = {
  encode(message: SearchRequest_QueryExpansionSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condition !== 0) {
      writer.uint32(8).int32(message.condition);
    }
    if (message.pinUnexpandedResults !== false) {
      writer.uint32(16).bool(message.pinUnexpandedResults);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_QueryExpansionSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_QueryExpansionSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.condition = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pinUnexpandedResults = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_QueryExpansionSpec {
    return {
      condition: isSet(object.condition) ? searchRequest_QueryExpansionSpec_ConditionFromJSON(object.condition) : 0,
      pinUnexpandedResults: isSet(object.pinUnexpandedResults)
        ? globalThis.Boolean(object.pinUnexpandedResults)
        : false,
    };
  },

  toJSON(message: SearchRequest_QueryExpansionSpec): unknown {
    const obj: any = {};
    if (message.condition !== 0) {
      obj.condition = searchRequest_QueryExpansionSpec_ConditionToJSON(message.condition);
    }
    if (message.pinUnexpandedResults !== false) {
      obj.pinUnexpandedResults = message.pinUnexpandedResults;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_QueryExpansionSpec>): SearchRequest_QueryExpansionSpec {
    return SearchRequest_QueryExpansionSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_QueryExpansionSpec>): SearchRequest_QueryExpansionSpec {
    const message = createBaseSearchRequest_QueryExpansionSpec();
    message.condition = object.condition ?? 0;
    message.pinUnexpandedResults = object.pinUnexpandedResults ?? false;
    return message;
  },
};

function createBaseSearchRequest_SpellCorrectionSpec(): SearchRequest_SpellCorrectionSpec {
  return { mode: 0 };
}

export const SearchRequest_SpellCorrectionSpec: MessageFns<SearchRequest_SpellCorrectionSpec> = {
  encode(message: SearchRequest_SpellCorrectionSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_SpellCorrectionSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_SpellCorrectionSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_SpellCorrectionSpec {
    return { mode: isSet(object.mode) ? searchRequest_SpellCorrectionSpec_ModeFromJSON(object.mode) : 0 };
  },

  toJSON(message: SearchRequest_SpellCorrectionSpec): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = searchRequest_SpellCorrectionSpec_ModeToJSON(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_SpellCorrectionSpec>): SearchRequest_SpellCorrectionSpec {
    return SearchRequest_SpellCorrectionSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_SpellCorrectionSpec>): SearchRequest_SpellCorrectionSpec {
    const message = createBaseSearchRequest_SpellCorrectionSpec();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec(): SearchRequest_ContentSearchSpec {
  return {
    snippetSpec: undefined,
    summarySpec: undefined,
    extractiveContentSpec: undefined,
    searchResultMode: 0,
    chunkSpec: undefined,
  };
}

export const SearchRequest_ContentSearchSpec: MessageFns<SearchRequest_ContentSearchSpec> = {
  encode(message: SearchRequest_ContentSearchSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.snippetSpec !== undefined) {
      SearchRequest_ContentSearchSpec_SnippetSpec.encode(message.snippetSpec, writer.uint32(10).fork()).join();
    }
    if (message.summarySpec !== undefined) {
      SearchRequest_ContentSearchSpec_SummarySpec.encode(message.summarySpec, writer.uint32(18).fork()).join();
    }
    if (message.extractiveContentSpec !== undefined) {
      SearchRequest_ContentSearchSpec_ExtractiveContentSpec.encode(
        message.extractiveContentSpec,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.searchResultMode !== 0) {
      writer.uint32(32).int32(message.searchResultMode);
    }
    if (message.chunkSpec !== undefined) {
      SearchRequest_ContentSearchSpec_ChunkSpec.encode(message.chunkSpec, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ContentSearchSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.snippetSpec = SearchRequest_ContentSearchSpec_SnippetSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.summarySpec = SearchRequest_ContentSearchSpec_SummarySpec.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.extractiveContentSpec = SearchRequest_ContentSearchSpec_ExtractiveContentSpec.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.searchResultMode = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.chunkSpec = SearchRequest_ContentSearchSpec_ChunkSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec {
    return {
      snippetSpec: isSet(object.snippetSpec)
        ? SearchRequest_ContentSearchSpec_SnippetSpec.fromJSON(object.snippetSpec)
        : undefined,
      summarySpec: isSet(object.summarySpec)
        ? SearchRequest_ContentSearchSpec_SummarySpec.fromJSON(object.summarySpec)
        : undefined,
      extractiveContentSpec: isSet(object.extractiveContentSpec)
        ? SearchRequest_ContentSearchSpec_ExtractiveContentSpec.fromJSON(object.extractiveContentSpec)
        : undefined,
      searchResultMode: isSet(object.searchResultMode)
        ? searchRequest_ContentSearchSpec_SearchResultModeFromJSON(object.searchResultMode)
        : 0,
      chunkSpec: isSet(object.chunkSpec)
        ? SearchRequest_ContentSearchSpec_ChunkSpec.fromJSON(object.chunkSpec)
        : undefined,
    };
  },

  toJSON(message: SearchRequest_ContentSearchSpec): unknown {
    const obj: any = {};
    if (message.snippetSpec !== undefined) {
      obj.snippetSpec = SearchRequest_ContentSearchSpec_SnippetSpec.toJSON(message.snippetSpec);
    }
    if (message.summarySpec !== undefined) {
      obj.summarySpec = SearchRequest_ContentSearchSpec_SummarySpec.toJSON(message.summarySpec);
    }
    if (message.extractiveContentSpec !== undefined) {
      obj.extractiveContentSpec = SearchRequest_ContentSearchSpec_ExtractiveContentSpec.toJSON(
        message.extractiveContentSpec,
      );
    }
    if (message.searchResultMode !== 0) {
      obj.searchResultMode = searchRequest_ContentSearchSpec_SearchResultModeToJSON(message.searchResultMode);
    }
    if (message.chunkSpec !== undefined) {
      obj.chunkSpec = SearchRequest_ContentSearchSpec_ChunkSpec.toJSON(message.chunkSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_ContentSearchSpec>): SearchRequest_ContentSearchSpec {
    return SearchRequest_ContentSearchSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_ContentSearchSpec>): SearchRequest_ContentSearchSpec {
    const message = createBaseSearchRequest_ContentSearchSpec();
    message.snippetSpec = (object.snippetSpec !== undefined && object.snippetSpec !== null)
      ? SearchRequest_ContentSearchSpec_SnippetSpec.fromPartial(object.snippetSpec)
      : undefined;
    message.summarySpec = (object.summarySpec !== undefined && object.summarySpec !== null)
      ? SearchRequest_ContentSearchSpec_SummarySpec.fromPartial(object.summarySpec)
      : undefined;
    message.extractiveContentSpec =
      (object.extractiveContentSpec !== undefined && object.extractiveContentSpec !== null)
        ? SearchRequest_ContentSearchSpec_ExtractiveContentSpec.fromPartial(object.extractiveContentSpec)
        : undefined;
    message.searchResultMode = object.searchResultMode ?? 0;
    message.chunkSpec = (object.chunkSpec !== undefined && object.chunkSpec !== null)
      ? SearchRequest_ContentSearchSpec_ChunkSpec.fromPartial(object.chunkSpec)
      : undefined;
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec_SnippetSpec(): SearchRequest_ContentSearchSpec_SnippetSpec {
  return { maxSnippetCount: 0, referenceOnly: false, returnSnippet: false };
}

export const SearchRequest_ContentSearchSpec_SnippetSpec: MessageFns<SearchRequest_ContentSearchSpec_SnippetSpec> = {
  encode(
    message: SearchRequest_ContentSearchSpec_SnippetSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.maxSnippetCount !== 0) {
      writer.uint32(8).int32(message.maxSnippetCount);
    }
    if (message.referenceOnly !== false) {
      writer.uint32(16).bool(message.referenceOnly);
    }
    if (message.returnSnippet !== false) {
      writer.uint32(24).bool(message.returnSnippet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ContentSearchSpec_SnippetSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec_SnippetSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxSnippetCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.referenceOnly = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.returnSnippet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec_SnippetSpec {
    return {
      maxSnippetCount: isSet(object.maxSnippetCount) ? globalThis.Number(object.maxSnippetCount) : 0,
      referenceOnly: isSet(object.referenceOnly) ? globalThis.Boolean(object.referenceOnly) : false,
      returnSnippet: isSet(object.returnSnippet) ? globalThis.Boolean(object.returnSnippet) : false,
    };
  },

  toJSON(message: SearchRequest_ContentSearchSpec_SnippetSpec): unknown {
    const obj: any = {};
    if (message.maxSnippetCount !== 0) {
      obj.maxSnippetCount = Math.round(message.maxSnippetCount);
    }
    if (message.referenceOnly !== false) {
      obj.referenceOnly = message.referenceOnly;
    }
    if (message.returnSnippet !== false) {
      obj.returnSnippet = message.returnSnippet;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_ContentSearchSpec_SnippetSpec>): SearchRequest_ContentSearchSpec_SnippetSpec {
    return SearchRequest_ContentSearchSpec_SnippetSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_ContentSearchSpec_SnippetSpec>,
  ): SearchRequest_ContentSearchSpec_SnippetSpec {
    const message = createBaseSearchRequest_ContentSearchSpec_SnippetSpec();
    message.maxSnippetCount = object.maxSnippetCount ?? 0;
    message.referenceOnly = object.referenceOnly ?? false;
    message.returnSnippet = object.returnSnippet ?? false;
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec_SummarySpec(): SearchRequest_ContentSearchSpec_SummarySpec {
  return {
    summaryResultCount: 0,
    includeCitations: false,
    ignoreAdversarialQuery: false,
    ignoreNonSummarySeekingQuery: false,
    ignoreLowRelevantContent: false,
    modelPromptSpec: undefined,
    languageCode: "",
    modelSpec: undefined,
    useSemanticChunks: false,
  };
}

export const SearchRequest_ContentSearchSpec_SummarySpec: MessageFns<SearchRequest_ContentSearchSpec_SummarySpec> = {
  encode(
    message: SearchRequest_ContentSearchSpec_SummarySpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.summaryResultCount !== 0) {
      writer.uint32(8).int32(message.summaryResultCount);
    }
    if (message.includeCitations !== false) {
      writer.uint32(16).bool(message.includeCitations);
    }
    if (message.ignoreAdversarialQuery !== false) {
      writer.uint32(24).bool(message.ignoreAdversarialQuery);
    }
    if (message.ignoreNonSummarySeekingQuery !== false) {
      writer.uint32(32).bool(message.ignoreNonSummarySeekingQuery);
    }
    if (message.ignoreLowRelevantContent !== false) {
      writer.uint32(72).bool(message.ignoreLowRelevantContent);
    }
    if (message.modelPromptSpec !== undefined) {
      SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec.encode(
        message.modelPromptSpec,
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(50).string(message.languageCode);
    }
    if (message.modelSpec !== undefined) {
      SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec.encode(message.modelSpec, writer.uint32(58).fork()).join();
    }
    if (message.useSemanticChunks !== false) {
      writer.uint32(64).bool(message.useSemanticChunks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ContentSearchSpec_SummarySpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec_SummarySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.summaryResultCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeCitations = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ignoreAdversarialQuery = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ignoreNonSummarySeekingQuery = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.ignoreLowRelevantContent = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.modelPromptSpec = SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.modelSpec = SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.useSemanticChunks = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec_SummarySpec {
    return {
      summaryResultCount: isSet(object.summaryResultCount) ? globalThis.Number(object.summaryResultCount) : 0,
      includeCitations: isSet(object.includeCitations) ? globalThis.Boolean(object.includeCitations) : false,
      ignoreAdversarialQuery: isSet(object.ignoreAdversarialQuery)
        ? globalThis.Boolean(object.ignoreAdversarialQuery)
        : false,
      ignoreNonSummarySeekingQuery: isSet(object.ignoreNonSummarySeekingQuery)
        ? globalThis.Boolean(object.ignoreNonSummarySeekingQuery)
        : false,
      ignoreLowRelevantContent: isSet(object.ignoreLowRelevantContent)
        ? globalThis.Boolean(object.ignoreLowRelevantContent)
        : false,
      modelPromptSpec: isSet(object.modelPromptSpec)
        ? SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec.fromJSON(object.modelPromptSpec)
        : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      modelSpec: isSet(object.modelSpec)
        ? SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec.fromJSON(object.modelSpec)
        : undefined,
      useSemanticChunks: isSet(object.useSemanticChunks) ? globalThis.Boolean(object.useSemanticChunks) : false,
    };
  },

  toJSON(message: SearchRequest_ContentSearchSpec_SummarySpec): unknown {
    const obj: any = {};
    if (message.summaryResultCount !== 0) {
      obj.summaryResultCount = Math.round(message.summaryResultCount);
    }
    if (message.includeCitations !== false) {
      obj.includeCitations = message.includeCitations;
    }
    if (message.ignoreAdversarialQuery !== false) {
      obj.ignoreAdversarialQuery = message.ignoreAdversarialQuery;
    }
    if (message.ignoreNonSummarySeekingQuery !== false) {
      obj.ignoreNonSummarySeekingQuery = message.ignoreNonSummarySeekingQuery;
    }
    if (message.ignoreLowRelevantContent !== false) {
      obj.ignoreLowRelevantContent = message.ignoreLowRelevantContent;
    }
    if (message.modelPromptSpec !== undefined) {
      obj.modelPromptSpec = SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec.toJSON(message.modelPromptSpec);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.modelSpec !== undefined) {
      obj.modelSpec = SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec.toJSON(message.modelSpec);
    }
    if (message.useSemanticChunks !== false) {
      obj.useSemanticChunks = message.useSemanticChunks;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_ContentSearchSpec_SummarySpec>): SearchRequest_ContentSearchSpec_SummarySpec {
    return SearchRequest_ContentSearchSpec_SummarySpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_ContentSearchSpec_SummarySpec>,
  ): SearchRequest_ContentSearchSpec_SummarySpec {
    const message = createBaseSearchRequest_ContentSearchSpec_SummarySpec();
    message.summaryResultCount = object.summaryResultCount ?? 0;
    message.includeCitations = object.includeCitations ?? false;
    message.ignoreAdversarialQuery = object.ignoreAdversarialQuery ?? false;
    message.ignoreNonSummarySeekingQuery = object.ignoreNonSummarySeekingQuery ?? false;
    message.ignoreLowRelevantContent = object.ignoreLowRelevantContent ?? false;
    message.modelPromptSpec = (object.modelPromptSpec !== undefined && object.modelPromptSpec !== null)
      ? SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec.fromPartial(object.modelPromptSpec)
      : undefined;
    message.languageCode = object.languageCode ?? "";
    message.modelSpec = (object.modelSpec !== undefined && object.modelSpec !== null)
      ? SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec.fromPartial(object.modelSpec)
      : undefined;
    message.useSemanticChunks = object.useSemanticChunks ?? false;
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec(): SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec {
  return { preamble: "" };
}

export const SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec: MessageFns<
  SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec
> = {
  encode(
    message: SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.preamble !== "") {
      writer.uint32(10).string(message.preamble);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.preamble = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec {
    return { preamble: isSet(object.preamble) ? globalThis.String(object.preamble) : "" };
  },

  toJSON(message: SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec): unknown {
    const obj: any = {};
    if (message.preamble !== "") {
      obj.preamble = message.preamble;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec>,
  ): SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec {
    return SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec>,
  ): SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec {
    const message = createBaseSearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec();
    message.preamble = object.preamble ?? "";
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec_SummarySpec_ModelSpec(): SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec {
  return { version: "" };
}

export const SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec: MessageFns<
  SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec
> = {
  encode(
    message: SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec_SummarySpec_ModelSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
  },

  toJSON(message: SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec>,
  ): SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec {
    return SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec>,
  ): SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec {
    const message = createBaseSearchRequest_ContentSearchSpec_SummarySpec_ModelSpec();
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec_ExtractiveContentSpec(): SearchRequest_ContentSearchSpec_ExtractiveContentSpec {
  return {
    maxExtractiveAnswerCount: 0,
    maxExtractiveSegmentCount: 0,
    returnExtractiveSegmentScore: false,
    numPreviousSegments: 0,
    numNextSegments: 0,
  };
}

export const SearchRequest_ContentSearchSpec_ExtractiveContentSpec: MessageFns<
  SearchRequest_ContentSearchSpec_ExtractiveContentSpec
> = {
  encode(
    message: SearchRequest_ContentSearchSpec_ExtractiveContentSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.maxExtractiveAnswerCount !== 0) {
      writer.uint32(8).int32(message.maxExtractiveAnswerCount);
    }
    if (message.maxExtractiveSegmentCount !== 0) {
      writer.uint32(16).int32(message.maxExtractiveSegmentCount);
    }
    if (message.returnExtractiveSegmentScore !== false) {
      writer.uint32(24).bool(message.returnExtractiveSegmentScore);
    }
    if (message.numPreviousSegments !== 0) {
      writer.uint32(32).int32(message.numPreviousSegments);
    }
    if (message.numNextSegments !== 0) {
      writer.uint32(40).int32(message.numNextSegments);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ContentSearchSpec_ExtractiveContentSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec_ExtractiveContentSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxExtractiveAnswerCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxExtractiveSegmentCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.returnExtractiveSegmentScore = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.numPreviousSegments = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.numNextSegments = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec_ExtractiveContentSpec {
    return {
      maxExtractiveAnswerCount: isSet(object.maxExtractiveAnswerCount)
        ? globalThis.Number(object.maxExtractiveAnswerCount)
        : 0,
      maxExtractiveSegmentCount: isSet(object.maxExtractiveSegmentCount)
        ? globalThis.Number(object.maxExtractiveSegmentCount)
        : 0,
      returnExtractiveSegmentScore: isSet(object.returnExtractiveSegmentScore)
        ? globalThis.Boolean(object.returnExtractiveSegmentScore)
        : false,
      numPreviousSegments: isSet(object.numPreviousSegments) ? globalThis.Number(object.numPreviousSegments) : 0,
      numNextSegments: isSet(object.numNextSegments) ? globalThis.Number(object.numNextSegments) : 0,
    };
  },

  toJSON(message: SearchRequest_ContentSearchSpec_ExtractiveContentSpec): unknown {
    const obj: any = {};
    if (message.maxExtractiveAnswerCount !== 0) {
      obj.maxExtractiveAnswerCount = Math.round(message.maxExtractiveAnswerCount);
    }
    if (message.maxExtractiveSegmentCount !== 0) {
      obj.maxExtractiveSegmentCount = Math.round(message.maxExtractiveSegmentCount);
    }
    if (message.returnExtractiveSegmentScore !== false) {
      obj.returnExtractiveSegmentScore = message.returnExtractiveSegmentScore;
    }
    if (message.numPreviousSegments !== 0) {
      obj.numPreviousSegments = Math.round(message.numPreviousSegments);
    }
    if (message.numNextSegments !== 0) {
      obj.numNextSegments = Math.round(message.numNextSegments);
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchRequest_ContentSearchSpec_ExtractiveContentSpec>,
  ): SearchRequest_ContentSearchSpec_ExtractiveContentSpec {
    return SearchRequest_ContentSearchSpec_ExtractiveContentSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_ContentSearchSpec_ExtractiveContentSpec>,
  ): SearchRequest_ContentSearchSpec_ExtractiveContentSpec {
    const message = createBaseSearchRequest_ContentSearchSpec_ExtractiveContentSpec();
    message.maxExtractiveAnswerCount = object.maxExtractiveAnswerCount ?? 0;
    message.maxExtractiveSegmentCount = object.maxExtractiveSegmentCount ?? 0;
    message.returnExtractiveSegmentScore = object.returnExtractiveSegmentScore ?? false;
    message.numPreviousSegments = object.numPreviousSegments ?? 0;
    message.numNextSegments = object.numNextSegments ?? 0;
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec_ChunkSpec(): SearchRequest_ContentSearchSpec_ChunkSpec {
  return { numPreviousChunks: 0, numNextChunks: 0 };
}

export const SearchRequest_ContentSearchSpec_ChunkSpec: MessageFns<SearchRequest_ContentSearchSpec_ChunkSpec> = {
  encode(message: SearchRequest_ContentSearchSpec_ChunkSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numPreviousChunks !== 0) {
      writer.uint32(8).int32(message.numPreviousChunks);
    }
    if (message.numNextChunks !== 0) {
      writer.uint32(16).int32(message.numNextChunks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ContentSearchSpec_ChunkSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec_ChunkSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.numPreviousChunks = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numNextChunks = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec_ChunkSpec {
    return {
      numPreviousChunks: isSet(object.numPreviousChunks) ? globalThis.Number(object.numPreviousChunks) : 0,
      numNextChunks: isSet(object.numNextChunks) ? globalThis.Number(object.numNextChunks) : 0,
    };
  },

  toJSON(message: SearchRequest_ContentSearchSpec_ChunkSpec): unknown {
    const obj: any = {};
    if (message.numPreviousChunks !== 0) {
      obj.numPreviousChunks = Math.round(message.numPreviousChunks);
    }
    if (message.numNextChunks !== 0) {
      obj.numNextChunks = Math.round(message.numNextChunks);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_ContentSearchSpec_ChunkSpec>): SearchRequest_ContentSearchSpec_ChunkSpec {
    return SearchRequest_ContentSearchSpec_ChunkSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_ContentSearchSpec_ChunkSpec>,
  ): SearchRequest_ContentSearchSpec_ChunkSpec {
    const message = createBaseSearchRequest_ContentSearchSpec_ChunkSpec();
    message.numPreviousChunks = object.numPreviousChunks ?? 0;
    message.numNextChunks = object.numNextChunks ?? 0;
    return message;
  },
};

function createBaseSearchRequest_SearchAsYouTypeSpec(): SearchRequest_SearchAsYouTypeSpec {
  return { condition: 0 };
}

export const SearchRequest_SearchAsYouTypeSpec: MessageFns<SearchRequest_SearchAsYouTypeSpec> = {
  encode(message: SearchRequest_SearchAsYouTypeSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condition !== 0) {
      writer.uint32(8).int32(message.condition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_SearchAsYouTypeSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_SearchAsYouTypeSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.condition = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_SearchAsYouTypeSpec {
    return {
      condition: isSet(object.condition) ? searchRequest_SearchAsYouTypeSpec_ConditionFromJSON(object.condition) : 0,
    };
  },

  toJSON(message: SearchRequest_SearchAsYouTypeSpec): unknown {
    const obj: any = {};
    if (message.condition !== 0) {
      obj.condition = searchRequest_SearchAsYouTypeSpec_ConditionToJSON(message.condition);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_SearchAsYouTypeSpec>): SearchRequest_SearchAsYouTypeSpec {
    return SearchRequest_SearchAsYouTypeSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_SearchAsYouTypeSpec>): SearchRequest_SearchAsYouTypeSpec {
    const message = createBaseSearchRequest_SearchAsYouTypeSpec();
    message.condition = object.condition ?? 0;
    return message;
  },
};

function createBaseSearchRequest_SessionSpec(): SearchRequest_SessionSpec {
  return { queryId: "", searchResultPersistenceCount: undefined };
}

export const SearchRequest_SessionSpec: MessageFns<SearchRequest_SessionSpec> = {
  encode(message: SearchRequest_SessionSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryId !== "") {
      writer.uint32(10).string(message.queryId);
    }
    if (message.searchResultPersistenceCount !== undefined) {
      writer.uint32(16).int32(message.searchResultPersistenceCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_SessionSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_SessionSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.searchResultPersistenceCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_SessionSpec {
    return {
      queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "",
      searchResultPersistenceCount: isSet(object.searchResultPersistenceCount)
        ? globalThis.Number(object.searchResultPersistenceCount)
        : undefined,
    };
  },

  toJSON(message: SearchRequest_SessionSpec): unknown {
    const obj: any = {};
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    if (message.searchResultPersistenceCount !== undefined) {
      obj.searchResultPersistenceCount = Math.round(message.searchResultPersistenceCount);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_SessionSpec>): SearchRequest_SessionSpec {
    return SearchRequest_SessionSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_SessionSpec>): SearchRequest_SessionSpec {
    const message = createBaseSearchRequest_SessionSpec();
    message.queryId = object.queryId ?? "";
    message.searchResultPersistenceCount = object.searchResultPersistenceCount ?? undefined;
    return message;
  },
};

function createBaseSearchRequest_ParamsEntry(): SearchRequest_ParamsEntry {
  return { key: "", value: undefined };
}

export const SearchRequest_ParamsEntry: MessageFns<SearchRequest_ParamsEntry> = {
  encode(message: SearchRequest_ParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: SearchRequest_ParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_ParamsEntry>): SearchRequest_ParamsEntry {
    return SearchRequest_ParamsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_ParamsEntry>): SearchRequest_ParamsEntry {
    const message = createBaseSearchRequest_ParamsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseSearchRequest_UserLabelsEntry(): SearchRequest_UserLabelsEntry {
  return { key: "", value: "" };
}

export const SearchRequest_UserLabelsEntry: MessageFns<SearchRequest_UserLabelsEntry> = {
  encode(message: SearchRequest_UserLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_UserLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_UserLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_UserLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SearchRequest_UserLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_UserLabelsEntry>): SearchRequest_UserLabelsEntry {
    return SearchRequest_UserLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_UserLabelsEntry>): SearchRequest_UserLabelsEntry {
    const message = createBaseSearchRequest_UserLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSearchResponse(): SearchResponse {
  return {
    results: [],
    facets: [],
    totalSize: 0,
    attributionToken: "",
    redirectUri: "",
    nextPageToken: "",
    correctedQuery: "",
    summary: undefined,
    queryExpansionInfo: undefined,
    sessionInfo: undefined,
  };
}

export const SearchResponse: MessageFns<SearchResponse> = {
  encode(message: SearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      SearchResponse_SearchResult.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.facets) {
      SearchResponse_Facet.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    if (message.attributionToken !== "") {
      writer.uint32(34).string(message.attributionToken);
    }
    if (message.redirectUri !== "") {
      writer.uint32(98).string(message.redirectUri);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(42).string(message.nextPageToken);
    }
    if (message.correctedQuery !== "") {
      writer.uint32(58).string(message.correctedQuery);
    }
    if (message.summary !== undefined) {
      SearchResponse_Summary.encode(message.summary, writer.uint32(74).fork()).join();
    }
    if (message.queryExpansionInfo !== undefined) {
      SearchResponse_QueryExpansionInfo.encode(message.queryExpansionInfo, writer.uint32(114).fork()).join();
    }
    if (message.sessionInfo !== undefined) {
      SearchResponse_SessionInfo.encode(message.sessionInfo, writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(SearchResponse_SearchResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.facets.push(SearchResponse_Facet.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.attributionToken = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.correctedQuery = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.summary = SearchResponse_Summary.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.queryExpansionInfo = SearchResponse_QueryExpansionInfo.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.sessionInfo = SearchResponse_SessionInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => SearchResponse_SearchResult.fromJSON(e))
        : [],
      facets: globalThis.Array.isArray(object?.facets)
        ? object.facets.map((e: any) => SearchResponse_Facet.fromJSON(e))
        : [],
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
      attributionToken: isSet(object.attributionToken) ? globalThis.String(object.attributionToken) : "",
      redirectUri: isSet(object.redirectUri) ? globalThis.String(object.redirectUri) : "",
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      correctedQuery: isSet(object.correctedQuery) ? globalThis.String(object.correctedQuery) : "",
      summary: isSet(object.summary) ? SearchResponse_Summary.fromJSON(object.summary) : undefined,
      queryExpansionInfo: isSet(object.queryExpansionInfo)
        ? SearchResponse_QueryExpansionInfo.fromJSON(object.queryExpansionInfo)
        : undefined,
      sessionInfo: isSet(object.sessionInfo) ? SearchResponse_SessionInfo.fromJSON(object.sessionInfo) : undefined,
    };
  },

  toJSON(message: SearchResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => SearchResponse_SearchResult.toJSON(e));
    }
    if (message.facets?.length) {
      obj.facets = message.facets.map((e) => SearchResponse_Facet.toJSON(e));
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    if (message.attributionToken !== "") {
      obj.attributionToken = message.attributionToken;
    }
    if (message.redirectUri !== "") {
      obj.redirectUri = message.redirectUri;
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.correctedQuery !== "") {
      obj.correctedQuery = message.correctedQuery;
    }
    if (message.summary !== undefined) {
      obj.summary = SearchResponse_Summary.toJSON(message.summary);
    }
    if (message.queryExpansionInfo !== undefined) {
      obj.queryExpansionInfo = SearchResponse_QueryExpansionInfo.toJSON(message.queryExpansionInfo);
    }
    if (message.sessionInfo !== undefined) {
      obj.sessionInfo = SearchResponse_SessionInfo.toJSON(message.sessionInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse>): SearchResponse {
    return SearchResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse>): SearchResponse {
    const message = createBaseSearchResponse();
    message.results = object.results?.map((e) => SearchResponse_SearchResult.fromPartial(e)) || [];
    message.facets = object.facets?.map((e) => SearchResponse_Facet.fromPartial(e)) || [];
    message.totalSize = object.totalSize ?? 0;
    message.attributionToken = object.attributionToken ?? "";
    message.redirectUri = object.redirectUri ?? "";
    message.nextPageToken = object.nextPageToken ?? "";
    message.correctedQuery = object.correctedQuery ?? "";
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? SearchResponse_Summary.fromPartial(object.summary)
      : undefined;
    message.queryExpansionInfo = (object.queryExpansionInfo !== undefined && object.queryExpansionInfo !== null)
      ? SearchResponse_QueryExpansionInfo.fromPartial(object.queryExpansionInfo)
      : undefined;
    message.sessionInfo = (object.sessionInfo !== undefined && object.sessionInfo !== null)
      ? SearchResponse_SessionInfo.fromPartial(object.sessionInfo)
      : undefined;
    return message;
  },
};

function createBaseSearchResponse_SearchResult(): SearchResponse_SearchResult {
  return { id: "", document: undefined, chunk: undefined };
}

export const SearchResponse_SearchResult: MessageFns<SearchResponse_SearchResult> = {
  encode(message: SearchResponse_SearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.document !== undefined) {
      Document.encode(message.document, writer.uint32(18).fork()).join();
    }
    if (message.chunk !== undefined) {
      Chunk.encode(message.chunk, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_SearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_SearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.document = Document.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.chunk = Chunk.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_SearchResult {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      document: isSet(object.document) ? Document.fromJSON(object.document) : undefined,
      chunk: isSet(object.chunk) ? Chunk.fromJSON(object.chunk) : undefined,
    };
  },

  toJSON(message: SearchResponse_SearchResult): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.document !== undefined) {
      obj.document = Document.toJSON(message.document);
    }
    if (message.chunk !== undefined) {
      obj.chunk = Chunk.toJSON(message.chunk);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_SearchResult>): SearchResponse_SearchResult {
    return SearchResponse_SearchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_SearchResult>): SearchResponse_SearchResult {
    const message = createBaseSearchResponse_SearchResult();
    message.id = object.id ?? "";
    message.document = (object.document !== undefined && object.document !== null)
      ? Document.fromPartial(object.document)
      : undefined;
    message.chunk = (object.chunk !== undefined && object.chunk !== null) ? Chunk.fromPartial(object.chunk) : undefined;
    return message;
  },
};

function createBaseSearchResponse_Facet(): SearchResponse_Facet {
  return { key: "", values: [], dynamicFacet: false };
}

export const SearchResponse_Facet: MessageFns<SearchResponse_Facet> = {
  encode(message: SearchResponse_Facet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    for (const v of message.values) {
      SearchResponse_Facet_FacetValue.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.dynamicFacet !== false) {
      writer.uint32(24).bool(message.dynamicFacet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Facet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Facet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.values.push(SearchResponse_Facet_FacetValue.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dynamicFacet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Facet {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => SearchResponse_Facet_FacetValue.fromJSON(e))
        : [],
      dynamicFacet: isSet(object.dynamicFacet) ? globalThis.Boolean(object.dynamicFacet) : false,
    };
  },

  toJSON(message: SearchResponse_Facet): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.values?.length) {
      obj.values = message.values.map((e) => SearchResponse_Facet_FacetValue.toJSON(e));
    }
    if (message.dynamicFacet !== false) {
      obj.dynamicFacet = message.dynamicFacet;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Facet>): SearchResponse_Facet {
    return SearchResponse_Facet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Facet>): SearchResponse_Facet {
    const message = createBaseSearchResponse_Facet();
    message.key = object.key ?? "";
    message.values = object.values?.map((e) => SearchResponse_Facet_FacetValue.fromPartial(e)) || [];
    message.dynamicFacet = object.dynamicFacet ?? false;
    return message;
  },
};

function createBaseSearchResponse_Facet_FacetValue(): SearchResponse_Facet_FacetValue {
  return { value: undefined, interval: undefined, count: Long.ZERO };
}

export const SearchResponse_Facet_FacetValue: MessageFns<SearchResponse_Facet_FacetValue> = {
  encode(message: SearchResponse_Facet_FacetValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    if (message.interval !== undefined) {
      Interval.encode(message.interval, writer.uint32(18).fork()).join();
    }
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.count.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Facet_FacetValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Facet_FacetValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.interval = Interval.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Facet_FacetValue {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      interval: isSet(object.interval) ? Interval.fromJSON(object.interval) : undefined,
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
    };
  },

  toJSON(message: SearchResponse_Facet_FacetValue): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.interval !== undefined) {
      obj.interval = Interval.toJSON(message.interval);
    }
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Facet_FacetValue>): SearchResponse_Facet_FacetValue {
    return SearchResponse_Facet_FacetValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Facet_FacetValue>): SearchResponse_Facet_FacetValue {
    const message = createBaseSearchResponse_Facet_FacetValue();
    message.value = object.value ?? undefined;
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? Interval.fromPartial(object.interval)
      : undefined;
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    return message;
  },
};

function createBaseSearchResponse_Summary(): SearchResponse_Summary {
  return { summaryText: "", summarySkippedReasons: [], safetyAttributes: undefined, summaryWithMetadata: undefined };
}

export const SearchResponse_Summary: MessageFns<SearchResponse_Summary> = {
  encode(message: SearchResponse_Summary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.summaryText !== "") {
      writer.uint32(10).string(message.summaryText);
    }
    writer.uint32(18).fork();
    for (const v of message.summarySkippedReasons) {
      writer.int32(v);
    }
    writer.join();
    if (message.safetyAttributes !== undefined) {
      SearchResponse_Summary_SafetyAttributes.encode(message.safetyAttributes, writer.uint32(26).fork()).join();
    }
    if (message.summaryWithMetadata !== undefined) {
      SearchResponse_Summary_SummaryWithMetadata.encode(message.summaryWithMetadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.summaryText = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.summarySkippedReasons.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.summarySkippedReasons.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.safetyAttributes = SearchResponse_Summary_SafetyAttributes.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.summaryWithMetadata = SearchResponse_Summary_SummaryWithMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary {
    return {
      summaryText: isSet(object.summaryText) ? globalThis.String(object.summaryText) : "",
      summarySkippedReasons: globalThis.Array.isArray(object?.summarySkippedReasons)
        ? object.summarySkippedReasons.map((e: any) => searchResponse_Summary_SummarySkippedReasonFromJSON(e))
        : [],
      safetyAttributes: isSet(object.safetyAttributes)
        ? SearchResponse_Summary_SafetyAttributes.fromJSON(object.safetyAttributes)
        : undefined,
      summaryWithMetadata: isSet(object.summaryWithMetadata)
        ? SearchResponse_Summary_SummaryWithMetadata.fromJSON(object.summaryWithMetadata)
        : undefined,
    };
  },

  toJSON(message: SearchResponse_Summary): unknown {
    const obj: any = {};
    if (message.summaryText !== "") {
      obj.summaryText = message.summaryText;
    }
    if (message.summarySkippedReasons?.length) {
      obj.summarySkippedReasons = message.summarySkippedReasons.map((e) =>
        searchResponse_Summary_SummarySkippedReasonToJSON(e)
      );
    }
    if (message.safetyAttributes !== undefined) {
      obj.safetyAttributes = SearchResponse_Summary_SafetyAttributes.toJSON(message.safetyAttributes);
    }
    if (message.summaryWithMetadata !== undefined) {
      obj.summaryWithMetadata = SearchResponse_Summary_SummaryWithMetadata.toJSON(message.summaryWithMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary>): SearchResponse_Summary {
    return SearchResponse_Summary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Summary>): SearchResponse_Summary {
    const message = createBaseSearchResponse_Summary();
    message.summaryText = object.summaryText ?? "";
    message.summarySkippedReasons = object.summarySkippedReasons?.map((e) => e) || [];
    message.safetyAttributes = (object.safetyAttributes !== undefined && object.safetyAttributes !== null)
      ? SearchResponse_Summary_SafetyAttributes.fromPartial(object.safetyAttributes)
      : undefined;
    message.summaryWithMetadata = (object.summaryWithMetadata !== undefined && object.summaryWithMetadata !== null)
      ? SearchResponse_Summary_SummaryWithMetadata.fromPartial(object.summaryWithMetadata)
      : undefined;
    return message;
  },
};

function createBaseSearchResponse_Summary_SafetyAttributes(): SearchResponse_Summary_SafetyAttributes {
  return { categories: [], scores: [] };
}

export const SearchResponse_Summary_SafetyAttributes: MessageFns<SearchResponse_Summary_SafetyAttributes> = {
  encode(message: SearchResponse_Summary_SafetyAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.categories) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.scores) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_SafetyAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary_SafetyAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.categories.push(reader.string());
          continue;
        case 2:
          if (tag === 21) {
            message.scores.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.scores.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary_SafetyAttributes {
    return {
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
      scores: globalThis.Array.isArray(object?.scores) ? object.scores.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: SearchResponse_Summary_SafetyAttributes): unknown {
    const obj: any = {};
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    if (message.scores?.length) {
      obj.scores = message.scores;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary_SafetyAttributes>): SearchResponse_Summary_SafetyAttributes {
    return SearchResponse_Summary_SafetyAttributes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Summary_SafetyAttributes>): SearchResponse_Summary_SafetyAttributes {
    const message = createBaseSearchResponse_Summary_SafetyAttributes();
    message.categories = object.categories?.map((e) => e) || [];
    message.scores = object.scores?.map((e) => e) || [];
    return message;
  },
};

function createBaseSearchResponse_Summary_CitationMetadata(): SearchResponse_Summary_CitationMetadata {
  return { citations: [] };
}

export const SearchResponse_Summary_CitationMetadata: MessageFns<SearchResponse_Summary_CitationMetadata> = {
  encode(message: SearchResponse_Summary_CitationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.citations) {
      SearchResponse_Summary_Citation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_CitationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary_CitationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.citations.push(SearchResponse_Summary_Citation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary_CitationMetadata {
    return {
      citations: globalThis.Array.isArray(object?.citations)
        ? object.citations.map((e: any) => SearchResponse_Summary_Citation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse_Summary_CitationMetadata): unknown {
    const obj: any = {};
    if (message.citations?.length) {
      obj.citations = message.citations.map((e) => SearchResponse_Summary_Citation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary_CitationMetadata>): SearchResponse_Summary_CitationMetadata {
    return SearchResponse_Summary_CitationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Summary_CitationMetadata>): SearchResponse_Summary_CitationMetadata {
    const message = createBaseSearchResponse_Summary_CitationMetadata();
    message.citations = object.citations?.map((e) => SearchResponse_Summary_Citation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchResponse_Summary_Citation(): SearchResponse_Summary_Citation {
  return { startIndex: Long.ZERO, endIndex: Long.ZERO, sources: [] };
}

export const SearchResponse_Summary_Citation: MessageFns<SearchResponse_Summary_Citation> = {
  encode(message: SearchResponse_Summary_Citation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.startIndex.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.startIndex.toString());
    }
    if (!message.endIndex.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.endIndex.toString());
    }
    for (const v of message.sources) {
      SearchResponse_Summary_CitationSource.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_Citation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary_Citation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startIndex = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endIndex = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sources.push(SearchResponse_Summary_CitationSource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary_Citation {
    return {
      startIndex: isSet(object.startIndex) ? Long.fromValue(object.startIndex) : Long.ZERO,
      endIndex: isSet(object.endIndex) ? Long.fromValue(object.endIndex) : Long.ZERO,
      sources: globalThis.Array.isArray(object?.sources)
        ? object.sources.map((e: any) => SearchResponse_Summary_CitationSource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse_Summary_Citation): unknown {
    const obj: any = {};
    if (!message.startIndex.equals(Long.ZERO)) {
      obj.startIndex = (message.startIndex || Long.ZERO).toString();
    }
    if (!message.endIndex.equals(Long.ZERO)) {
      obj.endIndex = (message.endIndex || Long.ZERO).toString();
    }
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => SearchResponse_Summary_CitationSource.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary_Citation>): SearchResponse_Summary_Citation {
    return SearchResponse_Summary_Citation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Summary_Citation>): SearchResponse_Summary_Citation {
    const message = createBaseSearchResponse_Summary_Citation();
    message.startIndex = (object.startIndex !== undefined && object.startIndex !== null)
      ? Long.fromValue(object.startIndex)
      : Long.ZERO;
    message.endIndex = (object.endIndex !== undefined && object.endIndex !== null)
      ? Long.fromValue(object.endIndex)
      : Long.ZERO;
    message.sources = object.sources?.map((e) => SearchResponse_Summary_CitationSource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchResponse_Summary_CitationSource(): SearchResponse_Summary_CitationSource {
  return { referenceIndex: Long.ZERO };
}

export const SearchResponse_Summary_CitationSource: MessageFns<SearchResponse_Summary_CitationSource> = {
  encode(message: SearchResponse_Summary_CitationSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.referenceIndex.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.referenceIndex.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_CitationSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary_CitationSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 32) {
            break;
          }

          message.referenceIndex = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary_CitationSource {
    return { referenceIndex: isSet(object.referenceIndex) ? Long.fromValue(object.referenceIndex) : Long.ZERO };
  },

  toJSON(message: SearchResponse_Summary_CitationSource): unknown {
    const obj: any = {};
    if (!message.referenceIndex.equals(Long.ZERO)) {
      obj.referenceIndex = (message.referenceIndex || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary_CitationSource>): SearchResponse_Summary_CitationSource {
    return SearchResponse_Summary_CitationSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Summary_CitationSource>): SearchResponse_Summary_CitationSource {
    const message = createBaseSearchResponse_Summary_CitationSource();
    message.referenceIndex = (object.referenceIndex !== undefined && object.referenceIndex !== null)
      ? Long.fromValue(object.referenceIndex)
      : Long.ZERO;
    return message;
  },
};

function createBaseSearchResponse_Summary_Reference(): SearchResponse_Summary_Reference {
  return { title: "", document: "", uri: "", chunkContents: [] };
}

export const SearchResponse_Summary_Reference: MessageFns<SearchResponse_Summary_Reference> = {
  encode(message: SearchResponse_Summary_Reference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.document !== "") {
      writer.uint32(18).string(message.document);
    }
    if (message.uri !== "") {
      writer.uint32(26).string(message.uri);
    }
    for (const v of message.chunkContents) {
      SearchResponse_Summary_Reference_ChunkContent.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_Reference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary_Reference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.document = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.chunkContents.push(SearchResponse_Summary_Reference_ChunkContent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary_Reference {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      document: isSet(object.document) ? globalThis.String(object.document) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      chunkContents: globalThis.Array.isArray(object?.chunkContents)
        ? object.chunkContents.map((e: any) => SearchResponse_Summary_Reference_ChunkContent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse_Summary_Reference): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.document !== "") {
      obj.document = message.document;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.chunkContents?.length) {
      obj.chunkContents = message.chunkContents.map((e) => SearchResponse_Summary_Reference_ChunkContent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary_Reference>): SearchResponse_Summary_Reference {
    return SearchResponse_Summary_Reference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Summary_Reference>): SearchResponse_Summary_Reference {
    const message = createBaseSearchResponse_Summary_Reference();
    message.title = object.title ?? "";
    message.document = object.document ?? "";
    message.uri = object.uri ?? "";
    message.chunkContents =
      object.chunkContents?.map((e) => SearchResponse_Summary_Reference_ChunkContent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchResponse_Summary_Reference_ChunkContent(): SearchResponse_Summary_Reference_ChunkContent {
  return { content: "", pageIdentifier: "" };
}

export const SearchResponse_Summary_Reference_ChunkContent: MessageFns<SearchResponse_Summary_Reference_ChunkContent> =
  {
    encode(
      message: SearchResponse_Summary_Reference_ChunkContent,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.content !== "") {
        writer.uint32(10).string(message.content);
      }
      if (message.pageIdentifier !== "") {
        writer.uint32(18).string(message.pageIdentifier);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_Reference_ChunkContent {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSearchResponse_Summary_Reference_ChunkContent();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.content = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.pageIdentifier = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SearchResponse_Summary_Reference_ChunkContent {
      return {
        content: isSet(object.content) ? globalThis.String(object.content) : "",
        pageIdentifier: isSet(object.pageIdentifier) ? globalThis.String(object.pageIdentifier) : "",
      };
    },

    toJSON(message: SearchResponse_Summary_Reference_ChunkContent): unknown {
      const obj: any = {};
      if (message.content !== "") {
        obj.content = message.content;
      }
      if (message.pageIdentifier !== "") {
        obj.pageIdentifier = message.pageIdentifier;
      }
      return obj;
    },

    create(
      base?: DeepPartial<SearchResponse_Summary_Reference_ChunkContent>,
    ): SearchResponse_Summary_Reference_ChunkContent {
      return SearchResponse_Summary_Reference_ChunkContent.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<SearchResponse_Summary_Reference_ChunkContent>,
    ): SearchResponse_Summary_Reference_ChunkContent {
      const message = createBaseSearchResponse_Summary_Reference_ChunkContent();
      message.content = object.content ?? "";
      message.pageIdentifier = object.pageIdentifier ?? "";
      return message;
    },
  };

function createBaseSearchResponse_Summary_SummaryWithMetadata(): SearchResponse_Summary_SummaryWithMetadata {
  return { summary: "", citationMetadata: undefined, references: [] };
}

export const SearchResponse_Summary_SummaryWithMetadata: MessageFns<SearchResponse_Summary_SummaryWithMetadata> = {
  encode(message: SearchResponse_Summary_SummaryWithMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.summary !== "") {
      writer.uint32(10).string(message.summary);
    }
    if (message.citationMetadata !== undefined) {
      SearchResponse_Summary_CitationMetadata.encode(message.citationMetadata, writer.uint32(18).fork()).join();
    }
    for (const v of message.references) {
      SearchResponse_Summary_Reference.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_SummaryWithMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary_SummaryWithMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.summary = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.citationMetadata = SearchResponse_Summary_CitationMetadata.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.references.push(SearchResponse_Summary_Reference.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary_SummaryWithMetadata {
    return {
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      citationMetadata: isSet(object.citationMetadata)
        ? SearchResponse_Summary_CitationMetadata.fromJSON(object.citationMetadata)
        : undefined,
      references: globalThis.Array.isArray(object?.references)
        ? object.references.map((e: any) => SearchResponse_Summary_Reference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse_Summary_SummaryWithMetadata): unknown {
    const obj: any = {};
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.citationMetadata !== undefined) {
      obj.citationMetadata = SearchResponse_Summary_CitationMetadata.toJSON(message.citationMetadata);
    }
    if (message.references?.length) {
      obj.references = message.references.map((e) => SearchResponse_Summary_Reference.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary_SummaryWithMetadata>): SearchResponse_Summary_SummaryWithMetadata {
    return SearchResponse_Summary_SummaryWithMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchResponse_Summary_SummaryWithMetadata>,
  ): SearchResponse_Summary_SummaryWithMetadata {
    const message = createBaseSearchResponse_Summary_SummaryWithMetadata();
    message.summary = object.summary ?? "";
    message.citationMetadata = (object.citationMetadata !== undefined && object.citationMetadata !== null)
      ? SearchResponse_Summary_CitationMetadata.fromPartial(object.citationMetadata)
      : undefined;
    message.references = object.references?.map((e) => SearchResponse_Summary_Reference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchResponse_QueryExpansionInfo(): SearchResponse_QueryExpansionInfo {
  return { expandedQuery: false, pinnedResultCount: Long.ZERO };
}

export const SearchResponse_QueryExpansionInfo: MessageFns<SearchResponse_QueryExpansionInfo> = {
  encode(message: SearchResponse_QueryExpansionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expandedQuery !== false) {
      writer.uint32(8).bool(message.expandedQuery);
    }
    if (!message.pinnedResultCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.pinnedResultCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_QueryExpansionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_QueryExpansionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.expandedQuery = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pinnedResultCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_QueryExpansionInfo {
    return {
      expandedQuery: isSet(object.expandedQuery) ? globalThis.Boolean(object.expandedQuery) : false,
      pinnedResultCount: isSet(object.pinnedResultCount) ? Long.fromValue(object.pinnedResultCount) : Long.ZERO,
    };
  },

  toJSON(message: SearchResponse_QueryExpansionInfo): unknown {
    const obj: any = {};
    if (message.expandedQuery !== false) {
      obj.expandedQuery = message.expandedQuery;
    }
    if (!message.pinnedResultCount.equals(Long.ZERO)) {
      obj.pinnedResultCount = (message.pinnedResultCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_QueryExpansionInfo>): SearchResponse_QueryExpansionInfo {
    return SearchResponse_QueryExpansionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_QueryExpansionInfo>): SearchResponse_QueryExpansionInfo {
    const message = createBaseSearchResponse_QueryExpansionInfo();
    message.expandedQuery = object.expandedQuery ?? false;
    message.pinnedResultCount = (object.pinnedResultCount !== undefined && object.pinnedResultCount !== null)
      ? Long.fromValue(object.pinnedResultCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseSearchResponse_SessionInfo(): SearchResponse_SessionInfo {
  return { name: "", queryId: "" };
}

export const SearchResponse_SessionInfo: MessageFns<SearchResponse_SessionInfo> = {
  encode(message: SearchResponse_SessionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.queryId !== "") {
      writer.uint32(18).string(message.queryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_SessionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_SessionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queryId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_SessionInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "",
    };
  },

  toJSON(message: SearchResponse_SessionInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_SessionInfo>): SearchResponse_SessionInfo {
    return SearchResponse_SessionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_SessionInfo>): SearchResponse_SessionInfo {
    const message = createBaseSearchResponse_SessionInfo();
    message.name = object.name ?? "";
    message.queryId = object.queryId ?? "";
    return message;
  },
};

/** Service for search. */
export type SearchServiceDefinition = typeof SearchServiceDefinition;
export const SearchServiceDefinition = {
  name: "SearchService",
  fullName: "google.cloud.discoveryengine.v1.SearchService",
  methods: {
    /** Performs a search. */
    search: {
      name: "Search",
      requestType: SearchRequest,
      requestStream: false,
      responseType: SearchResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              156,
              2,
              58,
              1,
              42,
              90,
              99,
              58,
              1,
              42,
              34,
              94,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              114,
              118,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              116,
              111,
              114,
              101,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              90,
              96,
              58,
              1,
              42,
              34,
              91,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              114,
              118,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              103,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              34,
              80,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              114,
              118,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              116,
              111,
              114,
              101,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface SearchServiceImplementation<CallContextExt = {}> {
  /** Performs a search. */
  search(request: SearchRequest, context: CallContext & CallContextExt): Promise<DeepPartial<SearchResponse>>;
}

export interface SearchServiceClient<CallOptionsExt = {}> {
  /** Performs a search. */
  search(request: DeepPartial<SearchRequest>, options?: CallOptions & CallOptionsExt): Promise<SearchResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
