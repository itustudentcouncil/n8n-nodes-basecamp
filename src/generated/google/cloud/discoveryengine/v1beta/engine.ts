// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/discoveryengine/v1beta/engine.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  IndustryVertical,
  industryVerticalFromJSON,
  industryVerticalToJSON,
  SearchAddOn,
  searchAddOnFromJSON,
  searchAddOnToJSON,
  SearchTier,
  searchTierFromJSON,
  searchTierToJSON,
  SolutionType,
  solutionTypeFromJSON,
  solutionTypeToJSON,
} from "./common.js";

export const protobufPackage = "google.cloud.discoveryengine.v1beta";

/**
 * Metadata that describes the training and serving parameters of an
 * [Engine][google.cloud.discoveryengine.v1beta.Engine].
 */
export interface Engine {
  /**
   * Configurations for the Chat Engine. Only applicable if
   * [solution_type][google.cloud.discoveryengine.v1beta.Engine.solution_type]
   * is
   * [SOLUTION_TYPE_CHAT][google.cloud.discoveryengine.v1beta.SolutionType.SOLUTION_TYPE_CHAT].
   */
  chatEngineConfig?:
    | Engine_ChatEngineConfig
    | undefined;
  /**
   * Configurations for the Search Engine. Only applicable if
   * [solution_type][google.cloud.discoveryengine.v1beta.Engine.solution_type]
   * is
   * [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1beta.SolutionType.SOLUTION_TYPE_SEARCH].
   */
  searchEngineConfig?:
    | Engine_SearchEngineConfig
    | undefined;
  /**
   * Output only. Additional information of the Chat Engine. Only applicable
   * if
   * [solution_type][google.cloud.discoveryengine.v1beta.Engine.solution_type]
   * is
   * [SOLUTION_TYPE_CHAT][google.cloud.discoveryengine.v1beta.SolutionType.SOLUTION_TYPE_CHAT].
   */
  chatEngineMetadata?:
    | Engine_ChatEngineMetadata
    | undefined;
  /**
   * Immutable. The fully qualified resource name of the engine.
   *
   * This field must be a UTF-8 encoded string with a length limit of 1024
   * characters.
   *
   * Format:
   * `projects/{project_number}/locations/{location}/collections/{collection}/engines/{engine}`
   * engine should be 1-63 characters, and valid characters are
   * /[a-z0-9][a-z0-9-_]* /. Otherwise, an INVALID_ARGUMENT error is returned.
   */
  name: string;
  /**
   * Required. The display name of the engine. Should be human readable. UTF-8
   * encoded string with limit of 1024 characters.
   */
  displayName: string;
  /** Output only. Timestamp the Recommendation Engine was created at. */
  createTime:
    | Date
    | undefined;
  /** Output only. Timestamp the Recommendation Engine was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * The data stores associated with this engine.
   *
   * For
   * [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1beta.SolutionType.SOLUTION_TYPE_SEARCH]
   * and
   * [SOLUTION_TYPE_RECOMMENDATION][google.cloud.discoveryengine.v1beta.SolutionType.SOLUTION_TYPE_RECOMMENDATION]
   * type of engines, they can only associate with at most one data store.
   *
   * If
   * [solution_type][google.cloud.discoveryengine.v1beta.Engine.solution_type]
   * is
   * [SOLUTION_TYPE_CHAT][google.cloud.discoveryengine.v1beta.SolutionType.SOLUTION_TYPE_CHAT],
   * multiple [DataStore][google.cloud.discoveryengine.v1beta.DataStore]s in the
   * same [Collection][google.cloud.discoveryengine.v1beta.Collection] can be
   * associated here.
   *
   * Note that when used in
   * [CreateEngineRequest][google.cloud.discoveryengine.v1beta.CreateEngineRequest],
   * one DataStore id must be provided as the system will use it for necessary
   * initializations.
   */
  dataStoreIds: string[];
  /** Required. The solutions of the engine. */
  solutionType: SolutionType;
  /**
   * The industry vertical that the engine registers.
   * The restriction of the Engine industry vertical is based on
   * [DataStore][google.cloud.discoveryengine.v1beta.DataStore]: If unspecified,
   * default to `GENERIC`. Vertical on Engine has to match vertical of the
   * DataStore linked to the engine.
   */
  industryVertical: IndustryVertical;
  /** Common config spec that specifies the metadata of the engine. */
  commonConfig: Engine_CommonConfig | undefined;
}

/** Configurations for a Search Engine. */
export interface Engine_SearchEngineConfig {
  /**
   * The search feature tier of this engine.
   *
   * Different tiers might have different
   * pricing. To learn more, check the pricing documentation.
   *
   * Defaults to
   * [SearchTier.SEARCH_TIER_STANDARD][google.cloud.discoveryengine.v1beta.SearchTier.SEARCH_TIER_STANDARD]
   * if not specified.
   */
  searchTier: SearchTier;
  /** The add-on that this search engine enables. */
  searchAddOns: SearchAddOn[];
}

/** Configurations for a Chat Engine. */
export interface Engine_ChatEngineConfig {
  /**
   * The configurationt generate the Dialogflow agent that is associated to
   * this Engine.
   *
   * Note that these configurations are one-time consumed by
   * and passed to Dialogflow service. It means they cannot be retrieved using
   * [EngineService.GetEngine][google.cloud.discoveryengine.v1beta.EngineService.GetEngine]
   * or
   * [EngineService.ListEngines][google.cloud.discoveryengine.v1beta.EngineService.ListEngines]
   * API after engine creation.
   */
  agentCreationConfig:
    | Engine_ChatEngineConfig_AgentCreationConfig
    | undefined;
  /**
   * The resource name of an exist Dialogflow agent to link to this Chat
   * Engine. Customers can either provide `agent_creation_config` to create
   * agent or provide an agent name that links the agent with the Chat engine.
   *
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>`.
   *
   * Note that the `dialogflow_agent_to_link` are one-time consumed by and
   * passed to Dialogflow service. It means they cannot be retrieved using
   * [EngineService.GetEngine][google.cloud.discoveryengine.v1beta.EngineService.GetEngine]
   * or
   * [EngineService.ListEngines][google.cloud.discoveryengine.v1beta.EngineService.ListEngines]
   * API after engine creation. Use
   * [ChatEngineMetadata.dialogflow_agent][google.cloud.discoveryengine.v1beta.Engine.ChatEngineMetadata.dialogflow_agent]
   * for actual agent association after Engine is created.
   */
  dialogflowAgentToLink: string;
}

/**
 * Configurations for generating a Dialogflow agent.
 *
 * Note that these configurations are one-time consumed by
 * and passed to Dialogflow service. It means they cannot be retrieved using
 * [EngineService.GetEngine][google.cloud.discoveryengine.v1beta.EngineService.GetEngine]
 * or
 * [EngineService.ListEngines][google.cloud.discoveryengine.v1beta.EngineService.ListEngines]
 * API after engine creation.
 */
export interface Engine_ChatEngineConfig_AgentCreationConfig {
  /**
   * Name of the company, organization or other entity that the agent
   * represents. Used for knowledge connector LLM prompt and for knowledge
   * search.
   */
  business: string;
  /**
   * Required. The default language of the agent as a language tag.
   * See [Language
   * Support](https://cloud.google.com/dialogflow/docs/reference/language)
   * for a list of the currently supported language codes.
   */
  defaultLanguageCode: string;
  /**
   * Required. The time zone of the agent from the [time zone
   * database](https://www.iana.org/time-zones), e.g., America/New_York,
   * Europe/Paris.
   */
  timeZone: string;
  /**
   * Agent location for Agent creation, supported values: global/us/eu.
   * If not provided, us Engine will create Agent using us-central-1 by
   * default; eu Engine will create Agent using eu-west-1 by default.
   */
  location: string;
}

/** Common configurations for an Engine. */
export interface Engine_CommonConfig {
  /**
   * The name of the company, business or entity that is associated with the
   * engine. Setting this may help improve LLM related features.
   */
  companyName: string;
}

/**
 * Additional information of a Chat Engine.
 * Fields in this message are output only.
 */
export interface Engine_ChatEngineMetadata {
  /**
   * The resource name of a Dialogflow agent, that this Chat Engine refers
   * to.
   *
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>`.
   */
  dialogflowAgent: string;
}

function createBaseEngine(): Engine {
  return {
    chatEngineConfig: undefined,
    searchEngineConfig: undefined,
    chatEngineMetadata: undefined,
    name: "",
    displayName: "",
    createTime: undefined,
    updateTime: undefined,
    dataStoreIds: [],
    solutionType: 0,
    industryVertical: 0,
    commonConfig: undefined,
  };
}

export const Engine: MessageFns<Engine> = {
  encode(message: Engine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatEngineConfig !== undefined) {
      Engine_ChatEngineConfig.encode(message.chatEngineConfig, writer.uint32(90).fork()).join();
    }
    if (message.searchEngineConfig !== undefined) {
      Engine_SearchEngineConfig.encode(message.searchEngineConfig, writer.uint32(106).fork()).join();
    }
    if (message.chatEngineMetadata !== undefined) {
      Engine_ChatEngineMetadata.encode(message.chatEngineMetadata, writer.uint32(98).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    for (const v of message.dataStoreIds) {
      writer.uint32(42).string(v!);
    }
    if (message.solutionType !== 0) {
      writer.uint32(48).int32(message.solutionType);
    }
    if (message.industryVertical !== 0) {
      writer.uint32(128).int32(message.industryVertical);
    }
    if (message.commonConfig !== undefined) {
      Engine_CommonConfig.encode(message.commonConfig, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Engine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 11:
          if (tag !== 90) {
            break;
          }

          message.chatEngineConfig = Engine_ChatEngineConfig.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.searchEngineConfig = Engine_SearchEngineConfig.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.chatEngineMetadata = Engine_ChatEngineMetadata.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dataStoreIds.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.solutionType = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.industryVertical = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.commonConfig = Engine_CommonConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Engine {
    return {
      chatEngineConfig: isSet(object.chatEngineConfig)
        ? Engine_ChatEngineConfig.fromJSON(object.chatEngineConfig)
        : undefined,
      searchEngineConfig: isSet(object.searchEngineConfig)
        ? Engine_SearchEngineConfig.fromJSON(object.searchEngineConfig)
        : undefined,
      chatEngineMetadata: isSet(object.chatEngineMetadata)
        ? Engine_ChatEngineMetadata.fromJSON(object.chatEngineMetadata)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      dataStoreIds: globalThis.Array.isArray(object?.dataStoreIds)
        ? object.dataStoreIds.map((e: any) => globalThis.String(e))
        : [],
      solutionType: isSet(object.solutionType) ? solutionTypeFromJSON(object.solutionType) : 0,
      industryVertical: isSet(object.industryVertical) ? industryVerticalFromJSON(object.industryVertical) : 0,
      commonConfig: isSet(object.commonConfig) ? Engine_CommonConfig.fromJSON(object.commonConfig) : undefined,
    };
  },

  toJSON(message: Engine): unknown {
    const obj: any = {};
    if (message.chatEngineConfig !== undefined) {
      obj.chatEngineConfig = Engine_ChatEngineConfig.toJSON(message.chatEngineConfig);
    }
    if (message.searchEngineConfig !== undefined) {
      obj.searchEngineConfig = Engine_SearchEngineConfig.toJSON(message.searchEngineConfig);
    }
    if (message.chatEngineMetadata !== undefined) {
      obj.chatEngineMetadata = Engine_ChatEngineMetadata.toJSON(message.chatEngineMetadata);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.dataStoreIds?.length) {
      obj.dataStoreIds = message.dataStoreIds;
    }
    if (message.solutionType !== 0) {
      obj.solutionType = solutionTypeToJSON(message.solutionType);
    }
    if (message.industryVertical !== 0) {
      obj.industryVertical = industryVerticalToJSON(message.industryVertical);
    }
    if (message.commonConfig !== undefined) {
      obj.commonConfig = Engine_CommonConfig.toJSON(message.commonConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Engine>): Engine {
    return Engine.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Engine>): Engine {
    const message = createBaseEngine();
    message.chatEngineConfig = (object.chatEngineConfig !== undefined && object.chatEngineConfig !== null)
      ? Engine_ChatEngineConfig.fromPartial(object.chatEngineConfig)
      : undefined;
    message.searchEngineConfig = (object.searchEngineConfig !== undefined && object.searchEngineConfig !== null)
      ? Engine_SearchEngineConfig.fromPartial(object.searchEngineConfig)
      : undefined;
    message.chatEngineMetadata = (object.chatEngineMetadata !== undefined && object.chatEngineMetadata !== null)
      ? Engine_ChatEngineMetadata.fromPartial(object.chatEngineMetadata)
      : undefined;
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.dataStoreIds = object.dataStoreIds?.map((e) => e) || [];
    message.solutionType = object.solutionType ?? 0;
    message.industryVertical = object.industryVertical ?? 0;
    message.commonConfig = (object.commonConfig !== undefined && object.commonConfig !== null)
      ? Engine_CommonConfig.fromPartial(object.commonConfig)
      : undefined;
    return message;
  },
};

function createBaseEngine_SearchEngineConfig(): Engine_SearchEngineConfig {
  return { searchTier: 0, searchAddOns: [] };
}

export const Engine_SearchEngineConfig: MessageFns<Engine_SearchEngineConfig> = {
  encode(message: Engine_SearchEngineConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchTier !== 0) {
      writer.uint32(8).int32(message.searchTier);
    }
    writer.uint32(18).fork();
    for (const v of message.searchAddOns) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Engine_SearchEngineConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngine_SearchEngineConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.searchTier = reader.int32() as any;
          continue;
        case 2:
          if (tag === 16) {
            message.searchAddOns.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.searchAddOns.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Engine_SearchEngineConfig {
    return {
      searchTier: isSet(object.searchTier) ? searchTierFromJSON(object.searchTier) : 0,
      searchAddOns: globalThis.Array.isArray(object?.searchAddOns)
        ? object.searchAddOns.map((e: any) => searchAddOnFromJSON(e))
        : [],
    };
  },

  toJSON(message: Engine_SearchEngineConfig): unknown {
    const obj: any = {};
    if (message.searchTier !== 0) {
      obj.searchTier = searchTierToJSON(message.searchTier);
    }
    if (message.searchAddOns?.length) {
      obj.searchAddOns = message.searchAddOns.map((e) => searchAddOnToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Engine_SearchEngineConfig>): Engine_SearchEngineConfig {
    return Engine_SearchEngineConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Engine_SearchEngineConfig>): Engine_SearchEngineConfig {
    const message = createBaseEngine_SearchEngineConfig();
    message.searchTier = object.searchTier ?? 0;
    message.searchAddOns = object.searchAddOns?.map((e) => e) || [];
    return message;
  },
};

function createBaseEngine_ChatEngineConfig(): Engine_ChatEngineConfig {
  return { agentCreationConfig: undefined, dialogflowAgentToLink: "" };
}

export const Engine_ChatEngineConfig: MessageFns<Engine_ChatEngineConfig> = {
  encode(message: Engine_ChatEngineConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agentCreationConfig !== undefined) {
      Engine_ChatEngineConfig_AgentCreationConfig.encode(message.agentCreationConfig, writer.uint32(10).fork()).join();
    }
    if (message.dialogflowAgentToLink !== "") {
      writer.uint32(18).string(message.dialogflowAgentToLink);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Engine_ChatEngineConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngine_ChatEngineConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentCreationConfig = Engine_ChatEngineConfig_AgentCreationConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dialogflowAgentToLink = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Engine_ChatEngineConfig {
    return {
      agentCreationConfig: isSet(object.agentCreationConfig)
        ? Engine_ChatEngineConfig_AgentCreationConfig.fromJSON(object.agentCreationConfig)
        : undefined,
      dialogflowAgentToLink: isSet(object.dialogflowAgentToLink) ? globalThis.String(object.dialogflowAgentToLink) : "",
    };
  },

  toJSON(message: Engine_ChatEngineConfig): unknown {
    const obj: any = {};
    if (message.agentCreationConfig !== undefined) {
      obj.agentCreationConfig = Engine_ChatEngineConfig_AgentCreationConfig.toJSON(message.agentCreationConfig);
    }
    if (message.dialogflowAgentToLink !== "") {
      obj.dialogflowAgentToLink = message.dialogflowAgentToLink;
    }
    return obj;
  },

  create(base?: DeepPartial<Engine_ChatEngineConfig>): Engine_ChatEngineConfig {
    return Engine_ChatEngineConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Engine_ChatEngineConfig>): Engine_ChatEngineConfig {
    const message = createBaseEngine_ChatEngineConfig();
    message.agentCreationConfig = (object.agentCreationConfig !== undefined && object.agentCreationConfig !== null)
      ? Engine_ChatEngineConfig_AgentCreationConfig.fromPartial(object.agentCreationConfig)
      : undefined;
    message.dialogflowAgentToLink = object.dialogflowAgentToLink ?? "";
    return message;
  },
};

function createBaseEngine_ChatEngineConfig_AgentCreationConfig(): Engine_ChatEngineConfig_AgentCreationConfig {
  return { business: "", defaultLanguageCode: "", timeZone: "", location: "" };
}

export const Engine_ChatEngineConfig_AgentCreationConfig: MessageFns<Engine_ChatEngineConfig_AgentCreationConfig> = {
  encode(
    message: Engine_ChatEngineConfig_AgentCreationConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.business !== "") {
      writer.uint32(10).string(message.business);
    }
    if (message.defaultLanguageCode !== "") {
      writer.uint32(18).string(message.defaultLanguageCode);
    }
    if (message.timeZone !== "") {
      writer.uint32(26).string(message.timeZone);
    }
    if (message.location !== "") {
      writer.uint32(34).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Engine_ChatEngineConfig_AgentCreationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngine_ChatEngineConfig_AgentCreationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.business = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.defaultLanguageCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timeZone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Engine_ChatEngineConfig_AgentCreationConfig {
    return {
      business: isSet(object.business) ? globalThis.String(object.business) : "",
      defaultLanguageCode: isSet(object.defaultLanguageCode) ? globalThis.String(object.defaultLanguageCode) : "",
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: Engine_ChatEngineConfig_AgentCreationConfig): unknown {
    const obj: any = {};
    if (message.business !== "") {
      obj.business = message.business;
    }
    if (message.defaultLanguageCode !== "") {
      obj.defaultLanguageCode = message.defaultLanguageCode;
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<Engine_ChatEngineConfig_AgentCreationConfig>): Engine_ChatEngineConfig_AgentCreationConfig {
    return Engine_ChatEngineConfig_AgentCreationConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Engine_ChatEngineConfig_AgentCreationConfig>,
  ): Engine_ChatEngineConfig_AgentCreationConfig {
    const message = createBaseEngine_ChatEngineConfig_AgentCreationConfig();
    message.business = object.business ?? "";
    message.defaultLanguageCode = object.defaultLanguageCode ?? "";
    message.timeZone = object.timeZone ?? "";
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseEngine_CommonConfig(): Engine_CommonConfig {
  return { companyName: "" };
}

export const Engine_CommonConfig: MessageFns<Engine_CommonConfig> = {
  encode(message: Engine_CommonConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.companyName !== "") {
      writer.uint32(10).string(message.companyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Engine_CommonConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngine_CommonConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.companyName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Engine_CommonConfig {
    return { companyName: isSet(object.companyName) ? globalThis.String(object.companyName) : "" };
  },

  toJSON(message: Engine_CommonConfig): unknown {
    const obj: any = {};
    if (message.companyName !== "") {
      obj.companyName = message.companyName;
    }
    return obj;
  },

  create(base?: DeepPartial<Engine_CommonConfig>): Engine_CommonConfig {
    return Engine_CommonConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Engine_CommonConfig>): Engine_CommonConfig {
    const message = createBaseEngine_CommonConfig();
    message.companyName = object.companyName ?? "";
    return message;
  },
};

function createBaseEngine_ChatEngineMetadata(): Engine_ChatEngineMetadata {
  return { dialogflowAgent: "" };
}

export const Engine_ChatEngineMetadata: MessageFns<Engine_ChatEngineMetadata> = {
  encode(message: Engine_ChatEngineMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dialogflowAgent !== "") {
      writer.uint32(10).string(message.dialogflowAgent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Engine_ChatEngineMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngine_ChatEngineMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dialogflowAgent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Engine_ChatEngineMetadata {
    return { dialogflowAgent: isSet(object.dialogflowAgent) ? globalThis.String(object.dialogflowAgent) : "" };
  },

  toJSON(message: Engine_ChatEngineMetadata): unknown {
    const obj: any = {};
    if (message.dialogflowAgent !== "") {
      obj.dialogflowAgent = message.dialogflowAgent;
    }
    return obj;
  },

  create(base?: DeepPartial<Engine_ChatEngineMetadata>): Engine_ChatEngineMetadata {
    return Engine_ChatEngineMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Engine_ChatEngineMetadata>): Engine_ChatEngineMetadata {
    const message = createBaseEngine_ChatEngineMetadata();
    message.dialogflowAgent = object.dialogflowAgent ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
