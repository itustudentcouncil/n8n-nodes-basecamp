// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/discoveryengine/v1beta/answer.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Struct } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.discoveryengine.v1beta";

/** Defines an answer. */
export interface Answer {
  /**
   * Immutable. Fully qualified name
   * `projects/{project}/locations/global/collections/{collection}/engines/{engine}/sessions/* /answers/*`
   */
  name: string;
  /** The state of the answer generation. */
  state: Answer_State;
  /** The textual answer. */
  answerText: string;
  /** Citations. */
  citations: Answer_Citation[];
  /** References. */
  references: Answer_Reference[];
  /** Suggested related questions. */
  relatedQuestions: string[];
  /** Answer generation steps. */
  steps: Answer_Step[];
  /** Query understanding information. */
  queryUnderstandingInfo:
    | Answer_QueryUnderstandingInfo
    | undefined;
  /**
   * Additional answer-skipped reasons. This provides the reason for ignored
   * cases. If nothing is skipped, this field is not set.
   */
  answerSkippedReasons: Answer_AnswerSkippedReason[];
  /** Output only. Answer creation timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. Answer completed timestamp. */
  completeTime: Date | undefined;
}

/** Enumeration of the state of the answer generation. */
export enum Answer_State {
  /** STATE_UNSPECIFIED - Unknown. */
  STATE_UNSPECIFIED = 0,
  /** IN_PROGRESS - Answer generation is currently in progress. */
  IN_PROGRESS = 1,
  /** FAILED - Answer generation currently failed. */
  FAILED = 2,
  /** SUCCEEDED - Answer generation has succeeded. */
  SUCCEEDED = 3,
  UNRECOGNIZED = -1,
}

export function answer_StateFromJSON(object: any): Answer_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Answer_State.STATE_UNSPECIFIED;
    case 1:
    case "IN_PROGRESS":
      return Answer_State.IN_PROGRESS;
    case 2:
    case "FAILED":
      return Answer_State.FAILED;
    case 3:
    case "SUCCEEDED":
      return Answer_State.SUCCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Answer_State.UNRECOGNIZED;
  }
}

export function answer_StateToJSON(object: Answer_State): string {
  switch (object) {
    case Answer_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Answer_State.IN_PROGRESS:
      return "IN_PROGRESS";
    case Answer_State.FAILED:
      return "FAILED";
    case Answer_State.SUCCEEDED:
      return "SUCCEEDED";
    case Answer_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An enum for answer skipped reasons. */
export enum Answer_AnswerSkippedReason {
  /** ANSWER_SKIPPED_REASON_UNSPECIFIED - Default value. The answer skipped reason is not specified. */
  ANSWER_SKIPPED_REASON_UNSPECIFIED = 0,
  /** ADVERSARIAL_QUERY_IGNORED - The adversarial query ignored case. */
  ADVERSARIAL_QUERY_IGNORED = 1,
  /** NON_ANSWER_SEEKING_QUERY_IGNORED - The non-answer seeking query ignored case. */
  NON_ANSWER_SEEKING_QUERY_IGNORED = 2,
  /**
   * OUT_OF_DOMAIN_QUERY_IGNORED - The out-of-domain query ignored case.
   *
   * Google skips the answer if there are no high-relevance search results.
   */
  OUT_OF_DOMAIN_QUERY_IGNORED = 3,
  /**
   * POTENTIAL_POLICY_VIOLATION - The potential policy violation case.
   *
   * Google skips the answer if there is a potential policy violation
   * detected. This includes content that may be violent or toxic.
   */
  POTENTIAL_POLICY_VIOLATION = 4,
  /**
   * NO_RELEVANT_CONTENT - The no relevant content case.
   *
   * Google skips the answer if there is no relevant content in the
   * retrieved search results.
   */
  NO_RELEVANT_CONTENT = 5,
  /**
   * JAIL_BREAKING_QUERY_IGNORED - The jail-breaking query ignored case.
   *
   * For example, "Reply in the tone of a competing company's CEO".
   * Google skips the answer if the query is classified as a jail-breaking
   * query.
   */
  JAIL_BREAKING_QUERY_IGNORED = 6,
  /**
   * CUSTOMER_POLICY_VIOLATION - The customer policy violation case.
   *
   * Google skips the summary if there is a customer policy violation
   * detected. The policy is defined by the customer.
   */
  CUSTOMER_POLICY_VIOLATION = 7,
  UNRECOGNIZED = -1,
}

export function answer_AnswerSkippedReasonFromJSON(object: any): Answer_AnswerSkippedReason {
  switch (object) {
    case 0:
    case "ANSWER_SKIPPED_REASON_UNSPECIFIED":
      return Answer_AnswerSkippedReason.ANSWER_SKIPPED_REASON_UNSPECIFIED;
    case 1:
    case "ADVERSARIAL_QUERY_IGNORED":
      return Answer_AnswerSkippedReason.ADVERSARIAL_QUERY_IGNORED;
    case 2:
    case "NON_ANSWER_SEEKING_QUERY_IGNORED":
      return Answer_AnswerSkippedReason.NON_ANSWER_SEEKING_QUERY_IGNORED;
    case 3:
    case "OUT_OF_DOMAIN_QUERY_IGNORED":
      return Answer_AnswerSkippedReason.OUT_OF_DOMAIN_QUERY_IGNORED;
    case 4:
    case "POTENTIAL_POLICY_VIOLATION":
      return Answer_AnswerSkippedReason.POTENTIAL_POLICY_VIOLATION;
    case 5:
    case "NO_RELEVANT_CONTENT":
      return Answer_AnswerSkippedReason.NO_RELEVANT_CONTENT;
    case 6:
    case "JAIL_BREAKING_QUERY_IGNORED":
      return Answer_AnswerSkippedReason.JAIL_BREAKING_QUERY_IGNORED;
    case 7:
    case "CUSTOMER_POLICY_VIOLATION":
      return Answer_AnswerSkippedReason.CUSTOMER_POLICY_VIOLATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Answer_AnswerSkippedReason.UNRECOGNIZED;
  }
}

export function answer_AnswerSkippedReasonToJSON(object: Answer_AnswerSkippedReason): string {
  switch (object) {
    case Answer_AnswerSkippedReason.ANSWER_SKIPPED_REASON_UNSPECIFIED:
      return "ANSWER_SKIPPED_REASON_UNSPECIFIED";
    case Answer_AnswerSkippedReason.ADVERSARIAL_QUERY_IGNORED:
      return "ADVERSARIAL_QUERY_IGNORED";
    case Answer_AnswerSkippedReason.NON_ANSWER_SEEKING_QUERY_IGNORED:
      return "NON_ANSWER_SEEKING_QUERY_IGNORED";
    case Answer_AnswerSkippedReason.OUT_OF_DOMAIN_QUERY_IGNORED:
      return "OUT_OF_DOMAIN_QUERY_IGNORED";
    case Answer_AnswerSkippedReason.POTENTIAL_POLICY_VIOLATION:
      return "POTENTIAL_POLICY_VIOLATION";
    case Answer_AnswerSkippedReason.NO_RELEVANT_CONTENT:
      return "NO_RELEVANT_CONTENT";
    case Answer_AnswerSkippedReason.JAIL_BREAKING_QUERY_IGNORED:
      return "JAIL_BREAKING_QUERY_IGNORED";
    case Answer_AnswerSkippedReason.CUSTOMER_POLICY_VIOLATION:
      return "CUSTOMER_POLICY_VIOLATION";
    case Answer_AnswerSkippedReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Citation info for a segment. */
export interface Answer_Citation {
  /**
   * Index indicates the start of the segment, measured in bytes (UTF-8
   * unicode).
   */
  startIndex: Long;
  /** End of the attributed segment, exclusive. */
  endIndex: Long;
  /** Citation sources for the attributed segment. */
  sources: Answer_CitationSource[];
}

/** Citation source. */
export interface Answer_CitationSource {
  /** ID of the citation source. */
  referenceId: string;
}

/** Reference. */
export interface Answer_Reference {
  /** Unstructured document information. */
  unstructuredDocumentInfo?:
    | Answer_Reference_UnstructuredDocumentInfo
    | undefined;
  /** Chunk information. */
  chunkInfo?:
    | Answer_Reference_ChunkInfo
    | undefined;
  /** Structured document information. */
  structuredDocumentInfo?: Answer_Reference_StructuredDocumentInfo | undefined;
}

/** Unstructured document information. */
export interface Answer_Reference_UnstructuredDocumentInfo {
  /** Document resource name. */
  document: string;
  /** URI for the document. */
  uri: string;
  /** Title. */
  title: string;
  /** List of cited chunk contents derived from document content. */
  chunkContents: Answer_Reference_UnstructuredDocumentInfo_ChunkContent[];
  /**
   * The structured JSON metadata for the document.
   * It is populated from the struct data from the Chunk in search result.
   */
  structData: { [key: string]: any } | undefined;
}

/** Chunk content. */
export interface Answer_Reference_UnstructuredDocumentInfo_ChunkContent {
  /** Chunk textual content. */
  content: string;
  /** Page identifier. */
  pageIdentifier: string;
  /**
   * The relevance of the chunk for a given query. Values range from 0.0
   * (completely irrelevant) to 1.0 (completely relevant).
   * This value is for informational purpose only. It may change for
   * the same query and chunk at any time due to a model retraining or
   * change in implementation.
   */
  relevanceScore?: number | undefined;
}

/** Chunk information. */
export interface Answer_Reference_ChunkInfo {
  /** Chunk resource name. */
  chunk: string;
  /** Chunk textual content. */
  content: string;
  /**
   * The relevance of the chunk for a given query. Values range from 0.0
   * (completely irrelevant) to 1.0 (completely relevant).
   * This value is for informational purpose only. It may change for
   * the same query and chunk at any time due to a model retraining or
   * change in implementation.
   */
  relevanceScore?:
    | number
    | undefined;
  /** Document metadata. */
  documentMetadata: Answer_Reference_ChunkInfo_DocumentMetadata | undefined;
}

/** Document metadata. */
export interface Answer_Reference_ChunkInfo_DocumentMetadata {
  /** Document resource name. */
  document: string;
  /** URI for the document. */
  uri: string;
  /** Title. */
  title: string;
  /** Page identifier. */
  pageIdentifier: string;
  /**
   * The structured JSON metadata for the document.
   * It is populated from the struct data from the Chunk in search result.
   */
  structData: { [key: string]: any } | undefined;
}

/** Structured search information. */
export interface Answer_Reference_StructuredDocumentInfo {
  /** Document resource name. */
  document: string;
  /** Structured search data. */
  structData: { [key: string]: any } | undefined;
}

/** Step information. */
export interface Answer_Step {
  /** The state of the step. */
  state: Answer_Step_State;
  /** The description of the step. */
  description: string;
  /** The thought of the step. */
  thought: string;
  /** Actions. */
  actions: Answer_Step_Action[];
}

/** Enumeration of the state of the step. */
export enum Answer_Step_State {
  /** STATE_UNSPECIFIED - Unknown. */
  STATE_UNSPECIFIED = 0,
  /** IN_PROGRESS - Step is currently in progress. */
  IN_PROGRESS = 1,
  /** FAILED - Step currently failed. */
  FAILED = 2,
  /** SUCCEEDED - Step has succeeded. */
  SUCCEEDED = 3,
  UNRECOGNIZED = -1,
}

export function answer_Step_StateFromJSON(object: any): Answer_Step_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Answer_Step_State.STATE_UNSPECIFIED;
    case 1:
    case "IN_PROGRESS":
      return Answer_Step_State.IN_PROGRESS;
    case 2:
    case "FAILED":
      return Answer_Step_State.FAILED;
    case 3:
    case "SUCCEEDED":
      return Answer_Step_State.SUCCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Answer_Step_State.UNRECOGNIZED;
  }
}

export function answer_Step_StateToJSON(object: Answer_Step_State): string {
  switch (object) {
    case Answer_Step_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Answer_Step_State.IN_PROGRESS:
      return "IN_PROGRESS";
    case Answer_Step_State.FAILED:
      return "FAILED";
    case Answer_Step_State.SUCCEEDED:
      return "SUCCEEDED";
    case Answer_Step_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Action. */
export interface Answer_Step_Action {
  /** Search action. */
  searchAction?:
    | Answer_Step_Action_SearchAction
    | undefined;
  /** Observation. */
  observation: Answer_Step_Action_Observation | undefined;
}

/** Search action. */
export interface Answer_Step_Action_SearchAction {
  /** The query to search. */
  query: string;
}

/** Observation. */
export interface Answer_Step_Action_Observation {
  /**
   * Search results observed by the search action, it can be snippets info
   * or chunk info, depending on the citation type set by the user.
   */
  searchResults: Answer_Step_Action_Observation_SearchResult[];
}

export interface Answer_Step_Action_Observation_SearchResult {
  /** Document resource name. */
  document: string;
  /** URI for the document. */
  uri: string;
  /** Title. */
  title: string;
  /**
   * If citation_type is DOCUMENT_LEVEL_CITATION, populate document
   * level snippets.
   */
  snippetInfo: Answer_Step_Action_Observation_SearchResult_SnippetInfo[];
  /**
   * If citation_type is CHUNK_LEVEL_CITATION and chunk mode is on,
   * populate chunk info.
   */
  chunkInfo: Answer_Step_Action_Observation_SearchResult_ChunkInfo[];
  /**
   * Data representation.
   * The structured JSON data for the document.
   * It's populated from the struct data from the Document
   * , or the Chunk in
   * search result
   * .
   */
  structData: { [key: string]: any } | undefined;
}

/** Snippet information. */
export interface Answer_Step_Action_Observation_SearchResult_SnippetInfo {
  /** Snippet content. */
  snippet: string;
  /** Status of the snippet defined by the search team. */
  snippetStatus: string;
}

/** Chunk information. */
export interface Answer_Step_Action_Observation_SearchResult_ChunkInfo {
  /** Chunk resource name. */
  chunk: string;
  /** Chunk textual content. */
  content: string;
  /**
   * The relevance of the chunk for a given query. Values range from
   * 0.0 (completely irrelevant) to 1.0 (completely relevant).
   * This value is for informational purpose only. It may change for
   * the same query and chunk at any time due to a model retraining or
   * change in implementation.
   */
  relevanceScore?: number | undefined;
}

/** Query understanding information. */
export interface Answer_QueryUnderstandingInfo {
  /** Query classification information. */
  queryClassificationInfo: Answer_QueryUnderstandingInfo_QueryClassificationInfo[];
}

/** Query classification information. */
export interface Answer_QueryUnderstandingInfo_QueryClassificationInfo {
  /** Query classification type. */
  type: Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type;
  /** Classification output. */
  positive: boolean;
}

/** Query classification types. */
export enum Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type {
  /** TYPE_UNSPECIFIED - Unspecified query classification type. */
  TYPE_UNSPECIFIED = 0,
  /** ADVERSARIAL_QUERY - Adversarial query classification type. */
  ADVERSARIAL_QUERY = 1,
  /** NON_ANSWER_SEEKING_QUERY - Non-answer-seeking query classification type. */
  NON_ANSWER_SEEKING_QUERY = 2,
  /** JAIL_BREAKING_QUERY - Jail-breaking query classification type. */
  JAIL_BREAKING_QUERY = 3,
  UNRECOGNIZED = -1,
}

export function answer_QueryUnderstandingInfo_QueryClassificationInfo_TypeFromJSON(
  object: any,
): Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type.TYPE_UNSPECIFIED;
    case 1:
    case "ADVERSARIAL_QUERY":
      return Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type.ADVERSARIAL_QUERY;
    case 2:
    case "NON_ANSWER_SEEKING_QUERY":
      return Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type.NON_ANSWER_SEEKING_QUERY;
    case 3:
    case "JAIL_BREAKING_QUERY":
      return Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type.JAIL_BREAKING_QUERY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type.UNRECOGNIZED;
  }
}

export function answer_QueryUnderstandingInfo_QueryClassificationInfo_TypeToJSON(
  object: Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type,
): string {
  switch (object) {
    case Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type.ADVERSARIAL_QUERY:
      return "ADVERSARIAL_QUERY";
    case Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type.NON_ANSWER_SEEKING_QUERY:
      return "NON_ANSWER_SEEKING_QUERY";
    case Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type.JAIL_BREAKING_QUERY:
      return "JAIL_BREAKING_QUERY";
    case Answer_QueryUnderstandingInfo_QueryClassificationInfo_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseAnswer(): Answer {
  return {
    name: "",
    state: 0,
    answerText: "",
    citations: [],
    references: [],
    relatedQuestions: [],
    steps: [],
    queryUnderstandingInfo: undefined,
    answerSkippedReasons: [],
    createTime: undefined,
    completeTime: undefined,
  };
}

export const Answer: MessageFns<Answer> = {
  encode(message: Answer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.answerText !== "") {
      writer.uint32(26).string(message.answerText);
    }
    for (const v of message.citations) {
      Answer_Citation.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.references) {
      Answer_Reference.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.relatedQuestions) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.steps) {
      Answer_Step.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.queryUnderstandingInfo !== undefined) {
      Answer_QueryUnderstandingInfo.encode(message.queryUnderstandingInfo, writer.uint32(82).fork()).join();
    }
    writer.uint32(90).fork();
    for (const v of message.answerSkippedReasons) {
      writer.int32(v);
    }
    writer.join();
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.completeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.completeTime), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.answerText = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.citations.push(Answer_Citation.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.references.push(Answer_Reference.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.relatedQuestions.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.steps.push(Answer_Step.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.queryUnderstandingInfo = Answer_QueryUnderstandingInfo.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag === 88) {
            message.answerSkippedReasons.push(reader.int32() as any);

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.answerSkippedReasons.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.completeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? answer_StateFromJSON(object.state) : 0,
      answerText: isSet(object.answerText) ? globalThis.String(object.answerText) : "",
      citations: globalThis.Array.isArray(object?.citations)
        ? object.citations.map((e: any) => Answer_Citation.fromJSON(e))
        : [],
      references: globalThis.Array.isArray(object?.references)
        ? object.references.map((e: any) => Answer_Reference.fromJSON(e))
        : [],
      relatedQuestions: globalThis.Array.isArray(object?.relatedQuestions)
        ? object.relatedQuestions.map((e: any) => globalThis.String(e))
        : [],
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => Answer_Step.fromJSON(e)) : [],
      queryUnderstandingInfo: isSet(object.queryUnderstandingInfo)
        ? Answer_QueryUnderstandingInfo.fromJSON(object.queryUnderstandingInfo)
        : undefined,
      answerSkippedReasons: globalThis.Array.isArray(object?.answerSkippedReasons)
        ? object.answerSkippedReasons.map((e: any) => answer_AnswerSkippedReasonFromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      completeTime: isSet(object.completeTime) ? fromJsonTimestamp(object.completeTime) : undefined,
    };
  },

  toJSON(message: Answer): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = answer_StateToJSON(message.state);
    }
    if (message.answerText !== "") {
      obj.answerText = message.answerText;
    }
    if (message.citations?.length) {
      obj.citations = message.citations.map((e) => Answer_Citation.toJSON(e));
    }
    if (message.references?.length) {
      obj.references = message.references.map((e) => Answer_Reference.toJSON(e));
    }
    if (message.relatedQuestions?.length) {
      obj.relatedQuestions = message.relatedQuestions;
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => Answer_Step.toJSON(e));
    }
    if (message.queryUnderstandingInfo !== undefined) {
      obj.queryUnderstandingInfo = Answer_QueryUnderstandingInfo.toJSON(message.queryUnderstandingInfo);
    }
    if (message.answerSkippedReasons?.length) {
      obj.answerSkippedReasons = message.answerSkippedReasons.map((e) => answer_AnswerSkippedReasonToJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.completeTime !== undefined) {
      obj.completeTime = message.completeTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Answer>): Answer {
    return Answer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Answer>): Answer {
    const message = createBaseAnswer();
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.answerText = object.answerText ?? "";
    message.citations = object.citations?.map((e) => Answer_Citation.fromPartial(e)) || [];
    message.references = object.references?.map((e) => Answer_Reference.fromPartial(e)) || [];
    message.relatedQuestions = object.relatedQuestions?.map((e) => e) || [];
    message.steps = object.steps?.map((e) => Answer_Step.fromPartial(e)) || [];
    message.queryUnderstandingInfo =
      (object.queryUnderstandingInfo !== undefined && object.queryUnderstandingInfo !== null)
        ? Answer_QueryUnderstandingInfo.fromPartial(object.queryUnderstandingInfo)
        : undefined;
    message.answerSkippedReasons = object.answerSkippedReasons?.map((e) => e) || [];
    message.createTime = object.createTime ?? undefined;
    message.completeTime = object.completeTime ?? undefined;
    return message;
  },
};

function createBaseAnswer_Citation(): Answer_Citation {
  return { startIndex: Long.ZERO, endIndex: Long.ZERO, sources: [] };
}

export const Answer_Citation: MessageFns<Answer_Citation> = {
  encode(message: Answer_Citation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.startIndex.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.startIndex.toString());
    }
    if (!message.endIndex.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.endIndex.toString());
    }
    for (const v of message.sources) {
      Answer_CitationSource.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Citation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Citation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startIndex = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endIndex = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sources.push(Answer_CitationSource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Citation {
    return {
      startIndex: isSet(object.startIndex) ? Long.fromValue(object.startIndex) : Long.ZERO,
      endIndex: isSet(object.endIndex) ? Long.fromValue(object.endIndex) : Long.ZERO,
      sources: globalThis.Array.isArray(object?.sources)
        ? object.sources.map((e: any) => Answer_CitationSource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Answer_Citation): unknown {
    const obj: any = {};
    if (!message.startIndex.equals(Long.ZERO)) {
      obj.startIndex = (message.startIndex || Long.ZERO).toString();
    }
    if (!message.endIndex.equals(Long.ZERO)) {
      obj.endIndex = (message.endIndex || Long.ZERO).toString();
    }
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => Answer_CitationSource.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Answer_Citation>): Answer_Citation {
    return Answer_Citation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Answer_Citation>): Answer_Citation {
    const message = createBaseAnswer_Citation();
    message.startIndex = (object.startIndex !== undefined && object.startIndex !== null)
      ? Long.fromValue(object.startIndex)
      : Long.ZERO;
    message.endIndex = (object.endIndex !== undefined && object.endIndex !== null)
      ? Long.fromValue(object.endIndex)
      : Long.ZERO;
    message.sources = object.sources?.map((e) => Answer_CitationSource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAnswer_CitationSource(): Answer_CitationSource {
  return { referenceId: "" };
}

export const Answer_CitationSource: MessageFns<Answer_CitationSource> = {
  encode(message: Answer_CitationSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceId !== "") {
      writer.uint32(10).string(message.referenceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_CitationSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_CitationSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referenceId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_CitationSource {
    return { referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : "" };
  },

  toJSON(message: Answer_CitationSource): unknown {
    const obj: any = {};
    if (message.referenceId !== "") {
      obj.referenceId = message.referenceId;
    }
    return obj;
  },

  create(base?: DeepPartial<Answer_CitationSource>): Answer_CitationSource {
    return Answer_CitationSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Answer_CitationSource>): Answer_CitationSource {
    const message = createBaseAnswer_CitationSource();
    message.referenceId = object.referenceId ?? "";
    return message;
  },
};

function createBaseAnswer_Reference(): Answer_Reference {
  return { unstructuredDocumentInfo: undefined, chunkInfo: undefined, structuredDocumentInfo: undefined };
}

export const Answer_Reference: MessageFns<Answer_Reference> = {
  encode(message: Answer_Reference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unstructuredDocumentInfo !== undefined) {
      Answer_Reference_UnstructuredDocumentInfo.encode(message.unstructuredDocumentInfo, writer.uint32(10).fork())
        .join();
    }
    if (message.chunkInfo !== undefined) {
      Answer_Reference_ChunkInfo.encode(message.chunkInfo, writer.uint32(18).fork()).join();
    }
    if (message.structuredDocumentInfo !== undefined) {
      Answer_Reference_StructuredDocumentInfo.encode(message.structuredDocumentInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Reference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Reference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unstructuredDocumentInfo = Answer_Reference_UnstructuredDocumentInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chunkInfo = Answer_Reference_ChunkInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.structuredDocumentInfo = Answer_Reference_StructuredDocumentInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Reference {
    return {
      unstructuredDocumentInfo: isSet(object.unstructuredDocumentInfo)
        ? Answer_Reference_UnstructuredDocumentInfo.fromJSON(object.unstructuredDocumentInfo)
        : undefined,
      chunkInfo: isSet(object.chunkInfo) ? Answer_Reference_ChunkInfo.fromJSON(object.chunkInfo) : undefined,
      structuredDocumentInfo: isSet(object.structuredDocumentInfo)
        ? Answer_Reference_StructuredDocumentInfo.fromJSON(object.structuredDocumentInfo)
        : undefined,
    };
  },

  toJSON(message: Answer_Reference): unknown {
    const obj: any = {};
    if (message.unstructuredDocumentInfo !== undefined) {
      obj.unstructuredDocumentInfo = Answer_Reference_UnstructuredDocumentInfo.toJSON(message.unstructuredDocumentInfo);
    }
    if (message.chunkInfo !== undefined) {
      obj.chunkInfo = Answer_Reference_ChunkInfo.toJSON(message.chunkInfo);
    }
    if (message.structuredDocumentInfo !== undefined) {
      obj.structuredDocumentInfo = Answer_Reference_StructuredDocumentInfo.toJSON(message.structuredDocumentInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<Answer_Reference>): Answer_Reference {
    return Answer_Reference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Answer_Reference>): Answer_Reference {
    const message = createBaseAnswer_Reference();
    message.unstructuredDocumentInfo =
      (object.unstructuredDocumentInfo !== undefined && object.unstructuredDocumentInfo !== null)
        ? Answer_Reference_UnstructuredDocumentInfo.fromPartial(object.unstructuredDocumentInfo)
        : undefined;
    message.chunkInfo = (object.chunkInfo !== undefined && object.chunkInfo !== null)
      ? Answer_Reference_ChunkInfo.fromPartial(object.chunkInfo)
      : undefined;
    message.structuredDocumentInfo =
      (object.structuredDocumentInfo !== undefined && object.structuredDocumentInfo !== null)
        ? Answer_Reference_StructuredDocumentInfo.fromPartial(object.structuredDocumentInfo)
        : undefined;
    return message;
  },
};

function createBaseAnswer_Reference_UnstructuredDocumentInfo(): Answer_Reference_UnstructuredDocumentInfo {
  return { document: "", uri: "", title: "", chunkContents: [], structData: undefined };
}

export const Answer_Reference_UnstructuredDocumentInfo: MessageFns<Answer_Reference_UnstructuredDocumentInfo> = {
  encode(message: Answer_Reference_UnstructuredDocumentInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.document !== "") {
      writer.uint32(10).string(message.document);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    for (const v of message.chunkContents) {
      Answer_Reference_UnstructuredDocumentInfo_ChunkContent.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.structData !== undefined) {
      Struct.encode(Struct.wrap(message.structData), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Reference_UnstructuredDocumentInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Reference_UnstructuredDocumentInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.document = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.chunkContents.push(
            Answer_Reference_UnstructuredDocumentInfo_ChunkContent.decode(reader, reader.uint32()),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.structData = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Reference_UnstructuredDocumentInfo {
    return {
      document: isSet(object.document) ? globalThis.String(object.document) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      chunkContents: globalThis.Array.isArray(object?.chunkContents)
        ? object.chunkContents.map((e: any) => Answer_Reference_UnstructuredDocumentInfo_ChunkContent.fromJSON(e))
        : [],
      structData: isObject(object.structData) ? object.structData : undefined,
    };
  },

  toJSON(message: Answer_Reference_UnstructuredDocumentInfo): unknown {
    const obj: any = {};
    if (message.document !== "") {
      obj.document = message.document;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.chunkContents?.length) {
      obj.chunkContents = message.chunkContents.map((e) =>
        Answer_Reference_UnstructuredDocumentInfo_ChunkContent.toJSON(e)
      );
    }
    if (message.structData !== undefined) {
      obj.structData = message.structData;
    }
    return obj;
  },

  create(base?: DeepPartial<Answer_Reference_UnstructuredDocumentInfo>): Answer_Reference_UnstructuredDocumentInfo {
    return Answer_Reference_UnstructuredDocumentInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Answer_Reference_UnstructuredDocumentInfo>,
  ): Answer_Reference_UnstructuredDocumentInfo {
    const message = createBaseAnswer_Reference_UnstructuredDocumentInfo();
    message.document = object.document ?? "";
    message.uri = object.uri ?? "";
    message.title = object.title ?? "";
    message.chunkContents =
      object.chunkContents?.map((e) => Answer_Reference_UnstructuredDocumentInfo_ChunkContent.fromPartial(e)) || [];
    message.structData = object.structData ?? undefined;
    return message;
  },
};

function createBaseAnswer_Reference_UnstructuredDocumentInfo_ChunkContent(): Answer_Reference_UnstructuredDocumentInfo_ChunkContent {
  return { content: "", pageIdentifier: "", relevanceScore: undefined };
}

export const Answer_Reference_UnstructuredDocumentInfo_ChunkContent: MessageFns<
  Answer_Reference_UnstructuredDocumentInfo_ChunkContent
> = {
  encode(
    message: Answer_Reference_UnstructuredDocumentInfo_ChunkContent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.pageIdentifier !== "") {
      writer.uint32(18).string(message.pageIdentifier);
    }
    if (message.relevanceScore !== undefined) {
      writer.uint32(29).float(message.relevanceScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Reference_UnstructuredDocumentInfo_ChunkContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Reference_UnstructuredDocumentInfo_ChunkContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageIdentifier = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.relevanceScore = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Reference_UnstructuredDocumentInfo_ChunkContent {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      pageIdentifier: isSet(object.pageIdentifier) ? globalThis.String(object.pageIdentifier) : "",
      relevanceScore: isSet(object.relevanceScore) ? globalThis.Number(object.relevanceScore) : undefined,
    };
  },

  toJSON(message: Answer_Reference_UnstructuredDocumentInfo_ChunkContent): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.pageIdentifier !== "") {
      obj.pageIdentifier = message.pageIdentifier;
    }
    if (message.relevanceScore !== undefined) {
      obj.relevanceScore = message.relevanceScore;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Answer_Reference_UnstructuredDocumentInfo_ChunkContent>,
  ): Answer_Reference_UnstructuredDocumentInfo_ChunkContent {
    return Answer_Reference_UnstructuredDocumentInfo_ChunkContent.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Answer_Reference_UnstructuredDocumentInfo_ChunkContent>,
  ): Answer_Reference_UnstructuredDocumentInfo_ChunkContent {
    const message = createBaseAnswer_Reference_UnstructuredDocumentInfo_ChunkContent();
    message.content = object.content ?? "";
    message.pageIdentifier = object.pageIdentifier ?? "";
    message.relevanceScore = object.relevanceScore ?? undefined;
    return message;
  },
};

function createBaseAnswer_Reference_ChunkInfo(): Answer_Reference_ChunkInfo {
  return { chunk: "", content: "", relevanceScore: undefined, documentMetadata: undefined };
}

export const Answer_Reference_ChunkInfo: MessageFns<Answer_Reference_ChunkInfo> = {
  encode(message: Answer_Reference_ChunkInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chunk !== "") {
      writer.uint32(10).string(message.chunk);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.relevanceScore !== undefined) {
      writer.uint32(29).float(message.relevanceScore);
    }
    if (message.documentMetadata !== undefined) {
      Answer_Reference_ChunkInfo_DocumentMetadata.encode(message.documentMetadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Reference_ChunkInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Reference_ChunkInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chunk = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.relevanceScore = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.documentMetadata = Answer_Reference_ChunkInfo_DocumentMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Reference_ChunkInfo {
    return {
      chunk: isSet(object.chunk) ? globalThis.String(object.chunk) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      relevanceScore: isSet(object.relevanceScore) ? globalThis.Number(object.relevanceScore) : undefined,
      documentMetadata: isSet(object.documentMetadata)
        ? Answer_Reference_ChunkInfo_DocumentMetadata.fromJSON(object.documentMetadata)
        : undefined,
    };
  },

  toJSON(message: Answer_Reference_ChunkInfo): unknown {
    const obj: any = {};
    if (message.chunk !== "") {
      obj.chunk = message.chunk;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.relevanceScore !== undefined) {
      obj.relevanceScore = message.relevanceScore;
    }
    if (message.documentMetadata !== undefined) {
      obj.documentMetadata = Answer_Reference_ChunkInfo_DocumentMetadata.toJSON(message.documentMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<Answer_Reference_ChunkInfo>): Answer_Reference_ChunkInfo {
    return Answer_Reference_ChunkInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Answer_Reference_ChunkInfo>): Answer_Reference_ChunkInfo {
    const message = createBaseAnswer_Reference_ChunkInfo();
    message.chunk = object.chunk ?? "";
    message.content = object.content ?? "";
    message.relevanceScore = object.relevanceScore ?? undefined;
    message.documentMetadata = (object.documentMetadata !== undefined && object.documentMetadata !== null)
      ? Answer_Reference_ChunkInfo_DocumentMetadata.fromPartial(object.documentMetadata)
      : undefined;
    return message;
  },
};

function createBaseAnswer_Reference_ChunkInfo_DocumentMetadata(): Answer_Reference_ChunkInfo_DocumentMetadata {
  return { document: "", uri: "", title: "", pageIdentifier: "", structData: undefined };
}

export const Answer_Reference_ChunkInfo_DocumentMetadata: MessageFns<Answer_Reference_ChunkInfo_DocumentMetadata> = {
  encode(
    message: Answer_Reference_ChunkInfo_DocumentMetadata,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.document !== "") {
      writer.uint32(10).string(message.document);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.pageIdentifier !== "") {
      writer.uint32(34).string(message.pageIdentifier);
    }
    if (message.structData !== undefined) {
      Struct.encode(Struct.wrap(message.structData), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Reference_ChunkInfo_DocumentMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Reference_ChunkInfo_DocumentMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.document = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageIdentifier = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.structData = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Reference_ChunkInfo_DocumentMetadata {
    return {
      document: isSet(object.document) ? globalThis.String(object.document) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      pageIdentifier: isSet(object.pageIdentifier) ? globalThis.String(object.pageIdentifier) : "",
      structData: isObject(object.structData) ? object.structData : undefined,
    };
  },

  toJSON(message: Answer_Reference_ChunkInfo_DocumentMetadata): unknown {
    const obj: any = {};
    if (message.document !== "") {
      obj.document = message.document;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.pageIdentifier !== "") {
      obj.pageIdentifier = message.pageIdentifier;
    }
    if (message.structData !== undefined) {
      obj.structData = message.structData;
    }
    return obj;
  },

  create(base?: DeepPartial<Answer_Reference_ChunkInfo_DocumentMetadata>): Answer_Reference_ChunkInfo_DocumentMetadata {
    return Answer_Reference_ChunkInfo_DocumentMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Answer_Reference_ChunkInfo_DocumentMetadata>,
  ): Answer_Reference_ChunkInfo_DocumentMetadata {
    const message = createBaseAnswer_Reference_ChunkInfo_DocumentMetadata();
    message.document = object.document ?? "";
    message.uri = object.uri ?? "";
    message.title = object.title ?? "";
    message.pageIdentifier = object.pageIdentifier ?? "";
    message.structData = object.structData ?? undefined;
    return message;
  },
};

function createBaseAnswer_Reference_StructuredDocumentInfo(): Answer_Reference_StructuredDocumentInfo {
  return { document: "", structData: undefined };
}

export const Answer_Reference_StructuredDocumentInfo: MessageFns<Answer_Reference_StructuredDocumentInfo> = {
  encode(message: Answer_Reference_StructuredDocumentInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.document !== "") {
      writer.uint32(10).string(message.document);
    }
    if (message.structData !== undefined) {
      Struct.encode(Struct.wrap(message.structData), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Reference_StructuredDocumentInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Reference_StructuredDocumentInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.document = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.structData = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Reference_StructuredDocumentInfo {
    return {
      document: isSet(object.document) ? globalThis.String(object.document) : "",
      structData: isObject(object.structData) ? object.structData : undefined,
    };
  },

  toJSON(message: Answer_Reference_StructuredDocumentInfo): unknown {
    const obj: any = {};
    if (message.document !== "") {
      obj.document = message.document;
    }
    if (message.structData !== undefined) {
      obj.structData = message.structData;
    }
    return obj;
  },

  create(base?: DeepPartial<Answer_Reference_StructuredDocumentInfo>): Answer_Reference_StructuredDocumentInfo {
    return Answer_Reference_StructuredDocumentInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Answer_Reference_StructuredDocumentInfo>): Answer_Reference_StructuredDocumentInfo {
    const message = createBaseAnswer_Reference_StructuredDocumentInfo();
    message.document = object.document ?? "";
    message.structData = object.structData ?? undefined;
    return message;
  },
};

function createBaseAnswer_Step(): Answer_Step {
  return { state: 0, description: "", thought: "", actions: [] };
}

export const Answer_Step: MessageFns<Answer_Step> = {
  encode(message: Answer_Step, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.thought !== "") {
      writer.uint32(26).string(message.thought);
    }
    for (const v of message.actions) {
      Answer_Step_Action.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Step {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Step();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.thought = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.actions.push(Answer_Step_Action.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Step {
    return {
      state: isSet(object.state) ? answer_Step_StateFromJSON(object.state) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      thought: isSet(object.thought) ? globalThis.String(object.thought) : "",
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => Answer_Step_Action.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Answer_Step): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = answer_Step_StateToJSON(message.state);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.thought !== "") {
      obj.thought = message.thought;
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => Answer_Step_Action.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Answer_Step>): Answer_Step {
    return Answer_Step.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Answer_Step>): Answer_Step {
    const message = createBaseAnswer_Step();
    message.state = object.state ?? 0;
    message.description = object.description ?? "";
    message.thought = object.thought ?? "";
    message.actions = object.actions?.map((e) => Answer_Step_Action.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAnswer_Step_Action(): Answer_Step_Action {
  return { searchAction: undefined, observation: undefined };
}

export const Answer_Step_Action: MessageFns<Answer_Step_Action> = {
  encode(message: Answer_Step_Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchAction !== undefined) {
      Answer_Step_Action_SearchAction.encode(message.searchAction, writer.uint32(18).fork()).join();
    }
    if (message.observation !== undefined) {
      Answer_Step_Action_Observation.encode(message.observation, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Step_Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Step_Action();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.searchAction = Answer_Step_Action_SearchAction.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.observation = Answer_Step_Action_Observation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Step_Action {
    return {
      searchAction: isSet(object.searchAction)
        ? Answer_Step_Action_SearchAction.fromJSON(object.searchAction)
        : undefined,
      observation: isSet(object.observation) ? Answer_Step_Action_Observation.fromJSON(object.observation) : undefined,
    };
  },

  toJSON(message: Answer_Step_Action): unknown {
    const obj: any = {};
    if (message.searchAction !== undefined) {
      obj.searchAction = Answer_Step_Action_SearchAction.toJSON(message.searchAction);
    }
    if (message.observation !== undefined) {
      obj.observation = Answer_Step_Action_Observation.toJSON(message.observation);
    }
    return obj;
  },

  create(base?: DeepPartial<Answer_Step_Action>): Answer_Step_Action {
    return Answer_Step_Action.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Answer_Step_Action>): Answer_Step_Action {
    const message = createBaseAnswer_Step_Action();
    message.searchAction = (object.searchAction !== undefined && object.searchAction !== null)
      ? Answer_Step_Action_SearchAction.fromPartial(object.searchAction)
      : undefined;
    message.observation = (object.observation !== undefined && object.observation !== null)
      ? Answer_Step_Action_Observation.fromPartial(object.observation)
      : undefined;
    return message;
  },
};

function createBaseAnswer_Step_Action_SearchAction(): Answer_Step_Action_SearchAction {
  return { query: "" };
}

export const Answer_Step_Action_SearchAction: MessageFns<Answer_Step_Action_SearchAction> = {
  encode(message: Answer_Step_Action_SearchAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Step_Action_SearchAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Step_Action_SearchAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Step_Action_SearchAction {
    return { query: isSet(object.query) ? globalThis.String(object.query) : "" };
  },

  toJSON(message: Answer_Step_Action_SearchAction): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create(base?: DeepPartial<Answer_Step_Action_SearchAction>): Answer_Step_Action_SearchAction {
    return Answer_Step_Action_SearchAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Answer_Step_Action_SearchAction>): Answer_Step_Action_SearchAction {
    const message = createBaseAnswer_Step_Action_SearchAction();
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseAnswer_Step_Action_Observation(): Answer_Step_Action_Observation {
  return { searchResults: [] };
}

export const Answer_Step_Action_Observation: MessageFns<Answer_Step_Action_Observation> = {
  encode(message: Answer_Step_Action_Observation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.searchResults) {
      Answer_Step_Action_Observation_SearchResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Step_Action_Observation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Step_Action_Observation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.searchResults.push(Answer_Step_Action_Observation_SearchResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Step_Action_Observation {
    return {
      searchResults: globalThis.Array.isArray(object?.searchResults)
        ? object.searchResults.map((e: any) => Answer_Step_Action_Observation_SearchResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Answer_Step_Action_Observation): unknown {
    const obj: any = {};
    if (message.searchResults?.length) {
      obj.searchResults = message.searchResults.map((e) => Answer_Step_Action_Observation_SearchResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Answer_Step_Action_Observation>): Answer_Step_Action_Observation {
    return Answer_Step_Action_Observation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Answer_Step_Action_Observation>): Answer_Step_Action_Observation {
    const message = createBaseAnswer_Step_Action_Observation();
    message.searchResults =
      object.searchResults?.map((e) => Answer_Step_Action_Observation_SearchResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAnswer_Step_Action_Observation_SearchResult(): Answer_Step_Action_Observation_SearchResult {
  return { document: "", uri: "", title: "", snippetInfo: [], chunkInfo: [], structData: undefined };
}

export const Answer_Step_Action_Observation_SearchResult: MessageFns<Answer_Step_Action_Observation_SearchResult> = {
  encode(
    message: Answer_Step_Action_Observation_SearchResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.document !== "") {
      writer.uint32(10).string(message.document);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    for (const v of message.snippetInfo) {
      Answer_Step_Action_Observation_SearchResult_SnippetInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.chunkInfo) {
      Answer_Step_Action_Observation_SearchResult_ChunkInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.structData !== undefined) {
      Struct.encode(Struct.wrap(message.structData), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Step_Action_Observation_SearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Step_Action_Observation_SearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.document = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.snippetInfo.push(
            Answer_Step_Action_Observation_SearchResult_SnippetInfo.decode(reader, reader.uint32()),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.chunkInfo.push(Answer_Step_Action_Observation_SearchResult_ChunkInfo.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.structData = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Step_Action_Observation_SearchResult {
    return {
      document: isSet(object.document) ? globalThis.String(object.document) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      snippetInfo: globalThis.Array.isArray(object?.snippetInfo)
        ? object.snippetInfo.map((e: any) => Answer_Step_Action_Observation_SearchResult_SnippetInfo.fromJSON(e))
        : [],
      chunkInfo: globalThis.Array.isArray(object?.chunkInfo)
        ? object.chunkInfo.map((e: any) => Answer_Step_Action_Observation_SearchResult_ChunkInfo.fromJSON(e))
        : [],
      structData: isObject(object.structData) ? object.structData : undefined,
    };
  },

  toJSON(message: Answer_Step_Action_Observation_SearchResult): unknown {
    const obj: any = {};
    if (message.document !== "") {
      obj.document = message.document;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.snippetInfo?.length) {
      obj.snippetInfo = message.snippetInfo.map((e) =>
        Answer_Step_Action_Observation_SearchResult_SnippetInfo.toJSON(e)
      );
    }
    if (message.chunkInfo?.length) {
      obj.chunkInfo = message.chunkInfo.map((e) => Answer_Step_Action_Observation_SearchResult_ChunkInfo.toJSON(e));
    }
    if (message.structData !== undefined) {
      obj.structData = message.structData;
    }
    return obj;
  },

  create(base?: DeepPartial<Answer_Step_Action_Observation_SearchResult>): Answer_Step_Action_Observation_SearchResult {
    return Answer_Step_Action_Observation_SearchResult.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Answer_Step_Action_Observation_SearchResult>,
  ): Answer_Step_Action_Observation_SearchResult {
    const message = createBaseAnswer_Step_Action_Observation_SearchResult();
    message.document = object.document ?? "";
    message.uri = object.uri ?? "";
    message.title = object.title ?? "";
    message.snippetInfo =
      object.snippetInfo?.map((e) => Answer_Step_Action_Observation_SearchResult_SnippetInfo.fromPartial(e)) || [];
    message.chunkInfo =
      object.chunkInfo?.map((e) => Answer_Step_Action_Observation_SearchResult_ChunkInfo.fromPartial(e)) || [];
    message.structData = object.structData ?? undefined;
    return message;
  },
};

function createBaseAnswer_Step_Action_Observation_SearchResult_SnippetInfo(): Answer_Step_Action_Observation_SearchResult_SnippetInfo {
  return { snippet: "", snippetStatus: "" };
}

export const Answer_Step_Action_Observation_SearchResult_SnippetInfo: MessageFns<
  Answer_Step_Action_Observation_SearchResult_SnippetInfo
> = {
  encode(
    message: Answer_Step_Action_Observation_SearchResult_SnippetInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.snippet !== "") {
      writer.uint32(10).string(message.snippet);
    }
    if (message.snippetStatus !== "") {
      writer.uint32(18).string(message.snippetStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Step_Action_Observation_SearchResult_SnippetInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Step_Action_Observation_SearchResult_SnippetInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.snippet = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.snippetStatus = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Step_Action_Observation_SearchResult_SnippetInfo {
    return {
      snippet: isSet(object.snippet) ? globalThis.String(object.snippet) : "",
      snippetStatus: isSet(object.snippetStatus) ? globalThis.String(object.snippetStatus) : "",
    };
  },

  toJSON(message: Answer_Step_Action_Observation_SearchResult_SnippetInfo): unknown {
    const obj: any = {};
    if (message.snippet !== "") {
      obj.snippet = message.snippet;
    }
    if (message.snippetStatus !== "") {
      obj.snippetStatus = message.snippetStatus;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Answer_Step_Action_Observation_SearchResult_SnippetInfo>,
  ): Answer_Step_Action_Observation_SearchResult_SnippetInfo {
    return Answer_Step_Action_Observation_SearchResult_SnippetInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Answer_Step_Action_Observation_SearchResult_SnippetInfo>,
  ): Answer_Step_Action_Observation_SearchResult_SnippetInfo {
    const message = createBaseAnswer_Step_Action_Observation_SearchResult_SnippetInfo();
    message.snippet = object.snippet ?? "";
    message.snippetStatus = object.snippetStatus ?? "";
    return message;
  },
};

function createBaseAnswer_Step_Action_Observation_SearchResult_ChunkInfo(): Answer_Step_Action_Observation_SearchResult_ChunkInfo {
  return { chunk: "", content: "", relevanceScore: undefined };
}

export const Answer_Step_Action_Observation_SearchResult_ChunkInfo: MessageFns<
  Answer_Step_Action_Observation_SearchResult_ChunkInfo
> = {
  encode(
    message: Answer_Step_Action_Observation_SearchResult_ChunkInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.chunk !== "") {
      writer.uint32(10).string(message.chunk);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.relevanceScore !== undefined) {
      writer.uint32(29).float(message.relevanceScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_Step_Action_Observation_SearchResult_ChunkInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_Step_Action_Observation_SearchResult_ChunkInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chunk = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.relevanceScore = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_Step_Action_Observation_SearchResult_ChunkInfo {
    return {
      chunk: isSet(object.chunk) ? globalThis.String(object.chunk) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      relevanceScore: isSet(object.relevanceScore) ? globalThis.Number(object.relevanceScore) : undefined,
    };
  },

  toJSON(message: Answer_Step_Action_Observation_SearchResult_ChunkInfo): unknown {
    const obj: any = {};
    if (message.chunk !== "") {
      obj.chunk = message.chunk;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.relevanceScore !== undefined) {
      obj.relevanceScore = message.relevanceScore;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Answer_Step_Action_Observation_SearchResult_ChunkInfo>,
  ): Answer_Step_Action_Observation_SearchResult_ChunkInfo {
    return Answer_Step_Action_Observation_SearchResult_ChunkInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Answer_Step_Action_Observation_SearchResult_ChunkInfo>,
  ): Answer_Step_Action_Observation_SearchResult_ChunkInfo {
    const message = createBaseAnswer_Step_Action_Observation_SearchResult_ChunkInfo();
    message.chunk = object.chunk ?? "";
    message.content = object.content ?? "";
    message.relevanceScore = object.relevanceScore ?? undefined;
    return message;
  },
};

function createBaseAnswer_QueryUnderstandingInfo(): Answer_QueryUnderstandingInfo {
  return { queryClassificationInfo: [] };
}

export const Answer_QueryUnderstandingInfo: MessageFns<Answer_QueryUnderstandingInfo> = {
  encode(message: Answer_QueryUnderstandingInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.queryClassificationInfo) {
      Answer_QueryUnderstandingInfo_QueryClassificationInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_QueryUnderstandingInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_QueryUnderstandingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryClassificationInfo.push(
            Answer_QueryUnderstandingInfo_QueryClassificationInfo.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_QueryUnderstandingInfo {
    return {
      queryClassificationInfo: globalThis.Array.isArray(object?.queryClassificationInfo)
        ? object.queryClassificationInfo.map((e: any) =>
          Answer_QueryUnderstandingInfo_QueryClassificationInfo.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: Answer_QueryUnderstandingInfo): unknown {
    const obj: any = {};
    if (message.queryClassificationInfo?.length) {
      obj.queryClassificationInfo = message.queryClassificationInfo.map((e) =>
        Answer_QueryUnderstandingInfo_QueryClassificationInfo.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<Answer_QueryUnderstandingInfo>): Answer_QueryUnderstandingInfo {
    return Answer_QueryUnderstandingInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Answer_QueryUnderstandingInfo>): Answer_QueryUnderstandingInfo {
    const message = createBaseAnswer_QueryUnderstandingInfo();
    message.queryClassificationInfo =
      object.queryClassificationInfo?.map((e) =>
        Answer_QueryUnderstandingInfo_QueryClassificationInfo.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseAnswer_QueryUnderstandingInfo_QueryClassificationInfo(): Answer_QueryUnderstandingInfo_QueryClassificationInfo {
  return { type: 0, positive: false };
}

export const Answer_QueryUnderstandingInfo_QueryClassificationInfo: MessageFns<
  Answer_QueryUnderstandingInfo_QueryClassificationInfo
> = {
  encode(
    message: Answer_QueryUnderstandingInfo_QueryClassificationInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.positive !== false) {
      writer.uint32(16).bool(message.positive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Answer_QueryUnderstandingInfo_QueryClassificationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswer_QueryUnderstandingInfo_QueryClassificationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.positive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Answer_QueryUnderstandingInfo_QueryClassificationInfo {
    return {
      type: isSet(object.type) ? answer_QueryUnderstandingInfo_QueryClassificationInfo_TypeFromJSON(object.type) : 0,
      positive: isSet(object.positive) ? globalThis.Boolean(object.positive) : false,
    };
  },

  toJSON(message: Answer_QueryUnderstandingInfo_QueryClassificationInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = answer_QueryUnderstandingInfo_QueryClassificationInfo_TypeToJSON(message.type);
    }
    if (message.positive !== false) {
      obj.positive = message.positive;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Answer_QueryUnderstandingInfo_QueryClassificationInfo>,
  ): Answer_QueryUnderstandingInfo_QueryClassificationInfo {
    return Answer_QueryUnderstandingInfo_QueryClassificationInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Answer_QueryUnderstandingInfo_QueryClassificationInfo>,
  ): Answer_QueryUnderstandingInfo_QueryClassificationInfo {
    const message = createBaseAnswer_QueryUnderstandingInfo_QueryClassificationInfo();
    message.type = object.type ?? 0;
    message.positive = object.positive ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
