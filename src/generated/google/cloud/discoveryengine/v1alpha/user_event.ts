// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/discoveryengine/v1alpha/user_event.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { CustomAttribute, UserInfo } from "./common.js";

export const protobufPackage = "google.cloud.discoveryengine.v1alpha";

/**
 * UserEvent captures all metadata information Discovery Engine API needs to
 * know about how end users interact with your website.
 */
export interface UserEvent {
  /**
   * Required. User event type. Allowed values are:
   *
   * Generic values:
   *
   * * `search`: Search for Documents.
   * * `view-item`: Detailed page view of a Document.
   * * `view-item-list`: View of a panel or ordered list of Documents.
   * * `view-home-page`: View of the home page.
   * * `view-category-page`: View of a category page, e.g. Home > Men > Jeans
   *
   * Retail-related values:
   *
   * * `add-to-cart`: Add an item(s) to cart, e.g. in Retail online shopping
   * * `purchase`: Purchase an item(s)
   *
   * Media-related values:
   *
   * * `media-play`: Start/resume watching a video, playing a song, etc.
   * * `media-complete`: Finished or stopped midway through a video, song, etc.
   */
  eventType: string;
  /**
   * Required. A unique identifier for tracking visitors.
   *
   * For example, this could be implemented with an HTTP cookie, which should be
   * able to uniquely identify a visitor on a single device. This unique
   * identifier should not change if the visitor log in/out of the website.
   *
   * Do not set the field to the same fixed ID for different users. This mixes
   * the event history of those users together, which results in degraded model
   * quality.
   *
   * The field must be a UTF-8 encoded string with a length limit of 128
   * characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
   *
   * The field should not contain PII or user-data. We recommend to use Google
   * Analytics [Client
   * ID](https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference#clientId)
   * for this field.
   */
  userPseudoId: string;
  /**
   * The [Engine][google.cloud.discoveryengine.v1alpha.Engine] resource name, in
   * the form of
   * `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
   *
   * Optional. Only required for
   * [Engine][google.cloud.discoveryengine.v1alpha.Engine] produced user events.
   * For example, user events from blended search.
   */
  engine: string;
  /**
   * The [DataStore][google.cloud.discoveryengine.v1alpha.DataStore] resource
   * full name, of the form
   * `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
   *
   * Optional. Only required for user events whose data store can't by
   * determined by
   * [UserEvent.engine][google.cloud.discoveryengine.v1alpha.UserEvent.engine]
   * or
   * [UserEvent.documents][google.cloud.discoveryengine.v1alpha.UserEvent.documents].
   * If data store is set in the parent of write/import/collect user event
   * requests, this field can be omitted.
   */
  dataStore: string;
  /**
   * Only required for
   * [UserEventService.ImportUserEvents][google.cloud.discoveryengine.v1alpha.UserEventService.ImportUserEvents]
   * method. Timestamp of when the user event happened.
   */
  eventTime:
    | Date
    | undefined;
  /** Information about the end user. */
  userInfo:
    | UserInfo
    | undefined;
  /**
   * Should set to true if the request is made directly from the end user, in
   * which case the
   * [UserEvent.user_info.user_agent][google.cloud.discoveryengine.v1alpha.UserInfo.user_agent]
   * can be populated from the HTTP request.
   *
   * This flag should be set only if the API request is made directly from the
   * end user such as a mobile app (and not if a gateway or a server is
   * processing and pushing the user events).
   *
   * This should not be set when using the JavaScript tag in
   * [UserEventService.CollectUserEvent][google.cloud.discoveryengine.v1alpha.UserEventService.CollectUserEvent].
   */
  directUserRequest: boolean;
  /**
   * A unique identifier for tracking a visitor session with a length limit of
   * 128 bytes. A session is an aggregation of an end user behavior in a time
   * span.
   *
   * A general guideline to populate the session_id:
   *
   * 1. If user has no activity for 30 min, a new session_id should be assigned.
   * 2. The session_id should be unique across users, suggest use uuid or add
   * [UserEvent.user_pseudo_id][google.cloud.discoveryengine.v1alpha.UserEvent.user_pseudo_id]
   * as prefix.
   */
  sessionId: string;
  /**
   * Page metadata such as categories and other critical information for certain
   * event types such as `view-category-page`.
   */
  pageInfo:
    | PageInfo
    | undefined;
  /**
   * Token to attribute an API response to user action(s) to trigger the event.
   *
   * Highly recommended for user events that are the result of
   * [RecommendationService.Recommend][google.cloud.discoveryengine.v1alpha.RecommendationService.Recommend].
   * This field enables accurate attribution of recommendation model
   * performance.
   *
   * The value must be one of:
   *
   * * [RecommendResponse.attribution_token][google.cloud.discoveryengine.v1alpha.RecommendResponse.attribution_token] for events that are the result of
   * [RecommendationService.Recommend][google.cloud.discoveryengine.v1alpha.RecommendationService.Recommend].
   * * [SearchResponse.attribution_token][google.cloud.discoveryengine.v1alpha.SearchResponse.attribution_token] for events that are the result of
   * [SearchService.Search][google.cloud.discoveryengine.v1alpha.SearchService.Search].
   *
   * This token enables us to accurately attribute page view or conversion
   * completion back to the event and the particular predict response containing
   * this clicked/purchased product. If user clicks on product K in the
   * recommendation results, pass
   * [RecommendResponse.attribution_token][google.cloud.discoveryengine.v1alpha.RecommendResponse.attribution_token]
   * as a URL parameter to product K's page. When recording events on product
   * K's page, log the
   * [RecommendResponse.attribution_token][google.cloud.discoveryengine.v1alpha.RecommendResponse.attribution_token]
   * to this field.
   */
  attributionToken: string;
  /**
   * The filter syntax consists of an expression language for constructing a
   * predicate from one or more fields of the documents being filtered.
   *
   * One example is for `search` events, the associated
   * [SearchRequest][google.cloud.discoveryengine.v1alpha.SearchRequest] may
   * contain a filter expression in
   * [SearchRequest.filter][google.cloud.discoveryengine.v1alpha.SearchRequest.filter]
   * conforming to https://google.aip.dev/160#filtering.
   *
   * Similarly, for `view-item-list` events that are generated from a
   * [RecommendRequest][google.cloud.discoveryengine.v1alpha.RecommendRequest],
   * this field may be populated directly from
   * [RecommendRequest.filter][google.cloud.discoveryengine.v1alpha.RecommendRequest.filter]
   * conforming to https://google.aip.dev/160#filtering.
   *
   * The value must be a UTF-8 encoded string with a length limit of 1,000
   * characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
   */
  filter: string;
  /**
   * List of [Document][google.cloud.discoveryengine.v1alpha.Document]s
   * associated with this user event.
   *
   * This field is optional except for the following event types:
   *
   * * `view-item`
   * * `add-to-cart`
   * * `purchase`
   * * `media-play`
   * * `media-complete`
   *
   * In a `search` event, this field represents the documents returned to the
   * end user on the current page (the end user may have not finished browsing
   * the whole page yet). When a new page is returned to the end user, after
   * pagination/filtering/ordering even for the same query, a new `search` event
   * with different
   * [UserEvent.documents][google.cloud.discoveryengine.v1alpha.UserEvent.documents]
   * is desired.
   */
  documents: DocumentInfo[];
  /** Panel metadata associated with this user event. */
  panel:
    | PanelInfo
    | undefined;
  /**
   * [SearchService.Search][google.cloud.discoveryengine.v1alpha.SearchService.Search]
   * details related to the event.
   *
   * This field should be set for `search` event.
   */
  searchInfo:
    | SearchInfo
    | undefined;
  /**
   * [CompletionService.CompleteQuery][google.cloud.discoveryengine.v1alpha.CompletionService.CompleteQuery]
   * details related to the event.
   *
   * This field should be set for `search` event when autocomplete function is
   * enabled and the user clicks a suggestion for search.
   */
  completionInfo:
    | CompletionInfo
    | undefined;
  /** The transaction metadata (if any) associated with this user event. */
  transactionInfo:
    | TransactionInfo
    | undefined;
  /**
   * A list of identifiers for the independent experiment groups this user event
   * belongs to. This is used to distinguish between user events associated with
   * different experiment setups.
   */
  tagIds: string[];
  /**
   * The promotion IDs if this is an event associated with promotions.
   * Currently, this field is restricted to at most one ID.
   */
  promotionIds: string[];
  /**
   * Extra user event features to include in the recommendation model.
   * These attributes must NOT contain data that needs to be parsed or processed
   * further, e.g. JSON or other encodings.
   *
   * If you provide custom attributes for ingested user events, also include
   * them in the user events that you associate with prediction requests. Custom
   * attribute formatting must be consistent between imported events and events
   * provided with prediction requests. This lets the Discovery Engine API use
   * those custom attributes when training models and serving predictions, which
   * helps improve recommendation quality.
   *
   * This field needs to pass all below criteria, otherwise an
   * `INVALID_ARGUMENT` error is returned:
   *
   * * The key must be a UTF-8 encoded string with a length limit of 5,000
   *   characters.
   * * For text attributes, at most 400 values are allowed. Empty values are not
   *   allowed. Each value must be a UTF-8 encoded string with a length limit of
   *   256 characters.
   * * For number attributes, at most 400 values are allowed.
   *
   * For product recommendations, an example of extra user information is
   * `traffic_channel`, which is how a user arrives at the site. Users can
   * arrive
   * at the site by coming to the site directly, coming through Google
   * search, or in other ways.
   */
  attributes: { [key: string]: CustomAttribute };
  /** Media-specific info. */
  mediaInfo: MediaInfo | undefined;
}

export interface UserEvent_AttributesEntry {
  key: string;
  value: CustomAttribute | undefined;
}

/** Detailed page information. */
export interface PageInfo {
  /**
   * A unique ID of a web page view.
   *
   * This should be kept the same for all user events triggered from the same
   * pageview. For example, an item detail page view could trigger multiple
   * events as the user is browsing the page. The `pageview_id` property should
   * be kept the same for all these events so that they can be grouped together
   * properly.
   *
   * When using the client side event reporting with JavaScript pixel and Google
   * Tag Manager, this value is filled in automatically.
   */
  pageviewId: string;
  /**
   * The most specific category associated with a category page.
   *
   * To represent full path of category, use '>' sign to separate different
   * hierarchies. If '>' is part of the category name, replace it with
   * other character(s).
   *
   * Category pages include special pages such as sales or promotions. For
   * instance, a special sale page may have the category hierarchy:
   * `"pageCategory" : "Sales > 2017 Black Friday Deals"`.
   *
   * Required for `view-category-page` events. Other event types should not set
   * this field. Otherwise, an `INVALID_ARGUMENT` error is returned.
   */
  pageCategory: string;
  /**
   * Complete URL (window.location.href) of the user's current page.
   *
   * When using the client side event reporting with JavaScript pixel and Google
   * Tag Manager, this value is filled in automatically. Maximum length 5,000
   * characters.
   */
  uri: string;
  /**
   * The referrer URL of the current page.
   *
   * When using the client side event reporting with JavaScript pixel and Google
   * Tag Manager, this value is filled in automatically. However, some browser
   * privacy restrictions may cause this field to be empty.
   */
  referrerUri: string;
}

/** Detailed search information. */
export interface SearchInfo {
  /**
   * The user's search query.
   *
   * See
   * [SearchRequest.query][google.cloud.discoveryengine.v1alpha.SearchRequest.query]
   * for definition.
   *
   * The value must be a UTF-8 encoded string with a length limit of 5,000
   * characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
   *
   * At least one of
   * [search_query][google.cloud.discoveryengine.v1alpha.SearchInfo.search_query]
   * or
   * [PageInfo.page_category][google.cloud.discoveryengine.v1alpha.PageInfo.page_category]
   * is required for `search` events. Other event types should not set this
   * field. Otherwise, an `INVALID_ARGUMENT` error is returned.
   */
  searchQuery: string;
  /**
   * The order in which products are returned, if applicable.
   *
   * See
   * [SearchRequest.order_by][google.cloud.discoveryengine.v1alpha.SearchRequest.order_by]
   * for definition and syntax.
   *
   * The value must be a UTF-8 encoded string with a length limit of 1,000
   * characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
   *
   * This can only be set for `search` events. Other event types should not set
   * this field. Otherwise, an `INVALID_ARGUMENT` error is returned.
   */
  orderBy: string;
  /**
   * An integer that specifies the current offset for pagination (the 0-indexed
   * starting location, amongst the products deemed by the API as relevant).
   *
   * See
   * [SearchRequest.offset][google.cloud.discoveryengine.v1alpha.SearchRequest.offset]
   * for definition.
   *
   * If this field is negative, an `INVALID_ARGUMENT` is returned.
   *
   * This can only be set for `search` events. Other event types should not set
   * this field. Otherwise, an `INVALID_ARGUMENT` error is returned.
   */
  offset?: number | undefined;
}

/**
 * Detailed completion information including completion attribution token and
 * clicked completion info.
 */
export interface CompletionInfo {
  /**
   * End user selected
   * [CompleteQueryResponse.QuerySuggestion.suggestion][google.cloud.discoveryengine.v1alpha.CompleteQueryResponse.QuerySuggestion.suggestion].
   */
  selectedSuggestion: string;
  /**
   * End user selected
   * [CompleteQueryResponse.QuerySuggestion.suggestion][google.cloud.discoveryengine.v1alpha.CompleteQueryResponse.QuerySuggestion.suggestion]
   * position, starting from 0.
   */
  selectedPosition: number;
}

/** A transaction represents the entire purchase transaction. */
export interface TransactionInfo {
  /**
   * Required. Total non-zero value associated with the transaction. This value
   * may include shipping, tax, or other adjustments to the total value that you
   * want to include.
   */
  value?:
    | number
    | undefined;
  /** Required. Currency code. Use three-character ISO-4217 code. */
  currency: string;
  /** The transaction ID with a length limit of 128 characters. */
  transactionId: string;
  /** All the taxes associated with the transaction. */
  tax?:
    | number
    | undefined;
  /**
   * All the costs associated with the products. These can be manufacturing
   * costs, shipping expenses not borne by the end user, or any other costs,
   * such that:
   *
   * * Profit =
   * [value][google.cloud.discoveryengine.v1alpha.TransactionInfo.value] -
   * [tax][google.cloud.discoveryengine.v1alpha.TransactionInfo.tax] -
   * [cost][google.cloud.discoveryengine.v1alpha.TransactionInfo.cost]
   */
  cost?:
    | number
    | undefined;
  /**
   * The total discount(s) value applied to this transaction.
   * This figure should be excluded from
   * [TransactionInfo.value][google.cloud.discoveryengine.v1alpha.TransactionInfo.value]
   *
   * For example, if a user paid
   * [TransactionInfo.value][google.cloud.discoveryengine.v1alpha.TransactionInfo.value]
   * amount, then nominal (pre-discount) value of the transaction is the sum of
   * [TransactionInfo.value][google.cloud.discoveryengine.v1alpha.TransactionInfo.value]
   * and
   * [TransactionInfo.discount_value][google.cloud.discoveryengine.v1alpha.TransactionInfo.discount_value]
   *
   * This means that profit is calculated the same way, regardless of the
   * discount value, and that
   * [TransactionInfo.discount_value][google.cloud.discoveryengine.v1alpha.TransactionInfo.discount_value]
   * can be larger than
   * [TransactionInfo.value][google.cloud.discoveryengine.v1alpha.TransactionInfo.value]:
   *
   * * Profit =
   * [value][google.cloud.discoveryengine.v1alpha.TransactionInfo.value] -
   * [tax][google.cloud.discoveryengine.v1alpha.TransactionInfo.tax] -
   * [cost][google.cloud.discoveryengine.v1alpha.TransactionInfo.cost]
   */
  discountValue?: number | undefined;
}

/** Detailed document information associated with a user event. */
export interface DocumentInfo {
  /**
   * The [Document][google.cloud.discoveryengine.v1alpha.Document] resource
   * ID.
   */
  id?:
    | string
    | undefined;
  /**
   * The [Document][google.cloud.discoveryengine.v1alpha.Document] resource
   * full name, of the form:
   * `projects/{project_id}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/branches/{branch_id}/documents/{document_id}`
   */
  name?:
    | string
    | undefined;
  /**
   * The [Document][google.cloud.discoveryengine.v1alpha.Document] URI - only
   * allowed for website data stores.
   */
  uri?:
    | string
    | undefined;
  /**
   * Quantity of the Document associated with the user event. Defaults to 1.
   *
   * For example, this field is 2 if two quantities of the same Document
   * are involved in a `add-to-cart` event.
   *
   * Required for events of the following event types:
   *
   * * `add-to-cart`
   * * `purchase`
   */
  quantity?:
    | number
    | undefined;
  /**
   * The promotion IDs associated with this Document.
   * Currently, this field is restricted to at most one ID.
   */
  promotionIds: string[];
  /**
   * Output only. Whether the referenced Document can be found in the data
   * store.
   */
  joined: boolean;
}

/** Detailed panel information associated with a user event. */
export interface PanelInfo {
  /** Required. The panel ID. */
  panelId: string;
  /** The display name of the panel. */
  displayName: string;
  /**
   * The ordered position of the panel, if shown to the user with other panels.
   * If set, then
   * [total_panels][google.cloud.discoveryengine.v1alpha.PanelInfo.total_panels]
   * must also be set.
   */
  panelPosition?:
    | number
    | undefined;
  /**
   * The total number of panels, including this one, shown to the user.
   * Must be set if
   * [panel_position][google.cloud.discoveryengine.v1alpha.PanelInfo.panel_position]
   * is set.
   */
  totalPanels?: number | undefined;
}

/** Media-specific user event information. */
export interface MediaInfo {
  /**
   * The media progress time in seconds, if applicable.
   * For example, if the end user has finished 90 seconds of a playback video,
   * then
   * [MediaInfo.media_progress_duration.seconds][google.protobuf.Duration.seconds]
   * should be set to 90.
   */
  mediaProgressDuration:
    | Duration
    | undefined;
  /**
   * Media progress should be computed using only the
   * [media_progress_duration][google.cloud.discoveryengine.v1alpha.MediaInfo.media_progress_duration]
   * relative to the media total length.
   *
   * This value must be between `[0, 1.0]` inclusive.
   *
   * If this is not a playback or the progress cannot be computed (e.g. ongoing
   * livestream), this field should be unset.
   */
  mediaProgressPercentage?: number | undefined;
}

function createBaseUserEvent(): UserEvent {
  return {
    eventType: "",
    userPseudoId: "",
    engine: "",
    dataStore: "",
    eventTime: undefined,
    userInfo: undefined,
    directUserRequest: false,
    sessionId: "",
    pageInfo: undefined,
    attributionToken: "",
    filter: "",
    documents: [],
    panel: undefined,
    searchInfo: undefined,
    completionInfo: undefined,
    transactionInfo: undefined,
    tagIds: [],
    promotionIds: [],
    attributes: {},
    mediaInfo: undefined,
  };
}

export const UserEvent: MessageFns<UserEvent> = {
  encode(message: UserEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventType !== "") {
      writer.uint32(10).string(message.eventType);
    }
    if (message.userPseudoId !== "") {
      writer.uint32(18).string(message.userPseudoId);
    }
    if (message.engine !== "") {
      writer.uint32(154).string(message.engine);
    }
    if (message.dataStore !== "") {
      writer.uint32(162).string(message.dataStore);
    }
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(26).fork()).join();
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(34).fork()).join();
    }
    if (message.directUserRequest !== false) {
      writer.uint32(40).bool(message.directUserRequest);
    }
    if (message.sessionId !== "") {
      writer.uint32(50).string(message.sessionId);
    }
    if (message.pageInfo !== undefined) {
      PageInfo.encode(message.pageInfo, writer.uint32(58).fork()).join();
    }
    if (message.attributionToken !== "") {
      writer.uint32(66).string(message.attributionToken);
    }
    if (message.filter !== "") {
      writer.uint32(74).string(message.filter);
    }
    for (const v of message.documents) {
      DocumentInfo.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.panel !== undefined) {
      PanelInfo.encode(message.panel, writer.uint32(90).fork()).join();
    }
    if (message.searchInfo !== undefined) {
      SearchInfo.encode(message.searchInfo, writer.uint32(98).fork()).join();
    }
    if (message.completionInfo !== undefined) {
      CompletionInfo.encode(message.completionInfo, writer.uint32(106).fork()).join();
    }
    if (message.transactionInfo !== undefined) {
      TransactionInfo.encode(message.transactionInfo, writer.uint32(114).fork()).join();
    }
    for (const v of message.tagIds) {
      writer.uint32(122).string(v!);
    }
    for (const v of message.promotionIds) {
      writer.uint32(130).string(v!);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      UserEvent_AttributesEntry.encode({ key: key as any, value }, writer.uint32(138).fork()).join();
    });
    if (message.mediaInfo !== undefined) {
      MediaInfo.encode(message.mediaInfo, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userPseudoId = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.engine = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.dataStore = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.directUserRequest = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.pageInfo = PageInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.attributionToken = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.documents.push(DocumentInfo.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.panel = PanelInfo.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.searchInfo = SearchInfo.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.completionInfo = CompletionInfo.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.transactionInfo = TransactionInfo.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.tagIds.push(reader.string());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.promotionIds.push(reader.string());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          const entry17 = UserEvent_AttributesEntry.decode(reader, reader.uint32());
          if (entry17.value !== undefined) {
            message.attributes[entry17.key] = entry17.value;
          }
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.mediaInfo = MediaInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserEvent {
    return {
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      userPseudoId: isSet(object.userPseudoId) ? globalThis.String(object.userPseudoId) : "",
      engine: isSet(object.engine) ? globalThis.String(object.engine) : "",
      dataStore: isSet(object.dataStore) ? globalThis.String(object.dataStore) : "",
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
      directUserRequest: isSet(object.directUserRequest) ? globalThis.Boolean(object.directUserRequest) : false,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      pageInfo: isSet(object.pageInfo) ? PageInfo.fromJSON(object.pageInfo) : undefined,
      attributionToken: isSet(object.attributionToken) ? globalThis.String(object.attributionToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      documents: globalThis.Array.isArray(object?.documents)
        ? object.documents.map((e: any) => DocumentInfo.fromJSON(e))
        : [],
      panel: isSet(object.panel) ? PanelInfo.fromJSON(object.panel) : undefined,
      searchInfo: isSet(object.searchInfo) ? SearchInfo.fromJSON(object.searchInfo) : undefined,
      completionInfo: isSet(object.completionInfo) ? CompletionInfo.fromJSON(object.completionInfo) : undefined,
      transactionInfo: isSet(object.transactionInfo) ? TransactionInfo.fromJSON(object.transactionInfo) : undefined,
      tagIds: globalThis.Array.isArray(object?.tagIds) ? object.tagIds.map((e: any) => globalThis.String(e)) : [],
      promotionIds: globalThis.Array.isArray(object?.promotionIds)
        ? object.promotionIds.map((e: any) => globalThis.String(e))
        : [],
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: CustomAttribute }>((acc, [key, value]) => {
          acc[key] = CustomAttribute.fromJSON(value);
          return acc;
        }, {})
        : {},
      mediaInfo: isSet(object.mediaInfo) ? MediaInfo.fromJSON(object.mediaInfo) : undefined,
    };
  },

  toJSON(message: UserEvent): unknown {
    const obj: any = {};
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.userPseudoId !== "") {
      obj.userPseudoId = message.userPseudoId;
    }
    if (message.engine !== "") {
      obj.engine = message.engine;
    }
    if (message.dataStore !== "") {
      obj.dataStore = message.dataStore;
    }
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    if (message.directUserRequest !== false) {
      obj.directUserRequest = message.directUserRequest;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.pageInfo !== undefined) {
      obj.pageInfo = PageInfo.toJSON(message.pageInfo);
    }
    if (message.attributionToken !== "") {
      obj.attributionToken = message.attributionToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.documents?.length) {
      obj.documents = message.documents.map((e) => DocumentInfo.toJSON(e));
    }
    if (message.panel !== undefined) {
      obj.panel = PanelInfo.toJSON(message.panel);
    }
    if (message.searchInfo !== undefined) {
      obj.searchInfo = SearchInfo.toJSON(message.searchInfo);
    }
    if (message.completionInfo !== undefined) {
      obj.completionInfo = CompletionInfo.toJSON(message.completionInfo);
    }
    if (message.transactionInfo !== undefined) {
      obj.transactionInfo = TransactionInfo.toJSON(message.transactionInfo);
    }
    if (message.tagIds?.length) {
      obj.tagIds = message.tagIds;
    }
    if (message.promotionIds?.length) {
      obj.promotionIds = message.promotionIds;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = CustomAttribute.toJSON(v);
        });
      }
    }
    if (message.mediaInfo !== undefined) {
      obj.mediaInfo = MediaInfo.toJSON(message.mediaInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<UserEvent>): UserEvent {
    return UserEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserEvent>): UserEvent {
    const message = createBaseUserEvent();
    message.eventType = object.eventType ?? "";
    message.userPseudoId = object.userPseudoId ?? "";
    message.engine = object.engine ?? "";
    message.dataStore = object.dataStore ?? "";
    message.eventTime = object.eventTime ?? undefined;
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    message.directUserRequest = object.directUserRequest ?? false;
    message.sessionId = object.sessionId ?? "";
    message.pageInfo = (object.pageInfo !== undefined && object.pageInfo !== null)
      ? PageInfo.fromPartial(object.pageInfo)
      : undefined;
    message.attributionToken = object.attributionToken ?? "";
    message.filter = object.filter ?? "";
    message.documents = object.documents?.map((e) => DocumentInfo.fromPartial(e)) || [];
    message.panel = (object.panel !== undefined && object.panel !== null)
      ? PanelInfo.fromPartial(object.panel)
      : undefined;
    message.searchInfo = (object.searchInfo !== undefined && object.searchInfo !== null)
      ? SearchInfo.fromPartial(object.searchInfo)
      : undefined;
    message.completionInfo = (object.completionInfo !== undefined && object.completionInfo !== null)
      ? CompletionInfo.fromPartial(object.completionInfo)
      : undefined;
    message.transactionInfo = (object.transactionInfo !== undefined && object.transactionInfo !== null)
      ? TransactionInfo.fromPartial(object.transactionInfo)
      : undefined;
    message.tagIds = object.tagIds?.map((e) => e) || [];
    message.promotionIds = object.promotionIds?.map((e) => e) || [];
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: CustomAttribute }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = CustomAttribute.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.mediaInfo = (object.mediaInfo !== undefined && object.mediaInfo !== null)
      ? MediaInfo.fromPartial(object.mediaInfo)
      : undefined;
    return message;
  },
};

function createBaseUserEvent_AttributesEntry(): UserEvent_AttributesEntry {
  return { key: "", value: undefined };
}

export const UserEvent_AttributesEntry: MessageFns<UserEvent_AttributesEntry> = {
  encode(message: UserEvent_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CustomAttribute.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserEvent_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserEvent_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = CustomAttribute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserEvent_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CustomAttribute.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: UserEvent_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CustomAttribute.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<UserEvent_AttributesEntry>): UserEvent_AttributesEntry {
    return UserEvent_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserEvent_AttributesEntry>): UserEvent_AttributesEntry {
    const message = createBaseUserEvent_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CustomAttribute.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePageInfo(): PageInfo {
  return { pageviewId: "", pageCategory: "", uri: "", referrerUri: "" };
}

export const PageInfo: MessageFns<PageInfo> = {
  encode(message: PageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageviewId !== "") {
      writer.uint32(10).string(message.pageviewId);
    }
    if (message.pageCategory !== "") {
      writer.uint32(18).string(message.pageCategory);
    }
    if (message.uri !== "") {
      writer.uint32(26).string(message.uri);
    }
    if (message.referrerUri !== "") {
      writer.uint32(34).string(message.referrerUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pageviewId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageCategory = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.referrerUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageInfo {
    return {
      pageviewId: isSet(object.pageviewId) ? globalThis.String(object.pageviewId) : "",
      pageCategory: isSet(object.pageCategory) ? globalThis.String(object.pageCategory) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      referrerUri: isSet(object.referrerUri) ? globalThis.String(object.referrerUri) : "",
    };
  },

  toJSON(message: PageInfo): unknown {
    const obj: any = {};
    if (message.pageviewId !== "") {
      obj.pageviewId = message.pageviewId;
    }
    if (message.pageCategory !== "") {
      obj.pageCategory = message.pageCategory;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.referrerUri !== "") {
      obj.referrerUri = message.referrerUri;
    }
    return obj;
  },

  create(base?: DeepPartial<PageInfo>): PageInfo {
    return PageInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PageInfo>): PageInfo {
    const message = createBasePageInfo();
    message.pageviewId = object.pageviewId ?? "";
    message.pageCategory = object.pageCategory ?? "";
    message.uri = object.uri ?? "";
    message.referrerUri = object.referrerUri ?? "";
    return message;
  },
};

function createBaseSearchInfo(): SearchInfo {
  return { searchQuery: "", orderBy: "", offset: undefined };
}

export const SearchInfo: MessageFns<SearchInfo> = {
  encode(message: SearchInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchQuery !== "") {
      writer.uint32(10).string(message.searchQuery);
    }
    if (message.orderBy !== "") {
      writer.uint32(18).string(message.orderBy);
    }
    if (message.offset !== undefined) {
      writer.uint32(24).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchQuery = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.offset = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchInfo {
    return {
      searchQuery: isSet(object.searchQuery) ? globalThis.String(object.searchQuery) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : undefined,
    };
  },

  toJSON(message: SearchInfo): unknown {
    const obj: any = {};
    if (message.searchQuery !== "") {
      obj.searchQuery = message.searchQuery;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.offset !== undefined) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchInfo>): SearchInfo {
    return SearchInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchInfo>): SearchInfo {
    const message = createBaseSearchInfo();
    message.searchQuery = object.searchQuery ?? "";
    message.orderBy = object.orderBy ?? "";
    message.offset = object.offset ?? undefined;
    return message;
  },
};

function createBaseCompletionInfo(): CompletionInfo {
  return { selectedSuggestion: "", selectedPosition: 0 };
}

export const CompletionInfo: MessageFns<CompletionInfo> = {
  encode(message: CompletionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.selectedSuggestion !== "") {
      writer.uint32(10).string(message.selectedSuggestion);
    }
    if (message.selectedPosition !== 0) {
      writer.uint32(16).int32(message.selectedPosition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompletionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.selectedSuggestion = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.selectedPosition = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionInfo {
    return {
      selectedSuggestion: isSet(object.selectedSuggestion) ? globalThis.String(object.selectedSuggestion) : "",
      selectedPosition: isSet(object.selectedPosition) ? globalThis.Number(object.selectedPosition) : 0,
    };
  },

  toJSON(message: CompletionInfo): unknown {
    const obj: any = {};
    if (message.selectedSuggestion !== "") {
      obj.selectedSuggestion = message.selectedSuggestion;
    }
    if (message.selectedPosition !== 0) {
      obj.selectedPosition = Math.round(message.selectedPosition);
    }
    return obj;
  },

  create(base?: DeepPartial<CompletionInfo>): CompletionInfo {
    return CompletionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompletionInfo>): CompletionInfo {
    const message = createBaseCompletionInfo();
    message.selectedSuggestion = object.selectedSuggestion ?? "";
    message.selectedPosition = object.selectedPosition ?? 0;
    return message;
  },
};

function createBaseTransactionInfo(): TransactionInfo {
  return {
    value: undefined,
    currency: "",
    transactionId: "",
    tax: undefined,
    cost: undefined,
    discountValue: undefined,
  };
}

export const TransactionInfo: MessageFns<TransactionInfo> = {
  encode(message: TransactionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(13).float(message.value);
    }
    if (message.currency !== "") {
      writer.uint32(18).string(message.currency);
    }
    if (message.transactionId !== "") {
      writer.uint32(26).string(message.transactionId);
    }
    if (message.tax !== undefined) {
      writer.uint32(37).float(message.tax);
    }
    if (message.cost !== undefined) {
      writer.uint32(45).float(message.cost);
    }
    if (message.discountValue !== undefined) {
      writer.uint32(53).float(message.discountValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.value = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.tax = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.cost = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.discountValue = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : undefined,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
      tax: isSet(object.tax) ? globalThis.Number(object.tax) : undefined,
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : undefined,
      discountValue: isSet(object.discountValue) ? globalThis.Number(object.discountValue) : undefined,
    };
  },

  toJSON(message: TransactionInfo): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.tax !== undefined) {
      obj.tax = message.tax;
    }
    if (message.cost !== undefined) {
      obj.cost = message.cost;
    }
    if (message.discountValue !== undefined) {
      obj.discountValue = message.discountValue;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionInfo>): TransactionInfo {
    return TransactionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionInfo>): TransactionInfo {
    const message = createBaseTransactionInfo();
    message.value = object.value ?? undefined;
    message.currency = object.currency ?? "";
    message.transactionId = object.transactionId ?? "";
    message.tax = object.tax ?? undefined;
    message.cost = object.cost ?? undefined;
    message.discountValue = object.discountValue ?? undefined;
    return message;
  },
};

function createBaseDocumentInfo(): DocumentInfo {
  return { id: undefined, name: undefined, uri: undefined, quantity: undefined, promotionIds: [], joined: false };
}

export const DocumentInfo: MessageFns<DocumentInfo> = {
  encode(message: DocumentInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.uri !== undefined) {
      writer.uint32(50).string(message.uri);
    }
    if (message.quantity !== undefined) {
      writer.uint32(24).int32(message.quantity);
    }
    for (const v of message.promotionIds) {
      writer.uint32(34).string(v!);
    }
    if (message.joined !== false) {
      writer.uint32(40).bool(message.joined);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.promotionIds.push(reader.string());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.joined = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : undefined,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : undefined,
      promotionIds: globalThis.Array.isArray(object?.promotionIds)
        ? object.promotionIds.map((e: any) => globalThis.String(e))
        : [],
      joined: isSet(object.joined) ? globalThis.Boolean(object.joined) : false,
    };
  },

  toJSON(message: DocumentInfo): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    if (message.quantity !== undefined) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.promotionIds?.length) {
      obj.promotionIds = message.promotionIds;
    }
    if (message.joined !== false) {
      obj.joined = message.joined;
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentInfo>): DocumentInfo {
    return DocumentInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentInfo>): DocumentInfo {
    const message = createBaseDocumentInfo();
    message.id = object.id ?? undefined;
    message.name = object.name ?? undefined;
    message.uri = object.uri ?? undefined;
    message.quantity = object.quantity ?? undefined;
    message.promotionIds = object.promotionIds?.map((e) => e) || [];
    message.joined = object.joined ?? false;
    return message;
  },
};

function createBasePanelInfo(): PanelInfo {
  return { panelId: "", displayName: "", panelPosition: undefined, totalPanels: undefined };
}

export const PanelInfo: MessageFns<PanelInfo> = {
  encode(message: PanelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.panelId !== "") {
      writer.uint32(18).string(message.panelId);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.panelPosition !== undefined) {
      writer.uint32(32).int32(message.panelPosition);
    }
    if (message.totalPanels !== undefined) {
      writer.uint32(40).int32(message.totalPanels);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PanelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePanelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.panelId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.panelPosition = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalPanels = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PanelInfo {
    return {
      panelId: isSet(object.panelId) ? globalThis.String(object.panelId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      panelPosition: isSet(object.panelPosition) ? globalThis.Number(object.panelPosition) : undefined,
      totalPanels: isSet(object.totalPanels) ? globalThis.Number(object.totalPanels) : undefined,
    };
  },

  toJSON(message: PanelInfo): unknown {
    const obj: any = {};
    if (message.panelId !== "") {
      obj.panelId = message.panelId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.panelPosition !== undefined) {
      obj.panelPosition = Math.round(message.panelPosition);
    }
    if (message.totalPanels !== undefined) {
      obj.totalPanels = Math.round(message.totalPanels);
    }
    return obj;
  },

  create(base?: DeepPartial<PanelInfo>): PanelInfo {
    return PanelInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PanelInfo>): PanelInfo {
    const message = createBasePanelInfo();
    message.panelId = object.panelId ?? "";
    message.displayName = object.displayName ?? "";
    message.panelPosition = object.panelPosition ?? undefined;
    message.totalPanels = object.totalPanels ?? undefined;
    return message;
  },
};

function createBaseMediaInfo(): MediaInfo {
  return { mediaProgressDuration: undefined, mediaProgressPercentage: undefined };
}

export const MediaInfo: MessageFns<MediaInfo> = {
  encode(message: MediaInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mediaProgressDuration !== undefined) {
      Duration.encode(message.mediaProgressDuration, writer.uint32(10).fork()).join();
    }
    if (message.mediaProgressPercentage !== undefined) {
      writer.uint32(21).float(message.mediaProgressPercentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mediaProgressDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.mediaProgressPercentage = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediaInfo {
    return {
      mediaProgressDuration: isSet(object.mediaProgressDuration)
        ? Duration.fromJSON(object.mediaProgressDuration)
        : undefined,
      mediaProgressPercentage: isSet(object.mediaProgressPercentage)
        ? globalThis.Number(object.mediaProgressPercentage)
        : undefined,
    };
  },

  toJSON(message: MediaInfo): unknown {
    const obj: any = {};
    if (message.mediaProgressDuration !== undefined) {
      obj.mediaProgressDuration = Duration.toJSON(message.mediaProgressDuration);
    }
    if (message.mediaProgressPercentage !== undefined) {
      obj.mediaProgressPercentage = message.mediaProgressPercentage;
    }
    return obj;
  },

  create(base?: DeepPartial<MediaInfo>): MediaInfo {
    return MediaInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MediaInfo>): MediaInfo {
    const message = createBaseMediaInfo();
    message.mediaProgressDuration =
      (object.mediaProgressDuration !== undefined && object.mediaProgressDuration !== null)
        ? Duration.fromPartial(object.mediaProgressDuration)
        : undefined;
    message.mediaProgressPercentage = object.mediaProgressPercentage ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
