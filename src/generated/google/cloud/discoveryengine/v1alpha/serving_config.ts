// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/discoveryengine/v1alpha/serving_config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  CustomFineTuningSpec,
  EmbeddingConfig,
  GuidedSearchSpec,
  SolutionType,
  solutionTypeFromJSON,
  solutionTypeToJSON,
} from "./common.js";
import { SearchRequest_ContentSearchSpec } from "./search_service.js";

export const protobufPackage = "google.cloud.discoveryengine.v1alpha";

/**
 * Configures metadata that is used to generate serving time results (e.g.
 * search results or recommendation predictions).
 * The ServingConfig is passed in the search and predict request and generates
 * results.
 */
export interface ServingConfig {
  /** The MediaConfig of the serving configuration. */
  mediaConfig?:
    | ServingConfig_MediaConfig
    | undefined;
  /** The GenericConfig of the serving configuration. */
  genericConfig?:
    | ServingConfig_GenericConfig
    | undefined;
  /**
   * Immutable. Fully qualified name
   * `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}/servingConfigs/{serving_config_id}`
   */
  name: string;
  /**
   * Required. The human readable serving config display name. Used in Discovery
   * UI.
   *
   * This field must be a UTF-8 encoded string with a length limit of 128
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   */
  displayName: string;
  /**
   * Required. Immutable. Specifies the solution type that a serving config can
   * be associated with.
   */
  solutionType: SolutionType;
  /**
   * The id of the model to use at serving time.
   * Currently only RecommendationModels are supported.
   * Can be changed but only to a compatible model (e.g.
   * others-you-may-like CTR to others-you-may-like CVR).
   *
   * Required when
   * [SolutionType][google.cloud.discoveryengine.v1alpha.SolutionType] is
   * [SOLUTION_TYPE_RECOMMENDATION][google.cloud.discoveryengine.v1alpha.SolutionType.SOLUTION_TYPE_RECOMMENDATION].
   */
  modelId: string;
  /**
   * How much diversity to use in recommendation model results e.g.
   * `medium-diversity` or `high-diversity`. Currently supported values:
   *
   * * `no-diversity`
   * * `low-diversity`
   * * `medium-diversity`
   * * `high-diversity`
   * * `auto-diversity`
   *
   * If not specified, we choose default based on recommendation model
   * type. Default value: `no-diversity`.
   *
   * Can only be set if
   * [SolutionType][google.cloud.discoveryengine.v1alpha.SolutionType] is
   * [SOLUTION_TYPE_RECOMMENDATION][google.cloud.discoveryengine.v1alpha.SolutionType.SOLUTION_TYPE_RECOMMENDATION].
   */
  diversityLevel: string;
  /**
   * Bring your own embedding config. The config is used for search semantic
   * retrieval. The retrieval is based on the dot product of
   * [SearchRequest.EmbeddingSpec.EmbeddingVector.vector][google.cloud.discoveryengine.v1alpha.SearchRequest.EmbeddingSpec.EmbeddingVector.vector]
   * and the document embeddings that are provided by this EmbeddingConfig. If
   * [SearchRequest.EmbeddingSpec.EmbeddingVector.vector][google.cloud.discoveryengine.v1alpha.SearchRequest.EmbeddingSpec.EmbeddingVector.vector]
   * is provided, it overrides this
   * [ServingConfig.embedding_config][google.cloud.discoveryengine.v1alpha.ServingConfig.embedding_config].
   */
  embeddingConfig:
    | EmbeddingConfig
    | undefined;
  /**
   * The ranking expression controls the customized ranking on retrieval
   * documents. To leverage this, document embedding is required. The ranking
   * expression setting in ServingConfig applies to all search requests served
   * by the serving config. However, if
   * [SearchRequest.ranking_expression][google.cloud.discoveryengine.v1alpha.SearchRequest.ranking_expression]
   * is specified, it overrides the ServingConfig ranking expression.
   *
   * The ranking expression is a single function or multiple functions that are
   * joined by "+".
   *
   *   * ranking_expression = function, { " + ", function };
   *
   * Supported functions:
   *
   *   * double * relevance_score
   *   * double * dotProduct(embedding_field_path)
   *
   * Function variables:
   *
   *   * `relevance_score`: pre-defined keywords, used for measure relevance
   *   between query and document.
   *   * `embedding_field_path`: the document embedding field
   *   used with query embedding vector.
   *   * `dotProduct`: embedding function between embedding_field_path and query
   *   embedding vector.
   *
   *  Example ranking expression:
   *
   *    If document has an embedding field doc_embedding, the ranking expression
   *    could be `0.5 * relevance_score + 0.3 * dotProduct(doc_embedding)`.
   */
  rankingExpression: string;
  /** Guided search configs. */
  guidedSearchSpec:
    | GuidedSearchSpec
    | undefined;
  /**
   * Custom fine tuning configs.
   * If
   * [SearchRequest.custom_fine_tuning_spec][google.cloud.discoveryengine.v1alpha.SearchRequest.custom_fine_tuning_spec]
   * is set, it has higher priority than the configs set here.
   */
  customFineTuningSpec:
    | CustomFineTuningSpec
    | undefined;
  /** Output only. ServingConfig created timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. ServingConfig updated timestamp. */
  updateTime:
    | Date
    | undefined;
  /**
   * Filter controls to use in serving path.
   * All triggered filter controls will be applied.
   * Filter controls must be in the same data store as the serving config.
   * Maximum of 20 filter controls.
   */
  filterControlIds: string[];
  /**
   * Boost controls to use in serving path.
   * All triggered boost controls will be applied.
   * Boost controls must be in the same data store as the serving config.
   * Maximum of 20 boost controls.
   */
  boostControlIds: string[];
  /**
   * IDs of the redirect controls. Only the first triggered redirect
   * action is applied, even if multiple apply. Maximum number of
   * specifications is 100.
   *
   * Can only be set if
   * [SolutionType][google.cloud.discoveryengine.v1alpha.SolutionType] is
   * [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1alpha.SolutionType.SOLUTION_TYPE_SEARCH].
   */
  redirectControlIds: string[];
  /**
   * Condition synonyms specifications. If multiple synonyms conditions
   * match, all matching synonyms controls in the list will execute.
   * Maximum number of specifications is 100.
   *
   * Can only be set if
   * [SolutionType][google.cloud.discoveryengine.v1alpha.SolutionType] is
   * [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1alpha.SolutionType.SOLUTION_TYPE_SEARCH].
   */
  synonymsControlIds: string[];
  /**
   * Condition oneway synonyms specifications. If multiple oneway synonyms
   * conditions match, all matching oneway synonyms controls in the list
   * will execute. Maximum number of specifications is 100.
   *
   * Can only be set if
   * [SolutionType][google.cloud.discoveryengine.v1alpha.SolutionType] is
   * [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1alpha.SolutionType.SOLUTION_TYPE_SEARCH].
   */
  onewaySynonymsControlIds: string[];
  /**
   * Condition do not associate specifications. If multiple do not
   * associate conditions match, all matching do not associate controls in
   * the list will execute.
   * Order does not matter.
   * Maximum number of specifications is 100.
   *
   * Can only be set if
   * [SolutionType][google.cloud.discoveryengine.v1alpha.SolutionType] is
   * [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1alpha.SolutionType.SOLUTION_TYPE_SEARCH].
   */
  dissociateControlIds: string[];
  /**
   * Condition replacement specifications.
   * Applied according to the order in the list.
   * A previously replaced term can not be re-replaced.
   * Maximum number of specifications is 100.
   *
   * Can only be set if
   * [SolutionType][google.cloud.discoveryengine.v1alpha.SolutionType] is
   * [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1alpha.SolutionType.SOLUTION_TYPE_SEARCH].
   */
  replacementControlIds: string[];
  /**
   * Condition ignore specifications. If multiple ignore
   * conditions match, all matching ignore controls in the list will
   * execute.
   * Order does not matter.
   * Maximum number of specifications is 100.
   */
  ignoreControlIds: string[];
}

/**
 * Specifies the configurations needed for Media Discovery. Currently we
 * support:
 *
 * * `demote_content_watched`: Threshold for watched content demotion.
 * Customers can specify if using watched content demotion or use viewed
 * detail page. Using the content watched demotion, customers need to specify
 * the watched minutes or percentage exceeds the threshold, the content will
 * be demoted in the recommendation result.
 * * `promote_fresh_content`: cutoff days for fresh content promotion.
 * Customers can specify if using content freshness promotion. If the content
 * was published within the cutoff days, the content will be promoted in the
 * recommendation result.
 * Can only be set if
 * [SolutionType][google.cloud.discoveryengine.v1alpha.SolutionType] is
 * [SOLUTION_TYPE_RECOMMENDATION][google.cloud.discoveryengine.v1alpha.SolutionType.SOLUTION_TYPE_RECOMMENDATION].
 */
export interface ServingConfig_MediaConfig {
  /**
   * Specifies the content watched percentage threshold for demotion.
   * Threshold value must be between [0, 1.0] inclusive.
   */
  contentWatchedPercentageThreshold?:
    | number
    | undefined;
  /** Specifies the content watched minutes threshold for demotion. */
  contentWatchedSecondsThreshold?:
    | number
    | undefined;
  /**
   * Specifies the event type used for demoting recommendation result.
   * Currently supported values:
   *
   * * `view-item`: Item viewed.
   * * `media-play`: Start/resume watching a video, playing a song, etc.
   * * `media-complete`: Finished or stopped midway through a video, song,
   * etc.
   *
   * If unset, watch history demotion will not be applied. Content freshness
   * demotion will still be applied.
   */
  demotionEventType: string;
  /**
   * Specifies the content freshness used for recommendation result.
   * Contents will be demoted if contents were published for more than content
   * freshness cutoff days.
   */
  contentFreshnessCutoffDays: number;
}

/**
 * Specifies the configurations needed for Generic Discovery.Currently we
 * support:
 *
 * * `content_search_spec`: configuration for generic content search.
 */
export interface ServingConfig_GenericConfig {
  /**
   * Specifies the expected behavior of content search.
   * Only valid for content-search enabled data store.
   */
  contentSearchSpec: SearchRequest_ContentSearchSpec | undefined;
}

function createBaseServingConfig(): ServingConfig {
  return {
    mediaConfig: undefined,
    genericConfig: undefined,
    name: "",
    displayName: "",
    solutionType: 0,
    modelId: "",
    diversityLevel: "",
    embeddingConfig: undefined,
    rankingExpression: "",
    guidedSearchSpec: undefined,
    customFineTuningSpec: undefined,
    createTime: undefined,
    updateTime: undefined,
    filterControlIds: [],
    boostControlIds: [],
    redirectControlIds: [],
    synonymsControlIds: [],
    onewaySynonymsControlIds: [],
    dissociateControlIds: [],
    replacementControlIds: [],
    ignoreControlIds: [],
  };
}

export const ServingConfig: MessageFns<ServingConfig> = {
  encode(message: ServingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mediaConfig !== undefined) {
      ServingConfig_MediaConfig.encode(message.mediaConfig, writer.uint32(58).fork()).join();
    }
    if (message.genericConfig !== undefined) {
      ServingConfig_GenericConfig.encode(message.genericConfig, writer.uint32(82).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.solutionType !== 0) {
      writer.uint32(24).int32(message.solutionType);
    }
    if (message.modelId !== "") {
      writer.uint32(34).string(message.modelId);
    }
    if (message.diversityLevel !== "") {
      writer.uint32(42).string(message.diversityLevel);
    }
    if (message.embeddingConfig !== undefined) {
      EmbeddingConfig.encode(message.embeddingConfig, writer.uint32(162).fork()).join();
    }
    if (message.rankingExpression !== "") {
      writer.uint32(170).string(message.rankingExpression);
    }
    if (message.guidedSearchSpec !== undefined) {
      GuidedSearchSpec.encode(message.guidedSearchSpec, writer.uint32(178).fork()).join();
    }
    if (message.customFineTuningSpec !== undefined) {
      CustomFineTuningSpec.encode(message.customFineTuningSpec, writer.uint32(194).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    for (const v of message.filterControlIds) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.boostControlIds) {
      writer.uint32(98).string(v!);
    }
    for (const v of message.redirectControlIds) {
      writer.uint32(114).string(v!);
    }
    for (const v of message.synonymsControlIds) {
      writer.uint32(122).string(v!);
    }
    for (const v of message.onewaySynonymsControlIds) {
      writer.uint32(130).string(v!);
    }
    for (const v of message.dissociateControlIds) {
      writer.uint32(138).string(v!);
    }
    for (const v of message.replacementControlIds) {
      writer.uint32(146).string(v!);
    }
    for (const v of message.ignoreControlIds) {
      writer.uint32(154).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.mediaConfig = ServingConfig_MediaConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.genericConfig = ServingConfig_GenericConfig.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.solutionType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.modelId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.diversityLevel = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.embeddingConfig = EmbeddingConfig.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.rankingExpression = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.guidedSearchSpec = GuidedSearchSpec.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.customFineTuningSpec = CustomFineTuningSpec.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.filterControlIds.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.boostControlIds.push(reader.string());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.redirectControlIds.push(reader.string());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.synonymsControlIds.push(reader.string());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.onewaySynonymsControlIds.push(reader.string());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.dissociateControlIds.push(reader.string());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.replacementControlIds.push(reader.string());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.ignoreControlIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServingConfig {
    return {
      mediaConfig: isSet(object.mediaConfig) ? ServingConfig_MediaConfig.fromJSON(object.mediaConfig) : undefined,
      genericConfig: isSet(object.genericConfig)
        ? ServingConfig_GenericConfig.fromJSON(object.genericConfig)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      solutionType: isSet(object.solutionType) ? solutionTypeFromJSON(object.solutionType) : 0,
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      diversityLevel: isSet(object.diversityLevel) ? globalThis.String(object.diversityLevel) : "",
      embeddingConfig: isSet(object.embeddingConfig) ? EmbeddingConfig.fromJSON(object.embeddingConfig) : undefined,
      rankingExpression: isSet(object.rankingExpression) ? globalThis.String(object.rankingExpression) : "",
      guidedSearchSpec: isSet(object.guidedSearchSpec) ? GuidedSearchSpec.fromJSON(object.guidedSearchSpec) : undefined,
      customFineTuningSpec: isSet(object.customFineTuningSpec)
        ? CustomFineTuningSpec.fromJSON(object.customFineTuningSpec)
        : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      filterControlIds: globalThis.Array.isArray(object?.filterControlIds)
        ? object.filterControlIds.map((e: any) => globalThis.String(e))
        : [],
      boostControlIds: globalThis.Array.isArray(object?.boostControlIds)
        ? object.boostControlIds.map((e: any) => globalThis.String(e))
        : [],
      redirectControlIds: globalThis.Array.isArray(object?.redirectControlIds)
        ? object.redirectControlIds.map((e: any) => globalThis.String(e))
        : [],
      synonymsControlIds: globalThis.Array.isArray(object?.synonymsControlIds)
        ? object.synonymsControlIds.map((e: any) => globalThis.String(e))
        : [],
      onewaySynonymsControlIds: globalThis.Array.isArray(object?.onewaySynonymsControlIds)
        ? object.onewaySynonymsControlIds.map((e: any) => globalThis.String(e))
        : [],
      dissociateControlIds: globalThis.Array.isArray(object?.dissociateControlIds)
        ? object.dissociateControlIds.map((e: any) => globalThis.String(e))
        : [],
      replacementControlIds: globalThis.Array.isArray(object?.replacementControlIds)
        ? object.replacementControlIds.map((e: any) => globalThis.String(e))
        : [],
      ignoreControlIds: globalThis.Array.isArray(object?.ignoreControlIds)
        ? object.ignoreControlIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ServingConfig): unknown {
    const obj: any = {};
    if (message.mediaConfig !== undefined) {
      obj.mediaConfig = ServingConfig_MediaConfig.toJSON(message.mediaConfig);
    }
    if (message.genericConfig !== undefined) {
      obj.genericConfig = ServingConfig_GenericConfig.toJSON(message.genericConfig);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.solutionType !== 0) {
      obj.solutionType = solutionTypeToJSON(message.solutionType);
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.diversityLevel !== "") {
      obj.diversityLevel = message.diversityLevel;
    }
    if (message.embeddingConfig !== undefined) {
      obj.embeddingConfig = EmbeddingConfig.toJSON(message.embeddingConfig);
    }
    if (message.rankingExpression !== "") {
      obj.rankingExpression = message.rankingExpression;
    }
    if (message.guidedSearchSpec !== undefined) {
      obj.guidedSearchSpec = GuidedSearchSpec.toJSON(message.guidedSearchSpec);
    }
    if (message.customFineTuningSpec !== undefined) {
      obj.customFineTuningSpec = CustomFineTuningSpec.toJSON(message.customFineTuningSpec);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.filterControlIds?.length) {
      obj.filterControlIds = message.filterControlIds;
    }
    if (message.boostControlIds?.length) {
      obj.boostControlIds = message.boostControlIds;
    }
    if (message.redirectControlIds?.length) {
      obj.redirectControlIds = message.redirectControlIds;
    }
    if (message.synonymsControlIds?.length) {
      obj.synonymsControlIds = message.synonymsControlIds;
    }
    if (message.onewaySynonymsControlIds?.length) {
      obj.onewaySynonymsControlIds = message.onewaySynonymsControlIds;
    }
    if (message.dissociateControlIds?.length) {
      obj.dissociateControlIds = message.dissociateControlIds;
    }
    if (message.replacementControlIds?.length) {
      obj.replacementControlIds = message.replacementControlIds;
    }
    if (message.ignoreControlIds?.length) {
      obj.ignoreControlIds = message.ignoreControlIds;
    }
    return obj;
  },

  create(base?: DeepPartial<ServingConfig>): ServingConfig {
    return ServingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServingConfig>): ServingConfig {
    const message = createBaseServingConfig();
    message.mediaConfig = (object.mediaConfig !== undefined && object.mediaConfig !== null)
      ? ServingConfig_MediaConfig.fromPartial(object.mediaConfig)
      : undefined;
    message.genericConfig = (object.genericConfig !== undefined && object.genericConfig !== null)
      ? ServingConfig_GenericConfig.fromPartial(object.genericConfig)
      : undefined;
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.solutionType = object.solutionType ?? 0;
    message.modelId = object.modelId ?? "";
    message.diversityLevel = object.diversityLevel ?? "";
    message.embeddingConfig = (object.embeddingConfig !== undefined && object.embeddingConfig !== null)
      ? EmbeddingConfig.fromPartial(object.embeddingConfig)
      : undefined;
    message.rankingExpression = object.rankingExpression ?? "";
    message.guidedSearchSpec = (object.guidedSearchSpec !== undefined && object.guidedSearchSpec !== null)
      ? GuidedSearchSpec.fromPartial(object.guidedSearchSpec)
      : undefined;
    message.customFineTuningSpec = (object.customFineTuningSpec !== undefined && object.customFineTuningSpec !== null)
      ? CustomFineTuningSpec.fromPartial(object.customFineTuningSpec)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.filterControlIds = object.filterControlIds?.map((e) => e) || [];
    message.boostControlIds = object.boostControlIds?.map((e) => e) || [];
    message.redirectControlIds = object.redirectControlIds?.map((e) => e) || [];
    message.synonymsControlIds = object.synonymsControlIds?.map((e) => e) || [];
    message.onewaySynonymsControlIds = object.onewaySynonymsControlIds?.map((e) => e) || [];
    message.dissociateControlIds = object.dissociateControlIds?.map((e) => e) || [];
    message.replacementControlIds = object.replacementControlIds?.map((e) => e) || [];
    message.ignoreControlIds = object.ignoreControlIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseServingConfig_MediaConfig(): ServingConfig_MediaConfig {
  return {
    contentWatchedPercentageThreshold: undefined,
    contentWatchedSecondsThreshold: undefined,
    demotionEventType: "",
    contentFreshnessCutoffDays: 0,
  };
}

export const ServingConfig_MediaConfig: MessageFns<ServingConfig_MediaConfig> = {
  encode(message: ServingConfig_MediaConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentWatchedPercentageThreshold !== undefined) {
      writer.uint32(21).float(message.contentWatchedPercentageThreshold);
    }
    if (message.contentWatchedSecondsThreshold !== undefined) {
      writer.uint32(45).float(message.contentWatchedSecondsThreshold);
    }
    if (message.demotionEventType !== "") {
      writer.uint32(10).string(message.demotionEventType);
    }
    if (message.contentFreshnessCutoffDays !== 0) {
      writer.uint32(32).int32(message.contentFreshnessCutoffDays);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServingConfig_MediaConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServingConfig_MediaConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 21) {
            break;
          }

          message.contentWatchedPercentageThreshold = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.contentWatchedSecondsThreshold = reader.float();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.demotionEventType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.contentFreshnessCutoffDays = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServingConfig_MediaConfig {
    return {
      contentWatchedPercentageThreshold: isSet(object.contentWatchedPercentageThreshold)
        ? globalThis.Number(object.contentWatchedPercentageThreshold)
        : undefined,
      contentWatchedSecondsThreshold: isSet(object.contentWatchedSecondsThreshold)
        ? globalThis.Number(object.contentWatchedSecondsThreshold)
        : undefined,
      demotionEventType: isSet(object.demotionEventType) ? globalThis.String(object.demotionEventType) : "",
      contentFreshnessCutoffDays: isSet(object.contentFreshnessCutoffDays)
        ? globalThis.Number(object.contentFreshnessCutoffDays)
        : 0,
    };
  },

  toJSON(message: ServingConfig_MediaConfig): unknown {
    const obj: any = {};
    if (message.contentWatchedPercentageThreshold !== undefined) {
      obj.contentWatchedPercentageThreshold = message.contentWatchedPercentageThreshold;
    }
    if (message.contentWatchedSecondsThreshold !== undefined) {
      obj.contentWatchedSecondsThreshold = message.contentWatchedSecondsThreshold;
    }
    if (message.demotionEventType !== "") {
      obj.demotionEventType = message.demotionEventType;
    }
    if (message.contentFreshnessCutoffDays !== 0) {
      obj.contentFreshnessCutoffDays = Math.round(message.contentFreshnessCutoffDays);
    }
    return obj;
  },

  create(base?: DeepPartial<ServingConfig_MediaConfig>): ServingConfig_MediaConfig {
    return ServingConfig_MediaConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServingConfig_MediaConfig>): ServingConfig_MediaConfig {
    const message = createBaseServingConfig_MediaConfig();
    message.contentWatchedPercentageThreshold = object.contentWatchedPercentageThreshold ?? undefined;
    message.contentWatchedSecondsThreshold = object.contentWatchedSecondsThreshold ?? undefined;
    message.demotionEventType = object.demotionEventType ?? "";
    message.contentFreshnessCutoffDays = object.contentFreshnessCutoffDays ?? 0;
    return message;
  },
};

function createBaseServingConfig_GenericConfig(): ServingConfig_GenericConfig {
  return { contentSearchSpec: undefined };
}

export const ServingConfig_GenericConfig: MessageFns<ServingConfig_GenericConfig> = {
  encode(message: ServingConfig_GenericConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentSearchSpec !== undefined) {
      SearchRequest_ContentSearchSpec.encode(message.contentSearchSpec, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServingConfig_GenericConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServingConfig_GenericConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contentSearchSpec = SearchRequest_ContentSearchSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServingConfig_GenericConfig {
    return {
      contentSearchSpec: isSet(object.contentSearchSpec)
        ? SearchRequest_ContentSearchSpec.fromJSON(object.contentSearchSpec)
        : undefined,
    };
  },

  toJSON(message: ServingConfig_GenericConfig): unknown {
    const obj: any = {};
    if (message.contentSearchSpec !== undefined) {
      obj.contentSearchSpec = SearchRequest_ContentSearchSpec.toJSON(message.contentSearchSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<ServingConfig_GenericConfig>): ServingConfig_GenericConfig {
    return ServingConfig_GenericConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServingConfig_GenericConfig>): ServingConfig_GenericConfig {
    const message = createBaseServingConfig_GenericConfig();
    message.contentSearchSpec = (object.contentSearchSpec !== undefined && object.contentSearchSpec !== null)
      ? SearchRequest_ContentSearchSpec.fromPartial(object.contentSearchSpec)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
