// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/discoveryengine/v1alpha/search_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Value } from "../../../protobuf/struct.js";
import { Chunk } from "./chunk.js";
import { CustomFineTuningSpec, DoubleList, Interval, UserInfo } from "./common.js";
import { Document } from "./document.js";

export const protobufPackage = "google.cloud.discoveryengine.v1alpha";

/**
 * Request message for
 * [SearchService.Search][google.cloud.discoveryengine.v1alpha.SearchService.Search]
 * method.
 */
export interface SearchRequest {
  /**
   * Required. The resource name of the Search serving config, such as
   * `projects/* /locations/global/collections/default_collection/engines/* /servingConfigs/default_serving_config`,
   * or
   * `projects/* /locations/global/collections/default_collection/dataStores/default_data_store/servingConfigs/default_serving_config`.
   * This field is used to identify the serving configuration name, set
   * of models used to make the search.
   */
  servingConfig: string;
  /**
   * The branch resource name, such as
   * `projects/* /locations/global/collections/default_collection/dataStores/default_data_store/branches/0`.
   *
   * Use `default_branch` as the branch ID or leave this field empty, to search
   * documents under the default branch.
   */
  branch: string;
  /** Raw search query. */
  query: string;
  /** Raw image query. */
  imageQuery:
    | SearchRequest_ImageQuery
    | undefined;
  /**
   * Maximum number of
   * [Document][google.cloud.discoveryengine.v1alpha.Document]s to return. The
   * maximum allowed value depends on the data type. Values above the maximum
   * value are coerced to the maximum value.
   *
   * * Websites with basic indexing: Default `10`, Maximum `25`.
   * * Websites with advanced indexing: Default `25`, Maximum `50`.
   * * Other: Default `50`, Maximum `100`.
   *
   * If this field is negative, an  `INVALID_ARGUMENT` is returned.
   */
  pageSize: number;
  /**
   * A page token received from a previous
   * [SearchService.Search][google.cloud.discoveryengine.v1alpha.SearchService.Search]
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * [SearchService.Search][google.cloud.discoveryengine.v1alpha.SearchService.Search]
   * must match the call that provided the page token. Otherwise, an
   *  `INVALID_ARGUMENT`  error is returned.
   */
  pageToken: string;
  /**
   * A 0-indexed integer that specifies the current offset (that is, starting
   * result location, amongst the
   * [Document][google.cloud.discoveryengine.v1alpha.Document]s deemed by the
   * API as relevant) in search results. This field is only considered if
   * [page_token][google.cloud.discoveryengine.v1alpha.SearchRequest.page_token]
   * is unset.
   *
   * If this field is negative, an  `INVALID_ARGUMENT`  is returned.
   */
  offset: number;
  /**
   * Specs defining dataStores to filter on in a search call and configurations
   * for those dataStores. This is only considered for engines with multiple
   * dataStores use case. For single dataStore within an engine, they should
   * use the specs at the top level.
   */
  dataStoreSpecs: SearchRequest_DataStoreSpec[];
  /**
   * The filter syntax consists of an expression language for constructing a
   * predicate from one or more fields of the documents being filtered. Filter
   * expression is case-sensitive.
   *
   * If this field is unrecognizable, an  `INVALID_ARGUMENT`  is returned.
   *
   * Filtering in Vertex AI Search is done by mapping the LHS filter key to a
   * key property defined in the Vertex AI Search backend -- this mapping is
   * defined by the customer in their schema. For example a media customer might
   * have a field 'name' in their schema. In this case the filter would look
   * like this: filter --> name:'ANY("king kong")'
   *
   * For more information about filtering including syntax and filter
   * operators, see
   * [Filter](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
   */
  filter: string;
  /**
   * The default filter that is applied when a user performs a search without
   * checking any filters on the search page.
   *
   * The filter applied to every search request when quality improvement such as
   * query expansion is needed. In the case a query does not have a sufficient
   * amount of results this filter will be used to determine whether or not to
   * enable the query expansion flow. The original filter will still be used for
   * the query expanded search.
   * This field is strongly recommended to achieve high search quality.
   *
   * For more information about filter syntax, see
   * [SearchRequest.filter][google.cloud.discoveryengine.v1alpha.SearchRequest.filter].
   */
  canonicalFilter: string;
  /**
   * The order in which documents are returned. Documents can be ordered by
   * a field in an [Document][google.cloud.discoveryengine.v1alpha.Document]
   * object. Leave it unset if ordered by relevance. `order_by` expression is
   * case-sensitive.
   *
   * For more information on ordering the website search results, see
   * [Order web search
   * results](https://cloud.google.com/generative-ai-app-builder/docs/order-web-search-results).
   * For more information on ordering the healthcare search results, see
   * [Order healthcare search
   * results](https://cloud.google.com/generative-ai-app-builder/docs/order-hc-results).
   * If this field is unrecognizable, an `INVALID_ARGUMENT` is returned.
   */
  orderBy: string;
  /**
   * Information about the end user.
   * Highly recommended for analytics.
   * [UserInfo.user_agent][google.cloud.discoveryengine.v1alpha.UserInfo.user_agent]
   * is used to deduce `device_type` for analytics.
   */
  userInfo:
    | UserInfo
    | undefined;
  /**
   * The BCP-47 language code, such as "en-US" or "sr-Latn". For more
   * information, see [Standard
   * fields](https://cloud.google.com/apis/design/standard_fields). This field
   * helps to better interpret the query. If a value isn't specified, the query
   * language code is automatically detected, which may not be accurate.
   */
  languageCode: string;
  /**
   * The Unicode country/region code (CLDR) of a location, such as "US" and
   * "419". For more information, see [Standard
   * fields](https://cloud.google.com/apis/design/standard_fields). If set,
   * then results will be boosted based on the region_code provided.
   */
  regionCode: string;
  /**
   * Facet specifications for faceted search. If empty, no facets are returned.
   *
   * A maximum of 100 values are allowed. Otherwise, an  `INVALID_ARGUMENT`
   * error is returned.
   */
  facetSpecs: SearchRequest_FacetSpec[];
  /**
   * Boost specification to boost certain documents.
   * For more information on boosting, see
   * [Boosting](https://cloud.google.com/generative-ai-app-builder/docs/boost-search-results)
   */
  boostSpec:
    | SearchRequest_BoostSpec
    | undefined;
  /**
   * Additional search parameters.
   *
   * For public website search only, supported values are:
   *
   * * `user_country_code`: string. Default empty. If set to non-empty, results
   *    are restricted or boosted based on the location provided.
   *    For example, `user_country_code: "au"`
   *
   *    For available codes see [Country
   *    Codes](https://developers.google.com/custom-search/docs/json_api_reference#countryCodes)
   *
   * * `search_type`: double. Default empty. Enables non-webpage searching
   *    depending on the value. The only valid non-default value is 1,
   *    which enables image searching.
   *    For example, `search_type: 1`
   */
  params: { [key: string]: any | undefined };
  /**
   * The query expansion specification that specifies the conditions under which
   * query expansion occurs.
   */
  queryExpansionSpec:
    | SearchRequest_QueryExpansionSpec
    | undefined;
  /**
   * The spell correction specification that specifies the mode under
   * which spell correction takes effect.
   */
  spellCorrectionSpec:
    | SearchRequest_SpellCorrectionSpec
    | undefined;
  /**
   * A unique identifier for tracking visitors. For example, this could be
   * implemented with an HTTP cookie, which should be able to uniquely identify
   * a visitor on a single device. This unique identifier should not change if
   * the visitor logs in or out of the website.
   *
   * This field should NOT have a fixed value such as `unknown_visitor`.
   *
   * This should be the same identifier as
   * [UserEvent.user_pseudo_id][google.cloud.discoveryengine.v1alpha.UserEvent.user_pseudo_id]
   * and
   * [CompleteQueryRequest.user_pseudo_id][google.cloud.discoveryengine.v1alpha.CompleteQueryRequest.user_pseudo_id]
   *
   * The field must be a UTF-8 encoded string with a length limit of 128
   * characters. Otherwise, an  `INVALID_ARGUMENT`  error is returned.
   */
  userPseudoId: string;
  /** A specification for configuring the behavior of content search. */
  contentSearchSpec:
    | SearchRequest_ContentSearchSpec
    | undefined;
  /**
   * Uses the provided embedding to do additional semantic document retrieval.
   * The retrieval is based on the dot product of
   * [SearchRequest.EmbeddingSpec.EmbeddingVector.vector][google.cloud.discoveryengine.v1alpha.SearchRequest.EmbeddingSpec.EmbeddingVector.vector]
   * and the document embedding that is provided in
   * [SearchRequest.EmbeddingSpec.EmbeddingVector.field_path][google.cloud.discoveryengine.v1alpha.SearchRequest.EmbeddingSpec.EmbeddingVector.field_path].
   *
   * If
   * [SearchRequest.EmbeddingSpec.EmbeddingVector.field_path][google.cloud.discoveryengine.v1alpha.SearchRequest.EmbeddingSpec.EmbeddingVector.field_path]
   * is not provided, it will use
   * [ServingConfig.EmbeddingConfig.field_path][google.cloud.discoveryengine.v1alpha.ServingConfig.embedding_config].
   */
  embeddingSpec:
    | SearchRequest_EmbeddingSpec
    | undefined;
  /**
   * The ranking expression controls the customized ranking on retrieval
   * documents. This overrides
   * [ServingConfig.ranking_expression][google.cloud.discoveryengine.v1alpha.ServingConfig.ranking_expression].
   * The ranking expression is a single function or multiple functions that are
   * joined by "+".
   *
   *   * ranking_expression = function, { " + ", function };
   *
   * Supported functions:
   *
   *   * double * relevance_score
   *   * double * dotProduct(embedding_field_path)
   *
   * Function variables:
   *
   *   * `relevance_score`: pre-defined keywords, used for measure relevance
   *   between query and document.
   *   * `embedding_field_path`: the document embedding field
   *   used with query embedding vector.
   *   * `dotProduct`: embedding function between embedding_field_path and query
   *   embedding vector.
   *
   *  Example ranking expression:
   *
   *    If document has an embedding field doc_embedding, the ranking expression
   *    could be `0.5 * relevance_score + 0.3 * dotProduct(doc_embedding)`.
   */
  rankingExpression: string;
  /**
   * Whether to turn on safe search. This is only supported for
   * website search.
   */
  safeSearch: boolean;
  /**
   * The user labels applied to a resource must meet the following requirements:
   *
   * * Each resource can have multiple labels, up to a maximum of 64.
   * * Each label must be a key-value pair.
   * * Keys have a minimum length of 1 character and a maximum length of 63
   *   characters and cannot be empty. Values can be empty and have a maximum
   *   length of 63 characters.
   * * Keys and values can contain only lowercase letters, numeric characters,
   *   underscores, and dashes. All characters must use UTF-8 encoding, and
   *   international characters are allowed.
   * * The key portion of a label must be unique. However, you can use the same
   *   key with multiple resources.
   * * Keys must start with a lowercase letter or international character.
   *
   * See [Google Cloud
   * Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
   * for more details.
   */
  userLabels: { [key: string]: string };
  /**
   * If `naturalLanguageQueryUnderstandingSpec` is not specified, no additional
   * natural language query understanding will be done.
   */
  naturalLanguageQueryUnderstandingSpec:
    | SearchRequest_NaturalLanguageQueryUnderstandingSpec
    | undefined;
  /**
   * Search as you type configuration. Only supported for the
   * [IndustryVertical.MEDIA][google.cloud.discoveryengine.v1alpha.IndustryVertical.MEDIA]
   * vertical.
   */
  searchAsYouTypeSpec:
    | SearchRequest_SearchAsYouTypeSpec
    | undefined;
  /**
   * Custom fine tuning configs.
   * If set, it has higher priority than the configs set in
   * [ServingConfig.custom_fine_tuning_spec][google.cloud.discoveryengine.v1alpha.ServingConfig.custom_fine_tuning_spec].
   */
  customFineTuningSpec:
    | CustomFineTuningSpec
    | undefined;
  /**
   * The session resource name. Optional.
   *
   * Session allows users to do multi-turn /search API calls or coordination
   * between /search API calls and /answer API calls.
   *
   * Example #1 (multi-turn /search API calls):
   *   1. Call /search API with the auto-session mode (see below).
   *   2. Call /search API with the session ID generated in the first call.
   *      Here, the previous search query gets considered in query
   *      standing. I.e., if the first query is "How did Alphabet do in 2022?"
   *      and the current query is "How about 2023?", the current query will
   *      be interpreted as "How did Alphabet do in 2023?".
   *
   * Example #2 (coordination between /search API calls and /answer API calls):
   *   1. Call /search API with the auto-session mode (see below).
   *   2. Call /answer API with the session ID generated in the first call.
   *      Here, the answer generation happens in the context of the search
   *      results from the first search call.
   *
   * Auto-session mode: when `projects/.../sessions/-` is used, a new session
   * gets automatically created. Otherwise, users can use the create-session API
   * to create a session manually.
   *
   * Multi-turn Search feature is currently at private GA stage. Please use
   * v1alpha or v1beta version instead before we launch this feature to public
   * GA. Or ask for allowlisting through Google Support team.
   */
  session: string;
  /**
   * Session specification.
   *
   * Can be used only when `session` is set.
   */
  sessionSpec:
    | SearchRequest_SessionSpec
    | undefined;
  /**
   * The relevance threshold of the search results.
   *
   * Default to Google defined threshold, leveraging a balance of
   * precision and recall to deliver both highly accurate results and
   * comprehensive coverage of relevant information.
   */
  relevanceThreshold: SearchRequest_RelevanceThreshold;
}

/**
 * The relevance threshold of the search results. The higher relevance
 * threshold is, the higher relevant results are shown and the less number of
 * results are returned.
 */
export enum SearchRequest_RelevanceThreshold {
  /**
   * RELEVANCE_THRESHOLD_UNSPECIFIED - Default value. In this case, server behavior defaults to Google defined
   * threshold.
   */
  RELEVANCE_THRESHOLD_UNSPECIFIED = 0,
  /** LOWEST - Lowest relevance threshold. */
  LOWEST = 1,
  /** LOW - Low relevance threshold. */
  LOW = 2,
  /** MEDIUM - Medium relevance threshold. */
  MEDIUM = 3,
  /** HIGH - High relevance threshold. */
  HIGH = 4,
  UNRECOGNIZED = -1,
}

export function searchRequest_RelevanceThresholdFromJSON(object: any): SearchRequest_RelevanceThreshold {
  switch (object) {
    case 0:
    case "RELEVANCE_THRESHOLD_UNSPECIFIED":
      return SearchRequest_RelevanceThreshold.RELEVANCE_THRESHOLD_UNSPECIFIED;
    case 1:
    case "LOWEST":
      return SearchRequest_RelevanceThreshold.LOWEST;
    case 2:
    case "LOW":
      return SearchRequest_RelevanceThreshold.LOW;
    case 3:
    case "MEDIUM":
      return SearchRequest_RelevanceThreshold.MEDIUM;
    case 4:
    case "HIGH":
      return SearchRequest_RelevanceThreshold.HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_RelevanceThreshold.UNRECOGNIZED;
  }
}

export function searchRequest_RelevanceThresholdToJSON(object: SearchRequest_RelevanceThreshold): string {
  switch (object) {
    case SearchRequest_RelevanceThreshold.RELEVANCE_THRESHOLD_UNSPECIFIED:
      return "RELEVANCE_THRESHOLD_UNSPECIFIED";
    case SearchRequest_RelevanceThreshold.LOWEST:
      return "LOWEST";
    case SearchRequest_RelevanceThreshold.LOW:
      return "LOW";
    case SearchRequest_RelevanceThreshold.MEDIUM:
      return "MEDIUM";
    case SearchRequest_RelevanceThreshold.HIGH:
      return "HIGH";
    case SearchRequest_RelevanceThreshold.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies the image query input. */
export interface SearchRequest_ImageQuery {
  /**
   * Base64 encoded image bytes. Supported image formats: JPEG, PNG, and
   * BMP.
   */
  imageBytes?: string | undefined;
}

/**
 * A struct to define data stores to filter on in a search call and
 * configurations for those data stores. Otherwise, an `INVALID_ARGUMENT`
 * error is returned.
 */
export interface SearchRequest_DataStoreSpec {
  /**
   * Required. Full resource name of
   * [DataStore][google.cloud.discoveryengine.v1alpha.DataStore], such as
   * `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
   */
  dataStore: string;
}

/** A facet specification to perform faceted search. */
export interface SearchRequest_FacetSpec {
  /** Required. The facet key specification. */
  facetKey:
    | SearchRequest_FacetSpec_FacetKey
    | undefined;
  /**
   * Maximum facet values that are returned for this facet. If
   * unspecified, defaults to 20. The maximum allowed value is 300. Values
   * above 300 are coerced to 300.
   * For aggregation in healthcare search, when the [FacetKey.key] is
   * "healthcare_aggregation_key", the limit will be overridden to
   * 10,000 internally, regardless of the value set here.
   *
   * If this field is negative, an  `INVALID_ARGUMENT`  is returned.
   */
  limit: number;
  /**
   * List of keys to exclude when faceting.
   *
   * By default,
   * [FacetKey.key][google.cloud.discoveryengine.v1alpha.SearchRequest.FacetSpec.FacetKey.key]
   * is not excluded from the filter unless it is listed in this field.
   *
   * Listing a facet key in this field allows its values to appear as facet
   * results, even when they are filtered out of search results. Using this
   * field does not affect what search results are returned.
   *
   * For example, suppose there are 100 documents with the color facet "Red"
   * and 200 documents with the color facet "Blue". A query containing the
   * filter "color:ANY("Red")" and having "color" as
   * [FacetKey.key][google.cloud.discoveryengine.v1alpha.SearchRequest.FacetSpec.FacetKey.key]
   * would by default return only "Red" documents in the search results, and
   * also return "Red" with count 100 as the only color facet. Although there
   * are also blue documents available, "Blue" would not be shown as an
   * available facet value.
   *
   * If "color" is listed in "excludedFilterKeys", then the query returns the
   * facet values "Red" with count 100 and "Blue" with count 200, because the
   * "color" key is now excluded from the filter. Because this field doesn't
   * affect search results, the search results are still correctly filtered to
   * return only "Red" documents.
   *
   * A maximum of 100 values are allowed. Otherwise, an  `INVALID_ARGUMENT`
   * error is returned.
   */
  excludedFilterKeys: string[];
  /**
   * Enables dynamic position for this facet. If set to true, the position of
   * this facet among all facets in the response is determined automatically.
   * If dynamic facets are enabled, it is ordered together.
   * If set to false, the position of this facet in the
   * response is the same as in the request, and it is ranked before
   * the facets with dynamic position enable and all dynamic facets.
   *
   * For example, you may always want to have rating facet returned in
   * the response, but it's not necessarily to always display the rating facet
   * at the top. In that case, you can set enable_dynamic_position to true so
   * that the position of rating facet in response is determined
   * automatically.
   *
   * Another example, assuming you have the following facets in the request:
   *
   * * "rating", enable_dynamic_position = true
   *
   * * "price", enable_dynamic_position = false
   *
   * * "brands", enable_dynamic_position = false
   *
   * And also you have a dynamic facets enabled, which generates a facet
   * `gender`. Then the final order of the facets in the response can be
   * ("price", "brands", "rating", "gender") or ("price", "brands", "gender",
   * "rating") depends on how API orders "gender" and "rating" facets.
   * However, notice that "price" and "brands" are always
   * ranked at first and second position because their enable_dynamic_position
   * is false.
   */
  enableDynamicPosition: boolean;
}

/** Specifies how a facet is computed. */
export interface SearchRequest_FacetSpec_FacetKey {
  /**
   * Required. Supported textual and numerical facet keys in
   * [Document][google.cloud.discoveryengine.v1alpha.Document] object, over
   * which the facet values are computed. Facet key is case-sensitive.
   */
  key: string;
  /**
   * Set only if values should be bucketed into intervals. Must be set
   * for facets with numerical values. Must not be set for facet with text
   * values. Maximum number of intervals is 30.
   */
  intervals: Interval[];
  /**
   * Only get facet for the given restricted values. Only supported on
   * textual fields. For example, suppose "category" has three values
   * "Action > 2022", "Action > 2021" and "Sci-Fi > 2022". If set
   * "restricted_values" to "Action > 2022", the "category" facet only
   * contains "Action > 2022". Only supported on textual fields. Maximum
   * is 10.
   */
  restrictedValues: string[];
  /**
   * Only get facet values that start with the given string prefix. For
   * example, suppose "category" has three values "Action > 2022",
   * "Action > 2021" and "Sci-Fi > 2022". If set "prefixes" to "Action", the
   * "category" facet only contains "Action > 2022" and "Action > 2021".
   * Only supported on textual fields. Maximum is 10.
   */
  prefixes: string[];
  /**
   * Only get facet values that contain the given strings. For example,
   * suppose "category" has three values "Action > 2022",
   * "Action > 2021" and "Sci-Fi > 2022". If set "contains" to "2022", the
   * "category" facet only contains "Action > 2022" and "Sci-Fi > 2022".
   * Only supported on textual fields. Maximum is 10.
   */
  contains: string[];
  /**
   * True to make facet keys case insensitive when getting faceting
   * values with prefixes or contains; false otherwise.
   */
  caseInsensitive: boolean;
  /**
   * The order in which documents are returned.
   *
   * Allowed values are:
   *
   * * "count desc", which means order by
   * [SearchResponse.Facet.values.count][google.cloud.discoveryengine.v1alpha.SearchResponse.Facet.FacetValue.count]
   * descending.
   *
   * * "value desc", which means order by
   * [SearchResponse.Facet.values.value][google.cloud.discoveryengine.v1alpha.SearchResponse.Facet.FacetValue.value]
   * descending.
   *   Only applies to textual facets.
   *
   * If not set, textual values are sorted in [natural
   * order](https://en.wikipedia.org/wiki/Natural_sort_order); numerical
   * intervals are sorted in the order given by
   * [FacetSpec.FacetKey.intervals][google.cloud.discoveryengine.v1alpha.SearchRequest.FacetSpec.FacetKey.intervals].
   */
  orderBy: string;
}

/** Boost specification to boost certain documents. */
export interface SearchRequest_BoostSpec {
  /**
   * Condition boost specifications. If a document matches multiple conditions
   * in the specifictions, boost scores from these specifications are all
   * applied and combined in a non-linear way. Maximum number of
   * specifications is 20.
   */
  conditionBoostSpecs: SearchRequest_BoostSpec_ConditionBoostSpec[];
}

/** Boost applies to documents which match a condition. */
export interface SearchRequest_BoostSpec_ConditionBoostSpec {
  /**
   * An expression which specifies a boost condition. The syntax and
   * supported fields are the same as a filter expression. See
   * [SearchRequest.filter][google.cloud.discoveryengine.v1alpha.SearchRequest.filter]
   * for detail syntax and limitations.
   *
   * Examples:
   *
   * * To boost documents with document ID "doc_1" or "doc_2", and
   * color "Red" or "Blue":
   * `(document_id: ANY("doc_1", "doc_2")) AND (color: ANY("Red", "Blue"))`
   */
  condition: string;
  /**
   * Strength of the condition boost, which should be in [-1, 1]. Negative
   * boost means demotion. Default is 0.0.
   *
   * Setting to 1.0 gives the document a big promotion. However, it does
   * not necessarily mean that the boosted document will be the top result
   * at all times, nor that other documents will be excluded. Results
   * could still be shown even when none of them matches the condition.
   * And results that are significantly more relevant to the search query
   * can still trump your heavily favored but irrelevant documents.
   *
   * Setting to -1.0 gives the document a big demotion. However, results
   * that are deeply relevant might still be shown. The document will have
   * an upstream battle to get a fairly high ranking, but it is not
   * blocked out completely.
   *
   * Setting to 0.0 means no boost applied. The boosting condition is
   * ignored. Only one of the (condition, boost) combination or the
   * boost_control_spec below are set. If both are set then the global boost
   * is ignored and the more fine-grained boost_control_spec is applied.
   */
  boost: number;
  /**
   * Complex specification for custom ranking based on customer defined
   * attribute value.
   */
  boostControlSpec: SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec | undefined;
}

/**
 * Specification for custom ranking based on customer specified attribute
 * value. It provides more controls for customized ranking than the simple
 * (condition, boost) combination above.
 */
export interface SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec {
  /**
   * The name of the field whose value will be used to determine the
   * boost amount.
   */
  fieldName: string;
  /**
   * The attribute type to be used to determine the boost amount. The
   * attribute value can be derived from the field value of the specified
   * field_name. In the case of numerical it is straightforward i.e.
   * attribute_value = numerical_field_value. In the case of freshness
   * however, attribute_value = (time.now() - datetime_field_value).
   */
  attributeType: SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeType;
  /**
   * The interpolation type to be applied to connect the control points
   * listed below.
   */
  interpolationType: SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationType;
  /**
   * The control points used to define the curve. The monotonic function
   * (defined through the interpolation_type above) passes through the
   * control points listed here.
   */
  controlPoints: SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint[];
}

/**
 * The attribute(or function) for which the custom ranking is to be
 * applied.
 */
export enum SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeType {
  /** ATTRIBUTE_TYPE_UNSPECIFIED - Unspecified AttributeType. */
  ATTRIBUTE_TYPE_UNSPECIFIED = 0,
  /**
   * NUMERICAL - The value of the numerical field will be used to dynamically update
   * the boost amount. In this case, the attribute_value (the x value)
   * of the control point will be the actual value of the numerical
   * field for which the boost_amount is specified.
   */
  NUMERICAL = 1,
  /**
   * FRESHNESS - For the freshness use case the attribute value will be the duration
   * between the current time and the date in the datetime field
   * specified. The value must be formatted as an XSD `dayTimeDuration`
   * value (a restricted subset of an ISO 8601 duration value). The
   * pattern for this is: `[nD][T[nH][nM][nS]]`.
   * For example, `5D`, `3DT12H30M`, `T24H`.
   */
  FRESHNESS = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeTypeFromJSON(
  object: any,
): SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeType {
  switch (object) {
    case 0:
    case "ATTRIBUTE_TYPE_UNSPECIFIED":
      return SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeType.ATTRIBUTE_TYPE_UNSPECIFIED;
    case 1:
    case "NUMERICAL":
      return SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeType.NUMERICAL;
    case 2:
    case "FRESHNESS":
      return SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeType.FRESHNESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeType.UNRECOGNIZED;
  }
}

export function searchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeTypeToJSON(
  object: SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeType,
): string {
  switch (object) {
    case SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeType.ATTRIBUTE_TYPE_UNSPECIFIED:
      return "ATTRIBUTE_TYPE_UNSPECIFIED";
    case SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeType.NUMERICAL:
      return "NUMERICAL";
    case SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeType.FRESHNESS:
      return "FRESHNESS";
    case SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The interpolation type to be applied. Default will be linear
 * (Piecewise Linear).
 */
export enum SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationType {
  /**
   * INTERPOLATION_TYPE_UNSPECIFIED - Interpolation type is unspecified. In this case, it defaults to
   * Linear.
   */
  INTERPOLATION_TYPE_UNSPECIFIED = 0,
  /** LINEAR - Piecewise linear interpolation will be applied. */
  LINEAR = 1,
  UNRECOGNIZED = -1,
}

export function searchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationTypeFromJSON(
  object: any,
): SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationType {
  switch (object) {
    case 0:
    case "INTERPOLATION_TYPE_UNSPECIFIED":
      return SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationType
        .INTERPOLATION_TYPE_UNSPECIFIED;
    case 1:
    case "LINEAR":
      return SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationType.LINEAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationType.UNRECOGNIZED;
  }
}

export function searchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationTypeToJSON(
  object: SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationType,
): string {
  switch (object) {
    case SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationType.INTERPOLATION_TYPE_UNSPECIFIED:
      return "INTERPOLATION_TYPE_UNSPECIFIED";
    case SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationType.LINEAR:
      return "LINEAR";
    case SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The control points used to define the curve. The curve defined
 * through these control points can only be monotonically increasing
 * or decreasing(constant values are acceptable).
 */
export interface SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint {
  /**
   * Can be one of:
   * 1. The numerical field value.
   * 2. The duration spec for freshness:
   * The value must be formatted as an XSD `dayTimeDuration` value (a
   * restricted subset of an ISO 8601 duration value). The pattern for
   * this is: `[nD][T[nH][nM][nS]]`.
   */
  attributeValue: string;
  /**
   * The value between -1 to 1 by which to boost the score if the
   * attribute_value evaluates to the value specified above.
   */
  boostAmount: number;
}

/**
 * Specification to determine under which conditions query expansion should
 * occur.
 */
export interface SearchRequest_QueryExpansionSpec {
  /**
   * The condition under which query expansion should occur. Default to
   * [Condition.DISABLED][google.cloud.discoveryengine.v1alpha.SearchRequest.QueryExpansionSpec.Condition.DISABLED].
   */
  condition: SearchRequest_QueryExpansionSpec_Condition;
  /**
   * Whether to pin unexpanded results. If this field is set to true,
   * unexpanded products are always at the top of the search results, followed
   * by the expanded results.
   */
  pinUnexpandedResults: boolean;
}

/** Enum describing under which condition query expansion should occur. */
export enum SearchRequest_QueryExpansionSpec_Condition {
  /**
   * CONDITION_UNSPECIFIED - Unspecified query expansion condition. In this case, server behavior
   * defaults to
   * [Condition.DISABLED][google.cloud.discoveryengine.v1alpha.SearchRequest.QueryExpansionSpec.Condition.DISABLED].
   */
  CONDITION_UNSPECIFIED = 0,
  /**
   * DISABLED - Disabled query expansion. Only the exact search query is used, even if
   * [SearchResponse.total_size][google.cloud.discoveryengine.v1alpha.SearchResponse.total_size]
   * is zero.
   */
  DISABLED = 1,
  /** AUTO - Automatic query expansion built by the Search API. */
  AUTO = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_QueryExpansionSpec_ConditionFromJSON(
  object: any,
): SearchRequest_QueryExpansionSpec_Condition {
  switch (object) {
    case 0:
    case "CONDITION_UNSPECIFIED":
      return SearchRequest_QueryExpansionSpec_Condition.CONDITION_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return SearchRequest_QueryExpansionSpec_Condition.DISABLED;
    case 2:
    case "AUTO":
      return SearchRequest_QueryExpansionSpec_Condition.AUTO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_QueryExpansionSpec_Condition.UNRECOGNIZED;
  }
}

export function searchRequest_QueryExpansionSpec_ConditionToJSON(
  object: SearchRequest_QueryExpansionSpec_Condition,
): string {
  switch (object) {
    case SearchRequest_QueryExpansionSpec_Condition.CONDITION_UNSPECIFIED:
      return "CONDITION_UNSPECIFIED";
    case SearchRequest_QueryExpansionSpec_Condition.DISABLED:
      return "DISABLED";
    case SearchRequest_QueryExpansionSpec_Condition.AUTO:
      return "AUTO";
    case SearchRequest_QueryExpansionSpec_Condition.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The specification for query spell correction. */
export interface SearchRequest_SpellCorrectionSpec {
  /**
   * The mode under which spell correction
   * replaces the original search query. Defaults to
   * [Mode.AUTO][google.cloud.discoveryengine.v1alpha.SearchRequest.SpellCorrectionSpec.Mode.AUTO].
   */
  mode: SearchRequest_SpellCorrectionSpec_Mode;
}

/** Enum describing under which mode spell correction should occur. */
export enum SearchRequest_SpellCorrectionSpec_Mode {
  /**
   * MODE_UNSPECIFIED - Unspecified spell correction mode. In this case, server behavior
   * defaults to
   * [Mode.AUTO][google.cloud.discoveryengine.v1alpha.SearchRequest.SpellCorrectionSpec.Mode.AUTO].
   */
  MODE_UNSPECIFIED = 0,
  /**
   * SUGGESTION_ONLY - Search API tries to find a spelling suggestion. If a suggestion is
   * found, it is put in the
   * [SearchResponse.corrected_query][google.cloud.discoveryengine.v1alpha.SearchResponse.corrected_query].
   * The spelling suggestion won't be used as the search query.
   */
  SUGGESTION_ONLY = 1,
  /**
   * AUTO - Automatic spell correction built by the Search API. Search will
   * be based on the corrected query if found.
   */
  AUTO = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_SpellCorrectionSpec_ModeFromJSON(object: any): SearchRequest_SpellCorrectionSpec_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return SearchRequest_SpellCorrectionSpec_Mode.MODE_UNSPECIFIED;
    case 1:
    case "SUGGESTION_ONLY":
      return SearchRequest_SpellCorrectionSpec_Mode.SUGGESTION_ONLY;
    case 2:
    case "AUTO":
      return SearchRequest_SpellCorrectionSpec_Mode.AUTO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_SpellCorrectionSpec_Mode.UNRECOGNIZED;
  }
}

export function searchRequest_SpellCorrectionSpec_ModeToJSON(object: SearchRequest_SpellCorrectionSpec_Mode): string {
  switch (object) {
    case SearchRequest_SpellCorrectionSpec_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case SearchRequest_SpellCorrectionSpec_Mode.SUGGESTION_ONLY:
      return "SUGGESTION_ONLY";
    case SearchRequest_SpellCorrectionSpec_Mode.AUTO:
      return "AUTO";
    case SearchRequest_SpellCorrectionSpec_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A specification for configuring the behavior of content search. */
export interface SearchRequest_ContentSearchSpec {
  /**
   * If `snippetSpec` is not specified, snippets are not included in the
   * search response.
   */
  snippetSpec:
    | SearchRequest_ContentSearchSpec_SnippetSpec
    | undefined;
  /**
   * If `summarySpec` is not specified, summaries are not included in the
   * search response.
   */
  summarySpec:
    | SearchRequest_ContentSearchSpec_SummarySpec
    | undefined;
  /**
   * If there is no extractive_content_spec provided, there will be no
   * extractive answer in the search response.
   */
  extractiveContentSpec:
    | SearchRequest_ContentSearchSpec_ExtractiveContentSpec
    | undefined;
  /**
   * Specifies the search result mode. If unspecified, the
   * search result mode defaults to `DOCUMENTS`.
   */
  searchResultMode: SearchRequest_ContentSearchSpec_SearchResultMode;
  /**
   * Specifies the chunk spec to be returned from the search response.
   * Only available if the
   * [SearchRequest.ContentSearchSpec.search_result_mode][google.cloud.discoveryengine.v1alpha.SearchRequest.ContentSearchSpec.search_result_mode]
   * is set to
   * [CHUNKS][google.cloud.discoveryengine.v1alpha.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS]
   */
  chunkSpec: SearchRequest_ContentSearchSpec_ChunkSpec | undefined;
}

/**
 * Specifies the search result mode. If unspecified, the
 * search result mode defaults to `DOCUMENTS`.
 */
export enum SearchRequest_ContentSearchSpec_SearchResultMode {
  /** SEARCH_RESULT_MODE_UNSPECIFIED - Default value. */
  SEARCH_RESULT_MODE_UNSPECIFIED = 0,
  /** DOCUMENTS - Returns documents in the search result. */
  DOCUMENTS = 1,
  /**
   * CHUNKS - Returns chunks in the search result. Only available if the
   * [DataStore.DocumentProcessingConfig.chunking_config][] is specified.
   */
  CHUNKS = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_ContentSearchSpec_SearchResultModeFromJSON(
  object: any,
): SearchRequest_ContentSearchSpec_SearchResultMode {
  switch (object) {
    case 0:
    case "SEARCH_RESULT_MODE_UNSPECIFIED":
      return SearchRequest_ContentSearchSpec_SearchResultMode.SEARCH_RESULT_MODE_UNSPECIFIED;
    case 1:
    case "DOCUMENTS":
      return SearchRequest_ContentSearchSpec_SearchResultMode.DOCUMENTS;
    case 2:
    case "CHUNKS":
      return SearchRequest_ContentSearchSpec_SearchResultMode.CHUNKS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_ContentSearchSpec_SearchResultMode.UNRECOGNIZED;
  }
}

export function searchRequest_ContentSearchSpec_SearchResultModeToJSON(
  object: SearchRequest_ContentSearchSpec_SearchResultMode,
): string {
  switch (object) {
    case SearchRequest_ContentSearchSpec_SearchResultMode.SEARCH_RESULT_MODE_UNSPECIFIED:
      return "SEARCH_RESULT_MODE_UNSPECIFIED";
    case SearchRequest_ContentSearchSpec_SearchResultMode.DOCUMENTS:
      return "DOCUMENTS";
    case SearchRequest_ContentSearchSpec_SearchResultMode.CHUNKS:
      return "CHUNKS";
    case SearchRequest_ContentSearchSpec_SearchResultMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A specification for configuring snippets in a search response. */
export interface SearchRequest_ContentSearchSpec_SnippetSpec {
  /**
   * [DEPRECATED] This field is deprecated. To control snippet return, use
   * `return_snippet` field. For backwards compatibility, we will return
   * snippet if max_snippet_count > 0.
   *
   * @deprecated
   */
  maxSnippetCount: number;
  /**
   * [DEPRECATED] This field is deprecated and will have no affect on the
   * snippet.
   *
   * @deprecated
   */
  referenceOnly: boolean;
  /**
   * If `true`, then return snippet. If no snippet can be generated, we
   * return "No snippet is available for this page." A `snippet_status` with
   * `SUCCESS` or `NO_SNIPPET_AVAILABLE` will also be returned.
   */
  returnSnippet: boolean;
}

/**
 * A specification for configuring a summary returned in a search
 * response.
 */
export interface SearchRequest_ContentSearchSpec_SummarySpec {
  /**
   * The number of top results to generate the summary from. If the number
   * of results returned is less than `summaryResultCount`, the summary is
   * generated from all of the results.
   *
   * At most 10 results for documents mode, or 50 for chunks mode, can be
   * used to generate a summary. The chunks mode is used when
   * [SearchRequest.ContentSearchSpec.search_result_mode][google.cloud.discoveryengine.v1alpha.SearchRequest.ContentSearchSpec.search_result_mode]
   * is set to
   * [CHUNKS][google.cloud.discoveryengine.v1alpha.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS].
   */
  summaryResultCount: number;
  /**
   * Specifies whether to include citations in the summary. The default
   * value is `false`.
   *
   * When this field is set to `true`, summaries include in-line citation
   * numbers.
   *
   * Example summary including citations:
   *
   * BigQuery is Google Cloud's fully managed and completely serverless
   * enterprise data warehouse [1]. BigQuery supports all data types, works
   * across clouds, and has built-in machine learning and business
   * intelligence, all within a unified platform [2, 3].
   *
   * The citation numbers refer to the returned search results and are
   * 1-indexed. For example, [1] means that the sentence is attributed to
   * the first search result. [2, 3] means that the sentence is attributed
   * to both the second and third search results.
   */
  includeCitations: boolean;
  /**
   * Specifies whether to filter out adversarial queries. The default value
   * is `false`.
   *
   * Google employs search-query classification to detect adversarial
   * queries. No summary is returned if the search query is classified as an
   * adversarial query. For example, a user might ask a question regarding
   * negative comments about the company or submit a query designed to
   * generate unsafe, policy-violating output. If this field is set to
   * `true`, we skip generating summaries for adversarial queries and return
   * fallback messages instead.
   */
  ignoreAdversarialQuery: boolean;
  /**
   * Specifies whether to filter out queries that are not summary-seeking.
   * The default value is `false`.
   *
   * Google employs search-query classification to detect summary-seeking
   * queries. No summary is returned if the search query is classified as a
   * non-summary seeking query. For example, `why is the sky blue` and `Who
   * is the best soccer player in the world?` are summary-seeking queries,
   * but `SFO airport` and `world cup 2026` are not. They are most likely
   * navigational queries. If this field is set to `true`, we skip
   * generating summaries for non-summary seeking queries and return
   * fallback messages instead.
   */
  ignoreNonSummarySeekingQuery: boolean;
  /**
   * Specifies whether to filter out queries that have low relevance. The
   * default value is `false`.
   *
   * If this field is set to `false`, all search results are used regardless
   * of relevance to generate answers. If set to `true`, only queries with
   * high relevance search results will generate answers.
   */
  ignoreLowRelevantContent: boolean;
  /**
   * If specified, the spec will be used to modify the prompt provided to
   * the LLM.
   */
  modelPromptSpec:
    | SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec
    | undefined;
  /**
   * Language code for Summary. Use language tags defined by
   * [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt).
   * Note: This is an experimental feature.
   */
  languageCode: string;
  /**
   * If specified, the spec will be used to modify the model specification
   * provided to the LLM.
   */
  modelSpec:
    | SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec
    | undefined;
  /**
   * If true, answer will be generated from most relevant chunks from top
   * search results. This feature will improve summary quality.
   * Note that with this feature enabled, not all top search results
   * will be referenced and included in the reference list, so the citation
   * source index only points to the search results listed in the reference
   * list.
   */
  useSemanticChunks: boolean;
}

/** Specification of the prompt to use with the model. */
export interface SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec {
  /**
   * Text at the beginning of the prompt that instructs the assistant.
   * Examples are available in the user guide.
   */
  preamble: string;
}

/** Specification of the model. */
export interface SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec {
  /**
   * The model version used to generate the summary.
   *
   * Supported values are:
   *
   * * `stable`: string. Default value when no value is specified. Uses a
   *    generally available, fine-tuned model. For more information, see
   *    [Answer generation model versions and
   *    lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models).
   * * `preview`: string. (Public preview) Uses a preview model. For more
   *    information, see
   *    [Answer generation model versions and
   *    lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models).
   */
  version: string;
}

/**
 * A specification for configuring the extractive content in a search
 * response.
 */
export interface SearchRequest_ContentSearchSpec_ExtractiveContentSpec {
  /**
   * The maximum number of extractive answers returned in each search
   * result.
   *
   * An extractive answer is a verbatim answer extracted from the original
   * document, which provides a precise and contextually relevant answer to
   * the search query.
   *
   * If the number of matching answers is less than the
   * `max_extractive_answer_count`, return all of the answers. Otherwise,
   * return the `max_extractive_answer_count`.
   *
   * At most five answers are returned for each
   * [SearchResult][google.cloud.discoveryengine.v1alpha.SearchResponse.SearchResult].
   */
  maxExtractiveAnswerCount: number;
  /**
   * The max number of extractive segments returned in each search result.
   * Only applied if the
   * [DataStore][google.cloud.discoveryengine.v1alpha.DataStore] is set to
   * [DataStore.ContentConfig.CONTENT_REQUIRED][google.cloud.discoveryengine.v1alpha.DataStore.ContentConfig.CONTENT_REQUIRED]
   * or
   * [DataStore.solution_types][google.cloud.discoveryengine.v1alpha.DataStore.solution_types]
   * is
   * [SOLUTION_TYPE_CHAT][google.cloud.discoveryengine.v1alpha.SolutionType.SOLUTION_TYPE_CHAT].
   *
   * An extractive segment is a text segment extracted from the original
   * document that is relevant to the search query, and, in general, more
   * verbose than an extractive answer. The segment could then be used as
   * input for LLMs to generate summaries and answers.
   *
   * If the number of matching segments is less than
   * `max_extractive_segment_count`, return all of the segments. Otherwise,
   * return the `max_extractive_segment_count`.
   */
  maxExtractiveSegmentCount: number;
  /**
   * Specifies whether to return the confidence score from the extractive
   * segments in each search result. This feature is available only for new
   * or allowlisted data stores. To allowlist your data store,
   * contact your Customer Engineer. The default value is `false`.
   */
  returnExtractiveSegmentScore: boolean;
  /**
   * Specifies whether to also include the adjacent from each selected
   * segments.
   * Return at most `num_previous_segments` segments before each selected
   * segments.
   */
  numPreviousSegments: number;
  /**
   * Return at most `num_next_segments` segments after each selected
   * segments.
   */
  numNextSegments: number;
}

/**
 * Specifies the chunk spec to be returned from the search response.
 * Only available if the
 * [SearchRequest.ContentSearchSpec.search_result_mode][google.cloud.discoveryengine.v1alpha.SearchRequest.ContentSearchSpec.search_result_mode]
 * is set to
 * [CHUNKS][google.cloud.discoveryengine.v1alpha.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS]
 */
export interface SearchRequest_ContentSearchSpec_ChunkSpec {
  /**
   * The number of previous chunks to be returned of the current chunk. The
   * maximum allowed value is 3.
   * If not specified, no previous chunks will be returned.
   */
  numPreviousChunks: number;
  /**
   * The number of next chunks to be returned of the current chunk. The
   * maximum allowed value is 3.
   * If not specified, no next chunks will be returned.
   */
  numNextChunks: number;
}

/**
 * The specification that uses customized query embedding vector to do
 * semantic document retrieval.
 */
export interface SearchRequest_EmbeddingSpec {
  /** The embedding vector used for retrieval. Limit to 1. */
  embeddingVectors: SearchRequest_EmbeddingSpec_EmbeddingVector[];
}

/** Embedding vector. */
export interface SearchRequest_EmbeddingSpec_EmbeddingVector {
  /** Embedding field path in schema. */
  fieldPath: string;
  /** Query embedding vector. */
  vector: number[];
}

/**
 * Specification to enable natural language understanding capabilities for
 * search requests.
 */
export interface SearchRequest_NaturalLanguageQueryUnderstandingSpec {
  /**
   * The condition under which filter extraction should occur.
   * Default to [Condition.DISABLED][].
   */
  filterExtractionCondition: SearchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionCondition;
  /**
   * Field names used for location-based filtering, where geolocation filters
   * are detected in natural language search queries.
   * Only valid when the FilterExtractionCondition is set to `ENABLED`.
   *
   * If this field is set, it overrides the field names set in
   * [ServingConfig.geo_search_query_detection_field_names][google.cloud.discoveryengine.v1alpha.ServingConfig.geo_search_query_detection_field_names].
   */
  geoSearchQueryDetectionFieldNames: string[];
}

/** Enum describing under which condition filter extraction should occur. */
export enum SearchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionCondition {
  /** CONDITION_UNSPECIFIED - Server behavior defaults to [Condition.DISABLED][]. */
  CONDITION_UNSPECIFIED = 0,
  /** DISABLED - Disables NL filter extraction. */
  DISABLED = 1,
  /** ENABLED - Enables NL filter extraction. */
  ENABLED = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionConditionFromJSON(
  object: any,
): SearchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionCondition {
  switch (object) {
    case 0:
    case "CONDITION_UNSPECIFIED":
      return SearchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionCondition.CONDITION_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return SearchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionCondition.DISABLED;
    case 2:
    case "ENABLED":
      return SearchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionCondition.ENABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionCondition.UNRECOGNIZED;
  }
}

export function searchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionConditionToJSON(
  object: SearchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionCondition,
): string {
  switch (object) {
    case SearchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionCondition.CONDITION_UNSPECIFIED:
      return "CONDITION_UNSPECIFIED";
    case SearchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionCondition.DISABLED:
      return "DISABLED";
    case SearchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionCondition.ENABLED:
      return "ENABLED";
    case SearchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionCondition.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specification for search as you type in search requests. */
export interface SearchRequest_SearchAsYouTypeSpec {
  /**
   * The condition under which search as you type should occur.
   * Default to
   * [Condition.DISABLED][google.cloud.discoveryengine.v1alpha.SearchRequest.SearchAsYouTypeSpec.Condition.DISABLED].
   */
  condition: SearchRequest_SearchAsYouTypeSpec_Condition;
}

/** Enum describing under which condition search as you type should occur. */
export enum SearchRequest_SearchAsYouTypeSpec_Condition {
  /**
   * CONDITION_UNSPECIFIED - Server behavior defaults to
   * [Condition.DISABLED][google.cloud.discoveryengine.v1alpha.SearchRequest.SearchAsYouTypeSpec.Condition.DISABLED].
   */
  CONDITION_UNSPECIFIED = 0,
  /** DISABLED - Disables Search As You Type. */
  DISABLED = 1,
  /** ENABLED - Enables Search As You Type. */
  ENABLED = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_SearchAsYouTypeSpec_ConditionFromJSON(
  object: any,
): SearchRequest_SearchAsYouTypeSpec_Condition {
  switch (object) {
    case 0:
    case "CONDITION_UNSPECIFIED":
      return SearchRequest_SearchAsYouTypeSpec_Condition.CONDITION_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return SearchRequest_SearchAsYouTypeSpec_Condition.DISABLED;
    case 2:
    case "ENABLED":
      return SearchRequest_SearchAsYouTypeSpec_Condition.ENABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_SearchAsYouTypeSpec_Condition.UNRECOGNIZED;
  }
}

export function searchRequest_SearchAsYouTypeSpec_ConditionToJSON(
  object: SearchRequest_SearchAsYouTypeSpec_Condition,
): string {
  switch (object) {
    case SearchRequest_SearchAsYouTypeSpec_Condition.CONDITION_UNSPECIFIED:
      return "CONDITION_UNSPECIFIED";
    case SearchRequest_SearchAsYouTypeSpec_Condition.DISABLED:
      return "DISABLED";
    case SearchRequest_SearchAsYouTypeSpec_Condition.ENABLED:
      return "ENABLED";
    case SearchRequest_SearchAsYouTypeSpec_Condition.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Session specification.
 *
 * Multi-turn Search feature is currently at private GA stage. Please use
 * v1alpha or v1beta version instead before we launch this feature to public
 * GA. Or ask for allowlisting through Google Support team.
 */
export interface SearchRequest_SessionSpec {
  /**
   * If set, the search result gets stored to the "turn" specified by this
   * query ID.
   *
   * Example: Let's say the session looks like this:
   *   session {
   *     name: ".../sessions/xxx"
   *     turns {
   *       query { text: "What is foo?" query_id: ".../questions/yyy" }
   *       answer: "Foo is ..."
   *     }
   *     turns {
   *       query { text: "How about bar then?" query_id: ".../questions/zzz" }
   *     }
   *   }
   *
   * The user can call /search API with a request like this:
   *
   *    session: ".../sessions/xxx"
   *    session_spec { query_id: ".../questions/zzz" }
   *
   * Then, the API stores the search result, associated with the last turn.
   * The stored search result can be used by a subsequent /answer API call
   * (with the session ID and the query ID specified). Also, it is possible
   * to call /search and /answer in parallel with the same session ID & query
   * ID.
   */
  queryId: string;
  /**
   * The number of top search results to persist. The persisted search results
   * can be used for the subsequent /answer api call.
   *
   * This field is simliar to the `summary_result_count` field in
   * [SearchRequest.ContentSearchSpec.SummarySpec.summary_result_count][google.cloud.discoveryengine.v1alpha.SearchRequest.ContentSearchSpec.SummarySpec.summary_result_count].
   *
   * At most 10 results for documents mode, or 50 for chunks mode.
   */
  searchResultPersistenceCount?: number | undefined;
}

export interface SearchRequest_ParamsEntry {
  key: string;
  value: any | undefined;
}

export interface SearchRequest_UserLabelsEntry {
  key: string;
  value: string;
}

/**
 * Response message for
 * [SearchService.Search][google.cloud.discoveryengine.v1alpha.SearchService.Search]
 * method.
 */
export interface SearchResponse {
  /** A list of matched documents. The order represents the ranking. */
  results: SearchResponse_SearchResult[];
  /** Results of facets requested by user. */
  facets: SearchResponse_Facet[];
  /** Guided search result. */
  guidedSearchResult:
    | SearchResponse_GuidedSearchResult
    | undefined;
  /**
   * The estimated total count of matched items irrespective of pagination. The
   * count of
   * [results][google.cloud.discoveryengine.v1alpha.SearchResponse.results]
   * returned by pagination may be less than the
   * [total_size][google.cloud.discoveryengine.v1alpha.SearchResponse.total_size]
   * that matches.
   */
  totalSize: number;
  /**
   * A unique search token. This should be included in the
   * [UserEvent][google.cloud.discoveryengine.v1alpha.UserEvent] logs resulting
   * from this search, which enables accurate attribution of search model
   * performance. This also helps to identify a request during the customer
   * support scenarios.
   */
  attributionToken: string;
  /**
   * The URI of a customer-defined redirect page. If redirect action is
   * triggered, no search is performed, and only
   * [redirect_uri][google.cloud.discoveryengine.v1alpha.SearchResponse.redirect_uri]
   * and
   * [attribution_token][google.cloud.discoveryengine.v1alpha.SearchResponse.attribution_token]
   * are set in the response.
   */
  redirectUri: string;
  /**
   * A token that can be sent as
   * [SearchRequest.page_token][google.cloud.discoveryengine.v1alpha.SearchRequest.page_token]
   * to retrieve the next page. If this field is omitted, there are no
   * subsequent pages.
   */
  nextPageToken: string;
  /**
   * Contains the spell corrected query, if found. If the spell correction type
   * is AUTOMATIC, then the search results are based on corrected_query.
   * Otherwise the original query is used for search.
   */
  correctedQuery: string;
  /**
   * A summary as part of the search results.
   * This field is only returned if
   * [SearchRequest.ContentSearchSpec.summary_spec][google.cloud.discoveryengine.v1alpha.SearchRequest.ContentSearchSpec.summary_spec]
   * is set.
   */
  summary:
    | SearchResponse_Summary
    | undefined;
  /** Controls applied as part of the Control service. */
  appliedControls: string[];
  geoSearchDebugInfo: SearchResponse_GeoSearchDebugInfo[];
  /** Query expansion information for the returned results. */
  queryExpansionInfo:
    | SearchResponse_QueryExpansionInfo
    | undefined;
  /** Natural language query understanding information for the returned results. */
  naturalLanguageQueryUnderstandingInfo:
    | SearchResponse_NaturalLanguageQueryUnderstandingInfo
    | undefined;
  /**
   * Session information.
   *
   * Only set if
   * [SearchRequest.session][google.cloud.discoveryengine.v1alpha.SearchRequest.session]
   * is provided. See its description for more details.
   */
  sessionInfo:
    | SearchResponse_SessionInfo
    | undefined;
  /**
   * A list of One Box results. There can be multiple One Box results of
   * different types.
   */
  oneBoxResults: SearchResponse_OneBoxResult[];
}

/** Represents the search results. */
export interface SearchResponse_SearchResult {
  /**
   * [Document.id][google.cloud.discoveryengine.v1alpha.Document.id] of the
   * searched [Document][google.cloud.discoveryengine.v1alpha.Document].
   */
  id: string;
  /**
   * The document data snippet in the search response. Only fields that are
   * marked as `retrievable` are populated.
   */
  document:
    | Document
    | undefined;
  /**
   * The chunk data in the search response if the
   * [SearchRequest.ContentSearchSpec.search_result_mode][google.cloud.discoveryengine.v1alpha.SearchRequest.ContentSearchSpec.search_result_mode]
   * is set to
   * [CHUNKS][google.cloud.discoveryengine.v1alpha.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS].
   */
  chunk:
    | Chunk
    | undefined;
  /** Google provided available scores. */
  modelScores: { [key: string]: DoubleList };
}

export interface SearchResponse_SearchResult_ModelScoresEntry {
  key: string;
  value: DoubleList | undefined;
}

/** A facet result. */
export interface SearchResponse_Facet {
  /**
   * The key for this facet. For example, `"colors"` or `"price"`. It matches
   * [SearchRequest.FacetSpec.FacetKey.key][google.cloud.discoveryengine.v1alpha.SearchRequest.FacetSpec.FacetKey.key].
   */
  key: string;
  /** The facet values for this field. */
  values: SearchResponse_Facet_FacetValue[];
  /** Whether the facet is dynamically generated. */
  dynamicFacet: boolean;
}

/** A facet value which contains value names and their count. */
export interface SearchResponse_Facet_FacetValue {
  /** Text value of a facet, such as "Black" for facet "colors". */
  value?:
    | string
    | undefined;
  /**
   * Interval value for a facet, such as [10, 20) for facet "price". It
   * matches
   * [SearchRequest.FacetSpec.FacetKey.intervals][google.cloud.discoveryengine.v1alpha.SearchRequest.FacetSpec.FacetKey.intervals].
   */
  interval?:
    | Interval
    | undefined;
  /** Number of items that have this facet value. */
  count: Long;
}

/**
 * Guided search result. The guided search helps user to refine the search
 * results and narrow down to the real needs from a broaded search results.
 */
export interface SearchResponse_GuidedSearchResult {
  /** A list of ranked refinement attributes. */
  refinementAttributes: SearchResponse_GuidedSearchResult_RefinementAttribute[];
  /** Suggested follow-up questions. */
  followUpQuestions: string[];
}

/** Useful attribute for search result refinements. */
export interface SearchResponse_GuidedSearchResult_RefinementAttribute {
  /** Attribute key used to refine the results. For example, `"movie_type"`. */
  attributeKey: string;
  /** Attribute value used to refine the results. For example, `"drama"`. */
  attributeValue: string;
}

/** Summary of the top N search results specified by the summary spec. */
export interface SearchResponse_Summary {
  /** The summary content. */
  summaryText: string;
  /**
   * Additional summary-skipped reasons. This provides the reason for ignored
   * cases. If nothing is skipped, this field is not set.
   */
  summarySkippedReasons: SearchResponse_Summary_SummarySkippedReason[];
  /**
   * A collection of Safety Attribute categories and their associated
   * confidence scores.
   */
  safetyAttributes:
    | SearchResponse_Summary_SafetyAttributes
    | undefined;
  /** Summary with metadata information. */
  summaryWithMetadata: SearchResponse_Summary_SummaryWithMetadata | undefined;
}

/** An Enum for summary-skipped reasons. */
export enum SearchResponse_Summary_SummarySkippedReason {
  /** SUMMARY_SKIPPED_REASON_UNSPECIFIED - Default value. The summary skipped reason is not specified. */
  SUMMARY_SKIPPED_REASON_UNSPECIFIED = 0,
  /**
   * ADVERSARIAL_QUERY_IGNORED - The adversarial query ignored case.
   *
   * Only used when
   * [SummarySpec.ignore_adversarial_query][google.cloud.discoveryengine.v1alpha.SearchRequest.ContentSearchSpec.SummarySpec.ignore_adversarial_query]
   * is set to `true`.
   */
  ADVERSARIAL_QUERY_IGNORED = 1,
  /**
   * NON_SUMMARY_SEEKING_QUERY_IGNORED - The non-summary seeking query ignored case.
   *
   * Only used when
   * [SummarySpec.ignore_non_summary_seeking_query][google.cloud.discoveryengine.v1alpha.SearchRequest.ContentSearchSpec.SummarySpec.ignore_non_summary_seeking_query]
   * is set to `true`.
   */
  NON_SUMMARY_SEEKING_QUERY_IGNORED = 2,
  /**
   * OUT_OF_DOMAIN_QUERY_IGNORED - The out-of-domain query ignored case.
   *
   * Google skips the summary if there are no high-relevance search results.
   * For example, the data store contains facts about company A but the
   * user query is asking questions about company B.
   */
  OUT_OF_DOMAIN_QUERY_IGNORED = 3,
  /**
   * POTENTIAL_POLICY_VIOLATION - The potential policy violation case.
   *
   * Google skips the summary if there is a potential policy violation
   * detected. This includes content that may be violent or toxic.
   */
  POTENTIAL_POLICY_VIOLATION = 4,
  /**
   * LLM_ADDON_NOT_ENABLED - The LLM addon not enabled case.
   *
   * Google skips the summary if the LLM addon is not enabled.
   */
  LLM_ADDON_NOT_ENABLED = 5,
  /**
   * NO_RELEVANT_CONTENT - The no relevant content case.
   *
   * Google skips the summary if there is no relevant content in the
   * retrieved search results.
   */
  NO_RELEVANT_CONTENT = 6,
  /**
   * JAIL_BREAKING_QUERY_IGNORED - The jail-breaking query ignored case.
   *
   * For example, "Reply in the tone of a competing company's CEO".
   * Only used when
   * [SearchRequest.ContentSearchSpec.SummarySpec.ignore_jail_breaking_query]
   * is set to `true`.
   */
  JAIL_BREAKING_QUERY_IGNORED = 7,
  /**
   * CUSTOMER_POLICY_VIOLATION - The customer policy violation case.
   *
   * Google skips the summary if there is a customer policy violation
   * detected. The policy is defined by the customer.
   */
  CUSTOMER_POLICY_VIOLATION = 8,
  /**
   * NON_SUMMARY_SEEKING_QUERY_IGNORED_V2 - The non-answer seeking query ignored case.
   *
   * Only used when
   * [SearchRequest.ContentSearchSpec.SummarySpec.ignore_non_answer_seeking_query]
   * is set to `true`.
   */
  NON_SUMMARY_SEEKING_QUERY_IGNORED_V2 = 9,
  UNRECOGNIZED = -1,
}

export function searchResponse_Summary_SummarySkippedReasonFromJSON(
  object: any,
): SearchResponse_Summary_SummarySkippedReason {
  switch (object) {
    case 0:
    case "SUMMARY_SKIPPED_REASON_UNSPECIFIED":
      return SearchResponse_Summary_SummarySkippedReason.SUMMARY_SKIPPED_REASON_UNSPECIFIED;
    case 1:
    case "ADVERSARIAL_QUERY_IGNORED":
      return SearchResponse_Summary_SummarySkippedReason.ADVERSARIAL_QUERY_IGNORED;
    case 2:
    case "NON_SUMMARY_SEEKING_QUERY_IGNORED":
      return SearchResponse_Summary_SummarySkippedReason.NON_SUMMARY_SEEKING_QUERY_IGNORED;
    case 3:
    case "OUT_OF_DOMAIN_QUERY_IGNORED":
      return SearchResponse_Summary_SummarySkippedReason.OUT_OF_DOMAIN_QUERY_IGNORED;
    case 4:
    case "POTENTIAL_POLICY_VIOLATION":
      return SearchResponse_Summary_SummarySkippedReason.POTENTIAL_POLICY_VIOLATION;
    case 5:
    case "LLM_ADDON_NOT_ENABLED":
      return SearchResponse_Summary_SummarySkippedReason.LLM_ADDON_NOT_ENABLED;
    case 6:
    case "NO_RELEVANT_CONTENT":
      return SearchResponse_Summary_SummarySkippedReason.NO_RELEVANT_CONTENT;
    case 7:
    case "JAIL_BREAKING_QUERY_IGNORED":
      return SearchResponse_Summary_SummarySkippedReason.JAIL_BREAKING_QUERY_IGNORED;
    case 8:
    case "CUSTOMER_POLICY_VIOLATION":
      return SearchResponse_Summary_SummarySkippedReason.CUSTOMER_POLICY_VIOLATION;
    case 9:
    case "NON_SUMMARY_SEEKING_QUERY_IGNORED_V2":
      return SearchResponse_Summary_SummarySkippedReason.NON_SUMMARY_SEEKING_QUERY_IGNORED_V2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchResponse_Summary_SummarySkippedReason.UNRECOGNIZED;
  }
}

export function searchResponse_Summary_SummarySkippedReasonToJSON(
  object: SearchResponse_Summary_SummarySkippedReason,
): string {
  switch (object) {
    case SearchResponse_Summary_SummarySkippedReason.SUMMARY_SKIPPED_REASON_UNSPECIFIED:
      return "SUMMARY_SKIPPED_REASON_UNSPECIFIED";
    case SearchResponse_Summary_SummarySkippedReason.ADVERSARIAL_QUERY_IGNORED:
      return "ADVERSARIAL_QUERY_IGNORED";
    case SearchResponse_Summary_SummarySkippedReason.NON_SUMMARY_SEEKING_QUERY_IGNORED:
      return "NON_SUMMARY_SEEKING_QUERY_IGNORED";
    case SearchResponse_Summary_SummarySkippedReason.OUT_OF_DOMAIN_QUERY_IGNORED:
      return "OUT_OF_DOMAIN_QUERY_IGNORED";
    case SearchResponse_Summary_SummarySkippedReason.POTENTIAL_POLICY_VIOLATION:
      return "POTENTIAL_POLICY_VIOLATION";
    case SearchResponse_Summary_SummarySkippedReason.LLM_ADDON_NOT_ENABLED:
      return "LLM_ADDON_NOT_ENABLED";
    case SearchResponse_Summary_SummarySkippedReason.NO_RELEVANT_CONTENT:
      return "NO_RELEVANT_CONTENT";
    case SearchResponse_Summary_SummarySkippedReason.JAIL_BREAKING_QUERY_IGNORED:
      return "JAIL_BREAKING_QUERY_IGNORED";
    case SearchResponse_Summary_SummarySkippedReason.CUSTOMER_POLICY_VIOLATION:
      return "CUSTOMER_POLICY_VIOLATION";
    case SearchResponse_Summary_SummarySkippedReason.NON_SUMMARY_SEEKING_QUERY_IGNORED_V2:
      return "NON_SUMMARY_SEEKING_QUERY_IGNORED_V2";
    case SearchResponse_Summary_SummarySkippedReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Safety Attribute categories and their associated confidence scores. */
export interface SearchResponse_Summary_SafetyAttributes {
  /**
   * The display names of Safety Attribute categories associated with the
   * generated content. Order matches the Scores.
   */
  categories: string[];
  /**
   * The confidence scores of the each category, higher
   * value means higher confidence. Order matches the Categories.
   */
  scores: number[];
}

/** Citation metadata. */
export interface SearchResponse_Summary_CitationMetadata {
  /** Citations for segments. */
  citations: SearchResponse_Summary_Citation[];
}

/** Citation info for a segment. */
export interface SearchResponse_Summary_Citation {
  /** Index indicates the start of the segment, measured in bytes/unicode. */
  startIndex: Long;
  /** End of the attributed segment, exclusive. */
  endIndex: Long;
  /** Citation sources for the attributed segment. */
  sources: SearchResponse_Summary_CitationSource[];
}

/** Citation source. */
export interface SearchResponse_Summary_CitationSource {
  /**
   * Document reference index from SummaryWithMetadata.references.
   * It is 0-indexed and the value will be zero if the reference_index is
   * not set explicitly.
   */
  referenceIndex: Long;
}

/** Document reference. */
export interface SearchResponse_Summary_Reference {
  /** Title of the document. */
  title: string;
  /**
   * Required.
   * [Document.name][google.cloud.discoveryengine.v1alpha.Document.name] of
   * the document. Full resource name of the referenced document, in the
   * format
   * `projects/* /locations/* /collections/* /dataStores/* /branches/* /documents/*`.
   */
  document: string;
  /** Cloud Storage or HTTP uri for the document. */
  uri: string;
  /** List of cited chunk contents derived from document content. */
  chunkContents: SearchResponse_Summary_Reference_ChunkContent[];
}

/** Chunk content. */
export interface SearchResponse_Summary_Reference_ChunkContent {
  /** Chunk textual content. */
  content: string;
  /** Page identifier. */
  pageIdentifier: string;
}

/** Summary with metadata information. */
export interface SearchResponse_Summary_SummaryWithMetadata {
  /** Summary text with no citation information. */
  summary: string;
  /** Citation metadata for given summary. */
  citationMetadata:
    | SearchResponse_Summary_CitationMetadata
    | undefined;
  /** Document References. */
  references: SearchResponse_Summary_Reference[];
}

/**
 * Debug information specifically related to forward geocoding issues arising
 * from Geolocation Search.
 */
export interface SearchResponse_GeoSearchDebugInfo {
  /** The address from which forward geocoding ingestion produced issues. */
  originalAddressQuery: string;
  /** The error produced. */
  errorMessage: string;
}

/**
 * Information describing query expansion including whether expansion has
 * occurred.
 */
export interface SearchResponse_QueryExpansionInfo {
  /** Bool describing whether query expansion has occurred. */
  expandedQuery: boolean;
  /**
   * Number of pinned results. This field will only be set when expansion
   * happens and
   * [SearchRequest.QueryExpansionSpec.pin_unexpanded_results][google.cloud.discoveryengine.v1alpha.SearchRequest.QueryExpansionSpec.pin_unexpanded_results]
   * is set to true.
   */
  pinnedResultCount: Long;
}

/**
 * Information describing what natural language understanding was
 * done on the input query.
 */
export interface SearchResponse_NaturalLanguageQueryUnderstandingInfo {
  /** The filters that were extracted from the input query. */
  extractedFilters: string;
  /** Rewritten input query minus the extracted filters. */
  rewrittenQuery: string;
  /**
   * The filters that were extracted from the input query represented in a
   * structured form.
   */
  structuredExtractedFilter: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter | undefined;
}

/**
 * The filters that were extracted from the input query represented in a
 * structured form.
 */
export interface SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter {
  /**
   * The expression denoting the filter that was extracted from the input
   * query in a structured form. It can be a simple expression denoting a
   * single string, numerical or geolocation constraint or a compound
   * expression which is a combination of multiple expressions connected
   * using logical (OR and AND) operators.
   */
  expression: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression | undefined;
}

/** Constraint expression of a string field. */
export interface SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint {
  /** Name of the string field as defined in the schema. */
  fieldName: string;
  /**
   * Values of the string field. The record will only be returned if the
   * field value matches one of the values specified here.
   */
  values: string[];
  /** Identifies the keywords within the search query that match a filter. */
  querySegment: string;
}

/** Constraint expression of a number field. Example: price < 100. */
export interface SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint {
  /** Name of the numerical field as defined in the schema. */
  fieldName: string;
  /**
   * The comparison operation performed between the field value and the
   * value specified in the constraint.
   */
  comparison:
    SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison;
  /** The value specified in the numerical constraint. */
  value: number;
  /** Identifies the keywords within the search query that match a filter. */
  querySegment: string;
}

/** The comparison operation that was performed. */
export enum SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison {
  /** COMPARISON_UNSPECIFIED - Undefined comparison operator. */
  COMPARISON_UNSPECIFIED = 0,
  /** EQUALS - Denotes equality `=` operator. */
  EQUALS = 1,
  /** LESS_THAN_EQUALS - Denotes less than or equal to `<=` operator. */
  LESS_THAN_EQUALS = 2,
  /** LESS_THAN - Denotes less than `<` operator. */
  LESS_THAN = 3,
  /** GREATER_THAN_EQUALS - Denotes greater than or equal to `>=` operator. */
  GREATER_THAN_EQUALS = 4,
  /** GREATER_THAN - Denotes greater than `>` operator. */
  GREATER_THAN = 5,
  UNRECOGNIZED = -1,
}

export function searchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_ComparisonFromJSON(
  object: any,
): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison {
  switch (object) {
    case 0:
    case "COMPARISON_UNSPECIFIED":
      return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
        .COMPARISON_UNSPECIFIED;
    case 1:
    case "EQUALS":
      return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
        .EQUALS;
    case 2:
    case "LESS_THAN_EQUALS":
      return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
        .LESS_THAN_EQUALS;
    case 3:
    case "LESS_THAN":
      return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
        .LESS_THAN;
    case 4:
    case "GREATER_THAN_EQUALS":
      return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
        .GREATER_THAN_EQUALS;
    case 5:
    case "GREATER_THAN":
      return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
        .GREATER_THAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
        .UNRECOGNIZED;
  }
}

export function searchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_ComparisonToJSON(
  object: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison,
): string {
  switch (object) {
    case SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
      .COMPARISON_UNSPECIFIED:
      return "COMPARISON_UNSPECIFIED";
    case SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
      .EQUALS:
      return "EQUALS";
    case SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
      .LESS_THAN_EQUALS:
      return "LESS_THAN_EQUALS";
    case SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
      .LESS_THAN:
      return "LESS_THAN";
    case SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
      .GREATER_THAN_EQUALS:
      return "GREATER_THAN_EQUALS";
    case SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
      .GREATER_THAN:
      return "GREATER_THAN";
    case SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_Comparison
      .UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Constraint of a geolocation field.
 * Name of the geolocation field as defined in the schema.
 */
export interface SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint {
  /** The name of the geolocation field as defined in the schema. */
  fieldName: string;
  /**
   * The reference address that was inferred from the input query. The
   * proximity of the reference address to the geolocation field will be
   * used to filter the results.
   */
  address: string;
  /** The latitude of the geolocation inferred from the input query. */
  latitude: number;
  /** The longitude of the geolocation inferred from the input query. */
  longitude: number;
  /**
   * The radius in meters around the address. The record is returned if
   * the location of the geolocation field is within the radius.
   */
  radiusInMeters: number;
}

/** Logical `And` operator. */
export interface SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression {
  /** The expressions that were ANDed together. */
  expressions: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression[];
}

/** Logical `Or` operator. */
export interface SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression {
  /** The expressions that were ORed together. */
  expressions: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression[];
}

/**
 * The expression denoting the filter that was extracted from the input
 * query.
 */
export interface SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression {
  /** String constraint expression. */
  stringConstraint?:
    | SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint
    | undefined;
  /** Numerical constraint expression. */
  numberConstraint?:
    | SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint
    | undefined;
  /** Geolocation constraint expression. */
  geolocationConstraint?:
    | SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint
    | undefined;
  /** Logical "And" compound operator connecting multiple expressions. */
  andExpr?:
    | SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression
    | undefined;
  /** Logical "Or" compound operator connecting multiple expressions. */
  orExpr?: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression | undefined;
}

/** Information about the session. */
export interface SearchResponse_SessionInfo {
  /**
   * Name of the session.
   * If the auto-session mode is used (when
   * [SearchRequest.session][google.cloud.discoveryengine.v1alpha.SearchRequest.session]
   * ends with "-"), this field holds the newly generated session name.
   */
  name: string;
  /**
   * Query ID that corresponds to this search API call.
   * One session can have multiple turns, each with a unique query ID.
   *
   * By specifying the session name and this query ID in the Answer API call,
   * the answer generation happens in the context of the search results from
   * this search call.
   */
  queryId: string;
}

/**
 * OneBoxResult is a holder for all results of specific type that we want
 * to display in UI differently.
 */
export interface SearchResponse_OneBoxResult {
  /** The type of One Box result. */
  oneBoxType: SearchResponse_OneBoxResult_OneBoxType;
  /** The search results for this One Box. */
  searchResults: SearchResponse_SearchResult[];
}

/** The type of One Box result. */
export enum SearchResponse_OneBoxResult_OneBoxType {
  /** ONE_BOX_TYPE_UNSPECIFIED - Default value. Should not be used. */
  ONE_BOX_TYPE_UNSPECIFIED = 0,
  /** PEOPLE - One Box result contains people results. */
  PEOPLE = 1,
  /** ORGANIZATION - One Box result contains organization results. */
  ORGANIZATION = 2,
  /** SLACK - One Box result contains slack results. */
  SLACK = 3,
  UNRECOGNIZED = -1,
}

export function searchResponse_OneBoxResult_OneBoxTypeFromJSON(object: any): SearchResponse_OneBoxResult_OneBoxType {
  switch (object) {
    case 0:
    case "ONE_BOX_TYPE_UNSPECIFIED":
      return SearchResponse_OneBoxResult_OneBoxType.ONE_BOX_TYPE_UNSPECIFIED;
    case 1:
    case "PEOPLE":
      return SearchResponse_OneBoxResult_OneBoxType.PEOPLE;
    case 2:
    case "ORGANIZATION":
      return SearchResponse_OneBoxResult_OneBoxType.ORGANIZATION;
    case 3:
    case "SLACK":
      return SearchResponse_OneBoxResult_OneBoxType.SLACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchResponse_OneBoxResult_OneBoxType.UNRECOGNIZED;
  }
}

export function searchResponse_OneBoxResult_OneBoxTypeToJSON(object: SearchResponse_OneBoxResult_OneBoxType): string {
  switch (object) {
    case SearchResponse_OneBoxResult_OneBoxType.ONE_BOX_TYPE_UNSPECIFIED:
      return "ONE_BOX_TYPE_UNSPECIFIED";
    case SearchResponse_OneBoxResult_OneBoxType.PEOPLE:
      return "PEOPLE";
    case SearchResponse_OneBoxResult_OneBoxType.ORGANIZATION:
      return "ORGANIZATION";
    case SearchResponse_OneBoxResult_OneBoxType.SLACK:
      return "SLACK";
    case SearchResponse_OneBoxResult_OneBoxType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseSearchRequest(): SearchRequest {
  return {
    servingConfig: "",
    branch: "",
    query: "",
    imageQuery: undefined,
    pageSize: 0,
    pageToken: "",
    offset: 0,
    dataStoreSpecs: [],
    filter: "",
    canonicalFilter: "",
    orderBy: "",
    userInfo: undefined,
    languageCode: "",
    regionCode: "",
    facetSpecs: [],
    boostSpec: undefined,
    params: {},
    queryExpansionSpec: undefined,
    spellCorrectionSpec: undefined,
    userPseudoId: "",
    contentSearchSpec: undefined,
    embeddingSpec: undefined,
    rankingExpression: "",
    safeSearch: false,
    userLabels: {},
    naturalLanguageQueryUnderstandingSpec: undefined,
    searchAsYouTypeSpec: undefined,
    customFineTuningSpec: undefined,
    session: "",
    sessionSpec: undefined,
    relevanceThreshold: 0,
  };
}

export const SearchRequest: MessageFns<SearchRequest> = {
  encode(message: SearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.servingConfig !== "") {
      writer.uint32(10).string(message.servingConfig);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.query !== "") {
      writer.uint32(26).string(message.query);
    }
    if (message.imageQuery !== undefined) {
      SearchRequest_ImageQuery.encode(message.imageQuery, writer.uint32(154).fork()).join();
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    if (message.offset !== 0) {
      writer.uint32(48).int32(message.offset);
    }
    for (const v of message.dataStoreSpecs) {
      SearchRequest_DataStoreSpec.encode(v!, writer.uint32(258).fork()).join();
    }
    if (message.filter !== "") {
      writer.uint32(58).string(message.filter);
    }
    if (message.canonicalFilter !== "") {
      writer.uint32(234).string(message.canonicalFilter);
    }
    if (message.orderBy !== "") {
      writer.uint32(66).string(message.orderBy);
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(170).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(282).string(message.languageCode);
    }
    if (message.regionCode !== "") {
      writer.uint32(290).string(message.regionCode);
    }
    for (const v of message.facetSpecs) {
      SearchRequest_FacetSpec.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.boostSpec !== undefined) {
      SearchRequest_BoostSpec.encode(message.boostSpec, writer.uint32(82).fork()).join();
    }
    Object.entries(message.params).forEach(([key, value]) => {
      if (value !== undefined) {
        SearchRequest_ParamsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
      }
    });
    if (message.queryExpansionSpec !== undefined) {
      SearchRequest_QueryExpansionSpec.encode(message.queryExpansionSpec, writer.uint32(106).fork()).join();
    }
    if (message.spellCorrectionSpec !== undefined) {
      SearchRequest_SpellCorrectionSpec.encode(message.spellCorrectionSpec, writer.uint32(114).fork()).join();
    }
    if (message.userPseudoId !== "") {
      writer.uint32(122).string(message.userPseudoId);
    }
    if (message.contentSearchSpec !== undefined) {
      SearchRequest_ContentSearchSpec.encode(message.contentSearchSpec, writer.uint32(194).fork()).join();
    }
    if (message.embeddingSpec !== undefined) {
      SearchRequest_EmbeddingSpec.encode(message.embeddingSpec, writer.uint32(186).fork()).join();
    }
    if (message.rankingExpression !== "") {
      writer.uint32(210).string(message.rankingExpression);
    }
    if (message.safeSearch !== false) {
      writer.uint32(160).bool(message.safeSearch);
    }
    Object.entries(message.userLabels).forEach(([key, value]) => {
      SearchRequest_UserLabelsEntry.encode({ key: key as any, value }, writer.uint32(178).fork()).join();
    });
    if (message.naturalLanguageQueryUnderstandingSpec !== undefined) {
      SearchRequest_NaturalLanguageQueryUnderstandingSpec.encode(
        message.naturalLanguageQueryUnderstandingSpec,
        writer.uint32(226).fork(),
      ).join();
    }
    if (message.searchAsYouTypeSpec !== undefined) {
      SearchRequest_SearchAsYouTypeSpec.encode(message.searchAsYouTypeSpec, writer.uint32(250).fork()).join();
    }
    if (message.customFineTuningSpec !== undefined) {
      CustomFineTuningSpec.encode(message.customFineTuningSpec, writer.uint32(274).fork()).join();
    }
    if (message.session !== "") {
      writer.uint32(330).string(message.session);
    }
    if (message.sessionSpec !== undefined) {
      SearchRequest_SessionSpec.encode(message.sessionSpec, writer.uint32(338).fork()).join();
    }
    if (message.relevanceThreshold !== 0) {
      writer.uint32(352).int32(message.relevanceThreshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.servingConfig = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.imageQuery = SearchRequest_ImageQuery.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.offset = reader.int32();
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.dataStoreSpecs.push(SearchRequest_DataStoreSpec.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.canonicalFilter = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.facetSpecs.push(SearchRequest_FacetSpec.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.boostSpec = SearchRequest_BoostSpec.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = SearchRequest_ParamsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.params[entry11.key] = entry11.value;
          }
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.queryExpansionSpec = SearchRequest_QueryExpansionSpec.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.spellCorrectionSpec = SearchRequest_SpellCorrectionSpec.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.userPseudoId = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.contentSearchSpec = SearchRequest_ContentSearchSpec.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.embeddingSpec = SearchRequest_EmbeddingSpec.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.rankingExpression = reader.string();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.safeSearch = reader.bool();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          const entry22 = SearchRequest_UserLabelsEntry.decode(reader, reader.uint32());
          if (entry22.value !== undefined) {
            message.userLabels[entry22.key] = entry22.value;
          }
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.naturalLanguageQueryUnderstandingSpec = SearchRequest_NaturalLanguageQueryUnderstandingSpec.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.searchAsYouTypeSpec = SearchRequest_SearchAsYouTypeSpec.decode(reader, reader.uint32());
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.customFineTuningSpec = CustomFineTuningSpec.decode(reader, reader.uint32());
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.session = reader.string();
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.sessionSpec = SearchRequest_SessionSpec.decode(reader, reader.uint32());
          continue;
        case 44:
          if (tag !== 352) {
            break;
          }

          message.relevanceThreshold = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest {
    return {
      servingConfig: isSet(object.servingConfig) ? globalThis.String(object.servingConfig) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      imageQuery: isSet(object.imageQuery) ? SearchRequest_ImageQuery.fromJSON(object.imageQuery) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      dataStoreSpecs: globalThis.Array.isArray(object?.dataStoreSpecs)
        ? object.dataStoreSpecs.map((e: any) => SearchRequest_DataStoreSpec.fromJSON(e))
        : [],
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      canonicalFilter: isSet(object.canonicalFilter) ? globalThis.String(object.canonicalFilter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      facetSpecs: globalThis.Array.isArray(object?.facetSpecs)
        ? object.facetSpecs.map((e: any) => SearchRequest_FacetSpec.fromJSON(e))
        : [],
      boostSpec: isSet(object.boostSpec) ? SearchRequest_BoostSpec.fromJSON(object.boostSpec) : undefined,
      params: isObject(object.params)
        ? Object.entries(object.params).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      queryExpansionSpec: isSet(object.queryExpansionSpec)
        ? SearchRequest_QueryExpansionSpec.fromJSON(object.queryExpansionSpec)
        : undefined,
      spellCorrectionSpec: isSet(object.spellCorrectionSpec)
        ? SearchRequest_SpellCorrectionSpec.fromJSON(object.spellCorrectionSpec)
        : undefined,
      userPseudoId: isSet(object.userPseudoId) ? globalThis.String(object.userPseudoId) : "",
      contentSearchSpec: isSet(object.contentSearchSpec)
        ? SearchRequest_ContentSearchSpec.fromJSON(object.contentSearchSpec)
        : undefined,
      embeddingSpec: isSet(object.embeddingSpec)
        ? SearchRequest_EmbeddingSpec.fromJSON(object.embeddingSpec)
        : undefined,
      rankingExpression: isSet(object.rankingExpression) ? globalThis.String(object.rankingExpression) : "",
      safeSearch: isSet(object.safeSearch) ? globalThis.Boolean(object.safeSearch) : false,
      userLabels: isObject(object.userLabels)
        ? Object.entries(object.userLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      naturalLanguageQueryUnderstandingSpec: isSet(object.naturalLanguageQueryUnderstandingSpec)
        ? SearchRequest_NaturalLanguageQueryUnderstandingSpec.fromJSON(object.naturalLanguageQueryUnderstandingSpec)
        : undefined,
      searchAsYouTypeSpec: isSet(object.searchAsYouTypeSpec)
        ? SearchRequest_SearchAsYouTypeSpec.fromJSON(object.searchAsYouTypeSpec)
        : undefined,
      customFineTuningSpec: isSet(object.customFineTuningSpec)
        ? CustomFineTuningSpec.fromJSON(object.customFineTuningSpec)
        : undefined,
      session: isSet(object.session) ? globalThis.String(object.session) : "",
      sessionSpec: isSet(object.sessionSpec) ? SearchRequest_SessionSpec.fromJSON(object.sessionSpec) : undefined,
      relevanceThreshold: isSet(object.relevanceThreshold)
        ? searchRequest_RelevanceThresholdFromJSON(object.relevanceThreshold)
        : 0,
    };
  },

  toJSON(message: SearchRequest): unknown {
    const obj: any = {};
    if (message.servingConfig !== "") {
      obj.servingConfig = message.servingConfig;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.imageQuery !== undefined) {
      obj.imageQuery = SearchRequest_ImageQuery.toJSON(message.imageQuery);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.dataStoreSpecs?.length) {
      obj.dataStoreSpecs = message.dataStoreSpecs.map((e) => SearchRequest_DataStoreSpec.toJSON(e));
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.canonicalFilter !== "") {
      obj.canonicalFilter = message.canonicalFilter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.facetSpecs?.length) {
      obj.facetSpecs = message.facetSpecs.map((e) => SearchRequest_FacetSpec.toJSON(e));
    }
    if (message.boostSpec !== undefined) {
      obj.boostSpec = SearchRequest_BoostSpec.toJSON(message.boostSpec);
    }
    if (message.params) {
      const entries = Object.entries(message.params);
      if (entries.length > 0) {
        obj.params = {};
        entries.forEach(([k, v]) => {
          obj.params[k] = v;
        });
      }
    }
    if (message.queryExpansionSpec !== undefined) {
      obj.queryExpansionSpec = SearchRequest_QueryExpansionSpec.toJSON(message.queryExpansionSpec);
    }
    if (message.spellCorrectionSpec !== undefined) {
      obj.spellCorrectionSpec = SearchRequest_SpellCorrectionSpec.toJSON(message.spellCorrectionSpec);
    }
    if (message.userPseudoId !== "") {
      obj.userPseudoId = message.userPseudoId;
    }
    if (message.contentSearchSpec !== undefined) {
      obj.contentSearchSpec = SearchRequest_ContentSearchSpec.toJSON(message.contentSearchSpec);
    }
    if (message.embeddingSpec !== undefined) {
      obj.embeddingSpec = SearchRequest_EmbeddingSpec.toJSON(message.embeddingSpec);
    }
    if (message.rankingExpression !== "") {
      obj.rankingExpression = message.rankingExpression;
    }
    if (message.safeSearch !== false) {
      obj.safeSearch = message.safeSearch;
    }
    if (message.userLabels) {
      const entries = Object.entries(message.userLabels);
      if (entries.length > 0) {
        obj.userLabels = {};
        entries.forEach(([k, v]) => {
          obj.userLabels[k] = v;
        });
      }
    }
    if (message.naturalLanguageQueryUnderstandingSpec !== undefined) {
      obj.naturalLanguageQueryUnderstandingSpec = SearchRequest_NaturalLanguageQueryUnderstandingSpec.toJSON(
        message.naturalLanguageQueryUnderstandingSpec,
      );
    }
    if (message.searchAsYouTypeSpec !== undefined) {
      obj.searchAsYouTypeSpec = SearchRequest_SearchAsYouTypeSpec.toJSON(message.searchAsYouTypeSpec);
    }
    if (message.customFineTuningSpec !== undefined) {
      obj.customFineTuningSpec = CustomFineTuningSpec.toJSON(message.customFineTuningSpec);
    }
    if (message.session !== "") {
      obj.session = message.session;
    }
    if (message.sessionSpec !== undefined) {
      obj.sessionSpec = SearchRequest_SessionSpec.toJSON(message.sessionSpec);
    }
    if (message.relevanceThreshold !== 0) {
      obj.relevanceThreshold = searchRequest_RelevanceThresholdToJSON(message.relevanceThreshold);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest>): SearchRequest {
    return SearchRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest>): SearchRequest {
    const message = createBaseSearchRequest();
    message.servingConfig = object.servingConfig ?? "";
    message.branch = object.branch ?? "";
    message.query = object.query ?? "";
    message.imageQuery = (object.imageQuery !== undefined && object.imageQuery !== null)
      ? SearchRequest_ImageQuery.fromPartial(object.imageQuery)
      : undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.offset = object.offset ?? 0;
    message.dataStoreSpecs = object.dataStoreSpecs?.map((e) => SearchRequest_DataStoreSpec.fromPartial(e)) || [];
    message.filter = object.filter ?? "";
    message.canonicalFilter = object.canonicalFilter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    message.languageCode = object.languageCode ?? "";
    message.regionCode = object.regionCode ?? "";
    message.facetSpecs = object.facetSpecs?.map((e) => SearchRequest_FacetSpec.fromPartial(e)) || [];
    message.boostSpec = (object.boostSpec !== undefined && object.boostSpec !== null)
      ? SearchRequest_BoostSpec.fromPartial(object.boostSpec)
      : undefined;
    message.params = Object.entries(object.params ?? {}).reduce<{ [key: string]: any | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.queryExpansionSpec = (object.queryExpansionSpec !== undefined && object.queryExpansionSpec !== null)
      ? SearchRequest_QueryExpansionSpec.fromPartial(object.queryExpansionSpec)
      : undefined;
    message.spellCorrectionSpec = (object.spellCorrectionSpec !== undefined && object.spellCorrectionSpec !== null)
      ? SearchRequest_SpellCorrectionSpec.fromPartial(object.spellCorrectionSpec)
      : undefined;
    message.userPseudoId = object.userPseudoId ?? "";
    message.contentSearchSpec = (object.contentSearchSpec !== undefined && object.contentSearchSpec !== null)
      ? SearchRequest_ContentSearchSpec.fromPartial(object.contentSearchSpec)
      : undefined;
    message.embeddingSpec = (object.embeddingSpec !== undefined && object.embeddingSpec !== null)
      ? SearchRequest_EmbeddingSpec.fromPartial(object.embeddingSpec)
      : undefined;
    message.rankingExpression = object.rankingExpression ?? "";
    message.safeSearch = object.safeSearch ?? false;
    message.userLabels = Object.entries(object.userLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.naturalLanguageQueryUnderstandingSpec =
      (object.naturalLanguageQueryUnderstandingSpec !== undefined &&
          object.naturalLanguageQueryUnderstandingSpec !== null)
        ? SearchRequest_NaturalLanguageQueryUnderstandingSpec.fromPartial(object.naturalLanguageQueryUnderstandingSpec)
        : undefined;
    message.searchAsYouTypeSpec = (object.searchAsYouTypeSpec !== undefined && object.searchAsYouTypeSpec !== null)
      ? SearchRequest_SearchAsYouTypeSpec.fromPartial(object.searchAsYouTypeSpec)
      : undefined;
    message.customFineTuningSpec = (object.customFineTuningSpec !== undefined && object.customFineTuningSpec !== null)
      ? CustomFineTuningSpec.fromPartial(object.customFineTuningSpec)
      : undefined;
    message.session = object.session ?? "";
    message.sessionSpec = (object.sessionSpec !== undefined && object.sessionSpec !== null)
      ? SearchRequest_SessionSpec.fromPartial(object.sessionSpec)
      : undefined;
    message.relevanceThreshold = object.relevanceThreshold ?? 0;
    return message;
  },
};

function createBaseSearchRequest_ImageQuery(): SearchRequest_ImageQuery {
  return { imageBytes: undefined };
}

export const SearchRequest_ImageQuery: MessageFns<SearchRequest_ImageQuery> = {
  encode(message: SearchRequest_ImageQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageBytes !== undefined) {
      writer.uint32(10).string(message.imageBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ImageQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ImageQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imageBytes = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ImageQuery {
    return { imageBytes: isSet(object.imageBytes) ? globalThis.String(object.imageBytes) : undefined };
  },

  toJSON(message: SearchRequest_ImageQuery): unknown {
    const obj: any = {};
    if (message.imageBytes !== undefined) {
      obj.imageBytes = message.imageBytes;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_ImageQuery>): SearchRequest_ImageQuery {
    return SearchRequest_ImageQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_ImageQuery>): SearchRequest_ImageQuery {
    const message = createBaseSearchRequest_ImageQuery();
    message.imageBytes = object.imageBytes ?? undefined;
    return message;
  },
};

function createBaseSearchRequest_DataStoreSpec(): SearchRequest_DataStoreSpec {
  return { dataStore: "" };
}

export const SearchRequest_DataStoreSpec: MessageFns<SearchRequest_DataStoreSpec> = {
  encode(message: SearchRequest_DataStoreSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataStore !== "") {
      writer.uint32(10).string(message.dataStore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_DataStoreSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_DataStoreSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataStore = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_DataStoreSpec {
    return { dataStore: isSet(object.dataStore) ? globalThis.String(object.dataStore) : "" };
  },

  toJSON(message: SearchRequest_DataStoreSpec): unknown {
    const obj: any = {};
    if (message.dataStore !== "") {
      obj.dataStore = message.dataStore;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_DataStoreSpec>): SearchRequest_DataStoreSpec {
    return SearchRequest_DataStoreSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_DataStoreSpec>): SearchRequest_DataStoreSpec {
    const message = createBaseSearchRequest_DataStoreSpec();
    message.dataStore = object.dataStore ?? "";
    return message;
  },
};

function createBaseSearchRequest_FacetSpec(): SearchRequest_FacetSpec {
  return { facetKey: undefined, limit: 0, excludedFilterKeys: [], enableDynamicPosition: false };
}

export const SearchRequest_FacetSpec: MessageFns<SearchRequest_FacetSpec> = {
  encode(message: SearchRequest_FacetSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.facetKey !== undefined) {
      SearchRequest_FacetSpec_FacetKey.encode(message.facetKey, writer.uint32(10).fork()).join();
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    for (const v of message.excludedFilterKeys) {
      writer.uint32(26).string(v!);
    }
    if (message.enableDynamicPosition !== false) {
      writer.uint32(32).bool(message.enableDynamicPosition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_FacetSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_FacetSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.facetKey = SearchRequest_FacetSpec_FacetKey.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.excludedFilterKeys.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enableDynamicPosition = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_FacetSpec {
    return {
      facetKey: isSet(object.facetKey) ? SearchRequest_FacetSpec_FacetKey.fromJSON(object.facetKey) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      excludedFilterKeys: globalThis.Array.isArray(object?.excludedFilterKeys)
        ? object.excludedFilterKeys.map((e: any) => globalThis.String(e))
        : [],
      enableDynamicPosition: isSet(object.enableDynamicPosition)
        ? globalThis.Boolean(object.enableDynamicPosition)
        : false,
    };
  },

  toJSON(message: SearchRequest_FacetSpec): unknown {
    const obj: any = {};
    if (message.facetKey !== undefined) {
      obj.facetKey = SearchRequest_FacetSpec_FacetKey.toJSON(message.facetKey);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.excludedFilterKeys?.length) {
      obj.excludedFilterKeys = message.excludedFilterKeys;
    }
    if (message.enableDynamicPosition !== false) {
      obj.enableDynamicPosition = message.enableDynamicPosition;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_FacetSpec>): SearchRequest_FacetSpec {
    return SearchRequest_FacetSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_FacetSpec>): SearchRequest_FacetSpec {
    const message = createBaseSearchRequest_FacetSpec();
    message.facetKey = (object.facetKey !== undefined && object.facetKey !== null)
      ? SearchRequest_FacetSpec_FacetKey.fromPartial(object.facetKey)
      : undefined;
    message.limit = object.limit ?? 0;
    message.excludedFilterKeys = object.excludedFilterKeys?.map((e) => e) || [];
    message.enableDynamicPosition = object.enableDynamicPosition ?? false;
    return message;
  },
};

function createBaseSearchRequest_FacetSpec_FacetKey(): SearchRequest_FacetSpec_FacetKey {
  return {
    key: "",
    intervals: [],
    restrictedValues: [],
    prefixes: [],
    contains: [],
    caseInsensitive: false,
    orderBy: "",
  };
}

export const SearchRequest_FacetSpec_FacetKey: MessageFns<SearchRequest_FacetSpec_FacetKey> = {
  encode(message: SearchRequest_FacetSpec_FacetKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    for (const v of message.intervals) {
      Interval.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.restrictedValues) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.prefixes) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.contains) {
      writer.uint32(42).string(v!);
    }
    if (message.caseInsensitive !== false) {
      writer.uint32(48).bool(message.caseInsensitive);
    }
    if (message.orderBy !== "") {
      writer.uint32(58).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_FacetSpec_FacetKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_FacetSpec_FacetKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.intervals.push(Interval.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.restrictedValues.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.prefixes.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contains.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.caseInsensitive = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_FacetSpec_FacetKey {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      intervals: globalThis.Array.isArray(object?.intervals)
        ? object.intervals.map((e: any) => Interval.fromJSON(e))
        : [],
      restrictedValues: globalThis.Array.isArray(object?.restrictedValues)
        ? object.restrictedValues.map((e: any) => globalThis.String(e))
        : [],
      prefixes: globalThis.Array.isArray(object?.prefixes) ? object.prefixes.map((e: any) => globalThis.String(e)) : [],
      contains: globalThis.Array.isArray(object?.contains) ? object.contains.map((e: any) => globalThis.String(e)) : [],
      caseInsensitive: isSet(object.caseInsensitive) ? globalThis.Boolean(object.caseInsensitive) : false,
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: SearchRequest_FacetSpec_FacetKey): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.intervals?.length) {
      obj.intervals = message.intervals.map((e) => Interval.toJSON(e));
    }
    if (message.restrictedValues?.length) {
      obj.restrictedValues = message.restrictedValues;
    }
    if (message.prefixes?.length) {
      obj.prefixes = message.prefixes;
    }
    if (message.contains?.length) {
      obj.contains = message.contains;
    }
    if (message.caseInsensitive !== false) {
      obj.caseInsensitive = message.caseInsensitive;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_FacetSpec_FacetKey>): SearchRequest_FacetSpec_FacetKey {
    return SearchRequest_FacetSpec_FacetKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_FacetSpec_FacetKey>): SearchRequest_FacetSpec_FacetKey {
    const message = createBaseSearchRequest_FacetSpec_FacetKey();
    message.key = object.key ?? "";
    message.intervals = object.intervals?.map((e) => Interval.fromPartial(e)) || [];
    message.restrictedValues = object.restrictedValues?.map((e) => e) || [];
    message.prefixes = object.prefixes?.map((e) => e) || [];
    message.contains = object.contains?.map((e) => e) || [];
    message.caseInsensitive = object.caseInsensitive ?? false;
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseSearchRequest_BoostSpec(): SearchRequest_BoostSpec {
  return { conditionBoostSpecs: [] };
}

export const SearchRequest_BoostSpec: MessageFns<SearchRequest_BoostSpec> = {
  encode(message: SearchRequest_BoostSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conditionBoostSpecs) {
      SearchRequest_BoostSpec_ConditionBoostSpec.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_BoostSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_BoostSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conditionBoostSpecs.push(SearchRequest_BoostSpec_ConditionBoostSpec.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_BoostSpec {
    return {
      conditionBoostSpecs: globalThis.Array.isArray(object?.conditionBoostSpecs)
        ? object.conditionBoostSpecs.map((e: any) => SearchRequest_BoostSpec_ConditionBoostSpec.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchRequest_BoostSpec): unknown {
    const obj: any = {};
    if (message.conditionBoostSpecs?.length) {
      obj.conditionBoostSpecs = message.conditionBoostSpecs.map((e) =>
        SearchRequest_BoostSpec_ConditionBoostSpec.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_BoostSpec>): SearchRequest_BoostSpec {
    return SearchRequest_BoostSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_BoostSpec>): SearchRequest_BoostSpec {
    const message = createBaseSearchRequest_BoostSpec();
    message.conditionBoostSpecs =
      object.conditionBoostSpecs?.map((e) => SearchRequest_BoostSpec_ConditionBoostSpec.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchRequest_BoostSpec_ConditionBoostSpec(): SearchRequest_BoostSpec_ConditionBoostSpec {
  return { condition: "", boost: 0, boostControlSpec: undefined };
}

export const SearchRequest_BoostSpec_ConditionBoostSpec: MessageFns<SearchRequest_BoostSpec_ConditionBoostSpec> = {
  encode(message: SearchRequest_BoostSpec_ConditionBoostSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condition !== "") {
      writer.uint32(10).string(message.condition);
    }
    if (message.boost !== 0) {
      writer.uint32(21).float(message.boost);
    }
    if (message.boostControlSpec !== undefined) {
      SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec.encode(
        message.boostControlSpec,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_BoostSpec_ConditionBoostSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_BoostSpec_ConditionBoostSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.boost = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.boostControlSpec = SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_BoostSpec_ConditionBoostSpec {
    return {
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      boost: isSet(object.boost) ? globalThis.Number(object.boost) : 0,
      boostControlSpec: isSet(object.boostControlSpec)
        ? SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec.fromJSON(object.boostControlSpec)
        : undefined,
    };
  },

  toJSON(message: SearchRequest_BoostSpec_ConditionBoostSpec): unknown {
    const obj: any = {};
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.boost !== 0) {
      obj.boost = message.boost;
    }
    if (message.boostControlSpec !== undefined) {
      obj.boostControlSpec = SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec.toJSON(
        message.boostControlSpec,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_BoostSpec_ConditionBoostSpec>): SearchRequest_BoostSpec_ConditionBoostSpec {
    return SearchRequest_BoostSpec_ConditionBoostSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_BoostSpec_ConditionBoostSpec>,
  ): SearchRequest_BoostSpec_ConditionBoostSpec {
    const message = createBaseSearchRequest_BoostSpec_ConditionBoostSpec();
    message.condition = object.condition ?? "";
    message.boost = object.boost ?? 0;
    message.boostControlSpec = (object.boostControlSpec !== undefined && object.boostControlSpec !== null)
      ? SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec.fromPartial(object.boostControlSpec)
      : undefined;
    return message;
  },
};

function createBaseSearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec(): SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec {
  return { fieldName: "", attributeType: 0, interpolationType: 0, controlPoints: [] };
}

export const SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec: MessageFns<
  SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec
> = {
  encode(
    message: SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.fieldName !== "") {
      writer.uint32(10).string(message.fieldName);
    }
    if (message.attributeType !== 0) {
      writer.uint32(16).int32(message.attributeType);
    }
    if (message.interpolationType !== 0) {
      writer.uint32(24).int32(message.interpolationType);
    }
    for (const v of message.controlPoints) {
      SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint.encode(v!, writer.uint32(34).fork())
        .join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.attributeType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.interpolationType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.controlPoints.push(
            SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec {
    return {
      fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
      attributeType: isSet(object.attributeType)
        ? searchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeTypeFromJSON(object.attributeType)
        : 0,
      interpolationType: isSet(object.interpolationType)
        ? searchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationTypeFromJSON(
          object.interpolationType,
        )
        : 0,
      controlPoints: globalThis.Array.isArray(object?.controlPoints)
        ? object.controlPoints.map((e: any) =>
          SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec): unknown {
    const obj: any = {};
    if (message.fieldName !== "") {
      obj.fieldName = message.fieldName;
    }
    if (message.attributeType !== 0) {
      obj.attributeType = searchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_AttributeTypeToJSON(
        message.attributeType,
      );
    }
    if (message.interpolationType !== 0) {
      obj.interpolationType = searchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_InterpolationTypeToJSON(
        message.interpolationType,
      );
    }
    if (message.controlPoints?.length) {
      obj.controlPoints = message.controlPoints.map((e) =>
        SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec>,
  ): SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec {
    return SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec>,
  ): SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec {
    const message = createBaseSearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec();
    message.fieldName = object.fieldName ?? "";
    message.attributeType = object.attributeType ?? 0;
    message.interpolationType = object.interpolationType ?? 0;
    message.controlPoints =
      object.controlPoints?.map((e) =>
        SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseSearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint(): SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint {
  return { attributeValue: "", boostAmount: 0 };
}

export const SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint: MessageFns<
  SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint
> = {
  encode(
    message: SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.attributeValue !== "") {
      writer.uint32(10).string(message.attributeValue);
    }
    if (message.boostAmount !== 0) {
      writer.uint32(21).float(message.boostAmount);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeValue = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.boostAmount = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint {
    return {
      attributeValue: isSet(object.attributeValue) ? globalThis.String(object.attributeValue) : "",
      boostAmount: isSet(object.boostAmount) ? globalThis.Number(object.boostAmount) : 0,
    };
  },

  toJSON(message: SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint): unknown {
    const obj: any = {};
    if (message.attributeValue !== "") {
      obj.attributeValue = message.attributeValue;
    }
    if (message.boostAmount !== 0) {
      obj.boostAmount = message.boostAmount;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint>,
  ): SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint {
    return SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint>,
  ): SearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint {
    const message = createBaseSearchRequest_BoostSpec_ConditionBoostSpec_BoostControlSpec_ControlPoint();
    message.attributeValue = object.attributeValue ?? "";
    message.boostAmount = object.boostAmount ?? 0;
    return message;
  },
};

function createBaseSearchRequest_QueryExpansionSpec(): SearchRequest_QueryExpansionSpec {
  return { condition: 0, pinUnexpandedResults: false };
}

export const SearchRequest_QueryExpansionSpec: MessageFns<SearchRequest_QueryExpansionSpec> = {
  encode(message: SearchRequest_QueryExpansionSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condition !== 0) {
      writer.uint32(8).int32(message.condition);
    }
    if (message.pinUnexpandedResults !== false) {
      writer.uint32(16).bool(message.pinUnexpandedResults);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_QueryExpansionSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_QueryExpansionSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.condition = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pinUnexpandedResults = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_QueryExpansionSpec {
    return {
      condition: isSet(object.condition) ? searchRequest_QueryExpansionSpec_ConditionFromJSON(object.condition) : 0,
      pinUnexpandedResults: isSet(object.pinUnexpandedResults)
        ? globalThis.Boolean(object.pinUnexpandedResults)
        : false,
    };
  },

  toJSON(message: SearchRequest_QueryExpansionSpec): unknown {
    const obj: any = {};
    if (message.condition !== 0) {
      obj.condition = searchRequest_QueryExpansionSpec_ConditionToJSON(message.condition);
    }
    if (message.pinUnexpandedResults !== false) {
      obj.pinUnexpandedResults = message.pinUnexpandedResults;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_QueryExpansionSpec>): SearchRequest_QueryExpansionSpec {
    return SearchRequest_QueryExpansionSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_QueryExpansionSpec>): SearchRequest_QueryExpansionSpec {
    const message = createBaseSearchRequest_QueryExpansionSpec();
    message.condition = object.condition ?? 0;
    message.pinUnexpandedResults = object.pinUnexpandedResults ?? false;
    return message;
  },
};

function createBaseSearchRequest_SpellCorrectionSpec(): SearchRequest_SpellCorrectionSpec {
  return { mode: 0 };
}

export const SearchRequest_SpellCorrectionSpec: MessageFns<SearchRequest_SpellCorrectionSpec> = {
  encode(message: SearchRequest_SpellCorrectionSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_SpellCorrectionSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_SpellCorrectionSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_SpellCorrectionSpec {
    return { mode: isSet(object.mode) ? searchRequest_SpellCorrectionSpec_ModeFromJSON(object.mode) : 0 };
  },

  toJSON(message: SearchRequest_SpellCorrectionSpec): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = searchRequest_SpellCorrectionSpec_ModeToJSON(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_SpellCorrectionSpec>): SearchRequest_SpellCorrectionSpec {
    return SearchRequest_SpellCorrectionSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_SpellCorrectionSpec>): SearchRequest_SpellCorrectionSpec {
    const message = createBaseSearchRequest_SpellCorrectionSpec();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec(): SearchRequest_ContentSearchSpec {
  return {
    snippetSpec: undefined,
    summarySpec: undefined,
    extractiveContentSpec: undefined,
    searchResultMode: 0,
    chunkSpec: undefined,
  };
}

export const SearchRequest_ContentSearchSpec: MessageFns<SearchRequest_ContentSearchSpec> = {
  encode(message: SearchRequest_ContentSearchSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.snippetSpec !== undefined) {
      SearchRequest_ContentSearchSpec_SnippetSpec.encode(message.snippetSpec, writer.uint32(10).fork()).join();
    }
    if (message.summarySpec !== undefined) {
      SearchRequest_ContentSearchSpec_SummarySpec.encode(message.summarySpec, writer.uint32(18).fork()).join();
    }
    if (message.extractiveContentSpec !== undefined) {
      SearchRequest_ContentSearchSpec_ExtractiveContentSpec.encode(
        message.extractiveContentSpec,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.searchResultMode !== 0) {
      writer.uint32(32).int32(message.searchResultMode);
    }
    if (message.chunkSpec !== undefined) {
      SearchRequest_ContentSearchSpec_ChunkSpec.encode(message.chunkSpec, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ContentSearchSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.snippetSpec = SearchRequest_ContentSearchSpec_SnippetSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.summarySpec = SearchRequest_ContentSearchSpec_SummarySpec.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.extractiveContentSpec = SearchRequest_ContentSearchSpec_ExtractiveContentSpec.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.searchResultMode = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.chunkSpec = SearchRequest_ContentSearchSpec_ChunkSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec {
    return {
      snippetSpec: isSet(object.snippetSpec)
        ? SearchRequest_ContentSearchSpec_SnippetSpec.fromJSON(object.snippetSpec)
        : undefined,
      summarySpec: isSet(object.summarySpec)
        ? SearchRequest_ContentSearchSpec_SummarySpec.fromJSON(object.summarySpec)
        : undefined,
      extractiveContentSpec: isSet(object.extractiveContentSpec)
        ? SearchRequest_ContentSearchSpec_ExtractiveContentSpec.fromJSON(object.extractiveContentSpec)
        : undefined,
      searchResultMode: isSet(object.searchResultMode)
        ? searchRequest_ContentSearchSpec_SearchResultModeFromJSON(object.searchResultMode)
        : 0,
      chunkSpec: isSet(object.chunkSpec)
        ? SearchRequest_ContentSearchSpec_ChunkSpec.fromJSON(object.chunkSpec)
        : undefined,
    };
  },

  toJSON(message: SearchRequest_ContentSearchSpec): unknown {
    const obj: any = {};
    if (message.snippetSpec !== undefined) {
      obj.snippetSpec = SearchRequest_ContentSearchSpec_SnippetSpec.toJSON(message.snippetSpec);
    }
    if (message.summarySpec !== undefined) {
      obj.summarySpec = SearchRequest_ContentSearchSpec_SummarySpec.toJSON(message.summarySpec);
    }
    if (message.extractiveContentSpec !== undefined) {
      obj.extractiveContentSpec = SearchRequest_ContentSearchSpec_ExtractiveContentSpec.toJSON(
        message.extractiveContentSpec,
      );
    }
    if (message.searchResultMode !== 0) {
      obj.searchResultMode = searchRequest_ContentSearchSpec_SearchResultModeToJSON(message.searchResultMode);
    }
    if (message.chunkSpec !== undefined) {
      obj.chunkSpec = SearchRequest_ContentSearchSpec_ChunkSpec.toJSON(message.chunkSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_ContentSearchSpec>): SearchRequest_ContentSearchSpec {
    return SearchRequest_ContentSearchSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_ContentSearchSpec>): SearchRequest_ContentSearchSpec {
    const message = createBaseSearchRequest_ContentSearchSpec();
    message.snippetSpec = (object.snippetSpec !== undefined && object.snippetSpec !== null)
      ? SearchRequest_ContentSearchSpec_SnippetSpec.fromPartial(object.snippetSpec)
      : undefined;
    message.summarySpec = (object.summarySpec !== undefined && object.summarySpec !== null)
      ? SearchRequest_ContentSearchSpec_SummarySpec.fromPartial(object.summarySpec)
      : undefined;
    message.extractiveContentSpec =
      (object.extractiveContentSpec !== undefined && object.extractiveContentSpec !== null)
        ? SearchRequest_ContentSearchSpec_ExtractiveContentSpec.fromPartial(object.extractiveContentSpec)
        : undefined;
    message.searchResultMode = object.searchResultMode ?? 0;
    message.chunkSpec = (object.chunkSpec !== undefined && object.chunkSpec !== null)
      ? SearchRequest_ContentSearchSpec_ChunkSpec.fromPartial(object.chunkSpec)
      : undefined;
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec_SnippetSpec(): SearchRequest_ContentSearchSpec_SnippetSpec {
  return { maxSnippetCount: 0, referenceOnly: false, returnSnippet: false };
}

export const SearchRequest_ContentSearchSpec_SnippetSpec: MessageFns<SearchRequest_ContentSearchSpec_SnippetSpec> = {
  encode(
    message: SearchRequest_ContentSearchSpec_SnippetSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.maxSnippetCount !== 0) {
      writer.uint32(8).int32(message.maxSnippetCount);
    }
    if (message.referenceOnly !== false) {
      writer.uint32(16).bool(message.referenceOnly);
    }
    if (message.returnSnippet !== false) {
      writer.uint32(24).bool(message.returnSnippet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ContentSearchSpec_SnippetSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec_SnippetSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxSnippetCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.referenceOnly = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.returnSnippet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec_SnippetSpec {
    return {
      maxSnippetCount: isSet(object.maxSnippetCount) ? globalThis.Number(object.maxSnippetCount) : 0,
      referenceOnly: isSet(object.referenceOnly) ? globalThis.Boolean(object.referenceOnly) : false,
      returnSnippet: isSet(object.returnSnippet) ? globalThis.Boolean(object.returnSnippet) : false,
    };
  },

  toJSON(message: SearchRequest_ContentSearchSpec_SnippetSpec): unknown {
    const obj: any = {};
    if (message.maxSnippetCount !== 0) {
      obj.maxSnippetCount = Math.round(message.maxSnippetCount);
    }
    if (message.referenceOnly !== false) {
      obj.referenceOnly = message.referenceOnly;
    }
    if (message.returnSnippet !== false) {
      obj.returnSnippet = message.returnSnippet;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_ContentSearchSpec_SnippetSpec>): SearchRequest_ContentSearchSpec_SnippetSpec {
    return SearchRequest_ContentSearchSpec_SnippetSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_ContentSearchSpec_SnippetSpec>,
  ): SearchRequest_ContentSearchSpec_SnippetSpec {
    const message = createBaseSearchRequest_ContentSearchSpec_SnippetSpec();
    message.maxSnippetCount = object.maxSnippetCount ?? 0;
    message.referenceOnly = object.referenceOnly ?? false;
    message.returnSnippet = object.returnSnippet ?? false;
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec_SummarySpec(): SearchRequest_ContentSearchSpec_SummarySpec {
  return {
    summaryResultCount: 0,
    includeCitations: false,
    ignoreAdversarialQuery: false,
    ignoreNonSummarySeekingQuery: false,
    ignoreLowRelevantContent: false,
    modelPromptSpec: undefined,
    languageCode: "",
    modelSpec: undefined,
    useSemanticChunks: false,
  };
}

export const SearchRequest_ContentSearchSpec_SummarySpec: MessageFns<SearchRequest_ContentSearchSpec_SummarySpec> = {
  encode(
    message: SearchRequest_ContentSearchSpec_SummarySpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.summaryResultCount !== 0) {
      writer.uint32(8).int32(message.summaryResultCount);
    }
    if (message.includeCitations !== false) {
      writer.uint32(16).bool(message.includeCitations);
    }
    if (message.ignoreAdversarialQuery !== false) {
      writer.uint32(24).bool(message.ignoreAdversarialQuery);
    }
    if (message.ignoreNonSummarySeekingQuery !== false) {
      writer.uint32(32).bool(message.ignoreNonSummarySeekingQuery);
    }
    if (message.ignoreLowRelevantContent !== false) {
      writer.uint32(72).bool(message.ignoreLowRelevantContent);
    }
    if (message.modelPromptSpec !== undefined) {
      SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec.encode(
        message.modelPromptSpec,
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(50).string(message.languageCode);
    }
    if (message.modelSpec !== undefined) {
      SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec.encode(message.modelSpec, writer.uint32(58).fork()).join();
    }
    if (message.useSemanticChunks !== false) {
      writer.uint32(64).bool(message.useSemanticChunks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ContentSearchSpec_SummarySpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec_SummarySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.summaryResultCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeCitations = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ignoreAdversarialQuery = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ignoreNonSummarySeekingQuery = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.ignoreLowRelevantContent = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.modelPromptSpec = SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.modelSpec = SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.useSemanticChunks = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec_SummarySpec {
    return {
      summaryResultCount: isSet(object.summaryResultCount) ? globalThis.Number(object.summaryResultCount) : 0,
      includeCitations: isSet(object.includeCitations) ? globalThis.Boolean(object.includeCitations) : false,
      ignoreAdversarialQuery: isSet(object.ignoreAdversarialQuery)
        ? globalThis.Boolean(object.ignoreAdversarialQuery)
        : false,
      ignoreNonSummarySeekingQuery: isSet(object.ignoreNonSummarySeekingQuery)
        ? globalThis.Boolean(object.ignoreNonSummarySeekingQuery)
        : false,
      ignoreLowRelevantContent: isSet(object.ignoreLowRelevantContent)
        ? globalThis.Boolean(object.ignoreLowRelevantContent)
        : false,
      modelPromptSpec: isSet(object.modelPromptSpec)
        ? SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec.fromJSON(object.modelPromptSpec)
        : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      modelSpec: isSet(object.modelSpec)
        ? SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec.fromJSON(object.modelSpec)
        : undefined,
      useSemanticChunks: isSet(object.useSemanticChunks) ? globalThis.Boolean(object.useSemanticChunks) : false,
    };
  },

  toJSON(message: SearchRequest_ContentSearchSpec_SummarySpec): unknown {
    const obj: any = {};
    if (message.summaryResultCount !== 0) {
      obj.summaryResultCount = Math.round(message.summaryResultCount);
    }
    if (message.includeCitations !== false) {
      obj.includeCitations = message.includeCitations;
    }
    if (message.ignoreAdversarialQuery !== false) {
      obj.ignoreAdversarialQuery = message.ignoreAdversarialQuery;
    }
    if (message.ignoreNonSummarySeekingQuery !== false) {
      obj.ignoreNonSummarySeekingQuery = message.ignoreNonSummarySeekingQuery;
    }
    if (message.ignoreLowRelevantContent !== false) {
      obj.ignoreLowRelevantContent = message.ignoreLowRelevantContent;
    }
    if (message.modelPromptSpec !== undefined) {
      obj.modelPromptSpec = SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec.toJSON(message.modelPromptSpec);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.modelSpec !== undefined) {
      obj.modelSpec = SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec.toJSON(message.modelSpec);
    }
    if (message.useSemanticChunks !== false) {
      obj.useSemanticChunks = message.useSemanticChunks;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_ContentSearchSpec_SummarySpec>): SearchRequest_ContentSearchSpec_SummarySpec {
    return SearchRequest_ContentSearchSpec_SummarySpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_ContentSearchSpec_SummarySpec>,
  ): SearchRequest_ContentSearchSpec_SummarySpec {
    const message = createBaseSearchRequest_ContentSearchSpec_SummarySpec();
    message.summaryResultCount = object.summaryResultCount ?? 0;
    message.includeCitations = object.includeCitations ?? false;
    message.ignoreAdversarialQuery = object.ignoreAdversarialQuery ?? false;
    message.ignoreNonSummarySeekingQuery = object.ignoreNonSummarySeekingQuery ?? false;
    message.ignoreLowRelevantContent = object.ignoreLowRelevantContent ?? false;
    message.modelPromptSpec = (object.modelPromptSpec !== undefined && object.modelPromptSpec !== null)
      ? SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec.fromPartial(object.modelPromptSpec)
      : undefined;
    message.languageCode = object.languageCode ?? "";
    message.modelSpec = (object.modelSpec !== undefined && object.modelSpec !== null)
      ? SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec.fromPartial(object.modelSpec)
      : undefined;
    message.useSemanticChunks = object.useSemanticChunks ?? false;
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec(): SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec {
  return { preamble: "" };
}

export const SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec: MessageFns<
  SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec
> = {
  encode(
    message: SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.preamble !== "") {
      writer.uint32(10).string(message.preamble);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.preamble = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec {
    return { preamble: isSet(object.preamble) ? globalThis.String(object.preamble) : "" };
  },

  toJSON(message: SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec): unknown {
    const obj: any = {};
    if (message.preamble !== "") {
      obj.preamble = message.preamble;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec>,
  ): SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec {
    return SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec>,
  ): SearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec {
    const message = createBaseSearchRequest_ContentSearchSpec_SummarySpec_ModelPromptSpec();
    message.preamble = object.preamble ?? "";
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec_SummarySpec_ModelSpec(): SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec {
  return { version: "" };
}

export const SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec: MessageFns<
  SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec
> = {
  encode(
    message: SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec_SummarySpec_ModelSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
  },

  toJSON(message: SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec>,
  ): SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec {
    return SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec>,
  ): SearchRequest_ContentSearchSpec_SummarySpec_ModelSpec {
    const message = createBaseSearchRequest_ContentSearchSpec_SummarySpec_ModelSpec();
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec_ExtractiveContentSpec(): SearchRequest_ContentSearchSpec_ExtractiveContentSpec {
  return {
    maxExtractiveAnswerCount: 0,
    maxExtractiveSegmentCount: 0,
    returnExtractiveSegmentScore: false,
    numPreviousSegments: 0,
    numNextSegments: 0,
  };
}

export const SearchRequest_ContentSearchSpec_ExtractiveContentSpec: MessageFns<
  SearchRequest_ContentSearchSpec_ExtractiveContentSpec
> = {
  encode(
    message: SearchRequest_ContentSearchSpec_ExtractiveContentSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.maxExtractiveAnswerCount !== 0) {
      writer.uint32(8).int32(message.maxExtractiveAnswerCount);
    }
    if (message.maxExtractiveSegmentCount !== 0) {
      writer.uint32(16).int32(message.maxExtractiveSegmentCount);
    }
    if (message.returnExtractiveSegmentScore !== false) {
      writer.uint32(24).bool(message.returnExtractiveSegmentScore);
    }
    if (message.numPreviousSegments !== 0) {
      writer.uint32(32).int32(message.numPreviousSegments);
    }
    if (message.numNextSegments !== 0) {
      writer.uint32(40).int32(message.numNextSegments);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ContentSearchSpec_ExtractiveContentSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec_ExtractiveContentSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxExtractiveAnswerCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxExtractiveSegmentCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.returnExtractiveSegmentScore = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.numPreviousSegments = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.numNextSegments = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec_ExtractiveContentSpec {
    return {
      maxExtractiveAnswerCount: isSet(object.maxExtractiveAnswerCount)
        ? globalThis.Number(object.maxExtractiveAnswerCount)
        : 0,
      maxExtractiveSegmentCount: isSet(object.maxExtractiveSegmentCount)
        ? globalThis.Number(object.maxExtractiveSegmentCount)
        : 0,
      returnExtractiveSegmentScore: isSet(object.returnExtractiveSegmentScore)
        ? globalThis.Boolean(object.returnExtractiveSegmentScore)
        : false,
      numPreviousSegments: isSet(object.numPreviousSegments) ? globalThis.Number(object.numPreviousSegments) : 0,
      numNextSegments: isSet(object.numNextSegments) ? globalThis.Number(object.numNextSegments) : 0,
    };
  },

  toJSON(message: SearchRequest_ContentSearchSpec_ExtractiveContentSpec): unknown {
    const obj: any = {};
    if (message.maxExtractiveAnswerCount !== 0) {
      obj.maxExtractiveAnswerCount = Math.round(message.maxExtractiveAnswerCount);
    }
    if (message.maxExtractiveSegmentCount !== 0) {
      obj.maxExtractiveSegmentCount = Math.round(message.maxExtractiveSegmentCount);
    }
    if (message.returnExtractiveSegmentScore !== false) {
      obj.returnExtractiveSegmentScore = message.returnExtractiveSegmentScore;
    }
    if (message.numPreviousSegments !== 0) {
      obj.numPreviousSegments = Math.round(message.numPreviousSegments);
    }
    if (message.numNextSegments !== 0) {
      obj.numNextSegments = Math.round(message.numNextSegments);
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchRequest_ContentSearchSpec_ExtractiveContentSpec>,
  ): SearchRequest_ContentSearchSpec_ExtractiveContentSpec {
    return SearchRequest_ContentSearchSpec_ExtractiveContentSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_ContentSearchSpec_ExtractiveContentSpec>,
  ): SearchRequest_ContentSearchSpec_ExtractiveContentSpec {
    const message = createBaseSearchRequest_ContentSearchSpec_ExtractiveContentSpec();
    message.maxExtractiveAnswerCount = object.maxExtractiveAnswerCount ?? 0;
    message.maxExtractiveSegmentCount = object.maxExtractiveSegmentCount ?? 0;
    message.returnExtractiveSegmentScore = object.returnExtractiveSegmentScore ?? false;
    message.numPreviousSegments = object.numPreviousSegments ?? 0;
    message.numNextSegments = object.numNextSegments ?? 0;
    return message;
  },
};

function createBaseSearchRequest_ContentSearchSpec_ChunkSpec(): SearchRequest_ContentSearchSpec_ChunkSpec {
  return { numPreviousChunks: 0, numNextChunks: 0 };
}

export const SearchRequest_ContentSearchSpec_ChunkSpec: MessageFns<SearchRequest_ContentSearchSpec_ChunkSpec> = {
  encode(message: SearchRequest_ContentSearchSpec_ChunkSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numPreviousChunks !== 0) {
      writer.uint32(8).int32(message.numPreviousChunks);
    }
    if (message.numNextChunks !== 0) {
      writer.uint32(16).int32(message.numNextChunks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ContentSearchSpec_ChunkSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ContentSearchSpec_ChunkSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.numPreviousChunks = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numNextChunks = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ContentSearchSpec_ChunkSpec {
    return {
      numPreviousChunks: isSet(object.numPreviousChunks) ? globalThis.Number(object.numPreviousChunks) : 0,
      numNextChunks: isSet(object.numNextChunks) ? globalThis.Number(object.numNextChunks) : 0,
    };
  },

  toJSON(message: SearchRequest_ContentSearchSpec_ChunkSpec): unknown {
    const obj: any = {};
    if (message.numPreviousChunks !== 0) {
      obj.numPreviousChunks = Math.round(message.numPreviousChunks);
    }
    if (message.numNextChunks !== 0) {
      obj.numNextChunks = Math.round(message.numNextChunks);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_ContentSearchSpec_ChunkSpec>): SearchRequest_ContentSearchSpec_ChunkSpec {
    return SearchRequest_ContentSearchSpec_ChunkSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_ContentSearchSpec_ChunkSpec>,
  ): SearchRequest_ContentSearchSpec_ChunkSpec {
    const message = createBaseSearchRequest_ContentSearchSpec_ChunkSpec();
    message.numPreviousChunks = object.numPreviousChunks ?? 0;
    message.numNextChunks = object.numNextChunks ?? 0;
    return message;
  },
};

function createBaseSearchRequest_EmbeddingSpec(): SearchRequest_EmbeddingSpec {
  return { embeddingVectors: [] };
}

export const SearchRequest_EmbeddingSpec: MessageFns<SearchRequest_EmbeddingSpec> = {
  encode(message: SearchRequest_EmbeddingSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.embeddingVectors) {
      SearchRequest_EmbeddingSpec_EmbeddingVector.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_EmbeddingSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_EmbeddingSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.embeddingVectors.push(SearchRequest_EmbeddingSpec_EmbeddingVector.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_EmbeddingSpec {
    return {
      embeddingVectors: globalThis.Array.isArray(object?.embeddingVectors)
        ? object.embeddingVectors.map((e: any) => SearchRequest_EmbeddingSpec_EmbeddingVector.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchRequest_EmbeddingSpec): unknown {
    const obj: any = {};
    if (message.embeddingVectors?.length) {
      obj.embeddingVectors = message.embeddingVectors.map((e) => SearchRequest_EmbeddingSpec_EmbeddingVector.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_EmbeddingSpec>): SearchRequest_EmbeddingSpec {
    return SearchRequest_EmbeddingSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_EmbeddingSpec>): SearchRequest_EmbeddingSpec {
    const message = createBaseSearchRequest_EmbeddingSpec();
    message.embeddingVectors =
      object.embeddingVectors?.map((e) => SearchRequest_EmbeddingSpec_EmbeddingVector.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchRequest_EmbeddingSpec_EmbeddingVector(): SearchRequest_EmbeddingSpec_EmbeddingVector {
  return { fieldPath: "", vector: [] };
}

export const SearchRequest_EmbeddingSpec_EmbeddingVector: MessageFns<SearchRequest_EmbeddingSpec_EmbeddingVector> = {
  encode(
    message: SearchRequest_EmbeddingSpec_EmbeddingVector,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.fieldPath !== "") {
      writer.uint32(10).string(message.fieldPath);
    }
    writer.uint32(18).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_EmbeddingSpec_EmbeddingVector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_EmbeddingSpec_EmbeddingVector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldPath = reader.string();
          continue;
        case 2:
          if (tag === 21) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_EmbeddingSpec_EmbeddingVector {
    return {
      fieldPath: isSet(object.fieldPath) ? globalThis.String(object.fieldPath) : "",
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: SearchRequest_EmbeddingSpec_EmbeddingVector): unknown {
    const obj: any = {};
    if (message.fieldPath !== "") {
      obj.fieldPath = message.fieldPath;
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_EmbeddingSpec_EmbeddingVector>): SearchRequest_EmbeddingSpec_EmbeddingVector {
    return SearchRequest_EmbeddingSpec_EmbeddingVector.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_EmbeddingSpec_EmbeddingVector>,
  ): SearchRequest_EmbeddingSpec_EmbeddingVector {
    const message = createBaseSearchRequest_EmbeddingSpec_EmbeddingVector();
    message.fieldPath = object.fieldPath ?? "";
    message.vector = object.vector?.map((e) => e) || [];
    return message;
  },
};

function createBaseSearchRequest_NaturalLanguageQueryUnderstandingSpec(): SearchRequest_NaturalLanguageQueryUnderstandingSpec {
  return { filterExtractionCondition: 0, geoSearchQueryDetectionFieldNames: [] };
}

export const SearchRequest_NaturalLanguageQueryUnderstandingSpec: MessageFns<
  SearchRequest_NaturalLanguageQueryUnderstandingSpec
> = {
  encode(
    message: SearchRequest_NaturalLanguageQueryUnderstandingSpec,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.filterExtractionCondition !== 0) {
      writer.uint32(8).int32(message.filterExtractionCondition);
    }
    for (const v of message.geoSearchQueryDetectionFieldNames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_NaturalLanguageQueryUnderstandingSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_NaturalLanguageQueryUnderstandingSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.filterExtractionCondition = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.geoSearchQueryDetectionFieldNames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_NaturalLanguageQueryUnderstandingSpec {
    return {
      filterExtractionCondition: isSet(object.filterExtractionCondition)
        ? searchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionConditionFromJSON(
          object.filterExtractionCondition,
        )
        : 0,
      geoSearchQueryDetectionFieldNames: globalThis.Array.isArray(object?.geoSearchQueryDetectionFieldNames)
        ? object.geoSearchQueryDetectionFieldNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SearchRequest_NaturalLanguageQueryUnderstandingSpec): unknown {
    const obj: any = {};
    if (message.filterExtractionCondition !== 0) {
      obj.filterExtractionCondition =
        searchRequest_NaturalLanguageQueryUnderstandingSpec_FilterExtractionConditionToJSON(
          message.filterExtractionCondition,
        );
    }
    if (message.geoSearchQueryDetectionFieldNames?.length) {
      obj.geoSearchQueryDetectionFieldNames = message.geoSearchQueryDetectionFieldNames;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchRequest_NaturalLanguageQueryUnderstandingSpec>,
  ): SearchRequest_NaturalLanguageQueryUnderstandingSpec {
    return SearchRequest_NaturalLanguageQueryUnderstandingSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_NaturalLanguageQueryUnderstandingSpec>,
  ): SearchRequest_NaturalLanguageQueryUnderstandingSpec {
    const message = createBaseSearchRequest_NaturalLanguageQueryUnderstandingSpec();
    message.filterExtractionCondition = object.filterExtractionCondition ?? 0;
    message.geoSearchQueryDetectionFieldNames = object.geoSearchQueryDetectionFieldNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseSearchRequest_SearchAsYouTypeSpec(): SearchRequest_SearchAsYouTypeSpec {
  return { condition: 0 };
}

export const SearchRequest_SearchAsYouTypeSpec: MessageFns<SearchRequest_SearchAsYouTypeSpec> = {
  encode(message: SearchRequest_SearchAsYouTypeSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condition !== 0) {
      writer.uint32(8).int32(message.condition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_SearchAsYouTypeSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_SearchAsYouTypeSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.condition = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_SearchAsYouTypeSpec {
    return {
      condition: isSet(object.condition) ? searchRequest_SearchAsYouTypeSpec_ConditionFromJSON(object.condition) : 0,
    };
  },

  toJSON(message: SearchRequest_SearchAsYouTypeSpec): unknown {
    const obj: any = {};
    if (message.condition !== 0) {
      obj.condition = searchRequest_SearchAsYouTypeSpec_ConditionToJSON(message.condition);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_SearchAsYouTypeSpec>): SearchRequest_SearchAsYouTypeSpec {
    return SearchRequest_SearchAsYouTypeSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_SearchAsYouTypeSpec>): SearchRequest_SearchAsYouTypeSpec {
    const message = createBaseSearchRequest_SearchAsYouTypeSpec();
    message.condition = object.condition ?? 0;
    return message;
  },
};

function createBaseSearchRequest_SessionSpec(): SearchRequest_SessionSpec {
  return { queryId: "", searchResultPersistenceCount: undefined };
}

export const SearchRequest_SessionSpec: MessageFns<SearchRequest_SessionSpec> = {
  encode(message: SearchRequest_SessionSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryId !== "") {
      writer.uint32(10).string(message.queryId);
    }
    if (message.searchResultPersistenceCount !== undefined) {
      writer.uint32(16).int32(message.searchResultPersistenceCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_SessionSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_SessionSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.searchResultPersistenceCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_SessionSpec {
    return {
      queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "",
      searchResultPersistenceCount: isSet(object.searchResultPersistenceCount)
        ? globalThis.Number(object.searchResultPersistenceCount)
        : undefined,
    };
  },

  toJSON(message: SearchRequest_SessionSpec): unknown {
    const obj: any = {};
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    if (message.searchResultPersistenceCount !== undefined) {
      obj.searchResultPersistenceCount = Math.round(message.searchResultPersistenceCount);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_SessionSpec>): SearchRequest_SessionSpec {
    return SearchRequest_SessionSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_SessionSpec>): SearchRequest_SessionSpec {
    const message = createBaseSearchRequest_SessionSpec();
    message.queryId = object.queryId ?? "";
    message.searchResultPersistenceCount = object.searchResultPersistenceCount ?? undefined;
    return message;
  },
};

function createBaseSearchRequest_ParamsEntry(): SearchRequest_ParamsEntry {
  return { key: "", value: undefined };
}

export const SearchRequest_ParamsEntry: MessageFns<SearchRequest_ParamsEntry> = {
  encode(message: SearchRequest_ParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_ParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_ParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_ParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: SearchRequest_ParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_ParamsEntry>): SearchRequest_ParamsEntry {
    return SearchRequest_ParamsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_ParamsEntry>): SearchRequest_ParamsEntry {
    const message = createBaseSearchRequest_ParamsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseSearchRequest_UserLabelsEntry(): SearchRequest_UserLabelsEntry {
  return { key: "", value: "" };
}

export const SearchRequest_UserLabelsEntry: MessageFns<SearchRequest_UserLabelsEntry> = {
  encode(message: SearchRequest_UserLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_UserLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_UserLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_UserLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SearchRequest_UserLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_UserLabelsEntry>): SearchRequest_UserLabelsEntry {
    return SearchRequest_UserLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_UserLabelsEntry>): SearchRequest_UserLabelsEntry {
    const message = createBaseSearchRequest_UserLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSearchResponse(): SearchResponse {
  return {
    results: [],
    facets: [],
    guidedSearchResult: undefined,
    totalSize: 0,
    attributionToken: "",
    redirectUri: "",
    nextPageToken: "",
    correctedQuery: "",
    summary: undefined,
    appliedControls: [],
    geoSearchDebugInfo: [],
    queryExpansionInfo: undefined,
    naturalLanguageQueryUnderstandingInfo: undefined,
    sessionInfo: undefined,
    oneBoxResults: [],
  };
}

export const SearchResponse: MessageFns<SearchResponse> = {
  encode(message: SearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      SearchResponse_SearchResult.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.facets) {
      SearchResponse_Facet.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.guidedSearchResult !== undefined) {
      SearchResponse_GuidedSearchResult.encode(message.guidedSearchResult, writer.uint32(66).fork()).join();
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    if (message.attributionToken !== "") {
      writer.uint32(34).string(message.attributionToken);
    }
    if (message.redirectUri !== "") {
      writer.uint32(98).string(message.redirectUri);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(42).string(message.nextPageToken);
    }
    if (message.correctedQuery !== "") {
      writer.uint32(58).string(message.correctedQuery);
    }
    if (message.summary !== undefined) {
      SearchResponse_Summary.encode(message.summary, writer.uint32(74).fork()).join();
    }
    for (const v of message.appliedControls) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.geoSearchDebugInfo) {
      SearchResponse_GeoSearchDebugInfo.encode(v!, writer.uint32(130).fork()).join();
    }
    if (message.queryExpansionInfo !== undefined) {
      SearchResponse_QueryExpansionInfo.encode(message.queryExpansionInfo, writer.uint32(114).fork()).join();
    }
    if (message.naturalLanguageQueryUnderstandingInfo !== undefined) {
      SearchResponse_NaturalLanguageQueryUnderstandingInfo.encode(
        message.naturalLanguageQueryUnderstandingInfo,
        writer.uint32(122).fork(),
      ).join();
    }
    if (message.sessionInfo !== undefined) {
      SearchResponse_SessionInfo.encode(message.sessionInfo, writer.uint32(154).fork()).join();
    }
    for (const v of message.oneBoxResults) {
      SearchResponse_OneBoxResult.encode(v!, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(SearchResponse_SearchResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.facets.push(SearchResponse_Facet.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.guidedSearchResult = SearchResponse_GuidedSearchResult.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.attributionToken = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.correctedQuery = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.summary = SearchResponse_Summary.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.appliedControls.push(reader.string());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.geoSearchDebugInfo.push(SearchResponse_GeoSearchDebugInfo.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.queryExpansionInfo = SearchResponse_QueryExpansionInfo.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.naturalLanguageQueryUnderstandingInfo = SearchResponse_NaturalLanguageQueryUnderstandingInfo.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.sessionInfo = SearchResponse_SessionInfo.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.oneBoxResults.push(SearchResponse_OneBoxResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => SearchResponse_SearchResult.fromJSON(e))
        : [],
      facets: globalThis.Array.isArray(object?.facets)
        ? object.facets.map((e: any) => SearchResponse_Facet.fromJSON(e))
        : [],
      guidedSearchResult: isSet(object.guidedSearchResult)
        ? SearchResponse_GuidedSearchResult.fromJSON(object.guidedSearchResult)
        : undefined,
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
      attributionToken: isSet(object.attributionToken) ? globalThis.String(object.attributionToken) : "",
      redirectUri: isSet(object.redirectUri) ? globalThis.String(object.redirectUri) : "",
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      correctedQuery: isSet(object.correctedQuery) ? globalThis.String(object.correctedQuery) : "",
      summary: isSet(object.summary) ? SearchResponse_Summary.fromJSON(object.summary) : undefined,
      appliedControls: globalThis.Array.isArray(object?.appliedControls)
        ? object.appliedControls.map((e: any) => globalThis.String(e))
        : [],
      geoSearchDebugInfo: globalThis.Array.isArray(object?.geoSearchDebugInfo)
        ? object.geoSearchDebugInfo.map((e: any) => SearchResponse_GeoSearchDebugInfo.fromJSON(e))
        : [],
      queryExpansionInfo: isSet(object.queryExpansionInfo)
        ? SearchResponse_QueryExpansionInfo.fromJSON(object.queryExpansionInfo)
        : undefined,
      naturalLanguageQueryUnderstandingInfo: isSet(object.naturalLanguageQueryUnderstandingInfo)
        ? SearchResponse_NaturalLanguageQueryUnderstandingInfo.fromJSON(object.naturalLanguageQueryUnderstandingInfo)
        : undefined,
      sessionInfo: isSet(object.sessionInfo) ? SearchResponse_SessionInfo.fromJSON(object.sessionInfo) : undefined,
      oneBoxResults: globalThis.Array.isArray(object?.oneBoxResults)
        ? object.oneBoxResults.map((e: any) => SearchResponse_OneBoxResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => SearchResponse_SearchResult.toJSON(e));
    }
    if (message.facets?.length) {
      obj.facets = message.facets.map((e) => SearchResponse_Facet.toJSON(e));
    }
    if (message.guidedSearchResult !== undefined) {
      obj.guidedSearchResult = SearchResponse_GuidedSearchResult.toJSON(message.guidedSearchResult);
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    if (message.attributionToken !== "") {
      obj.attributionToken = message.attributionToken;
    }
    if (message.redirectUri !== "") {
      obj.redirectUri = message.redirectUri;
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.correctedQuery !== "") {
      obj.correctedQuery = message.correctedQuery;
    }
    if (message.summary !== undefined) {
      obj.summary = SearchResponse_Summary.toJSON(message.summary);
    }
    if (message.appliedControls?.length) {
      obj.appliedControls = message.appliedControls;
    }
    if (message.geoSearchDebugInfo?.length) {
      obj.geoSearchDebugInfo = message.geoSearchDebugInfo.map((e) => SearchResponse_GeoSearchDebugInfo.toJSON(e));
    }
    if (message.queryExpansionInfo !== undefined) {
      obj.queryExpansionInfo = SearchResponse_QueryExpansionInfo.toJSON(message.queryExpansionInfo);
    }
    if (message.naturalLanguageQueryUnderstandingInfo !== undefined) {
      obj.naturalLanguageQueryUnderstandingInfo = SearchResponse_NaturalLanguageQueryUnderstandingInfo.toJSON(
        message.naturalLanguageQueryUnderstandingInfo,
      );
    }
    if (message.sessionInfo !== undefined) {
      obj.sessionInfo = SearchResponse_SessionInfo.toJSON(message.sessionInfo);
    }
    if (message.oneBoxResults?.length) {
      obj.oneBoxResults = message.oneBoxResults.map((e) => SearchResponse_OneBoxResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse>): SearchResponse {
    return SearchResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse>): SearchResponse {
    const message = createBaseSearchResponse();
    message.results = object.results?.map((e) => SearchResponse_SearchResult.fromPartial(e)) || [];
    message.facets = object.facets?.map((e) => SearchResponse_Facet.fromPartial(e)) || [];
    message.guidedSearchResult = (object.guidedSearchResult !== undefined && object.guidedSearchResult !== null)
      ? SearchResponse_GuidedSearchResult.fromPartial(object.guidedSearchResult)
      : undefined;
    message.totalSize = object.totalSize ?? 0;
    message.attributionToken = object.attributionToken ?? "";
    message.redirectUri = object.redirectUri ?? "";
    message.nextPageToken = object.nextPageToken ?? "";
    message.correctedQuery = object.correctedQuery ?? "";
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? SearchResponse_Summary.fromPartial(object.summary)
      : undefined;
    message.appliedControls = object.appliedControls?.map((e) => e) || [];
    message.geoSearchDebugInfo =
      object.geoSearchDebugInfo?.map((e) => SearchResponse_GeoSearchDebugInfo.fromPartial(e)) || [];
    message.queryExpansionInfo = (object.queryExpansionInfo !== undefined && object.queryExpansionInfo !== null)
      ? SearchResponse_QueryExpansionInfo.fromPartial(object.queryExpansionInfo)
      : undefined;
    message.naturalLanguageQueryUnderstandingInfo =
      (object.naturalLanguageQueryUnderstandingInfo !== undefined &&
          object.naturalLanguageQueryUnderstandingInfo !== null)
        ? SearchResponse_NaturalLanguageQueryUnderstandingInfo.fromPartial(object.naturalLanguageQueryUnderstandingInfo)
        : undefined;
    message.sessionInfo = (object.sessionInfo !== undefined && object.sessionInfo !== null)
      ? SearchResponse_SessionInfo.fromPartial(object.sessionInfo)
      : undefined;
    message.oneBoxResults = object.oneBoxResults?.map((e) => SearchResponse_OneBoxResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchResponse_SearchResult(): SearchResponse_SearchResult {
  return { id: "", document: undefined, chunk: undefined, modelScores: {} };
}

export const SearchResponse_SearchResult: MessageFns<SearchResponse_SearchResult> = {
  encode(message: SearchResponse_SearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.document !== undefined) {
      Document.encode(message.document, writer.uint32(18).fork()).join();
    }
    if (message.chunk !== undefined) {
      Chunk.encode(message.chunk, writer.uint32(146).fork()).join();
    }
    Object.entries(message.modelScores).forEach(([key, value]) => {
      SearchResponse_SearchResult_ModelScoresEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_SearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_SearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.document = Document.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.chunk = Chunk.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = SearchResponse_SearchResult_ModelScoresEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.modelScores[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_SearchResult {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      document: isSet(object.document) ? Document.fromJSON(object.document) : undefined,
      chunk: isSet(object.chunk) ? Chunk.fromJSON(object.chunk) : undefined,
      modelScores: isObject(object.modelScores)
        ? Object.entries(object.modelScores).reduce<{ [key: string]: DoubleList }>((acc, [key, value]) => {
          acc[key] = DoubleList.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SearchResponse_SearchResult): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.document !== undefined) {
      obj.document = Document.toJSON(message.document);
    }
    if (message.chunk !== undefined) {
      obj.chunk = Chunk.toJSON(message.chunk);
    }
    if (message.modelScores) {
      const entries = Object.entries(message.modelScores);
      if (entries.length > 0) {
        obj.modelScores = {};
        entries.forEach(([k, v]) => {
          obj.modelScores[k] = DoubleList.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_SearchResult>): SearchResponse_SearchResult {
    return SearchResponse_SearchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_SearchResult>): SearchResponse_SearchResult {
    const message = createBaseSearchResponse_SearchResult();
    message.id = object.id ?? "";
    message.document = (object.document !== undefined && object.document !== null)
      ? Document.fromPartial(object.document)
      : undefined;
    message.chunk = (object.chunk !== undefined && object.chunk !== null) ? Chunk.fromPartial(object.chunk) : undefined;
    message.modelScores = Object.entries(object.modelScores ?? {}).reduce<{ [key: string]: DoubleList }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = DoubleList.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSearchResponse_SearchResult_ModelScoresEntry(): SearchResponse_SearchResult_ModelScoresEntry {
  return { key: "", value: undefined };
}

export const SearchResponse_SearchResult_ModelScoresEntry: MessageFns<SearchResponse_SearchResult_ModelScoresEntry> = {
  encode(
    message: SearchResponse_SearchResult_ModelScoresEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DoubleList.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_SearchResult_ModelScoresEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_SearchResult_ModelScoresEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = DoubleList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_SearchResult_ModelScoresEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DoubleList.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SearchResponse_SearchResult_ModelScoresEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DoubleList.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchResponse_SearchResult_ModelScoresEntry>,
  ): SearchResponse_SearchResult_ModelScoresEntry {
    return SearchResponse_SearchResult_ModelScoresEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchResponse_SearchResult_ModelScoresEntry>,
  ): SearchResponse_SearchResult_ModelScoresEntry {
    const message = createBaseSearchResponse_SearchResult_ModelScoresEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DoubleList.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSearchResponse_Facet(): SearchResponse_Facet {
  return { key: "", values: [], dynamicFacet: false };
}

export const SearchResponse_Facet: MessageFns<SearchResponse_Facet> = {
  encode(message: SearchResponse_Facet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    for (const v of message.values) {
      SearchResponse_Facet_FacetValue.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.dynamicFacet !== false) {
      writer.uint32(24).bool(message.dynamicFacet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Facet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Facet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.values.push(SearchResponse_Facet_FacetValue.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dynamicFacet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Facet {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => SearchResponse_Facet_FacetValue.fromJSON(e))
        : [],
      dynamicFacet: isSet(object.dynamicFacet) ? globalThis.Boolean(object.dynamicFacet) : false,
    };
  },

  toJSON(message: SearchResponse_Facet): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.values?.length) {
      obj.values = message.values.map((e) => SearchResponse_Facet_FacetValue.toJSON(e));
    }
    if (message.dynamicFacet !== false) {
      obj.dynamicFacet = message.dynamicFacet;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Facet>): SearchResponse_Facet {
    return SearchResponse_Facet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Facet>): SearchResponse_Facet {
    const message = createBaseSearchResponse_Facet();
    message.key = object.key ?? "";
    message.values = object.values?.map((e) => SearchResponse_Facet_FacetValue.fromPartial(e)) || [];
    message.dynamicFacet = object.dynamicFacet ?? false;
    return message;
  },
};

function createBaseSearchResponse_Facet_FacetValue(): SearchResponse_Facet_FacetValue {
  return { value: undefined, interval: undefined, count: Long.ZERO };
}

export const SearchResponse_Facet_FacetValue: MessageFns<SearchResponse_Facet_FacetValue> = {
  encode(message: SearchResponse_Facet_FacetValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    if (message.interval !== undefined) {
      Interval.encode(message.interval, writer.uint32(18).fork()).join();
    }
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.count.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Facet_FacetValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Facet_FacetValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.interval = Interval.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Facet_FacetValue {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      interval: isSet(object.interval) ? Interval.fromJSON(object.interval) : undefined,
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
    };
  },

  toJSON(message: SearchResponse_Facet_FacetValue): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.interval !== undefined) {
      obj.interval = Interval.toJSON(message.interval);
    }
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Facet_FacetValue>): SearchResponse_Facet_FacetValue {
    return SearchResponse_Facet_FacetValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Facet_FacetValue>): SearchResponse_Facet_FacetValue {
    const message = createBaseSearchResponse_Facet_FacetValue();
    message.value = object.value ?? undefined;
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? Interval.fromPartial(object.interval)
      : undefined;
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    return message;
  },
};

function createBaseSearchResponse_GuidedSearchResult(): SearchResponse_GuidedSearchResult {
  return { refinementAttributes: [], followUpQuestions: [] };
}

export const SearchResponse_GuidedSearchResult: MessageFns<SearchResponse_GuidedSearchResult> = {
  encode(message: SearchResponse_GuidedSearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.refinementAttributes) {
      SearchResponse_GuidedSearchResult_RefinementAttribute.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.followUpQuestions) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_GuidedSearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_GuidedSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.refinementAttributes.push(
            SearchResponse_GuidedSearchResult_RefinementAttribute.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.followUpQuestions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_GuidedSearchResult {
    return {
      refinementAttributes: globalThis.Array.isArray(object?.refinementAttributes)
        ? object.refinementAttributes.map((e: any) => SearchResponse_GuidedSearchResult_RefinementAttribute.fromJSON(e))
        : [],
      followUpQuestions: globalThis.Array.isArray(object?.followUpQuestions)
        ? object.followUpQuestions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SearchResponse_GuidedSearchResult): unknown {
    const obj: any = {};
    if (message.refinementAttributes?.length) {
      obj.refinementAttributes = message.refinementAttributes.map((e) =>
        SearchResponse_GuidedSearchResult_RefinementAttribute.toJSON(e)
      );
    }
    if (message.followUpQuestions?.length) {
      obj.followUpQuestions = message.followUpQuestions;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_GuidedSearchResult>): SearchResponse_GuidedSearchResult {
    return SearchResponse_GuidedSearchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_GuidedSearchResult>): SearchResponse_GuidedSearchResult {
    const message = createBaseSearchResponse_GuidedSearchResult();
    message.refinementAttributes =
      object.refinementAttributes?.map((e) => SearchResponse_GuidedSearchResult_RefinementAttribute.fromPartial(e)) ||
      [];
    message.followUpQuestions = object.followUpQuestions?.map((e) => e) || [];
    return message;
  },
};

function createBaseSearchResponse_GuidedSearchResult_RefinementAttribute(): SearchResponse_GuidedSearchResult_RefinementAttribute {
  return { attributeKey: "", attributeValue: "" };
}

export const SearchResponse_GuidedSearchResult_RefinementAttribute: MessageFns<
  SearchResponse_GuidedSearchResult_RefinementAttribute
> = {
  encode(
    message: SearchResponse_GuidedSearchResult_RefinementAttribute,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.attributeKey !== "") {
      writer.uint32(10).string(message.attributeKey);
    }
    if (message.attributeValue !== "") {
      writer.uint32(18).string(message.attributeValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_GuidedSearchResult_RefinementAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_GuidedSearchResult_RefinementAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributeValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_GuidedSearchResult_RefinementAttribute {
    return {
      attributeKey: isSet(object.attributeKey) ? globalThis.String(object.attributeKey) : "",
      attributeValue: isSet(object.attributeValue) ? globalThis.String(object.attributeValue) : "",
    };
  },

  toJSON(message: SearchResponse_GuidedSearchResult_RefinementAttribute): unknown {
    const obj: any = {};
    if (message.attributeKey !== "") {
      obj.attributeKey = message.attributeKey;
    }
    if (message.attributeValue !== "") {
      obj.attributeValue = message.attributeValue;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchResponse_GuidedSearchResult_RefinementAttribute>,
  ): SearchResponse_GuidedSearchResult_RefinementAttribute {
    return SearchResponse_GuidedSearchResult_RefinementAttribute.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchResponse_GuidedSearchResult_RefinementAttribute>,
  ): SearchResponse_GuidedSearchResult_RefinementAttribute {
    const message = createBaseSearchResponse_GuidedSearchResult_RefinementAttribute();
    message.attributeKey = object.attributeKey ?? "";
    message.attributeValue = object.attributeValue ?? "";
    return message;
  },
};

function createBaseSearchResponse_Summary(): SearchResponse_Summary {
  return { summaryText: "", summarySkippedReasons: [], safetyAttributes: undefined, summaryWithMetadata: undefined };
}

export const SearchResponse_Summary: MessageFns<SearchResponse_Summary> = {
  encode(message: SearchResponse_Summary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.summaryText !== "") {
      writer.uint32(10).string(message.summaryText);
    }
    writer.uint32(18).fork();
    for (const v of message.summarySkippedReasons) {
      writer.int32(v);
    }
    writer.join();
    if (message.safetyAttributes !== undefined) {
      SearchResponse_Summary_SafetyAttributes.encode(message.safetyAttributes, writer.uint32(26).fork()).join();
    }
    if (message.summaryWithMetadata !== undefined) {
      SearchResponse_Summary_SummaryWithMetadata.encode(message.summaryWithMetadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.summaryText = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.summarySkippedReasons.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.summarySkippedReasons.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.safetyAttributes = SearchResponse_Summary_SafetyAttributes.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.summaryWithMetadata = SearchResponse_Summary_SummaryWithMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary {
    return {
      summaryText: isSet(object.summaryText) ? globalThis.String(object.summaryText) : "",
      summarySkippedReasons: globalThis.Array.isArray(object?.summarySkippedReasons)
        ? object.summarySkippedReasons.map((e: any) => searchResponse_Summary_SummarySkippedReasonFromJSON(e))
        : [],
      safetyAttributes: isSet(object.safetyAttributes)
        ? SearchResponse_Summary_SafetyAttributes.fromJSON(object.safetyAttributes)
        : undefined,
      summaryWithMetadata: isSet(object.summaryWithMetadata)
        ? SearchResponse_Summary_SummaryWithMetadata.fromJSON(object.summaryWithMetadata)
        : undefined,
    };
  },

  toJSON(message: SearchResponse_Summary): unknown {
    const obj: any = {};
    if (message.summaryText !== "") {
      obj.summaryText = message.summaryText;
    }
    if (message.summarySkippedReasons?.length) {
      obj.summarySkippedReasons = message.summarySkippedReasons.map((e) =>
        searchResponse_Summary_SummarySkippedReasonToJSON(e)
      );
    }
    if (message.safetyAttributes !== undefined) {
      obj.safetyAttributes = SearchResponse_Summary_SafetyAttributes.toJSON(message.safetyAttributes);
    }
    if (message.summaryWithMetadata !== undefined) {
      obj.summaryWithMetadata = SearchResponse_Summary_SummaryWithMetadata.toJSON(message.summaryWithMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary>): SearchResponse_Summary {
    return SearchResponse_Summary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Summary>): SearchResponse_Summary {
    const message = createBaseSearchResponse_Summary();
    message.summaryText = object.summaryText ?? "";
    message.summarySkippedReasons = object.summarySkippedReasons?.map((e) => e) || [];
    message.safetyAttributes = (object.safetyAttributes !== undefined && object.safetyAttributes !== null)
      ? SearchResponse_Summary_SafetyAttributes.fromPartial(object.safetyAttributes)
      : undefined;
    message.summaryWithMetadata = (object.summaryWithMetadata !== undefined && object.summaryWithMetadata !== null)
      ? SearchResponse_Summary_SummaryWithMetadata.fromPartial(object.summaryWithMetadata)
      : undefined;
    return message;
  },
};

function createBaseSearchResponse_Summary_SafetyAttributes(): SearchResponse_Summary_SafetyAttributes {
  return { categories: [], scores: [] };
}

export const SearchResponse_Summary_SafetyAttributes: MessageFns<SearchResponse_Summary_SafetyAttributes> = {
  encode(message: SearchResponse_Summary_SafetyAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.categories) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.scores) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_SafetyAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary_SafetyAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.categories.push(reader.string());
          continue;
        case 2:
          if (tag === 21) {
            message.scores.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.scores.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary_SafetyAttributes {
    return {
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
      scores: globalThis.Array.isArray(object?.scores) ? object.scores.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: SearchResponse_Summary_SafetyAttributes): unknown {
    const obj: any = {};
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    if (message.scores?.length) {
      obj.scores = message.scores;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary_SafetyAttributes>): SearchResponse_Summary_SafetyAttributes {
    return SearchResponse_Summary_SafetyAttributes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Summary_SafetyAttributes>): SearchResponse_Summary_SafetyAttributes {
    const message = createBaseSearchResponse_Summary_SafetyAttributes();
    message.categories = object.categories?.map((e) => e) || [];
    message.scores = object.scores?.map((e) => e) || [];
    return message;
  },
};

function createBaseSearchResponse_Summary_CitationMetadata(): SearchResponse_Summary_CitationMetadata {
  return { citations: [] };
}

export const SearchResponse_Summary_CitationMetadata: MessageFns<SearchResponse_Summary_CitationMetadata> = {
  encode(message: SearchResponse_Summary_CitationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.citations) {
      SearchResponse_Summary_Citation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_CitationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary_CitationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.citations.push(SearchResponse_Summary_Citation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary_CitationMetadata {
    return {
      citations: globalThis.Array.isArray(object?.citations)
        ? object.citations.map((e: any) => SearchResponse_Summary_Citation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse_Summary_CitationMetadata): unknown {
    const obj: any = {};
    if (message.citations?.length) {
      obj.citations = message.citations.map((e) => SearchResponse_Summary_Citation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary_CitationMetadata>): SearchResponse_Summary_CitationMetadata {
    return SearchResponse_Summary_CitationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Summary_CitationMetadata>): SearchResponse_Summary_CitationMetadata {
    const message = createBaseSearchResponse_Summary_CitationMetadata();
    message.citations = object.citations?.map((e) => SearchResponse_Summary_Citation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchResponse_Summary_Citation(): SearchResponse_Summary_Citation {
  return { startIndex: Long.ZERO, endIndex: Long.ZERO, sources: [] };
}

export const SearchResponse_Summary_Citation: MessageFns<SearchResponse_Summary_Citation> = {
  encode(message: SearchResponse_Summary_Citation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.startIndex.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.startIndex.toString());
    }
    if (!message.endIndex.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.endIndex.toString());
    }
    for (const v of message.sources) {
      SearchResponse_Summary_CitationSource.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_Citation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary_Citation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startIndex = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endIndex = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sources.push(SearchResponse_Summary_CitationSource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary_Citation {
    return {
      startIndex: isSet(object.startIndex) ? Long.fromValue(object.startIndex) : Long.ZERO,
      endIndex: isSet(object.endIndex) ? Long.fromValue(object.endIndex) : Long.ZERO,
      sources: globalThis.Array.isArray(object?.sources)
        ? object.sources.map((e: any) => SearchResponse_Summary_CitationSource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse_Summary_Citation): unknown {
    const obj: any = {};
    if (!message.startIndex.equals(Long.ZERO)) {
      obj.startIndex = (message.startIndex || Long.ZERO).toString();
    }
    if (!message.endIndex.equals(Long.ZERO)) {
      obj.endIndex = (message.endIndex || Long.ZERO).toString();
    }
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => SearchResponse_Summary_CitationSource.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary_Citation>): SearchResponse_Summary_Citation {
    return SearchResponse_Summary_Citation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Summary_Citation>): SearchResponse_Summary_Citation {
    const message = createBaseSearchResponse_Summary_Citation();
    message.startIndex = (object.startIndex !== undefined && object.startIndex !== null)
      ? Long.fromValue(object.startIndex)
      : Long.ZERO;
    message.endIndex = (object.endIndex !== undefined && object.endIndex !== null)
      ? Long.fromValue(object.endIndex)
      : Long.ZERO;
    message.sources = object.sources?.map((e) => SearchResponse_Summary_CitationSource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchResponse_Summary_CitationSource(): SearchResponse_Summary_CitationSource {
  return { referenceIndex: Long.ZERO };
}

export const SearchResponse_Summary_CitationSource: MessageFns<SearchResponse_Summary_CitationSource> = {
  encode(message: SearchResponse_Summary_CitationSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.referenceIndex.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.referenceIndex.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_CitationSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary_CitationSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 32) {
            break;
          }

          message.referenceIndex = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary_CitationSource {
    return { referenceIndex: isSet(object.referenceIndex) ? Long.fromValue(object.referenceIndex) : Long.ZERO };
  },

  toJSON(message: SearchResponse_Summary_CitationSource): unknown {
    const obj: any = {};
    if (!message.referenceIndex.equals(Long.ZERO)) {
      obj.referenceIndex = (message.referenceIndex || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary_CitationSource>): SearchResponse_Summary_CitationSource {
    return SearchResponse_Summary_CitationSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Summary_CitationSource>): SearchResponse_Summary_CitationSource {
    const message = createBaseSearchResponse_Summary_CitationSource();
    message.referenceIndex = (object.referenceIndex !== undefined && object.referenceIndex !== null)
      ? Long.fromValue(object.referenceIndex)
      : Long.ZERO;
    return message;
  },
};

function createBaseSearchResponse_Summary_Reference(): SearchResponse_Summary_Reference {
  return { title: "", document: "", uri: "", chunkContents: [] };
}

export const SearchResponse_Summary_Reference: MessageFns<SearchResponse_Summary_Reference> = {
  encode(message: SearchResponse_Summary_Reference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.document !== "") {
      writer.uint32(18).string(message.document);
    }
    if (message.uri !== "") {
      writer.uint32(26).string(message.uri);
    }
    for (const v of message.chunkContents) {
      SearchResponse_Summary_Reference_ChunkContent.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_Reference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary_Reference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.document = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.chunkContents.push(SearchResponse_Summary_Reference_ChunkContent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary_Reference {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      document: isSet(object.document) ? globalThis.String(object.document) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      chunkContents: globalThis.Array.isArray(object?.chunkContents)
        ? object.chunkContents.map((e: any) => SearchResponse_Summary_Reference_ChunkContent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse_Summary_Reference): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.document !== "") {
      obj.document = message.document;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.chunkContents?.length) {
      obj.chunkContents = message.chunkContents.map((e) => SearchResponse_Summary_Reference_ChunkContent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary_Reference>): SearchResponse_Summary_Reference {
    return SearchResponse_Summary_Reference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Summary_Reference>): SearchResponse_Summary_Reference {
    const message = createBaseSearchResponse_Summary_Reference();
    message.title = object.title ?? "";
    message.document = object.document ?? "";
    message.uri = object.uri ?? "";
    message.chunkContents =
      object.chunkContents?.map((e) => SearchResponse_Summary_Reference_ChunkContent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchResponse_Summary_Reference_ChunkContent(): SearchResponse_Summary_Reference_ChunkContent {
  return { content: "", pageIdentifier: "" };
}

export const SearchResponse_Summary_Reference_ChunkContent: MessageFns<SearchResponse_Summary_Reference_ChunkContent> =
  {
    encode(
      message: SearchResponse_Summary_Reference_ChunkContent,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.content !== "") {
        writer.uint32(10).string(message.content);
      }
      if (message.pageIdentifier !== "") {
        writer.uint32(18).string(message.pageIdentifier);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_Reference_ChunkContent {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSearchResponse_Summary_Reference_ChunkContent();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.content = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.pageIdentifier = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SearchResponse_Summary_Reference_ChunkContent {
      return {
        content: isSet(object.content) ? globalThis.String(object.content) : "",
        pageIdentifier: isSet(object.pageIdentifier) ? globalThis.String(object.pageIdentifier) : "",
      };
    },

    toJSON(message: SearchResponse_Summary_Reference_ChunkContent): unknown {
      const obj: any = {};
      if (message.content !== "") {
        obj.content = message.content;
      }
      if (message.pageIdentifier !== "") {
        obj.pageIdentifier = message.pageIdentifier;
      }
      return obj;
    },

    create(
      base?: DeepPartial<SearchResponse_Summary_Reference_ChunkContent>,
    ): SearchResponse_Summary_Reference_ChunkContent {
      return SearchResponse_Summary_Reference_ChunkContent.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<SearchResponse_Summary_Reference_ChunkContent>,
    ): SearchResponse_Summary_Reference_ChunkContent {
      const message = createBaseSearchResponse_Summary_Reference_ChunkContent();
      message.content = object.content ?? "";
      message.pageIdentifier = object.pageIdentifier ?? "";
      return message;
    },
  };

function createBaseSearchResponse_Summary_SummaryWithMetadata(): SearchResponse_Summary_SummaryWithMetadata {
  return { summary: "", citationMetadata: undefined, references: [] };
}

export const SearchResponse_Summary_SummaryWithMetadata: MessageFns<SearchResponse_Summary_SummaryWithMetadata> = {
  encode(message: SearchResponse_Summary_SummaryWithMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.summary !== "") {
      writer.uint32(10).string(message.summary);
    }
    if (message.citationMetadata !== undefined) {
      SearchResponse_Summary_CitationMetadata.encode(message.citationMetadata, writer.uint32(18).fork()).join();
    }
    for (const v of message.references) {
      SearchResponse_Summary_Reference.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Summary_SummaryWithMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Summary_SummaryWithMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.summary = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.citationMetadata = SearchResponse_Summary_CitationMetadata.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.references.push(SearchResponse_Summary_Reference.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Summary_SummaryWithMetadata {
    return {
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      citationMetadata: isSet(object.citationMetadata)
        ? SearchResponse_Summary_CitationMetadata.fromJSON(object.citationMetadata)
        : undefined,
      references: globalThis.Array.isArray(object?.references)
        ? object.references.map((e: any) => SearchResponse_Summary_Reference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse_Summary_SummaryWithMetadata): unknown {
    const obj: any = {};
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.citationMetadata !== undefined) {
      obj.citationMetadata = SearchResponse_Summary_CitationMetadata.toJSON(message.citationMetadata);
    }
    if (message.references?.length) {
      obj.references = message.references.map((e) => SearchResponse_Summary_Reference.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Summary_SummaryWithMetadata>): SearchResponse_Summary_SummaryWithMetadata {
    return SearchResponse_Summary_SummaryWithMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchResponse_Summary_SummaryWithMetadata>,
  ): SearchResponse_Summary_SummaryWithMetadata {
    const message = createBaseSearchResponse_Summary_SummaryWithMetadata();
    message.summary = object.summary ?? "";
    message.citationMetadata = (object.citationMetadata !== undefined && object.citationMetadata !== null)
      ? SearchResponse_Summary_CitationMetadata.fromPartial(object.citationMetadata)
      : undefined;
    message.references = object.references?.map((e) => SearchResponse_Summary_Reference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchResponse_GeoSearchDebugInfo(): SearchResponse_GeoSearchDebugInfo {
  return { originalAddressQuery: "", errorMessage: "" };
}

export const SearchResponse_GeoSearchDebugInfo: MessageFns<SearchResponse_GeoSearchDebugInfo> = {
  encode(message: SearchResponse_GeoSearchDebugInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.originalAddressQuery !== "") {
      writer.uint32(10).string(message.originalAddressQuery);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_GeoSearchDebugInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_GeoSearchDebugInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.originalAddressQuery = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_GeoSearchDebugInfo {
    return {
      originalAddressQuery: isSet(object.originalAddressQuery) ? globalThis.String(object.originalAddressQuery) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: SearchResponse_GeoSearchDebugInfo): unknown {
    const obj: any = {};
    if (message.originalAddressQuery !== "") {
      obj.originalAddressQuery = message.originalAddressQuery;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_GeoSearchDebugInfo>): SearchResponse_GeoSearchDebugInfo {
    return SearchResponse_GeoSearchDebugInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_GeoSearchDebugInfo>): SearchResponse_GeoSearchDebugInfo {
    const message = createBaseSearchResponse_GeoSearchDebugInfo();
    message.originalAddressQuery = object.originalAddressQuery ?? "";
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseSearchResponse_QueryExpansionInfo(): SearchResponse_QueryExpansionInfo {
  return { expandedQuery: false, pinnedResultCount: Long.ZERO };
}

export const SearchResponse_QueryExpansionInfo: MessageFns<SearchResponse_QueryExpansionInfo> = {
  encode(message: SearchResponse_QueryExpansionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expandedQuery !== false) {
      writer.uint32(8).bool(message.expandedQuery);
    }
    if (!message.pinnedResultCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.pinnedResultCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_QueryExpansionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_QueryExpansionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.expandedQuery = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pinnedResultCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_QueryExpansionInfo {
    return {
      expandedQuery: isSet(object.expandedQuery) ? globalThis.Boolean(object.expandedQuery) : false,
      pinnedResultCount: isSet(object.pinnedResultCount) ? Long.fromValue(object.pinnedResultCount) : Long.ZERO,
    };
  },

  toJSON(message: SearchResponse_QueryExpansionInfo): unknown {
    const obj: any = {};
    if (message.expandedQuery !== false) {
      obj.expandedQuery = message.expandedQuery;
    }
    if (!message.pinnedResultCount.equals(Long.ZERO)) {
      obj.pinnedResultCount = (message.pinnedResultCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_QueryExpansionInfo>): SearchResponse_QueryExpansionInfo {
    return SearchResponse_QueryExpansionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_QueryExpansionInfo>): SearchResponse_QueryExpansionInfo {
    const message = createBaseSearchResponse_QueryExpansionInfo();
    message.expandedQuery = object.expandedQuery ?? false;
    message.pinnedResultCount = (object.pinnedResultCount !== undefined && object.pinnedResultCount !== null)
      ? Long.fromValue(object.pinnedResultCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo(): SearchResponse_NaturalLanguageQueryUnderstandingInfo {
  return { extractedFilters: "", rewrittenQuery: "", structuredExtractedFilter: undefined };
}

export const SearchResponse_NaturalLanguageQueryUnderstandingInfo: MessageFns<
  SearchResponse_NaturalLanguageQueryUnderstandingInfo
> = {
  encode(
    message: SearchResponse_NaturalLanguageQueryUnderstandingInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.extractedFilters !== "") {
      writer.uint32(10).string(message.extractedFilters);
    }
    if (message.rewrittenQuery !== "") {
      writer.uint32(18).string(message.rewrittenQuery);
    }
    if (message.structuredExtractedFilter !== undefined) {
      SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter.encode(
        message.structuredExtractedFilter,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_NaturalLanguageQueryUnderstandingInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.extractedFilters = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rewrittenQuery = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.structuredExtractedFilter =
            SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter.decode(
              reader,
              reader.uint32(),
            );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_NaturalLanguageQueryUnderstandingInfo {
    return {
      extractedFilters: isSet(object.extractedFilters) ? globalThis.String(object.extractedFilters) : "",
      rewrittenQuery: isSet(object.rewrittenQuery) ? globalThis.String(object.rewrittenQuery) : "",
      structuredExtractedFilter: isSet(object.structuredExtractedFilter)
        ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter.fromJSON(
          object.structuredExtractedFilter,
        )
        : undefined,
    };
  },

  toJSON(message: SearchResponse_NaturalLanguageQueryUnderstandingInfo): unknown {
    const obj: any = {};
    if (message.extractedFilters !== "") {
      obj.extractedFilters = message.extractedFilters;
    }
    if (message.rewrittenQuery !== "") {
      obj.rewrittenQuery = message.rewrittenQuery;
    }
    if (message.structuredExtractedFilter !== undefined) {
      obj.structuredExtractedFilter = SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter
        .toJSON(message.structuredExtractedFilter);
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchResponse_NaturalLanguageQueryUnderstandingInfo>,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo {
    return SearchResponse_NaturalLanguageQueryUnderstandingInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchResponse_NaturalLanguageQueryUnderstandingInfo>,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo {
    const message = createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo();
    message.extractedFilters = object.extractedFilters ?? "";
    message.rewrittenQuery = object.rewrittenQuery ?? "";
    message.structuredExtractedFilter =
      (object.structuredExtractedFilter !== undefined && object.structuredExtractedFilter !== null)
        ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter.fromPartial(
          object.structuredExtractedFilter,
        )
        : undefined;
    return message;
  },
};

function createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter(): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter {
  return { expression: undefined };
}

export const SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter: MessageFns<
  SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter
> = {
  encode(
    message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.expression !== undefined) {
      SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.encode(
        message.expression,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expression = SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression
            .decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter {
    return {
      expression: isSet(object.expression)
        ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.fromJSON(
          object.expression,
        )
        : undefined,
    };
  },

  toJSON(message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter): unknown {
    const obj: any = {};
    if (message.expression !== undefined) {
      obj.expression = SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.toJSON(
        message.expression,
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter>,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter {
    return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter>,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter {
    const message = createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter();
    message.expression = (object.expression !== undefined && object.expression !== null)
      ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.fromPartial(
        object.expression,
      )
      : undefined;
    return message;
  },
};

function createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint(): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint {
  return { fieldName: "", values: [], querySegment: "" };
}

export const SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint:
  MessageFns<SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint> = {
    encode(
      message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.fieldName !== "") {
        writer.uint32(10).string(message.fieldName);
      }
      for (const v of message.values) {
        writer.uint32(18).string(v!);
      }
      if (message.querySegment !== "") {
        writer.uint32(26).string(message.querySegment);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.fieldName = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.values.push(reader.string());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.querySegment = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(
      object: any,
    ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint {
      return {
        fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
        values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
        querySegment: isSet(object.querySegment) ? globalThis.String(object.querySegment) : "",
      };
    },

    toJSON(
      message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint,
    ): unknown {
      const obj: any = {};
      if (message.fieldName !== "") {
        obj.fieldName = message.fieldName;
      }
      if (message.values?.length) {
        obj.values = message.values;
      }
      if (message.querySegment !== "") {
        obj.querySegment = message.querySegment;
      }
      return obj;
    },

    create(
      base?: DeepPartial<
        SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint
      >,
    ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint {
      return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint
        .fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<
        SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint
      >,
    ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint {
      const message =
        createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint();
      message.fieldName = object.fieldName ?? "";
      message.values = object.values?.map((e) => e) || [];
      message.querySegment = object.querySegment ?? "";
      return message;
    },
  };

function createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint(): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint {
  return { fieldName: "", comparison: 0, value: 0, querySegment: "" };
}

export const SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint:
  MessageFns<SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint> = {
    encode(
      message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.fieldName !== "") {
        writer.uint32(10).string(message.fieldName);
      }
      if (message.comparison !== 0) {
        writer.uint32(16).int32(message.comparison);
      }
      if (message.value !== 0) {
        writer.uint32(25).double(message.value);
      }
      if (message.querySegment !== "") {
        writer.uint32(34).string(message.querySegment);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.fieldName = reader.string();
            continue;
          case 2:
            if (tag !== 16) {
              break;
            }

            message.comparison = reader.int32() as any;
            continue;
          case 3:
            if (tag !== 25) {
              break;
            }

            message.value = reader.double();
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }

            message.querySegment = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(
      object: any,
    ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint {
      return {
        fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
        comparison: isSet(object.comparison)
          ? searchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_ComparisonFromJSON(
            object.comparison,
          )
          : 0,
        value: isSet(object.value) ? globalThis.Number(object.value) : 0,
        querySegment: isSet(object.querySegment) ? globalThis.String(object.querySegment) : "",
      };
    },

    toJSON(
      message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint,
    ): unknown {
      const obj: any = {};
      if (message.fieldName !== "") {
        obj.fieldName = message.fieldName;
      }
      if (message.comparison !== 0) {
        obj.comparison =
          searchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint_ComparisonToJSON(
            message.comparison,
          );
      }
      if (message.value !== 0) {
        obj.value = message.value;
      }
      if (message.querySegment !== "") {
        obj.querySegment = message.querySegment;
      }
      return obj;
    },

    create(
      base?: DeepPartial<
        SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint
      >,
    ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint {
      return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint
        .fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<
        SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint
      >,
    ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint {
      const message =
        createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint();
      message.fieldName = object.fieldName ?? "";
      message.comparison = object.comparison ?? 0;
      message.value = object.value ?? 0;
      message.querySegment = object.querySegment ?? "";
      return message;
    },
  };

function createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint(): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint {
  return { fieldName: "", address: "", latitude: 0, longitude: 0, radiusInMeters: 0 };
}

export const SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint:
  MessageFns<SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint> = {
    encode(
      message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.fieldName !== "") {
        writer.uint32(10).string(message.fieldName);
      }
      if (message.address !== "") {
        writer.uint32(18).string(message.address);
      }
      if (message.latitude !== 0) {
        writer.uint32(33).double(message.latitude);
      }
      if (message.longitude !== 0) {
        writer.uint32(41).double(message.longitude);
      }
      if (message.radiusInMeters !== 0) {
        writer.uint32(29).float(message.radiusInMeters);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.fieldName = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.address = reader.string();
            continue;
          case 4:
            if (tag !== 33) {
              break;
            }

            message.latitude = reader.double();
            continue;
          case 5:
            if (tag !== 41) {
              break;
            }

            message.longitude = reader.double();
            continue;
          case 3:
            if (tag !== 29) {
              break;
            }

            message.radiusInMeters = reader.float();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(
      object: any,
    ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint {
      return {
        fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
        address: isSet(object.address) ? globalThis.String(object.address) : "",
        latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
        longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
        radiusInMeters: isSet(object.radiusInMeters) ? globalThis.Number(object.radiusInMeters) : 0,
      };
    },

    toJSON(
      message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint,
    ): unknown {
      const obj: any = {};
      if (message.fieldName !== "") {
        obj.fieldName = message.fieldName;
      }
      if (message.address !== "") {
        obj.address = message.address;
      }
      if (message.latitude !== 0) {
        obj.latitude = message.latitude;
      }
      if (message.longitude !== 0) {
        obj.longitude = message.longitude;
      }
      if (message.radiusInMeters !== 0) {
        obj.radiusInMeters = message.radiusInMeters;
      }
      return obj;
    },

    create(
      base?: DeepPartial<
        SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint
      >,
    ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint {
      return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint
        .fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<
        SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint
      >,
    ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint {
      const message =
        createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint();
      message.fieldName = object.fieldName ?? "";
      message.address = object.address ?? "";
      message.latitude = object.latitude ?? 0;
      message.longitude = object.longitude ?? 0;
      message.radiusInMeters = object.radiusInMeters ?? 0;
      return message;
    },
  };

function createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression(): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression {
  return { expressions: [] };
}

export const SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression: MessageFns<
  SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression
> = {
  encode(
    message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.expressions) {
      SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.encode(
        v!,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message =
      createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expressions.push(
            SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.decode(
              reader,
              reader.uint32(),
            ),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression {
    return {
      expressions: globalThis.Array.isArray(object?.expressions)
        ? object.expressions.map((e: any) =>
          SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(
    message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression,
  ): unknown {
    const obj: any = {};
    if (message.expressions?.length) {
      obj.expressions = message.expressions.map((e) =>
        SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression>,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression {
    return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression.fromPartial(
      base ?? {},
    );
  },
  fromPartial(
    object: DeepPartial<SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression>,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression {
    const message =
      createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression();
    message.expressions =
      object.expressions?.map((e) =>
        SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression(): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression {
  return { expressions: [] };
}

export const SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression: MessageFns<
  SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression
> = {
  encode(
    message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.expressions) {
      SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.encode(
        v!,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message =
      createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expressions.push(
            SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.decode(
              reader,
              reader.uint32(),
            ),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression {
    return {
      expressions: globalThis.Array.isArray(object?.expressions)
        ? object.expressions.map((e: any) =>
          SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(
    message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression,
  ): unknown {
    const obj: any = {};
    if (message.expressions?.length) {
      obj.expressions = message.expressions.map((e) =>
        SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression>,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression {
    return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression.fromPartial(
      base ?? {},
    );
  },
  fromPartial(
    object: DeepPartial<SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression>,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression {
    const message =
      createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression();
    message.expressions =
      object.expressions?.map((e) =>
        SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression(): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression {
  return {
    stringConstraint: undefined,
    numberConstraint: undefined,
    geolocationConstraint: undefined,
    andExpr: undefined,
    orExpr: undefined,
  };
}

export const SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression: MessageFns<
  SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression
> = {
  encode(
    message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.stringConstraint !== undefined) {
      SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint.encode(
        message.stringConstraint,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.numberConstraint !== undefined) {
      SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint.encode(
        message.numberConstraint,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.geolocationConstraint !== undefined) {
      SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint.encode(
        message.geolocationConstraint,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.andExpr !== undefined) {
      SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression.encode(
        message.andExpr,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.orExpr !== undefined) {
      SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression.encode(
        message.orExpr,
        writer.uint32(42).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message =
      createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stringConstraint =
            SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint.decode(
              reader,
              reader.uint32(),
            );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.numberConstraint =
            SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint.decode(
              reader,
              reader.uint32(),
            );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.geolocationConstraint =
            SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint.decode(
              reader,
              reader.uint32(),
            );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.andExpr = SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression
            .decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orExpr = SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression
            .decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression {
    return {
      stringConstraint: isSet(object.stringConstraint)
        ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint.fromJSON(
          object.stringConstraint,
        )
        : undefined,
      numberConstraint: isSet(object.numberConstraint)
        ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint.fromJSON(
          object.numberConstraint,
        )
        : undefined,
      geolocationConstraint: isSet(object.geolocationConstraint)
        ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint.fromJSON(
          object.geolocationConstraint,
        )
        : undefined,
      andExpr: isSet(object.andExpr)
        ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression.fromJSON(
          object.andExpr,
        )
        : undefined,
      orExpr: isSet(object.orExpr)
        ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression.fromJSON(
          object.orExpr,
        )
        : undefined,
    };
  },

  toJSON(message: SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression): unknown {
    const obj: any = {};
    if (message.stringConstraint !== undefined) {
      obj.stringConstraint =
        SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint.toJSON(
          message.stringConstraint,
        );
    }
    if (message.numberConstraint !== undefined) {
      obj.numberConstraint =
        SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint.toJSON(
          message.numberConstraint,
        );
    }
    if (message.geolocationConstraint !== undefined) {
      obj.geolocationConstraint =
        SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint.toJSON(
          message.geolocationConstraint,
        );
    }
    if (message.andExpr !== undefined) {
      obj.andExpr = SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression.toJSON(
        message.andExpr,
      );
    }
    if (message.orExpr !== undefined) {
      obj.orExpr = SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression.toJSON(
        message.orExpr,
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression>,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression {
    return SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression.fromPartial(
      base ?? {},
    );
  },
  fromPartial(
    object: DeepPartial<SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression>,
  ): SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression {
    const message =
      createBaseSearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_Expression();
    message.stringConstraint = (object.stringConstraint !== undefined && object.stringConstraint !== null)
      ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_StringConstraint.fromPartial(
        object.stringConstraint,
      )
      : undefined;
    message.numberConstraint = (object.numberConstraint !== undefined && object.numberConstraint !== null)
      ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_NumberConstraint.fromPartial(
        object.numberConstraint,
      )
      : undefined;
    message.geolocationConstraint =
      (object.geolocationConstraint !== undefined && object.geolocationConstraint !== null)
        ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_GeolocationConstraint
          .fromPartial(object.geolocationConstraint)
        : undefined;
    message.andExpr = (object.andExpr !== undefined && object.andExpr !== null)
      ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_AndExpression.fromPartial(
        object.andExpr,
      )
      : undefined;
    message.orExpr = (object.orExpr !== undefined && object.orExpr !== null)
      ? SearchResponse_NaturalLanguageQueryUnderstandingInfo_StructuredExtractedFilter_OrExpression.fromPartial(
        object.orExpr,
      )
      : undefined;
    return message;
  },
};

function createBaseSearchResponse_SessionInfo(): SearchResponse_SessionInfo {
  return { name: "", queryId: "" };
}

export const SearchResponse_SessionInfo: MessageFns<SearchResponse_SessionInfo> = {
  encode(message: SearchResponse_SessionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.queryId !== "") {
      writer.uint32(18).string(message.queryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_SessionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_SessionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queryId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_SessionInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      queryId: isSet(object.queryId) ? globalThis.String(object.queryId) : "",
    };
  },

  toJSON(message: SearchResponse_SessionInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.queryId !== "") {
      obj.queryId = message.queryId;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_SessionInfo>): SearchResponse_SessionInfo {
    return SearchResponse_SessionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_SessionInfo>): SearchResponse_SessionInfo {
    const message = createBaseSearchResponse_SessionInfo();
    message.name = object.name ?? "";
    message.queryId = object.queryId ?? "";
    return message;
  },
};

function createBaseSearchResponse_OneBoxResult(): SearchResponse_OneBoxResult {
  return { oneBoxType: 0, searchResults: [] };
}

export const SearchResponse_OneBoxResult: MessageFns<SearchResponse_OneBoxResult> = {
  encode(message: SearchResponse_OneBoxResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.oneBoxType !== 0) {
      writer.uint32(8).int32(message.oneBoxType);
    }
    for (const v of message.searchResults) {
      SearchResponse_SearchResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_OneBoxResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_OneBoxResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.oneBoxType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.searchResults.push(SearchResponse_SearchResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_OneBoxResult {
    return {
      oneBoxType: isSet(object.oneBoxType) ? searchResponse_OneBoxResult_OneBoxTypeFromJSON(object.oneBoxType) : 0,
      searchResults: globalThis.Array.isArray(object?.searchResults)
        ? object.searchResults.map((e: any) => SearchResponse_SearchResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse_OneBoxResult): unknown {
    const obj: any = {};
    if (message.oneBoxType !== 0) {
      obj.oneBoxType = searchResponse_OneBoxResult_OneBoxTypeToJSON(message.oneBoxType);
    }
    if (message.searchResults?.length) {
      obj.searchResults = message.searchResults.map((e) => SearchResponse_SearchResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_OneBoxResult>): SearchResponse_OneBoxResult {
    return SearchResponse_OneBoxResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_OneBoxResult>): SearchResponse_OneBoxResult {
    const message = createBaseSearchResponse_OneBoxResult();
    message.oneBoxType = object.oneBoxType ?? 0;
    message.searchResults = object.searchResults?.map((e) => SearchResponse_SearchResult.fromPartial(e)) || [];
    return message;
  },
};

/** Service for search. */
export type SearchServiceDefinition = typeof SearchServiceDefinition;
export const SearchServiceDefinition = {
  name: "SearchService",
  fullName: "google.cloud.discoveryengine.v1alpha.SearchService",
  methods: {
    /** Performs a search. */
    search: {
      name: "Search",
      requestType: SearchRequest,
      requestStream: false,
      responseType: SearchResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              171,
              2,
              58,
              1,
              42,
              90,
              104,
              58,
              1,
              42,
              34,
              99,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              115,
              101,
              114,
              118,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              116,
              111,
              114,
              101,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              90,
              101,
              58,
              1,
              42,
              34,
              96,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              115,
              101,
              114,
              118,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              103,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              34,
              85,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              115,
              101,
              114,
              118,
              105,
              110,
              103,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              116,
              111,
              114,
              101,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface SearchServiceImplementation<CallContextExt = {}> {
  /** Performs a search. */
  search(request: SearchRequest, context: CallContext & CallContextExt): Promise<DeepPartial<SearchResponse>>;
}

export interface SearchServiceClient<CallOptionsExt = {}> {
  /** Performs a search. */
  search(request: DeepPartial<SearchRequest>, options?: CallOptions & CallOptionsExt): Promise<SearchResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
