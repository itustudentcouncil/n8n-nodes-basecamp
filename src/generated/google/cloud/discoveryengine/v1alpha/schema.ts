// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/discoveryengine/v1alpha/schema.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Struct } from "../../../protobuf/struct.js";

export const protobufPackage = "google.cloud.discoveryengine.v1alpha";

/** Defines the structure and layout of a type of document data. */
export interface Schema {
  /** The structured representation of the schema. */
  structSchema?:
    | { [key: string]: any }
    | undefined;
  /** The JSON representation of the schema. */
  jsonSchema?:
    | string
    | undefined;
  /**
   * Immutable. The full resource name of the schema, in the format of
   * `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
   *
   * This field must be a UTF-8 encoded string with a length limit of 1024
   * characters.
   */
  name: string;
  /** Output only. Configurations for fields of the schema. */
  fieldConfigs: FieldConfig[];
}

/**
 * Configurations for fields of a schema. For example, configuring a field is
 * indexable, or searchable.
 */
export interface FieldConfig {
  /**
   * Required. Field path of the schema field.
   * For example: `title`, `description`, `release_info.release_year`.
   */
  fieldPath: string;
  /** Output only. Raw type of the field. */
  fieldType: FieldConfig_FieldType;
  /**
   * If
   * [indexable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.indexable_option]
   * is
   * [INDEXABLE_ENABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.IndexableOption.INDEXABLE_ENABLED],
   * field values are indexed so that it can be filtered or faceted in
   * [SearchService.Search][google.cloud.discoveryengine.v1alpha.SearchService.Search].
   *
   * If
   * [indexable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.indexable_option]
   * is unset, the server behavior defaults to
   * [INDEXABLE_DISABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.IndexableOption.INDEXABLE_DISABLED]
   * for fields that support setting indexable options. For those fields that do
   * not support setting indexable options, such as `object` and `boolean` and
   * key properties, the server will skip
   * [indexable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.indexable_option]
   * setting, and setting
   * [indexable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.indexable_option]
   * for those fields will throw `INVALID_ARGUMENT` error.
   */
  indexableOption: FieldConfig_IndexableOption;
  /**
   * If
   * [dynamic_facetable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.dynamic_facetable_option]
   * is
   * [DYNAMIC_FACETABLE_ENABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.DynamicFacetableOption.DYNAMIC_FACETABLE_ENABLED],
   * field values are available for dynamic facet. Could only be
   * [DYNAMIC_FACETABLE_DISABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.DynamicFacetableOption.DYNAMIC_FACETABLE_DISABLED]
   * if
   * [FieldConfig.indexable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.indexable_option]
   * is
   * [INDEXABLE_DISABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.IndexableOption.INDEXABLE_DISABLED].
   * Otherwise, an `INVALID_ARGUMENT` error will be returned.
   *
   * If
   * [dynamic_facetable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.dynamic_facetable_option]
   * is unset, the server behavior defaults to
   * [DYNAMIC_FACETABLE_DISABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.DynamicFacetableOption.DYNAMIC_FACETABLE_DISABLED]
   * for fields that support setting dynamic facetable options. For those fields
   * that do not support setting dynamic facetable options, such as `object` and
   * `boolean`, the server will skip dynamic facetable option setting, and
   * setting
   * [dynamic_facetable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.dynamic_facetable_option]
   * for those fields will throw `INVALID_ARGUMENT` error.
   */
  dynamicFacetableOption: FieldConfig_DynamicFacetableOption;
  /**
   * If
   * [searchable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.searchable_option]
   * is
   * [SEARCHABLE_ENABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.SearchableOption.SEARCHABLE_ENABLED],
   * field values are searchable by text queries in
   * [SearchService.Search][google.cloud.discoveryengine.v1alpha.SearchService.Search].
   *
   * If
   * [SEARCHABLE_ENABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.SearchableOption.SEARCHABLE_ENABLED]
   * but field type is numerical, field values will not be searchable by text
   * queries in
   * [SearchService.Search][google.cloud.discoveryengine.v1alpha.SearchService.Search],
   * as there are no text values associated to numerical fields.
   *
   * If
   * [searchable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.searchable_option]
   * is unset, the server behavior defaults to
   * [SEARCHABLE_DISABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.SearchableOption.SEARCHABLE_DISABLED]
   * for fields that support setting searchable options. Only `string` fields
   * that have no key property mapping support setting
   * [searchable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.searchable_option].
   *
   * For those fields that do not support setting searchable options, the server
   * will skip searchable option setting, and setting
   * [searchable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.searchable_option]
   * for those fields will throw `INVALID_ARGUMENT` error.
   */
  searchableOption: FieldConfig_SearchableOption;
  /**
   * If
   * [retrievable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.retrievable_option]
   * is
   * [RETRIEVABLE_ENABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.RetrievableOption.RETRIEVABLE_ENABLED],
   * field values are included in the search results.
   *
   * If
   * [retrievable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.retrievable_option]
   * is unset, the server behavior defaults to
   * [RETRIEVABLE_DISABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.RetrievableOption.RETRIEVABLE_DISABLED]
   * for fields that support setting retrievable options. For those fields
   * that do not support setting retrievable options, such as `object` and
   * `boolean`, the server will skip retrievable option setting, and setting
   * [retrievable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.retrievable_option]
   * for those fields will throw `INVALID_ARGUMENT` error.
   */
  retrievableOption: FieldConfig_RetrievableOption;
  /**
   * If
   * [completable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.completable_option]
   * is
   * [COMPLETABLE_ENABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.CompletableOption.COMPLETABLE_ENABLED],
   * field values are directly used and returned as suggestions for Autocomplete
   * in
   * [CompletionService.CompleteQuery][google.cloud.discoveryengine.v1alpha.CompletionService.CompleteQuery].
   *
   * If
   * [completable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.completable_option]
   * is unset, the server behavior defaults to
   * [COMPLETABLE_DISABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.CompletableOption.COMPLETABLE_DISABLED]
   * for fields that support setting completable options, which are just
   * `string` fields. For those fields that do not support setting completable
   * options, the server will skip completable option setting, and setting
   * [completable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.completable_option]
   * for those fields will throw `INVALID_ARGUMENT` error.
   */
  completableOption: FieldConfig_CompletableOption;
  /**
   * If
   * [recs_filterable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.recs_filterable_option]
   * is
   * [FILTERABLE_ENABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.FilterableOption.FILTERABLE_ENABLED],
   * field values are filterable by filter expression in
   * [RecommendationService.Recommend][google.cloud.discoveryengine.v1alpha.RecommendationService.Recommend].
   *
   * If
   * [FILTERABLE_ENABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.FilterableOption.FILTERABLE_ENABLED]
   * but the field type is numerical, field values are not filterable by text
   * queries in
   * [RecommendationService.Recommend][google.cloud.discoveryengine.v1alpha.RecommendationService.Recommend].
   * Only textual fields are supported.
   *
   * If
   * [recs_filterable_option][google.cloud.discoveryengine.v1alpha.FieldConfig.recs_filterable_option]
   * is unset, the default setting is
   * [FILTERABLE_DISABLED][google.cloud.discoveryengine.v1alpha.FieldConfig.FilterableOption.FILTERABLE_DISABLED]
   * for fields that support setting filterable options.
   *
   * When a field set to [FILTERABLE_DISABLED] is filtered, a warning is
   * generated and an empty result is returned.
   */
  recsFilterableOption: FieldConfig_FilterableOption;
  /**
   * Output only. Type of the key property that this field is mapped to. Empty
   * string if this is not annotated as mapped to a key property.
   *
   * Example types are `title`, `description`. Full list is defined
   * by `keyPropertyMapping` in the schema field annotation.
   *
   * If the schema field has a `KeyPropertyMapping` annotation,
   * `indexable_option` and `searchable_option` of this field cannot be
   * modified.
   */
  keyPropertyType: string;
  /**
   * If this field is set, only the corresponding source will be indexed for
   * this field. Otherwise, the values from different sources are merged.
   *
   * Assuming a page with `<author, a>` in meta tag, and `<author, b>` in page
   * map:
   *  if this enum is set to METATAGS, we will only index `<author, a>`;
   *  if this enum is not set, we will merge them and index `<author, [a, b]>`.
   */
  advancedSiteSearchDataSources: FieldConfig_AdvancedSiteSearchDataSource[];
  /**
   * Field paths for indexing custom attribute from schema.org data. More
   * details of schema.org and its defined types can be found at
   * [schema.org](https://schema.org).
   *
   * It is only used on advanced site search schema.
   *
   * Currently only support full path from root. The full path to a field is
   * constructed by concatenating field names, starting from `_root`, with
   * a period `.` as the delimiter. Examples:
   *
   * * Publish date of the root: _root.datePublished
   * * Publish date of the reviews: _root.review.datePublished
   */
  schemaOrgPaths: string[];
}

/** Field value type in the Schema. */
export enum FieldConfig_FieldType {
  /** FIELD_TYPE_UNSPECIFIED - Field type is unspecified. */
  FIELD_TYPE_UNSPECIFIED = 0,
  /** OBJECT - Field value type is Object. */
  OBJECT = 1,
  /** STRING - Field value type is String. */
  STRING = 2,
  /** NUMBER - Field value type is Number. */
  NUMBER = 3,
  /** INTEGER - Field value type is Integer. */
  INTEGER = 4,
  /** BOOLEAN - Field value type is Boolean. */
  BOOLEAN = 5,
  /**
   * GEOLOCATION - Field value type is Geolocation. Geolocation is expressed as an object
   * with the following keys:
   *
   * * `id`: a string representing the location id
   * * `longitude`: a number representing the longitude coordinate of the
   * location
   * * `latitude`: a number repesenting the latitude coordinate of the
   * location
   * * `address`: a string representing the full address of the location
   *
   * `latitude` and `longitude` must always be provided together. At least one
   * of a) `address` or b) `latitude`-`longitude` pair must be provided.
   */
  GEOLOCATION = 6,
  /**
   * DATETIME - Field value type is Datetime. Datetime can be expressed as either:
   *
   * * a number representing milliseconds-since-the-epoch
   * * a string representing milliseconds-since-the-epoch. e.g.
   * `"1420070400001"`
   * * a string representing the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) date or date and time. e.g.
   * `"2015-01-01"` or `"2015-01-01T12:10:30Z"`
   */
  DATETIME = 7,
  UNRECOGNIZED = -1,
}

export function fieldConfig_FieldTypeFromJSON(object: any): FieldConfig_FieldType {
  switch (object) {
    case 0:
    case "FIELD_TYPE_UNSPECIFIED":
      return FieldConfig_FieldType.FIELD_TYPE_UNSPECIFIED;
    case 1:
    case "OBJECT":
      return FieldConfig_FieldType.OBJECT;
    case 2:
    case "STRING":
      return FieldConfig_FieldType.STRING;
    case 3:
    case "NUMBER":
      return FieldConfig_FieldType.NUMBER;
    case 4:
    case "INTEGER":
      return FieldConfig_FieldType.INTEGER;
    case 5:
    case "BOOLEAN":
      return FieldConfig_FieldType.BOOLEAN;
    case 6:
    case "GEOLOCATION":
      return FieldConfig_FieldType.GEOLOCATION;
    case 7:
    case "DATETIME":
      return FieldConfig_FieldType.DATETIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldConfig_FieldType.UNRECOGNIZED;
  }
}

export function fieldConfig_FieldTypeToJSON(object: FieldConfig_FieldType): string {
  switch (object) {
    case FieldConfig_FieldType.FIELD_TYPE_UNSPECIFIED:
      return "FIELD_TYPE_UNSPECIFIED";
    case FieldConfig_FieldType.OBJECT:
      return "OBJECT";
    case FieldConfig_FieldType.STRING:
      return "STRING";
    case FieldConfig_FieldType.NUMBER:
      return "NUMBER";
    case FieldConfig_FieldType.INTEGER:
      return "INTEGER";
    case FieldConfig_FieldType.BOOLEAN:
      return "BOOLEAN";
    case FieldConfig_FieldType.GEOLOCATION:
      return "GEOLOCATION";
    case FieldConfig_FieldType.DATETIME:
      return "DATETIME";
    case FieldConfig_FieldType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The setting of Indexable options in schema. */
export enum FieldConfig_IndexableOption {
  /** INDEXABLE_OPTION_UNSPECIFIED - Value used when unset. */
  INDEXABLE_OPTION_UNSPECIFIED = 0,
  /** INDEXABLE_ENABLED - Indexable option enabled for a schema field. */
  INDEXABLE_ENABLED = 1,
  /** INDEXABLE_DISABLED - Indexable option disabled for a schema field. */
  INDEXABLE_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function fieldConfig_IndexableOptionFromJSON(object: any): FieldConfig_IndexableOption {
  switch (object) {
    case 0:
    case "INDEXABLE_OPTION_UNSPECIFIED":
      return FieldConfig_IndexableOption.INDEXABLE_OPTION_UNSPECIFIED;
    case 1:
    case "INDEXABLE_ENABLED":
      return FieldConfig_IndexableOption.INDEXABLE_ENABLED;
    case 2:
    case "INDEXABLE_DISABLED":
      return FieldConfig_IndexableOption.INDEXABLE_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldConfig_IndexableOption.UNRECOGNIZED;
  }
}

export function fieldConfig_IndexableOptionToJSON(object: FieldConfig_IndexableOption): string {
  switch (object) {
    case FieldConfig_IndexableOption.INDEXABLE_OPTION_UNSPECIFIED:
      return "INDEXABLE_OPTION_UNSPECIFIED";
    case FieldConfig_IndexableOption.INDEXABLE_ENABLED:
      return "INDEXABLE_ENABLED";
    case FieldConfig_IndexableOption.INDEXABLE_DISABLED:
      return "INDEXABLE_DISABLED";
    case FieldConfig_IndexableOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The status of the dynamic facetable option of a schema field. */
export enum FieldConfig_DynamicFacetableOption {
  /** DYNAMIC_FACETABLE_OPTION_UNSPECIFIED - Value used when unset. */
  DYNAMIC_FACETABLE_OPTION_UNSPECIFIED = 0,
  /** DYNAMIC_FACETABLE_ENABLED - Dynamic facetable option enabled for a schema field. */
  DYNAMIC_FACETABLE_ENABLED = 1,
  /** DYNAMIC_FACETABLE_DISABLED - Dynamic facetable option disabled for a schema field. */
  DYNAMIC_FACETABLE_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function fieldConfig_DynamicFacetableOptionFromJSON(object: any): FieldConfig_DynamicFacetableOption {
  switch (object) {
    case 0:
    case "DYNAMIC_FACETABLE_OPTION_UNSPECIFIED":
      return FieldConfig_DynamicFacetableOption.DYNAMIC_FACETABLE_OPTION_UNSPECIFIED;
    case 1:
    case "DYNAMIC_FACETABLE_ENABLED":
      return FieldConfig_DynamicFacetableOption.DYNAMIC_FACETABLE_ENABLED;
    case 2:
    case "DYNAMIC_FACETABLE_DISABLED":
      return FieldConfig_DynamicFacetableOption.DYNAMIC_FACETABLE_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldConfig_DynamicFacetableOption.UNRECOGNIZED;
  }
}

export function fieldConfig_DynamicFacetableOptionToJSON(object: FieldConfig_DynamicFacetableOption): string {
  switch (object) {
    case FieldConfig_DynamicFacetableOption.DYNAMIC_FACETABLE_OPTION_UNSPECIFIED:
      return "DYNAMIC_FACETABLE_OPTION_UNSPECIFIED";
    case FieldConfig_DynamicFacetableOption.DYNAMIC_FACETABLE_ENABLED:
      return "DYNAMIC_FACETABLE_ENABLED";
    case FieldConfig_DynamicFacetableOption.DYNAMIC_FACETABLE_DISABLED:
      return "DYNAMIC_FACETABLE_DISABLED";
    case FieldConfig_DynamicFacetableOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The setting of Searchable options in schema. */
export enum FieldConfig_SearchableOption {
  /** SEARCHABLE_OPTION_UNSPECIFIED - Value used when unset. */
  SEARCHABLE_OPTION_UNSPECIFIED = 0,
  /** SEARCHABLE_ENABLED - Searchable option enabled for a schema field. */
  SEARCHABLE_ENABLED = 1,
  /** SEARCHABLE_DISABLED - Searchable option disabled for a schema field. */
  SEARCHABLE_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function fieldConfig_SearchableOptionFromJSON(object: any): FieldConfig_SearchableOption {
  switch (object) {
    case 0:
    case "SEARCHABLE_OPTION_UNSPECIFIED":
      return FieldConfig_SearchableOption.SEARCHABLE_OPTION_UNSPECIFIED;
    case 1:
    case "SEARCHABLE_ENABLED":
      return FieldConfig_SearchableOption.SEARCHABLE_ENABLED;
    case 2:
    case "SEARCHABLE_DISABLED":
      return FieldConfig_SearchableOption.SEARCHABLE_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldConfig_SearchableOption.UNRECOGNIZED;
  }
}

export function fieldConfig_SearchableOptionToJSON(object: FieldConfig_SearchableOption): string {
  switch (object) {
    case FieldConfig_SearchableOption.SEARCHABLE_OPTION_UNSPECIFIED:
      return "SEARCHABLE_OPTION_UNSPECIFIED";
    case FieldConfig_SearchableOption.SEARCHABLE_ENABLED:
      return "SEARCHABLE_ENABLED";
    case FieldConfig_SearchableOption.SEARCHABLE_DISABLED:
      return "SEARCHABLE_DISABLED";
    case FieldConfig_SearchableOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The setting of Retrievable options in schema. */
export enum FieldConfig_RetrievableOption {
  /** RETRIEVABLE_OPTION_UNSPECIFIED - Value used when unset. */
  RETRIEVABLE_OPTION_UNSPECIFIED = 0,
  /** RETRIEVABLE_ENABLED - Retrievable option enabled for a schema field. */
  RETRIEVABLE_ENABLED = 1,
  /** RETRIEVABLE_DISABLED - Retrievable option disabled for a schema field. */
  RETRIEVABLE_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function fieldConfig_RetrievableOptionFromJSON(object: any): FieldConfig_RetrievableOption {
  switch (object) {
    case 0:
    case "RETRIEVABLE_OPTION_UNSPECIFIED":
      return FieldConfig_RetrievableOption.RETRIEVABLE_OPTION_UNSPECIFIED;
    case 1:
    case "RETRIEVABLE_ENABLED":
      return FieldConfig_RetrievableOption.RETRIEVABLE_ENABLED;
    case 2:
    case "RETRIEVABLE_DISABLED":
      return FieldConfig_RetrievableOption.RETRIEVABLE_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldConfig_RetrievableOption.UNRECOGNIZED;
  }
}

export function fieldConfig_RetrievableOptionToJSON(object: FieldConfig_RetrievableOption): string {
  switch (object) {
    case FieldConfig_RetrievableOption.RETRIEVABLE_OPTION_UNSPECIFIED:
      return "RETRIEVABLE_OPTION_UNSPECIFIED";
    case FieldConfig_RetrievableOption.RETRIEVABLE_ENABLED:
      return "RETRIEVABLE_ENABLED";
    case FieldConfig_RetrievableOption.RETRIEVABLE_DISABLED:
      return "RETRIEVABLE_DISABLED";
    case FieldConfig_RetrievableOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The setting of Completable options in schema. */
export enum FieldConfig_CompletableOption {
  /** COMPLETABLE_OPTION_UNSPECIFIED - Value used when unset. */
  COMPLETABLE_OPTION_UNSPECIFIED = 0,
  /** COMPLETABLE_ENABLED - Completable option enabled for a schema field. */
  COMPLETABLE_ENABLED = 1,
  /** COMPLETABLE_DISABLED - Completable option disabled for a schema field. */
  COMPLETABLE_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function fieldConfig_CompletableOptionFromJSON(object: any): FieldConfig_CompletableOption {
  switch (object) {
    case 0:
    case "COMPLETABLE_OPTION_UNSPECIFIED":
      return FieldConfig_CompletableOption.COMPLETABLE_OPTION_UNSPECIFIED;
    case 1:
    case "COMPLETABLE_ENABLED":
      return FieldConfig_CompletableOption.COMPLETABLE_ENABLED;
    case 2:
    case "COMPLETABLE_DISABLED":
      return FieldConfig_CompletableOption.COMPLETABLE_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldConfig_CompletableOption.UNRECOGNIZED;
  }
}

export function fieldConfig_CompletableOptionToJSON(object: FieldConfig_CompletableOption): string {
  switch (object) {
    case FieldConfig_CompletableOption.COMPLETABLE_OPTION_UNSPECIFIED:
      return "COMPLETABLE_OPTION_UNSPECIFIED";
    case FieldConfig_CompletableOption.COMPLETABLE_ENABLED:
      return "COMPLETABLE_ENABLED";
    case FieldConfig_CompletableOption.COMPLETABLE_DISABLED:
      return "COMPLETABLE_DISABLED";
    case FieldConfig_CompletableOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Sets the filterable option for schema fields. */
export enum FieldConfig_FilterableOption {
  /** FILTERABLE_OPTION_UNSPECIFIED - Value used when unset. */
  FILTERABLE_OPTION_UNSPECIFIED = 0,
  /** FILTERABLE_ENABLED - Filterable option enabled for a schema field. */
  FILTERABLE_ENABLED = 1,
  /** FILTERABLE_DISABLED - Filterable option disabled for a schema field. */
  FILTERABLE_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function fieldConfig_FilterableOptionFromJSON(object: any): FieldConfig_FilterableOption {
  switch (object) {
    case 0:
    case "FILTERABLE_OPTION_UNSPECIFIED":
      return FieldConfig_FilterableOption.FILTERABLE_OPTION_UNSPECIFIED;
    case 1:
    case "FILTERABLE_ENABLED":
      return FieldConfig_FilterableOption.FILTERABLE_ENABLED;
    case 2:
    case "FILTERABLE_DISABLED":
      return FieldConfig_FilterableOption.FILTERABLE_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldConfig_FilterableOption.UNRECOGNIZED;
  }
}

export function fieldConfig_FilterableOptionToJSON(object: FieldConfig_FilterableOption): string {
  switch (object) {
    case FieldConfig_FilterableOption.FILTERABLE_OPTION_UNSPECIFIED:
      return "FILTERABLE_OPTION_UNSPECIFIED";
    case FieldConfig_FilterableOption.FILTERABLE_ENABLED:
      return "FILTERABLE_ENABLED";
    case FieldConfig_FilterableOption.FILTERABLE_DISABLED:
      return "FILTERABLE_DISABLED";
    case FieldConfig_FilterableOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Optional source of the advanced site search field. */
export enum FieldConfig_AdvancedSiteSearchDataSource {
  /** ADVANCED_SITE_SEARCH_DATA_SOURCE_UNSPECIFIED - Value used when unset. */
  ADVANCED_SITE_SEARCH_DATA_SOURCE_UNSPECIFIED = 0,
  /** METATAGS - Retrieve value from meta tag. */
  METATAGS = 1,
  /** PAGEMAP - Retrieve value from page map. */
  PAGEMAP = 2,
  /**
   * URI_PATTERN_MAPPING - Retrieve value from the attributes set by
   * [SiteSearchEngineService.SetUriPatternDocumentData][google.cloud.discoveryengine.v1alpha.SiteSearchEngineService.SetUriPatternDocumentData]
   * API.
   */
  URI_PATTERN_MAPPING = 3,
  /** SCHEMA_ORG - Retrieve value from schema.org data. */
  SCHEMA_ORG = 4,
  UNRECOGNIZED = -1,
}

export function fieldConfig_AdvancedSiteSearchDataSourceFromJSON(
  object: any,
): FieldConfig_AdvancedSiteSearchDataSource {
  switch (object) {
    case 0:
    case "ADVANCED_SITE_SEARCH_DATA_SOURCE_UNSPECIFIED":
      return FieldConfig_AdvancedSiteSearchDataSource.ADVANCED_SITE_SEARCH_DATA_SOURCE_UNSPECIFIED;
    case 1:
    case "METATAGS":
      return FieldConfig_AdvancedSiteSearchDataSource.METATAGS;
    case 2:
    case "PAGEMAP":
      return FieldConfig_AdvancedSiteSearchDataSource.PAGEMAP;
    case 3:
    case "URI_PATTERN_MAPPING":
      return FieldConfig_AdvancedSiteSearchDataSource.URI_PATTERN_MAPPING;
    case 4:
    case "SCHEMA_ORG":
      return FieldConfig_AdvancedSiteSearchDataSource.SCHEMA_ORG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FieldConfig_AdvancedSiteSearchDataSource.UNRECOGNIZED;
  }
}

export function fieldConfig_AdvancedSiteSearchDataSourceToJSON(
  object: FieldConfig_AdvancedSiteSearchDataSource,
): string {
  switch (object) {
    case FieldConfig_AdvancedSiteSearchDataSource.ADVANCED_SITE_SEARCH_DATA_SOURCE_UNSPECIFIED:
      return "ADVANCED_SITE_SEARCH_DATA_SOURCE_UNSPECIFIED";
    case FieldConfig_AdvancedSiteSearchDataSource.METATAGS:
      return "METATAGS";
    case FieldConfig_AdvancedSiteSearchDataSource.PAGEMAP:
      return "PAGEMAP";
    case FieldConfig_AdvancedSiteSearchDataSource.URI_PATTERN_MAPPING:
      return "URI_PATTERN_MAPPING";
    case FieldConfig_AdvancedSiteSearchDataSource.SCHEMA_ORG:
      return "SCHEMA_ORG";
    case FieldConfig_AdvancedSiteSearchDataSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseSchema(): Schema {
  return { structSchema: undefined, jsonSchema: undefined, name: "", fieldConfigs: [] };
}

export const Schema: MessageFns<Schema> = {
  encode(message: Schema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.structSchema !== undefined) {
      Struct.encode(Struct.wrap(message.structSchema), writer.uint32(18).fork()).join();
    }
    if (message.jsonSchema !== undefined) {
      writer.uint32(26).string(message.jsonSchema);
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.fieldConfigs) {
      FieldConfig.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.structSchema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.jsonSchema = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fieldConfigs.push(FieldConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema {
    return {
      structSchema: isObject(object.structSchema) ? object.structSchema : undefined,
      jsonSchema: isSet(object.jsonSchema) ? globalThis.String(object.jsonSchema) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fieldConfigs: globalThis.Array.isArray(object?.fieldConfigs)
        ? object.fieldConfigs.map((e: any) => FieldConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Schema): unknown {
    const obj: any = {};
    if (message.structSchema !== undefined) {
      obj.structSchema = message.structSchema;
    }
    if (message.jsonSchema !== undefined) {
      obj.jsonSchema = message.jsonSchema;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fieldConfigs?.length) {
      obj.fieldConfigs = message.fieldConfigs.map((e) => FieldConfig.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Schema>): Schema {
    return Schema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Schema>): Schema {
    const message = createBaseSchema();
    message.structSchema = object.structSchema ?? undefined;
    message.jsonSchema = object.jsonSchema ?? undefined;
    message.name = object.name ?? "";
    message.fieldConfigs = object.fieldConfigs?.map((e) => FieldConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFieldConfig(): FieldConfig {
  return {
    fieldPath: "",
    fieldType: 0,
    indexableOption: 0,
    dynamicFacetableOption: 0,
    searchableOption: 0,
    retrievableOption: 0,
    completableOption: 0,
    recsFilterableOption: 0,
    keyPropertyType: "",
    advancedSiteSearchDataSources: [],
    schemaOrgPaths: [],
  };
}

export const FieldConfig: MessageFns<FieldConfig> = {
  encode(message: FieldConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldPath !== "") {
      writer.uint32(10).string(message.fieldPath);
    }
    if (message.fieldType !== 0) {
      writer.uint32(16).int32(message.fieldType);
    }
    if (message.indexableOption !== 0) {
      writer.uint32(24).int32(message.indexableOption);
    }
    if (message.dynamicFacetableOption !== 0) {
      writer.uint32(32).int32(message.dynamicFacetableOption);
    }
    if (message.searchableOption !== 0) {
      writer.uint32(40).int32(message.searchableOption);
    }
    if (message.retrievableOption !== 0) {
      writer.uint32(48).int32(message.retrievableOption);
    }
    if (message.completableOption !== 0) {
      writer.uint32(64).int32(message.completableOption);
    }
    if (message.recsFilterableOption !== 0) {
      writer.uint32(72).int32(message.recsFilterableOption);
    }
    if (message.keyPropertyType !== "") {
      writer.uint32(58).string(message.keyPropertyType);
    }
    writer.uint32(82).fork();
    for (const v of message.advancedSiteSearchDataSources) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.schemaOrgPaths) {
      writer.uint32(90).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldPath = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fieldType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.indexableOption = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.dynamicFacetableOption = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.searchableOption = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.retrievableOption = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.completableOption = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.recsFilterableOption = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.keyPropertyType = reader.string();
          continue;
        case 10:
          if (tag === 80) {
            message.advancedSiteSearchDataSources.push(reader.int32() as any);

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.advancedSiteSearchDataSources.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.schemaOrgPaths.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldConfig {
    return {
      fieldPath: isSet(object.fieldPath) ? globalThis.String(object.fieldPath) : "",
      fieldType: isSet(object.fieldType) ? fieldConfig_FieldTypeFromJSON(object.fieldType) : 0,
      indexableOption: isSet(object.indexableOption) ? fieldConfig_IndexableOptionFromJSON(object.indexableOption) : 0,
      dynamicFacetableOption: isSet(object.dynamicFacetableOption)
        ? fieldConfig_DynamicFacetableOptionFromJSON(object.dynamicFacetableOption)
        : 0,
      searchableOption: isSet(object.searchableOption)
        ? fieldConfig_SearchableOptionFromJSON(object.searchableOption)
        : 0,
      retrievableOption: isSet(object.retrievableOption)
        ? fieldConfig_RetrievableOptionFromJSON(object.retrievableOption)
        : 0,
      completableOption: isSet(object.completableOption)
        ? fieldConfig_CompletableOptionFromJSON(object.completableOption)
        : 0,
      recsFilterableOption: isSet(object.recsFilterableOption)
        ? fieldConfig_FilterableOptionFromJSON(object.recsFilterableOption)
        : 0,
      keyPropertyType: isSet(object.keyPropertyType) ? globalThis.String(object.keyPropertyType) : "",
      advancedSiteSearchDataSources: globalThis.Array.isArray(object?.advancedSiteSearchDataSources)
        ? object.advancedSiteSearchDataSources.map((e: any) => fieldConfig_AdvancedSiteSearchDataSourceFromJSON(e))
        : [],
      schemaOrgPaths: globalThis.Array.isArray(object?.schemaOrgPaths)
        ? object.schemaOrgPaths.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: FieldConfig): unknown {
    const obj: any = {};
    if (message.fieldPath !== "") {
      obj.fieldPath = message.fieldPath;
    }
    if (message.fieldType !== 0) {
      obj.fieldType = fieldConfig_FieldTypeToJSON(message.fieldType);
    }
    if (message.indexableOption !== 0) {
      obj.indexableOption = fieldConfig_IndexableOptionToJSON(message.indexableOption);
    }
    if (message.dynamicFacetableOption !== 0) {
      obj.dynamicFacetableOption = fieldConfig_DynamicFacetableOptionToJSON(message.dynamicFacetableOption);
    }
    if (message.searchableOption !== 0) {
      obj.searchableOption = fieldConfig_SearchableOptionToJSON(message.searchableOption);
    }
    if (message.retrievableOption !== 0) {
      obj.retrievableOption = fieldConfig_RetrievableOptionToJSON(message.retrievableOption);
    }
    if (message.completableOption !== 0) {
      obj.completableOption = fieldConfig_CompletableOptionToJSON(message.completableOption);
    }
    if (message.recsFilterableOption !== 0) {
      obj.recsFilterableOption = fieldConfig_FilterableOptionToJSON(message.recsFilterableOption);
    }
    if (message.keyPropertyType !== "") {
      obj.keyPropertyType = message.keyPropertyType;
    }
    if (message.advancedSiteSearchDataSources?.length) {
      obj.advancedSiteSearchDataSources = message.advancedSiteSearchDataSources.map((e) =>
        fieldConfig_AdvancedSiteSearchDataSourceToJSON(e)
      );
    }
    if (message.schemaOrgPaths?.length) {
      obj.schemaOrgPaths = message.schemaOrgPaths;
    }
    return obj;
  },

  create(base?: DeepPartial<FieldConfig>): FieldConfig {
    return FieldConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FieldConfig>): FieldConfig {
    const message = createBaseFieldConfig();
    message.fieldPath = object.fieldPath ?? "";
    message.fieldType = object.fieldType ?? 0;
    message.indexableOption = object.indexableOption ?? 0;
    message.dynamicFacetableOption = object.dynamicFacetableOption ?? 0;
    message.searchableOption = object.searchableOption ?? 0;
    message.retrievableOption = object.retrievableOption ?? 0;
    message.completableOption = object.completableOption ?? 0;
    message.recsFilterableOption = object.recsFilterableOption ?? 0;
    message.keyPropertyType = object.keyPropertyType ?? "";
    message.advancedSiteSearchDataSources = object.advancedSiteSearchDataSources?.map((e) => e) || [];
    message.schemaOrgPaths = object.schemaOrgPaths?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
