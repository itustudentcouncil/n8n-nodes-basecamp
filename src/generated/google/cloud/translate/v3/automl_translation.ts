// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/translate/v3/automl_translation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import {
  GcsInputSource,
  GcsOutputDestination,
  OperationState,
  operationStateFromJSON,
  operationStateToJSON,
} from "./common.js";

export const protobufPackage = "google.cloud.translation.v3";

/** Request message for ImportData. */
export interface ImportDataRequest {
  /**
   * Required. Name of the dataset. In form of
   * `projects/{project-number-or-id}/locations/{location-id}/datasets/{dataset-id}`
   */
  dataset: string;
  /** Required. The config for the input content. */
  inputConfig: DatasetInputConfig | undefined;
}

/** Input configuration for datasets. */
export interface DatasetInputConfig {
  /** Files containing the sentence pairs to be imported to the dataset. */
  inputFiles: DatasetInputConfig_InputFile[];
}

/** An input file. */
export interface DatasetInputConfig_InputFile {
  /**
   * Optional. Usage of the file contents. Options are TRAIN|VALIDATION|TEST,
   * or UNASSIGNED (by default) for auto split.
   */
  usage: string;
  /** Google Cloud Storage file source. */
  gcsSource?: GcsInputSource | undefined;
}

/** Metadata of import data operation. */
export interface ImportDataMetadata {
  /** The current state of the operation. */
  state: OperationState;
  /** The creation time of the operation. */
  createTime:
    | Date
    | undefined;
  /** The last update time of the operation. */
  updateTime:
    | Date
    | undefined;
  /** Only populated when operation doesn't succeed. */
  error: Status | undefined;
}

/** Request message for ExportData. */
export interface ExportDataRequest {
  /**
   * Required. Name of the dataset. In form of
   * `projects/{project-number-or-id}/locations/{location-id}/datasets/{dataset-id}`
   */
  dataset: string;
  /** Required. The config for the output content. */
  outputConfig: DatasetOutputConfig | undefined;
}

/** Output configuration for datasets. */
export interface DatasetOutputConfig {
  /** Google Cloud Storage destination to write the output. */
  gcsDestination?: GcsOutputDestination | undefined;
}

/** Metadata of export data operation. */
export interface ExportDataMetadata {
  /** The current state of the operation. */
  state: OperationState;
  /** The creation time of the operation. */
  createTime:
    | Date
    | undefined;
  /** The last update time of the operation. */
  updateTime:
    | Date
    | undefined;
  /** Only populated when operation doesn't succeed. */
  error: Status | undefined;
}

/** Request message for DeleteDataset. */
export interface DeleteDatasetRequest {
  /** Required. The name of the dataset to delete. */
  name: string;
}

/** Metadata of delete dataset operation. */
export interface DeleteDatasetMetadata {
  /** The current state of the operation. */
  state: OperationState;
  /** The creation time of the operation. */
  createTime:
    | Date
    | undefined;
  /** The last update time of the operation. */
  updateTime:
    | Date
    | undefined;
  /** Only populated when operation doesn't succeed. */
  error: Status | undefined;
}

/** Request message for GetDataset. */
export interface GetDatasetRequest {
  /** Required. The resource name of the dataset to retrieve. */
  name: string;
}

/** Request message for ListDatasets. */
export interface ListDatasetsRequest {
  /**
   * Required. Name of the parent project. In form of
   * `projects/{project-number-or-id}/locations/{location-id}`
   */
  parent: string;
  /**
   * Optional. Requested page size. The server can return fewer results than
   * requested.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results for the server to return.
   * Typically obtained from next_page_token field in the response of a
   * ListDatasets call.
   */
  pageToken: string;
}

/** Response message for ListDatasets. */
export interface ListDatasetsResponse {
  /** The datasets read. */
  datasets: Dataset[];
  /**
   * A token to retrieve next page of results.
   * Pass this token to the page_token field in the ListDatasetsRequest to
   * obtain the corresponding page.
   */
  nextPageToken: string;
}

/** Request message for CreateDataset. */
export interface CreateDatasetRequest {
  /** Required. The project name. */
  parent: string;
  /** Required. The Dataset to create. */
  dataset: Dataset | undefined;
}

/** Metadata of create dataset operation. */
export interface CreateDatasetMetadata {
  /** The current state of the operation. */
  state: OperationState;
  /** The creation time of the operation. */
  createTime:
    | Date
    | undefined;
  /** The last update time of the operation. */
  updateTime:
    | Date
    | undefined;
  /** Only populated when operation doesn't succeed. */
  error: Status | undefined;
}

/** Request message for ListExamples. */
export interface ListExamplesRequest {
  /**
   * Required. Name of the parent dataset. In form of
   * `projects/{project-number-or-id}/locations/{location-id}/datasets/{dataset-id}`
   */
  parent: string;
  /**
   * Optional. An expression for filtering the examples that will be returned.
   * Example filter:
   * * `usage=TRAIN`
   */
  filter: string;
  /**
   * Optional. Requested page size. The server can return fewer results than
   * requested.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results for the server to return.
   * Typically obtained from next_page_token field in the response of a
   * ListExamples call.
   */
  pageToken: string;
}

/** Response message for ListExamples. */
export interface ListExamplesResponse {
  /** The sentence pairs. */
  examples: Example[];
  /**
   * A token to retrieve next page of results.
   * Pass this token to the page_token field in the ListExamplesRequest to
   * obtain the corresponding page.
   */
  nextPageToken: string;
}

/** A sentence pair. */
export interface Example {
  /**
   * Output only. The resource name of the example, in form of
   * `projects/{project-number-or-id}/locations/{location_id}/datasets/{dataset_id}/examples/{example_id}`
   */
  name: string;
  /** Sentence in source language. */
  sourceText: string;
  /** Sentence in target language. */
  targetText: string;
  /** Output only. Usage of the sentence pair. Options are TRAIN|VALIDATION|TEST. */
  usage: string;
}

/** Response message for BatchTransferResources. */
export interface BatchTransferResourcesResponse {
  /** Responses of the transfer for individual resources. */
  responses: BatchTransferResourcesResponse_TransferResourceResponse[];
}

/** Transfer response for a single resource. */
export interface BatchTransferResourcesResponse_TransferResourceResponse {
  /** Full name of the resource to transfer as specified in the request. */
  source: string;
  /**
   * Full name of the new resource successfully transferred from the source
   * hosted by Translation API. Target will be empty if the transfer failed.
   */
  target: string;
  /** The error result in case of failure. */
  error: Status | undefined;
}

/**
 * A dataset that hosts the examples (sentence pairs) used for translation
 * models.
 */
export interface Dataset {
  /**
   * The resource name of the dataset, in form of
   * `projects/{project-number-or-id}/locations/{location_id}/datasets/{dataset_id}`
   */
  name: string;
  /**
   * The name of the dataset to show in the interface. The name can be
   * up to 32 characters long and can consist only of ASCII Latin letters A-Z
   * and a-z, underscores (_), and ASCII digits 0-9.
   */
  displayName: string;
  /** The BCP-47 language code of the source language. */
  sourceLanguageCode: string;
  /** The BCP-47 language code of the target language. */
  targetLanguageCode: string;
  /** Output only. The number of examples in the dataset. */
  exampleCount: number;
  /** Output only. Number of training examples (sentence pairs). */
  trainExampleCount: number;
  /** Output only. Number of validation examples (sentence pairs). */
  validateExampleCount: number;
  /** Output only. Number of test examples (sentence pairs). */
  testExampleCount: number;
  /** Output only. Timestamp when this dataset was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Timestamp when this dataset was last updated. */
  updateTime: Date | undefined;
}

/** Request message for CreateModel. */
export interface CreateModelRequest {
  /**
   * Required. The project name, in form of
   * `projects/{project}/locations/{location}`
   */
  parent: string;
  /** Required. The Model to create. */
  model: Model | undefined;
}

/** Metadata of create model operation. */
export interface CreateModelMetadata {
  /** The current state of the operation. */
  state: OperationState;
  /** The creation time of the operation. */
  createTime:
    | Date
    | undefined;
  /** The last update time of the operation. */
  updateTime:
    | Date
    | undefined;
  /** Only populated when operation doesn't succeed. */
  error: Status | undefined;
}

/** Request message for ListModels. */
export interface ListModelsRequest {
  /**
   * Required. Name of the parent project. In form of
   * `projects/{project-number-or-id}/locations/{location-id}`
   */
  parent: string;
  /**
   * Optional. An expression for filtering the models that will be returned.
   * Supported filter:
   * `dataset_id=${dataset_id}`
   */
  filter: string;
  /**
   * Optional. Requested page size. The server can return fewer results than
   * requested.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results for the server to return.
   * Typically obtained from next_page_token field in the response of a
   * ListModels call.
   */
  pageToken: string;
}

/** Response message for ListModels. */
export interface ListModelsResponse {
  /** The models read. */
  models: Model[];
  /**
   * A token to retrieve next page of results.
   * Pass this token to the page_token field in the ListModelsRequest to
   * obtain the corresponding page.
   */
  nextPageToken: string;
}

/** Request message for GetModel. */
export interface GetModelRequest {
  /** Required. The resource name of the model to retrieve. */
  name: string;
}

/** Request message for DeleteModel. */
export interface DeleteModelRequest {
  /** Required. The name of the model to delete. */
  name: string;
}

/** Metadata of delete model operation. */
export interface DeleteModelMetadata {
  /** The current state of the operation. */
  state: OperationState;
  /** The creation time of the operation. */
  createTime:
    | Date
    | undefined;
  /** The last update time of the operation. */
  updateTime:
    | Date
    | undefined;
  /** Only populated when operation doesn't succeed. */
  error: Status | undefined;
}

/** A trained translation model. */
export interface Model {
  /**
   * The resource name of the model, in form of
   * `projects/{project-number-or-id}/locations/{location_id}/models/{model_id}`
   */
  name: string;
  /**
   * The name of the model to show in the interface. The name can be
   * up to 32 characters long and can consist only of ASCII Latin letters A-Z
   * and a-z, underscores (_), and ASCII digits 0-9.
   */
  displayName: string;
  /**
   * The dataset from which the model is trained, in form of
   * `projects/{project-number-or-id}/locations/{location_id}/datasets/{dataset_id}`
   */
  dataset: string;
  /** Output only. The BCP-47 language code of the source language. */
  sourceLanguageCode: string;
  /** Output only. The BCP-47 language code of the target language. */
  targetLanguageCode: string;
  /** Output only. Number of examples (sentence pairs) used to train the model. */
  trainExampleCount: number;
  /**
   * Output only. Number of examples (sentence pairs) used to validate the
   * model.
   */
  validateExampleCount: number;
  /** Output only. Number of examples (sentence pairs) used to test the model. */
  testExampleCount: number;
  /**
   * Output only. Timestamp when the model resource was created, which is also
   * when the training started.
   */
  createTime:
    | Date
    | undefined;
  /** Output only. Timestamp when this model was last updated. */
  updateTime: Date | undefined;
}

function createBaseImportDataRequest(): ImportDataRequest {
  return { dataset: "", inputConfig: undefined };
}

export const ImportDataRequest: MessageFns<ImportDataRequest> = {
  encode(message: ImportDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataset !== "") {
      writer.uint32(10).string(message.dataset);
    }
    if (message.inputConfig !== undefined) {
      DatasetInputConfig.encode(message.inputConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputConfig = DatasetInputConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportDataRequest {
    return {
      dataset: isSet(object.dataset) ? globalThis.String(object.dataset) : "",
      inputConfig: isSet(object.inputConfig) ? DatasetInputConfig.fromJSON(object.inputConfig) : undefined,
    };
  },

  toJSON(message: ImportDataRequest): unknown {
    const obj: any = {};
    if (message.dataset !== "") {
      obj.dataset = message.dataset;
    }
    if (message.inputConfig !== undefined) {
      obj.inputConfig = DatasetInputConfig.toJSON(message.inputConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportDataRequest>): ImportDataRequest {
    return ImportDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportDataRequest>): ImportDataRequest {
    const message = createBaseImportDataRequest();
    message.dataset = object.dataset ?? "";
    message.inputConfig = (object.inputConfig !== undefined && object.inputConfig !== null)
      ? DatasetInputConfig.fromPartial(object.inputConfig)
      : undefined;
    return message;
  },
};

function createBaseDatasetInputConfig(): DatasetInputConfig {
  return { inputFiles: [] };
}

export const DatasetInputConfig: MessageFns<DatasetInputConfig> = {
  encode(message: DatasetInputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inputFiles) {
      DatasetInputConfig_InputFile.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetInputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputFiles.push(DatasetInputConfig_InputFile.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetInputConfig {
    return {
      inputFiles: globalThis.Array.isArray(object?.inputFiles)
        ? object.inputFiles.map((e: any) => DatasetInputConfig_InputFile.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DatasetInputConfig): unknown {
    const obj: any = {};
    if (message.inputFiles?.length) {
      obj.inputFiles = message.inputFiles.map((e) => DatasetInputConfig_InputFile.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DatasetInputConfig>): DatasetInputConfig {
    return DatasetInputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatasetInputConfig>): DatasetInputConfig {
    const message = createBaseDatasetInputConfig();
    message.inputFiles = object.inputFiles?.map((e) => DatasetInputConfig_InputFile.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDatasetInputConfig_InputFile(): DatasetInputConfig_InputFile {
  return { usage: "", gcsSource: undefined };
}

export const DatasetInputConfig_InputFile: MessageFns<DatasetInputConfig_InputFile> = {
  encode(message: DatasetInputConfig_InputFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.usage !== "") {
      writer.uint32(18).string(message.usage);
    }
    if (message.gcsSource !== undefined) {
      GcsInputSource.encode(message.gcsSource, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetInputConfig_InputFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetInputConfig_InputFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.usage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gcsSource = GcsInputSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetInputConfig_InputFile {
    return {
      usage: isSet(object.usage) ? globalThis.String(object.usage) : "",
      gcsSource: isSet(object.gcsSource) ? GcsInputSource.fromJSON(object.gcsSource) : undefined,
    };
  },

  toJSON(message: DatasetInputConfig_InputFile): unknown {
    const obj: any = {};
    if (message.usage !== "") {
      obj.usage = message.usage;
    }
    if (message.gcsSource !== undefined) {
      obj.gcsSource = GcsInputSource.toJSON(message.gcsSource);
    }
    return obj;
  },

  create(base?: DeepPartial<DatasetInputConfig_InputFile>): DatasetInputConfig_InputFile {
    return DatasetInputConfig_InputFile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatasetInputConfig_InputFile>): DatasetInputConfig_InputFile {
    const message = createBaseDatasetInputConfig_InputFile();
    message.usage = object.usage ?? "";
    message.gcsSource = (object.gcsSource !== undefined && object.gcsSource !== null)
      ? GcsInputSource.fromPartial(object.gcsSource)
      : undefined;
    return message;
  },
};

function createBaseImportDataMetadata(): ImportDataMetadata {
  return { state: 0, createTime: undefined, updateTime: undefined, error: undefined };
}

export const ImportDataMetadata: MessageFns<ImportDataMetadata> = {
  encode(message: ImportDataMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportDataMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportDataMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportDataMetadata {
    return {
      state: isSet(object.state) ? operationStateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ImportDataMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = operationStateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportDataMetadata>): ImportDataMetadata {
    return ImportDataMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportDataMetadata>): ImportDataMetadata {
    const message = createBaseImportDataMetadata();
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseExportDataRequest(): ExportDataRequest {
  return { dataset: "", outputConfig: undefined };
}

export const ExportDataRequest: MessageFns<ExportDataRequest> = {
  encode(message: ExportDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataset !== "") {
      writer.uint32(10).string(message.dataset);
    }
    if (message.outputConfig !== undefined) {
      DatasetOutputConfig.encode(message.outputConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outputConfig = DatasetOutputConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportDataRequest {
    return {
      dataset: isSet(object.dataset) ? globalThis.String(object.dataset) : "",
      outputConfig: isSet(object.outputConfig) ? DatasetOutputConfig.fromJSON(object.outputConfig) : undefined,
    };
  },

  toJSON(message: ExportDataRequest): unknown {
    const obj: any = {};
    if (message.dataset !== "") {
      obj.dataset = message.dataset;
    }
    if (message.outputConfig !== undefined) {
      obj.outputConfig = DatasetOutputConfig.toJSON(message.outputConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportDataRequest>): ExportDataRequest {
    return ExportDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportDataRequest>): ExportDataRequest {
    const message = createBaseExportDataRequest();
    message.dataset = object.dataset ?? "";
    message.outputConfig = (object.outputConfig !== undefined && object.outputConfig !== null)
      ? DatasetOutputConfig.fromPartial(object.outputConfig)
      : undefined;
    return message;
  },
};

function createBaseDatasetOutputConfig(): DatasetOutputConfig {
  return { gcsDestination: undefined };
}

export const DatasetOutputConfig: MessageFns<DatasetOutputConfig> = {
  encode(message: DatasetOutputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsDestination !== undefined) {
      GcsOutputDestination.encode(message.gcsDestination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatasetOutputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatasetOutputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsDestination = GcsOutputDestination.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatasetOutputConfig {
    return {
      gcsDestination: isSet(object.gcsDestination) ? GcsOutputDestination.fromJSON(object.gcsDestination) : undefined,
    };
  },

  toJSON(message: DatasetOutputConfig): unknown {
    const obj: any = {};
    if (message.gcsDestination !== undefined) {
      obj.gcsDestination = GcsOutputDestination.toJSON(message.gcsDestination);
    }
    return obj;
  },

  create(base?: DeepPartial<DatasetOutputConfig>): DatasetOutputConfig {
    return DatasetOutputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatasetOutputConfig>): DatasetOutputConfig {
    const message = createBaseDatasetOutputConfig();
    message.gcsDestination = (object.gcsDestination !== undefined && object.gcsDestination !== null)
      ? GcsOutputDestination.fromPartial(object.gcsDestination)
      : undefined;
    return message;
  },
};

function createBaseExportDataMetadata(): ExportDataMetadata {
  return { state: 0, createTime: undefined, updateTime: undefined, error: undefined };
}

export const ExportDataMetadata: MessageFns<ExportDataMetadata> = {
  encode(message: ExportDataMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportDataMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportDataMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportDataMetadata {
    return {
      state: isSet(object.state) ? operationStateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ExportDataMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = operationStateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportDataMetadata>): ExportDataMetadata {
    return ExportDataMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportDataMetadata>): ExportDataMetadata {
    const message = createBaseExportDataMetadata();
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseDeleteDatasetRequest(): DeleteDatasetRequest {
  return { name: "" };
}

export const DeleteDatasetRequest: MessageFns<DeleteDatasetRequest> = {
  encode(message: DeleteDatasetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDatasetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDatasetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDatasetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteDatasetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDatasetRequest>): DeleteDatasetRequest {
    return DeleteDatasetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDatasetRequest>): DeleteDatasetRequest {
    const message = createBaseDeleteDatasetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteDatasetMetadata(): DeleteDatasetMetadata {
  return { state: 0, createTime: undefined, updateTime: undefined, error: undefined };
}

export const DeleteDatasetMetadata: MessageFns<DeleteDatasetMetadata> = {
  encode(message: DeleteDatasetMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDatasetMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDatasetMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDatasetMetadata {
    return {
      state: isSet(object.state) ? operationStateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: DeleteDatasetMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = operationStateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDatasetMetadata>): DeleteDatasetMetadata {
    return DeleteDatasetMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDatasetMetadata>): DeleteDatasetMetadata {
    const message = createBaseDeleteDatasetMetadata();
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseGetDatasetRequest(): GetDatasetRequest {
  return { name: "" };
}

export const GetDatasetRequest: MessageFns<GetDatasetRequest> = {
  encode(message: GetDatasetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatasetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatasetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatasetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDatasetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDatasetRequest>): GetDatasetRequest {
    return GetDatasetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDatasetRequest>): GetDatasetRequest {
    const message = createBaseGetDatasetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListDatasetsRequest(): ListDatasetsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListDatasetsRequest: MessageFns<ListDatasetsRequest> = {
  encode(message: ListDatasetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatasetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatasetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatasetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListDatasetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDatasetsRequest>): ListDatasetsRequest {
    return ListDatasetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDatasetsRequest>): ListDatasetsRequest {
    const message = createBaseListDatasetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListDatasetsResponse(): ListDatasetsResponse {
  return { datasets: [], nextPageToken: "" };
}

export const ListDatasetsResponse: MessageFns<ListDatasetsResponse> = {
  encode(message: ListDatasetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.datasets) {
      Dataset.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatasetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatasetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datasets.push(Dataset.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatasetsResponse {
    return {
      datasets: globalThis.Array.isArray(object?.datasets) ? object.datasets.map((e: any) => Dataset.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDatasetsResponse): unknown {
    const obj: any = {};
    if (message.datasets?.length) {
      obj.datasets = message.datasets.map((e) => Dataset.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDatasetsResponse>): ListDatasetsResponse {
    return ListDatasetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDatasetsResponse>): ListDatasetsResponse {
    const message = createBaseListDatasetsResponse();
    message.datasets = object.datasets?.map((e) => Dataset.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateDatasetRequest(): CreateDatasetRequest {
  return { parent: "", dataset: undefined };
}

export const CreateDatasetRequest: MessageFns<CreateDatasetRequest> = {
  encode(message: CreateDatasetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.dataset !== undefined) {
      Dataset.encode(message.dataset, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDatasetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDatasetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataset = Dataset.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDatasetRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      dataset: isSet(object.dataset) ? Dataset.fromJSON(object.dataset) : undefined,
    };
  },

  toJSON(message: CreateDatasetRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.dataset !== undefined) {
      obj.dataset = Dataset.toJSON(message.dataset);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDatasetRequest>): CreateDatasetRequest {
    return CreateDatasetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDatasetRequest>): CreateDatasetRequest {
    const message = createBaseCreateDatasetRequest();
    message.parent = object.parent ?? "";
    message.dataset = (object.dataset !== undefined && object.dataset !== null)
      ? Dataset.fromPartial(object.dataset)
      : undefined;
    return message;
  },
};

function createBaseCreateDatasetMetadata(): CreateDatasetMetadata {
  return { state: 0, createTime: undefined, updateTime: undefined, error: undefined };
}

export const CreateDatasetMetadata: MessageFns<CreateDatasetMetadata> = {
  encode(message: CreateDatasetMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDatasetMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDatasetMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDatasetMetadata {
    return {
      state: isSet(object.state) ? operationStateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: CreateDatasetMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = operationStateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDatasetMetadata>): CreateDatasetMetadata {
    return CreateDatasetMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDatasetMetadata>): CreateDatasetMetadata {
    const message = createBaseCreateDatasetMetadata();
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseListExamplesRequest(): ListExamplesRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListExamplesRequest: MessageFns<ListExamplesRequest> = {
  encode(message: ListExamplesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExamplesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExamplesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExamplesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListExamplesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListExamplesRequest>): ListExamplesRequest {
    return ListExamplesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListExamplesRequest>): ListExamplesRequest {
    const message = createBaseListExamplesRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListExamplesResponse(): ListExamplesResponse {
  return { examples: [], nextPageToken: "" };
}

export const ListExamplesResponse: MessageFns<ListExamplesResponse> = {
  encode(message: ListExamplesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.examples) {
      Example.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExamplesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExamplesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.examples.push(Example.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExamplesResponse {
    return {
      examples: globalThis.Array.isArray(object?.examples) ? object.examples.map((e: any) => Example.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListExamplesResponse): unknown {
    const obj: any = {};
    if (message.examples?.length) {
      obj.examples = message.examples.map((e) => Example.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListExamplesResponse>): ListExamplesResponse {
    return ListExamplesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListExamplesResponse>): ListExamplesResponse {
    const message = createBaseListExamplesResponse();
    message.examples = object.examples?.map((e) => Example.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseExample(): Example {
  return { name: "", sourceText: "", targetText: "", usage: "" };
}

export const Example: MessageFns<Example> = {
  encode(message: Example, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.sourceText !== "") {
      writer.uint32(18).string(message.sourceText);
    }
    if (message.targetText !== "") {
      writer.uint32(26).string(message.targetText);
    }
    if (message.usage !== "") {
      writer.uint32(34).string(message.usage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Example {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceText = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetText = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.usage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Example {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sourceText: isSet(object.sourceText) ? globalThis.String(object.sourceText) : "",
      targetText: isSet(object.targetText) ? globalThis.String(object.targetText) : "",
      usage: isSet(object.usage) ? globalThis.String(object.usage) : "",
    };
  },

  toJSON(message: Example): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sourceText !== "") {
      obj.sourceText = message.sourceText;
    }
    if (message.targetText !== "") {
      obj.targetText = message.targetText;
    }
    if (message.usage !== "") {
      obj.usage = message.usage;
    }
    return obj;
  },

  create(base?: DeepPartial<Example>): Example {
    return Example.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Example>): Example {
    const message = createBaseExample();
    message.name = object.name ?? "";
    message.sourceText = object.sourceText ?? "";
    message.targetText = object.targetText ?? "";
    message.usage = object.usage ?? "";
    return message;
  },
};

function createBaseBatchTransferResourcesResponse(): BatchTransferResourcesResponse {
  return { responses: [] };
}

export const BatchTransferResourcesResponse: MessageFns<BatchTransferResourcesResponse> = {
  encode(message: BatchTransferResourcesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.responses) {
      BatchTransferResourcesResponse_TransferResourceResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTransferResourcesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTransferResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.responses.push(
            BatchTransferResourcesResponse_TransferResourceResponse.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTransferResourcesResponse {
    return {
      responses: globalThis.Array.isArray(object?.responses)
        ? object.responses.map((e: any) => BatchTransferResourcesResponse_TransferResourceResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchTransferResourcesResponse): unknown {
    const obj: any = {};
    if (message.responses?.length) {
      obj.responses = message.responses.map((e) => BatchTransferResourcesResponse_TransferResourceResponse.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchTransferResourcesResponse>): BatchTransferResourcesResponse {
    return BatchTransferResourcesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchTransferResourcesResponse>): BatchTransferResourcesResponse {
    const message = createBaseBatchTransferResourcesResponse();
    message.responses =
      object.responses?.map((e) => BatchTransferResourcesResponse_TransferResourceResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchTransferResourcesResponse_TransferResourceResponse(): BatchTransferResourcesResponse_TransferResourceResponse {
  return { source: "", target: "", error: undefined };
}

export const BatchTransferResourcesResponse_TransferResourceResponse: MessageFns<
  BatchTransferResourcesResponse_TransferResourceResponse
> = {
  encode(
    message: BatchTransferResourcesResponse_TransferResourceResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.target !== "") {
      writer.uint32(18).string(message.target);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTransferResourcesResponse_TransferResourceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTransferResourcesResponse_TransferResourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.target = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTransferResourcesResponse_TransferResourceResponse {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: BatchTransferResourcesResponse_TransferResourceResponse): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(
    base?: DeepPartial<BatchTransferResourcesResponse_TransferResourceResponse>,
  ): BatchTransferResourcesResponse_TransferResourceResponse {
    return BatchTransferResourcesResponse_TransferResourceResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BatchTransferResourcesResponse_TransferResourceResponse>,
  ): BatchTransferResourcesResponse_TransferResourceResponse {
    const message = createBaseBatchTransferResourcesResponse_TransferResourceResponse();
    message.source = object.source ?? "";
    message.target = object.target ?? "";
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseDataset(): Dataset {
  return {
    name: "",
    displayName: "",
    sourceLanguageCode: "",
    targetLanguageCode: "",
    exampleCount: 0,
    trainExampleCount: 0,
    validateExampleCount: 0,
    testExampleCount: 0,
    createTime: undefined,
    updateTime: undefined,
  };
}

export const Dataset: MessageFns<Dataset> = {
  encode(message: Dataset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.sourceLanguageCode !== "") {
      writer.uint32(26).string(message.sourceLanguageCode);
    }
    if (message.targetLanguageCode !== "") {
      writer.uint32(34).string(message.targetLanguageCode);
    }
    if (message.exampleCount !== 0) {
      writer.uint32(40).int32(message.exampleCount);
    }
    if (message.trainExampleCount !== 0) {
      writer.uint32(48).int32(message.trainExampleCount);
    }
    if (message.validateExampleCount !== 0) {
      writer.uint32(56).int32(message.validateExampleCount);
    }
    if (message.testExampleCount !== 0) {
      writer.uint32(64).int32(message.testExampleCount);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dataset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceLanguageCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetLanguageCode = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.exampleCount = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.trainExampleCount = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.validateExampleCount = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.testExampleCount = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dataset {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      sourceLanguageCode: isSet(object.sourceLanguageCode) ? globalThis.String(object.sourceLanguageCode) : "",
      targetLanguageCode: isSet(object.targetLanguageCode) ? globalThis.String(object.targetLanguageCode) : "",
      exampleCount: isSet(object.exampleCount) ? globalThis.Number(object.exampleCount) : 0,
      trainExampleCount: isSet(object.trainExampleCount) ? globalThis.Number(object.trainExampleCount) : 0,
      validateExampleCount: isSet(object.validateExampleCount) ? globalThis.Number(object.validateExampleCount) : 0,
      testExampleCount: isSet(object.testExampleCount) ? globalThis.Number(object.testExampleCount) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: Dataset): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.sourceLanguageCode !== "") {
      obj.sourceLanguageCode = message.sourceLanguageCode;
    }
    if (message.targetLanguageCode !== "") {
      obj.targetLanguageCode = message.targetLanguageCode;
    }
    if (message.exampleCount !== 0) {
      obj.exampleCount = Math.round(message.exampleCount);
    }
    if (message.trainExampleCount !== 0) {
      obj.trainExampleCount = Math.round(message.trainExampleCount);
    }
    if (message.validateExampleCount !== 0) {
      obj.validateExampleCount = Math.round(message.validateExampleCount);
    }
    if (message.testExampleCount !== 0) {
      obj.testExampleCount = Math.round(message.testExampleCount);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Dataset>): Dataset {
    return Dataset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Dataset>): Dataset {
    const message = createBaseDataset();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.sourceLanguageCode = object.sourceLanguageCode ?? "";
    message.targetLanguageCode = object.targetLanguageCode ?? "";
    message.exampleCount = object.exampleCount ?? 0;
    message.trainExampleCount = object.trainExampleCount ?? 0;
    message.validateExampleCount = object.validateExampleCount ?? 0;
    message.testExampleCount = object.testExampleCount ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseCreateModelRequest(): CreateModelRequest {
  return { parent: "", model: undefined };
}

export const CreateModelRequest: MessageFns<CreateModelRequest> = {
  encode(message: CreateModelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateModelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateModelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateModelRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      model: isSet(object.model) ? Model.fromJSON(object.model) : undefined,
    };
  },

  toJSON(message: CreateModelRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateModelRequest>): CreateModelRequest {
    return CreateModelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateModelRequest>): CreateModelRequest {
    const message = createBaseCreateModelRequest();
    message.parent = object.parent ?? "";
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    return message;
  },
};

function createBaseCreateModelMetadata(): CreateModelMetadata {
  return { state: 0, createTime: undefined, updateTime: undefined, error: undefined };
}

export const CreateModelMetadata: MessageFns<CreateModelMetadata> = {
  encode(message: CreateModelMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateModelMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateModelMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateModelMetadata {
    return {
      state: isSet(object.state) ? operationStateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: CreateModelMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = operationStateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateModelMetadata>): CreateModelMetadata {
    return CreateModelMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateModelMetadata>): CreateModelMetadata {
    const message = createBaseCreateModelMetadata();
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseListModelsRequest(): ListModelsRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListModelsRequest: MessageFns<ListModelsRequest> = {
  encode(message: ListModelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListModelsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListModelsRequest>): ListModelsRequest {
    return ListModelsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListModelsRequest>): ListModelsRequest {
    const message = createBaseListModelsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListModelsResponse(): ListModelsResponse {
  return { models: [], nextPageToken: "" };
}

export const ListModelsResponse: MessageFns<ListModelsResponse> = {
  encode(message: ListModelsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.models) {
      Model.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListModelsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.models.push(Model.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelsResponse {
    return {
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => Model.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListModelsResponse): unknown {
    const obj: any = {};
    if (message.models?.length) {
      obj.models = message.models.map((e) => Model.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListModelsResponse>): ListModelsResponse {
    return ListModelsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListModelsResponse>): ListModelsResponse {
    const message = createBaseListModelsResponse();
    message.models = object.models?.map((e) => Model.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetModelRequest(): GetModelRequest {
  return { name: "" };
}

export const GetModelRequest: MessageFns<GetModelRequest> = {
  encode(message: GetModelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetModelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetModelRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetModelRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetModelRequest>): GetModelRequest {
    return GetModelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetModelRequest>): GetModelRequest {
    const message = createBaseGetModelRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteModelRequest(): DeleteModelRequest {
  return { name: "" };
}

export const DeleteModelRequest: MessageFns<DeleteModelRequest> = {
  encode(message: DeleteModelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteModelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteModelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteModelRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteModelRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteModelRequest>): DeleteModelRequest {
    return DeleteModelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteModelRequest>): DeleteModelRequest {
    const message = createBaseDeleteModelRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteModelMetadata(): DeleteModelMetadata {
  return { state: 0, createTime: undefined, updateTime: undefined, error: undefined };
}

export const DeleteModelMetadata: MessageFns<DeleteModelMetadata> = {
  encode(message: DeleteModelMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteModelMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteModelMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteModelMetadata {
    return {
      state: isSet(object.state) ? operationStateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: DeleteModelMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = operationStateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteModelMetadata>): DeleteModelMetadata {
    return DeleteModelMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteModelMetadata>): DeleteModelMetadata {
    const message = createBaseDeleteModelMetadata();
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseModel(): Model {
  return {
    name: "",
    displayName: "",
    dataset: "",
    sourceLanguageCode: "",
    targetLanguageCode: "",
    trainExampleCount: 0,
    validateExampleCount: 0,
    testExampleCount: 0,
    createTime: undefined,
    updateTime: undefined,
  };
}

export const Model: MessageFns<Model> = {
  encode(message: Model, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.dataset !== "") {
      writer.uint32(26).string(message.dataset);
    }
    if (message.sourceLanguageCode !== "") {
      writer.uint32(34).string(message.sourceLanguageCode);
    }
    if (message.targetLanguageCode !== "") {
      writer.uint32(42).string(message.targetLanguageCode);
    }
    if (message.trainExampleCount !== 0) {
      writer.uint32(48).int32(message.trainExampleCount);
    }
    if (message.validateExampleCount !== 0) {
      writer.uint32(56).int32(message.validateExampleCount);
    }
    if (message.testExampleCount !== 0) {
      writer.uint32(96).int32(message.testExampleCount);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Model {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dataset = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sourceLanguageCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetLanguageCode = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.trainExampleCount = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.validateExampleCount = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.testExampleCount = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Model {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      dataset: isSet(object.dataset) ? globalThis.String(object.dataset) : "",
      sourceLanguageCode: isSet(object.sourceLanguageCode) ? globalThis.String(object.sourceLanguageCode) : "",
      targetLanguageCode: isSet(object.targetLanguageCode) ? globalThis.String(object.targetLanguageCode) : "",
      trainExampleCount: isSet(object.trainExampleCount) ? globalThis.Number(object.trainExampleCount) : 0,
      validateExampleCount: isSet(object.validateExampleCount) ? globalThis.Number(object.validateExampleCount) : 0,
      testExampleCount: isSet(object.testExampleCount) ? globalThis.Number(object.testExampleCount) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: Model): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.dataset !== "") {
      obj.dataset = message.dataset;
    }
    if (message.sourceLanguageCode !== "") {
      obj.sourceLanguageCode = message.sourceLanguageCode;
    }
    if (message.targetLanguageCode !== "") {
      obj.targetLanguageCode = message.targetLanguageCode;
    }
    if (message.trainExampleCount !== 0) {
      obj.trainExampleCount = Math.round(message.trainExampleCount);
    }
    if (message.validateExampleCount !== 0) {
      obj.validateExampleCount = Math.round(message.validateExampleCount);
    }
    if (message.testExampleCount !== 0) {
      obj.testExampleCount = Math.round(message.testExampleCount);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Model>): Model {
    return Model.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Model>): Model {
    const message = createBaseModel();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.dataset = object.dataset ?? "";
    message.sourceLanguageCode = object.sourceLanguageCode ?? "";
    message.targetLanguageCode = object.targetLanguageCode ?? "";
    message.trainExampleCount = object.trainExampleCount ?? 0;
    message.validateExampleCount = object.validateExampleCount ?? 0;
    message.testExampleCount = object.testExampleCount ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
