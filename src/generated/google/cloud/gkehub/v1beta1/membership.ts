// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/gkehub/v1beta1/membership.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";

export const protobufPackage = "google.cloud.gkehub.v1beta1";

/** Membership contains information about a member cluster. */
export interface Membership {
  /**
   * Output only. The full, unique name of this Membership resource in the
   * format `projects/* /locations/* /memberships/{membership_id}`, set during
   * creation.
   *
   * `membership_id` must be a valid RFC 1123 compliant DNS label:
   *
   *   1. At most 63 characters in length
   *   2. It must consist of lower case alphanumeric characters or `-`
   *   3. It must start and end with an alphanumeric character
   *
   * Which can be expressed as the regex: `[a-z0-9]([-a-z0-9]*[a-z0-9])?`,
   * with a maximum length of 63 characters.
   */
  name: string;
  /** Optional. GCP labels for this membership. */
  labels: { [key: string]: string };
  /**
   * Optional. Description of this membership, limited to 63 characters.
   * Must match the regex: `[a-zA-Z0-9][a-zA-Z0-9_\-\.\ ]*`
   */
  description: string;
  /** Optional. Endpoint information to reach this member. */
  endpoint?:
    | MembershipEndpoint
    | undefined;
  /** Output only. State of the Membership resource. */
  state:
    | MembershipState
    | undefined;
  /**
   * Optional. How to identify workloads from this Membership.
   * See the documentation on Workload Identity for more details:
   * https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity
   */
  authority:
    | Authority
    | undefined;
  /** Output only. When the Membership was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. When the Membership was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Output only. When the Membership was deleted. */
  deleteTime:
    | Date
    | undefined;
  /**
   * Optional. An externally-generated and managed ID for this Membership. This
   * ID may be modified after creation, but this is not recommended. For GKE
   * clusters, external_id is managed by the Hub API and updates will be
   * ignored.
   *
   * The ID must match the regex: `[a-zA-Z0-9][a-zA-Z0-9_\-\.]*`
   *
   * If this Membership represents a Kubernetes cluster, this value should be
   * set to the UID of the `kube-system` namespace object.
   */
  externalId: string;
  /**
   * Output only. For clusters using Connect, the timestamp of the most recent
   * connection established with Google Cloud. This time is updated every
   * several minutes, not continuously. For clusters that do not use GKE
   * Connect, or that have never connected successfully, this field will be
   * unset.
   */
  lastConnectionTime:
    | Date
    | undefined;
  /**
   * Output only. Google-generated UUID for this resource. This is unique across
   * all Membership resources. If a Membership resource is deleted and another
   * resource with the same name is created, it gets a different unique_id.
   */
  uniqueId: string;
  /** Optional. The infrastructure type this Membership is running on. */
  infrastructureType: Membership_InfrastructureType;
  /** Optional. The monitoring config information for this membership. */
  monitoringConfig: MonitoringConfig | undefined;
}

/**
 * Specifies the infrastructure type of a Membership. Infrastructure type is
 * used by Hub to control infrastructure-specific behavior, including pricing.
 *
 * Each GKE distribution (on-GCP, on-Prem, on-X,...) will set this field
 * automatically, but Attached Clusters customers should specify a type
 * during registration.
 */
export enum Membership_InfrastructureType {
  /**
   * INFRASTRUCTURE_TYPE_UNSPECIFIED - No type was specified. Some Hub functionality may require a type be
   * specified, and will not support Memberships with this value.
   */
  INFRASTRUCTURE_TYPE_UNSPECIFIED = 0,
  /**
   * ON_PREM - Private infrastructure that is owned or operated by customer. This
   * includes GKE distributions such as GKE-OnPrem and GKE-OnBareMetal.
   */
  ON_PREM = 1,
  /** MULTI_CLOUD - Public cloud infrastructure. */
  MULTI_CLOUD = 2,
  UNRECOGNIZED = -1,
}

export function membership_InfrastructureTypeFromJSON(object: any): Membership_InfrastructureType {
  switch (object) {
    case 0:
    case "INFRASTRUCTURE_TYPE_UNSPECIFIED":
      return Membership_InfrastructureType.INFRASTRUCTURE_TYPE_UNSPECIFIED;
    case 1:
    case "ON_PREM":
      return Membership_InfrastructureType.ON_PREM;
    case 2:
    case "MULTI_CLOUD":
      return Membership_InfrastructureType.MULTI_CLOUD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Membership_InfrastructureType.UNRECOGNIZED;
  }
}

export function membership_InfrastructureTypeToJSON(object: Membership_InfrastructureType): string {
  switch (object) {
    case Membership_InfrastructureType.INFRASTRUCTURE_TYPE_UNSPECIFIED:
      return "INFRASTRUCTURE_TYPE_UNSPECIFIED";
    case Membership_InfrastructureType.ON_PREM:
      return "ON_PREM";
    case Membership_InfrastructureType.MULTI_CLOUD:
      return "MULTI_CLOUD";
    case Membership_InfrastructureType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Membership_LabelsEntry {
  key: string;
  value: string;
}

/**
 * MembershipEndpoint contains information needed to contact a Kubernetes API,
 * endpoint and any additional Kubernetes metadata.
 */
export interface MembershipEndpoint {
  /** Optional. Specific information for a GKE-on-GCP cluster. */
  gkeCluster?:
    | GkeCluster
    | undefined;
  /**
   * Optional. Specific information for a GKE On-Prem cluster. An onprem
   * user-cluster who has no resourceLink is not allowed to use this field, it
   * should have a nil "type" instead.
   */
  onPremCluster?:
    | OnPremCluster
    | undefined;
  /** Optional. Specific information for a GKE Multi-Cloud cluster. */
  multiCloudCluster?:
    | MultiCloudCluster
    | undefined;
  /** Optional. Specific information for a Google Edge cluster. */
  edgeCluster?:
    | EdgeCluster
    | undefined;
  /** Optional. Specific information for a GDC Edge Appliance cluster. */
  applianceCluster?:
    | ApplianceCluster
    | undefined;
  /** Output only. Useful Kubernetes-specific metadata. */
  kubernetesMetadata:
    | KubernetesMetadata
    | undefined;
  /**
   * Optional. The in-cluster Kubernetes Resources that should be applied for a
   * correctly registered cluster, in the steady state. These resources:
   *
   *   * Ensure that the cluster is exclusively registered to one and only one
   *     Hub Membership.
   *   * Propagate Workload Pool Information available in the Membership
   *     Authority field.
   *   * Ensure proper initial configuration of default Hub Features.
   */
  kubernetesResource: KubernetesResource | undefined;
}

/**
 * KubernetesResource contains the YAML manifests and configuration for
 * Membership Kubernetes resources in the cluster. After CreateMembership or
 * UpdateMembership, these resources should be re-applied in the cluster.
 */
export interface KubernetesResource {
  /**
   * Input only. The YAML representation of the Membership CR. This field is
   * ignored for GKE clusters where Hub can read the CR directly.
   *
   * Callers should provide the CR that is currently present in the cluster
   * during CreateMembership or UpdateMembership, or leave this field empty if
   * none exists. The CR manifest is used to validate the cluster has not been
   * registered with another Membership.
   */
  membershipCrManifest: string;
  /**
   * Output only. Additional Kubernetes resources that need to be applied to the
   * cluster after Membership creation, and after every update.
   *
   * This field is only populated in the Membership returned from a successful
   * long-running operation from CreateMembership or UpdateMembership. It is not
   * populated during normal GetMembership or ListMemberships requests. To get
   * the resource manifest after the initial registration, the caller should
   * make a UpdateMembership call with an empty field mask.
   */
  membershipResources: ResourceManifest[];
  /**
   * Output only. The Kubernetes resources for installing the GKE Connect agent
   *
   * This field is only populated in the Membership returned from a successful
   * long-running operation from CreateMembership or UpdateMembership. It is not
   * populated during normal GetMembership or ListMemberships requests. To get
   * the resource manifest after the initial registration, the caller should
   * make a UpdateMembership call with an empty field mask.
   */
  connectResources: ResourceManifest[];
  /** Optional. Options for Kubernetes resource generation. */
  resourceOptions: ResourceOptions | undefined;
}

/** ResourceOptions represent options for Kubernetes resource generation. */
export interface ResourceOptions {
  /**
   * Optional. The Connect agent version to use for connect_resources. Defaults
   * to the latest GKE Connect version. The version must be a currently
   * supported version, obsolete versions will be rejected.
   */
  connectVersion: string;
  /**
   * Optional. Use `apiextensions/v1beta1` instead of `apiextensions/v1` for
   * CustomResourceDefinition resources.
   * This option should be set for clusters with Kubernetes apiserver versions
   * <1.16.
   */
  v1beta1Crd: boolean;
  /**
   * Optional. Major version of the Kubernetes cluster. This is only used to
   * determine which version to use for the CustomResourceDefinition resources,
   * `apiextensions/v1beta1` or`apiextensions/v1`.
   */
  k8sVersion: string;
}

/**
 * ResourceManifest represents a single Kubernetes resource to be applied to
 * the cluster.
 */
export interface ResourceManifest {
  /** YAML manifest of the resource. */
  manifest: string;
  /**
   * Whether the resource provided in the manifest is `cluster_scoped`.
   * If unset, the manifest is assumed to be namespace scoped.
   *
   * This field is used for REST mapping when applying the resource in a
   * cluster.
   */
  clusterScoped: boolean;
}

/** GkeCluster contains information specific to GKE clusters. */
export interface GkeCluster {
  /**
   * Immutable. Self-link of the GCP resource for the GKE cluster. For example:
   *
   *     //container.googleapis.com/projects/my-project/locations/us-west1-a/clusters/my-cluster
   *
   * Zonal clusters are also supported.
   */
  resourceLink: string;
  /**
   * Output only. If cluster_missing is set then it denotes that the GKE cluster
   * no longer exists in the GKE Control Plane.
   */
  clusterMissing: boolean;
}

/** OnPremCluster contains information specific to GKE On-Prem clusters. */
export interface OnPremCluster {
  /**
   * Immutable. Self-link of the GCP resource for the GKE On-Prem cluster. For
   * example:
   *
   *  //gkeonprem.googleapis.com/projects/my-project/locations/us-west1-a/vmwareClusters/my-cluster
   *  //gkeonprem.googleapis.com/projects/my-project/locations/us-west1-a/bareMetalClusters/my-cluster
   */
  resourceLink: string;
  /**
   * Output only. If cluster_missing is set then it denotes that
   * API(gkeonprem.googleapis.com) resource for this GKE On-Prem cluster no
   * longer exists.
   */
  clusterMissing: boolean;
  /** Immutable. Whether the cluster is an admin cluster. */
  adminCluster: boolean;
  /** Immutable. The on prem cluster's type. */
  clusterType: OnPremCluster_ClusterType;
}

/** ClusterType describes on prem cluster's type. */
export enum OnPremCluster_ClusterType {
  /** CLUSTERTYPE_UNSPECIFIED - The ClusterType is not set. */
  CLUSTERTYPE_UNSPECIFIED = 0,
  /** BOOTSTRAP - The ClusterType is bootstrap cluster. */
  BOOTSTRAP = 1,
  /** HYBRID - The ClusterType is baremetal hybrid cluster. */
  HYBRID = 2,
  /** STANDALONE - The ClusterType is baremetal standalone cluster. */
  STANDALONE = 3,
  /** USER - The ClusterType is user cluster. */
  USER = 4,
  UNRECOGNIZED = -1,
}

export function onPremCluster_ClusterTypeFromJSON(object: any): OnPremCluster_ClusterType {
  switch (object) {
    case 0:
    case "CLUSTERTYPE_UNSPECIFIED":
      return OnPremCluster_ClusterType.CLUSTERTYPE_UNSPECIFIED;
    case 1:
    case "BOOTSTRAP":
      return OnPremCluster_ClusterType.BOOTSTRAP;
    case 2:
    case "HYBRID":
      return OnPremCluster_ClusterType.HYBRID;
    case 3:
    case "STANDALONE":
      return OnPremCluster_ClusterType.STANDALONE;
    case 4:
    case "USER":
      return OnPremCluster_ClusterType.USER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OnPremCluster_ClusterType.UNRECOGNIZED;
  }
}

export function onPremCluster_ClusterTypeToJSON(object: OnPremCluster_ClusterType): string {
  switch (object) {
    case OnPremCluster_ClusterType.CLUSTERTYPE_UNSPECIFIED:
      return "CLUSTERTYPE_UNSPECIFIED";
    case OnPremCluster_ClusterType.BOOTSTRAP:
      return "BOOTSTRAP";
    case OnPremCluster_ClusterType.HYBRID:
      return "HYBRID";
    case OnPremCluster_ClusterType.STANDALONE:
      return "STANDALONE";
    case OnPremCluster_ClusterType.USER:
      return "USER";
    case OnPremCluster_ClusterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** MultiCloudCluster contains information specific to GKE Multi-Cloud clusters. */
export interface MultiCloudCluster {
  /**
   * Immutable. Self-link of the GCP resource for the GKE Multi-Cloud cluster.
   * For example:
   *
   *  //gkemulticloud.googleapis.com/projects/my-project/locations/us-west1-a/awsClusters/my-cluster
   *  //gkemulticloud.googleapis.com/projects/my-project/locations/us-west1-a/azureClusters/my-cluster
   *  //gkemulticloud.googleapis.com/projects/my-project/locations/us-west1-a/attachedClusters/my-cluster
   */
  resourceLink: string;
  /**
   * Output only. If cluster_missing is set then it denotes that
   * API(gkemulticloud.googleapis.com) resource for this GKE Multi-Cloud cluster
   * no longer exists.
   */
  clusterMissing: boolean;
}

/** EdgeCluster contains information specific to Google Edge Clusters. */
export interface EdgeCluster {
  /**
   * Immutable. Self-link of the GCP resource for the Edge Cluster. For
   * example:
   *
   * //edgecontainer.googleapis.com/projects/my-project/locations/us-west1-a/clusters/my-cluster
   */
  resourceLink: string;
}

/**
 * ApplianceCluster contains information specific to GDC Edge Appliance
 * Clusters.
 */
export interface ApplianceCluster {
  /**
   * Immutable. Self-link of the GCP resource for the Appliance Cluster. For
   * example:
   *
   * //transferappliance.googleapis.com/projects/my-project/locations/us-west1-a/appliances/my-appliance
   */
  resourceLink: string;
}

/**
 * KubernetesMetadata provides informational metadata for Memberships
 * representing Kubernetes clusters.
 */
export interface KubernetesMetadata {
  /**
   * Output only. Kubernetes API server version string as reported by
   * '/version'.
   */
  kubernetesApiServerVersion: string;
  /**
   * Output only. Node providerID as reported by the first node in the list of
   * nodes on the Kubernetes endpoint. On Kubernetes platforms that support
   * zero-node clusters (like GKE-on-GCP), the node_count will be zero and the
   * node_provider_id will be empty.
   */
  nodeProviderId: string;
  /** Output only. Node count as reported by Kubernetes nodes resources. */
  nodeCount: number;
  /** Output only. vCPU count as reported by Kubernetes nodes resources. */
  vcpuCount: number;
  /**
   * Output only. The total memory capacity as reported by the sum of all
   * Kubernetes nodes resources, defined in MB.
   */
  memoryMb: number;
  /**
   * Output only. The time at which these details were last updated. This
   * update_time is different from the Membership-level update_time since
   * EndpointDetails are updated internally for API consumers.
   */
  updateTime: Date | undefined;
}

/**
 * Authority encodes how Google will recognize identities from this Membership.
 * See the workload identity documentation for more details:
 * https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity
 */
export interface Authority {
  /**
   * Optional. A JSON Web Token (JWT) issuer URI. `issuer` must start with
   * `https://` and be a valid URL with length <2000 characters.
   *
   * If set, then Google will allow valid OIDC tokens from this issuer to
   * authenticate within the workload_identity_pool. OIDC discovery will be
   * performed on this URI to validate tokens from the issuer.
   *
   * Clearing `issuer` disables Workload Identity. `issuer` cannot be directly
   * modified; it must be cleared (and Workload Identity disabled) before using
   * a new issuer (and re-enabling Workload Identity).
   */
  issuer: string;
  /**
   * Output only. The name of the workload identity pool in which `issuer` will
   * be recognized.
   *
   * There is a single Workload Identity Pool per Hub that is shared
   * between all Memberships that belong to that Hub. For a Hub hosted in
   * {PROJECT_ID}, the workload pool format is `{PROJECT_ID}.hub.id.goog`,
   * although this is subject to change in newer versions of this API.
   */
  workloadIdentityPool: string;
  /**
   * Output only. An identity provider that reflects the `issuer` in the
   * workload identity pool.
   */
  identityProvider: string;
  /**
   * Optional. OIDC verification keys for this Membership in JWKS format (RFC
   * 7517).
   *
   * When this field is set, OIDC discovery will NOT be performed on `issuer`,
   * and instead OIDC tokens will be validated using this field.
   */
  oidcJwks: Buffer;
}

/**
 * This field informs Fleet-based applications/services/UIs with the necessary
 * information for where each underlying Cluster reports its metrics.
 */
export interface MonitoringConfig {
  /** Immutable. Project used to report Metrics */
  projectId: string;
  /** Immutable. Location used to report Metrics */
  location: string;
  /**
   * Immutable. Cluster name used to report metrics.
   * For Anthos on VMWare/Baremetal, it would be in format
   * `memberClusters/cluster_name`; And for Anthos on MultiCloud, it would be in
   * format
   * `{azureClusters, awsClusters}/cluster_name`.
   */
  cluster: string;
  /**
   * Kubernetes system metrics, if available, are written to this prefix.
   * This defaults to kubernetes.io for GKE, and kubernetes.io/anthos for Anthos
   * eventually. Noted: Anthos MultiCloud will have kubernetes.io prefix today
   * but will migration to be under kubernetes.io/anthos
   */
  kubernetesMetricsPrefix: string;
  /**
   * Immutable. Cluster hash, this is a unique string generated by google code,
   * which does not contain any PII, which we can use to reference the cluster.
   * This is expected to be created by the monitoring stack and persisted into
   * the Cluster object as well as to GKE-Hub.
   */
  clusterHash: string;
}

/** State of the Membership resource. */
export interface MembershipState {
  /** Output only. The current state of the Membership resource. */
  code: MembershipState_Code;
  /**
   * This field is never set by the Hub Service.
   *
   * @deprecated
   */
  description: string;
  /**
   * This field is never set by the Hub Service.
   *
   * @deprecated
   */
  updateTime: Date | undefined;
}

/** Code describes the state of a Membership resource. */
export enum MembershipState_Code {
  /** CODE_UNSPECIFIED - The code is not set. */
  CODE_UNSPECIFIED = 0,
  /** CREATING - The cluster is being registered. */
  CREATING = 1,
  /** READY - The cluster is registered. */
  READY = 2,
  /** DELETING - The cluster is being unregistered. */
  DELETING = 3,
  /** UPDATING - The Membership is being updated. */
  UPDATING = 4,
  /** SERVICE_UPDATING - The Membership is being updated by the Hub Service. */
  SERVICE_UPDATING = 5,
  UNRECOGNIZED = -1,
}

export function membershipState_CodeFromJSON(object: any): MembershipState_Code {
  switch (object) {
    case 0:
    case "CODE_UNSPECIFIED":
      return MembershipState_Code.CODE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return MembershipState_Code.CREATING;
    case 2:
    case "READY":
      return MembershipState_Code.READY;
    case 3:
    case "DELETING":
      return MembershipState_Code.DELETING;
    case 4:
    case "UPDATING":
      return MembershipState_Code.UPDATING;
    case 5:
    case "SERVICE_UPDATING":
      return MembershipState_Code.SERVICE_UPDATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MembershipState_Code.UNRECOGNIZED;
  }
}

export function membershipState_CodeToJSON(object: MembershipState_Code): string {
  switch (object) {
    case MembershipState_Code.CODE_UNSPECIFIED:
      return "CODE_UNSPECIFIED";
    case MembershipState_Code.CREATING:
      return "CREATING";
    case MembershipState_Code.READY:
      return "READY";
    case MembershipState_Code.DELETING:
      return "DELETING";
    case MembershipState_Code.UPDATING:
      return "UPDATING";
    case MembershipState_Code.SERVICE_UPDATING:
      return "SERVICE_UPDATING";
    case MembershipState_Code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for `GkeHubMembershipService.ListMemberships` method. */
export interface ListMembershipsRequest {
  /**
   * Required. The parent (project and location) where the Memberships will be
   * listed. Specified in the format `projects/* /locations/*`.
   * `projects/* /locations/-` list memberships in all the regions.
   */
  parent: string;
  /**
   * Optional. When requesting a 'page' of resources, `page_size` specifies
   * number of resources to return. If unspecified or set to 0, all resources
   * will be returned.
   */
  pageSize: number;
  /**
   * Optional. Token returned by previous call to `ListMemberships` which
   * specifies the position in the list from where to continue listing the
   * resources.
   */
  pageToken: string;
  /**
   * Optional. Lists Memberships that match the filter expression, following the
   * syntax outlined in https://google.aip.dev/160.
   *
   * Examples:
   *
   *   - Name is `bar` in project `foo-proj` and location `global`:
   *
   *       name = "projects/foo-proj/locations/global/membership/bar"
   *
   *   - Memberships that have a label called `foo`:
   *
   *       labels.foo:*
   *
   *   - Memberships that have a label called `foo` whose value is `bar`:
   *
   *       labels.foo = bar
   *
   *   - Memberships in the CREATING state:
   *
   *       state = CREATING
   */
  filter: string;
  /**
   * Optional. One or more fields to compare and use to sort the output.
   * See https://google.aip.dev/132#ordering.
   */
  orderBy: string;
}

/** Response message for the `GkeHubMembershipService.ListMemberships` method. */
export interface ListMembershipsResponse {
  /** The list of matching Memberships. */
  resources: Membership[];
  /**
   * A token to request the next page of resources from the
   * `ListMemberships` method. The value of an empty string means that
   * there are no more resources to return.
   */
  nextPageToken: string;
  /** List of locations that could not be reached while fetching this list. */
  unreachable: string[];
}

/** Request message for `GkeHubMembershipService.GetMembership` method. */
export interface GetMembershipRequest {
  /**
   * Required. The Membership resource name in the format
   * `projects/* /locations/* /memberships/*`.
   */
  name: string;
}

/** Request message for the `GkeHubMembershipService.CreateMembership` method. */
export interface CreateMembershipRequest {
  /**
   * Required. The parent (project and location) where the Memberships will be
   * created. Specified in the format `projects/* /locations/*`.
   */
  parent: string;
  /**
   * Required. Client chosen ID for the membership. `membership_id` must be a
   * valid RFC 1123 compliant DNS label:
   *
   *   1. At most 63 characters in length
   *   2. It must consist of lower case alphanumeric characters or `-`
   *   3. It must start and end with an alphanumeric character
   *
   * Which can be expressed as the regex: `[a-z0-9]([-a-z0-9]*[a-z0-9])?`,
   * with a maximum length of 63 characters.
   */
  membershipId: string;
  /** Required. The membership to create. */
  resource:
    | Membership
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for `GkeHubMembershipService.DeleteMembership` method. */
export interface DeleteMembershipRequest {
  /**
   * Required. The Membership resource name in the format
   * `projects/* /locations/* /memberships/*`.
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, any subresource from this Membership will also be
   * deleted. Otherwise, the request will only work if the Membership has no
   * subresource.
   */
  force: boolean;
}

/** Request message for `GkeHubMembershipService.UpdateMembership` method. */
export interface UpdateMembershipRequest {
  /**
   * Required. The membership resource name in the format:
   * `projects/[project_id]/locations/global/memberships/[membership_id]`
   */
  name: string;
  /**
   * Required. Mask of fields to update. At least one field path must be
   * specified in this mask.
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * Required. Only fields specified in update_mask are updated.
   * If you specify a field in the update_mask but don't specify its value here
   * that field will be deleted.
   * If you are updating a map field, set the value of a key to null or empty
   * string to delete the key from the map. It's not possible to update a key's
   * value to the empty string.
   * If you specify the update_mask to be a special path "*", fully replaces all
   * user-modifiable fields to match `resource`.
   */
  resource:
    | Membership
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for `GkeHubMembershipService.GenerateConnectManifest`
 * method.
 */
export interface GenerateConnectManifestRequest {
  /**
   * Required. The Membership resource name the Agent will associate with, in
   * the format `projects/* /locations/* /memberships/*`.
   */
  name: string;
  /** Optional. The connect agent to generate manifest for. */
  connectAgent:
    | ConnectAgent
    | undefined;
  /**
   * Optional. The Connect agent version to use. Defaults to the most current
   * version.
   */
  version: string;
  /**
   * Optional. If true, generate the resources for upgrade only. Some resources
   * generated only for installation (e.g. secrets) will be excluded.
   */
  isUpgrade: boolean;
  /**
   * Optional. The registry to fetch the connect agent image from. Defaults to
   * gcr.io/gkeconnect.
   */
  registry: string;
  /** Optional. The image pull secret content for the registry, if not public. */
  imagePullSecretContent: Buffer;
}

/**
 * GenerateConnectManifestResponse contains manifest information for
 * installing/upgrading a Connect agent.
 */
export interface GenerateConnectManifestResponse {
  /**
   * The ordered list of Kubernetes resources that need to be applied to the
   * cluster for GKE Connect agent installation/upgrade.
   */
  manifest: ConnectAgentResource[];
}

/**
 * ConnectAgentResource represents a Kubernetes resource manifest for Connect
 * Agent deployment.
 */
export interface ConnectAgentResource {
  /** Kubernetes type of the resource. */
  type:
    | TypeMeta
    | undefined;
  /** YAML manifest of the resource. */
  manifest: string;
}

/**
 * TypeMeta is the type information needed for content unmarshalling of
 * Kubernetes resources in the manifest.
 */
export interface TypeMeta {
  /** Kind of the resource (e.g. Deployment). */
  kind: string;
  /** APIVersion of the resource (e.g. v1). */
  apiVersion: string;
}

/** The information required from end users to use GKE Connect. */
export interface ConnectAgent {
  /**
   * Do not set.
   *
   * @deprecated
   */
  name: string;
  /**
   * Optional. URI of a proxy if connectivity from the agent to
   * gkeconnect.googleapis.com requires the use of a proxy. Format must be in
   * the form `http(s)://{proxy_address}`, depending on the HTTP/HTTPS protocol
   * supported by the proxy. This will direct the connect agent's outbound
   * traffic through a HTTP(S) proxy.
   */
  proxy: Buffer;
  /**
   * Optional. Namespace for GKE Connect agent resources. Defaults to
   * `gke-connect`.
   *
   * The Connect Agent is authorized automatically when run in the default
   * namespace. Otherwise, explicit authorization must be granted with an
   * additional IAM binding.
   */
  namespace: string;
}

/**
 * The request to validate the existing state of the membership CR in the
 * cluster.
 */
export interface ValidateExclusivityRequest {
  /**
   * Required. The parent (project and location) where the Memberships will be
   * created. Specified in the format `projects/* /locations/*`.
   */
  parent: string;
  /**
   * Optional. The YAML of the membership CR in the cluster. Empty if the
   * membership CR does not exist.
   */
  crManifest: string;
  /**
   * Required. The intended membership name under the `parent`. This method only
   * does validation in anticipation of a CreateMembership call with the same
   * name.
   */
  intendedMembership: string;
}

/** The response of exclusivity artifacts validation result status. */
export interface ValidateExclusivityResponse {
  /**
   * The validation result.
   *
   * * `OK` means that exclusivity is validated, assuming the manifest produced
   *    by GenerateExclusivityManifest is successfully applied.
   * * `ALREADY_EXISTS` means that the Membership CRD is already owned by
   *    another Hub. See `status.message` for more information.
   */
  status: Status | undefined;
}

/** The request to generate the manifests for exclusivity artifacts. */
export interface GenerateExclusivityManifestRequest {
  /**
   * Required. The Membership resource name in the format
   * `projects/* /locations/* /memberships/*`.
   */
  name: string;
  /**
   * Optional. The YAML manifest of the membership CRD retrieved by
   * `kubectl get customresourcedefinitions membership`.
   * Leave empty if the resource does not exist.
   */
  crdManifest: string;
  /**
   * Optional. The YAML manifest of the membership CR retrieved by
   * `kubectl get memberships membership`.
   * Leave empty if the resource does not exist.
   */
  crManifest: string;
}

/** The response of the exclusivity artifacts manifests for the client to apply. */
export interface GenerateExclusivityManifestResponse {
  /**
   * The YAML manifest of the membership CRD to apply if a newer version of the
   * CRD is available. Empty if no update needs to be applied.
   */
  crdManifest: string;
  /**
   * The YAML manifest of the membership CR to apply if a new version of the
   * CR is available. Empty if no update needs to be applied.
   */
  crManifest: string;
}

/** Represents the metadata of the long-running operation. */
export interface OperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /** Output only. Human-readable status of the operation, if any. */
  statusDetail: string;
  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have successfully been cancelled
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   */
  cancelRequested: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

function createBaseMembership(): Membership {
  return {
    name: "",
    labels: {},
    description: "",
    endpoint: undefined,
    state: undefined,
    authority: undefined,
    createTime: undefined,
    updateTime: undefined,
    deleteTime: undefined,
    externalId: "",
    lastConnectionTime: undefined,
    uniqueId: "",
    infrastructureType: 0,
    monitoringConfig: undefined,
  };
}

export const Membership: MessageFns<Membership> = {
  encode(message: Membership, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Membership_LabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.endpoint !== undefined) {
      MembershipEndpoint.encode(message.endpoint, writer.uint32(34).fork()).join();
    }
    if (message.state !== undefined) {
      MembershipState.encode(message.state, writer.uint32(42).fork()).join();
    }
    if (message.authority !== undefined) {
      Authority.encode(message.authority, writer.uint32(74).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(66).fork()).join();
    }
    if (message.externalId !== "") {
      writer.uint32(82).string(message.externalId);
    }
    if (message.lastConnectionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastConnectionTime), writer.uint32(90).fork()).join();
    }
    if (message.uniqueId !== "") {
      writer.uint32(98).string(message.uniqueId);
    }
    if (message.infrastructureType !== 0) {
      writer.uint32(104).int32(message.infrastructureType);
    }
    if (message.monitoringConfig !== undefined) {
      MonitoringConfig.encode(message.monitoringConfig, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Membership {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembership();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Membership_LabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labels[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endpoint = MembershipEndpoint.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.state = MembershipState.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.authority = Authority.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.externalId = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.lastConnectionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.infrastructureType = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.monitoringConfig = MonitoringConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Membership {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      endpoint: isSet(object.endpoint) ? MembershipEndpoint.fromJSON(object.endpoint) : undefined,
      state: isSet(object.state) ? MembershipState.fromJSON(object.state) : undefined,
      authority: isSet(object.authority) ? Authority.fromJSON(object.authority) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      lastConnectionTime: isSet(object.lastConnectionTime) ? fromJsonTimestamp(object.lastConnectionTime) : undefined,
      uniqueId: isSet(object.uniqueId) ? globalThis.String(object.uniqueId) : "",
      infrastructureType: isSet(object.infrastructureType)
        ? membership_InfrastructureTypeFromJSON(object.infrastructureType)
        : 0,
      monitoringConfig: isSet(object.monitoringConfig) ? MonitoringConfig.fromJSON(object.monitoringConfig) : undefined,
    };
  },

  toJSON(message: Membership): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.endpoint !== undefined) {
      obj.endpoint = MembershipEndpoint.toJSON(message.endpoint);
    }
    if (message.state !== undefined) {
      obj.state = MembershipState.toJSON(message.state);
    }
    if (message.authority !== undefined) {
      obj.authority = Authority.toJSON(message.authority);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (message.lastConnectionTime !== undefined) {
      obj.lastConnectionTime = message.lastConnectionTime.toISOString();
    }
    if (message.uniqueId !== "") {
      obj.uniqueId = message.uniqueId;
    }
    if (message.infrastructureType !== 0) {
      obj.infrastructureType = membership_InfrastructureTypeToJSON(message.infrastructureType);
    }
    if (message.monitoringConfig !== undefined) {
      obj.monitoringConfig = MonitoringConfig.toJSON(message.monitoringConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Membership>): Membership {
    return Membership.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Membership>): Membership {
    const message = createBaseMembership();
    message.name = object.name ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.endpoint = (object.endpoint !== undefined && object.endpoint !== null)
      ? MembershipEndpoint.fromPartial(object.endpoint)
      : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? MembershipState.fromPartial(object.state)
      : undefined;
    message.authority = (object.authority !== undefined && object.authority !== null)
      ? Authority.fromPartial(object.authority)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.externalId = object.externalId ?? "";
    message.lastConnectionTime = object.lastConnectionTime ?? undefined;
    message.uniqueId = object.uniqueId ?? "";
    message.infrastructureType = object.infrastructureType ?? 0;
    message.monitoringConfig = (object.monitoringConfig !== undefined && object.monitoringConfig !== null)
      ? MonitoringConfig.fromPartial(object.monitoringConfig)
      : undefined;
    return message;
  },
};

function createBaseMembership_LabelsEntry(): Membership_LabelsEntry {
  return { key: "", value: "" };
}

export const Membership_LabelsEntry: MessageFns<Membership_LabelsEntry> = {
  encode(message: Membership_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Membership_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembership_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Membership_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Membership_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Membership_LabelsEntry>): Membership_LabelsEntry {
    return Membership_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Membership_LabelsEntry>): Membership_LabelsEntry {
    const message = createBaseMembership_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMembershipEndpoint(): MembershipEndpoint {
  return {
    gkeCluster: undefined,
    onPremCluster: undefined,
    multiCloudCluster: undefined,
    edgeCluster: undefined,
    applianceCluster: undefined,
    kubernetesMetadata: undefined,
    kubernetesResource: undefined,
  };
}

export const MembershipEndpoint: MessageFns<MembershipEndpoint> = {
  encode(message: MembershipEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gkeCluster !== undefined) {
      GkeCluster.encode(message.gkeCluster, writer.uint32(34).fork()).join();
    }
    if (message.onPremCluster !== undefined) {
      OnPremCluster.encode(message.onPremCluster, writer.uint32(58).fork()).join();
    }
    if (message.multiCloudCluster !== undefined) {
      MultiCloudCluster.encode(message.multiCloudCluster, writer.uint32(66).fork()).join();
    }
    if (message.edgeCluster !== undefined) {
      EdgeCluster.encode(message.edgeCluster, writer.uint32(74).fork()).join();
    }
    if (message.applianceCluster !== undefined) {
      ApplianceCluster.encode(message.applianceCluster, writer.uint32(82).fork()).join();
    }
    if (message.kubernetesMetadata !== undefined) {
      KubernetesMetadata.encode(message.kubernetesMetadata, writer.uint32(42).fork()).join();
    }
    if (message.kubernetesResource !== undefined) {
      KubernetesResource.encode(message.kubernetesResource, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gkeCluster = GkeCluster.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.onPremCluster = OnPremCluster.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.multiCloudCluster = MultiCloudCluster.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.edgeCluster = EdgeCluster.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.applianceCluster = ApplianceCluster.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.kubernetesMetadata = KubernetesMetadata.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.kubernetesResource = KubernetesResource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipEndpoint {
    return {
      gkeCluster: isSet(object.gkeCluster) ? GkeCluster.fromJSON(object.gkeCluster) : undefined,
      onPremCluster: isSet(object.onPremCluster) ? OnPremCluster.fromJSON(object.onPremCluster) : undefined,
      multiCloudCluster: isSet(object.multiCloudCluster)
        ? MultiCloudCluster.fromJSON(object.multiCloudCluster)
        : undefined,
      edgeCluster: isSet(object.edgeCluster) ? EdgeCluster.fromJSON(object.edgeCluster) : undefined,
      applianceCluster: isSet(object.applianceCluster) ? ApplianceCluster.fromJSON(object.applianceCluster) : undefined,
      kubernetesMetadata: isSet(object.kubernetesMetadata)
        ? KubernetesMetadata.fromJSON(object.kubernetesMetadata)
        : undefined,
      kubernetesResource: isSet(object.kubernetesResource)
        ? KubernetesResource.fromJSON(object.kubernetesResource)
        : undefined,
    };
  },

  toJSON(message: MembershipEndpoint): unknown {
    const obj: any = {};
    if (message.gkeCluster !== undefined) {
      obj.gkeCluster = GkeCluster.toJSON(message.gkeCluster);
    }
    if (message.onPremCluster !== undefined) {
      obj.onPremCluster = OnPremCluster.toJSON(message.onPremCluster);
    }
    if (message.multiCloudCluster !== undefined) {
      obj.multiCloudCluster = MultiCloudCluster.toJSON(message.multiCloudCluster);
    }
    if (message.edgeCluster !== undefined) {
      obj.edgeCluster = EdgeCluster.toJSON(message.edgeCluster);
    }
    if (message.applianceCluster !== undefined) {
      obj.applianceCluster = ApplianceCluster.toJSON(message.applianceCluster);
    }
    if (message.kubernetesMetadata !== undefined) {
      obj.kubernetesMetadata = KubernetesMetadata.toJSON(message.kubernetesMetadata);
    }
    if (message.kubernetesResource !== undefined) {
      obj.kubernetesResource = KubernetesResource.toJSON(message.kubernetesResource);
    }
    return obj;
  },

  create(base?: DeepPartial<MembershipEndpoint>): MembershipEndpoint {
    return MembershipEndpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MembershipEndpoint>): MembershipEndpoint {
    const message = createBaseMembershipEndpoint();
    message.gkeCluster = (object.gkeCluster !== undefined && object.gkeCluster !== null)
      ? GkeCluster.fromPartial(object.gkeCluster)
      : undefined;
    message.onPremCluster = (object.onPremCluster !== undefined && object.onPremCluster !== null)
      ? OnPremCluster.fromPartial(object.onPremCluster)
      : undefined;
    message.multiCloudCluster = (object.multiCloudCluster !== undefined && object.multiCloudCluster !== null)
      ? MultiCloudCluster.fromPartial(object.multiCloudCluster)
      : undefined;
    message.edgeCluster = (object.edgeCluster !== undefined && object.edgeCluster !== null)
      ? EdgeCluster.fromPartial(object.edgeCluster)
      : undefined;
    message.applianceCluster = (object.applianceCluster !== undefined && object.applianceCluster !== null)
      ? ApplianceCluster.fromPartial(object.applianceCluster)
      : undefined;
    message.kubernetesMetadata = (object.kubernetesMetadata !== undefined && object.kubernetesMetadata !== null)
      ? KubernetesMetadata.fromPartial(object.kubernetesMetadata)
      : undefined;
    message.kubernetesResource = (object.kubernetesResource !== undefined && object.kubernetesResource !== null)
      ? KubernetesResource.fromPartial(object.kubernetesResource)
      : undefined;
    return message;
  },
};

function createBaseKubernetesResource(): KubernetesResource {
  return { membershipCrManifest: "", membershipResources: [], connectResources: [], resourceOptions: undefined };
}

export const KubernetesResource: MessageFns<KubernetesResource> = {
  encode(message: KubernetesResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.membershipCrManifest !== "") {
      writer.uint32(10).string(message.membershipCrManifest);
    }
    for (const v of message.membershipResources) {
      ResourceManifest.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.connectResources) {
      ResourceManifest.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.resourceOptions !== undefined) {
      ResourceOptions.encode(message.resourceOptions, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.membershipCrManifest = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.membershipResources.push(ResourceManifest.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.connectResources.push(ResourceManifest.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resourceOptions = ResourceOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesResource {
    return {
      membershipCrManifest: isSet(object.membershipCrManifest) ? globalThis.String(object.membershipCrManifest) : "",
      membershipResources: globalThis.Array.isArray(object?.membershipResources)
        ? object.membershipResources.map((e: any) => ResourceManifest.fromJSON(e))
        : [],
      connectResources: globalThis.Array.isArray(object?.connectResources)
        ? object.connectResources.map((e: any) => ResourceManifest.fromJSON(e))
        : [],
      resourceOptions: isSet(object.resourceOptions) ? ResourceOptions.fromJSON(object.resourceOptions) : undefined,
    };
  },

  toJSON(message: KubernetesResource): unknown {
    const obj: any = {};
    if (message.membershipCrManifest !== "") {
      obj.membershipCrManifest = message.membershipCrManifest;
    }
    if (message.membershipResources?.length) {
      obj.membershipResources = message.membershipResources.map((e) => ResourceManifest.toJSON(e));
    }
    if (message.connectResources?.length) {
      obj.connectResources = message.connectResources.map((e) => ResourceManifest.toJSON(e));
    }
    if (message.resourceOptions !== undefined) {
      obj.resourceOptions = ResourceOptions.toJSON(message.resourceOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<KubernetesResource>): KubernetesResource {
    return KubernetesResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KubernetesResource>): KubernetesResource {
    const message = createBaseKubernetesResource();
    message.membershipCrManifest = object.membershipCrManifest ?? "";
    message.membershipResources = object.membershipResources?.map((e) => ResourceManifest.fromPartial(e)) || [];
    message.connectResources = object.connectResources?.map((e) => ResourceManifest.fromPartial(e)) || [];
    message.resourceOptions = (object.resourceOptions !== undefined && object.resourceOptions !== null)
      ? ResourceOptions.fromPartial(object.resourceOptions)
      : undefined;
    return message;
  },
};

function createBaseResourceOptions(): ResourceOptions {
  return { connectVersion: "", v1beta1Crd: false, k8sVersion: "" };
}

export const ResourceOptions: MessageFns<ResourceOptions> = {
  encode(message: ResourceOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectVersion !== "") {
      writer.uint32(10).string(message.connectVersion);
    }
    if (message.v1beta1Crd !== false) {
      writer.uint32(16).bool(message.v1beta1Crd);
    }
    if (message.k8sVersion !== "") {
      writer.uint32(26).string(message.k8sVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.connectVersion = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.v1beta1Crd = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.k8sVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceOptions {
    return {
      connectVersion: isSet(object.connectVersion) ? globalThis.String(object.connectVersion) : "",
      v1beta1Crd: isSet(object.v1beta1Crd) ? globalThis.Boolean(object.v1beta1Crd) : false,
      k8sVersion: isSet(object.k8sVersion) ? globalThis.String(object.k8sVersion) : "",
    };
  },

  toJSON(message: ResourceOptions): unknown {
    const obj: any = {};
    if (message.connectVersion !== "") {
      obj.connectVersion = message.connectVersion;
    }
    if (message.v1beta1Crd !== false) {
      obj.v1beta1Crd = message.v1beta1Crd;
    }
    if (message.k8sVersion !== "") {
      obj.k8sVersion = message.k8sVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceOptions>): ResourceOptions {
    return ResourceOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceOptions>): ResourceOptions {
    const message = createBaseResourceOptions();
    message.connectVersion = object.connectVersion ?? "";
    message.v1beta1Crd = object.v1beta1Crd ?? false;
    message.k8sVersion = object.k8sVersion ?? "";
    return message;
  },
};

function createBaseResourceManifest(): ResourceManifest {
  return { manifest: "", clusterScoped: false };
}

export const ResourceManifest: MessageFns<ResourceManifest> = {
  encode(message: ResourceManifest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.manifest !== "") {
      writer.uint32(10).string(message.manifest);
    }
    if (message.clusterScoped !== false) {
      writer.uint32(16).bool(message.clusterScoped);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceManifest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceManifest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.manifest = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clusterScoped = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceManifest {
    return {
      manifest: isSet(object.manifest) ? globalThis.String(object.manifest) : "",
      clusterScoped: isSet(object.clusterScoped) ? globalThis.Boolean(object.clusterScoped) : false,
    };
  },

  toJSON(message: ResourceManifest): unknown {
    const obj: any = {};
    if (message.manifest !== "") {
      obj.manifest = message.manifest;
    }
    if (message.clusterScoped !== false) {
      obj.clusterScoped = message.clusterScoped;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceManifest>): ResourceManifest {
    return ResourceManifest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceManifest>): ResourceManifest {
    const message = createBaseResourceManifest();
    message.manifest = object.manifest ?? "";
    message.clusterScoped = object.clusterScoped ?? false;
    return message;
  },
};

function createBaseGkeCluster(): GkeCluster {
  return { resourceLink: "", clusterMissing: false };
}

export const GkeCluster: MessageFns<GkeCluster> = {
  encode(message: GkeCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceLink !== "") {
      writer.uint32(10).string(message.resourceLink);
    }
    if (message.clusterMissing !== false) {
      writer.uint32(24).bool(message.clusterMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GkeCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGkeCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceLink = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.clusterMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GkeCluster {
    return {
      resourceLink: isSet(object.resourceLink) ? globalThis.String(object.resourceLink) : "",
      clusterMissing: isSet(object.clusterMissing) ? globalThis.Boolean(object.clusterMissing) : false,
    };
  },

  toJSON(message: GkeCluster): unknown {
    const obj: any = {};
    if (message.resourceLink !== "") {
      obj.resourceLink = message.resourceLink;
    }
    if (message.clusterMissing !== false) {
      obj.clusterMissing = message.clusterMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<GkeCluster>): GkeCluster {
    return GkeCluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GkeCluster>): GkeCluster {
    const message = createBaseGkeCluster();
    message.resourceLink = object.resourceLink ?? "";
    message.clusterMissing = object.clusterMissing ?? false;
    return message;
  },
};

function createBaseOnPremCluster(): OnPremCluster {
  return { resourceLink: "", clusterMissing: false, adminCluster: false, clusterType: 0 };
}

export const OnPremCluster: MessageFns<OnPremCluster> = {
  encode(message: OnPremCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceLink !== "") {
      writer.uint32(10).string(message.resourceLink);
    }
    if (message.clusterMissing !== false) {
      writer.uint32(16).bool(message.clusterMissing);
    }
    if (message.adminCluster !== false) {
      writer.uint32(24).bool(message.adminCluster);
    }
    if (message.clusterType !== 0) {
      writer.uint32(32).int32(message.clusterType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OnPremCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnPremCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceLink = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clusterMissing = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.adminCluster = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.clusterType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnPremCluster {
    return {
      resourceLink: isSet(object.resourceLink) ? globalThis.String(object.resourceLink) : "",
      clusterMissing: isSet(object.clusterMissing) ? globalThis.Boolean(object.clusterMissing) : false,
      adminCluster: isSet(object.adminCluster) ? globalThis.Boolean(object.adminCluster) : false,
      clusterType: isSet(object.clusterType) ? onPremCluster_ClusterTypeFromJSON(object.clusterType) : 0,
    };
  },

  toJSON(message: OnPremCluster): unknown {
    const obj: any = {};
    if (message.resourceLink !== "") {
      obj.resourceLink = message.resourceLink;
    }
    if (message.clusterMissing !== false) {
      obj.clusterMissing = message.clusterMissing;
    }
    if (message.adminCluster !== false) {
      obj.adminCluster = message.adminCluster;
    }
    if (message.clusterType !== 0) {
      obj.clusterType = onPremCluster_ClusterTypeToJSON(message.clusterType);
    }
    return obj;
  },

  create(base?: DeepPartial<OnPremCluster>): OnPremCluster {
    return OnPremCluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OnPremCluster>): OnPremCluster {
    const message = createBaseOnPremCluster();
    message.resourceLink = object.resourceLink ?? "";
    message.clusterMissing = object.clusterMissing ?? false;
    message.adminCluster = object.adminCluster ?? false;
    message.clusterType = object.clusterType ?? 0;
    return message;
  },
};

function createBaseMultiCloudCluster(): MultiCloudCluster {
  return { resourceLink: "", clusterMissing: false };
}

export const MultiCloudCluster: MessageFns<MultiCloudCluster> = {
  encode(message: MultiCloudCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceLink !== "") {
      writer.uint32(10).string(message.resourceLink);
    }
    if (message.clusterMissing !== false) {
      writer.uint32(16).bool(message.clusterMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiCloudCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiCloudCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceLink = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clusterMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiCloudCluster {
    return {
      resourceLink: isSet(object.resourceLink) ? globalThis.String(object.resourceLink) : "",
      clusterMissing: isSet(object.clusterMissing) ? globalThis.Boolean(object.clusterMissing) : false,
    };
  },

  toJSON(message: MultiCloudCluster): unknown {
    const obj: any = {};
    if (message.resourceLink !== "") {
      obj.resourceLink = message.resourceLink;
    }
    if (message.clusterMissing !== false) {
      obj.clusterMissing = message.clusterMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<MultiCloudCluster>): MultiCloudCluster {
    return MultiCloudCluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultiCloudCluster>): MultiCloudCluster {
    const message = createBaseMultiCloudCluster();
    message.resourceLink = object.resourceLink ?? "";
    message.clusterMissing = object.clusterMissing ?? false;
    return message;
  },
};

function createBaseEdgeCluster(): EdgeCluster {
  return { resourceLink: "" };
}

export const EdgeCluster: MessageFns<EdgeCluster> = {
  encode(message: EdgeCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceLink !== "") {
      writer.uint32(10).string(message.resourceLink);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EdgeCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdgeCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceLink = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EdgeCluster {
    return { resourceLink: isSet(object.resourceLink) ? globalThis.String(object.resourceLink) : "" };
  },

  toJSON(message: EdgeCluster): unknown {
    const obj: any = {};
    if (message.resourceLink !== "") {
      obj.resourceLink = message.resourceLink;
    }
    return obj;
  },

  create(base?: DeepPartial<EdgeCluster>): EdgeCluster {
    return EdgeCluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EdgeCluster>): EdgeCluster {
    const message = createBaseEdgeCluster();
    message.resourceLink = object.resourceLink ?? "";
    return message;
  },
};

function createBaseApplianceCluster(): ApplianceCluster {
  return { resourceLink: "" };
}

export const ApplianceCluster: MessageFns<ApplianceCluster> = {
  encode(message: ApplianceCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceLink !== "") {
      writer.uint32(10).string(message.resourceLink);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplianceCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplianceCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceLink = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplianceCluster {
    return { resourceLink: isSet(object.resourceLink) ? globalThis.String(object.resourceLink) : "" };
  },

  toJSON(message: ApplianceCluster): unknown {
    const obj: any = {};
    if (message.resourceLink !== "") {
      obj.resourceLink = message.resourceLink;
    }
    return obj;
  },

  create(base?: DeepPartial<ApplianceCluster>): ApplianceCluster {
    return ApplianceCluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApplianceCluster>): ApplianceCluster {
    const message = createBaseApplianceCluster();
    message.resourceLink = object.resourceLink ?? "";
    return message;
  },
};

function createBaseKubernetesMetadata(): KubernetesMetadata {
  return {
    kubernetesApiServerVersion: "",
    nodeProviderId: "",
    nodeCount: 0,
    vcpuCount: 0,
    memoryMb: 0,
    updateTime: undefined,
  };
}

export const KubernetesMetadata: MessageFns<KubernetesMetadata> = {
  encode(message: KubernetesMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kubernetesApiServerVersion !== "") {
      writer.uint32(10).string(message.kubernetesApiServerVersion);
    }
    if (message.nodeProviderId !== "") {
      writer.uint32(18).string(message.nodeProviderId);
    }
    if (message.nodeCount !== 0) {
      writer.uint32(24).int32(message.nodeCount);
    }
    if (message.vcpuCount !== 0) {
      writer.uint32(32).int32(message.vcpuCount);
    }
    if (message.memoryMb !== 0) {
      writer.uint32(40).int32(message.memoryMb);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kubernetesApiServerVersion = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodeProviderId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.vcpuCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.memoryMb = reader.int32();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesMetadata {
    return {
      kubernetesApiServerVersion: isSet(object.kubernetesApiServerVersion)
        ? globalThis.String(object.kubernetesApiServerVersion)
        : "",
      nodeProviderId: isSet(object.nodeProviderId) ? globalThis.String(object.nodeProviderId) : "",
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      vcpuCount: isSet(object.vcpuCount) ? globalThis.Number(object.vcpuCount) : 0,
      memoryMb: isSet(object.memoryMb) ? globalThis.Number(object.memoryMb) : 0,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: KubernetesMetadata): unknown {
    const obj: any = {};
    if (message.kubernetesApiServerVersion !== "") {
      obj.kubernetesApiServerVersion = message.kubernetesApiServerVersion;
    }
    if (message.nodeProviderId !== "") {
      obj.nodeProviderId = message.nodeProviderId;
    }
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.vcpuCount !== 0) {
      obj.vcpuCount = Math.round(message.vcpuCount);
    }
    if (message.memoryMb !== 0) {
      obj.memoryMb = Math.round(message.memoryMb);
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<KubernetesMetadata>): KubernetesMetadata {
    return KubernetesMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KubernetesMetadata>): KubernetesMetadata {
    const message = createBaseKubernetesMetadata();
    message.kubernetesApiServerVersion = object.kubernetesApiServerVersion ?? "";
    message.nodeProviderId = object.nodeProviderId ?? "";
    message.nodeCount = object.nodeCount ?? 0;
    message.vcpuCount = object.vcpuCount ?? 0;
    message.memoryMb = object.memoryMb ?? 0;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseAuthority(): Authority {
  return { issuer: "", workloadIdentityPool: "", identityProvider: "", oidcJwks: Buffer.alloc(0) };
}

export const Authority: MessageFns<Authority> = {
  encode(message: Authority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuer !== "") {
      writer.uint32(10).string(message.issuer);
    }
    if (message.workloadIdentityPool !== "") {
      writer.uint32(18).string(message.workloadIdentityPool);
    }
    if (message.identityProvider !== "") {
      writer.uint32(26).string(message.identityProvider);
    }
    if (message.oidcJwks.length !== 0) {
      writer.uint32(34).bytes(message.oidcJwks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Authority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issuer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workloadIdentityPool = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.identityProvider = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.oidcJwks = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Authority {
    return {
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      workloadIdentityPool: isSet(object.workloadIdentityPool) ? globalThis.String(object.workloadIdentityPool) : "",
      identityProvider: isSet(object.identityProvider) ? globalThis.String(object.identityProvider) : "",
      oidcJwks: isSet(object.oidcJwks) ? Buffer.from(bytesFromBase64(object.oidcJwks)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Authority): unknown {
    const obj: any = {};
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.workloadIdentityPool !== "") {
      obj.workloadIdentityPool = message.workloadIdentityPool;
    }
    if (message.identityProvider !== "") {
      obj.identityProvider = message.identityProvider;
    }
    if (message.oidcJwks.length !== 0) {
      obj.oidcJwks = base64FromBytes(message.oidcJwks);
    }
    return obj;
  },

  create(base?: DeepPartial<Authority>): Authority {
    return Authority.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Authority>): Authority {
    const message = createBaseAuthority();
    message.issuer = object.issuer ?? "";
    message.workloadIdentityPool = object.workloadIdentityPool ?? "";
    message.identityProvider = object.identityProvider ?? "";
    message.oidcJwks = object.oidcJwks ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseMonitoringConfig(): MonitoringConfig {
  return { projectId: "", location: "", cluster: "", kubernetesMetricsPrefix: "", clusterHash: "" };
}

export const MonitoringConfig: MessageFns<MonitoringConfig> = {
  encode(message: MonitoringConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.cluster !== "") {
      writer.uint32(26).string(message.cluster);
    }
    if (message.kubernetesMetricsPrefix !== "") {
      writer.uint32(34).string(message.kubernetesMetricsPrefix);
    }
    if (message.clusterHash !== "") {
      writer.uint32(42).string(message.clusterHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonitoringConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonitoringConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cluster = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.kubernetesMetricsPrefix = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.clusterHash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonitoringConfig {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "",
      kubernetesMetricsPrefix: isSet(object.kubernetesMetricsPrefix)
        ? globalThis.String(object.kubernetesMetricsPrefix)
        : "",
      clusterHash: isSet(object.clusterHash) ? globalThis.String(object.clusterHash) : "",
    };
  },

  toJSON(message: MonitoringConfig): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    if (message.kubernetesMetricsPrefix !== "") {
      obj.kubernetesMetricsPrefix = message.kubernetesMetricsPrefix;
    }
    if (message.clusterHash !== "") {
      obj.clusterHash = message.clusterHash;
    }
    return obj;
  },

  create(base?: DeepPartial<MonitoringConfig>): MonitoringConfig {
    return MonitoringConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonitoringConfig>): MonitoringConfig {
    const message = createBaseMonitoringConfig();
    message.projectId = object.projectId ?? "";
    message.location = object.location ?? "";
    message.cluster = object.cluster ?? "";
    message.kubernetesMetricsPrefix = object.kubernetesMetricsPrefix ?? "";
    message.clusterHash = object.clusterHash ?? "";
    return message;
  },
};

function createBaseMembershipState(): MembershipState {
  return { code: 0, description: "", updateTime: undefined };
}

export const MembershipState: MessageFns<MembershipState> = {
  encode(message: MembershipState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipState {
    return {
      code: isSet(object.code) ? membershipState_CodeFromJSON(object.code) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: MembershipState): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = membershipState_CodeToJSON(message.code);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<MembershipState>): MembershipState {
    return MembershipState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MembershipState>): MembershipState {
    const message = createBaseMembershipState();
    message.code = object.code ?? 0;
    message.description = object.description ?? "";
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseListMembershipsRequest(): ListMembershipsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListMembershipsRequest: MessageFns<ListMembershipsRequest> = {
  encode(message: ListMembershipsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMembershipsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMembershipsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMembershipsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListMembershipsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMembershipsRequest>): ListMembershipsRequest {
    return ListMembershipsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMembershipsRequest>): ListMembershipsRequest {
    const message = createBaseListMembershipsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListMembershipsResponse(): ListMembershipsResponse {
  return { resources: [], nextPageToken: "", unreachable: [] };
}

export const ListMembershipsResponse: MessageFns<ListMembershipsResponse> = {
  encode(message: ListMembershipsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.resources) {
      Membership.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMembershipsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMembershipsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resources.push(Membership.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMembershipsResponse {
    return {
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Membership.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListMembershipsResponse): unknown {
    const obj: any = {};
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Membership.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMembershipsResponse>): ListMembershipsResponse {
    return ListMembershipsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMembershipsResponse>): ListMembershipsResponse {
    const message = createBaseListMembershipsResponse();
    message.resources = object.resources?.map((e) => Membership.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetMembershipRequest(): GetMembershipRequest {
  return { name: "" };
}

export const GetMembershipRequest: MessageFns<GetMembershipRequest> = {
  encode(message: GetMembershipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMembershipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMembershipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMembershipRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetMembershipRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetMembershipRequest>): GetMembershipRequest {
    return GetMembershipRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMembershipRequest>): GetMembershipRequest {
    const message = createBaseGetMembershipRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateMembershipRequest(): CreateMembershipRequest {
  return { parent: "", membershipId: "", resource: undefined, requestId: "" };
}

export const CreateMembershipRequest: MessageFns<CreateMembershipRequest> = {
  encode(message: CreateMembershipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.membershipId !== "") {
      writer.uint32(18).string(message.membershipId);
    }
    if (message.resource !== undefined) {
      Membership.encode(message.resource, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMembershipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMembershipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.membershipId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resource = Membership.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateMembershipRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      membershipId: isSet(object.membershipId) ? globalThis.String(object.membershipId) : "",
      resource: isSet(object.resource) ? Membership.fromJSON(object.resource) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateMembershipRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.membershipId !== "") {
      obj.membershipId = message.membershipId;
    }
    if (message.resource !== undefined) {
      obj.resource = Membership.toJSON(message.resource);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateMembershipRequest>): CreateMembershipRequest {
    return CreateMembershipRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateMembershipRequest>): CreateMembershipRequest {
    const message = createBaseCreateMembershipRequest();
    message.parent = object.parent ?? "";
    message.membershipId = object.membershipId ?? "";
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Membership.fromPartial(object.resource)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteMembershipRequest(): DeleteMembershipRequest {
  return { name: "", requestId: "", force: false };
}

export const DeleteMembershipRequest: MessageFns<DeleteMembershipRequest> = {
  encode(message: DeleteMembershipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    if (message.force !== false) {
      writer.uint32(40).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMembershipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMembershipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMembershipRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteMembershipRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteMembershipRequest>): DeleteMembershipRequest {
    return DeleteMembershipRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteMembershipRequest>): DeleteMembershipRequest {
    const message = createBaseDeleteMembershipRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseUpdateMembershipRequest(): UpdateMembershipRequest {
  return { name: "", updateMask: undefined, resource: undefined, requestId: "" };
}

export const UpdateMembershipRequest: MessageFns<UpdateMembershipRequest> = {
  encode(message: UpdateMembershipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.resource !== undefined) {
      Membership.encode(message.resource, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateMembershipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMembershipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resource = Membership.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateMembershipRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      resource: isSet(object.resource) ? Membership.fromJSON(object.resource) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateMembershipRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.resource !== undefined) {
      obj.resource = Membership.toJSON(message.resource);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateMembershipRequest>): UpdateMembershipRequest {
    return UpdateMembershipRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateMembershipRequest>): UpdateMembershipRequest {
    const message = createBaseUpdateMembershipRequest();
    message.name = object.name ?? "";
    message.updateMask = object.updateMask ?? undefined;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Membership.fromPartial(object.resource)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseGenerateConnectManifestRequest(): GenerateConnectManifestRequest {
  return {
    name: "",
    connectAgent: undefined,
    version: "",
    isUpgrade: false,
    registry: "",
    imagePullSecretContent: Buffer.alloc(0),
  };
}

export const GenerateConnectManifestRequest: MessageFns<GenerateConnectManifestRequest> = {
  encode(message: GenerateConnectManifestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.connectAgent !== undefined) {
      ConnectAgent.encode(message.connectAgent, writer.uint32(18).fork()).join();
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.isUpgrade !== false) {
      writer.uint32(32).bool(message.isUpgrade);
    }
    if (message.registry !== "") {
      writer.uint32(42).string(message.registry);
    }
    if (message.imagePullSecretContent.length !== 0) {
      writer.uint32(50).bytes(message.imagePullSecretContent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateConnectManifestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateConnectManifestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.connectAgent = ConnectAgent.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isUpgrade = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.registry = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.imagePullSecretContent = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateConnectManifestRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      connectAgent: isSet(object.connectAgent) ? ConnectAgent.fromJSON(object.connectAgent) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      isUpgrade: isSet(object.isUpgrade) ? globalThis.Boolean(object.isUpgrade) : false,
      registry: isSet(object.registry) ? globalThis.String(object.registry) : "",
      imagePullSecretContent: isSet(object.imagePullSecretContent)
        ? Buffer.from(bytesFromBase64(object.imagePullSecretContent))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: GenerateConnectManifestRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.connectAgent !== undefined) {
      obj.connectAgent = ConnectAgent.toJSON(message.connectAgent);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.isUpgrade !== false) {
      obj.isUpgrade = message.isUpgrade;
    }
    if (message.registry !== "") {
      obj.registry = message.registry;
    }
    if (message.imagePullSecretContent.length !== 0) {
      obj.imagePullSecretContent = base64FromBytes(message.imagePullSecretContent);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateConnectManifestRequest>): GenerateConnectManifestRequest {
    return GenerateConnectManifestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateConnectManifestRequest>): GenerateConnectManifestRequest {
    const message = createBaseGenerateConnectManifestRequest();
    message.name = object.name ?? "";
    message.connectAgent = (object.connectAgent !== undefined && object.connectAgent !== null)
      ? ConnectAgent.fromPartial(object.connectAgent)
      : undefined;
    message.version = object.version ?? "";
    message.isUpgrade = object.isUpgrade ?? false;
    message.registry = object.registry ?? "";
    message.imagePullSecretContent = object.imagePullSecretContent ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseGenerateConnectManifestResponse(): GenerateConnectManifestResponse {
  return { manifest: [] };
}

export const GenerateConnectManifestResponse: MessageFns<GenerateConnectManifestResponse> = {
  encode(message: GenerateConnectManifestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.manifest) {
      ConnectAgentResource.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateConnectManifestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateConnectManifestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.manifest.push(ConnectAgentResource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateConnectManifestResponse {
    return {
      manifest: globalThis.Array.isArray(object?.manifest)
        ? object.manifest.map((e: any) => ConnectAgentResource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateConnectManifestResponse): unknown {
    const obj: any = {};
    if (message.manifest?.length) {
      obj.manifest = message.manifest.map((e) => ConnectAgentResource.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateConnectManifestResponse>): GenerateConnectManifestResponse {
    return GenerateConnectManifestResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateConnectManifestResponse>): GenerateConnectManifestResponse {
    const message = createBaseGenerateConnectManifestResponse();
    message.manifest = object.manifest?.map((e) => ConnectAgentResource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConnectAgentResource(): ConnectAgentResource {
  return { type: undefined, manifest: "" };
}

export const ConnectAgentResource: MessageFns<ConnectAgentResource> = {
  encode(message: ConnectAgentResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined) {
      TypeMeta.encode(message.type, writer.uint32(10).fork()).join();
    }
    if (message.manifest !== "") {
      writer.uint32(18).string(message.manifest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectAgentResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectAgentResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = TypeMeta.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.manifest = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectAgentResource {
    return {
      type: isSet(object.type) ? TypeMeta.fromJSON(object.type) : undefined,
      manifest: isSet(object.manifest) ? globalThis.String(object.manifest) : "",
    };
  },

  toJSON(message: ConnectAgentResource): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = TypeMeta.toJSON(message.type);
    }
    if (message.manifest !== "") {
      obj.manifest = message.manifest;
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectAgentResource>): ConnectAgentResource {
    return ConnectAgentResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectAgentResource>): ConnectAgentResource {
    const message = createBaseConnectAgentResource();
    message.type = (object.type !== undefined && object.type !== null) ? TypeMeta.fromPartial(object.type) : undefined;
    message.manifest = object.manifest ?? "";
    return message;
  },
};

function createBaseTypeMeta(): TypeMeta {
  return { kind: "", apiVersion: "" };
}

export const TypeMeta: MessageFns<TypeMeta> = {
  encode(message: TypeMeta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.apiVersion !== "") {
      writer.uint32(18).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypeMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypeMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypeMeta {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: TypeMeta): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<TypeMeta>): TypeMeta {
    return TypeMeta.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TypeMeta>): TypeMeta {
    const message = createBaseTypeMeta();
    message.kind = object.kind ?? "";
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseConnectAgent(): ConnectAgent {
  return { name: "", proxy: Buffer.alloc(0), namespace: "" };
}

export const ConnectAgent: MessageFns<ConnectAgent> = {
  encode(message: ConnectAgent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.proxy.length !== 0) {
      writer.uint32(18).bytes(message.proxy);
    }
    if (message.namespace !== "") {
      writer.uint32(26).string(message.namespace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectAgent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectAgent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.proxy = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.namespace = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectAgent {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      proxy: isSet(object.proxy) ? Buffer.from(bytesFromBase64(object.proxy)) : Buffer.alloc(0),
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
    };
  },

  toJSON(message: ConnectAgent): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.proxy.length !== 0) {
      obj.proxy = base64FromBytes(message.proxy);
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectAgent>): ConnectAgent {
    return ConnectAgent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectAgent>): ConnectAgent {
    const message = createBaseConnectAgent();
    message.name = object.name ?? "";
    message.proxy = object.proxy ?? Buffer.alloc(0);
    message.namespace = object.namespace ?? "";
    return message;
  },
};

function createBaseValidateExclusivityRequest(): ValidateExclusivityRequest {
  return { parent: "", crManifest: "", intendedMembership: "" };
}

export const ValidateExclusivityRequest: MessageFns<ValidateExclusivityRequest> = {
  encode(message: ValidateExclusivityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.crManifest !== "") {
      writer.uint32(18).string(message.crManifest);
    }
    if (message.intendedMembership !== "") {
      writer.uint32(26).string(message.intendedMembership);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateExclusivityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateExclusivityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.crManifest = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.intendedMembership = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateExclusivityRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      crManifest: isSet(object.crManifest) ? globalThis.String(object.crManifest) : "",
      intendedMembership: isSet(object.intendedMembership) ? globalThis.String(object.intendedMembership) : "",
    };
  },

  toJSON(message: ValidateExclusivityRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.crManifest !== "") {
      obj.crManifest = message.crManifest;
    }
    if (message.intendedMembership !== "") {
      obj.intendedMembership = message.intendedMembership;
    }
    return obj;
  },

  create(base?: DeepPartial<ValidateExclusivityRequest>): ValidateExclusivityRequest {
    return ValidateExclusivityRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidateExclusivityRequest>): ValidateExclusivityRequest {
    const message = createBaseValidateExclusivityRequest();
    message.parent = object.parent ?? "";
    message.crManifest = object.crManifest ?? "";
    message.intendedMembership = object.intendedMembership ?? "";
    return message;
  },
};

function createBaseValidateExclusivityResponse(): ValidateExclusivityResponse {
  return { status: undefined };
}

export const ValidateExclusivityResponse: MessageFns<ValidateExclusivityResponse> = {
  encode(message: ValidateExclusivityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateExclusivityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateExclusivityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateExclusivityResponse {
    return { status: isSet(object.status) ? Status.fromJSON(object.status) : undefined };
  },

  toJSON(message: ValidateExclusivityResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<ValidateExclusivityResponse>): ValidateExclusivityResponse {
    return ValidateExclusivityResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidateExclusivityResponse>): ValidateExclusivityResponse {
    const message = createBaseValidateExclusivityResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseGenerateExclusivityManifestRequest(): GenerateExclusivityManifestRequest {
  return { name: "", crdManifest: "", crManifest: "" };
}

export const GenerateExclusivityManifestRequest: MessageFns<GenerateExclusivityManifestRequest> = {
  encode(message: GenerateExclusivityManifestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.crdManifest !== "") {
      writer.uint32(18).string(message.crdManifest);
    }
    if (message.crManifest !== "") {
      writer.uint32(26).string(message.crManifest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateExclusivityManifestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateExclusivityManifestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.crdManifest = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.crManifest = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateExclusivityManifestRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      crdManifest: isSet(object.crdManifest) ? globalThis.String(object.crdManifest) : "",
      crManifest: isSet(object.crManifest) ? globalThis.String(object.crManifest) : "",
    };
  },

  toJSON(message: GenerateExclusivityManifestRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.crdManifest !== "") {
      obj.crdManifest = message.crdManifest;
    }
    if (message.crManifest !== "") {
      obj.crManifest = message.crManifest;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateExclusivityManifestRequest>): GenerateExclusivityManifestRequest {
    return GenerateExclusivityManifestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateExclusivityManifestRequest>): GenerateExclusivityManifestRequest {
    const message = createBaseGenerateExclusivityManifestRequest();
    message.name = object.name ?? "";
    message.crdManifest = object.crdManifest ?? "";
    message.crManifest = object.crManifest ?? "";
    return message;
  },
};

function createBaseGenerateExclusivityManifestResponse(): GenerateExclusivityManifestResponse {
  return { crdManifest: "", crManifest: "" };
}

export const GenerateExclusivityManifestResponse: MessageFns<GenerateExclusivityManifestResponse> = {
  encode(message: GenerateExclusivityManifestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.crdManifest !== "") {
      writer.uint32(10).string(message.crdManifest);
    }
    if (message.crManifest !== "") {
      writer.uint32(18).string(message.crManifest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateExclusivityManifestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateExclusivityManifestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.crdManifest = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.crManifest = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateExclusivityManifestResponse {
    return {
      crdManifest: isSet(object.crdManifest) ? globalThis.String(object.crdManifest) : "",
      crManifest: isSet(object.crManifest) ? globalThis.String(object.crManifest) : "",
    };
  },

  toJSON(message: GenerateExclusivityManifestResponse): unknown {
    const obj: any = {};
    if (message.crdManifest !== "") {
      obj.crdManifest = message.crdManifest;
    }
    if (message.crManifest !== "") {
      obj.crManifest = message.crManifest;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateExclusivityManifestResponse>): GenerateExclusivityManifestResponse {
    return GenerateExclusivityManifestResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateExclusivityManifestResponse>): GenerateExclusivityManifestResponse {
    const message = createBaseGenerateExclusivityManifestResponse();
    message.crdManifest = object.crdManifest ?? "";
    message.crManifest = object.crManifest ?? "";
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusDetail: "",
    cancelRequested: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusDetail !== "") {
      writer.uint32(42).string(message.statusDetail);
    }
    if (message.cancelRequested !== false) {
      writer.uint32(48).bool(message.cancelRequested);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusDetail = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cancelRequested = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusDetail: isSet(object.statusDetail) ? globalThis.String(object.statusDetail) : "",
      cancelRequested: isSet(object.cancelRequested) ? globalThis.Boolean(object.cancelRequested) : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusDetail !== "") {
      obj.statusDetail = message.statusDetail;
    }
    if (message.cancelRequested !== false) {
      obj.cancelRequested = message.cancelRequested;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusDetail = object.statusDetail ?? "";
    message.cancelRequested = object.cancelRequested ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

/**
 * The GKE Hub MembershipService handles the registration of many Kubernetes
 * clusters to Google Cloud, represented with the
 * [Membership][google.cloud.gkehub.v1beta1.Membership] resource.
 *
 * GKE Hub is currently available in the global region and all regions in
 * https://cloud.google.com/compute/docs/regions-zones.
 *
 * **Membership management may be non-trivial:** it is recommended to use one
 * of the Google-provided client libraries or tools where possible when working
 * with Membership resources.
 */
export type GkeHubMembershipServiceDefinition = typeof GkeHubMembershipServiceDefinition;
export const GkeHubMembershipServiceDefinition = {
  name: "GkeHubMembershipService",
  fullName: "google.cloud.gkehub.v1beta1.GkeHubMembershipService",
  methods: {
    /** Lists Memberships in a given project and location. */
    listMemberships: {
      name: "ListMemberships",
      requestType: ListMembershipsRequest,
      requestStream: false,
      responseType: ListMembershipsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a Membership. */
    getMembership: {
      name: "GetMembership",
      requestType: GetMembershipRequest,
      requestStream: false,
      responseType: Membership,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              109,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new Membership.
     *
     * **This is currently only supported for GKE clusters on Google Cloud**.
     * To register other clusters, follow the instructions at
     * https://cloud.google.com/anthos/multicluster-management/connect/registering-a-cluster.
     */
    createMembership: {
      name: "CreateMembership",
      requestType: CreateMembershipRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              31,
              10,
              10,
              77,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              29,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              109,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              64,
              58,
              8,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              34,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Removes a Membership.
     *
     * **This is currently only supported for GKE clusters on Google Cloud**.
     * To unregister other clusters, follow the instructions at
     * https://cloud.google.com/anthos/multicluster-management/connect/unregistering-a-cluster.
     */
    deleteMembership: {
      name: "DeleteMembership",
      requestType: DeleteMembershipRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              42,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              109,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates an existing Membership. */
    updateMembership: {
      name: "UpdateMembership",
      requestType: UpdateMembershipRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              31,
              10,
              10,
              77,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              25,
              110,
              97,
              109,
              101,
              44,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              64,
              58,
              8,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              50,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              109,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Generates the manifest for deployment of the GKE connect agent.
     *
     * **This method is used internally by Google-provided libraries.**
     * Most clients should not need to call this method directly.
     */
    generateConnectManifest: {
      name: "GenerateConnectManifest",
      requestType: GenerateConnectManifestRequest,
      requestStream: false,
      responseType: GenerateConnectManifestResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              78,
              18,
              76,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              109,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              77,
              97,
              110,
              105,
              102,
              101,
              115,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * ValidateExclusivity validates the state of exclusivity in the cluster.
     * The validation does not depend on an existing Hub membership resource.
     */
    validateExclusivity: {
      name: "ValidateExclusivity",
      requestType: ValidateExclusivityRequest,
      requestStream: false,
      responseType: ValidateExclusivityResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              74,
              18,
              72,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
              115,
              58,
              118,
              97,
              108,
              105,
              100,
              97,
              116,
              101,
              69,
              120,
              99,
              108,
              117,
              115,
              105,
              118,
              105,
              116,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * GenerateExclusivityManifest generates the manifests to update the
     * exclusivity artifacts in the cluster if needed.
     *
     * Exclusivity artifacts include the Membership custom resource definition
     * (CRD) and the singleton Membership custom resource (CR). Combined with
     * ValidateExclusivity, exclusivity artifacts guarantee that a Kubernetes
     * cluster is only registered to a single GKE Hub.
     *
     * The Membership CRD is versioned, and may require conversion when the GKE
     * Hub API server begins serving a newer version of the CRD and
     * corresponding CR. The response will be the converted CRD and CR if there
     * are any differences between the versions.
     */
    generateExclusivityManifest: {
      name: "GenerateExclusivityManifest",
      requestType: GenerateExclusivityManifestRequest,
      requestStream: false,
      responseType: GenerateExclusivityManifestResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              82,
              18,
              80,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              109,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              69,
              120,
              99,
              108,
              117,
              115,
              105,
              118,
              105,
              116,
              121,
              77,
              97,
              110,
              105,
              102,
              101,
              115,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface GkeHubMembershipServiceImplementation<CallContextExt = {}> {
  /** Lists Memberships in a given project and location. */
  listMemberships(
    request: ListMembershipsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListMembershipsResponse>>;
  /** Gets the details of a Membership. */
  getMembership(request: GetMembershipRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Membership>>;
  /**
   * Creates a new Membership.
   *
   * **This is currently only supported for GKE clusters on Google Cloud**.
   * To register other clusters, follow the instructions at
   * https://cloud.google.com/anthos/multicluster-management/connect/registering-a-cluster.
   */
  createMembership(
    request: CreateMembershipRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Removes a Membership.
   *
   * **This is currently only supported for GKE clusters on Google Cloud**.
   * To unregister other clusters, follow the instructions at
   * https://cloud.google.com/anthos/multicluster-management/connect/unregistering-a-cluster.
   */
  deleteMembership(
    request: DeleteMembershipRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates an existing Membership. */
  updateMembership(
    request: UpdateMembershipRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Generates the manifest for deployment of the GKE connect agent.
   *
   * **This method is used internally by Google-provided libraries.**
   * Most clients should not need to call this method directly.
   */
  generateConnectManifest(
    request: GenerateConnectManifestRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateConnectManifestResponse>>;
  /**
   * ValidateExclusivity validates the state of exclusivity in the cluster.
   * The validation does not depend on an existing Hub membership resource.
   */
  validateExclusivity(
    request: ValidateExclusivityRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ValidateExclusivityResponse>>;
  /**
   * GenerateExclusivityManifest generates the manifests to update the
   * exclusivity artifacts in the cluster if needed.
   *
   * Exclusivity artifacts include the Membership custom resource definition
   * (CRD) and the singleton Membership custom resource (CR). Combined with
   * ValidateExclusivity, exclusivity artifacts guarantee that a Kubernetes
   * cluster is only registered to a single GKE Hub.
   *
   * The Membership CRD is versioned, and may require conversion when the GKE
   * Hub API server begins serving a newer version of the CRD and
   * corresponding CR. The response will be the converted CRD and CR if there
   * are any differences between the versions.
   */
  generateExclusivityManifest(
    request: GenerateExclusivityManifestRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateExclusivityManifestResponse>>;
}

export interface GkeHubMembershipServiceClient<CallOptionsExt = {}> {
  /** Lists Memberships in a given project and location. */
  listMemberships(
    request: DeepPartial<ListMembershipsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListMembershipsResponse>;
  /** Gets the details of a Membership. */
  getMembership(
    request: DeepPartial<GetMembershipRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Membership>;
  /**
   * Creates a new Membership.
   *
   * **This is currently only supported for GKE clusters on Google Cloud**.
   * To register other clusters, follow the instructions at
   * https://cloud.google.com/anthos/multicluster-management/connect/registering-a-cluster.
   */
  createMembership(
    request: DeepPartial<CreateMembershipRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Removes a Membership.
   *
   * **This is currently only supported for GKE clusters on Google Cloud**.
   * To unregister other clusters, follow the instructions at
   * https://cloud.google.com/anthos/multicluster-management/connect/unregistering-a-cluster.
   */
  deleteMembership(
    request: DeepPartial<DeleteMembershipRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates an existing Membership. */
  updateMembership(
    request: DeepPartial<UpdateMembershipRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Generates the manifest for deployment of the GKE connect agent.
   *
   * **This method is used internally by Google-provided libraries.**
   * Most clients should not need to call this method directly.
   */
  generateConnectManifest(
    request: DeepPartial<GenerateConnectManifestRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateConnectManifestResponse>;
  /**
   * ValidateExclusivity validates the state of exclusivity in the cluster.
   * The validation does not depend on an existing Hub membership resource.
   */
  validateExclusivity(
    request: DeepPartial<ValidateExclusivityRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ValidateExclusivityResponse>;
  /**
   * GenerateExclusivityManifest generates the manifests to update the
   * exclusivity artifacts in the cluster if needed.
   *
   * Exclusivity artifacts include the Membership custom resource definition
   * (CRD) and the singleton Membership custom resource (CR). Combined with
   * ValidateExclusivity, exclusivity artifacts guarantee that a Kubernetes
   * cluster is only registered to a single GKE Hub.
   *
   * The Membership CRD is versioned, and may require conversion when the GKE
   * Hub API server begins serving a newer version of the CRD and
   * corresponding CR. The response will be the converted CRD and CR if there
   * are any differences between the versions.
   */
  generateExclusivityManifest(
    request: DeepPartial<GenerateExclusivityManifestRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateExclusivityManifestResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
