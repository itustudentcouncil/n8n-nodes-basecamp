// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/resourcemanager/v3/folders.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  GetIamPolicyRequest,
  SetIamPolicyRequest,
  TestIamPermissionsRequest,
  TestIamPermissionsResponse,
} from "../../../iam/v1/iam_policy.js";
import { Policy } from "../../../iam/v1/policy.js";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.resourcemanager.v3";

/**
 * A folder in an organization's resource hierarchy, used to
 * organize that organization's resources.
 */
export interface Folder {
  /**
   * Output only. The resource name of the folder.
   * Its format is `folders/{folder_id}`, for example: "folders/1234".
   */
  name: string;
  /**
   * Required. The folder's parent's resource name.
   * Updates to the folder's parent must be performed using
   * [MoveFolder][google.cloud.resourcemanager.v3.Folders.MoveFolder].
   */
  parent: string;
  /**
   * The folder's display name.
   * A folder's display name must be unique amongst its siblings. For example,
   * no two folders with the same parent can share the same display name.
   * The display name must start and end with a letter or digit, may contain
   * letters, digits, spaces, hyphens and underscores and can be no longer
   * than 30 characters. This is captured by the regular expression:
   * `[\p{L}\p{N}]([\p{L}\p{N}_- ]{0,28}[\p{L}\p{N}])?`.
   */
  displayName: string;
  /**
   * Output only. The lifecycle state of the folder.
   * Updates to the state must be performed using
   * [DeleteFolder][google.cloud.resourcemanager.v3.Folders.DeleteFolder] and
   * [UndeleteFolder][google.cloud.resourcemanager.v3.Folders.UndeleteFolder].
   */
  state: Folder_State;
  /** Output only. Timestamp when the folder was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Timestamp when the folder was last modified. */
  updateTime:
    | Date
    | undefined;
  /** Output only. Timestamp when the folder was requested to be deleted. */
  deleteTime:
    | Date
    | undefined;
  /**
   * Output only. A checksum computed by the server based on the current value
   * of the folder resource. This may be sent on update and delete requests to
   * ensure the client has an up-to-date value before proceeding.
   */
  etag: string;
}

/** Folder lifecycle states. */
export enum Folder_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The normal and active state. */
  ACTIVE = 1,
  /** DELETE_REQUESTED - The folder has been marked for deletion by the user. */
  DELETE_REQUESTED = 2,
  UNRECOGNIZED = -1,
}

export function folder_StateFromJSON(object: any): Folder_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Folder_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Folder_State.ACTIVE;
    case 2:
    case "DELETE_REQUESTED":
      return Folder_State.DELETE_REQUESTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Folder_State.UNRECOGNIZED;
  }
}

export function folder_StateToJSON(object: Folder_State): string {
  switch (object) {
    case Folder_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Folder_State.ACTIVE:
      return "ACTIVE";
    case Folder_State.DELETE_REQUESTED:
      return "DELETE_REQUESTED";
    case Folder_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The GetFolder request message. */
export interface GetFolderRequest {
  /**
   * Required. The resource name of the folder to retrieve.
   * Must be of the form `folders/{folder_id}`.
   */
  name: string;
}

/** The ListFolders request message. */
export interface ListFoldersRequest {
  /**
   * Required. The name of the parent resource whose folders are being listed.
   * Only children of this parent resource are listed; descendants are not
   * listed.
   *
   * If the parent is a folder, use the value `folders/{folder_id}`. If the
   * parent is an organization, use the value `organizations/{org_id}`.
   *
   * Access to this method is controlled by checking the
   * `resourcemanager.folders.list` permission on the `parent`.
   */
  parent: string;
  /**
   * Optional. The maximum number of folders to return in the response. The
   * server can return fewer folders than requested. If unspecified, server
   * picks an appropriate default.
   */
  pageSize: number;
  /**
   * Optional. A pagination token returned from a previous call to `ListFolders`
   * that indicates where this listing should continue from.
   */
  pageToken: string;
  /**
   * Optional. Controls whether folders in the
   * [DELETE_REQUESTED][google.cloud.resourcemanager.v3.Folder.State.DELETE_REQUESTED]
   * state should be returned. Defaults to false.
   */
  showDeleted: boolean;
}

/** The ListFolders response message. */
export interface ListFoldersResponse {
  /**
   * A possibly paginated list of folders that are direct descendants of
   * the specified parent resource.
   */
  folders: Folder[];
  /**
   * A pagination token returned from a previous call to `ListFolders`
   * that indicates from where listing should continue.
   */
  nextPageToken: string;
}

/** The request message for searching folders. */
export interface SearchFoldersRequest {
  /**
   * Optional. The maximum number of folders to return in the response. The
   * server can return fewer folders than requested. If unspecified, server
   * picks an appropriate default.
   */
  pageSize: number;
  /**
   * Optional. A pagination token returned from a previous call to
   * `SearchFolders` that indicates from where search should continue.
   */
  pageToken: string;
  /**
   * Optional. Search criteria used to select the folders to return.
   * If no search criteria is specified then all accessible folders will be
   * returned.
   *
   * Query expressions can be used to restrict results based upon displayName,
   * state and parent, where the operators `=` (`:`) `NOT`, `AND` and `OR`
   * can be used along with the suffix wildcard symbol `*`.
   *
   * The `displayName` field in a query expression should use escaped quotes
   * for values that include whitespace to prevent unexpected behavior.
   *
   * ```
   * | Field                   | Description                            |
   * |-------------------------|----------------------------------------|
   * | displayName             | Filters by displayName.                |
   * | parent                  | Filters by parent (for example: folders/123). |
   * | state, lifecycleState   | Filters by state.                      |
   * ```
   *
   * Some example queries are:
   *
   * * Query `displayName=Test*` returns Folder resources whose display name
   * starts with "Test".
   * * Query `state=ACTIVE` returns Folder resources with
   * `state` set to `ACTIVE`.
   * * Query `parent=folders/123` returns Folder resources that have
   * `folders/123` as a parent resource.
   * * Query `parent=folders/123 AND state=ACTIVE` returns active
   * Folder resources that have `folders/123` as a parent resource.
   * * Query `displayName=\\"Test String\\"` returns Folder resources with
   * display names that include both "Test" and "String".
   */
  query: string;
}

/** The response message for searching folders. */
export interface SearchFoldersResponse {
  /**
   * A possibly paginated folder search results.
   * the specified parent resource.
   */
  folders: Folder[];
  /**
   * A pagination token returned from a previous call to `SearchFolders`
   * that indicates from where searching should continue.
   */
  nextPageToken: string;
}

/** The CreateFolder request message. */
export interface CreateFolderRequest {
  /**
   * Required. The folder being created, only the display name and parent will
   * be consulted. All other fields will be ignored.
   */
  folder: Folder | undefined;
}

/** Metadata pertaining to the Folder creation process. */
export interface CreateFolderMetadata {
  /** The display name of the folder. */
  displayName: string;
  /**
   * The resource name of the folder or organization we are creating the folder
   * under.
   */
  parent: string;
}

/**
 * The request sent to the
 * [UpdateFolder][google.cloud.resourcemanager.v3.Folder.UpdateFolder]
 * method.
 *
 * Only the `display_name` field can be changed. All other fields will be
 * ignored. Use the
 * [MoveFolder][google.cloud.resourcemanager.v3.Folders.MoveFolder] method to
 * change the `parent` field.
 */
export interface UpdateFolderRequest {
  /**
   * Required. The new definition of the Folder. It must include the `name`
   * field, which cannot be changed.
   */
  folder:
    | Folder
    | undefined;
  /**
   * Required. Fields to be updated.
   * Only the `display_name` can be updated.
   */
  updateMask: string[] | undefined;
}

/**
 * A status object which is used as the `metadata` field for the Operation
 * returned by UpdateFolder.
 */
export interface UpdateFolderMetadata {
}

/** The MoveFolder request message. */
export interface MoveFolderRequest {
  /**
   * Required. The resource name of the Folder to move.
   * Must be of the form folders/{folder_id}
   */
  name: string;
  /**
   * Required. The resource name of the folder or organization which should be
   * the folder's new parent. Must be of the form `folders/{folder_id}` or
   * `organizations/{org_id}`.
   */
  destinationParent: string;
}

/** Metadata pertaining to the folder move process. */
export interface MoveFolderMetadata {
  /** The display name of the folder. */
  displayName: string;
  /** The resource name of the folder's parent. */
  sourceParent: string;
  /** The resource name of the folder or organization to move the folder to. */
  destinationParent: string;
}

/** The DeleteFolder request message. */
export interface DeleteFolderRequest {
  /**
   * Required. The resource name of the folder to be deleted.
   * Must be of the form `folders/{folder_id}`.
   */
  name: string;
}

/**
 * A status object which is used as the `metadata` field for the `Operation`
 * returned by `DeleteFolder`.
 */
export interface DeleteFolderMetadata {
}

/** The UndeleteFolder request message. */
export interface UndeleteFolderRequest {
  /**
   * Required. The resource name of the folder to undelete.
   * Must be of the form `folders/{folder_id}`.
   */
  name: string;
}

/**
 * A status object which is used as the `metadata` field for the `Operation`
 * returned by `UndeleteFolder`.
 */
export interface UndeleteFolderMetadata {
}

function createBaseFolder(): Folder {
  return {
    name: "",
    parent: "",
    displayName: "",
    state: 0,
    createTime: undefined,
    updateTime: undefined,
    deleteTime: undefined,
    etag: "",
  };
}

export const Folder: MessageFns<Folder> = {
  encode(message: Folder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(58).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(66).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Folder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFolder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Folder {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      state: isSet(object.state) ? folder_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: Folder): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.state !== 0) {
      obj.state = folder_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<Folder>): Folder {
    return Folder.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Folder>): Folder {
    const message = createBaseFolder();
    message.name = object.name ?? "";
    message.parent = object.parent ?? "";
    message.displayName = object.displayName ?? "";
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseGetFolderRequest(): GetFolderRequest {
  return { name: "" };
}

export const GetFolderRequest: MessageFns<GetFolderRequest> = {
  encode(message: GetFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFolderRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetFolderRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetFolderRequest>): GetFolderRequest {
    return GetFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetFolderRequest>): GetFolderRequest {
    const message = createBaseGetFolderRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListFoldersRequest(): ListFoldersRequest {
  return { parent: "", pageSize: 0, pageToken: "", showDeleted: false };
}

export const ListFoldersRequest: MessageFns<ListFoldersRequest> = {
  encode(message: ListFoldersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.showDeleted !== false) {
      writer.uint32(32).bool(message.showDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFoldersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFoldersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.showDeleted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFoldersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      showDeleted: isSet(object.showDeleted) ? globalThis.Boolean(object.showDeleted) : false,
    };
  },

  toJSON(message: ListFoldersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.showDeleted !== false) {
      obj.showDeleted = message.showDeleted;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFoldersRequest>): ListFoldersRequest {
    return ListFoldersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFoldersRequest>): ListFoldersRequest {
    const message = createBaseListFoldersRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.showDeleted = object.showDeleted ?? false;
    return message;
  },
};

function createBaseListFoldersResponse(): ListFoldersResponse {
  return { folders: [], nextPageToken: "" };
}

export const ListFoldersResponse: MessageFns<ListFoldersResponse> = {
  encode(message: ListFoldersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.folders) {
      Folder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFoldersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFoldersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.folders.push(Folder.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFoldersResponse {
    return {
      folders: globalThis.Array.isArray(object?.folders) ? object.folders.map((e: any) => Folder.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListFoldersResponse): unknown {
    const obj: any = {};
    if (message.folders?.length) {
      obj.folders = message.folders.map((e) => Folder.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFoldersResponse>): ListFoldersResponse {
    return ListFoldersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFoldersResponse>): ListFoldersResponse {
    const message = createBaseListFoldersResponse();
    message.folders = object.folders?.map((e) => Folder.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSearchFoldersRequest(): SearchFoldersRequest {
  return { pageSize: 0, pageToken: "", query: "" };
}

export const SearchFoldersRequest: MessageFns<SearchFoldersRequest> = {
  encode(message: SearchFoldersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.query !== "") {
      writer.uint32(26).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchFoldersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchFoldersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchFoldersRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
    };
  },

  toJSON(message: SearchFoldersRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchFoldersRequest>): SearchFoldersRequest {
    return SearchFoldersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchFoldersRequest>): SearchFoldersRequest {
    const message = createBaseSearchFoldersRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseSearchFoldersResponse(): SearchFoldersResponse {
  return { folders: [], nextPageToken: "" };
}

export const SearchFoldersResponse: MessageFns<SearchFoldersResponse> = {
  encode(message: SearchFoldersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.folders) {
      Folder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchFoldersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchFoldersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.folders.push(Folder.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchFoldersResponse {
    return {
      folders: globalThis.Array.isArray(object?.folders) ? object.folders.map((e: any) => Folder.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchFoldersResponse): unknown {
    const obj: any = {};
    if (message.folders?.length) {
      obj.folders = message.folders.map((e) => Folder.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchFoldersResponse>): SearchFoldersResponse {
    return SearchFoldersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchFoldersResponse>): SearchFoldersResponse {
    const message = createBaseSearchFoldersResponse();
    message.folders = object.folders?.map((e) => Folder.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateFolderRequest(): CreateFolderRequest {
  return { folder: undefined };
}

export const CreateFolderRequest: MessageFns<CreateFolderRequest> = {
  encode(message: CreateFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.folder !== undefined) {
      Folder.encode(message.folder, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.folder = Folder.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFolderRequest {
    return { folder: isSet(object.folder) ? Folder.fromJSON(object.folder) : undefined };
  },

  toJSON(message: CreateFolderRequest): unknown {
    const obj: any = {};
    if (message.folder !== undefined) {
      obj.folder = Folder.toJSON(message.folder);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateFolderRequest>): CreateFolderRequest {
    return CreateFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateFolderRequest>): CreateFolderRequest {
    const message = createBaseCreateFolderRequest();
    message.folder = (object.folder !== undefined && object.folder !== null)
      ? Folder.fromPartial(object.folder)
      : undefined;
    return message;
  },
};

function createBaseCreateFolderMetadata(): CreateFolderMetadata {
  return { displayName: "", parent: "" };
}

export const CreateFolderMetadata: MessageFns<CreateFolderMetadata> = {
  encode(message: CreateFolderMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFolderMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFolderMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFolderMetadata {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: CreateFolderMetadata): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateFolderMetadata>): CreateFolderMetadata {
    return CreateFolderMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateFolderMetadata>): CreateFolderMetadata {
    const message = createBaseCreateFolderMetadata();
    message.displayName = object.displayName ?? "";
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseUpdateFolderRequest(): UpdateFolderRequest {
  return { folder: undefined, updateMask: undefined };
}

export const UpdateFolderRequest: MessageFns<UpdateFolderRequest> = {
  encode(message: UpdateFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.folder !== undefined) {
      Folder.encode(message.folder, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.folder = Folder.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFolderRequest {
    return {
      folder: isSet(object.folder) ? Folder.fromJSON(object.folder) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateFolderRequest): unknown {
    const obj: any = {};
    if (message.folder !== undefined) {
      obj.folder = Folder.toJSON(message.folder);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateFolderRequest>): UpdateFolderRequest {
    return UpdateFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateFolderRequest>): UpdateFolderRequest {
    const message = createBaseUpdateFolderRequest();
    message.folder = (object.folder !== undefined && object.folder !== null)
      ? Folder.fromPartial(object.folder)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUpdateFolderMetadata(): UpdateFolderMetadata {
  return {};
}

export const UpdateFolderMetadata: MessageFns<UpdateFolderMetadata> = {
  encode(_: UpdateFolderMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFolderMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFolderMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateFolderMetadata {
    return {};
  },

  toJSON(_: UpdateFolderMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UpdateFolderMetadata>): UpdateFolderMetadata {
    return UpdateFolderMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UpdateFolderMetadata>): UpdateFolderMetadata {
    const message = createBaseUpdateFolderMetadata();
    return message;
  },
};

function createBaseMoveFolderRequest(): MoveFolderRequest {
  return { name: "", destinationParent: "" };
}

export const MoveFolderRequest: MessageFns<MoveFolderRequest> = {
  encode(message: MoveFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.destinationParent !== "") {
      writer.uint32(18).string(message.destinationParent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destinationParent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveFolderRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      destinationParent: isSet(object.destinationParent) ? globalThis.String(object.destinationParent) : "",
    };
  },

  toJSON(message: MoveFolderRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.destinationParent !== "") {
      obj.destinationParent = message.destinationParent;
    }
    return obj;
  },

  create(base?: DeepPartial<MoveFolderRequest>): MoveFolderRequest {
    return MoveFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MoveFolderRequest>): MoveFolderRequest {
    const message = createBaseMoveFolderRequest();
    message.name = object.name ?? "";
    message.destinationParent = object.destinationParent ?? "";
    return message;
  },
};

function createBaseMoveFolderMetadata(): MoveFolderMetadata {
  return { displayName: "", sourceParent: "", destinationParent: "" };
}

export const MoveFolderMetadata: MessageFns<MoveFolderMetadata> = {
  encode(message: MoveFolderMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.sourceParent !== "") {
      writer.uint32(18).string(message.sourceParent);
    }
    if (message.destinationParent !== "") {
      writer.uint32(26).string(message.destinationParent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveFolderMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveFolderMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceParent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destinationParent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveFolderMetadata {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      sourceParent: isSet(object.sourceParent) ? globalThis.String(object.sourceParent) : "",
      destinationParent: isSet(object.destinationParent) ? globalThis.String(object.destinationParent) : "",
    };
  },

  toJSON(message: MoveFolderMetadata): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.sourceParent !== "") {
      obj.sourceParent = message.sourceParent;
    }
    if (message.destinationParent !== "") {
      obj.destinationParent = message.destinationParent;
    }
    return obj;
  },

  create(base?: DeepPartial<MoveFolderMetadata>): MoveFolderMetadata {
    return MoveFolderMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MoveFolderMetadata>): MoveFolderMetadata {
    const message = createBaseMoveFolderMetadata();
    message.displayName = object.displayName ?? "";
    message.sourceParent = object.sourceParent ?? "";
    message.destinationParent = object.destinationParent ?? "";
    return message;
  },
};

function createBaseDeleteFolderRequest(): DeleteFolderRequest {
  return { name: "" };
}

export const DeleteFolderRequest: MessageFns<DeleteFolderRequest> = {
  encode(message: DeleteFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteFolderRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteFolderRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteFolderRequest>): DeleteFolderRequest {
    return DeleteFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteFolderRequest>): DeleteFolderRequest {
    const message = createBaseDeleteFolderRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteFolderMetadata(): DeleteFolderMetadata {
  return {};
}

export const DeleteFolderMetadata: MessageFns<DeleteFolderMetadata> = {
  encode(_: DeleteFolderMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFolderMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFolderMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteFolderMetadata {
    return {};
  },

  toJSON(_: DeleteFolderMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DeleteFolderMetadata>): DeleteFolderMetadata {
    return DeleteFolderMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeleteFolderMetadata>): DeleteFolderMetadata {
    const message = createBaseDeleteFolderMetadata();
    return message;
  },
};

function createBaseUndeleteFolderRequest(): UndeleteFolderRequest {
  return { name: "" };
}

export const UndeleteFolderRequest: MessageFns<UndeleteFolderRequest> = {
  encode(message: UndeleteFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeleteFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeleteFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeleteFolderRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: UndeleteFolderRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<UndeleteFolderRequest>): UndeleteFolderRequest {
    return UndeleteFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndeleteFolderRequest>): UndeleteFolderRequest {
    const message = createBaseUndeleteFolderRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUndeleteFolderMetadata(): UndeleteFolderMetadata {
  return {};
}

export const UndeleteFolderMetadata: MessageFns<UndeleteFolderMetadata> = {
  encode(_: UndeleteFolderMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeleteFolderMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeleteFolderMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UndeleteFolderMetadata {
    return {};
  },

  toJSON(_: UndeleteFolderMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UndeleteFolderMetadata>): UndeleteFolderMetadata {
    return UndeleteFolderMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UndeleteFolderMetadata>): UndeleteFolderMetadata {
    const message = createBaseUndeleteFolderMetadata();
    return message;
  },
};

/**
 * Manages Cloud Platform folder resources.
 * Folders can be used to organize the resources under an
 * organization and to control the policies applied to groups of resources.
 */
export type FoldersDefinition = typeof FoldersDefinition;
export const FoldersDefinition = {
  name: "Folders",
  fullName: "google.cloud.resourcemanager.v3.Folders",
  methods: {
    /**
     * Retrieves a folder identified by the supplied resource name.
     * Valid folder resource names have the format `folders/{folder_id}`
     * (for example, `folders/1234`).
     * The caller must have `resourcemanager.folders.get` permission on the
     * identified folder.
     */
    getFolder: {
      name: "GetFolder",
      requestType: GetFolderRequest,
      requestStream: false,
      responseType: Folder,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              22,
              18,
              20,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the folders that are direct descendants of supplied parent resource.
     * `list()` provides a strongly consistent view of the folders underneath
     * the specified parent resource.
     * `list()` returns folders sorted based upon the (ascending) lexical ordering
     * of their display_name.
     * The caller must have `resourcemanager.folders.list` permission on the
     * identified parent.
     */
    listFolders: {
      name: "ListFolders",
      requestType: ListFoldersRequest,
      requestStream: false,
      responseType: ListFoldersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [Buffer.from([13, 18, 11, 47, 118, 51, 47, 102, 111, 108, 100, 101, 114, 115])],
        },
      },
    },
    /**
     * Search for folders that match specific filter criteria.
     * `search()` provides an eventually consistent view of the folders a user has
     * access to which meet the specified filter criteria.
     *
     * This will only return folders on which the caller has the
     * permission `resourcemanager.folders.get`.
     */
    searchFolders: {
      name: "SearchFolders",
      requestType: SearchFoldersRequest,
      requestStream: false,
      responseType: SearchFoldersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([5, 113, 117, 101, 114, 121])],
          578365826: [
            Buffer.from([
              20,
              18,
              18,
              47,
              118,
              51,
              47,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a folder in the resource hierarchy.
     * Returns an `Operation` which can be used to track the progress of the
     * folder creation workflow.
     * Upon success, the `Operation.response` field will be populated with the
     * created Folder.
     *
     * In order to succeed, the addition of this new folder must not violate
     * the folder naming, height, or fanout constraints.
     *
     * + The folder's `display_name` must be distinct from all other folders that
     * share its parent.
     * + The addition of the folder must not cause the active folder hierarchy
     * to exceed a height of 10. Note, the full active + deleted folder hierarchy
     * is allowed to reach a height of 20; this provides additional headroom when
     * moving folders that contain deleted folders.
     * + The addition of the folder must not cause the total number of folders
     * under its parent to exceed 300.
     *
     * If the operation fails due to a folder constraint violation, some errors
     * may be returned by the `CreateFolder` request, with status code
     * `FAILED_PRECONDITION` and an error description. Other folder constraint
     * violations will be communicated in the `Operation`, with the specific
     * `PreconditionFailure` returned in the details list in the `Operation.error`
     * field.
     *
     * The caller must have `resourcemanager.folders.create` permission on the
     * identified parent.
     */
    createFolder: {
      name: "CreateFolder",
      requestType: CreateFolderRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              30,
              10,
              6,
              70,
              111,
              108,
              100,
              101,
              114,
              18,
              20,
              67,
              114,
              101,
              97,
              116,
              101,
              70,
              111,
              108,
              100,
              101,
              114,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([6, 102, 111, 108, 100, 101, 114])],
          578365826: [
            Buffer.from([
              21,
              58,
              6,
              102,
              111,
              108,
              100,
              101,
              114,
              34,
              11,
              47,
              118,
              51,
              47,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a folder, changing its `display_name`.
     * Changes to the folder `display_name` will be rejected if they violate
     * either the `display_name` formatting rules or the naming constraints
     * described in the
     * [CreateFolder][google.cloud.resourcemanager.v3.Folders.CreateFolder]
     * documentation.
     *
     * The folder's `display_name` must start and end with a letter or digit,
     * may contain letters, digits, spaces, hyphens and underscores and can be
     * between 3 and 30 characters. This is captured by the regular expression:
     * `[\p{L}\p{N}][\p{L}\p{N}_- ]{1,28}[\p{L}\p{N}]`.
     * The caller must have `resourcemanager.folders.update` permission on the
     * identified folder.
     *
     * If the update fails due to the unique name constraint then a
     * `PreconditionFailure` explaining this violation will be returned
     * in the Status.details field.
     */
    updateFolder: {
      name: "UpdateFolder",
      requestType: UpdateFolderRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              30,
              10,
              6,
              70,
              111,
              108,
              100,
              101,
              114,
              18,
              20,
              85,
              112,
              100,
              97,
              116,
              101,
              70,
              111,
              108,
              100,
              101,
              114,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([18, 102, 111, 108, 100, 101, 114, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              37,
              58,
              6,
              102,
              111,
              108,
              100,
              101,
              114,
              50,
              27,
              47,
              118,
              51,
              47,
              123,
              102,
              111,
              108,
              100,
              101,
              114,
              46,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Moves a folder under a new resource parent.
     * Returns an `Operation` which can be used to track the progress of the
     * folder move workflow.
     * Upon success, the `Operation.response` field will be populated with the
     * moved folder.
     * Upon failure, a `FolderOperationError` categorizing the failure cause will
     * be returned - if the failure occurs synchronously then the
     * `FolderOperationError` will be returned in the `Status.details` field.
     * If it occurs asynchronously, then the FolderOperation will be returned
     * in the `Operation.error` field.
     * In addition, the `Operation.metadata` field will be populated with a
     * `FolderOperation` message as an aid to stateless clients.
     * Folder moves will be rejected if they violate either the naming, height,
     * or fanout constraints described in the
     * [CreateFolder][google.cloud.resourcemanager.v3.Folders.CreateFolder]
     * documentation. The caller must have `resourcemanager.folders.move`
     * permission on the folder's current and proposed new parent.
     */
    moveFolder: {
      name: "MoveFolder",
      requestType: MoveFolderRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              6,
              70,
              111,
              108,
              100,
              101,
              114,
              18,
              18,
              77,
              111,
              118,
              101,
              70,
              111,
              108,
              100,
              101,
              114,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              110,
              97,
              109,
              101,
              44,
              100,
              101,
              115,
              116,
              105,
              110,
              97,
              116,
              105,
              111,
              110,
              95,
              112,
              97,
              114,
              101,
              110,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              30,
              58,
              1,
              42,
              34,
              25,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              109,
              111,
              118,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Requests deletion of a folder. The folder is moved into the
     * [DELETE_REQUESTED][google.cloud.resourcemanager.v3.Folder.State.DELETE_REQUESTED]
     * state immediately, and is deleted approximately 30 days later. This method
     * may only be called on an empty folder, where a folder is empty if it
     * doesn't contain any folders or projects in the
     * [ACTIVE][google.cloud.resourcemanager.v3.Folder.State.ACTIVE] state. If
     * called on a folder in
     * [DELETE_REQUESTED][google.cloud.resourcemanager.v3.Folder.State.DELETE_REQUESTED]
     * state the operation will result in a no-op success.
     * The caller must have `resourcemanager.folders.delete` permission on the
     * identified folder.
     */
    deleteFolder: {
      name: "DeleteFolder",
      requestType: DeleteFolderRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              30,
              10,
              6,
              70,
              111,
              108,
              100,
              101,
              114,
              18,
              20,
              68,
              101,
              108,
              101,
              116,
              101,
              70,
              111,
              108,
              100,
              101,
              114,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              22,
              42,
              20,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Cancels the deletion request for a folder. This method may be called on a
     * folder in any state. If the folder is in the
     * [ACTIVE][google.cloud.resourcemanager.v3.Folder.State.ACTIVE] state the
     * result will be a no-op success. In order to succeed, the folder's parent
     * must be in the
     * [ACTIVE][google.cloud.resourcemanager.v3.Folder.State.ACTIVE] state. In
     * addition, reintroducing the folder into the tree must not violate folder
     * naming, height, and fanout constraints described in the
     * [CreateFolder][google.cloud.resourcemanager.v3.Folders.CreateFolder]
     * documentation. The caller must have `resourcemanager.folders.undelete`
     * permission on the identified folder.
     */
    undeleteFolder: {
      name: "UndeleteFolder",
      requestType: UndeleteFolderRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              6,
              70,
              111,
              108,
              100,
              101,
              114,
              18,
              22,
              85,
              110,
              100,
              101,
              108,
              101,
              116,
              101,
              70,
              111,
              108,
              100,
              101,
              114,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              34,
              58,
              1,
              42,
              34,
              29,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              117,
              110,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the access control policy for a folder. The returned policy may be
     * empty if no such policy or resource exists. The `resource` field should
     * be the folder's resource name, for example: "folders/1234".
     * The caller must have `resourcemanager.folders.getIamPolicy` permission
     * on the identified folder.
     */
    getIamPolicy: {
      name: "GetIamPolicy",
      requestType: GetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([8, 114, 101, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              42,
              58,
              1,
              42,
              34,
              37,
              47,
              118,
              51,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Sets the access control policy on a folder, replacing any existing policy.
     * The `resource` field should be the folder's resource name, for example:
     * "folders/1234".
     * The caller must have `resourcemanager.folders.setIamPolicy` permission
     * on the identified folder.
     */
    setIamPolicy: {
      name: "SetIamPolicy",
      requestType: SetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 114, 101, 115, 111, 117, 114, 99, 101, 44, 112, 111, 108, 105, 99, 121])],
          578365826: [
            Buffer.from([
              42,
              58,
              1,
              42,
              34,
              37,
              47,
              118,
              51,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Returns permissions that a caller has on the specified folder.
     * The `resource` field should be the folder's resource name,
     * for example: "folders/1234".
     *
     * There are no permissions required for making this API call.
     */
    testIamPermissions: {
      name: "TestIamPermissions",
      requestType: TestIamPermissionsRequest,
      requestStream: false,
      responseType: TestIamPermissionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              112,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              48,
              58,
              1,
              42,
              34,
              43,
              47,
              118,
              51,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              116,
              101,
              115,
              116,
              73,
              97,
              109,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface FoldersServiceImplementation<CallContextExt = {}> {
  /**
   * Retrieves a folder identified by the supplied resource name.
   * Valid folder resource names have the format `folders/{folder_id}`
   * (for example, `folders/1234`).
   * The caller must have `resourcemanager.folders.get` permission on the
   * identified folder.
   */
  getFolder(request: GetFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Folder>>;
  /**
   * Lists the folders that are direct descendants of supplied parent resource.
   * `list()` provides a strongly consistent view of the folders underneath
   * the specified parent resource.
   * `list()` returns folders sorted based upon the (ascending) lexical ordering
   * of their display_name.
   * The caller must have `resourcemanager.folders.list` permission on the
   * identified parent.
   */
  listFolders(
    request: ListFoldersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListFoldersResponse>>;
  /**
   * Search for folders that match specific filter criteria.
   * `search()` provides an eventually consistent view of the folders a user has
   * access to which meet the specified filter criteria.
   *
   * This will only return folders on which the caller has the
   * permission `resourcemanager.folders.get`.
   */
  searchFolders(
    request: SearchFoldersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchFoldersResponse>>;
  /**
   * Creates a folder in the resource hierarchy.
   * Returns an `Operation` which can be used to track the progress of the
   * folder creation workflow.
   * Upon success, the `Operation.response` field will be populated with the
   * created Folder.
   *
   * In order to succeed, the addition of this new folder must not violate
   * the folder naming, height, or fanout constraints.
   *
   * + The folder's `display_name` must be distinct from all other folders that
   * share its parent.
   * + The addition of the folder must not cause the active folder hierarchy
   * to exceed a height of 10. Note, the full active + deleted folder hierarchy
   * is allowed to reach a height of 20; this provides additional headroom when
   * moving folders that contain deleted folders.
   * + The addition of the folder must not cause the total number of folders
   * under its parent to exceed 300.
   *
   * If the operation fails due to a folder constraint violation, some errors
   * may be returned by the `CreateFolder` request, with status code
   * `FAILED_PRECONDITION` and an error description. Other folder constraint
   * violations will be communicated in the `Operation`, with the specific
   * `PreconditionFailure` returned in the details list in the `Operation.error`
   * field.
   *
   * The caller must have `resourcemanager.folders.create` permission on the
   * identified parent.
   */
  createFolder(request: CreateFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Updates a folder, changing its `display_name`.
   * Changes to the folder `display_name` will be rejected if they violate
   * either the `display_name` formatting rules or the naming constraints
   * described in the
   * [CreateFolder][google.cloud.resourcemanager.v3.Folders.CreateFolder]
   * documentation.
   *
   * The folder's `display_name` must start and end with a letter or digit,
   * may contain letters, digits, spaces, hyphens and underscores and can be
   * between 3 and 30 characters. This is captured by the regular expression:
   * `[\p{L}\p{N}][\p{L}\p{N}_- ]{1,28}[\p{L}\p{N}]`.
   * The caller must have `resourcemanager.folders.update` permission on the
   * identified folder.
   *
   * If the update fails due to the unique name constraint then a
   * `PreconditionFailure` explaining this violation will be returned
   * in the Status.details field.
   */
  updateFolder(request: UpdateFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Moves a folder under a new resource parent.
   * Returns an `Operation` which can be used to track the progress of the
   * folder move workflow.
   * Upon success, the `Operation.response` field will be populated with the
   * moved folder.
   * Upon failure, a `FolderOperationError` categorizing the failure cause will
   * be returned - if the failure occurs synchronously then the
   * `FolderOperationError` will be returned in the `Status.details` field.
   * If it occurs asynchronously, then the FolderOperation will be returned
   * in the `Operation.error` field.
   * In addition, the `Operation.metadata` field will be populated with a
   * `FolderOperation` message as an aid to stateless clients.
   * Folder moves will be rejected if they violate either the naming, height,
   * or fanout constraints described in the
   * [CreateFolder][google.cloud.resourcemanager.v3.Folders.CreateFolder]
   * documentation. The caller must have `resourcemanager.folders.move`
   * permission on the folder's current and proposed new parent.
   */
  moveFolder(request: MoveFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Requests deletion of a folder. The folder is moved into the
   * [DELETE_REQUESTED][google.cloud.resourcemanager.v3.Folder.State.DELETE_REQUESTED]
   * state immediately, and is deleted approximately 30 days later. This method
   * may only be called on an empty folder, where a folder is empty if it
   * doesn't contain any folders or projects in the
   * [ACTIVE][google.cloud.resourcemanager.v3.Folder.State.ACTIVE] state. If
   * called on a folder in
   * [DELETE_REQUESTED][google.cloud.resourcemanager.v3.Folder.State.DELETE_REQUESTED]
   * state the operation will result in a no-op success.
   * The caller must have `resourcemanager.folders.delete` permission on the
   * identified folder.
   */
  deleteFolder(request: DeleteFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Cancels the deletion request for a folder. This method may be called on a
   * folder in any state. If the folder is in the
   * [ACTIVE][google.cloud.resourcemanager.v3.Folder.State.ACTIVE] state the
   * result will be a no-op success. In order to succeed, the folder's parent
   * must be in the
   * [ACTIVE][google.cloud.resourcemanager.v3.Folder.State.ACTIVE] state. In
   * addition, reintroducing the folder into the tree must not violate folder
   * naming, height, and fanout constraints described in the
   * [CreateFolder][google.cloud.resourcemanager.v3.Folders.CreateFolder]
   * documentation. The caller must have `resourcemanager.folders.undelete`
   * permission on the identified folder.
   */
  undeleteFolder(
    request: UndeleteFolderRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Gets the access control policy for a folder. The returned policy may be
   * empty if no such policy or resource exists. The `resource` field should
   * be the folder's resource name, for example: "folders/1234".
   * The caller must have `resourcemanager.folders.getIamPolicy` permission
   * on the identified folder.
   */
  getIamPolicy(request: GetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Sets the access control policy on a folder, replacing any existing policy.
   * The `resource` field should be the folder's resource name, for example:
   * "folders/1234".
   * The caller must have `resourcemanager.folders.setIamPolicy` permission
   * on the identified folder.
   */
  setIamPolicy(request: SetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Returns permissions that a caller has on the specified folder.
   * The `resource` field should be the folder's resource name,
   * for example: "folders/1234".
   *
   * There are no permissions required for making this API call.
   */
  testIamPermissions(
    request: TestIamPermissionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestIamPermissionsResponse>>;
}

export interface FoldersClient<CallOptionsExt = {}> {
  /**
   * Retrieves a folder identified by the supplied resource name.
   * Valid folder resource names have the format `folders/{folder_id}`
   * (for example, `folders/1234`).
   * The caller must have `resourcemanager.folders.get` permission on the
   * identified folder.
   */
  getFolder(request: DeepPartial<GetFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Folder>;
  /**
   * Lists the folders that are direct descendants of supplied parent resource.
   * `list()` provides a strongly consistent view of the folders underneath
   * the specified parent resource.
   * `list()` returns folders sorted based upon the (ascending) lexical ordering
   * of their display_name.
   * The caller must have `resourcemanager.folders.list` permission on the
   * identified parent.
   */
  listFolders(
    request: DeepPartial<ListFoldersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListFoldersResponse>;
  /**
   * Search for folders that match specific filter criteria.
   * `search()` provides an eventually consistent view of the folders a user has
   * access to which meet the specified filter criteria.
   *
   * This will only return folders on which the caller has the
   * permission `resourcemanager.folders.get`.
   */
  searchFolders(
    request: DeepPartial<SearchFoldersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchFoldersResponse>;
  /**
   * Creates a folder in the resource hierarchy.
   * Returns an `Operation` which can be used to track the progress of the
   * folder creation workflow.
   * Upon success, the `Operation.response` field will be populated with the
   * created Folder.
   *
   * In order to succeed, the addition of this new folder must not violate
   * the folder naming, height, or fanout constraints.
   *
   * + The folder's `display_name` must be distinct from all other folders that
   * share its parent.
   * + The addition of the folder must not cause the active folder hierarchy
   * to exceed a height of 10. Note, the full active + deleted folder hierarchy
   * is allowed to reach a height of 20; this provides additional headroom when
   * moving folders that contain deleted folders.
   * + The addition of the folder must not cause the total number of folders
   * under its parent to exceed 300.
   *
   * If the operation fails due to a folder constraint violation, some errors
   * may be returned by the `CreateFolder` request, with status code
   * `FAILED_PRECONDITION` and an error description. Other folder constraint
   * violations will be communicated in the `Operation`, with the specific
   * `PreconditionFailure` returned in the details list in the `Operation.error`
   * field.
   *
   * The caller must have `resourcemanager.folders.create` permission on the
   * identified parent.
   */
  createFolder(request: DeepPartial<CreateFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Updates a folder, changing its `display_name`.
   * Changes to the folder `display_name` will be rejected if they violate
   * either the `display_name` formatting rules or the naming constraints
   * described in the
   * [CreateFolder][google.cloud.resourcemanager.v3.Folders.CreateFolder]
   * documentation.
   *
   * The folder's `display_name` must start and end with a letter or digit,
   * may contain letters, digits, spaces, hyphens and underscores and can be
   * between 3 and 30 characters. This is captured by the regular expression:
   * `[\p{L}\p{N}][\p{L}\p{N}_- ]{1,28}[\p{L}\p{N}]`.
   * The caller must have `resourcemanager.folders.update` permission on the
   * identified folder.
   *
   * If the update fails due to the unique name constraint then a
   * `PreconditionFailure` explaining this violation will be returned
   * in the Status.details field.
   */
  updateFolder(request: DeepPartial<UpdateFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Moves a folder under a new resource parent.
   * Returns an `Operation` which can be used to track the progress of the
   * folder move workflow.
   * Upon success, the `Operation.response` field will be populated with the
   * moved folder.
   * Upon failure, a `FolderOperationError` categorizing the failure cause will
   * be returned - if the failure occurs synchronously then the
   * `FolderOperationError` will be returned in the `Status.details` field.
   * If it occurs asynchronously, then the FolderOperation will be returned
   * in the `Operation.error` field.
   * In addition, the `Operation.metadata` field will be populated with a
   * `FolderOperation` message as an aid to stateless clients.
   * Folder moves will be rejected if they violate either the naming, height,
   * or fanout constraints described in the
   * [CreateFolder][google.cloud.resourcemanager.v3.Folders.CreateFolder]
   * documentation. The caller must have `resourcemanager.folders.move`
   * permission on the folder's current and proposed new parent.
   */
  moveFolder(request: DeepPartial<MoveFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Requests deletion of a folder. The folder is moved into the
   * [DELETE_REQUESTED][google.cloud.resourcemanager.v3.Folder.State.DELETE_REQUESTED]
   * state immediately, and is deleted approximately 30 days later. This method
   * may only be called on an empty folder, where a folder is empty if it
   * doesn't contain any folders or projects in the
   * [ACTIVE][google.cloud.resourcemanager.v3.Folder.State.ACTIVE] state. If
   * called on a folder in
   * [DELETE_REQUESTED][google.cloud.resourcemanager.v3.Folder.State.DELETE_REQUESTED]
   * state the operation will result in a no-op success.
   * The caller must have `resourcemanager.folders.delete` permission on the
   * identified folder.
   */
  deleteFolder(request: DeepPartial<DeleteFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Cancels the deletion request for a folder. This method may be called on a
   * folder in any state. If the folder is in the
   * [ACTIVE][google.cloud.resourcemanager.v3.Folder.State.ACTIVE] state the
   * result will be a no-op success. In order to succeed, the folder's parent
   * must be in the
   * [ACTIVE][google.cloud.resourcemanager.v3.Folder.State.ACTIVE] state. In
   * addition, reintroducing the folder into the tree must not violate folder
   * naming, height, and fanout constraints described in the
   * [CreateFolder][google.cloud.resourcemanager.v3.Folders.CreateFolder]
   * documentation. The caller must have `resourcemanager.folders.undelete`
   * permission on the identified folder.
   */
  undeleteFolder(
    request: DeepPartial<UndeleteFolderRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Gets the access control policy for a folder. The returned policy may be
   * empty if no such policy or resource exists. The `resource` field should
   * be the folder's resource name, for example: "folders/1234".
   * The caller must have `resourcemanager.folders.getIamPolicy` permission
   * on the identified folder.
   */
  getIamPolicy(request: DeepPartial<GetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Sets the access control policy on a folder, replacing any existing policy.
   * The `resource` field should be the folder's resource name, for example:
   * "folders/1234".
   * The caller must have `resourcemanager.folders.setIamPolicy` permission
   * on the identified folder.
   */
  setIamPolicy(request: DeepPartial<SetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Returns permissions that a caller has on the specified folder.
   * The `resource` field should be the folder's resource name,
   * for example: "folders/1234".
   *
   * There are no permissions required for making this API call.
   */
  testIamPermissions(
    request: DeepPartial<TestIamPermissionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestIamPermissionsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
