// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/vision/v1p2beta1/web_detection.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.vision.v1p2beta1";

/** Relevant information for the image from the Internet. */
export interface WebDetection {
  /** Deduced entities from similar images on the Internet. */
  webEntities: WebDetection_WebEntity[];
  /**
   * Fully matching images from the Internet.
   * Can include resized copies of the query image.
   */
  fullMatchingImages: WebDetection_WebImage[];
  /**
   * Partial matching images from the Internet.
   * Those images are similar enough to share some key-point features. For
   * example an original image will likely have partial matching for its crops.
   */
  partialMatchingImages: WebDetection_WebImage[];
  /** Web pages containing the matching images from the Internet. */
  pagesWithMatchingImages: WebDetection_WebPage[];
  /** The visually similar image results. */
  visuallySimilarImages: WebDetection_WebImage[];
  /** Best guess text labels for the request image. */
  bestGuessLabels: WebDetection_WebLabel[];
}

/** Entity deduced from similar images on the Internet. */
export interface WebDetection_WebEntity {
  /** Opaque entity ID. */
  entityId: string;
  /**
   * Overall relevancy score for the entity.
   * Not normalized and not comparable across different image queries.
   */
  score: number;
  /** Canonical description of the entity, in English. */
  description: string;
}

/** Metadata for online images. */
export interface WebDetection_WebImage {
  /** The result image URL. */
  url: string;
  /** (Deprecated) Overall relevancy score for the image. */
  score: number;
}

/** Metadata for web pages. */
export interface WebDetection_WebPage {
  /** The result web page URL. */
  url: string;
  /** (Deprecated) Overall relevancy score for the web page. */
  score: number;
  /** Title for the web page, may contain HTML markups. */
  pageTitle: string;
  /**
   * Fully matching images on the page.
   * Can include resized copies of the query image.
   */
  fullMatchingImages: WebDetection_WebImage[];
  /**
   * Partial matching images on the page.
   * Those images are similar enough to share some key-point features. For
   * example an original image will likely have partial matching for its
   * crops.
   */
  partialMatchingImages: WebDetection_WebImage[];
}

/** Label to provide extra metadata for the web detection. */
export interface WebDetection_WebLabel {
  /** Label for extra metadata. */
  label: string;
  /**
   * The BCP-47 language code for `label`, such as "en-US" or "sr-Latn".
   * For more information, see
   * http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
   */
  languageCode: string;
}

function createBaseWebDetection(): WebDetection {
  return {
    webEntities: [],
    fullMatchingImages: [],
    partialMatchingImages: [],
    pagesWithMatchingImages: [],
    visuallySimilarImages: [],
    bestGuessLabels: [],
  };
}

export const WebDetection: MessageFns<WebDetection> = {
  encode(message: WebDetection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.webEntities) {
      WebDetection_WebEntity.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.fullMatchingImages) {
      WebDetection_WebImage.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.partialMatchingImages) {
      WebDetection_WebImage.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.pagesWithMatchingImages) {
      WebDetection_WebPage.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.visuallySimilarImages) {
      WebDetection_WebImage.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.bestGuessLabels) {
      WebDetection_WebLabel.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebDetection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebDetection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.webEntities.push(WebDetection_WebEntity.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fullMatchingImages.push(WebDetection_WebImage.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.partialMatchingImages.push(WebDetection_WebImage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pagesWithMatchingImages.push(WebDetection_WebPage.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.visuallySimilarImages.push(WebDetection_WebImage.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.bestGuessLabels.push(WebDetection_WebLabel.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebDetection {
    return {
      webEntities: globalThis.Array.isArray(object?.webEntities)
        ? object.webEntities.map((e: any) => WebDetection_WebEntity.fromJSON(e))
        : [],
      fullMatchingImages: globalThis.Array.isArray(object?.fullMatchingImages)
        ? object.fullMatchingImages.map((e: any) => WebDetection_WebImage.fromJSON(e))
        : [],
      partialMatchingImages: globalThis.Array.isArray(object?.partialMatchingImages)
        ? object.partialMatchingImages.map((e: any) => WebDetection_WebImage.fromJSON(e))
        : [],
      pagesWithMatchingImages: globalThis.Array.isArray(object?.pagesWithMatchingImages)
        ? object.pagesWithMatchingImages.map((e: any) => WebDetection_WebPage.fromJSON(e))
        : [],
      visuallySimilarImages: globalThis.Array.isArray(object?.visuallySimilarImages)
        ? object.visuallySimilarImages.map((e: any) => WebDetection_WebImage.fromJSON(e))
        : [],
      bestGuessLabels: globalThis.Array.isArray(object?.bestGuessLabels)
        ? object.bestGuessLabels.map((e: any) => WebDetection_WebLabel.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WebDetection): unknown {
    const obj: any = {};
    if (message.webEntities?.length) {
      obj.webEntities = message.webEntities.map((e) => WebDetection_WebEntity.toJSON(e));
    }
    if (message.fullMatchingImages?.length) {
      obj.fullMatchingImages = message.fullMatchingImages.map((e) => WebDetection_WebImage.toJSON(e));
    }
    if (message.partialMatchingImages?.length) {
      obj.partialMatchingImages = message.partialMatchingImages.map((e) => WebDetection_WebImage.toJSON(e));
    }
    if (message.pagesWithMatchingImages?.length) {
      obj.pagesWithMatchingImages = message.pagesWithMatchingImages.map((e) => WebDetection_WebPage.toJSON(e));
    }
    if (message.visuallySimilarImages?.length) {
      obj.visuallySimilarImages = message.visuallySimilarImages.map((e) => WebDetection_WebImage.toJSON(e));
    }
    if (message.bestGuessLabels?.length) {
      obj.bestGuessLabels = message.bestGuessLabels.map((e) => WebDetection_WebLabel.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WebDetection>): WebDetection {
    return WebDetection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebDetection>): WebDetection {
    const message = createBaseWebDetection();
    message.webEntities = object.webEntities?.map((e) => WebDetection_WebEntity.fromPartial(e)) || [];
    message.fullMatchingImages = object.fullMatchingImages?.map((e) => WebDetection_WebImage.fromPartial(e)) || [];
    message.partialMatchingImages = object.partialMatchingImages?.map((e) => WebDetection_WebImage.fromPartial(e)) ||
      [];
    message.pagesWithMatchingImages = object.pagesWithMatchingImages?.map((e) => WebDetection_WebPage.fromPartial(e)) ||
      [];
    message.visuallySimilarImages = object.visuallySimilarImages?.map((e) => WebDetection_WebImage.fromPartial(e)) ||
      [];
    message.bestGuessLabels = object.bestGuessLabels?.map((e) => WebDetection_WebLabel.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWebDetection_WebEntity(): WebDetection_WebEntity {
  return { entityId: "", score: 0, description: "" };
}

export const WebDetection_WebEntity: MessageFns<WebDetection_WebEntity> = {
  encode(message: WebDetection_WebEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityId !== "") {
      writer.uint32(10).string(message.entityId);
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebDetection_WebEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebDetection_WebEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityId = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebDetection_WebEntity {
    return {
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: WebDetection_WebEntity): unknown {
    const obj: any = {};
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<WebDetection_WebEntity>): WebDetection_WebEntity {
    return WebDetection_WebEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebDetection_WebEntity>): WebDetection_WebEntity {
    const message = createBaseWebDetection_WebEntity();
    message.entityId = object.entityId ?? "";
    message.score = object.score ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseWebDetection_WebImage(): WebDetection_WebImage {
  return { url: "", score: 0 };
}

export const WebDetection_WebImage: MessageFns<WebDetection_WebImage> = {
  encode(message: WebDetection_WebImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebDetection_WebImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebDetection_WebImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebDetection_WebImage {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
    };
  },

  toJSON(message: WebDetection_WebImage): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<WebDetection_WebImage>): WebDetection_WebImage {
    return WebDetection_WebImage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebDetection_WebImage>): WebDetection_WebImage {
    const message = createBaseWebDetection_WebImage();
    message.url = object.url ?? "";
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseWebDetection_WebPage(): WebDetection_WebPage {
  return { url: "", score: 0, pageTitle: "", fullMatchingImages: [], partialMatchingImages: [] };
}

export const WebDetection_WebPage: MessageFns<WebDetection_WebPage> = {
  encode(message: WebDetection_WebPage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    if (message.pageTitle !== "") {
      writer.uint32(26).string(message.pageTitle);
    }
    for (const v of message.fullMatchingImages) {
      WebDetection_WebImage.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.partialMatchingImages) {
      WebDetection_WebImage.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebDetection_WebPage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebDetection_WebPage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageTitle = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fullMatchingImages.push(WebDetection_WebImage.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.partialMatchingImages.push(WebDetection_WebImage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebDetection_WebPage {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      pageTitle: isSet(object.pageTitle) ? globalThis.String(object.pageTitle) : "",
      fullMatchingImages: globalThis.Array.isArray(object?.fullMatchingImages)
        ? object.fullMatchingImages.map((e: any) => WebDetection_WebImage.fromJSON(e))
        : [],
      partialMatchingImages: globalThis.Array.isArray(object?.partialMatchingImages)
        ? object.partialMatchingImages.map((e: any) => WebDetection_WebImage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WebDetection_WebPage): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.pageTitle !== "") {
      obj.pageTitle = message.pageTitle;
    }
    if (message.fullMatchingImages?.length) {
      obj.fullMatchingImages = message.fullMatchingImages.map((e) => WebDetection_WebImage.toJSON(e));
    }
    if (message.partialMatchingImages?.length) {
      obj.partialMatchingImages = message.partialMatchingImages.map((e) => WebDetection_WebImage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WebDetection_WebPage>): WebDetection_WebPage {
    return WebDetection_WebPage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebDetection_WebPage>): WebDetection_WebPage {
    const message = createBaseWebDetection_WebPage();
    message.url = object.url ?? "";
    message.score = object.score ?? 0;
    message.pageTitle = object.pageTitle ?? "";
    message.fullMatchingImages = object.fullMatchingImages?.map((e) => WebDetection_WebImage.fromPartial(e)) || [];
    message.partialMatchingImages = object.partialMatchingImages?.map((e) => WebDetection_WebImage.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseWebDetection_WebLabel(): WebDetection_WebLabel {
  return { label: "", languageCode: "" };
}

export const WebDetection_WebLabel: MessageFns<WebDetection_WebLabel> = {
  encode(message: WebDetection_WebLabel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebDetection_WebLabel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebDetection_WebLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebDetection_WebLabel {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: WebDetection_WebLabel): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<WebDetection_WebLabel>): WebDetection_WebLabel {
    return WebDetection_WebLabel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebDetection_WebLabel>): WebDetection_WebLabel {
    const message = createBaseWebDetection_WebLabel();
    message.label = object.label ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
