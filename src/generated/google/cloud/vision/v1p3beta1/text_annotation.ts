// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/vision/v1p3beta1/text_annotation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { BoundingPoly } from "./geometry.js";

export const protobufPackage = "google.cloud.vision.v1p3beta1";

/**
 * TextAnnotation contains a structured representation of OCR extracted text.
 * The hierarchy of an OCR extracted text structure is like this:
 *     TextAnnotation -> Page -> Block -> Paragraph -> Word -> Symbol
 * Each structural component, starting from Page, may further have their own
 * properties. Properties describe detected languages, breaks etc.. Please refer
 * to the
 * [TextAnnotation.TextProperty][google.cloud.vision.v1p3beta1.TextAnnotation.TextProperty]
 * message definition below for more detail.
 */
export interface TextAnnotation {
  /** List of pages detected by OCR. */
  pages: Page[];
  /** UTF-8 text detected on the pages. */
  text: string;
}

/** Detected language for a structural component. */
export interface TextAnnotation_DetectedLanguage {
  /**
   * The BCP-47 language code, such as "en-US" or "sr-Latn". For more
   * information, see
   * http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
   */
  languageCode: string;
  /** Confidence of detected language. Range [0, 1]. */
  confidence: number;
}

/** Detected start or end of a structural component. */
export interface TextAnnotation_DetectedBreak {
  /** Detected break type. */
  type: TextAnnotation_DetectedBreak_BreakType;
  /** True if break prepends the element. */
  isPrefix: boolean;
}

/** Enum to denote the type of break found. New line, space etc. */
export enum TextAnnotation_DetectedBreak_BreakType {
  /** UNKNOWN - Unknown break label type. */
  UNKNOWN = 0,
  /** SPACE - Regular space. */
  SPACE = 1,
  /** SURE_SPACE - Sure space (very wide). */
  SURE_SPACE = 2,
  /** EOL_SURE_SPACE - Line-wrapping break. */
  EOL_SURE_SPACE = 3,
  /**
   * HYPHEN - End-line hyphen that is not present in text; does not co-occur with
   * `SPACE`, `LEADER_SPACE`, or `LINE_BREAK`.
   */
  HYPHEN = 4,
  /** LINE_BREAK - Line break that ends a paragraph. */
  LINE_BREAK = 5,
  UNRECOGNIZED = -1,
}

export function textAnnotation_DetectedBreak_BreakTypeFromJSON(object: any): TextAnnotation_DetectedBreak_BreakType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return TextAnnotation_DetectedBreak_BreakType.UNKNOWN;
    case 1:
    case "SPACE":
      return TextAnnotation_DetectedBreak_BreakType.SPACE;
    case 2:
    case "SURE_SPACE":
      return TextAnnotation_DetectedBreak_BreakType.SURE_SPACE;
    case 3:
    case "EOL_SURE_SPACE":
      return TextAnnotation_DetectedBreak_BreakType.EOL_SURE_SPACE;
    case 4:
    case "HYPHEN":
      return TextAnnotation_DetectedBreak_BreakType.HYPHEN;
    case 5:
    case "LINE_BREAK":
      return TextAnnotation_DetectedBreak_BreakType.LINE_BREAK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TextAnnotation_DetectedBreak_BreakType.UNRECOGNIZED;
  }
}

export function textAnnotation_DetectedBreak_BreakTypeToJSON(object: TextAnnotation_DetectedBreak_BreakType): string {
  switch (object) {
    case TextAnnotation_DetectedBreak_BreakType.UNKNOWN:
      return "UNKNOWN";
    case TextAnnotation_DetectedBreak_BreakType.SPACE:
      return "SPACE";
    case TextAnnotation_DetectedBreak_BreakType.SURE_SPACE:
      return "SURE_SPACE";
    case TextAnnotation_DetectedBreak_BreakType.EOL_SURE_SPACE:
      return "EOL_SURE_SPACE";
    case TextAnnotation_DetectedBreak_BreakType.HYPHEN:
      return "HYPHEN";
    case TextAnnotation_DetectedBreak_BreakType.LINE_BREAK:
      return "LINE_BREAK";
    case TextAnnotation_DetectedBreak_BreakType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Additional information detected on the structural component. */
export interface TextAnnotation_TextProperty {
  /** A list of detected languages together with confidence. */
  detectedLanguages: TextAnnotation_DetectedLanguage[];
  /** Detected start or end of a text segment. */
  detectedBreak: TextAnnotation_DetectedBreak | undefined;
}

/** Detected page from OCR. */
export interface Page {
  /** Additional information detected on the page. */
  property:
    | TextAnnotation_TextProperty
    | undefined;
  /**
   * Page width. For PDFs the unit is points. For images (including
   * TIFFs) the unit is pixels.
   */
  width: number;
  /**
   * Page height. For PDFs the unit is points. For images (including
   * TIFFs) the unit is pixels.
   */
  height: number;
  /** List of blocks of text, images etc on this page. */
  blocks: Block[];
  /** Confidence of the OCR results on the page. Range [0, 1]. */
  confidence: number;
}

/** Logical element on the page. */
export interface Block {
  /** Additional information detected for the block. */
  property:
    | TextAnnotation_TextProperty
    | undefined;
  /**
   * The bounding box for the block.
   * The vertices are in the order of top-left, top-right, bottom-right,
   * bottom-left. When a rotation of the bounding box is detected the rotation
   * is represented as around the top-left corner as defined when the text is
   * read in the 'natural' orientation.
   * For example:
   *
   * * when the text is horizontal it might look like:
   *
   *         0----1
   *         |    |
   *         3----2
   *
   * * when it's rotated 180 degrees around the top-left corner it becomes:
   *
   *         2----3
   *         |    |
   *         1----0
   *
   *   and the vertice order will still be (0, 1, 2, 3).
   */
  boundingBox:
    | BoundingPoly
    | undefined;
  /** List of paragraphs in this block (if this blocks is of type text). */
  paragraphs: Paragraph[];
  /** Detected block type (text, image etc) for this block. */
  blockType: Block_BlockType;
  /** Confidence of the OCR results on the block. Range [0, 1]. */
  confidence: number;
}

/** Type of a block (text, image etc) as identified by OCR. */
export enum Block_BlockType {
  /** UNKNOWN - Unknown block type. */
  UNKNOWN = 0,
  /** TEXT - Regular text block. */
  TEXT = 1,
  /** TABLE - Table block. */
  TABLE = 2,
  /** PICTURE - Image block. */
  PICTURE = 3,
  /** RULER - Horizontal/vertical line box. */
  RULER = 4,
  /** BARCODE - Barcode block. */
  BARCODE = 5,
  UNRECOGNIZED = -1,
}

export function block_BlockTypeFromJSON(object: any): Block_BlockType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Block_BlockType.UNKNOWN;
    case 1:
    case "TEXT":
      return Block_BlockType.TEXT;
    case 2:
    case "TABLE":
      return Block_BlockType.TABLE;
    case 3:
    case "PICTURE":
      return Block_BlockType.PICTURE;
    case 4:
    case "RULER":
      return Block_BlockType.RULER;
    case 5:
    case "BARCODE":
      return Block_BlockType.BARCODE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Block_BlockType.UNRECOGNIZED;
  }
}

export function block_BlockTypeToJSON(object: Block_BlockType): string {
  switch (object) {
    case Block_BlockType.UNKNOWN:
      return "UNKNOWN";
    case Block_BlockType.TEXT:
      return "TEXT";
    case Block_BlockType.TABLE:
      return "TABLE";
    case Block_BlockType.PICTURE:
      return "PICTURE";
    case Block_BlockType.RULER:
      return "RULER";
    case Block_BlockType.BARCODE:
      return "BARCODE";
    case Block_BlockType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Structural unit of text representing a number of words in certain order. */
export interface Paragraph {
  /** Additional information detected for the paragraph. */
  property:
    | TextAnnotation_TextProperty
    | undefined;
  /**
   * The bounding box for the paragraph.
   * The vertices are in the order of top-left, top-right, bottom-right,
   * bottom-left. When a rotation of the bounding box is detected the rotation
   * is represented as around the top-left corner as defined when the text is
   * read in the 'natural' orientation.
   * For example:
   *   * when the text is horizontal it might look like:
   *      0----1
   *      |    |
   *      3----2
   *   * when it's rotated 180 degrees around the top-left corner it becomes:
   *      2----3
   *      |    |
   *      1----0
   *   and the vertice order will still be (0, 1, 2, 3).
   */
  boundingBox:
    | BoundingPoly
    | undefined;
  /** List of words in this paragraph. */
  words: Word[];
  /** Confidence of the OCR results for the paragraph. Range [0, 1]. */
  confidence: number;
}

/** A word representation. */
export interface Word {
  /** Additional information detected for the word. */
  property:
    | TextAnnotation_TextProperty
    | undefined;
  /**
   * The bounding box for the word.
   * The vertices are in the order of top-left, top-right, bottom-right,
   * bottom-left. When a rotation of the bounding box is detected the rotation
   * is represented as around the top-left corner as defined when the text is
   * read in the 'natural' orientation.
   * For example:
   *   * when the text is horizontal it might look like:
   *      0----1
   *      |    |
   *      3----2
   *   * when it's rotated 180 degrees around the top-left corner it becomes:
   *      2----3
   *      |    |
   *      1----0
   *   and the vertice order will still be (0, 1, 2, 3).
   */
  boundingBox:
    | BoundingPoly
    | undefined;
  /**
   * List of symbols in the word.
   * The order of the symbols follows the natural reading order.
   */
  symbols: Symbol[];
  /** Confidence of the OCR results for the word. Range [0, 1]. */
  confidence: number;
}

/** A single symbol representation. */
export interface Symbol {
  /** Additional information detected for the symbol. */
  property:
    | TextAnnotation_TextProperty
    | undefined;
  /**
   * The bounding box for the symbol.
   * The vertices are in the order of top-left, top-right, bottom-right,
   * bottom-left. When a rotation of the bounding box is detected the rotation
   * is represented as around the top-left corner as defined when the text is
   * read in the 'natural' orientation.
   * For example:
   *   * when the text is horizontal it might look like:
   *      0----1
   *      |    |
   *      3----2
   *   * when it's rotated 180 degrees around the top-left corner it becomes:
   *      2----3
   *      |    |
   *      1----0
   *   and the vertice order will still be (0, 1, 2, 3).
   */
  boundingBox:
    | BoundingPoly
    | undefined;
  /** The actual UTF-8 representation of the symbol. */
  text: string;
  /** Confidence of the OCR results for the symbol. Range [0, 1]. */
  confidence: number;
}

function createBaseTextAnnotation(): TextAnnotation {
  return { pages: [], text: "" };
}

export const TextAnnotation: MessageFns<TextAnnotation> = {
  encode(message: TextAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pages) {
      Page.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pages.push(Page.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextAnnotation {
    return {
      pages: globalThis.Array.isArray(object?.pages) ? object.pages.map((e: any) => Page.fromJSON(e)) : [],
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: TextAnnotation): unknown {
    const obj: any = {};
    if (message.pages?.length) {
      obj.pages = message.pages.map((e) => Page.toJSON(e));
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<TextAnnotation>): TextAnnotation {
    return TextAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextAnnotation>): TextAnnotation {
    const message = createBaseTextAnnotation();
    message.pages = object.pages?.map((e) => Page.fromPartial(e)) || [];
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseTextAnnotation_DetectedLanguage(): TextAnnotation_DetectedLanguage {
  return { languageCode: "", confidence: 0 };
}

export const TextAnnotation_DetectedLanguage: MessageFns<TextAnnotation_DetectedLanguage> = {
  encode(message: TextAnnotation_DetectedLanguage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.languageCode !== "") {
      writer.uint32(10).string(message.languageCode);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextAnnotation_DetectedLanguage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextAnnotation_DetectedLanguage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextAnnotation_DetectedLanguage {
    return {
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: TextAnnotation_DetectedLanguage): unknown {
    const obj: any = {};
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<TextAnnotation_DetectedLanguage>): TextAnnotation_DetectedLanguage {
    return TextAnnotation_DetectedLanguage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextAnnotation_DetectedLanguage>): TextAnnotation_DetectedLanguage {
    const message = createBaseTextAnnotation_DetectedLanguage();
    message.languageCode = object.languageCode ?? "";
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseTextAnnotation_DetectedBreak(): TextAnnotation_DetectedBreak {
  return { type: 0, isPrefix: false };
}

export const TextAnnotation_DetectedBreak: MessageFns<TextAnnotation_DetectedBreak> = {
  encode(message: TextAnnotation_DetectedBreak, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.isPrefix !== false) {
      writer.uint32(16).bool(message.isPrefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextAnnotation_DetectedBreak {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextAnnotation_DetectedBreak();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isPrefix = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextAnnotation_DetectedBreak {
    return {
      type: isSet(object.type) ? textAnnotation_DetectedBreak_BreakTypeFromJSON(object.type) : 0,
      isPrefix: isSet(object.isPrefix) ? globalThis.Boolean(object.isPrefix) : false,
    };
  },

  toJSON(message: TextAnnotation_DetectedBreak): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = textAnnotation_DetectedBreak_BreakTypeToJSON(message.type);
    }
    if (message.isPrefix !== false) {
      obj.isPrefix = message.isPrefix;
    }
    return obj;
  },

  create(base?: DeepPartial<TextAnnotation_DetectedBreak>): TextAnnotation_DetectedBreak {
    return TextAnnotation_DetectedBreak.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextAnnotation_DetectedBreak>): TextAnnotation_DetectedBreak {
    const message = createBaseTextAnnotation_DetectedBreak();
    message.type = object.type ?? 0;
    message.isPrefix = object.isPrefix ?? false;
    return message;
  },
};

function createBaseTextAnnotation_TextProperty(): TextAnnotation_TextProperty {
  return { detectedLanguages: [], detectedBreak: undefined };
}

export const TextAnnotation_TextProperty: MessageFns<TextAnnotation_TextProperty> = {
  encode(message: TextAnnotation_TextProperty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.detectedLanguages) {
      TextAnnotation_DetectedLanguage.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.detectedBreak !== undefined) {
      TextAnnotation_DetectedBreak.encode(message.detectedBreak, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextAnnotation_TextProperty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextAnnotation_TextProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.detectedLanguages.push(TextAnnotation_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detectedBreak = TextAnnotation_DetectedBreak.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextAnnotation_TextProperty {
    return {
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => TextAnnotation_DetectedLanguage.fromJSON(e))
        : [],
      detectedBreak: isSet(object.detectedBreak)
        ? TextAnnotation_DetectedBreak.fromJSON(object.detectedBreak)
        : undefined,
    };
  },

  toJSON(message: TextAnnotation_TextProperty): unknown {
    const obj: any = {};
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => TextAnnotation_DetectedLanguage.toJSON(e));
    }
    if (message.detectedBreak !== undefined) {
      obj.detectedBreak = TextAnnotation_DetectedBreak.toJSON(message.detectedBreak);
    }
    return obj;
  },

  create(base?: DeepPartial<TextAnnotation_TextProperty>): TextAnnotation_TextProperty {
    return TextAnnotation_TextProperty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextAnnotation_TextProperty>): TextAnnotation_TextProperty {
    const message = createBaseTextAnnotation_TextProperty();
    message.detectedLanguages = object.detectedLanguages?.map((e) => TextAnnotation_DetectedLanguage.fromPartial(e)) ||
      [];
    message.detectedBreak = (object.detectedBreak !== undefined && object.detectedBreak !== null)
      ? TextAnnotation_DetectedBreak.fromPartial(object.detectedBreak)
      : undefined;
    return message;
  },
};

function createBasePage(): Page {
  return { property: undefined, width: 0, height: 0, blocks: [], confidence: 0 };
}

export const Page: MessageFns<Page> = {
  encode(message: Page, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== undefined) {
      TextAnnotation_TextProperty.encode(message.property, writer.uint32(10).fork()).join();
    }
    if (message.width !== 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    for (const v of message.blocks) {
      Block.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.confidence !== 0) {
      writer.uint32(45).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Page {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = TextAnnotation_TextProperty.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.height = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blocks.push(Block.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Page {
    return {
      property: isSet(object.property) ? TextAnnotation_TextProperty.fromJSON(object.property) : undefined,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      blocks: globalThis.Array.isArray(object?.blocks) ? object.blocks.map((e: any) => Block.fromJSON(e)) : [],
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: Page): unknown {
    const obj: any = {};
    if (message.property !== undefined) {
      obj.property = TextAnnotation_TextProperty.toJSON(message.property);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => Block.toJSON(e));
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<Page>): Page {
    return Page.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Page>): Page {
    const message = createBasePage();
    message.property = (object.property !== undefined && object.property !== null)
      ? TextAnnotation_TextProperty.fromPartial(object.property)
      : undefined;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.blocks = object.blocks?.map((e) => Block.fromPartial(e)) || [];
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseBlock(): Block {
  return { property: undefined, boundingBox: undefined, paragraphs: [], blockType: 0, confidence: 0 };
}

export const Block: MessageFns<Block> = {
  encode(message: Block, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== undefined) {
      TextAnnotation_TextProperty.encode(message.property, writer.uint32(10).fork()).join();
    }
    if (message.boundingBox !== undefined) {
      BoundingPoly.encode(message.boundingBox, writer.uint32(18).fork()).join();
    }
    for (const v of message.paragraphs) {
      Paragraph.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.blockType !== 0) {
      writer.uint32(32).int32(message.blockType);
    }
    if (message.confidence !== 0) {
      writer.uint32(45).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Block {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = TextAnnotation_TextProperty.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.boundingBox = BoundingPoly.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.paragraphs.push(Paragraph.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.blockType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Block {
    return {
      property: isSet(object.property) ? TextAnnotation_TextProperty.fromJSON(object.property) : undefined,
      boundingBox: isSet(object.boundingBox) ? BoundingPoly.fromJSON(object.boundingBox) : undefined,
      paragraphs: globalThis.Array.isArray(object?.paragraphs)
        ? object.paragraphs.map((e: any) => Paragraph.fromJSON(e))
        : [],
      blockType: isSet(object.blockType) ? block_BlockTypeFromJSON(object.blockType) : 0,
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: Block): unknown {
    const obj: any = {};
    if (message.property !== undefined) {
      obj.property = TextAnnotation_TextProperty.toJSON(message.property);
    }
    if (message.boundingBox !== undefined) {
      obj.boundingBox = BoundingPoly.toJSON(message.boundingBox);
    }
    if (message.paragraphs?.length) {
      obj.paragraphs = message.paragraphs.map((e) => Paragraph.toJSON(e));
    }
    if (message.blockType !== 0) {
      obj.blockType = block_BlockTypeToJSON(message.blockType);
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<Block>): Block {
    return Block.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Block>): Block {
    const message = createBaseBlock();
    message.property = (object.property !== undefined && object.property !== null)
      ? TextAnnotation_TextProperty.fromPartial(object.property)
      : undefined;
    message.boundingBox = (object.boundingBox !== undefined && object.boundingBox !== null)
      ? BoundingPoly.fromPartial(object.boundingBox)
      : undefined;
    message.paragraphs = object.paragraphs?.map((e) => Paragraph.fromPartial(e)) || [];
    message.blockType = object.blockType ?? 0;
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseParagraph(): Paragraph {
  return { property: undefined, boundingBox: undefined, words: [], confidence: 0 };
}

export const Paragraph: MessageFns<Paragraph> = {
  encode(message: Paragraph, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== undefined) {
      TextAnnotation_TextProperty.encode(message.property, writer.uint32(10).fork()).join();
    }
    if (message.boundingBox !== undefined) {
      BoundingPoly.encode(message.boundingBox, writer.uint32(18).fork()).join();
    }
    for (const v of message.words) {
      Word.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.confidence !== 0) {
      writer.uint32(37).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Paragraph {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParagraph();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = TextAnnotation_TextProperty.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.boundingBox = BoundingPoly.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.words.push(Word.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Paragraph {
    return {
      property: isSet(object.property) ? TextAnnotation_TextProperty.fromJSON(object.property) : undefined,
      boundingBox: isSet(object.boundingBox) ? BoundingPoly.fromJSON(object.boundingBox) : undefined,
      words: globalThis.Array.isArray(object?.words) ? object.words.map((e: any) => Word.fromJSON(e)) : [],
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: Paragraph): unknown {
    const obj: any = {};
    if (message.property !== undefined) {
      obj.property = TextAnnotation_TextProperty.toJSON(message.property);
    }
    if (message.boundingBox !== undefined) {
      obj.boundingBox = BoundingPoly.toJSON(message.boundingBox);
    }
    if (message.words?.length) {
      obj.words = message.words.map((e) => Word.toJSON(e));
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<Paragraph>): Paragraph {
    return Paragraph.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Paragraph>): Paragraph {
    const message = createBaseParagraph();
    message.property = (object.property !== undefined && object.property !== null)
      ? TextAnnotation_TextProperty.fromPartial(object.property)
      : undefined;
    message.boundingBox = (object.boundingBox !== undefined && object.boundingBox !== null)
      ? BoundingPoly.fromPartial(object.boundingBox)
      : undefined;
    message.words = object.words?.map((e) => Word.fromPartial(e)) || [];
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseWord(): Word {
  return { property: undefined, boundingBox: undefined, symbols: [], confidence: 0 };
}

export const Word: MessageFns<Word> = {
  encode(message: Word, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== undefined) {
      TextAnnotation_TextProperty.encode(message.property, writer.uint32(10).fork()).join();
    }
    if (message.boundingBox !== undefined) {
      BoundingPoly.encode(message.boundingBox, writer.uint32(18).fork()).join();
    }
    for (const v of message.symbols) {
      Symbol.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.confidence !== 0) {
      writer.uint32(37).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Word {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = TextAnnotation_TextProperty.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.boundingBox = BoundingPoly.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.symbols.push(Symbol.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Word {
    return {
      property: isSet(object.property) ? TextAnnotation_TextProperty.fromJSON(object.property) : undefined,
      boundingBox: isSet(object.boundingBox) ? BoundingPoly.fromJSON(object.boundingBox) : undefined,
      symbols: globalThis.Array.isArray(object?.symbols) ? object.symbols.map((e: any) => Symbol.fromJSON(e)) : [],
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: Word): unknown {
    const obj: any = {};
    if (message.property !== undefined) {
      obj.property = TextAnnotation_TextProperty.toJSON(message.property);
    }
    if (message.boundingBox !== undefined) {
      obj.boundingBox = BoundingPoly.toJSON(message.boundingBox);
    }
    if (message.symbols?.length) {
      obj.symbols = message.symbols.map((e) => Symbol.toJSON(e));
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<Word>): Word {
    return Word.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Word>): Word {
    const message = createBaseWord();
    message.property = (object.property !== undefined && object.property !== null)
      ? TextAnnotation_TextProperty.fromPartial(object.property)
      : undefined;
    message.boundingBox = (object.boundingBox !== undefined && object.boundingBox !== null)
      ? BoundingPoly.fromPartial(object.boundingBox)
      : undefined;
    message.symbols = object.symbols?.map((e) => Symbol.fromPartial(e)) || [];
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseSymbol(): Symbol {
  return { property: undefined, boundingBox: undefined, text: "", confidence: 0 };
}

export const Symbol: MessageFns<Symbol> = {
  encode(message: Symbol, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== undefined) {
      TextAnnotation_TextProperty.encode(message.property, writer.uint32(10).fork()).join();
    }
    if (message.boundingBox !== undefined) {
      BoundingPoly.encode(message.boundingBox, writer.uint32(18).fork()).join();
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.confidence !== 0) {
      writer.uint32(37).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Symbol {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSymbol();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = TextAnnotation_TextProperty.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.boundingBox = BoundingPoly.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Symbol {
    return {
      property: isSet(object.property) ? TextAnnotation_TextProperty.fromJSON(object.property) : undefined,
      boundingBox: isSet(object.boundingBox) ? BoundingPoly.fromJSON(object.boundingBox) : undefined,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: Symbol): unknown {
    const obj: any = {};
    if (message.property !== undefined) {
      obj.property = TextAnnotation_TextProperty.toJSON(message.property);
    }
    if (message.boundingBox !== undefined) {
      obj.boundingBox = BoundingPoly.toJSON(message.boundingBox);
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<Symbol>): Symbol {
    return Symbol.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Symbol>): Symbol {
    const message = createBaseSymbol();
    message.property = (object.property !== undefined && object.property !== null)
      ? TextAnnotation_TextProperty.fromPartial(object.property)
      : undefined;
    message.boundingBox = (object.boundingBox !== undefined && object.boundingBox !== null)
      ? BoundingPoly.fromPartial(object.boundingBox)
      : undefined;
    message.text = object.text ?? "";
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
