// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/vision/v1p4beta1/product_search_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { BoundingPoly } from "./geometry.js";

export const protobufPackage = "google.cloud.vision.v1p4beta1";

/** A Product contains ReferenceImages. */
export interface Product {
  /**
   * The resource name of the product.
   *
   * Format is:
   * `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`.
   *
   * This field is ignored when creating a product.
   */
  name: string;
  /**
   * The user-provided name for this Product. Must not be empty. Must be at most
   * 4096 characters long.
   */
  displayName: string;
  /**
   * User-provided metadata to be stored with this product. Must be at most 4096
   * characters long.
   */
  description: string;
  /**
   * Immutable. The category for the product identified by the reference image.
   * This should be either "homegoods-v2", "apparel-v2", or "toys-v2". The
   * legacy categories "homegoods", "apparel", and "toys" are still supported,
   * but these should not be used for new products.
   */
  productCategory: string;
  /**
   * Key-value pairs that can be attached to a product. At query time,
   * constraints can be specified based on the product_labels.
   *
   * Note that integer values can be provided as strings, e.g. "1199". Only
   * strings with integer values can match a range-based restriction which is
   * to be supported soon.
   *
   * Multiple values can be assigned to the same key. One product may have up to
   * 500 product_labels.
   *
   * Notice that the total number of distinct product_labels over all products
   * in one ProductSet cannot exceed 1M, otherwise the product search pipeline
   * will refuse to work for that ProductSet.
   */
  productLabels: Product_KeyValue[];
}

/** A product label represented as a key-value pair. */
export interface Product_KeyValue {
  /**
   * The key of the label attached to the product. Cannot be empty and cannot
   * exceed 128 bytes.
   */
  key: string;
  /**
   * The value of the label attached to the product. Cannot be empty and
   * cannot exceed 128 bytes.
   */
  value: string;
}

/**
 * A ProductSet contains Products. A ProductSet can contain a maximum of 1
 * million reference images. If the limit is exceeded, periodic indexing will
 * fail.
 */
export interface ProductSet {
  /**
   * The resource name of the ProductSet.
   *
   * Format is:
   * `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`.
   *
   * This field is ignored when creating a ProductSet.
   */
  name: string;
  /**
   * The user-provided name for this ProductSet. Must not be empty. Must be at
   * most 4096 characters long.
   */
  displayName: string;
  /**
   * Output only. The time at which this ProductSet was last indexed. Query
   * results will reflect all updates before this time. If this ProductSet has
   * never been indexed, this timestamp is the default value
   * "1970-01-01T00:00:00Z".
   *
   * This field is ignored when creating a ProductSet.
   */
  indexTime:
    | Date
    | undefined;
  /**
   * Output only. If there was an error with indexing the product set, the field
   * is populated.
   *
   * This field is ignored when creating a ProductSet.
   */
  indexError: Status | undefined;
}

/**
 * A `ReferenceImage` represents a product image and its associated metadata,
 * such as bounding boxes.
 */
export interface ReferenceImage {
  /**
   * The resource name of the reference image.
   *
   * Format is:
   *
   * `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID/referenceImages/IMAGE_ID`.
   *
   * This field is ignored when creating a reference image.
   */
  name: string;
  /**
   * Required. The Google Cloud Storage URI of the reference image.
   *
   * The URI must start with `gs://`.
   */
  uri: string;
  /**
   * Optional. Bounding polygons around the areas of interest in the reference
   * image. If this field is empty, the system will try to detect regions of
   * interest. At most 10 bounding polygons will be used.
   *
   * The provided shape is converted into a non-rotated rectangle. Once
   * converted, the small edge of the rectangle must be greater than or equal
   * to 300 pixels. The aspect ratio must be 1:4 or less (i.e. 1:3 is ok; 1:5
   * is not).
   */
  boundingPolys: BoundingPoly[];
}

/** Request message for the `CreateProduct` method. */
export interface CreateProductRequest {
  /**
   * Required. The project in which the Product should be created.
   *
   * Format is
   * `projects/PROJECT_ID/locations/LOC_ID`.
   */
  parent: string;
  /** Required. The product to create. */
  product:
    | Product
    | undefined;
  /**
   * A user-supplied resource id for this Product. If set, the server will
   * attempt to use this value as the resource id. If it is already in use, an
   * error is returned with code ALREADY_EXISTS. Must be at most 128 characters
   * long. It cannot contain the character `/`.
   */
  productId: string;
}

/** Request message for the `ListProducts` method. */
export interface ListProductsRequest {
  /**
   * Required. The project OR ProductSet from which Products should be listed.
   *
   * Format:
   * `projects/PROJECT_ID/locations/LOC_ID`
   */
  parent: string;
  /** The maximum number of items to return. Default 10, maximum 100. */
  pageSize: number;
  /** The next_page_token returned from a previous List request, if any. */
  pageToken: string;
}

/** Response message for the `ListProducts` method. */
export interface ListProductsResponse {
  /** List of products. */
  products: Product[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
}

/** Request message for the `GetProduct` method. */
export interface GetProductRequest {
  /**
   * Required. Resource name of the Product to get.
   *
   * Format is:
   * `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`
   */
  name: string;
}

/** Request message for the `UpdateProduct` method. */
export interface UpdateProductRequest {
  /**
   * Required. The Product resource which replaces the one on the server.
   * product.name is immutable.
   */
  product:
    | Product
    | undefined;
  /**
   * The [FieldMask][google.protobuf.FieldMask] that specifies which fields
   * to update.
   * If update_mask isn't specified, all mutable fields are to be updated.
   * Valid mask paths include `product_labels`, `display_name`, and
   * `description`.
   */
  updateMask: string[] | undefined;
}

/** Request message for the `DeleteProduct` method. */
export interface DeleteProductRequest {
  /**
   * Required. Resource name of product to delete.
   *
   * Format is:
   * `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`
   */
  name: string;
}

/** Request message for the `CreateProductSet` method. */
export interface CreateProductSetRequest {
  /**
   * Required. The project in which the ProductSet should be created.
   *
   * Format is `projects/PROJECT_ID/locations/LOC_ID`.
   */
  parent: string;
  /** Required. The ProductSet to create. */
  productSet:
    | ProductSet
    | undefined;
  /**
   * A user-supplied resource id for this ProductSet. If set, the server will
   * attempt to use this value as the resource id. If it is already in use, an
   * error is returned with code ALREADY_EXISTS. Must be at most 128 characters
   * long. It cannot contain the character `/`.
   */
  productSetId: string;
}

/** Request message for the `ListProductSets` method. */
export interface ListProductSetsRequest {
  /**
   * Required. The project from which ProductSets should be listed.
   *
   * Format is `projects/PROJECT_ID/locations/LOC_ID`.
   */
  parent: string;
  /** The maximum number of items to return. Default 10, maximum 100. */
  pageSize: number;
  /** The next_page_token returned from a previous List request, if any. */
  pageToken: string;
}

/** Response message for the `ListProductSets` method. */
export interface ListProductSetsResponse {
  /** List of ProductSets. */
  productSets: ProductSet[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
}

/** Request message for the `GetProductSet` method. */
export interface GetProductSetRequest {
  /**
   * Required. Resource name of the ProductSet to get.
   *
   * Format is:
   * `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
   */
  name: string;
}

/** Request message for the `UpdateProductSet` method. */
export interface UpdateProductSetRequest {
  /** Required. The ProductSet resource which replaces the one on the server. */
  productSet:
    | ProductSet
    | undefined;
  /**
   * The [FieldMask][google.protobuf.FieldMask] that specifies which fields to
   * update.
   * If update_mask isn't specified, all mutable fields are to be updated.
   * Valid mask path is `display_name`.
   */
  updateMask: string[] | undefined;
}

/** Request message for the `DeleteProductSet` method. */
export interface DeleteProductSetRequest {
  /**
   * Required. Resource name of the ProductSet to delete.
   *
   * Format is:
   * `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
   */
  name: string;
}

/** Request message for the `CreateReferenceImage` method. */
export interface CreateReferenceImageRequest {
  /**
   * Required. Resource name of the product in which to create the reference
   * image.
   *
   * Format is
   * `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`.
   */
  parent: string;
  /**
   * Required. The reference image to create.
   * If an image ID is specified, it is ignored.
   */
  referenceImage:
    | ReferenceImage
    | undefined;
  /**
   * A user-supplied resource id for the ReferenceImage to be added. If set,
   * the server will attempt to use this value as the resource id. If it is
   * already in use, an error is returned with code ALREADY_EXISTS. Must be at
   * most 128 characters long. It cannot contain the character `/`.
   */
  referenceImageId: string;
}

/** Request message for the `ListReferenceImages` method. */
export interface ListReferenceImagesRequest {
  /**
   * Required. Resource name of the product containing the reference images.
   *
   * Format is
   * `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`.
   */
  parent: string;
  /** The maximum number of items to return. Default 10, maximum 100. */
  pageSize: number;
  /**
   * A token identifying a page of results to be returned. This is the value
   * of `nextPageToken` returned in a previous reference image list request.
   *
   * Defaults to the first page if not specified.
   */
  pageToken: string;
}

/** Response message for the `ListReferenceImages` method. */
export interface ListReferenceImagesResponse {
  /** The list of reference images. */
  referenceImages: ReferenceImage[];
  /** The maximum number of items to return. Default 10, maximum 100. */
  pageSize: number;
  /** The next_page_token returned from a previous List request, if any. */
  nextPageToken: string;
}

/** Request message for the `GetReferenceImage` method. */
export interface GetReferenceImageRequest {
  /**
   * Required. The resource name of the ReferenceImage to get.
   *
   * Format is:
   *
   * `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID/referenceImages/IMAGE_ID`.
   */
  name: string;
}

/** Request message for the `DeleteReferenceImage` method. */
export interface DeleteReferenceImageRequest {
  /**
   * Required. The resource name of the reference image to delete.
   *
   * Format is:
   *
   * `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID/referenceImages/IMAGE_ID`
   */
  name: string;
}

/** Request message for the `AddProductToProductSet` method. */
export interface AddProductToProductSetRequest {
  /**
   * Required. The resource name for the ProductSet to modify.
   *
   * Format is:
   * `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
   */
  name: string;
  /**
   * Required. The resource name for the Product to be added to this ProductSet.
   *
   * Format is:
   * `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`
   */
  product: string;
}

/** Request message for the `RemoveProductFromProductSet` method. */
export interface RemoveProductFromProductSetRequest {
  /**
   * Required. The resource name for the ProductSet to modify.
   *
   * Format is:
   * `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
   */
  name: string;
  /**
   * Required. The resource name for the Product to be removed from this
   * ProductSet.
   *
   * Format is:
   * `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`
   */
  product: string;
}

/** Request message for the `ListProductsInProductSet` method. */
export interface ListProductsInProductSetRequest {
  /**
   * Required. The ProductSet resource for which to retrieve Products.
   *
   * Format is:
   * `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
   */
  name: string;
  /** The maximum number of items to return. Default 10, maximum 100. */
  pageSize: number;
  /** The next_page_token returned from a previous List request, if any. */
  pageToken: string;
}

/** Response message for the `ListProductsInProductSet` method. */
export interface ListProductsInProductSetResponse {
  /** The list of Products. */
  products: Product[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
}

/**
 * The Google Cloud Storage location for a csv file which preserves a list of
 * ImportProductSetRequests in each line.
 */
export interface ImportProductSetsGcsSource {
  /**
   * The Google Cloud Storage URI of the input csv file.
   *
   * The URI must start with `gs://`.
   *
   * The format of the input csv file should be one image per line.
   * In each line, there are 8 columns.
   *
   * 1.  image-uri
   * 2.  image-id
   * 3.  product-set-id
   * 4.  product-id
   * 5.  product-category
   * 6.  product-display-name
   * 7.  labels
   * 8.  bounding-poly
   *
   * The `image-uri`, `product-set-id`, `product-id`, and `product-category`
   * columns are required. All other columns are optional.
   *
   * If the `ProductSet` or `Product` specified by the `product-set-id` and
   * `product-id` values does not exist, then the system will create a new
   * `ProductSet` or `Product` for the image. In this case, the
   * `product-display-name` column refers to
   * [display_name][google.cloud.vision.v1p4beta1.Product.display_name], the
   * `product-category` column refers to
   * [product_category][google.cloud.vision.v1p4beta1.Product.product_category],
   * and the `labels` column refers to
   * [product_labels][google.cloud.vision.v1p4beta1.Product.product_labels].
   *
   * The `image-id` column is optional but must be unique if provided. If it is
   * empty, the system will automatically assign a unique id to the image.
   *
   * The `product-display-name` column is optional. If it is empty, the system
   * sets the [display_name][google.cloud.vision.v1p4beta1.Product.display_name]
   * field for the product to a space (" "). You can update the `display_name`
   * later by using the API.
   *
   * If a `Product` with the specified `product-id` already exists, then the
   * system ignores the `product-display-name`, `product-category`, and `labels`
   * columns.
   *
   * The `labels` column (optional) is a line containing a list of
   * comma-separated key-value pairs, in the following format:
   *
   *     "key_1=value_1,key_2=value_2,...,key_n=value_n"
   *
   * The `bounding-poly` column (optional) identifies one region of
   * interest from the image in the same manner as `CreateReferenceImage`. If
   * you do not specify the `bounding-poly` column, then the system will try to
   * detect regions of interest automatically.
   *
   * At most one `bounding-poly` column is allowed per line. If the image
   * contains multiple regions of interest, add a line to the CSV file that
   * includes the same product information, and the `bounding-poly` values for
   * each region of interest.
   *
   * The `bounding-poly` column must contain an even number of comma-separated
   * numbers, in the format "p1_x,p1_y,p2_x,p2_y,...,pn_x,pn_y". Use
   * non-negative integers for absolute bounding polygons, and float values
   * in [0, 1] for normalized bounding polygons.
   *
   * The system will resize the image if the image resolution is too
   * large to process (larger than 20MP).
   */
  csvFileUri: string;
}

/** The input content for the `ImportProductSets` method. */
export interface ImportProductSetsInputConfig {
  /**
   * The Google Cloud Storage location for a csv file which preserves a list
   * of ImportProductSetRequests in each line.
   */
  gcsSource?: ImportProductSetsGcsSource | undefined;
}

/** Request message for the `ImportProductSets` method. */
export interface ImportProductSetsRequest {
  /**
   * Required. The project in which the ProductSets should be imported.
   *
   * Format is `projects/PROJECT_ID/locations/LOC_ID`.
   */
  parent: string;
  /** Required. The input content for the list of requests. */
  inputConfig: ImportProductSetsInputConfig | undefined;
}

/**
 * Response message for the `ImportProductSets` method.
 *
 * This message is returned by the
 * [google.longrunning.Operations.GetOperation][google.longrunning.Operations.GetOperation]
 * method in the returned
 * [google.longrunning.Operation.response][google.longrunning.Operation.response]
 * field.
 */
export interface ImportProductSetsResponse {
  /** The list of reference_images that are imported successfully. */
  referenceImages: ReferenceImage[];
  /**
   * The rpc status for each ImportProductSet request, including both successes
   * and errors.
   *
   * The number of statuses here matches the number of lines in the csv file,
   * and statuses[i] stores the success or failure status of processing the i-th
   * line of the csv, starting from line 0.
   */
  statuses: Status[];
}

/**
 * Metadata for the batch operations such as the current state.
 *
 * This is included in the `metadata` field of the `Operation` returned by the
 * `GetOperation` call of the `google::longrunning::Operations` service.
 */
export interface BatchOperationMetadata {
  /** The current state of the batch operation. */
  state: BatchOperationMetadata_State;
  /** The time when the batch request was submitted to the server. */
  submitTime:
    | Date
    | undefined;
  /**
   * The time when the batch request is finished and
   * [google.longrunning.Operation.done][google.longrunning.Operation.done] is
   * set to true.
   */
  endTime: Date | undefined;
}

/** Enumerates the possible states that the batch request can be in. */
export enum BatchOperationMetadata_State {
  /** STATE_UNSPECIFIED - Invalid. */
  STATE_UNSPECIFIED = 0,
  /** PROCESSING - Request is actively being processed. */
  PROCESSING = 1,
  /**
   * SUCCESSFUL - The request is done and at least one item has been successfully
   * processed.
   */
  SUCCESSFUL = 2,
  /** FAILED - The request is done and no item has been successfully processed. */
  FAILED = 3,
  /**
   * CANCELLED - The request is done after the longrunning.Operations.CancelOperation has
   * been called by the user.  Any records that were processed before the
   * cancel command are output as specified in the request.
   */
  CANCELLED = 4,
  UNRECOGNIZED = -1,
}

export function batchOperationMetadata_StateFromJSON(object: any): BatchOperationMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return BatchOperationMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "PROCESSING":
      return BatchOperationMetadata_State.PROCESSING;
    case 2:
    case "SUCCESSFUL":
      return BatchOperationMetadata_State.SUCCESSFUL;
    case 3:
    case "FAILED":
      return BatchOperationMetadata_State.FAILED;
    case 4:
    case "CANCELLED":
      return BatchOperationMetadata_State.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BatchOperationMetadata_State.UNRECOGNIZED;
  }
}

export function batchOperationMetadata_StateToJSON(object: BatchOperationMetadata_State): string {
  switch (object) {
    case BatchOperationMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case BatchOperationMetadata_State.PROCESSING:
      return "PROCESSING";
    case BatchOperationMetadata_State.SUCCESSFUL:
      return "SUCCESSFUL";
    case BatchOperationMetadata_State.FAILED:
      return "FAILED";
    case BatchOperationMetadata_State.CANCELLED:
      return "CANCELLED";
    case BatchOperationMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Config to control which ProductSet contains the Products to be deleted. */
export interface ProductSetPurgeConfig {
  /**
   * The ProductSet that contains the Products to delete. If a Product is a
   * member of product_set_id in addition to other ProductSets, the Product will
   * still be deleted.
   */
  productSetId: string;
}

/** Request message for the `PurgeProducts` method. */
export interface PurgeProductsRequest {
  /** Specify which ProductSet contains the Products to be deleted. */
  productSetPurgeConfig?:
    | ProductSetPurgeConfig
    | undefined;
  /**
   * If delete_orphan_products is true, all Products that are not in any
   * ProductSet will be deleted.
   */
  deleteOrphanProducts?:
    | boolean
    | undefined;
  /**
   * Required. The project and location in which the Products should be deleted.
   *
   * Format is `projects/PROJECT_ID/locations/LOC_ID`.
   */
  parent: string;
  /**
   * The default value is false. Override this value to true to actually perform
   * the purge.
   */
  force: boolean;
}

function createBaseProduct(): Product {
  return { name: "", displayName: "", description: "", productCategory: "", productLabels: [] };
}

export const Product: MessageFns<Product> = {
  encode(message: Product, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.productCategory !== "") {
      writer.uint32(34).string(message.productCategory);
    }
    for (const v of message.productLabels) {
      Product_KeyValue.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Product {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.productCategory = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.productLabels.push(Product_KeyValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Product {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      productCategory: isSet(object.productCategory) ? globalThis.String(object.productCategory) : "",
      productLabels: globalThis.Array.isArray(object?.productLabels)
        ? object.productLabels.map((e: any) => Product_KeyValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Product): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.productCategory !== "") {
      obj.productCategory = message.productCategory;
    }
    if (message.productLabels?.length) {
      obj.productLabels = message.productLabels.map((e) => Product_KeyValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Product>): Product {
    return Product.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Product>): Product {
    const message = createBaseProduct();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.productCategory = object.productCategory ?? "";
    message.productLabels = object.productLabels?.map((e) => Product_KeyValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProduct_KeyValue(): Product_KeyValue {
  return { key: "", value: "" };
}

export const Product_KeyValue: MessageFns<Product_KeyValue> = {
  encode(message: Product_KeyValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Product_KeyValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduct_KeyValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Product_KeyValue {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Product_KeyValue): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Product_KeyValue>): Product_KeyValue {
    return Product_KeyValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Product_KeyValue>): Product_KeyValue {
    const message = createBaseProduct_KeyValue();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseProductSet(): ProductSet {
  return { name: "", displayName: "", indexTime: undefined, indexError: undefined };
}

export const ProductSet: MessageFns<ProductSet> = {
  encode(message: ProductSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.indexTime !== undefined) {
      Timestamp.encode(toTimestamp(message.indexTime), writer.uint32(26).fork()).join();
    }
    if (message.indexError !== undefined) {
      Status.encode(message.indexError, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.indexTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.indexError = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductSet {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      indexTime: isSet(object.indexTime) ? fromJsonTimestamp(object.indexTime) : undefined,
      indexError: isSet(object.indexError) ? Status.fromJSON(object.indexError) : undefined,
    };
  },

  toJSON(message: ProductSet): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.indexTime !== undefined) {
      obj.indexTime = message.indexTime.toISOString();
    }
    if (message.indexError !== undefined) {
      obj.indexError = Status.toJSON(message.indexError);
    }
    return obj;
  },

  create(base?: DeepPartial<ProductSet>): ProductSet {
    return ProductSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductSet>): ProductSet {
    const message = createBaseProductSet();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.indexTime = object.indexTime ?? undefined;
    message.indexError = (object.indexError !== undefined && object.indexError !== null)
      ? Status.fromPartial(object.indexError)
      : undefined;
    return message;
  },
};

function createBaseReferenceImage(): ReferenceImage {
  return { name: "", uri: "", boundingPolys: [] };
}

export const ReferenceImage: MessageFns<ReferenceImage> = {
  encode(message: ReferenceImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    for (const v of message.boundingPolys) {
      BoundingPoly.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReferenceImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReferenceImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.boundingPolys.push(BoundingPoly.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReferenceImage {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      boundingPolys: globalThis.Array.isArray(object?.boundingPolys)
        ? object.boundingPolys.map((e: any) => BoundingPoly.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReferenceImage): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.boundingPolys?.length) {
      obj.boundingPolys = message.boundingPolys.map((e) => BoundingPoly.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReferenceImage>): ReferenceImage {
    return ReferenceImage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReferenceImage>): ReferenceImage {
    const message = createBaseReferenceImage();
    message.name = object.name ?? "";
    message.uri = object.uri ?? "";
    message.boundingPolys = object.boundingPolys?.map((e) => BoundingPoly.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateProductRequest(): CreateProductRequest {
  return { parent: "", product: undefined, productId: "" };
}

export const CreateProductRequest: MessageFns<CreateProductRequest> = {
  encode(message: CreateProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(18).fork()).join();
    }
    if (message.productId !== "") {
      writer.uint32(26).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.productId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
    };
  },

  toJSON(message: CreateProductRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateProductRequest>): CreateProductRequest {
    return CreateProductRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateProductRequest>): CreateProductRequest {
    const message = createBaseCreateProductRequest();
    message.parent = object.parent ?? "";
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseListProductsRequest(): ListProductsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListProductsRequest: MessageFns<ListProductsRequest> = {
  encode(message: ListProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListProductsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProductsRequest>): ListProductsRequest {
    return ListProductsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProductsRequest>): ListProductsRequest {
    const message = createBaseListProductsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListProductsResponse(): ListProductsResponse {
  return { products: [], nextPageToken: "" };
}

export const ListProductsResponse: MessageFns<ListProductsResponse> = {
  encode(message: ListProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductsResponse {
    return {
      products: globalThis.Array.isArray(object?.products) ? object.products.map((e: any) => Product.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListProductsResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProductsResponse>): ListProductsResponse {
    return ListProductsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProductsResponse>): ListProductsResponse {
    const message = createBaseListProductsResponse();
    message.products = object.products?.map((e) => Product.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetProductRequest(): GetProductRequest {
  return { name: "" };
}

export const GetProductRequest: MessageFns<GetProductRequest> = {
  encode(message: GetProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetProductRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetProductRequest>): GetProductRequest {
    return GetProductRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetProductRequest>): GetProductRequest {
    const message = createBaseGetProductRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateProductRequest(): UpdateProductRequest {
  return { product: undefined, updateMask: undefined };
}

export const UpdateProductRequest: MessageFns<UpdateProductRequest> = {
  encode(message: UpdateProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductRequest {
    return {
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateProductRequest): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateProductRequest>): UpdateProductRequest {
    return UpdateProductRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateProductRequest>): UpdateProductRequest {
    const message = createBaseUpdateProductRequest();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteProductRequest(): DeleteProductRequest {
  return { name: "" };
}

export const DeleteProductRequest: MessageFns<DeleteProductRequest> = {
  encode(message: DeleteProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProductRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteProductRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteProductRequest>): DeleteProductRequest {
    return DeleteProductRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteProductRequest>): DeleteProductRequest {
    const message = createBaseDeleteProductRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateProductSetRequest(): CreateProductSetRequest {
  return { parent: "", productSet: undefined, productSetId: "" };
}

export const CreateProductSetRequest: MessageFns<CreateProductSetRequest> = {
  encode(message: CreateProductSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.productSet !== undefined) {
      ProductSet.encode(message.productSet, writer.uint32(18).fork()).join();
    }
    if (message.productSetId !== "") {
      writer.uint32(26).string(message.productSetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.productSet = ProductSet.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.productSetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductSetRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      productSet: isSet(object.productSet) ? ProductSet.fromJSON(object.productSet) : undefined,
      productSetId: isSet(object.productSetId) ? globalThis.String(object.productSetId) : "",
    };
  },

  toJSON(message: CreateProductSetRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.productSet !== undefined) {
      obj.productSet = ProductSet.toJSON(message.productSet);
    }
    if (message.productSetId !== "") {
      obj.productSetId = message.productSetId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateProductSetRequest>): CreateProductSetRequest {
    return CreateProductSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateProductSetRequest>): CreateProductSetRequest {
    const message = createBaseCreateProductSetRequest();
    message.parent = object.parent ?? "";
    message.productSet = (object.productSet !== undefined && object.productSet !== null)
      ? ProductSet.fromPartial(object.productSet)
      : undefined;
    message.productSetId = object.productSetId ?? "";
    return message;
  },
};

function createBaseListProductSetsRequest(): ListProductSetsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListProductSetsRequest: MessageFns<ListProductSetsRequest> = {
  encode(message: ListProductSetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductSetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductSetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductSetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListProductSetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProductSetsRequest>): ListProductSetsRequest {
    return ListProductSetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProductSetsRequest>): ListProductSetsRequest {
    const message = createBaseListProductSetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListProductSetsResponse(): ListProductSetsResponse {
  return { productSets: [], nextPageToken: "" };
}

export const ListProductSetsResponse: MessageFns<ListProductSetsResponse> = {
  encode(message: ListProductSetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.productSets) {
      ProductSet.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductSetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductSetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.productSets.push(ProductSet.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductSetsResponse {
    return {
      productSets: globalThis.Array.isArray(object?.productSets)
        ? object.productSets.map((e: any) => ProductSet.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListProductSetsResponse): unknown {
    const obj: any = {};
    if (message.productSets?.length) {
      obj.productSets = message.productSets.map((e) => ProductSet.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProductSetsResponse>): ListProductSetsResponse {
    return ListProductSetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProductSetsResponse>): ListProductSetsResponse {
    const message = createBaseListProductSetsResponse();
    message.productSets = object.productSets?.map((e) => ProductSet.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetProductSetRequest(): GetProductSetRequest {
  return { name: "" };
}

export const GetProductSetRequest: MessageFns<GetProductSetRequest> = {
  encode(message: GetProductSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductSetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetProductSetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetProductSetRequest>): GetProductSetRequest {
    return GetProductSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetProductSetRequest>): GetProductSetRequest {
    const message = createBaseGetProductSetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateProductSetRequest(): UpdateProductSetRequest {
  return { productSet: undefined, updateMask: undefined };
}

export const UpdateProductSetRequest: MessageFns<UpdateProductSetRequest> = {
  encode(message: UpdateProductSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productSet !== undefined) {
      ProductSet.encode(message.productSet, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.productSet = ProductSet.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductSetRequest {
    return {
      productSet: isSet(object.productSet) ? ProductSet.fromJSON(object.productSet) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateProductSetRequest): unknown {
    const obj: any = {};
    if (message.productSet !== undefined) {
      obj.productSet = ProductSet.toJSON(message.productSet);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateProductSetRequest>): UpdateProductSetRequest {
    return UpdateProductSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateProductSetRequest>): UpdateProductSetRequest {
    const message = createBaseUpdateProductSetRequest();
    message.productSet = (object.productSet !== undefined && object.productSet !== null)
      ? ProductSet.fromPartial(object.productSet)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteProductSetRequest(): DeleteProductSetRequest {
  return { name: "" };
}

export const DeleteProductSetRequest: MessageFns<DeleteProductSetRequest> = {
  encode(message: DeleteProductSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProductSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProductSetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteProductSetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteProductSetRequest>): DeleteProductSetRequest {
    return DeleteProductSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteProductSetRequest>): DeleteProductSetRequest {
    const message = createBaseDeleteProductSetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateReferenceImageRequest(): CreateReferenceImageRequest {
  return { parent: "", referenceImage: undefined, referenceImageId: "" };
}

export const CreateReferenceImageRequest: MessageFns<CreateReferenceImageRequest> = {
  encode(message: CreateReferenceImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.referenceImage !== undefined) {
      ReferenceImage.encode(message.referenceImage, writer.uint32(18).fork()).join();
    }
    if (message.referenceImageId !== "") {
      writer.uint32(26).string(message.referenceImageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReferenceImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReferenceImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.referenceImage = ReferenceImage.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.referenceImageId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReferenceImageRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      referenceImage: isSet(object.referenceImage) ? ReferenceImage.fromJSON(object.referenceImage) : undefined,
      referenceImageId: isSet(object.referenceImageId) ? globalThis.String(object.referenceImageId) : "",
    };
  },

  toJSON(message: CreateReferenceImageRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.referenceImage !== undefined) {
      obj.referenceImage = ReferenceImage.toJSON(message.referenceImage);
    }
    if (message.referenceImageId !== "") {
      obj.referenceImageId = message.referenceImageId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateReferenceImageRequest>): CreateReferenceImageRequest {
    return CreateReferenceImageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateReferenceImageRequest>): CreateReferenceImageRequest {
    const message = createBaseCreateReferenceImageRequest();
    message.parent = object.parent ?? "";
    message.referenceImage = (object.referenceImage !== undefined && object.referenceImage !== null)
      ? ReferenceImage.fromPartial(object.referenceImage)
      : undefined;
    message.referenceImageId = object.referenceImageId ?? "";
    return message;
  },
};

function createBaseListReferenceImagesRequest(): ListReferenceImagesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListReferenceImagesRequest: MessageFns<ListReferenceImagesRequest> = {
  encode(message: ListReferenceImagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReferenceImagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReferenceImagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReferenceImagesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListReferenceImagesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReferenceImagesRequest>): ListReferenceImagesRequest {
    return ListReferenceImagesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReferenceImagesRequest>): ListReferenceImagesRequest {
    const message = createBaseListReferenceImagesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListReferenceImagesResponse(): ListReferenceImagesResponse {
  return { referenceImages: [], pageSize: 0, nextPageToken: "" };
}

export const ListReferenceImagesResponse: MessageFns<ListReferenceImagesResponse> = {
  encode(message: ListReferenceImagesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.referenceImages) {
      ReferenceImage.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReferenceImagesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReferenceImagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referenceImages.push(ReferenceImage.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReferenceImagesResponse {
    return {
      referenceImages: globalThis.Array.isArray(object?.referenceImages)
        ? object.referenceImages.map((e: any) => ReferenceImage.fromJSON(e))
        : [],
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListReferenceImagesResponse): unknown {
    const obj: any = {};
    if (message.referenceImages?.length) {
      obj.referenceImages = message.referenceImages.map((e) => ReferenceImage.toJSON(e));
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReferenceImagesResponse>): ListReferenceImagesResponse {
    return ListReferenceImagesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReferenceImagesResponse>): ListReferenceImagesResponse {
    const message = createBaseListReferenceImagesResponse();
    message.referenceImages = object.referenceImages?.map((e) => ReferenceImage.fromPartial(e)) || [];
    message.pageSize = object.pageSize ?? 0;
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetReferenceImageRequest(): GetReferenceImageRequest {
  return { name: "" };
}

export const GetReferenceImageRequest: MessageFns<GetReferenceImageRequest> = {
  encode(message: GetReferenceImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReferenceImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReferenceImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReferenceImageRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetReferenceImageRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReferenceImageRequest>): GetReferenceImageRequest {
    return GetReferenceImageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReferenceImageRequest>): GetReferenceImageRequest {
    const message = createBaseGetReferenceImageRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteReferenceImageRequest(): DeleteReferenceImageRequest {
  return { name: "" };
}

export const DeleteReferenceImageRequest: MessageFns<DeleteReferenceImageRequest> = {
  encode(message: DeleteReferenceImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteReferenceImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteReferenceImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteReferenceImageRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteReferenceImageRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteReferenceImageRequest>): DeleteReferenceImageRequest {
    return DeleteReferenceImageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteReferenceImageRequest>): DeleteReferenceImageRequest {
    const message = createBaseDeleteReferenceImageRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAddProductToProductSetRequest(): AddProductToProductSetRequest {
  return { name: "", product: "" };
}

export const AddProductToProductSetRequest: MessageFns<AddProductToProductSetRequest> = {
  encode(message: AddProductToProductSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.product !== "") {
      writer.uint32(18).string(message.product);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddProductToProductSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddProductToProductSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.product = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddProductToProductSetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      product: isSet(object.product) ? globalThis.String(object.product) : "",
    };
  },

  toJSON(message: AddProductToProductSetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.product !== "") {
      obj.product = message.product;
    }
    return obj;
  },

  create(base?: DeepPartial<AddProductToProductSetRequest>): AddProductToProductSetRequest {
    return AddProductToProductSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddProductToProductSetRequest>): AddProductToProductSetRequest {
    const message = createBaseAddProductToProductSetRequest();
    message.name = object.name ?? "";
    message.product = object.product ?? "";
    return message;
  },
};

function createBaseRemoveProductFromProductSetRequest(): RemoveProductFromProductSetRequest {
  return { name: "", product: "" };
}

export const RemoveProductFromProductSetRequest: MessageFns<RemoveProductFromProductSetRequest> = {
  encode(message: RemoveProductFromProductSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.product !== "") {
      writer.uint32(18).string(message.product);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveProductFromProductSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveProductFromProductSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.product = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveProductFromProductSetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      product: isSet(object.product) ? globalThis.String(object.product) : "",
    };
  },

  toJSON(message: RemoveProductFromProductSetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.product !== "") {
      obj.product = message.product;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveProductFromProductSetRequest>): RemoveProductFromProductSetRequest {
    return RemoveProductFromProductSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveProductFromProductSetRequest>): RemoveProductFromProductSetRequest {
    const message = createBaseRemoveProductFromProductSetRequest();
    message.name = object.name ?? "";
    message.product = object.product ?? "";
    return message;
  },
};

function createBaseListProductsInProductSetRequest(): ListProductsInProductSetRequest {
  return { name: "", pageSize: 0, pageToken: "" };
}

export const ListProductsInProductSetRequest: MessageFns<ListProductsInProductSetRequest> = {
  encode(message: ListProductsInProductSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsInProductSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsInProductSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductsInProductSetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListProductsInProductSetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProductsInProductSetRequest>): ListProductsInProductSetRequest {
    return ListProductsInProductSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProductsInProductSetRequest>): ListProductsInProductSetRequest {
    const message = createBaseListProductsInProductSetRequest();
    message.name = object.name ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListProductsInProductSetResponse(): ListProductsInProductSetResponse {
  return { products: [], nextPageToken: "" };
}

export const ListProductsInProductSetResponse: MessageFns<ListProductsInProductSetResponse> = {
  encode(message: ListProductsInProductSetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsInProductSetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsInProductSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductsInProductSetResponse {
    return {
      products: globalThis.Array.isArray(object?.products) ? object.products.map((e: any) => Product.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListProductsInProductSetResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProductsInProductSetResponse>): ListProductsInProductSetResponse {
    return ListProductsInProductSetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProductsInProductSetResponse>): ListProductsInProductSetResponse {
    const message = createBaseListProductsInProductSetResponse();
    message.products = object.products?.map((e) => Product.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseImportProductSetsGcsSource(): ImportProductSetsGcsSource {
  return { csvFileUri: "" };
}

export const ImportProductSetsGcsSource: MessageFns<ImportProductSetsGcsSource> = {
  encode(message: ImportProductSetsGcsSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.csvFileUri !== "") {
      writer.uint32(10).string(message.csvFileUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportProductSetsGcsSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportProductSetsGcsSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.csvFileUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportProductSetsGcsSource {
    return { csvFileUri: isSet(object.csvFileUri) ? globalThis.String(object.csvFileUri) : "" };
  },

  toJSON(message: ImportProductSetsGcsSource): unknown {
    const obj: any = {};
    if (message.csvFileUri !== "") {
      obj.csvFileUri = message.csvFileUri;
    }
    return obj;
  },

  create(base?: DeepPartial<ImportProductSetsGcsSource>): ImportProductSetsGcsSource {
    return ImportProductSetsGcsSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportProductSetsGcsSource>): ImportProductSetsGcsSource {
    const message = createBaseImportProductSetsGcsSource();
    message.csvFileUri = object.csvFileUri ?? "";
    return message;
  },
};

function createBaseImportProductSetsInputConfig(): ImportProductSetsInputConfig {
  return { gcsSource: undefined };
}

export const ImportProductSetsInputConfig: MessageFns<ImportProductSetsInputConfig> = {
  encode(message: ImportProductSetsInputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsSource !== undefined) {
      ImportProductSetsGcsSource.encode(message.gcsSource, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportProductSetsInputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportProductSetsInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsSource = ImportProductSetsGcsSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportProductSetsInputConfig {
    return { gcsSource: isSet(object.gcsSource) ? ImportProductSetsGcsSource.fromJSON(object.gcsSource) : undefined };
  },

  toJSON(message: ImportProductSetsInputConfig): unknown {
    const obj: any = {};
    if (message.gcsSource !== undefined) {
      obj.gcsSource = ImportProductSetsGcsSource.toJSON(message.gcsSource);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportProductSetsInputConfig>): ImportProductSetsInputConfig {
    return ImportProductSetsInputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportProductSetsInputConfig>): ImportProductSetsInputConfig {
    const message = createBaseImportProductSetsInputConfig();
    message.gcsSource = (object.gcsSource !== undefined && object.gcsSource !== null)
      ? ImportProductSetsGcsSource.fromPartial(object.gcsSource)
      : undefined;
    return message;
  },
};

function createBaseImportProductSetsRequest(): ImportProductSetsRequest {
  return { parent: "", inputConfig: undefined };
}

export const ImportProductSetsRequest: MessageFns<ImportProductSetsRequest> = {
  encode(message: ImportProductSetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.inputConfig !== undefined) {
      ImportProductSetsInputConfig.encode(message.inputConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportProductSetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportProductSetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputConfig = ImportProductSetsInputConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportProductSetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      inputConfig: isSet(object.inputConfig) ? ImportProductSetsInputConfig.fromJSON(object.inputConfig) : undefined,
    };
  },

  toJSON(message: ImportProductSetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.inputConfig !== undefined) {
      obj.inputConfig = ImportProductSetsInputConfig.toJSON(message.inputConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportProductSetsRequest>): ImportProductSetsRequest {
    return ImportProductSetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportProductSetsRequest>): ImportProductSetsRequest {
    const message = createBaseImportProductSetsRequest();
    message.parent = object.parent ?? "";
    message.inputConfig = (object.inputConfig !== undefined && object.inputConfig !== null)
      ? ImportProductSetsInputConfig.fromPartial(object.inputConfig)
      : undefined;
    return message;
  },
};

function createBaseImportProductSetsResponse(): ImportProductSetsResponse {
  return { referenceImages: [], statuses: [] };
}

export const ImportProductSetsResponse: MessageFns<ImportProductSetsResponse> = {
  encode(message: ImportProductSetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.referenceImages) {
      ReferenceImage.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.statuses) {
      Status.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportProductSetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportProductSetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referenceImages.push(ReferenceImage.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.statuses.push(Status.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportProductSetsResponse {
    return {
      referenceImages: globalThis.Array.isArray(object?.referenceImages)
        ? object.referenceImages.map((e: any) => ReferenceImage.fromJSON(e))
        : [],
      statuses: globalThis.Array.isArray(object?.statuses) ? object.statuses.map((e: any) => Status.fromJSON(e)) : [],
    };
  },

  toJSON(message: ImportProductSetsResponse): unknown {
    const obj: any = {};
    if (message.referenceImages?.length) {
      obj.referenceImages = message.referenceImages.map((e) => ReferenceImage.toJSON(e));
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => Status.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ImportProductSetsResponse>): ImportProductSetsResponse {
    return ImportProductSetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportProductSetsResponse>): ImportProductSetsResponse {
    const message = createBaseImportProductSetsResponse();
    message.referenceImages = object.referenceImages?.map((e) => ReferenceImage.fromPartial(e)) || [];
    message.statuses = object.statuses?.map((e) => Status.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchOperationMetadata(): BatchOperationMetadata {
  return { state: 0, submitTime: undefined, endTime: undefined };
}

export const BatchOperationMetadata: MessageFns<BatchOperationMetadata> = {
  encode(message: BatchOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.submitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.submitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchOperationMetadata {
    return {
      state: isSet(object.state) ? batchOperationMetadata_StateFromJSON(object.state) : 0,
      submitTime: isSet(object.submitTime) ? fromJsonTimestamp(object.submitTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: BatchOperationMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = batchOperationMetadata_StateToJSON(message.state);
    }
    if (message.submitTime !== undefined) {
      obj.submitTime = message.submitTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<BatchOperationMetadata>): BatchOperationMetadata {
    return BatchOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchOperationMetadata>): BatchOperationMetadata {
    const message = createBaseBatchOperationMetadata();
    message.state = object.state ?? 0;
    message.submitTime = object.submitTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseProductSetPurgeConfig(): ProductSetPurgeConfig {
  return { productSetId: "" };
}

export const ProductSetPurgeConfig: MessageFns<ProductSetPurgeConfig> = {
  encode(message: ProductSetPurgeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productSetId !== "") {
      writer.uint32(10).string(message.productSetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductSetPurgeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductSetPurgeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.productSetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductSetPurgeConfig {
    return { productSetId: isSet(object.productSetId) ? globalThis.String(object.productSetId) : "" };
  },

  toJSON(message: ProductSetPurgeConfig): unknown {
    const obj: any = {};
    if (message.productSetId !== "") {
      obj.productSetId = message.productSetId;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductSetPurgeConfig>): ProductSetPurgeConfig {
    return ProductSetPurgeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductSetPurgeConfig>): ProductSetPurgeConfig {
    const message = createBaseProductSetPurgeConfig();
    message.productSetId = object.productSetId ?? "";
    return message;
  },
};

function createBasePurgeProductsRequest(): PurgeProductsRequest {
  return { productSetPurgeConfig: undefined, deleteOrphanProducts: undefined, parent: "", force: false };
}

export const PurgeProductsRequest: MessageFns<PurgeProductsRequest> = {
  encode(message: PurgeProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productSetPurgeConfig !== undefined) {
      ProductSetPurgeConfig.encode(message.productSetPurgeConfig, writer.uint32(18).fork()).join();
    }
    if (message.deleteOrphanProducts !== undefined) {
      writer.uint32(24).bool(message.deleteOrphanProducts);
    }
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.force !== false) {
      writer.uint32(32).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.productSetPurgeConfig = ProductSetPurgeConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.deleteOrphanProducts = reader.bool();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeProductsRequest {
    return {
      productSetPurgeConfig: isSet(object.productSetPurgeConfig)
        ? ProductSetPurgeConfig.fromJSON(object.productSetPurgeConfig)
        : undefined,
      deleteOrphanProducts: isSet(object.deleteOrphanProducts)
        ? globalThis.Boolean(object.deleteOrphanProducts)
        : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: PurgeProductsRequest): unknown {
    const obj: any = {};
    if (message.productSetPurgeConfig !== undefined) {
      obj.productSetPurgeConfig = ProductSetPurgeConfig.toJSON(message.productSetPurgeConfig);
    }
    if (message.deleteOrphanProducts !== undefined) {
      obj.deleteOrphanProducts = message.deleteOrphanProducts;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeProductsRequest>): PurgeProductsRequest {
    return PurgeProductsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeProductsRequest>): PurgeProductsRequest {
    const message = createBasePurgeProductsRequest();
    message.productSetPurgeConfig =
      (object.productSetPurgeConfig !== undefined && object.productSetPurgeConfig !== null)
        ? ProductSetPurgeConfig.fromPartial(object.productSetPurgeConfig)
        : undefined;
    message.deleteOrphanProducts = object.deleteOrphanProducts ?? undefined;
    message.parent = object.parent ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

/**
 * Manages Products and ProductSets of reference images for use in product
 * search. It uses the following resource model:
 *
 * - The API has a collection of
 * [ProductSet][google.cloud.vision.v1p4beta1.ProductSet] resources, named
 * `projects/* /locations/* /productSets/*`, which acts as a way to put different
 * products into groups to limit identification.
 *
 * In parallel,
 *
 * - The API has a collection of
 * [Product][google.cloud.vision.v1p4beta1.Product] resources, named
 *   `projects/* /locations/* /products/*`
 *
 * - Each [Product][google.cloud.vision.v1p4beta1.Product] has a collection of
 * [ReferenceImage][google.cloud.vision.v1p4beta1.ReferenceImage] resources,
 * named
 *   `projects/* /locations/* /products/* /referenceImages/*`
 */
export type ProductSearchDefinition = typeof ProductSearchDefinition;
export const ProductSearchDefinition = {
  name: "ProductSearch",
  fullName: "google.cloud.vision.v1p4beta1.ProductSearch",
  methods: {
    /**
     * Creates and returns a new ProductSet resource.
     *
     * Possible errors:
     *
     * * Returns INVALID_ARGUMENT if display_name is missing, or is longer than
     *   4096 characters.
     */
    createProductSet: {
      name: "CreateProductSet",
      requestType: CreateProductSetRequest,
      requestStream: false,
      responseType: ProductSet,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              33,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              95,
              115,
              101,
              116,
              44,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              69,
              58,
              11,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              95,
              115,
              101,
              116,
              34,
              54,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              83,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists ProductSets in an unspecified order.
     *
     * Possible errors:
     *
     * * Returns INVALID_ARGUMENT if page_size is greater than 100, or less
     *   than 1.
     */
    listProductSets: {
      name: "ListProductSets",
      requestType: ListProductSetsRequest,
      requestStream: false,
      responseType: ListProductSetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              83,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets information associated with a ProductSet.
     *
     * Possible errors:
     *
     * * Returns NOT_FOUND if the ProductSet does not exist.
     */
    getProductSet: {
      name: "GetProductSet",
      requestType: GetProductSetRequest,
      requestStream: false,
      responseType: ProductSet,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              83,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Makes changes to a ProductSet resource.
     * Only display_name can be updated currently.
     *
     * Possible errors:
     *
     * * Returns NOT_FOUND if the ProductSet does not exist.
     * * Returns INVALID_ARGUMENT if display_name is present in update_mask but
     *   missing from the request or longer than 4096 characters.
     */
    updateProductSet: {
      name: "UpdateProductSet",
      requestType: UpdateProductSetRequest,
      requestStream: false,
      responseType: ProductSet,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              95,
              115,
              101,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              81,
              58,
              11,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              95,
              115,
              101,
              116,
              50,
              66,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              95,
              115,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              83,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Permanently deletes a ProductSet. Products and ReferenceImages in the
     * ProductSet are not deleted.
     *
     * The actual image files are not deleted from Google Cloud Storage.
     */
    deleteProductSet: {
      name: "DeleteProductSet",
      requestType: DeleteProductSetRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              42,
              54,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              83,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates and returns a new product resource.
     *
     * Possible errors:
     *
     * * Returns INVALID_ARGUMENT if display_name is missing or longer than 4096
     *   characters.
     * * Returns INVALID_ARGUMENT if description is longer than 4096 characters.
     * * Returns INVALID_ARGUMENT if product_category is missing or invalid.
     */
    createProduct: {
      name: "CreateProduct",
      requestType: CreateProductRequest,
      requestStream: false,
      responseType: Product,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              25,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              44,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              62,
              58,
              7,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              34,
              51,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists products in an unspecified order.
     *
     * Possible errors:
     *
     * * Returns INVALID_ARGUMENT if page_size is greater than 100 or less than 1.
     */
    listProducts: {
      name: "ListProducts",
      requestType: ListProductsRequest,
      requestStream: false,
      responseType: ListProductsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets information associated with a Product.
     *
     * Possible errors:
     *
     * * Returns NOT_FOUND if the Product does not exist.
     */
    getProduct: {
      name: "GetProduct",
      requestType: GetProductRequest,
      requestStream: false,
      responseType: Product,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Makes changes to a Product resource.
     * Only the `display_name`, `description`, and `labels` fields can be updated
     * right now.
     *
     * If labels are updated, the change will not be reflected in queries until
     * the next index time.
     *
     * Possible errors:
     *
     * * Returns NOT_FOUND if the Product does not exist.
     * * Returns INVALID_ARGUMENT if display_name is present in update_mask but is
     *   missing from the request or longer than 4096 characters.
     * * Returns INVALID_ARGUMENT if description is present in update_mask but is
     *   longer than 4096 characters.
     * * Returns INVALID_ARGUMENT if product_category is present in update_mask.
     */
    updateProduct: {
      name: "UpdateProduct",
      requestType: UpdateProductRequest,
      requestStream: false,
      responseType: Product,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([19, 112, 114, 111, 100, 117, 99, 116, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              70,
              58,
              7,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              50,
              59,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Permanently deletes a product and its reference images.
     *
     * Metadata of the product and all its images will be deleted right away, but
     * search queries against ProductSets containing the product may still work
     * until all related caches are refreshed.
     */
    deleteProduct: {
      name: "DeleteProduct",
      requestType: DeleteProductRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              42,
              51,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates and returns a new ReferenceImage resource.
     *
     * The `bounding_poly` field is optional. If `bounding_poly` is not specified,
     * the system will try to detect regions of interest in the image that are
     * compatible with the product_category on the parent product. If it is
     * specified, detection is ALWAYS skipped. The system converts polygons into
     * non-rotated rectangles.
     *
     * Note that the pipeline will resize the image if the image resolution is too
     * large to process (above 50MP).
     *
     * Possible errors:
     *
     * * Returns INVALID_ARGUMENT if the image_uri is missing or longer than 4096
     *   characters.
     * * Returns INVALID_ARGUMENT if the product does not exist.
     * * Returns INVALID_ARGUMENT if bounding_poly is not provided, and nothing
     *   compatible with the parent product's product_category is detected.
     * * Returns INVALID_ARGUMENT if bounding_poly contains more than 10 polygons.
     */
    createReferenceImage: {
      name: "CreateReferenceImage",
      requestType: CreateReferenceImageRequest,
      requestStream: false,
      responseType: ReferenceImage,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              41,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              95,
              105,
              109,
              97,
              103,
              101,
              44,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              95,
              105,
              109,
              97,
              103,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              88,
              58,
              15,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              95,
              105,
              109,
              97,
              103,
              101,
              34,
              69,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              73,
              109,
              97,
              103,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Permanently deletes a reference image.
     *
     * The image metadata will be deleted right away, but search queries
     * against ProductSets containing the image may still work until all related
     * caches are refreshed.
     *
     * The actual image files are not deleted from Google Cloud Storage.
     */
    deleteReferenceImage: {
      name: "DeleteReferenceImage",
      requestType: DeleteReferenceImageRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              71,
              42,
              69,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              73,
              109,
              97,
              103,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists reference images.
     *
     * Possible errors:
     *
     * * Returns NOT_FOUND if the parent product does not exist.
     * * Returns INVALID_ARGUMENT if the page_size is greater than 100, or less
     *   than 1.
     */
    listReferenceImages: {
      name: "ListReferenceImages",
      requestType: ListReferenceImagesRequest,
      requestStream: false,
      responseType: ListReferenceImagesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              71,
              18,
              69,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              73,
              109,
              97,
              103,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets information associated with a ReferenceImage.
     *
     * Possible errors:
     *
     * * Returns NOT_FOUND if the specified image does not exist.
     */
    getReferenceImage: {
      name: "GetReferenceImage",
      requestType: GetReferenceImageRequest,
      requestStream: false,
      responseType: ReferenceImage,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              71,
              18,
              69,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              73,
              109,
              97,
              103,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Adds a Product to the specified ProductSet. If the Product is already
     * present, no change is made.
     *
     * One Product can be added to at most 100 ProductSets.
     *
     * Possible errors:
     *
     * * Returns NOT_FOUND if the Product or the ProductSet doesn't exist.
     */
    addProductToProductSet: {
      name: "AddProductToProductSet",
      requestType: AddProductToProductSetRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 110, 97, 109, 101, 44, 112, 114, 111, 100, 117, 99, 116])],
          578365826: [
            Buffer.from([
              70,
              58,
              1,
              42,
              34,
              65,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              83,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              100,
              100,
              80,
              114,
              111,
              100,
              117,
              99,
              116,
            ]),
          ],
        },
      },
    },
    /** Removes a Product from the specified ProductSet. */
    removeProductFromProductSet: {
      name: "RemoveProductFromProductSet",
      requestType: RemoveProductFromProductSetRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 110, 97, 109, 101, 44, 112, 114, 111, 100, 117, 99, 116])],
          578365826: [
            Buffer.from([
              73,
              58,
              1,
              42,
              34,
              68,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              83,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              109,
              111,
              118,
              101,
              80,
              114,
              111,
              100,
              117,
              99,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the Products in a ProductSet, in an unspecified order. If the
     * ProductSet does not exist, the products field of the response will be
     * empty.
     *
     * Possible errors:
     *
     * * Returns INVALID_ARGUMENT if page_size is greater than 100 or less than 1.
     */
    listProductsInProductSet: {
      name: "ListProductsInProductSet",
      requestType: ListProductsInProductSetRequest,
      requestStream: false,
      responseType: ListProductsInProductSetResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              65,
              18,
              63,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              83,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Asynchronous API that imports a list of reference images to specified
     * product sets based on a list of image information.
     *
     * The [google.longrunning.Operation][google.longrunning.Operation] API can be
     * used to keep track of the progress and results of the request.
     * `Operation.metadata` contains `BatchOperationMetadata`. (progress)
     * `Operation.response` contains `ImportProductSetsResponse`. (results)
     *
     * The input source of this method is a csv file on Google Cloud Storage.
     * For the format of the csv file please see
     * [ImportProductSetsGcsSource.csv_file_uri][google.cloud.vision.v1p4beta1.ImportProductSetsGcsSource.csv_file_uri].
     */
    importProductSets: {
      name: "ImportProductSets",
      requestType: ImportProductSetsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              51,
              10,
              25,
              73,
              109,
              112,
              111,
              114,
              116,
              80,
              114,
              111,
              100,
              117,
              99,
              116,
              83,
              101,
              116,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              22,
              66,
              97,
              116,
              99,
              104,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              19,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              105,
              110,
              112,
              117,
              116,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              83,
              101,
              116,
              115,
              58,
              105,
              109,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Asynchronous API to delete all Products in a ProductSet or all Products
     * that are in no ProductSet.
     *
     * If a Product is a member of the specified ProductSet in addition to other
     * ProductSets, the Product will still be deleted.
     *
     * It is recommended to not delete the specified ProductSet until after this
     * operation has completed. It is also recommended to not add any of the
     * Products involved in the batch delete to a new ProductSet while this
     * operation is running because those Products may still end up deleted.
     *
     * It's not possible to undo the PurgeProducts operation. Therefore, it is
     * recommended to keep the csv files used in ImportProductSets (if that was
     * how you originally built the Product Set) before starting PurgeProducts, in
     * case you need to re-import the data after deletion.
     *
     * If the plan is to purge all of the Products from a ProductSet and then
     * re-use the empty ProductSet to re-import new Products into the empty
     * ProductSet, you must wait until the PurgeProducts operation has finished
     * for that ProductSet.
     *
     * The [google.longrunning.Operation][google.longrunning.Operation] API can be
     * used to keep track of the progress and results of the request.
     * `Operation.metadata` contains `BatchOperationMetadata`. (progress)
     */
    purgeProducts: {
      name: "PurgeProducts",
      requestType: PurgeProductsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              47,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              22,
              66,
              97,
              116,
              99,
              104,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              62,
              58,
              1,
              42,
              34,
              57,
              47,
              118,
              49,
              112,
              52,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
              58,
              112,
              117,
              114,
              103,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ProductSearchServiceImplementation<CallContextExt = {}> {
  /**
   * Creates and returns a new ProductSet resource.
   *
   * Possible errors:
   *
   * * Returns INVALID_ARGUMENT if display_name is missing, or is longer than
   *   4096 characters.
   */
  createProductSet(
    request: CreateProductSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ProductSet>>;
  /**
   * Lists ProductSets in an unspecified order.
   *
   * Possible errors:
   *
   * * Returns INVALID_ARGUMENT if page_size is greater than 100, or less
   *   than 1.
   */
  listProductSets(
    request: ListProductSetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListProductSetsResponse>>;
  /**
   * Gets information associated with a ProductSet.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the ProductSet does not exist.
   */
  getProductSet(request: GetProductSetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ProductSet>>;
  /**
   * Makes changes to a ProductSet resource.
   * Only display_name can be updated currently.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the ProductSet does not exist.
   * * Returns INVALID_ARGUMENT if display_name is present in update_mask but
   *   missing from the request or longer than 4096 characters.
   */
  updateProductSet(
    request: UpdateProductSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ProductSet>>;
  /**
   * Permanently deletes a ProductSet. Products and ReferenceImages in the
   * ProductSet are not deleted.
   *
   * The actual image files are not deleted from Google Cloud Storage.
   */
  deleteProductSet(
    request: DeleteProductSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Creates and returns a new product resource.
   *
   * Possible errors:
   *
   * * Returns INVALID_ARGUMENT if display_name is missing or longer than 4096
   *   characters.
   * * Returns INVALID_ARGUMENT if description is longer than 4096 characters.
   * * Returns INVALID_ARGUMENT if product_category is missing or invalid.
   */
  createProduct(request: CreateProductRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Product>>;
  /**
   * Lists products in an unspecified order.
   *
   * Possible errors:
   *
   * * Returns INVALID_ARGUMENT if page_size is greater than 100 or less than 1.
   */
  listProducts(
    request: ListProductsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListProductsResponse>>;
  /**
   * Gets information associated with a Product.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the Product does not exist.
   */
  getProduct(request: GetProductRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Product>>;
  /**
   * Makes changes to a Product resource.
   * Only the `display_name`, `description`, and `labels` fields can be updated
   * right now.
   *
   * If labels are updated, the change will not be reflected in queries until
   * the next index time.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the Product does not exist.
   * * Returns INVALID_ARGUMENT if display_name is present in update_mask but is
   *   missing from the request or longer than 4096 characters.
   * * Returns INVALID_ARGUMENT if description is present in update_mask but is
   *   longer than 4096 characters.
   * * Returns INVALID_ARGUMENT if product_category is present in update_mask.
   */
  updateProduct(request: UpdateProductRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Product>>;
  /**
   * Permanently deletes a product and its reference images.
   *
   * Metadata of the product and all its images will be deleted right away, but
   * search queries against ProductSets containing the product may still work
   * until all related caches are refreshed.
   */
  deleteProduct(request: DeleteProductRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Creates and returns a new ReferenceImage resource.
   *
   * The `bounding_poly` field is optional. If `bounding_poly` is not specified,
   * the system will try to detect regions of interest in the image that are
   * compatible with the product_category on the parent product. If it is
   * specified, detection is ALWAYS skipped. The system converts polygons into
   * non-rotated rectangles.
   *
   * Note that the pipeline will resize the image if the image resolution is too
   * large to process (above 50MP).
   *
   * Possible errors:
   *
   * * Returns INVALID_ARGUMENT if the image_uri is missing or longer than 4096
   *   characters.
   * * Returns INVALID_ARGUMENT if the product does not exist.
   * * Returns INVALID_ARGUMENT if bounding_poly is not provided, and nothing
   *   compatible with the parent product's product_category is detected.
   * * Returns INVALID_ARGUMENT if bounding_poly contains more than 10 polygons.
   */
  createReferenceImage(
    request: CreateReferenceImageRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReferenceImage>>;
  /**
   * Permanently deletes a reference image.
   *
   * The image metadata will be deleted right away, but search queries
   * against ProductSets containing the image may still work until all related
   * caches are refreshed.
   *
   * The actual image files are not deleted from Google Cloud Storage.
   */
  deleteReferenceImage(
    request: DeleteReferenceImageRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Lists reference images.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the parent product does not exist.
   * * Returns INVALID_ARGUMENT if the page_size is greater than 100, or less
   *   than 1.
   */
  listReferenceImages(
    request: ListReferenceImagesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListReferenceImagesResponse>>;
  /**
   * Gets information associated with a ReferenceImage.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the specified image does not exist.
   */
  getReferenceImage(
    request: GetReferenceImageRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReferenceImage>>;
  /**
   * Adds a Product to the specified ProductSet. If the Product is already
   * present, no change is made.
   *
   * One Product can be added to at most 100 ProductSets.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the Product or the ProductSet doesn't exist.
   */
  addProductToProductSet(
    request: AddProductToProductSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Removes a Product from the specified ProductSet. */
  removeProductFromProductSet(
    request: RemoveProductFromProductSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Lists the Products in a ProductSet, in an unspecified order. If the
   * ProductSet does not exist, the products field of the response will be
   * empty.
   *
   * Possible errors:
   *
   * * Returns INVALID_ARGUMENT if page_size is greater than 100 or less than 1.
   */
  listProductsInProductSet(
    request: ListProductsInProductSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListProductsInProductSetResponse>>;
  /**
   * Asynchronous API that imports a list of reference images to specified
   * product sets based on a list of image information.
   *
   * The [google.longrunning.Operation][google.longrunning.Operation] API can be
   * used to keep track of the progress and results of the request.
   * `Operation.metadata` contains `BatchOperationMetadata`. (progress)
   * `Operation.response` contains `ImportProductSetsResponse`. (results)
   *
   * The input source of this method is a csv file on Google Cloud Storage.
   * For the format of the csv file please see
   * [ImportProductSetsGcsSource.csv_file_uri][google.cloud.vision.v1p4beta1.ImportProductSetsGcsSource.csv_file_uri].
   */
  importProductSets(
    request: ImportProductSetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Asynchronous API to delete all Products in a ProductSet or all Products
   * that are in no ProductSet.
   *
   * If a Product is a member of the specified ProductSet in addition to other
   * ProductSets, the Product will still be deleted.
   *
   * It is recommended to not delete the specified ProductSet until after this
   * operation has completed. It is also recommended to not add any of the
   * Products involved in the batch delete to a new ProductSet while this
   * operation is running because those Products may still end up deleted.
   *
   * It's not possible to undo the PurgeProducts operation. Therefore, it is
   * recommended to keep the csv files used in ImportProductSets (if that was
   * how you originally built the Product Set) before starting PurgeProducts, in
   * case you need to re-import the data after deletion.
   *
   * If the plan is to purge all of the Products from a ProductSet and then
   * re-use the empty ProductSet to re-import new Products into the empty
   * ProductSet, you must wait until the PurgeProducts operation has finished
   * for that ProductSet.
   *
   * The [google.longrunning.Operation][google.longrunning.Operation] API can be
   * used to keep track of the progress and results of the request.
   * `Operation.metadata` contains `BatchOperationMetadata`. (progress)
   */
  purgeProducts(request: PurgeProductsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
}

export interface ProductSearchClient<CallOptionsExt = {}> {
  /**
   * Creates and returns a new ProductSet resource.
   *
   * Possible errors:
   *
   * * Returns INVALID_ARGUMENT if display_name is missing, or is longer than
   *   4096 characters.
   */
  createProductSet(
    request: DeepPartial<CreateProductSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ProductSet>;
  /**
   * Lists ProductSets in an unspecified order.
   *
   * Possible errors:
   *
   * * Returns INVALID_ARGUMENT if page_size is greater than 100, or less
   *   than 1.
   */
  listProductSets(
    request: DeepPartial<ListProductSetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListProductSetsResponse>;
  /**
   * Gets information associated with a ProductSet.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the ProductSet does not exist.
   */
  getProductSet(
    request: DeepPartial<GetProductSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ProductSet>;
  /**
   * Makes changes to a ProductSet resource.
   * Only display_name can be updated currently.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the ProductSet does not exist.
   * * Returns INVALID_ARGUMENT if display_name is present in update_mask but
   *   missing from the request or longer than 4096 characters.
   */
  updateProductSet(
    request: DeepPartial<UpdateProductSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ProductSet>;
  /**
   * Permanently deletes a ProductSet. Products and ReferenceImages in the
   * ProductSet are not deleted.
   *
   * The actual image files are not deleted from Google Cloud Storage.
   */
  deleteProductSet(
    request: DeepPartial<DeleteProductSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Creates and returns a new product resource.
   *
   * Possible errors:
   *
   * * Returns INVALID_ARGUMENT if display_name is missing or longer than 4096
   *   characters.
   * * Returns INVALID_ARGUMENT if description is longer than 4096 characters.
   * * Returns INVALID_ARGUMENT if product_category is missing or invalid.
   */
  createProduct(request: DeepPartial<CreateProductRequest>, options?: CallOptions & CallOptionsExt): Promise<Product>;
  /**
   * Lists products in an unspecified order.
   *
   * Possible errors:
   *
   * * Returns INVALID_ARGUMENT if page_size is greater than 100 or less than 1.
   */
  listProducts(
    request: DeepPartial<ListProductsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListProductsResponse>;
  /**
   * Gets information associated with a Product.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the Product does not exist.
   */
  getProduct(request: DeepPartial<GetProductRequest>, options?: CallOptions & CallOptionsExt): Promise<Product>;
  /**
   * Makes changes to a Product resource.
   * Only the `display_name`, `description`, and `labels` fields can be updated
   * right now.
   *
   * If labels are updated, the change will not be reflected in queries until
   * the next index time.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the Product does not exist.
   * * Returns INVALID_ARGUMENT if display_name is present in update_mask but is
   *   missing from the request or longer than 4096 characters.
   * * Returns INVALID_ARGUMENT if description is present in update_mask but is
   *   longer than 4096 characters.
   * * Returns INVALID_ARGUMENT if product_category is present in update_mask.
   */
  updateProduct(request: DeepPartial<UpdateProductRequest>, options?: CallOptions & CallOptionsExt): Promise<Product>;
  /**
   * Permanently deletes a product and its reference images.
   *
   * Metadata of the product and all its images will be deleted right away, but
   * search queries against ProductSets containing the product may still work
   * until all related caches are refreshed.
   */
  deleteProduct(request: DeepPartial<DeleteProductRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Creates and returns a new ReferenceImage resource.
   *
   * The `bounding_poly` field is optional. If `bounding_poly` is not specified,
   * the system will try to detect regions of interest in the image that are
   * compatible with the product_category on the parent product. If it is
   * specified, detection is ALWAYS skipped. The system converts polygons into
   * non-rotated rectangles.
   *
   * Note that the pipeline will resize the image if the image resolution is too
   * large to process (above 50MP).
   *
   * Possible errors:
   *
   * * Returns INVALID_ARGUMENT if the image_uri is missing or longer than 4096
   *   characters.
   * * Returns INVALID_ARGUMENT if the product does not exist.
   * * Returns INVALID_ARGUMENT if bounding_poly is not provided, and nothing
   *   compatible with the parent product's product_category is detected.
   * * Returns INVALID_ARGUMENT if bounding_poly contains more than 10 polygons.
   */
  createReferenceImage(
    request: DeepPartial<CreateReferenceImageRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReferenceImage>;
  /**
   * Permanently deletes a reference image.
   *
   * The image metadata will be deleted right away, but search queries
   * against ProductSets containing the image may still work until all related
   * caches are refreshed.
   *
   * The actual image files are not deleted from Google Cloud Storage.
   */
  deleteReferenceImage(
    request: DeepPartial<DeleteReferenceImageRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Lists reference images.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the parent product does not exist.
   * * Returns INVALID_ARGUMENT if the page_size is greater than 100, or less
   *   than 1.
   */
  listReferenceImages(
    request: DeepPartial<ListReferenceImagesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListReferenceImagesResponse>;
  /**
   * Gets information associated with a ReferenceImage.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the specified image does not exist.
   */
  getReferenceImage(
    request: DeepPartial<GetReferenceImageRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReferenceImage>;
  /**
   * Adds a Product to the specified ProductSet. If the Product is already
   * present, no change is made.
   *
   * One Product can be added to at most 100 ProductSets.
   *
   * Possible errors:
   *
   * * Returns NOT_FOUND if the Product or the ProductSet doesn't exist.
   */
  addProductToProductSet(
    request: DeepPartial<AddProductToProductSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Removes a Product from the specified ProductSet. */
  removeProductFromProductSet(
    request: DeepPartial<RemoveProductFromProductSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Lists the Products in a ProductSet, in an unspecified order. If the
   * ProductSet does not exist, the products field of the response will be
   * empty.
   *
   * Possible errors:
   *
   * * Returns INVALID_ARGUMENT if page_size is greater than 100 or less than 1.
   */
  listProductsInProductSet(
    request: DeepPartial<ListProductsInProductSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListProductsInProductSetResponse>;
  /**
   * Asynchronous API that imports a list of reference images to specified
   * product sets based on a list of image information.
   *
   * The [google.longrunning.Operation][google.longrunning.Operation] API can be
   * used to keep track of the progress and results of the request.
   * `Operation.metadata` contains `BatchOperationMetadata`. (progress)
   * `Operation.response` contains `ImportProductSetsResponse`. (results)
   *
   * The input source of this method is a csv file on Google Cloud Storage.
   * For the format of the csv file please see
   * [ImportProductSetsGcsSource.csv_file_uri][google.cloud.vision.v1p4beta1.ImportProductSetsGcsSource.csv_file_uri].
   */
  importProductSets(
    request: DeepPartial<ImportProductSetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Asynchronous API to delete all Products in a ProductSet or all Products
   * that are in no ProductSet.
   *
   * If a Product is a member of the specified ProductSet in addition to other
   * ProductSets, the Product will still be deleted.
   *
   * It is recommended to not delete the specified ProductSet until after this
   * operation has completed. It is also recommended to not add any of the
   * Products involved in the batch delete to a new ProductSet while this
   * operation is running because those Products may still end up deleted.
   *
   * It's not possible to undo the PurgeProducts operation. Therefore, it is
   * recommended to keep the csv files used in ImportProductSets (if that was
   * how you originally built the Product Set) before starting PurgeProducts, in
   * case you need to re-import the data after deletion.
   *
   * If the plan is to purge all of the Products from a ProductSet and then
   * re-use the empty ProductSet to re-import new Products into the empty
   * ProductSet, you must wait until the PurgeProducts operation has finished
   * for that ProductSet.
   *
   * The [google.longrunning.Operation][google.longrunning.Operation] API can be
   * used to keep track of the progress and results of the request.
   * `Operation.metadata` contains `BatchOperationMetadata`. (progress)
   */
  purgeProducts(request: DeepPartial<PurgeProductsRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
