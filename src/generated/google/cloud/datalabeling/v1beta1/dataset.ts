// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/datalabeling/v1beta1/dataset.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  Annotation,
  AnnotationSource,
  annotationSourceFromJSON,
  annotationSourceToJSON,
  AnnotationType,
  annotationTypeFromJSON,
  annotationTypeToJSON,
} from "./annotation.js";
import { ImagePayload, TextPayload, VideoPayload } from "./data_payloads.js";
import {
  BoundingPolyConfig,
  EventConfig,
  HumanAnnotationConfig,
  ImageClassificationConfig,
  ObjectDetectionConfig,
  ObjectTrackingConfig,
  PolylineConfig,
  SegmentationConfig,
  TextClassificationConfig,
  TextEntityExtractionConfig,
  VideoClassificationConfig,
} from "./human_annotation_config.js";

export const protobufPackage = "google.cloud.datalabeling.v1beta1";

export enum DataType {
  DATA_TYPE_UNSPECIFIED = 0,
  /** IMAGE - Allowed for continuous evaluation. */
  IMAGE = 1,
  VIDEO = 2,
  /** TEXT - Allowed for continuous evaluation. */
  TEXT = 4,
  /** GENERAL_DATA - Allowed for continuous evaluation. */
  GENERAL_DATA = 6,
  UNRECOGNIZED = -1,
}

export function dataTypeFromJSON(object: any): DataType {
  switch (object) {
    case 0:
    case "DATA_TYPE_UNSPECIFIED":
      return DataType.DATA_TYPE_UNSPECIFIED;
    case 1:
    case "IMAGE":
      return DataType.IMAGE;
    case 2:
    case "VIDEO":
      return DataType.VIDEO;
    case 4:
    case "TEXT":
      return DataType.TEXT;
    case 6:
    case "GENERAL_DATA":
      return DataType.GENERAL_DATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataType.UNRECOGNIZED;
  }
}

export function dataTypeToJSON(object: DataType): string {
  switch (object) {
    case DataType.DATA_TYPE_UNSPECIFIED:
      return "DATA_TYPE_UNSPECIFIED";
    case DataType.IMAGE:
      return "IMAGE";
    case DataType.VIDEO:
      return "VIDEO";
    case DataType.TEXT:
      return "TEXT";
    case DataType.GENERAL_DATA:
      return "GENERAL_DATA";
    case DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Dataset is the resource to hold your data. You can request multiple labeling
 * tasks for a dataset while each one will generate an AnnotatedDataset.
 */
export interface Dataset {
  /**
   * Output only. Dataset resource name, format is:
   * projects/{project_id}/datasets/{dataset_id}
   */
  name: string;
  /** Required. The display name of the dataset. Maximum of 64 characters. */
  displayName: string;
  /**
   * Optional. User-provided description of the annotation specification set.
   * The description can be up to 10000 characters long.
   */
  description: string;
  /** Output only. Time the dataset is created. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. This is populated with the original input configs
   * where ImportData is called. It is available only after the clients
   * import data to this dataset.
   */
  inputConfigs: InputConfig[];
  /**
   * Output only. The names of any related resources that are blocking changes
   * to the dataset.
   */
  blockingResources: string[];
  /** Output only. The number of data items in the dataset. */
  dataItemCount: Long;
}

/** The configuration of input data, including data type, location, etc. */
export interface InputConfig {
  /** Required for text import, as language code must be specified. */
  textMetadata?:
    | TextMetadata
    | undefined;
  /** Source located in Cloud Storage. */
  gcsSource?:
    | GcsSource
    | undefined;
  /**
   * Source located in BigQuery. You must specify this field if you are using
   * this InputConfig in an [EvaluationJob][google.cloud.datalabeling.v1beta1.EvaluationJob].
   */
  bigquerySource?:
    | BigQuerySource
    | undefined;
  /** Required. Data type must be specifed when user tries to import data. */
  dataType: DataType;
  /**
   * Optional. The type of annotation to be performed on this data. You must
   * specify this field if you are using this InputConfig in an
   * [EvaluationJob][google.cloud.datalabeling.v1beta1.EvaluationJob].
   */
  annotationType: AnnotationType;
  /**
   * Optional. Metadata about annotations for the input. You must specify this
   * field if you are using this InputConfig in an [EvaluationJob][google.cloud.datalabeling.v1beta1.EvaluationJob] for a
   * model version that performs classification.
   */
  classificationMetadata: ClassificationMetadata | undefined;
}

/** Metadata for the text. */
export interface TextMetadata {
  /**
   * The language of this text, as a
   * [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt).
   * Default value is en-US.
   */
  languageCode: string;
}

/** Metadata for classification annotations. */
export interface ClassificationMetadata {
  /** Whether the classification task is multi-label or not. */
  isMultiLabel: boolean;
}

/** Source of the Cloud Storage file to be imported. */
export interface GcsSource {
  /**
   * Required. The input URI of source file. This must be a Cloud Storage path
   * (`gs://...`).
   */
  inputUri: string;
  /** Required. The format of the source file. Only "text/csv" is supported. */
  mimeType: string;
}

/**
 * The BigQuery location for input data. If used in an [EvaluationJob][google.cloud.datalabeling.v1beta1.EvaluationJob], this
 * is where the service saves the prediction input and output sampled from the
 * model version.
 */
export interface BigQuerySource {
  /**
   * Required. BigQuery URI to a table, up to 2,000 characters long. If you
   * specify the URI of a table that does not exist, Data Labeling Service
   * creates a table at the URI with the correct schema when you create your
   * [EvaluationJob][google.cloud.datalabeling.v1beta1.EvaluationJob]. If you specify the URI of a table that already exists,
   * it must have the
   * [correct
   * schema](/ml-engine/docs/continuous-evaluation/create-job#table-schema).
   *
   * Provide the table URI in the following format:
   *
   * "bq://<var>{your_project_id}</var>/<var>{your_dataset_name}</var>/<var>{your_table_name}</var>"
   *
   * [Learn
   * more](/ml-engine/docs/continuous-evaluation/create-job#table-schema).
   */
  inputUri: string;
}

/** The configuration of output data. */
export interface OutputConfig {
  /**
   * Output to a file in Cloud Storage. Should be used for labeling output
   * other than image segmentation.
   */
  gcsDestination?:
    | GcsDestination
    | undefined;
  /**
   * Output to a folder in Cloud Storage. Should be used for image
   * segmentation labeling output.
   */
  gcsFolderDestination?: GcsFolderDestination | undefined;
}

/**
 * Export destination of the data.Only gcs path is allowed in
 * output_uri.
 */
export interface GcsDestination {
  /** Required. The output uri of destination file. */
  outputUri: string;
  /**
   * Required. The format of the gcs destination. Only "text/csv" and
   * "application/json"
   * are supported.
   */
  mimeType: string;
}

/** Export folder destination of the data. */
export interface GcsFolderDestination {
  /** Required. Cloud Storage directory to export data to. */
  outputFolderUri: string;
}

/** DataItem is a piece of data, without annotation. For example, an image. */
export interface DataItem {
  /** The image payload, a container of the image bytes/uri. */
  imagePayload?:
    | ImagePayload
    | undefined;
  /** The text payload, a container of text content. */
  textPayload?:
    | TextPayload
    | undefined;
  /** The video payload, a container of the video uri. */
  videoPayload?:
    | VideoPayload
    | undefined;
  /**
   * Output only. Name of the data item, in format of:
   * projects/{project_id}/datasets/{dataset_id}/dataItems/{data_item_id}
   */
  name: string;
}

/**
 * AnnotatedDataset is a set holding annotations for data in a Dataset. Each
 * labeling task will generate an AnnotatedDataset under the Dataset that the
 * task is requested for.
 */
export interface AnnotatedDataset {
  /**
   * Output only. AnnotatedDataset resource name in format of:
   * projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/
   * {annotated_dataset_id}
   */
  name: string;
  /**
   * Output only. The display name of the AnnotatedDataset. It is specified in
   * HumanAnnotationConfig when user starts a labeling task. Maximum of 64
   * characters.
   */
  displayName: string;
  /**
   * Output only. The description of the AnnotatedDataset. It is specified in
   * HumanAnnotationConfig when user starts a labeling task. Maximum of 10000
   * characters.
   */
  description: string;
  /** Output only. Source of the annotation. */
  annotationSource: AnnotationSource;
  /**
   * Output only. Type of the annotation. It is specified when starting labeling
   * task.
   */
  annotationType: AnnotationType;
  /** Output only. Number of examples in the annotated dataset. */
  exampleCount: Long;
  /**
   * Output only. Number of examples that have annotation in the annotated
   * dataset.
   */
  completedExampleCount: Long;
  /** Output only. Per label statistics. */
  labelStats:
    | LabelStats
    | undefined;
  /** Output only. Time the AnnotatedDataset was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Additional information about AnnotatedDataset. */
  metadata:
    | AnnotatedDatasetMetadata
    | undefined;
  /**
   * Output only. The names of any related resources that are blocking changes
   * to the annotated dataset.
   */
  blockingResources: string[];
}

/** Statistics about annotation specs. */
export interface LabelStats {
  /**
   * Map of each annotation spec's example count. Key is the annotation spec
   * name and value is the number of examples for that annotation spec.
   * If the annotated dataset does not have annotation spec, the map will return
   * a pair where the key is empty string and value is the total number of
   * annotations.
   */
  exampleCount: { [key: string]: Long };
}

export interface LabelStats_ExampleCountEntry {
  key: string;
  value: Long;
}

/** Metadata on AnnotatedDataset. */
export interface AnnotatedDatasetMetadata {
  /** Configuration for image classification task. */
  imageClassificationConfig?:
    | ImageClassificationConfig
    | undefined;
  /** Configuration for image bounding box and bounding poly task. */
  boundingPolyConfig?:
    | BoundingPolyConfig
    | undefined;
  /** Configuration for image polyline task. */
  polylineConfig?:
    | PolylineConfig
    | undefined;
  /** Configuration for image segmentation task. */
  segmentationConfig?:
    | SegmentationConfig
    | undefined;
  /** Configuration for video classification task. */
  videoClassificationConfig?:
    | VideoClassificationConfig
    | undefined;
  /** Configuration for video object detection task. */
  objectDetectionConfig?:
    | ObjectDetectionConfig
    | undefined;
  /** Configuration for video object tracking task. */
  objectTrackingConfig?:
    | ObjectTrackingConfig
    | undefined;
  /** Configuration for video event labeling task. */
  eventConfig?:
    | EventConfig
    | undefined;
  /** Configuration for text classification task. */
  textClassificationConfig?:
    | TextClassificationConfig
    | undefined;
  /** Configuration for text entity extraction task. */
  textEntityExtractionConfig?:
    | TextEntityExtractionConfig
    | undefined;
  /**
   * HumanAnnotationConfig used when requesting the human labeling task for this
   * AnnotatedDataset.
   */
  humanAnnotationConfig: HumanAnnotationConfig | undefined;
}

/**
 * An Example is a piece of data and its annotation. For example, an image with
 * label "house".
 */
export interface Example {
  /** The image payload, a container of the image bytes/uri. */
  imagePayload?:
    | ImagePayload
    | undefined;
  /** The text payload, a container of the text content. */
  textPayload?:
    | TextPayload
    | undefined;
  /** The video payload, a container of the video uri. */
  videoPayload?:
    | VideoPayload
    | undefined;
  /**
   * Output only. Name of the example, in format of:
   * projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/
   * {annotated_dataset_id}/examples/{example_id}
   */
  name: string;
  /**
   * Output only. Annotations for the piece of data in Example.
   * One piece of data can have multiple annotations.
   */
  annotations: Annotation[];
}

function createBaseDataset(): Dataset {
  return {
    name: "",
    displayName: "",
    description: "",
    createTime: undefined,
    inputConfigs: [],
    blockingResources: [],
    dataItemCount: Long.ZERO,
  };
}

export const Dataset: MessageFns<Dataset> = {
  encode(message: Dataset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    for (const v of message.inputConfigs) {
      InputConfig.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.blockingResources) {
      writer.uint32(50).string(v!);
    }
    if (!message.dataItemCount.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.dataItemCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dataset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inputConfigs.push(InputConfig.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.blockingResources.push(reader.string());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.dataItemCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dataset {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      inputConfigs: globalThis.Array.isArray(object?.inputConfigs)
        ? object.inputConfigs.map((e: any) => InputConfig.fromJSON(e))
        : [],
      blockingResources: globalThis.Array.isArray(object?.blockingResources)
        ? object.blockingResources.map((e: any) => globalThis.String(e))
        : [],
      dataItemCount: isSet(object.dataItemCount) ? Long.fromValue(object.dataItemCount) : Long.ZERO,
    };
  },

  toJSON(message: Dataset): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.inputConfigs?.length) {
      obj.inputConfigs = message.inputConfigs.map((e) => InputConfig.toJSON(e));
    }
    if (message.blockingResources?.length) {
      obj.blockingResources = message.blockingResources;
    }
    if (!message.dataItemCount.equals(Long.ZERO)) {
      obj.dataItemCount = (message.dataItemCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Dataset>): Dataset {
    return Dataset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Dataset>): Dataset {
    const message = createBaseDataset();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.inputConfigs = object.inputConfigs?.map((e) => InputConfig.fromPartial(e)) || [];
    message.blockingResources = object.blockingResources?.map((e) => e) || [];
    message.dataItemCount = (object.dataItemCount !== undefined && object.dataItemCount !== null)
      ? Long.fromValue(object.dataItemCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseInputConfig(): InputConfig {
  return {
    textMetadata: undefined,
    gcsSource: undefined,
    bigquerySource: undefined,
    dataType: 0,
    annotationType: 0,
    classificationMetadata: undefined,
  };
}

export const InputConfig: MessageFns<InputConfig> = {
  encode(message: InputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textMetadata !== undefined) {
      TextMetadata.encode(message.textMetadata, writer.uint32(50).fork()).join();
    }
    if (message.gcsSource !== undefined) {
      GcsSource.encode(message.gcsSource, writer.uint32(18).fork()).join();
    }
    if (message.bigquerySource !== undefined) {
      BigQuerySource.encode(message.bigquerySource, writer.uint32(42).fork()).join();
    }
    if (message.dataType !== 0) {
      writer.uint32(8).int32(message.dataType);
    }
    if (message.annotationType !== 0) {
      writer.uint32(24).int32(message.annotationType);
    }
    if (message.classificationMetadata !== undefined) {
      ClassificationMetadata.encode(message.classificationMetadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.textMetadata = TextMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcsSource = GcsSource.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bigquerySource = BigQuerySource.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.annotationType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.classificationMetadata = ClassificationMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputConfig {
    return {
      textMetadata: isSet(object.textMetadata) ? TextMetadata.fromJSON(object.textMetadata) : undefined,
      gcsSource: isSet(object.gcsSource) ? GcsSource.fromJSON(object.gcsSource) : undefined,
      bigquerySource: isSet(object.bigquerySource) ? BigQuerySource.fromJSON(object.bigquerySource) : undefined,
      dataType: isSet(object.dataType) ? dataTypeFromJSON(object.dataType) : 0,
      annotationType: isSet(object.annotationType) ? annotationTypeFromJSON(object.annotationType) : 0,
      classificationMetadata: isSet(object.classificationMetadata)
        ? ClassificationMetadata.fromJSON(object.classificationMetadata)
        : undefined,
    };
  },

  toJSON(message: InputConfig): unknown {
    const obj: any = {};
    if (message.textMetadata !== undefined) {
      obj.textMetadata = TextMetadata.toJSON(message.textMetadata);
    }
    if (message.gcsSource !== undefined) {
      obj.gcsSource = GcsSource.toJSON(message.gcsSource);
    }
    if (message.bigquerySource !== undefined) {
      obj.bigquerySource = BigQuerySource.toJSON(message.bigquerySource);
    }
    if (message.dataType !== 0) {
      obj.dataType = dataTypeToJSON(message.dataType);
    }
    if (message.annotationType !== 0) {
      obj.annotationType = annotationTypeToJSON(message.annotationType);
    }
    if (message.classificationMetadata !== undefined) {
      obj.classificationMetadata = ClassificationMetadata.toJSON(message.classificationMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<InputConfig>): InputConfig {
    return InputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputConfig>): InputConfig {
    const message = createBaseInputConfig();
    message.textMetadata = (object.textMetadata !== undefined && object.textMetadata !== null)
      ? TextMetadata.fromPartial(object.textMetadata)
      : undefined;
    message.gcsSource = (object.gcsSource !== undefined && object.gcsSource !== null)
      ? GcsSource.fromPartial(object.gcsSource)
      : undefined;
    message.bigquerySource = (object.bigquerySource !== undefined && object.bigquerySource !== null)
      ? BigQuerySource.fromPartial(object.bigquerySource)
      : undefined;
    message.dataType = object.dataType ?? 0;
    message.annotationType = object.annotationType ?? 0;
    message.classificationMetadata =
      (object.classificationMetadata !== undefined && object.classificationMetadata !== null)
        ? ClassificationMetadata.fromPartial(object.classificationMetadata)
        : undefined;
    return message;
  },
};

function createBaseTextMetadata(): TextMetadata {
  return { languageCode: "" };
}

export const TextMetadata: MessageFns<TextMetadata> = {
  encode(message: TextMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.languageCode !== "") {
      writer.uint32(10).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextMetadata {
    return { languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "" };
  },

  toJSON(message: TextMetadata): unknown {
    const obj: any = {};
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<TextMetadata>): TextMetadata {
    return TextMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextMetadata>): TextMetadata {
    const message = createBaseTextMetadata();
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseClassificationMetadata(): ClassificationMetadata {
  return { isMultiLabel: false };
}

export const ClassificationMetadata: MessageFns<ClassificationMetadata> = {
  encode(message: ClassificationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isMultiLabel !== false) {
      writer.uint32(8).bool(message.isMultiLabel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClassificationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassificationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isMultiLabel = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClassificationMetadata {
    return { isMultiLabel: isSet(object.isMultiLabel) ? globalThis.Boolean(object.isMultiLabel) : false };
  },

  toJSON(message: ClassificationMetadata): unknown {
    const obj: any = {};
    if (message.isMultiLabel !== false) {
      obj.isMultiLabel = message.isMultiLabel;
    }
    return obj;
  },

  create(base?: DeepPartial<ClassificationMetadata>): ClassificationMetadata {
    return ClassificationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClassificationMetadata>): ClassificationMetadata {
    const message = createBaseClassificationMetadata();
    message.isMultiLabel = object.isMultiLabel ?? false;
    return message;
  },
};

function createBaseGcsSource(): GcsSource {
  return { inputUri: "", mimeType: "" };
}

export const GcsSource: MessageFns<GcsSource> = {
  encode(message: GcsSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputUri !== "") {
      writer.uint32(10).string(message.inputUri);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsSource {
    return {
      inputUri: isSet(object.inputUri) ? globalThis.String(object.inputUri) : "",
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
    };
  },

  toJSON(message: GcsSource): unknown {
    const obj: any = {};
    if (message.inputUri !== "") {
      obj.inputUri = message.inputUri;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create(base?: DeepPartial<GcsSource>): GcsSource {
    return GcsSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsSource>): GcsSource {
    const message = createBaseGcsSource();
    message.inputUri = object.inputUri ?? "";
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseBigQuerySource(): BigQuerySource {
  return { inputUri: "" };
}

export const BigQuerySource: MessageFns<BigQuerySource> = {
  encode(message: BigQuerySource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputUri !== "") {
      writer.uint32(10).string(message.inputUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BigQuerySource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigQuerySource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BigQuerySource {
    return { inputUri: isSet(object.inputUri) ? globalThis.String(object.inputUri) : "" };
  },

  toJSON(message: BigQuerySource): unknown {
    const obj: any = {};
    if (message.inputUri !== "") {
      obj.inputUri = message.inputUri;
    }
    return obj;
  },

  create(base?: DeepPartial<BigQuerySource>): BigQuerySource {
    return BigQuerySource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BigQuerySource>): BigQuerySource {
    const message = createBaseBigQuerySource();
    message.inputUri = object.inputUri ?? "";
    return message;
  },
};

function createBaseOutputConfig(): OutputConfig {
  return { gcsDestination: undefined, gcsFolderDestination: undefined };
}

export const OutputConfig: MessageFns<OutputConfig> = {
  encode(message: OutputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsDestination !== undefined) {
      GcsDestination.encode(message.gcsDestination, writer.uint32(10).fork()).join();
    }
    if (message.gcsFolderDestination !== undefined) {
      GcsFolderDestination.encode(message.gcsFolderDestination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsDestination = GcsDestination.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcsFolderDestination = GcsFolderDestination.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputConfig {
    return {
      gcsDestination: isSet(object.gcsDestination) ? GcsDestination.fromJSON(object.gcsDestination) : undefined,
      gcsFolderDestination: isSet(object.gcsFolderDestination)
        ? GcsFolderDestination.fromJSON(object.gcsFolderDestination)
        : undefined,
    };
  },

  toJSON(message: OutputConfig): unknown {
    const obj: any = {};
    if (message.gcsDestination !== undefined) {
      obj.gcsDestination = GcsDestination.toJSON(message.gcsDestination);
    }
    if (message.gcsFolderDestination !== undefined) {
      obj.gcsFolderDestination = GcsFolderDestination.toJSON(message.gcsFolderDestination);
    }
    return obj;
  },

  create(base?: DeepPartial<OutputConfig>): OutputConfig {
    return OutputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutputConfig>): OutputConfig {
    const message = createBaseOutputConfig();
    message.gcsDestination = (object.gcsDestination !== undefined && object.gcsDestination !== null)
      ? GcsDestination.fromPartial(object.gcsDestination)
      : undefined;
    message.gcsFolderDestination = (object.gcsFolderDestination !== undefined && object.gcsFolderDestination !== null)
      ? GcsFolderDestination.fromPartial(object.gcsFolderDestination)
      : undefined;
    return message;
  },
};

function createBaseGcsDestination(): GcsDestination {
  return { outputUri: "", mimeType: "" };
}

export const GcsDestination: MessageFns<GcsDestination> = {
  encode(message: GcsDestination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputUri !== "") {
      writer.uint32(10).string(message.outputUri);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsDestination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outputUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsDestination {
    return {
      outputUri: isSet(object.outputUri) ? globalThis.String(object.outputUri) : "",
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
    };
  },

  toJSON(message: GcsDestination): unknown {
    const obj: any = {};
    if (message.outputUri !== "") {
      obj.outputUri = message.outputUri;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create(base?: DeepPartial<GcsDestination>): GcsDestination {
    return GcsDestination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsDestination>): GcsDestination {
    const message = createBaseGcsDestination();
    message.outputUri = object.outputUri ?? "";
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseGcsFolderDestination(): GcsFolderDestination {
  return { outputFolderUri: "" };
}

export const GcsFolderDestination: MessageFns<GcsFolderDestination> = {
  encode(message: GcsFolderDestination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputFolderUri !== "") {
      writer.uint32(10).string(message.outputFolderUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsFolderDestination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsFolderDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outputFolderUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsFolderDestination {
    return { outputFolderUri: isSet(object.outputFolderUri) ? globalThis.String(object.outputFolderUri) : "" };
  },

  toJSON(message: GcsFolderDestination): unknown {
    const obj: any = {};
    if (message.outputFolderUri !== "") {
      obj.outputFolderUri = message.outputFolderUri;
    }
    return obj;
  },

  create(base?: DeepPartial<GcsFolderDestination>): GcsFolderDestination {
    return GcsFolderDestination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsFolderDestination>): GcsFolderDestination {
    const message = createBaseGcsFolderDestination();
    message.outputFolderUri = object.outputFolderUri ?? "";
    return message;
  },
};

function createBaseDataItem(): DataItem {
  return { imagePayload: undefined, textPayload: undefined, videoPayload: undefined, name: "" };
}

export const DataItem: MessageFns<DataItem> = {
  encode(message: DataItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imagePayload !== undefined) {
      ImagePayload.encode(message.imagePayload, writer.uint32(18).fork()).join();
    }
    if (message.textPayload !== undefined) {
      TextPayload.encode(message.textPayload, writer.uint32(26).fork()).join();
    }
    if (message.videoPayload !== undefined) {
      VideoPayload.encode(message.videoPayload, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imagePayload = ImagePayload.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textPayload = TextPayload.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.videoPayload = VideoPayload.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataItem {
    return {
      imagePayload: isSet(object.imagePayload) ? ImagePayload.fromJSON(object.imagePayload) : undefined,
      textPayload: isSet(object.textPayload) ? TextPayload.fromJSON(object.textPayload) : undefined,
      videoPayload: isSet(object.videoPayload) ? VideoPayload.fromJSON(object.videoPayload) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DataItem): unknown {
    const obj: any = {};
    if (message.imagePayload !== undefined) {
      obj.imagePayload = ImagePayload.toJSON(message.imagePayload);
    }
    if (message.textPayload !== undefined) {
      obj.textPayload = TextPayload.toJSON(message.textPayload);
    }
    if (message.videoPayload !== undefined) {
      obj.videoPayload = VideoPayload.toJSON(message.videoPayload);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DataItem>): DataItem {
    return DataItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataItem>): DataItem {
    const message = createBaseDataItem();
    message.imagePayload = (object.imagePayload !== undefined && object.imagePayload !== null)
      ? ImagePayload.fromPartial(object.imagePayload)
      : undefined;
    message.textPayload = (object.textPayload !== undefined && object.textPayload !== null)
      ? TextPayload.fromPartial(object.textPayload)
      : undefined;
    message.videoPayload = (object.videoPayload !== undefined && object.videoPayload !== null)
      ? VideoPayload.fromPartial(object.videoPayload)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAnnotatedDataset(): AnnotatedDataset {
  return {
    name: "",
    displayName: "",
    description: "",
    annotationSource: 0,
    annotationType: 0,
    exampleCount: Long.ZERO,
    completedExampleCount: Long.ZERO,
    labelStats: undefined,
    createTime: undefined,
    metadata: undefined,
    blockingResources: [],
  };
}

export const AnnotatedDataset: MessageFns<AnnotatedDataset> = {
  encode(message: AnnotatedDataset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.annotationSource !== 0) {
      writer.uint32(24).int32(message.annotationSource);
    }
    if (message.annotationType !== 0) {
      writer.uint32(64).int32(message.annotationType);
    }
    if (!message.exampleCount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.exampleCount.toString());
    }
    if (!message.completedExampleCount.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.completedExampleCount.toString());
    }
    if (message.labelStats !== undefined) {
      LabelStats.encode(message.labelStats, writer.uint32(50).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.metadata !== undefined) {
      AnnotatedDatasetMetadata.encode(message.metadata, writer.uint32(82).fork()).join();
    }
    for (const v of message.blockingResources) {
      writer.uint32(90).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotatedDataset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotatedDataset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.annotationSource = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.annotationType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.exampleCount = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.completedExampleCount = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.labelStats = LabelStats.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.metadata = AnnotatedDatasetMetadata.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.blockingResources.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotatedDataset {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      annotationSource: isSet(object.annotationSource) ? annotationSourceFromJSON(object.annotationSource) : 0,
      annotationType: isSet(object.annotationType) ? annotationTypeFromJSON(object.annotationType) : 0,
      exampleCount: isSet(object.exampleCount) ? Long.fromValue(object.exampleCount) : Long.ZERO,
      completedExampleCount: isSet(object.completedExampleCount)
        ? Long.fromValue(object.completedExampleCount)
        : Long.ZERO,
      labelStats: isSet(object.labelStats) ? LabelStats.fromJSON(object.labelStats) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      metadata: isSet(object.metadata) ? AnnotatedDatasetMetadata.fromJSON(object.metadata) : undefined,
      blockingResources: globalThis.Array.isArray(object?.blockingResources)
        ? object.blockingResources.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AnnotatedDataset): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.annotationSource !== 0) {
      obj.annotationSource = annotationSourceToJSON(message.annotationSource);
    }
    if (message.annotationType !== 0) {
      obj.annotationType = annotationTypeToJSON(message.annotationType);
    }
    if (!message.exampleCount.equals(Long.ZERO)) {
      obj.exampleCount = (message.exampleCount || Long.ZERO).toString();
    }
    if (!message.completedExampleCount.equals(Long.ZERO)) {
      obj.completedExampleCount = (message.completedExampleCount || Long.ZERO).toString();
    }
    if (message.labelStats !== undefined) {
      obj.labelStats = LabelStats.toJSON(message.labelStats);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = AnnotatedDatasetMetadata.toJSON(message.metadata);
    }
    if (message.blockingResources?.length) {
      obj.blockingResources = message.blockingResources;
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotatedDataset>): AnnotatedDataset {
    return AnnotatedDataset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotatedDataset>): AnnotatedDataset {
    const message = createBaseAnnotatedDataset();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.annotationSource = object.annotationSource ?? 0;
    message.annotationType = object.annotationType ?? 0;
    message.exampleCount = (object.exampleCount !== undefined && object.exampleCount !== null)
      ? Long.fromValue(object.exampleCount)
      : Long.ZERO;
    message.completedExampleCount =
      (object.completedExampleCount !== undefined && object.completedExampleCount !== null)
        ? Long.fromValue(object.completedExampleCount)
        : Long.ZERO;
    message.labelStats = (object.labelStats !== undefined && object.labelStats !== null)
      ? LabelStats.fromPartial(object.labelStats)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? AnnotatedDatasetMetadata.fromPartial(object.metadata)
      : undefined;
    message.blockingResources = object.blockingResources?.map((e) => e) || [];
    return message;
  },
};

function createBaseLabelStats(): LabelStats {
  return { exampleCount: {} };
}

export const LabelStats: MessageFns<LabelStats> = {
  encode(message: LabelStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.exampleCount).forEach(([key, value]) => {
      LabelStats_ExampleCountEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = LabelStats_ExampleCountEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.exampleCount[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelStats {
    return {
      exampleCount: isObject(object.exampleCount)
        ? Object.entries(object.exampleCount).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: LabelStats): unknown {
    const obj: any = {};
    if (message.exampleCount) {
      const entries = Object.entries(message.exampleCount);
      if (entries.length > 0) {
        obj.exampleCount = {};
        entries.forEach(([k, v]) => {
          obj.exampleCount[k] = v.toString();
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<LabelStats>): LabelStats {
    return LabelStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabelStats>): LabelStats {
    const message = createBaseLabelStats();
    message.exampleCount = Object.entries(object.exampleCount ?? {}).reduce<{ [key: string]: Long }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Long.fromValue(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseLabelStats_ExampleCountEntry(): LabelStats_ExampleCountEntry {
  return { key: "", value: Long.ZERO };
}

export const LabelStats_ExampleCountEntry: MessageFns<LabelStats_ExampleCountEntry> = {
  encode(message: LabelStats_ExampleCountEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelStats_ExampleCountEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelStats_ExampleCountEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelStats_ExampleCountEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: LabelStats_ExampleCountEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<LabelStats_ExampleCountEntry>): LabelStats_ExampleCountEntry {
    return LabelStats_ExampleCountEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabelStats_ExampleCountEntry>): LabelStats_ExampleCountEntry {
    const message = createBaseLabelStats_ExampleCountEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseAnnotatedDatasetMetadata(): AnnotatedDatasetMetadata {
  return {
    imageClassificationConfig: undefined,
    boundingPolyConfig: undefined,
    polylineConfig: undefined,
    segmentationConfig: undefined,
    videoClassificationConfig: undefined,
    objectDetectionConfig: undefined,
    objectTrackingConfig: undefined,
    eventConfig: undefined,
    textClassificationConfig: undefined,
    textEntityExtractionConfig: undefined,
    humanAnnotationConfig: undefined,
  };
}

export const AnnotatedDatasetMetadata: MessageFns<AnnotatedDatasetMetadata> = {
  encode(message: AnnotatedDatasetMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageClassificationConfig !== undefined) {
      ImageClassificationConfig.encode(message.imageClassificationConfig, writer.uint32(18).fork()).join();
    }
    if (message.boundingPolyConfig !== undefined) {
      BoundingPolyConfig.encode(message.boundingPolyConfig, writer.uint32(26).fork()).join();
    }
    if (message.polylineConfig !== undefined) {
      PolylineConfig.encode(message.polylineConfig, writer.uint32(34).fork()).join();
    }
    if (message.segmentationConfig !== undefined) {
      SegmentationConfig.encode(message.segmentationConfig, writer.uint32(42).fork()).join();
    }
    if (message.videoClassificationConfig !== undefined) {
      VideoClassificationConfig.encode(message.videoClassificationConfig, writer.uint32(50).fork()).join();
    }
    if (message.objectDetectionConfig !== undefined) {
      ObjectDetectionConfig.encode(message.objectDetectionConfig, writer.uint32(58).fork()).join();
    }
    if (message.objectTrackingConfig !== undefined) {
      ObjectTrackingConfig.encode(message.objectTrackingConfig, writer.uint32(66).fork()).join();
    }
    if (message.eventConfig !== undefined) {
      EventConfig.encode(message.eventConfig, writer.uint32(74).fork()).join();
    }
    if (message.textClassificationConfig !== undefined) {
      TextClassificationConfig.encode(message.textClassificationConfig, writer.uint32(82).fork()).join();
    }
    if (message.textEntityExtractionConfig !== undefined) {
      TextEntityExtractionConfig.encode(message.textEntityExtractionConfig, writer.uint32(90).fork()).join();
    }
    if (message.humanAnnotationConfig !== undefined) {
      HumanAnnotationConfig.encode(message.humanAnnotationConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotatedDatasetMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotatedDatasetMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imageClassificationConfig = ImageClassificationConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.boundingPolyConfig = BoundingPolyConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.polylineConfig = PolylineConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.segmentationConfig = SegmentationConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.videoClassificationConfig = VideoClassificationConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.objectDetectionConfig = ObjectDetectionConfig.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.objectTrackingConfig = ObjectTrackingConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.eventConfig = EventConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.textClassificationConfig = TextClassificationConfig.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.textEntityExtractionConfig = TextEntityExtractionConfig.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.humanAnnotationConfig = HumanAnnotationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotatedDatasetMetadata {
    return {
      imageClassificationConfig: isSet(object.imageClassificationConfig)
        ? ImageClassificationConfig.fromJSON(object.imageClassificationConfig)
        : undefined,
      boundingPolyConfig: isSet(object.boundingPolyConfig)
        ? BoundingPolyConfig.fromJSON(object.boundingPolyConfig)
        : undefined,
      polylineConfig: isSet(object.polylineConfig) ? PolylineConfig.fromJSON(object.polylineConfig) : undefined,
      segmentationConfig: isSet(object.segmentationConfig)
        ? SegmentationConfig.fromJSON(object.segmentationConfig)
        : undefined,
      videoClassificationConfig: isSet(object.videoClassificationConfig)
        ? VideoClassificationConfig.fromJSON(object.videoClassificationConfig)
        : undefined,
      objectDetectionConfig: isSet(object.objectDetectionConfig)
        ? ObjectDetectionConfig.fromJSON(object.objectDetectionConfig)
        : undefined,
      objectTrackingConfig: isSet(object.objectTrackingConfig)
        ? ObjectTrackingConfig.fromJSON(object.objectTrackingConfig)
        : undefined,
      eventConfig: isSet(object.eventConfig) ? EventConfig.fromJSON(object.eventConfig) : undefined,
      textClassificationConfig: isSet(object.textClassificationConfig)
        ? TextClassificationConfig.fromJSON(object.textClassificationConfig)
        : undefined,
      textEntityExtractionConfig: isSet(object.textEntityExtractionConfig)
        ? TextEntityExtractionConfig.fromJSON(object.textEntityExtractionConfig)
        : undefined,
      humanAnnotationConfig: isSet(object.humanAnnotationConfig)
        ? HumanAnnotationConfig.fromJSON(object.humanAnnotationConfig)
        : undefined,
    };
  },

  toJSON(message: AnnotatedDatasetMetadata): unknown {
    const obj: any = {};
    if (message.imageClassificationConfig !== undefined) {
      obj.imageClassificationConfig = ImageClassificationConfig.toJSON(message.imageClassificationConfig);
    }
    if (message.boundingPolyConfig !== undefined) {
      obj.boundingPolyConfig = BoundingPolyConfig.toJSON(message.boundingPolyConfig);
    }
    if (message.polylineConfig !== undefined) {
      obj.polylineConfig = PolylineConfig.toJSON(message.polylineConfig);
    }
    if (message.segmentationConfig !== undefined) {
      obj.segmentationConfig = SegmentationConfig.toJSON(message.segmentationConfig);
    }
    if (message.videoClassificationConfig !== undefined) {
      obj.videoClassificationConfig = VideoClassificationConfig.toJSON(message.videoClassificationConfig);
    }
    if (message.objectDetectionConfig !== undefined) {
      obj.objectDetectionConfig = ObjectDetectionConfig.toJSON(message.objectDetectionConfig);
    }
    if (message.objectTrackingConfig !== undefined) {
      obj.objectTrackingConfig = ObjectTrackingConfig.toJSON(message.objectTrackingConfig);
    }
    if (message.eventConfig !== undefined) {
      obj.eventConfig = EventConfig.toJSON(message.eventConfig);
    }
    if (message.textClassificationConfig !== undefined) {
      obj.textClassificationConfig = TextClassificationConfig.toJSON(message.textClassificationConfig);
    }
    if (message.textEntityExtractionConfig !== undefined) {
      obj.textEntityExtractionConfig = TextEntityExtractionConfig.toJSON(message.textEntityExtractionConfig);
    }
    if (message.humanAnnotationConfig !== undefined) {
      obj.humanAnnotationConfig = HumanAnnotationConfig.toJSON(message.humanAnnotationConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotatedDatasetMetadata>): AnnotatedDatasetMetadata {
    return AnnotatedDatasetMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotatedDatasetMetadata>): AnnotatedDatasetMetadata {
    const message = createBaseAnnotatedDatasetMetadata();
    message.imageClassificationConfig =
      (object.imageClassificationConfig !== undefined && object.imageClassificationConfig !== null)
        ? ImageClassificationConfig.fromPartial(object.imageClassificationConfig)
        : undefined;
    message.boundingPolyConfig = (object.boundingPolyConfig !== undefined && object.boundingPolyConfig !== null)
      ? BoundingPolyConfig.fromPartial(object.boundingPolyConfig)
      : undefined;
    message.polylineConfig = (object.polylineConfig !== undefined && object.polylineConfig !== null)
      ? PolylineConfig.fromPartial(object.polylineConfig)
      : undefined;
    message.segmentationConfig = (object.segmentationConfig !== undefined && object.segmentationConfig !== null)
      ? SegmentationConfig.fromPartial(object.segmentationConfig)
      : undefined;
    message.videoClassificationConfig =
      (object.videoClassificationConfig !== undefined && object.videoClassificationConfig !== null)
        ? VideoClassificationConfig.fromPartial(object.videoClassificationConfig)
        : undefined;
    message.objectDetectionConfig =
      (object.objectDetectionConfig !== undefined && object.objectDetectionConfig !== null)
        ? ObjectDetectionConfig.fromPartial(object.objectDetectionConfig)
        : undefined;
    message.objectTrackingConfig = (object.objectTrackingConfig !== undefined && object.objectTrackingConfig !== null)
      ? ObjectTrackingConfig.fromPartial(object.objectTrackingConfig)
      : undefined;
    message.eventConfig = (object.eventConfig !== undefined && object.eventConfig !== null)
      ? EventConfig.fromPartial(object.eventConfig)
      : undefined;
    message.textClassificationConfig =
      (object.textClassificationConfig !== undefined && object.textClassificationConfig !== null)
        ? TextClassificationConfig.fromPartial(object.textClassificationConfig)
        : undefined;
    message.textEntityExtractionConfig =
      (object.textEntityExtractionConfig !== undefined && object.textEntityExtractionConfig !== null)
        ? TextEntityExtractionConfig.fromPartial(object.textEntityExtractionConfig)
        : undefined;
    message.humanAnnotationConfig =
      (object.humanAnnotationConfig !== undefined && object.humanAnnotationConfig !== null)
        ? HumanAnnotationConfig.fromPartial(object.humanAnnotationConfig)
        : undefined;
    return message;
  },
};

function createBaseExample(): Example {
  return { imagePayload: undefined, textPayload: undefined, videoPayload: undefined, name: "", annotations: [] };
}

export const Example: MessageFns<Example> = {
  encode(message: Example, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imagePayload !== undefined) {
      ImagePayload.encode(message.imagePayload, writer.uint32(18).fork()).join();
    }
    if (message.textPayload !== undefined) {
      TextPayload.encode(message.textPayload, writer.uint32(50).fork()).join();
    }
    if (message.videoPayload !== undefined) {
      VideoPayload.encode(message.videoPayload, writer.uint32(58).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Example {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imagePayload = ImagePayload.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.textPayload = TextPayload.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.videoPayload = VideoPayload.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Example {
    return {
      imagePayload: isSet(object.imagePayload) ? ImagePayload.fromJSON(object.imagePayload) : undefined,
      textPayload: isSet(object.textPayload) ? TextPayload.fromJSON(object.textPayload) : undefined,
      videoPayload: isSet(object.videoPayload) ? VideoPayload.fromJSON(object.videoPayload) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Example): unknown {
    const obj: any = {};
    if (message.imagePayload !== undefined) {
      obj.imagePayload = ImagePayload.toJSON(message.imagePayload);
    }
    if (message.textPayload !== undefined) {
      obj.textPayload = TextPayload.toJSON(message.textPayload);
    }
    if (message.videoPayload !== undefined) {
      obj.videoPayload = VideoPayload.toJSON(message.videoPayload);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => Annotation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Example>): Example {
    return Example.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Example>): Example {
    const message = createBaseExample();
    message.imagePayload = (object.imagePayload !== undefined && object.imagePayload !== null)
      ? ImagePayload.fromPartial(object.imagePayload)
      : undefined;
    message.textPayload = (object.textPayload !== undefined && object.textPayload !== null)
      ? TextPayload.fromPartial(object.textPayload)
      : undefined;
    message.videoPayload = (object.videoPayload !== undefined && object.videoPayload !== null)
      ? VideoPayload.fromPartial(object.videoPayload)
      : undefined;
    message.name = object.name ?? "";
    message.annotations = object.annotations?.map((e) => Annotation.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
