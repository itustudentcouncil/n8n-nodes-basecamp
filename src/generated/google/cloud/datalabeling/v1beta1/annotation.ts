// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/datalabeling/v1beta1/annotation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { AnnotationSpec } from "./annotation_spec_set.js";

export const protobufPackage = "google.cloud.datalabeling.v1beta1";

/**
 * Specifies where the annotation comes from (whether it was provided by a
 * human labeler or a different source).
 */
export enum AnnotationSource {
  ANNOTATION_SOURCE_UNSPECIFIED = 0,
  /** OPERATOR - Answer is provided by a human contributor. */
  OPERATOR = 3,
  UNRECOGNIZED = -1,
}

export function annotationSourceFromJSON(object: any): AnnotationSource {
  switch (object) {
    case 0:
    case "ANNOTATION_SOURCE_UNSPECIFIED":
      return AnnotationSource.ANNOTATION_SOURCE_UNSPECIFIED;
    case 3:
    case "OPERATOR":
      return AnnotationSource.OPERATOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnnotationSource.UNRECOGNIZED;
  }
}

export function annotationSourceToJSON(object: AnnotationSource): string {
  switch (object) {
    case AnnotationSource.ANNOTATION_SOURCE_UNSPECIFIED:
      return "ANNOTATION_SOURCE_UNSPECIFIED";
    case AnnotationSource.OPERATOR:
      return "OPERATOR";
    case AnnotationSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AnnotationSentiment {
  ANNOTATION_SENTIMENT_UNSPECIFIED = 0,
  /** NEGATIVE - This annotation describes negatively about the data. */
  NEGATIVE = 1,
  /** POSITIVE - This label describes positively about the data. */
  POSITIVE = 2,
  UNRECOGNIZED = -1,
}

export function annotationSentimentFromJSON(object: any): AnnotationSentiment {
  switch (object) {
    case 0:
    case "ANNOTATION_SENTIMENT_UNSPECIFIED":
      return AnnotationSentiment.ANNOTATION_SENTIMENT_UNSPECIFIED;
    case 1:
    case "NEGATIVE":
      return AnnotationSentiment.NEGATIVE;
    case 2:
    case "POSITIVE":
      return AnnotationSentiment.POSITIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnnotationSentiment.UNRECOGNIZED;
  }
}

export function annotationSentimentToJSON(object: AnnotationSentiment): string {
  switch (object) {
    case AnnotationSentiment.ANNOTATION_SENTIMENT_UNSPECIFIED:
      return "ANNOTATION_SENTIMENT_UNSPECIFIED";
    case AnnotationSentiment.NEGATIVE:
      return "NEGATIVE";
    case AnnotationSentiment.POSITIVE:
      return "POSITIVE";
    case AnnotationSentiment.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AnnotationType {
  ANNOTATION_TYPE_UNSPECIFIED = 0,
  /** IMAGE_CLASSIFICATION_ANNOTATION - Classification annotations in an image. Allowed for continuous evaluation. */
  IMAGE_CLASSIFICATION_ANNOTATION = 1,
  /**
   * IMAGE_BOUNDING_BOX_ANNOTATION - Bounding box annotations in an image. A form of image object detection.
   * Allowed for continuous evaluation.
   */
  IMAGE_BOUNDING_BOX_ANNOTATION = 2,
  /**
   * IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION - Oriented bounding box. The box does not have to be parallel to horizontal
   * line.
   */
  IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION = 13,
  /** IMAGE_BOUNDING_POLY_ANNOTATION - Bounding poly annotations in an image. */
  IMAGE_BOUNDING_POLY_ANNOTATION = 10,
  /** IMAGE_POLYLINE_ANNOTATION - Polyline annotations in an image. */
  IMAGE_POLYLINE_ANNOTATION = 11,
  /** IMAGE_SEGMENTATION_ANNOTATION - Segmentation annotations in an image. */
  IMAGE_SEGMENTATION_ANNOTATION = 12,
  /** VIDEO_SHOTS_CLASSIFICATION_ANNOTATION - Classification annotations in video shots. */
  VIDEO_SHOTS_CLASSIFICATION_ANNOTATION = 3,
  /** VIDEO_OBJECT_TRACKING_ANNOTATION - Video object tracking annotation. */
  VIDEO_OBJECT_TRACKING_ANNOTATION = 4,
  /** VIDEO_OBJECT_DETECTION_ANNOTATION - Video object detection annotation. */
  VIDEO_OBJECT_DETECTION_ANNOTATION = 5,
  /** VIDEO_EVENT_ANNOTATION - Video event annotation. */
  VIDEO_EVENT_ANNOTATION = 6,
  /** TEXT_CLASSIFICATION_ANNOTATION - Classification for text. Allowed for continuous evaluation. */
  TEXT_CLASSIFICATION_ANNOTATION = 8,
  /** TEXT_ENTITY_EXTRACTION_ANNOTATION - Entity extraction for text. */
  TEXT_ENTITY_EXTRACTION_ANNOTATION = 9,
  /** GENERAL_CLASSIFICATION_ANNOTATION - General classification. Allowed for continuous evaluation. */
  GENERAL_CLASSIFICATION_ANNOTATION = 14,
  UNRECOGNIZED = -1,
}

export function annotationTypeFromJSON(object: any): AnnotationType {
  switch (object) {
    case 0:
    case "ANNOTATION_TYPE_UNSPECIFIED":
      return AnnotationType.ANNOTATION_TYPE_UNSPECIFIED;
    case 1:
    case "IMAGE_CLASSIFICATION_ANNOTATION":
      return AnnotationType.IMAGE_CLASSIFICATION_ANNOTATION;
    case 2:
    case "IMAGE_BOUNDING_BOX_ANNOTATION":
      return AnnotationType.IMAGE_BOUNDING_BOX_ANNOTATION;
    case 13:
    case "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION":
      return AnnotationType.IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION;
    case 10:
    case "IMAGE_BOUNDING_POLY_ANNOTATION":
      return AnnotationType.IMAGE_BOUNDING_POLY_ANNOTATION;
    case 11:
    case "IMAGE_POLYLINE_ANNOTATION":
      return AnnotationType.IMAGE_POLYLINE_ANNOTATION;
    case 12:
    case "IMAGE_SEGMENTATION_ANNOTATION":
      return AnnotationType.IMAGE_SEGMENTATION_ANNOTATION;
    case 3:
    case "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION":
      return AnnotationType.VIDEO_SHOTS_CLASSIFICATION_ANNOTATION;
    case 4:
    case "VIDEO_OBJECT_TRACKING_ANNOTATION":
      return AnnotationType.VIDEO_OBJECT_TRACKING_ANNOTATION;
    case 5:
    case "VIDEO_OBJECT_DETECTION_ANNOTATION":
      return AnnotationType.VIDEO_OBJECT_DETECTION_ANNOTATION;
    case 6:
    case "VIDEO_EVENT_ANNOTATION":
      return AnnotationType.VIDEO_EVENT_ANNOTATION;
    case 8:
    case "TEXT_CLASSIFICATION_ANNOTATION":
      return AnnotationType.TEXT_CLASSIFICATION_ANNOTATION;
    case 9:
    case "TEXT_ENTITY_EXTRACTION_ANNOTATION":
      return AnnotationType.TEXT_ENTITY_EXTRACTION_ANNOTATION;
    case 14:
    case "GENERAL_CLASSIFICATION_ANNOTATION":
      return AnnotationType.GENERAL_CLASSIFICATION_ANNOTATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnnotationType.UNRECOGNIZED;
  }
}

export function annotationTypeToJSON(object: AnnotationType): string {
  switch (object) {
    case AnnotationType.ANNOTATION_TYPE_UNSPECIFIED:
      return "ANNOTATION_TYPE_UNSPECIFIED";
    case AnnotationType.IMAGE_CLASSIFICATION_ANNOTATION:
      return "IMAGE_CLASSIFICATION_ANNOTATION";
    case AnnotationType.IMAGE_BOUNDING_BOX_ANNOTATION:
      return "IMAGE_BOUNDING_BOX_ANNOTATION";
    case AnnotationType.IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION:
      return "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION";
    case AnnotationType.IMAGE_BOUNDING_POLY_ANNOTATION:
      return "IMAGE_BOUNDING_POLY_ANNOTATION";
    case AnnotationType.IMAGE_POLYLINE_ANNOTATION:
      return "IMAGE_POLYLINE_ANNOTATION";
    case AnnotationType.IMAGE_SEGMENTATION_ANNOTATION:
      return "IMAGE_SEGMENTATION_ANNOTATION";
    case AnnotationType.VIDEO_SHOTS_CLASSIFICATION_ANNOTATION:
      return "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION";
    case AnnotationType.VIDEO_OBJECT_TRACKING_ANNOTATION:
      return "VIDEO_OBJECT_TRACKING_ANNOTATION";
    case AnnotationType.VIDEO_OBJECT_DETECTION_ANNOTATION:
      return "VIDEO_OBJECT_DETECTION_ANNOTATION";
    case AnnotationType.VIDEO_EVENT_ANNOTATION:
      return "VIDEO_EVENT_ANNOTATION";
    case AnnotationType.TEXT_CLASSIFICATION_ANNOTATION:
      return "TEXT_CLASSIFICATION_ANNOTATION";
    case AnnotationType.TEXT_ENTITY_EXTRACTION_ANNOTATION:
      return "TEXT_ENTITY_EXTRACTION_ANNOTATION";
    case AnnotationType.GENERAL_CLASSIFICATION_ANNOTATION:
      return "GENERAL_CLASSIFICATION_ANNOTATION";
    case AnnotationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Annotation for Example. Each example may have one or more annotations. For
 * example in image classification problem, each image might have one or more
 * labels. We call labels binded with this image an Annotation.
 */
export interface Annotation {
  /**
   * Output only. Unique name of this annotation, format is:
   *
   * projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/{annotated_dataset}/examples/{example_id}/annotations/{annotation_id}
   */
  name: string;
  /** Output only. The source of the annotation. */
  annotationSource: AnnotationSource;
  /**
   * Output only. This is the actual annotation value, e.g classification,
   * bounding box values are stored here.
   */
  annotationValue:
    | AnnotationValue
    | undefined;
  /**
   * Output only. Annotation metadata, including information like votes
   * for labels.
   */
  annotationMetadata:
    | AnnotationMetadata
    | undefined;
  /** Output only. Sentiment for this annotation. */
  annotationSentiment: AnnotationSentiment;
}

/** Annotation value for an example. */
export interface AnnotationValue {
  /** Annotation value for image classification case. */
  imageClassificationAnnotation?:
    | ImageClassificationAnnotation
    | undefined;
  /**
   * Annotation value for image bounding box, oriented bounding box
   * and polygon cases.
   */
  imageBoundingPolyAnnotation?:
    | ImageBoundingPolyAnnotation
    | undefined;
  /**
   * Annotation value for image polyline cases.
   * Polyline here is different from BoundingPoly. It is formed by
   * line segments connected to each other but not closed form(Bounding Poly).
   * The line segments can cross each other.
   */
  imagePolylineAnnotation?:
    | ImagePolylineAnnotation
    | undefined;
  /** Annotation value for image segmentation. */
  imageSegmentationAnnotation?:
    | ImageSegmentationAnnotation
    | undefined;
  /** Annotation value for text classification case. */
  textClassificationAnnotation?:
    | TextClassificationAnnotation
    | undefined;
  /** Annotation value for text entity extraction case. */
  textEntityExtractionAnnotation?:
    | TextEntityExtractionAnnotation
    | undefined;
  /** Annotation value for video classification case. */
  videoClassificationAnnotation?:
    | VideoClassificationAnnotation
    | undefined;
  /** Annotation value for video object detection and tracking case. */
  videoObjectTrackingAnnotation?:
    | VideoObjectTrackingAnnotation
    | undefined;
  /** Annotation value for video event case. */
  videoEventAnnotation?: VideoEventAnnotation | undefined;
}

/** Image classification annotation definition. */
export interface ImageClassificationAnnotation {
  /** Label of image. */
  annotationSpec: AnnotationSpec | undefined;
}

/**
 * A vertex represents a 2D point in the image.
 * NOTE: the vertex coordinates are in the same scale as the original image.
 */
export interface Vertex {
  /** X coordinate. */
  x: number;
  /** Y coordinate. */
  y: number;
}

/**
 * A vertex represents a 2D point in the image.
 * NOTE: the normalized vertex coordinates are relative to the original image
 * and range from 0 to 1.
 */
export interface NormalizedVertex {
  /** X coordinate. */
  x: number;
  /** Y coordinate. */
  y: number;
}

/** A bounding polygon in the image. */
export interface BoundingPoly {
  /** The bounding polygon vertices. */
  vertices: Vertex[];
}

/** Normalized bounding polygon. */
export interface NormalizedBoundingPoly {
  /** The bounding polygon normalized vertices. */
  normalizedVertices: NormalizedVertex[];
}

/**
 * Image bounding poly annotation. It represents a polygon including
 * bounding box in the image.
 */
export interface ImageBoundingPolyAnnotation {
  boundingPoly?: BoundingPoly | undefined;
  normalizedBoundingPoly?:
    | NormalizedBoundingPoly
    | undefined;
  /** Label of object in this bounding polygon. */
  annotationSpec: AnnotationSpec | undefined;
}

/** A line with multiple line segments. */
export interface Polyline {
  /** The polyline vertices. */
  vertices: Vertex[];
}

/** Normalized polyline. */
export interface NormalizedPolyline {
  /** The normalized polyline vertices. */
  normalizedVertices: NormalizedVertex[];
}

/** A polyline for the image annotation. */
export interface ImagePolylineAnnotation {
  polyline?: Polyline | undefined;
  normalizedPolyline?:
    | NormalizedPolyline
    | undefined;
  /** Label of this polyline. */
  annotationSpec: AnnotationSpec | undefined;
}

/** Image segmentation annotation. */
export interface ImageSegmentationAnnotation {
  /**
   * The mapping between rgb color and annotation spec. The key is the rgb
   * color represented in format of rgb(0, 0, 0). The value is the
   * AnnotationSpec.
   */
  annotationColors: { [key: string]: AnnotationSpec };
  /** Image format. */
  mimeType: string;
  /** A byte string of a full image's color map. */
  imageBytes: Buffer;
}

export interface ImageSegmentationAnnotation_AnnotationColorsEntry {
  key: string;
  value: AnnotationSpec | undefined;
}

/** Text classification annotation. */
export interface TextClassificationAnnotation {
  /** Label of the text. */
  annotationSpec: AnnotationSpec | undefined;
}

/** Text entity extraction annotation. */
export interface TextEntityExtractionAnnotation {
  /** Label of the text entities. */
  annotationSpec:
    | AnnotationSpec
    | undefined;
  /** Position of the entity. */
  sequentialSegment: SequentialSegment | undefined;
}

/** Start and end position in a sequence (e.g. text segment). */
export interface SequentialSegment {
  /** Start position (inclusive). */
  start: number;
  /** End position (exclusive). */
  end: number;
}

/** A time period inside of an example that has a time dimension (e.g. video). */
export interface TimeSegment {
  /**
   * Start of the time segment (inclusive), represented as the duration since
   * the example start.
   */
  startTimeOffset:
    | Duration
    | undefined;
  /**
   * End of the time segment (exclusive), represented as the duration since the
   * example start.
   */
  endTimeOffset: Duration | undefined;
}

/** Video classification annotation. */
export interface VideoClassificationAnnotation {
  /** The time segment of the video to which the annotation applies. */
  timeSegment:
    | TimeSegment
    | undefined;
  /** Label of the segment specified by time_segment. */
  annotationSpec: AnnotationSpec | undefined;
}

/** Video frame level annotation for object detection and tracking. */
export interface ObjectTrackingFrame {
  boundingPoly?: BoundingPoly | undefined;
  normalizedBoundingPoly?:
    | NormalizedBoundingPoly
    | undefined;
  /** The time offset of this frame relative to the beginning of the video. */
  timeOffset: Duration | undefined;
}

/** Video object tracking annotation. */
export interface VideoObjectTrackingAnnotation {
  /** Label of the object tracked in this annotation. */
  annotationSpec:
    | AnnotationSpec
    | undefined;
  /** The time segment of the video to which object tracking applies. */
  timeSegment:
    | TimeSegment
    | undefined;
  /** The list of frames where this object track appears. */
  objectTrackingFrames: ObjectTrackingFrame[];
}

/** Video event annotation. */
export interface VideoEventAnnotation {
  /** Label of the event in this annotation. */
  annotationSpec:
    | AnnotationSpec
    | undefined;
  /** The time segment of the video to which the annotation applies. */
  timeSegment: TimeSegment | undefined;
}

/** Additional information associated with the annotation. */
export interface AnnotationMetadata {
  /** Metadata related to human labeling. */
  operatorMetadata: OperatorMetadata | undefined;
}

/** General information useful for labels coming from contributors. */
export interface OperatorMetadata {
  /**
   * Confidence score corresponding to a label. For examle, if 3 contributors
   * have answered the question and 2 of them agree on the final label, the
   * confidence score will be 0.67 (2/3).
   */
  score: number;
  /** The total number of contributors that answer this question. */
  totalVotes: number;
  /** The total number of contributors that choose this label. */
  labelVotes: number;
  /** Comments from contributors. */
  comments: string[];
}

function createBaseAnnotation(): Annotation {
  return {
    name: "",
    annotationSource: 0,
    annotationValue: undefined,
    annotationMetadata: undefined,
    annotationSentiment: 0,
  };
}

export const Annotation: MessageFns<Annotation> = {
  encode(message: Annotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.annotationSource !== 0) {
      writer.uint32(16).int32(message.annotationSource);
    }
    if (message.annotationValue !== undefined) {
      AnnotationValue.encode(message.annotationValue, writer.uint32(26).fork()).join();
    }
    if (message.annotationMetadata !== undefined) {
      AnnotationMetadata.encode(message.annotationMetadata, writer.uint32(34).fork()).join();
    }
    if (message.annotationSentiment !== 0) {
      writer.uint32(48).int32(message.annotationSentiment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Annotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.annotationSource = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.annotationValue = AnnotationValue.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.annotationMetadata = AnnotationMetadata.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.annotationSentiment = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Annotation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      annotationSource: isSet(object.annotationSource) ? annotationSourceFromJSON(object.annotationSource) : 0,
      annotationValue: isSet(object.annotationValue) ? AnnotationValue.fromJSON(object.annotationValue) : undefined,
      annotationMetadata: isSet(object.annotationMetadata)
        ? AnnotationMetadata.fromJSON(object.annotationMetadata)
        : undefined,
      annotationSentiment: isSet(object.annotationSentiment)
        ? annotationSentimentFromJSON(object.annotationSentiment)
        : 0,
    };
  },

  toJSON(message: Annotation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.annotationSource !== 0) {
      obj.annotationSource = annotationSourceToJSON(message.annotationSource);
    }
    if (message.annotationValue !== undefined) {
      obj.annotationValue = AnnotationValue.toJSON(message.annotationValue);
    }
    if (message.annotationMetadata !== undefined) {
      obj.annotationMetadata = AnnotationMetadata.toJSON(message.annotationMetadata);
    }
    if (message.annotationSentiment !== 0) {
      obj.annotationSentiment = annotationSentimentToJSON(message.annotationSentiment);
    }
    return obj;
  },

  create(base?: DeepPartial<Annotation>): Annotation {
    return Annotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Annotation>): Annotation {
    const message = createBaseAnnotation();
    message.name = object.name ?? "";
    message.annotationSource = object.annotationSource ?? 0;
    message.annotationValue = (object.annotationValue !== undefined && object.annotationValue !== null)
      ? AnnotationValue.fromPartial(object.annotationValue)
      : undefined;
    message.annotationMetadata = (object.annotationMetadata !== undefined && object.annotationMetadata !== null)
      ? AnnotationMetadata.fromPartial(object.annotationMetadata)
      : undefined;
    message.annotationSentiment = object.annotationSentiment ?? 0;
    return message;
  },
};

function createBaseAnnotationValue(): AnnotationValue {
  return {
    imageClassificationAnnotation: undefined,
    imageBoundingPolyAnnotation: undefined,
    imagePolylineAnnotation: undefined,
    imageSegmentationAnnotation: undefined,
    textClassificationAnnotation: undefined,
    textEntityExtractionAnnotation: undefined,
    videoClassificationAnnotation: undefined,
    videoObjectTrackingAnnotation: undefined,
    videoEventAnnotation: undefined,
  };
}

export const AnnotationValue: MessageFns<AnnotationValue> = {
  encode(message: AnnotationValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageClassificationAnnotation !== undefined) {
      ImageClassificationAnnotation.encode(message.imageClassificationAnnotation, writer.uint32(10).fork()).join();
    }
    if (message.imageBoundingPolyAnnotation !== undefined) {
      ImageBoundingPolyAnnotation.encode(message.imageBoundingPolyAnnotation, writer.uint32(18).fork()).join();
    }
    if (message.imagePolylineAnnotation !== undefined) {
      ImagePolylineAnnotation.encode(message.imagePolylineAnnotation, writer.uint32(66).fork()).join();
    }
    if (message.imageSegmentationAnnotation !== undefined) {
      ImageSegmentationAnnotation.encode(message.imageSegmentationAnnotation, writer.uint32(74).fork()).join();
    }
    if (message.textClassificationAnnotation !== undefined) {
      TextClassificationAnnotation.encode(message.textClassificationAnnotation, writer.uint32(26).fork()).join();
    }
    if (message.textEntityExtractionAnnotation !== undefined) {
      TextEntityExtractionAnnotation.encode(message.textEntityExtractionAnnotation, writer.uint32(82).fork()).join();
    }
    if (message.videoClassificationAnnotation !== undefined) {
      VideoClassificationAnnotation.encode(message.videoClassificationAnnotation, writer.uint32(34).fork()).join();
    }
    if (message.videoObjectTrackingAnnotation !== undefined) {
      VideoObjectTrackingAnnotation.encode(message.videoObjectTrackingAnnotation, writer.uint32(42).fork()).join();
    }
    if (message.videoEventAnnotation !== undefined) {
      VideoEventAnnotation.encode(message.videoEventAnnotation, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imageClassificationAnnotation = ImageClassificationAnnotation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imageBoundingPolyAnnotation = ImageBoundingPolyAnnotation.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.imagePolylineAnnotation = ImagePolylineAnnotation.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.imageSegmentationAnnotation = ImageSegmentationAnnotation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textClassificationAnnotation = TextClassificationAnnotation.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.textEntityExtractionAnnotation = TextEntityExtractionAnnotation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.videoClassificationAnnotation = VideoClassificationAnnotation.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.videoObjectTrackingAnnotation = VideoObjectTrackingAnnotation.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.videoEventAnnotation = VideoEventAnnotation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationValue {
    return {
      imageClassificationAnnotation: isSet(object.imageClassificationAnnotation)
        ? ImageClassificationAnnotation.fromJSON(object.imageClassificationAnnotation)
        : undefined,
      imageBoundingPolyAnnotation: isSet(object.imageBoundingPolyAnnotation)
        ? ImageBoundingPolyAnnotation.fromJSON(object.imageBoundingPolyAnnotation)
        : undefined,
      imagePolylineAnnotation: isSet(object.imagePolylineAnnotation)
        ? ImagePolylineAnnotation.fromJSON(object.imagePolylineAnnotation)
        : undefined,
      imageSegmentationAnnotation: isSet(object.imageSegmentationAnnotation)
        ? ImageSegmentationAnnotation.fromJSON(object.imageSegmentationAnnotation)
        : undefined,
      textClassificationAnnotation: isSet(object.textClassificationAnnotation)
        ? TextClassificationAnnotation.fromJSON(object.textClassificationAnnotation)
        : undefined,
      textEntityExtractionAnnotation: isSet(object.textEntityExtractionAnnotation)
        ? TextEntityExtractionAnnotation.fromJSON(object.textEntityExtractionAnnotation)
        : undefined,
      videoClassificationAnnotation: isSet(object.videoClassificationAnnotation)
        ? VideoClassificationAnnotation.fromJSON(object.videoClassificationAnnotation)
        : undefined,
      videoObjectTrackingAnnotation: isSet(object.videoObjectTrackingAnnotation)
        ? VideoObjectTrackingAnnotation.fromJSON(object.videoObjectTrackingAnnotation)
        : undefined,
      videoEventAnnotation: isSet(object.videoEventAnnotation)
        ? VideoEventAnnotation.fromJSON(object.videoEventAnnotation)
        : undefined,
    };
  },

  toJSON(message: AnnotationValue): unknown {
    const obj: any = {};
    if (message.imageClassificationAnnotation !== undefined) {
      obj.imageClassificationAnnotation = ImageClassificationAnnotation.toJSON(message.imageClassificationAnnotation);
    }
    if (message.imageBoundingPolyAnnotation !== undefined) {
      obj.imageBoundingPolyAnnotation = ImageBoundingPolyAnnotation.toJSON(message.imageBoundingPolyAnnotation);
    }
    if (message.imagePolylineAnnotation !== undefined) {
      obj.imagePolylineAnnotation = ImagePolylineAnnotation.toJSON(message.imagePolylineAnnotation);
    }
    if (message.imageSegmentationAnnotation !== undefined) {
      obj.imageSegmentationAnnotation = ImageSegmentationAnnotation.toJSON(message.imageSegmentationAnnotation);
    }
    if (message.textClassificationAnnotation !== undefined) {
      obj.textClassificationAnnotation = TextClassificationAnnotation.toJSON(message.textClassificationAnnotation);
    }
    if (message.textEntityExtractionAnnotation !== undefined) {
      obj.textEntityExtractionAnnotation = TextEntityExtractionAnnotation.toJSON(
        message.textEntityExtractionAnnotation,
      );
    }
    if (message.videoClassificationAnnotation !== undefined) {
      obj.videoClassificationAnnotation = VideoClassificationAnnotation.toJSON(message.videoClassificationAnnotation);
    }
    if (message.videoObjectTrackingAnnotation !== undefined) {
      obj.videoObjectTrackingAnnotation = VideoObjectTrackingAnnotation.toJSON(message.videoObjectTrackingAnnotation);
    }
    if (message.videoEventAnnotation !== undefined) {
      obj.videoEventAnnotation = VideoEventAnnotation.toJSON(message.videoEventAnnotation);
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotationValue>): AnnotationValue {
    return AnnotationValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotationValue>): AnnotationValue {
    const message = createBaseAnnotationValue();
    message.imageClassificationAnnotation =
      (object.imageClassificationAnnotation !== undefined && object.imageClassificationAnnotation !== null)
        ? ImageClassificationAnnotation.fromPartial(object.imageClassificationAnnotation)
        : undefined;
    message.imageBoundingPolyAnnotation =
      (object.imageBoundingPolyAnnotation !== undefined && object.imageBoundingPolyAnnotation !== null)
        ? ImageBoundingPolyAnnotation.fromPartial(object.imageBoundingPolyAnnotation)
        : undefined;
    message.imagePolylineAnnotation =
      (object.imagePolylineAnnotation !== undefined && object.imagePolylineAnnotation !== null)
        ? ImagePolylineAnnotation.fromPartial(object.imagePolylineAnnotation)
        : undefined;
    message.imageSegmentationAnnotation =
      (object.imageSegmentationAnnotation !== undefined && object.imageSegmentationAnnotation !== null)
        ? ImageSegmentationAnnotation.fromPartial(object.imageSegmentationAnnotation)
        : undefined;
    message.textClassificationAnnotation =
      (object.textClassificationAnnotation !== undefined && object.textClassificationAnnotation !== null)
        ? TextClassificationAnnotation.fromPartial(object.textClassificationAnnotation)
        : undefined;
    message.textEntityExtractionAnnotation =
      (object.textEntityExtractionAnnotation !== undefined && object.textEntityExtractionAnnotation !== null)
        ? TextEntityExtractionAnnotation.fromPartial(object.textEntityExtractionAnnotation)
        : undefined;
    message.videoClassificationAnnotation =
      (object.videoClassificationAnnotation !== undefined && object.videoClassificationAnnotation !== null)
        ? VideoClassificationAnnotation.fromPartial(object.videoClassificationAnnotation)
        : undefined;
    message.videoObjectTrackingAnnotation =
      (object.videoObjectTrackingAnnotation !== undefined && object.videoObjectTrackingAnnotation !== null)
        ? VideoObjectTrackingAnnotation.fromPartial(object.videoObjectTrackingAnnotation)
        : undefined;
    message.videoEventAnnotation = (object.videoEventAnnotation !== undefined && object.videoEventAnnotation !== null)
      ? VideoEventAnnotation.fromPartial(object.videoEventAnnotation)
      : undefined;
    return message;
  },
};

function createBaseImageClassificationAnnotation(): ImageClassificationAnnotation {
  return { annotationSpec: undefined };
}

export const ImageClassificationAnnotation: MessageFns<ImageClassificationAnnotation> = {
  encode(message: ImageClassificationAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationSpec !== undefined) {
      AnnotationSpec.encode(message.annotationSpec, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageClassificationAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageClassificationAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSpec = AnnotationSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageClassificationAnnotation {
    return {
      annotationSpec: isSet(object.annotationSpec) ? AnnotationSpec.fromJSON(object.annotationSpec) : undefined,
    };
  },

  toJSON(message: ImageClassificationAnnotation): unknown {
    const obj: any = {};
    if (message.annotationSpec !== undefined) {
      obj.annotationSpec = AnnotationSpec.toJSON(message.annotationSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<ImageClassificationAnnotation>): ImageClassificationAnnotation {
    return ImageClassificationAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImageClassificationAnnotation>): ImageClassificationAnnotation {
    const message = createBaseImageClassificationAnnotation();
    message.annotationSpec = (object.annotationSpec !== undefined && object.annotationSpec !== null)
      ? AnnotationSpec.fromPartial(object.annotationSpec)
      : undefined;
    return message;
  },
};

function createBaseVertex(): Vertex {
  return { x: 0, y: 0 };
}

export const Vertex: MessageFns<Vertex> = {
  encode(message: Vertex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(8).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).int32(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vertex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.x = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.y = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vertex {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: Vertex): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create(base?: DeepPartial<Vertex>): Vertex {
    return Vertex.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Vertex>): Vertex {
    const message = createBaseVertex();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseNormalizedVertex(): NormalizedVertex {
  return { x: 0, y: 0 };
}

export const NormalizedVertex: MessageFns<NormalizedVertex> = {
  encode(message: NormalizedVertex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NormalizedVertex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNormalizedVertex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NormalizedVertex {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: NormalizedVertex): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create(base?: DeepPartial<NormalizedVertex>): NormalizedVertex {
    return NormalizedVertex.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NormalizedVertex>): NormalizedVertex {
    const message = createBaseNormalizedVertex();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseBoundingPoly(): BoundingPoly {
  return { vertices: [] };
}

export const BoundingPoly: MessageFns<BoundingPoly> = {
  encode(message: BoundingPoly, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.vertices) {
      Vertex.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoundingPoly {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoundingPoly();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vertices.push(Vertex.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoundingPoly {
    return {
      vertices: globalThis.Array.isArray(object?.vertices) ? object.vertices.map((e: any) => Vertex.fromJSON(e)) : [],
    };
  },

  toJSON(message: BoundingPoly): unknown {
    const obj: any = {};
    if (message.vertices?.length) {
      obj.vertices = message.vertices.map((e) => Vertex.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BoundingPoly>): BoundingPoly {
    return BoundingPoly.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BoundingPoly>): BoundingPoly {
    const message = createBaseBoundingPoly();
    message.vertices = object.vertices?.map((e) => Vertex.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNormalizedBoundingPoly(): NormalizedBoundingPoly {
  return { normalizedVertices: [] };
}

export const NormalizedBoundingPoly: MessageFns<NormalizedBoundingPoly> = {
  encode(message: NormalizedBoundingPoly, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.normalizedVertices) {
      NormalizedVertex.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NormalizedBoundingPoly {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNormalizedBoundingPoly();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.normalizedVertices.push(NormalizedVertex.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NormalizedBoundingPoly {
    return {
      normalizedVertices: globalThis.Array.isArray(object?.normalizedVertices)
        ? object.normalizedVertices.map((e: any) => NormalizedVertex.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NormalizedBoundingPoly): unknown {
    const obj: any = {};
    if (message.normalizedVertices?.length) {
      obj.normalizedVertices = message.normalizedVertices.map((e) => NormalizedVertex.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NormalizedBoundingPoly>): NormalizedBoundingPoly {
    return NormalizedBoundingPoly.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NormalizedBoundingPoly>): NormalizedBoundingPoly {
    const message = createBaseNormalizedBoundingPoly();
    message.normalizedVertices = object.normalizedVertices?.map((e) => NormalizedVertex.fromPartial(e)) || [];
    return message;
  },
};

function createBaseImageBoundingPolyAnnotation(): ImageBoundingPolyAnnotation {
  return { boundingPoly: undefined, normalizedBoundingPoly: undefined, annotationSpec: undefined };
}

export const ImageBoundingPolyAnnotation: MessageFns<ImageBoundingPolyAnnotation> = {
  encode(message: ImageBoundingPolyAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.boundingPoly !== undefined) {
      BoundingPoly.encode(message.boundingPoly, writer.uint32(18).fork()).join();
    }
    if (message.normalizedBoundingPoly !== undefined) {
      NormalizedBoundingPoly.encode(message.normalizedBoundingPoly, writer.uint32(26).fork()).join();
    }
    if (message.annotationSpec !== undefined) {
      AnnotationSpec.encode(message.annotationSpec, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageBoundingPolyAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageBoundingPolyAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.boundingPoly = BoundingPoly.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.normalizedBoundingPoly = NormalizedBoundingPoly.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSpec = AnnotationSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageBoundingPolyAnnotation {
    return {
      boundingPoly: isSet(object.boundingPoly) ? BoundingPoly.fromJSON(object.boundingPoly) : undefined,
      normalizedBoundingPoly: isSet(object.normalizedBoundingPoly)
        ? NormalizedBoundingPoly.fromJSON(object.normalizedBoundingPoly)
        : undefined,
      annotationSpec: isSet(object.annotationSpec) ? AnnotationSpec.fromJSON(object.annotationSpec) : undefined,
    };
  },

  toJSON(message: ImageBoundingPolyAnnotation): unknown {
    const obj: any = {};
    if (message.boundingPoly !== undefined) {
      obj.boundingPoly = BoundingPoly.toJSON(message.boundingPoly);
    }
    if (message.normalizedBoundingPoly !== undefined) {
      obj.normalizedBoundingPoly = NormalizedBoundingPoly.toJSON(message.normalizedBoundingPoly);
    }
    if (message.annotationSpec !== undefined) {
      obj.annotationSpec = AnnotationSpec.toJSON(message.annotationSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<ImageBoundingPolyAnnotation>): ImageBoundingPolyAnnotation {
    return ImageBoundingPolyAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImageBoundingPolyAnnotation>): ImageBoundingPolyAnnotation {
    const message = createBaseImageBoundingPolyAnnotation();
    message.boundingPoly = (object.boundingPoly !== undefined && object.boundingPoly !== null)
      ? BoundingPoly.fromPartial(object.boundingPoly)
      : undefined;
    message.normalizedBoundingPoly =
      (object.normalizedBoundingPoly !== undefined && object.normalizedBoundingPoly !== null)
        ? NormalizedBoundingPoly.fromPartial(object.normalizedBoundingPoly)
        : undefined;
    message.annotationSpec = (object.annotationSpec !== undefined && object.annotationSpec !== null)
      ? AnnotationSpec.fromPartial(object.annotationSpec)
      : undefined;
    return message;
  },
};

function createBasePolyline(): Polyline {
  return { vertices: [] };
}

export const Polyline: MessageFns<Polyline> = {
  encode(message: Polyline, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.vertices) {
      Vertex.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Polyline {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolyline();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vertices.push(Vertex.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Polyline {
    return {
      vertices: globalThis.Array.isArray(object?.vertices) ? object.vertices.map((e: any) => Vertex.fromJSON(e)) : [],
    };
  },

  toJSON(message: Polyline): unknown {
    const obj: any = {};
    if (message.vertices?.length) {
      obj.vertices = message.vertices.map((e) => Vertex.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Polyline>): Polyline {
    return Polyline.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Polyline>): Polyline {
    const message = createBasePolyline();
    message.vertices = object.vertices?.map((e) => Vertex.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNormalizedPolyline(): NormalizedPolyline {
  return { normalizedVertices: [] };
}

export const NormalizedPolyline: MessageFns<NormalizedPolyline> = {
  encode(message: NormalizedPolyline, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.normalizedVertices) {
      NormalizedVertex.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NormalizedPolyline {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNormalizedPolyline();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.normalizedVertices.push(NormalizedVertex.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NormalizedPolyline {
    return {
      normalizedVertices: globalThis.Array.isArray(object?.normalizedVertices)
        ? object.normalizedVertices.map((e: any) => NormalizedVertex.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NormalizedPolyline): unknown {
    const obj: any = {};
    if (message.normalizedVertices?.length) {
      obj.normalizedVertices = message.normalizedVertices.map((e) => NormalizedVertex.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NormalizedPolyline>): NormalizedPolyline {
    return NormalizedPolyline.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NormalizedPolyline>): NormalizedPolyline {
    const message = createBaseNormalizedPolyline();
    message.normalizedVertices = object.normalizedVertices?.map((e) => NormalizedVertex.fromPartial(e)) || [];
    return message;
  },
};

function createBaseImagePolylineAnnotation(): ImagePolylineAnnotation {
  return { polyline: undefined, normalizedPolyline: undefined, annotationSpec: undefined };
}

export const ImagePolylineAnnotation: MessageFns<ImagePolylineAnnotation> = {
  encode(message: ImagePolylineAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.polyline !== undefined) {
      Polyline.encode(message.polyline, writer.uint32(18).fork()).join();
    }
    if (message.normalizedPolyline !== undefined) {
      NormalizedPolyline.encode(message.normalizedPolyline, writer.uint32(26).fork()).join();
    }
    if (message.annotationSpec !== undefined) {
      AnnotationSpec.encode(message.annotationSpec, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImagePolylineAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImagePolylineAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.polyline = Polyline.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.normalizedPolyline = NormalizedPolyline.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSpec = AnnotationSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImagePolylineAnnotation {
    return {
      polyline: isSet(object.polyline) ? Polyline.fromJSON(object.polyline) : undefined,
      normalizedPolyline: isSet(object.normalizedPolyline)
        ? NormalizedPolyline.fromJSON(object.normalizedPolyline)
        : undefined,
      annotationSpec: isSet(object.annotationSpec) ? AnnotationSpec.fromJSON(object.annotationSpec) : undefined,
    };
  },

  toJSON(message: ImagePolylineAnnotation): unknown {
    const obj: any = {};
    if (message.polyline !== undefined) {
      obj.polyline = Polyline.toJSON(message.polyline);
    }
    if (message.normalizedPolyline !== undefined) {
      obj.normalizedPolyline = NormalizedPolyline.toJSON(message.normalizedPolyline);
    }
    if (message.annotationSpec !== undefined) {
      obj.annotationSpec = AnnotationSpec.toJSON(message.annotationSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<ImagePolylineAnnotation>): ImagePolylineAnnotation {
    return ImagePolylineAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImagePolylineAnnotation>): ImagePolylineAnnotation {
    const message = createBaseImagePolylineAnnotation();
    message.polyline = (object.polyline !== undefined && object.polyline !== null)
      ? Polyline.fromPartial(object.polyline)
      : undefined;
    message.normalizedPolyline = (object.normalizedPolyline !== undefined && object.normalizedPolyline !== null)
      ? NormalizedPolyline.fromPartial(object.normalizedPolyline)
      : undefined;
    message.annotationSpec = (object.annotationSpec !== undefined && object.annotationSpec !== null)
      ? AnnotationSpec.fromPartial(object.annotationSpec)
      : undefined;
    return message;
  },
};

function createBaseImageSegmentationAnnotation(): ImageSegmentationAnnotation {
  return { annotationColors: {}, mimeType: "", imageBytes: Buffer.alloc(0) };
}

export const ImageSegmentationAnnotation: MessageFns<ImageSegmentationAnnotation> = {
  encode(message: ImageSegmentationAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.annotationColors).forEach(([key, value]) => {
      ImageSegmentationAnnotation_AnnotationColorsEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    if (message.imageBytes.length !== 0) {
      writer.uint32(26).bytes(message.imageBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageSegmentationAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageSegmentationAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ImageSegmentationAnnotation_AnnotationColorsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.annotationColors[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.imageBytes = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageSegmentationAnnotation {
    return {
      annotationColors: isObject(object.annotationColors)
        ? Object.entries(object.annotationColors).reduce<{ [key: string]: AnnotationSpec }>((acc, [key, value]) => {
          acc[key] = AnnotationSpec.fromJSON(value);
          return acc;
        }, {})
        : {},
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      imageBytes: isSet(object.imageBytes) ? Buffer.from(bytesFromBase64(object.imageBytes)) : Buffer.alloc(0),
    };
  },

  toJSON(message: ImageSegmentationAnnotation): unknown {
    const obj: any = {};
    if (message.annotationColors) {
      const entries = Object.entries(message.annotationColors);
      if (entries.length > 0) {
        obj.annotationColors = {};
        entries.forEach(([k, v]) => {
          obj.annotationColors[k] = AnnotationSpec.toJSON(v);
        });
      }
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.imageBytes.length !== 0) {
      obj.imageBytes = base64FromBytes(message.imageBytes);
    }
    return obj;
  },

  create(base?: DeepPartial<ImageSegmentationAnnotation>): ImageSegmentationAnnotation {
    return ImageSegmentationAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImageSegmentationAnnotation>): ImageSegmentationAnnotation {
    const message = createBaseImageSegmentationAnnotation();
    message.annotationColors = Object.entries(object.annotationColors ?? {}).reduce<{ [key: string]: AnnotationSpec }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AnnotationSpec.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.mimeType = object.mimeType ?? "";
    message.imageBytes = object.imageBytes ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseImageSegmentationAnnotation_AnnotationColorsEntry(): ImageSegmentationAnnotation_AnnotationColorsEntry {
  return { key: "", value: undefined };
}

export const ImageSegmentationAnnotation_AnnotationColorsEntry: MessageFns<
  ImageSegmentationAnnotation_AnnotationColorsEntry
> = {
  encode(
    message: ImageSegmentationAnnotation_AnnotationColorsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AnnotationSpec.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageSegmentationAnnotation_AnnotationColorsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageSegmentationAnnotation_AnnotationColorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AnnotationSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageSegmentationAnnotation_AnnotationColorsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AnnotationSpec.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ImageSegmentationAnnotation_AnnotationColorsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AnnotationSpec.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ImageSegmentationAnnotation_AnnotationColorsEntry>,
  ): ImageSegmentationAnnotation_AnnotationColorsEntry {
    return ImageSegmentationAnnotation_AnnotationColorsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ImageSegmentationAnnotation_AnnotationColorsEntry>,
  ): ImageSegmentationAnnotation_AnnotationColorsEntry {
    const message = createBaseImageSegmentationAnnotation_AnnotationColorsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AnnotationSpec.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTextClassificationAnnotation(): TextClassificationAnnotation {
  return { annotationSpec: undefined };
}

export const TextClassificationAnnotation: MessageFns<TextClassificationAnnotation> = {
  encode(message: TextClassificationAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationSpec !== undefined) {
      AnnotationSpec.encode(message.annotationSpec, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextClassificationAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextClassificationAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSpec = AnnotationSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextClassificationAnnotation {
    return {
      annotationSpec: isSet(object.annotationSpec) ? AnnotationSpec.fromJSON(object.annotationSpec) : undefined,
    };
  },

  toJSON(message: TextClassificationAnnotation): unknown {
    const obj: any = {};
    if (message.annotationSpec !== undefined) {
      obj.annotationSpec = AnnotationSpec.toJSON(message.annotationSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<TextClassificationAnnotation>): TextClassificationAnnotation {
    return TextClassificationAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextClassificationAnnotation>): TextClassificationAnnotation {
    const message = createBaseTextClassificationAnnotation();
    message.annotationSpec = (object.annotationSpec !== undefined && object.annotationSpec !== null)
      ? AnnotationSpec.fromPartial(object.annotationSpec)
      : undefined;
    return message;
  },
};

function createBaseTextEntityExtractionAnnotation(): TextEntityExtractionAnnotation {
  return { annotationSpec: undefined, sequentialSegment: undefined };
}

export const TextEntityExtractionAnnotation: MessageFns<TextEntityExtractionAnnotation> = {
  encode(message: TextEntityExtractionAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationSpec !== undefined) {
      AnnotationSpec.encode(message.annotationSpec, writer.uint32(10).fork()).join();
    }
    if (message.sequentialSegment !== undefined) {
      SequentialSegment.encode(message.sequentialSegment, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextEntityExtractionAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextEntityExtractionAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSpec = AnnotationSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sequentialSegment = SequentialSegment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextEntityExtractionAnnotation {
    return {
      annotationSpec: isSet(object.annotationSpec) ? AnnotationSpec.fromJSON(object.annotationSpec) : undefined,
      sequentialSegment: isSet(object.sequentialSegment)
        ? SequentialSegment.fromJSON(object.sequentialSegment)
        : undefined,
    };
  },

  toJSON(message: TextEntityExtractionAnnotation): unknown {
    const obj: any = {};
    if (message.annotationSpec !== undefined) {
      obj.annotationSpec = AnnotationSpec.toJSON(message.annotationSpec);
    }
    if (message.sequentialSegment !== undefined) {
      obj.sequentialSegment = SequentialSegment.toJSON(message.sequentialSegment);
    }
    return obj;
  },

  create(base?: DeepPartial<TextEntityExtractionAnnotation>): TextEntityExtractionAnnotation {
    return TextEntityExtractionAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextEntityExtractionAnnotation>): TextEntityExtractionAnnotation {
    const message = createBaseTextEntityExtractionAnnotation();
    message.annotationSpec = (object.annotationSpec !== undefined && object.annotationSpec !== null)
      ? AnnotationSpec.fromPartial(object.annotationSpec)
      : undefined;
    message.sequentialSegment = (object.sequentialSegment !== undefined && object.sequentialSegment !== null)
      ? SequentialSegment.fromPartial(object.sequentialSegment)
      : undefined;
    return message;
  },
};

function createBaseSequentialSegment(): SequentialSegment {
  return { start: 0, end: 0 };
}

export const SequentialSegment: MessageFns<SequentialSegment> = {
  encode(message: SequentialSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SequentialSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSequentialSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SequentialSegment {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
    };
  },

  toJSON(message: SequentialSegment): unknown {
    const obj: any = {};
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    return obj;
  },

  create(base?: DeepPartial<SequentialSegment>): SequentialSegment {
    return SequentialSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SequentialSegment>): SequentialSegment {
    const message = createBaseSequentialSegment();
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    return message;
  },
};

function createBaseTimeSegment(): TimeSegment {
  return { startTimeOffset: undefined, endTimeOffset: undefined };
}

export const TimeSegment: MessageFns<TimeSegment> = {
  encode(message: TimeSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTimeOffset !== undefined) {
      Duration.encode(message.startTimeOffset, writer.uint32(10).fork()).join();
    }
    if (message.endTimeOffset !== undefined) {
      Duration.encode(message.endTimeOffset, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTimeOffset = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTimeOffset = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeSegment {
    return {
      startTimeOffset: isSet(object.startTimeOffset) ? Duration.fromJSON(object.startTimeOffset) : undefined,
      endTimeOffset: isSet(object.endTimeOffset) ? Duration.fromJSON(object.endTimeOffset) : undefined,
    };
  },

  toJSON(message: TimeSegment): unknown {
    const obj: any = {};
    if (message.startTimeOffset !== undefined) {
      obj.startTimeOffset = Duration.toJSON(message.startTimeOffset);
    }
    if (message.endTimeOffset !== undefined) {
      obj.endTimeOffset = Duration.toJSON(message.endTimeOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<TimeSegment>): TimeSegment {
    return TimeSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeSegment>): TimeSegment {
    const message = createBaseTimeSegment();
    message.startTimeOffset = (object.startTimeOffset !== undefined && object.startTimeOffset !== null)
      ? Duration.fromPartial(object.startTimeOffset)
      : undefined;
    message.endTimeOffset = (object.endTimeOffset !== undefined && object.endTimeOffset !== null)
      ? Duration.fromPartial(object.endTimeOffset)
      : undefined;
    return message;
  },
};

function createBaseVideoClassificationAnnotation(): VideoClassificationAnnotation {
  return { timeSegment: undefined, annotationSpec: undefined };
}

export const VideoClassificationAnnotation: MessageFns<VideoClassificationAnnotation> = {
  encode(message: VideoClassificationAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeSegment !== undefined) {
      TimeSegment.encode(message.timeSegment, writer.uint32(10).fork()).join();
    }
    if (message.annotationSpec !== undefined) {
      AnnotationSpec.encode(message.annotationSpec, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoClassificationAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoClassificationAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeSegment = TimeSegment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotationSpec = AnnotationSpec.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoClassificationAnnotation {
    return {
      timeSegment: isSet(object.timeSegment) ? TimeSegment.fromJSON(object.timeSegment) : undefined,
      annotationSpec: isSet(object.annotationSpec) ? AnnotationSpec.fromJSON(object.annotationSpec) : undefined,
    };
  },

  toJSON(message: VideoClassificationAnnotation): unknown {
    const obj: any = {};
    if (message.timeSegment !== undefined) {
      obj.timeSegment = TimeSegment.toJSON(message.timeSegment);
    }
    if (message.annotationSpec !== undefined) {
      obj.annotationSpec = AnnotationSpec.toJSON(message.annotationSpec);
    }
    return obj;
  },

  create(base?: DeepPartial<VideoClassificationAnnotation>): VideoClassificationAnnotation {
    return VideoClassificationAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoClassificationAnnotation>): VideoClassificationAnnotation {
    const message = createBaseVideoClassificationAnnotation();
    message.timeSegment = (object.timeSegment !== undefined && object.timeSegment !== null)
      ? TimeSegment.fromPartial(object.timeSegment)
      : undefined;
    message.annotationSpec = (object.annotationSpec !== undefined && object.annotationSpec !== null)
      ? AnnotationSpec.fromPartial(object.annotationSpec)
      : undefined;
    return message;
  },
};

function createBaseObjectTrackingFrame(): ObjectTrackingFrame {
  return { boundingPoly: undefined, normalizedBoundingPoly: undefined, timeOffset: undefined };
}

export const ObjectTrackingFrame: MessageFns<ObjectTrackingFrame> = {
  encode(message: ObjectTrackingFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.boundingPoly !== undefined) {
      BoundingPoly.encode(message.boundingPoly, writer.uint32(10).fork()).join();
    }
    if (message.normalizedBoundingPoly !== undefined) {
      NormalizedBoundingPoly.encode(message.normalizedBoundingPoly, writer.uint32(18).fork()).join();
    }
    if (message.timeOffset !== undefined) {
      Duration.encode(message.timeOffset, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectTrackingFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectTrackingFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.boundingPoly = BoundingPoly.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.normalizedBoundingPoly = NormalizedBoundingPoly.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timeOffset = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectTrackingFrame {
    return {
      boundingPoly: isSet(object.boundingPoly) ? BoundingPoly.fromJSON(object.boundingPoly) : undefined,
      normalizedBoundingPoly: isSet(object.normalizedBoundingPoly)
        ? NormalizedBoundingPoly.fromJSON(object.normalizedBoundingPoly)
        : undefined,
      timeOffset: isSet(object.timeOffset) ? Duration.fromJSON(object.timeOffset) : undefined,
    };
  },

  toJSON(message: ObjectTrackingFrame): unknown {
    const obj: any = {};
    if (message.boundingPoly !== undefined) {
      obj.boundingPoly = BoundingPoly.toJSON(message.boundingPoly);
    }
    if (message.normalizedBoundingPoly !== undefined) {
      obj.normalizedBoundingPoly = NormalizedBoundingPoly.toJSON(message.normalizedBoundingPoly);
    }
    if (message.timeOffset !== undefined) {
      obj.timeOffset = Duration.toJSON(message.timeOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectTrackingFrame>): ObjectTrackingFrame {
    return ObjectTrackingFrame.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectTrackingFrame>): ObjectTrackingFrame {
    const message = createBaseObjectTrackingFrame();
    message.boundingPoly = (object.boundingPoly !== undefined && object.boundingPoly !== null)
      ? BoundingPoly.fromPartial(object.boundingPoly)
      : undefined;
    message.normalizedBoundingPoly =
      (object.normalizedBoundingPoly !== undefined && object.normalizedBoundingPoly !== null)
        ? NormalizedBoundingPoly.fromPartial(object.normalizedBoundingPoly)
        : undefined;
    message.timeOffset = (object.timeOffset !== undefined && object.timeOffset !== null)
      ? Duration.fromPartial(object.timeOffset)
      : undefined;
    return message;
  },
};

function createBaseVideoObjectTrackingAnnotation(): VideoObjectTrackingAnnotation {
  return { annotationSpec: undefined, timeSegment: undefined, objectTrackingFrames: [] };
}

export const VideoObjectTrackingAnnotation: MessageFns<VideoObjectTrackingAnnotation> = {
  encode(message: VideoObjectTrackingAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationSpec !== undefined) {
      AnnotationSpec.encode(message.annotationSpec, writer.uint32(10).fork()).join();
    }
    if (message.timeSegment !== undefined) {
      TimeSegment.encode(message.timeSegment, writer.uint32(18).fork()).join();
    }
    for (const v of message.objectTrackingFrames) {
      ObjectTrackingFrame.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoObjectTrackingAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoObjectTrackingAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSpec = AnnotationSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeSegment = TimeSegment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.objectTrackingFrames.push(ObjectTrackingFrame.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoObjectTrackingAnnotation {
    return {
      annotationSpec: isSet(object.annotationSpec) ? AnnotationSpec.fromJSON(object.annotationSpec) : undefined,
      timeSegment: isSet(object.timeSegment) ? TimeSegment.fromJSON(object.timeSegment) : undefined,
      objectTrackingFrames: globalThis.Array.isArray(object?.objectTrackingFrames)
        ? object.objectTrackingFrames.map((e: any) => ObjectTrackingFrame.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VideoObjectTrackingAnnotation): unknown {
    const obj: any = {};
    if (message.annotationSpec !== undefined) {
      obj.annotationSpec = AnnotationSpec.toJSON(message.annotationSpec);
    }
    if (message.timeSegment !== undefined) {
      obj.timeSegment = TimeSegment.toJSON(message.timeSegment);
    }
    if (message.objectTrackingFrames?.length) {
      obj.objectTrackingFrames = message.objectTrackingFrames.map((e) => ObjectTrackingFrame.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VideoObjectTrackingAnnotation>): VideoObjectTrackingAnnotation {
    return VideoObjectTrackingAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoObjectTrackingAnnotation>): VideoObjectTrackingAnnotation {
    const message = createBaseVideoObjectTrackingAnnotation();
    message.annotationSpec = (object.annotationSpec !== undefined && object.annotationSpec !== null)
      ? AnnotationSpec.fromPartial(object.annotationSpec)
      : undefined;
    message.timeSegment = (object.timeSegment !== undefined && object.timeSegment !== null)
      ? TimeSegment.fromPartial(object.timeSegment)
      : undefined;
    message.objectTrackingFrames = object.objectTrackingFrames?.map((e) => ObjectTrackingFrame.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVideoEventAnnotation(): VideoEventAnnotation {
  return { annotationSpec: undefined, timeSegment: undefined };
}

export const VideoEventAnnotation: MessageFns<VideoEventAnnotation> = {
  encode(message: VideoEventAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationSpec !== undefined) {
      AnnotationSpec.encode(message.annotationSpec, writer.uint32(10).fork()).join();
    }
    if (message.timeSegment !== undefined) {
      TimeSegment.encode(message.timeSegment, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoEventAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoEventAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSpec = AnnotationSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeSegment = TimeSegment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoEventAnnotation {
    return {
      annotationSpec: isSet(object.annotationSpec) ? AnnotationSpec.fromJSON(object.annotationSpec) : undefined,
      timeSegment: isSet(object.timeSegment) ? TimeSegment.fromJSON(object.timeSegment) : undefined,
    };
  },

  toJSON(message: VideoEventAnnotation): unknown {
    const obj: any = {};
    if (message.annotationSpec !== undefined) {
      obj.annotationSpec = AnnotationSpec.toJSON(message.annotationSpec);
    }
    if (message.timeSegment !== undefined) {
      obj.timeSegment = TimeSegment.toJSON(message.timeSegment);
    }
    return obj;
  },

  create(base?: DeepPartial<VideoEventAnnotation>): VideoEventAnnotation {
    return VideoEventAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoEventAnnotation>): VideoEventAnnotation {
    const message = createBaseVideoEventAnnotation();
    message.annotationSpec = (object.annotationSpec !== undefined && object.annotationSpec !== null)
      ? AnnotationSpec.fromPartial(object.annotationSpec)
      : undefined;
    message.timeSegment = (object.timeSegment !== undefined && object.timeSegment !== null)
      ? TimeSegment.fromPartial(object.timeSegment)
      : undefined;
    return message;
  },
};

function createBaseAnnotationMetadata(): AnnotationMetadata {
  return { operatorMetadata: undefined };
}

export const AnnotationMetadata: MessageFns<AnnotationMetadata> = {
  encode(message: AnnotationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operatorMetadata !== undefined) {
      OperatorMetadata.encode(message.operatorMetadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operatorMetadata = OperatorMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationMetadata {
    return {
      operatorMetadata: isSet(object.operatorMetadata) ? OperatorMetadata.fromJSON(object.operatorMetadata) : undefined,
    };
  },

  toJSON(message: AnnotationMetadata): unknown {
    const obj: any = {};
    if (message.operatorMetadata !== undefined) {
      obj.operatorMetadata = OperatorMetadata.toJSON(message.operatorMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotationMetadata>): AnnotationMetadata {
    return AnnotationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotationMetadata>): AnnotationMetadata {
    const message = createBaseAnnotationMetadata();
    message.operatorMetadata = (object.operatorMetadata !== undefined && object.operatorMetadata !== null)
      ? OperatorMetadata.fromPartial(object.operatorMetadata)
      : undefined;
    return message;
  },
};

function createBaseOperatorMetadata(): OperatorMetadata {
  return { score: 0, totalVotes: 0, labelVotes: 0, comments: [] };
}

export const OperatorMetadata: MessageFns<OperatorMetadata> = {
  encode(message: OperatorMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== 0) {
      writer.uint32(13).float(message.score);
    }
    if (message.totalVotes !== 0) {
      writer.uint32(16).int32(message.totalVotes);
    }
    if (message.labelVotes !== 0) {
      writer.uint32(24).int32(message.labelVotes);
    }
    for (const v of message.comments) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperatorMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperatorMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalVotes = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.labelVotes = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comments.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperatorMetadata {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      totalVotes: isSet(object.totalVotes) ? globalThis.Number(object.totalVotes) : 0,
      labelVotes: isSet(object.labelVotes) ? globalThis.Number(object.labelVotes) : 0,
      comments: globalThis.Array.isArray(object?.comments) ? object.comments.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: OperatorMetadata): unknown {
    const obj: any = {};
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.totalVotes !== 0) {
      obj.totalVotes = Math.round(message.totalVotes);
    }
    if (message.labelVotes !== 0) {
      obj.labelVotes = Math.round(message.labelVotes);
    }
    if (message.comments?.length) {
      obj.comments = message.comments;
    }
    return obj;
  },

  create(base?: DeepPartial<OperatorMetadata>): OperatorMetadata {
    return OperatorMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperatorMetadata>): OperatorMetadata {
    const message = createBaseOperatorMetadata();
    message.score = object.score ?? 0;
    message.totalVotes = object.totalVotes ?? 0;
    message.labelVotes = object.labelVotes ?? 0;
    message.comments = object.comments?.map((e) => e) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
