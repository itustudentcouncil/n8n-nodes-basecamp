// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/vmmigration/v1/vmmigration.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Duration } from "../../../protobuf/duration.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Help_Link, LocalizedMessage } from "../../../rpc/error_details.js";
import { Status } from "../../../rpc/status.js";

export const protobufPackage = "google.cloud.vmmigration.v1";

/** Controls the level of details of a Utilization Report. */
export enum UtilizationReportView {
  /**
   * UTILIZATION_REPORT_VIEW_UNSPECIFIED - The default / unset value.
   * The API will default to FULL on single report request and BASIC for
   * multiple reports request.
   */
  UTILIZATION_REPORT_VIEW_UNSPECIFIED = 0,
  /**
   * BASIC - Get the report metadata, without the list of VMs and their utilization
   * info.
   */
  BASIC = 1,
  /** FULL - Include everything. */
  FULL = 2,
  UNRECOGNIZED = -1,
}

export function utilizationReportViewFromJSON(object: any): UtilizationReportView {
  switch (object) {
    case 0:
    case "UTILIZATION_REPORT_VIEW_UNSPECIFIED":
      return UtilizationReportView.UTILIZATION_REPORT_VIEW_UNSPECIFIED;
    case 1:
    case "BASIC":
      return UtilizationReportView.BASIC;
    case 2:
    case "FULL":
      return UtilizationReportView.FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UtilizationReportView.UNRECOGNIZED;
  }
}

export function utilizationReportViewToJSON(object: UtilizationReportView): string {
  switch (object) {
    case UtilizationReportView.UTILIZATION_REPORT_VIEW_UNSPECIFIED:
      return "UTILIZATION_REPORT_VIEW_UNSPECIFIED";
    case UtilizationReportView.BASIC:
      return "BASIC";
    case UtilizationReportView.FULL:
      return "FULL";
    case UtilizationReportView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Controls the level of details of a Migrating VM. */
export enum MigratingVmView {
  /** MIGRATING_VM_VIEW_UNSPECIFIED - View is unspecified. The API will fallback to the default value. */
  MIGRATING_VM_VIEW_UNSPECIFIED = 0,
  /**
   * MIGRATING_VM_VIEW_BASIC - Get the migrating VM basic details.
   * The basic details do not include the recent clone jobs and recent cutover
   * jobs lists.
   */
  MIGRATING_VM_VIEW_BASIC = 1,
  /** MIGRATING_VM_VIEW_FULL - Include everything. */
  MIGRATING_VM_VIEW_FULL = 2,
  UNRECOGNIZED = -1,
}

export function migratingVmViewFromJSON(object: any): MigratingVmView {
  switch (object) {
    case 0:
    case "MIGRATING_VM_VIEW_UNSPECIFIED":
      return MigratingVmView.MIGRATING_VM_VIEW_UNSPECIFIED;
    case 1:
    case "MIGRATING_VM_VIEW_BASIC":
      return MigratingVmView.MIGRATING_VM_VIEW_BASIC;
    case 2:
    case "MIGRATING_VM_VIEW_FULL":
      return MigratingVmView.MIGRATING_VM_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MigratingVmView.UNRECOGNIZED;
  }
}

export function migratingVmViewToJSON(object: MigratingVmView): string {
  switch (object) {
    case MigratingVmView.MIGRATING_VM_VIEW_UNSPECIFIED:
      return "MIGRATING_VM_VIEW_UNSPECIFIED";
    case MigratingVmView.MIGRATING_VM_VIEW_BASIC:
      return "MIGRATING_VM_VIEW_BASIC";
    case MigratingVmView.MIGRATING_VM_VIEW_FULL:
      return "MIGRATING_VM_VIEW_FULL";
    case MigratingVmView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Types of disks supported for Compute Engine VM. */
export enum ComputeEngineDiskType {
  /** COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED - An unspecified disk type. Will be used as STANDARD. */
  COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED = 0,
  /** COMPUTE_ENGINE_DISK_TYPE_STANDARD - A Standard disk type. */
  COMPUTE_ENGINE_DISK_TYPE_STANDARD = 1,
  /** COMPUTE_ENGINE_DISK_TYPE_SSD - SSD hard disk type. */
  COMPUTE_ENGINE_DISK_TYPE_SSD = 2,
  /**
   * COMPUTE_ENGINE_DISK_TYPE_BALANCED - An alternative to SSD persistent disks that balance performance and
   * cost.
   */
  COMPUTE_ENGINE_DISK_TYPE_BALANCED = 3,
  UNRECOGNIZED = -1,
}

export function computeEngineDiskTypeFromJSON(object: any): ComputeEngineDiskType {
  switch (object) {
    case 0:
    case "COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED":
      return ComputeEngineDiskType.COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED;
    case 1:
    case "COMPUTE_ENGINE_DISK_TYPE_STANDARD":
      return ComputeEngineDiskType.COMPUTE_ENGINE_DISK_TYPE_STANDARD;
    case 2:
    case "COMPUTE_ENGINE_DISK_TYPE_SSD":
      return ComputeEngineDiskType.COMPUTE_ENGINE_DISK_TYPE_SSD;
    case 3:
    case "COMPUTE_ENGINE_DISK_TYPE_BALANCED":
      return ComputeEngineDiskType.COMPUTE_ENGINE_DISK_TYPE_BALANCED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComputeEngineDiskType.UNRECOGNIZED;
  }
}

export function computeEngineDiskTypeToJSON(object: ComputeEngineDiskType): string {
  switch (object) {
    case ComputeEngineDiskType.COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED:
      return "COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED";
    case ComputeEngineDiskType.COMPUTE_ENGINE_DISK_TYPE_STANDARD:
      return "COMPUTE_ENGINE_DISK_TYPE_STANDARD";
    case ComputeEngineDiskType.COMPUTE_ENGINE_DISK_TYPE_SSD:
      return "COMPUTE_ENGINE_DISK_TYPE_SSD";
    case ComputeEngineDiskType.COMPUTE_ENGINE_DISK_TYPE_BALANCED:
      return "COMPUTE_ENGINE_DISK_TYPE_BALANCED";
    case ComputeEngineDiskType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Types of licenses used in OS adaptation. */
export enum ComputeEngineLicenseType {
  /** COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT - The license type is the default for the OS. */
  COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT = 0,
  /** COMPUTE_ENGINE_LICENSE_TYPE_PAYG - The license type is Pay As You Go license type. */
  COMPUTE_ENGINE_LICENSE_TYPE_PAYG = 1,
  /** COMPUTE_ENGINE_LICENSE_TYPE_BYOL - The license type is Bring Your Own License type. */
  COMPUTE_ENGINE_LICENSE_TYPE_BYOL = 2,
  UNRECOGNIZED = -1,
}

export function computeEngineLicenseTypeFromJSON(object: any): ComputeEngineLicenseType {
  switch (object) {
    case 0:
    case "COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT":
      return ComputeEngineLicenseType.COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT;
    case 1:
    case "COMPUTE_ENGINE_LICENSE_TYPE_PAYG":
      return ComputeEngineLicenseType.COMPUTE_ENGINE_LICENSE_TYPE_PAYG;
    case 2:
    case "COMPUTE_ENGINE_LICENSE_TYPE_BYOL":
      return ComputeEngineLicenseType.COMPUTE_ENGINE_LICENSE_TYPE_BYOL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComputeEngineLicenseType.UNRECOGNIZED;
  }
}

export function computeEngineLicenseTypeToJSON(object: ComputeEngineLicenseType): string {
  switch (object) {
    case ComputeEngineLicenseType.COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT:
      return "COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT";
    case ComputeEngineLicenseType.COMPUTE_ENGINE_LICENSE_TYPE_PAYG:
      return "COMPUTE_ENGINE_LICENSE_TYPE_PAYG";
    case ComputeEngineLicenseType.COMPUTE_ENGINE_LICENSE_TYPE_BYOL:
      return "COMPUTE_ENGINE_LICENSE_TYPE_BYOL";
    case ComputeEngineLicenseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible values for vm boot option. */
export enum ComputeEngineBootOption {
  /** COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED - The boot option is unknown. */
  COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED = 0,
  /** COMPUTE_ENGINE_BOOT_OPTION_EFI - The boot option is EFI. */
  COMPUTE_ENGINE_BOOT_OPTION_EFI = 1,
  /** COMPUTE_ENGINE_BOOT_OPTION_BIOS - The boot option is BIOS. */
  COMPUTE_ENGINE_BOOT_OPTION_BIOS = 2,
  UNRECOGNIZED = -1,
}

export function computeEngineBootOptionFromJSON(object: any): ComputeEngineBootOption {
  switch (object) {
    case 0:
    case "COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED":
      return ComputeEngineBootOption.COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED;
    case 1:
    case "COMPUTE_ENGINE_BOOT_OPTION_EFI":
      return ComputeEngineBootOption.COMPUTE_ENGINE_BOOT_OPTION_EFI;
    case 2:
    case "COMPUTE_ENGINE_BOOT_OPTION_BIOS":
      return ComputeEngineBootOption.COMPUTE_ENGINE_BOOT_OPTION_BIOS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComputeEngineBootOption.UNRECOGNIZED;
  }
}

export function computeEngineBootOptionToJSON(object: ComputeEngineBootOption): string {
  switch (object) {
    case ComputeEngineBootOption.COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED:
      return "COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED";
    case ComputeEngineBootOption.COMPUTE_ENGINE_BOOT_OPTION_EFI:
      return "COMPUTE_ENGINE_BOOT_OPTION_EFI";
    case ComputeEngineBootOption.COMPUTE_ENGINE_BOOT_OPTION_BIOS:
      return "COMPUTE_ENGINE_BOOT_OPTION_BIOS";
    case ComputeEngineBootOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * ReplicationCycle contains information about the current replication cycle
 * status.
 */
export interface ReplicationCycle {
  /** The identifier of the ReplicationCycle. */
  name: string;
  /** The cycle's ordinal number. */
  cycleNumber: number;
  /** The time the replication cycle has started. */
  startTime:
    | Date
    | undefined;
  /** The time the replication cycle has ended. */
  endTime:
    | Date
    | undefined;
  /** The accumulated duration the replication cycle was paused. */
  totalPauseDuration:
    | Duration
    | undefined;
  /**
   * The current progress in percentage of this cycle.
   * Was replaced by 'steps' field, which breaks down the cycle progression more
   * accurately.
   *
   * @deprecated
   */
  progressPercent: number;
  /** The cycle's steps list representing its progress. */
  steps: CycleStep[];
  /** State of the ReplicationCycle. */
  state: ReplicationCycle_State;
  /** Provides details on the state of the cycle in case of an error. */
  error: Status | undefined;
}

/** Possible states of a replication cycle. */
export enum ReplicationCycle_State {
  /**
   * STATE_UNSPECIFIED - The state is unknown. This is used for API compatibility only and is not
   * used by the system.
   */
  STATE_UNSPECIFIED = 0,
  /** RUNNING - The replication cycle is running. */
  RUNNING = 1,
  /** PAUSED - The replication cycle is paused. */
  PAUSED = 2,
  /** FAILED - The replication cycle finished with errors. */
  FAILED = 3,
  /** SUCCEEDED - The replication cycle finished successfully. */
  SUCCEEDED = 4,
  UNRECOGNIZED = -1,
}

export function replicationCycle_StateFromJSON(object: any): ReplicationCycle_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ReplicationCycle_State.STATE_UNSPECIFIED;
    case 1:
    case "RUNNING":
      return ReplicationCycle_State.RUNNING;
    case 2:
    case "PAUSED":
      return ReplicationCycle_State.PAUSED;
    case 3:
    case "FAILED":
      return ReplicationCycle_State.FAILED;
    case 4:
    case "SUCCEEDED":
      return ReplicationCycle_State.SUCCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReplicationCycle_State.UNRECOGNIZED;
  }
}

export function replicationCycle_StateToJSON(object: ReplicationCycle_State): string {
  switch (object) {
    case ReplicationCycle_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ReplicationCycle_State.RUNNING:
      return "RUNNING";
    case ReplicationCycle_State.PAUSED:
      return "PAUSED";
    case ReplicationCycle_State.FAILED:
      return "FAILED";
    case ReplicationCycle_State.SUCCEEDED:
      return "SUCCEEDED";
    case ReplicationCycle_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** CycleStep holds information about a step progress. */
export interface CycleStep {
  /** Initializing replication step. */
  initializingReplication?:
    | InitializingReplicationStep
    | undefined;
  /** Replicating step. */
  replicating?:
    | ReplicatingStep
    | undefined;
  /** Post processing step. */
  postProcessing?:
    | PostProcessingStep
    | undefined;
  /** The time the cycle step has started. */
  startTime:
    | Date
    | undefined;
  /** The time the cycle step has ended. */
  endTime: Date | undefined;
}

/** InitializingReplicationStep contains specific step details. */
export interface InitializingReplicationStep {
}

/** ReplicatingStep contains specific step details. */
export interface ReplicatingStep {
  /** Total bytes to be handled in the step. */
  totalBytes: Long;
  /** Replicated bytes in the step. */
  replicatedBytes: Long;
  /**
   * The source disks replication rate for the last 2 minutes in bytes per
   * second.
   */
  lastTwoMinutesAverageBytesPerSecond: Long;
  /**
   * The source disks replication rate for the last 30 minutes in bytes per
   * second.
   */
  lastThirtyMinutesAverageBytesPerSecond: Long;
}

/** PostProcessingStep contains specific step details. */
export interface PostProcessingStep {
}

/** ReplicationSync contain information about the last replica sync to the cloud. */
export interface ReplicationSync {
  /**
   * The most updated snapshot created time in the source that finished
   * replication.
   */
  lastSyncTime: Date | undefined;
}

/**
 * MigratingVm describes the VM that will be migrated from a Source environment
 * and its replication state.
 */
export interface MigratingVm {
  /** Details of the target VM in Compute Engine. */
  computeEngineTargetDefaults?:
    | ComputeEngineTargetDefaults
    | undefined;
  /** Output only. Details of the VM from an AWS source. */
  awsSourceVmDetails?:
    | AwsSourceVmDetails
    | undefined;
  /** Output only. The identifier of the MigratingVm. */
  name: string;
  /**
   * The unique ID of the VM in the source.
   * The VM's name in vSphere can be changed, so this is not the VM's name but
   * rather its moRef id. This id is of the form vm-<num>.
   */
  sourceVmId: string;
  /** The display name attached to the MigratingVm by the user. */
  displayName: string;
  /** The description attached to the migrating VM by the user. */
  description: string;
  /** The replication schedule policy. */
  policy:
    | SchedulePolicy
    | undefined;
  /**
   * Output only. The time the migrating VM was created (this refers to this
   * resource and not to the time it was installed in the source).
   */
  createTime:
    | Date
    | undefined;
  /** Output only. The last time the migrating VM resource was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. The most updated snapshot created time in the source that
   * finished replication.
   */
  lastSync:
    | ReplicationSync
    | undefined;
  /** Output only. State of the MigratingVm. */
  state: MigratingVm_State;
  /** Output only. The last time the migrating VM state was updated. */
  stateTime:
    | Date
    | undefined;
  /**
   * Output only. The percentage progress of the current running replication
   * cycle.
   */
  currentSyncInfo:
    | ReplicationCycle
    | undefined;
  /**
   * Output only. The group this migrating vm is included in, if any. The group
   * is represented by the full path of the appropriate
   * [Group][google.cloud.vmmigration.v1.Group] resource.
   */
  group: string;
  /** The labels of the migrating VM. */
  labels: { [key: string]: string };
  /**
   * Output only. The recent [clone jobs][google.cloud.vmmigration.v1.CloneJob]
   * performed on the migrating VM. This field holds the vm's last completed
   * clone job and the vm's running clone job, if one exists.
   * Note: To have this field populated you need to explicitly request it via
   * the "view" parameter of the Get/List request.
   */
  recentCloneJobs: CloneJob[];
  /**
   * Output only. Provides details on the state of the Migrating VM in case of
   * an error in replication.
   */
  error:
    | Status
    | undefined;
  /**
   * Output only. The recent cutover jobs performed on the migrating VM.
   * This field holds the vm's last completed cutover job and the vm's
   * running cutover job, if one exists.
   * Note: To have this field populated you need to explicitly request it via
   * the "view" parameter of the Get/List request.
   */
  recentCutoverJobs: CutoverJob[];
}

/** The possible values of the state/health of source VM. */
export enum MigratingVm_State {
  /** STATE_UNSPECIFIED - The state was not sampled by the health checks yet. */
  STATE_UNSPECIFIED = 0,
  /** PENDING - The VM in the source is being verified. */
  PENDING = 1,
  /** READY - The source VM was verified, and it's ready to start replication. */
  READY = 2,
  /** FIRST_SYNC - Migration is going through the first sync cycle. */
  FIRST_SYNC = 3,
  /** ACTIVE - The replication is active, and it's running or scheduled to run. */
  ACTIVE = 4,
  /**
   * CUTTING_OVER - The source VM is being turned off, and a final replication is currently
   * running.
   */
  CUTTING_OVER = 7,
  /**
   * CUTOVER - The source VM was stopped and replicated. The replication is currently
   * paused.
   */
  CUTOVER = 8,
  /** FINAL_SYNC - A cutover job is active and replication cycle is running the final sync. */
  FINAL_SYNC = 9,
  /**
   * PAUSED - The replication was paused by the user and no cycles are scheduled to
   * run.
   */
  PAUSED = 10,
  /**
   * FINALIZING - The migrating VM is being finalized and migration resources are being
   * removed.
   */
  FINALIZING = 11,
  /**
   * FINALIZED - The replication process is done. The migrating VM is finalized and no
   * longer consumes billable resources.
   */
  FINALIZED = 12,
  /**
   * ERROR - The replication process encountered an unrecoverable error and was
   * aborted.
   */
  ERROR = 13,
  UNRECOGNIZED = -1,
}

export function migratingVm_StateFromJSON(object: any): MigratingVm_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return MigratingVm_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return MigratingVm_State.PENDING;
    case 2:
    case "READY":
      return MigratingVm_State.READY;
    case 3:
    case "FIRST_SYNC":
      return MigratingVm_State.FIRST_SYNC;
    case 4:
    case "ACTIVE":
      return MigratingVm_State.ACTIVE;
    case 7:
    case "CUTTING_OVER":
      return MigratingVm_State.CUTTING_OVER;
    case 8:
    case "CUTOVER":
      return MigratingVm_State.CUTOVER;
    case 9:
    case "FINAL_SYNC":
      return MigratingVm_State.FINAL_SYNC;
    case 10:
    case "PAUSED":
      return MigratingVm_State.PAUSED;
    case 11:
    case "FINALIZING":
      return MigratingVm_State.FINALIZING;
    case 12:
    case "FINALIZED":
      return MigratingVm_State.FINALIZED;
    case 13:
    case "ERROR":
      return MigratingVm_State.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MigratingVm_State.UNRECOGNIZED;
  }
}

export function migratingVm_StateToJSON(object: MigratingVm_State): string {
  switch (object) {
    case MigratingVm_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case MigratingVm_State.PENDING:
      return "PENDING";
    case MigratingVm_State.READY:
      return "READY";
    case MigratingVm_State.FIRST_SYNC:
      return "FIRST_SYNC";
    case MigratingVm_State.ACTIVE:
      return "ACTIVE";
    case MigratingVm_State.CUTTING_OVER:
      return "CUTTING_OVER";
    case MigratingVm_State.CUTOVER:
      return "CUTOVER";
    case MigratingVm_State.FINAL_SYNC:
      return "FINAL_SYNC";
    case MigratingVm_State.PAUSED:
      return "PAUSED";
    case MigratingVm_State.FINALIZING:
      return "FINALIZING";
    case MigratingVm_State.FINALIZED:
      return "FINALIZED";
    case MigratingVm_State.ERROR:
      return "ERROR";
    case MigratingVm_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface MigratingVm_LabelsEntry {
  key: string;
  value: string;
}

/**
 * CloneJob describes the process of creating a clone of a
 * [MigratingVM][google.cloud.vmmigration.v1.MigratingVm] to the
 * requested target based on the latest successful uploaded snapshots.
 * While the migration cycles of a MigratingVm take place, it is possible to
 * verify the uploaded VM can be started in the cloud, by creating a clone. The
 * clone can be created without any downtime, and it is created using the latest
 * snapshots which are already in the cloud. The cloneJob is only responsible
 * for its work, not its products, which means once it is finished, it will
 * never touch the instance it created. It will only delete it in case of the
 * CloneJob being cancelled or upon failure to clone.
 */
export interface CloneJob {
  /** Output only. Details of the target VM in Compute Engine. */
  computeEngineTargetDetails?:
    | ComputeEngineTargetDetails
    | undefined;
  /**
   * Output only. The time the clone job was created (as an API call, not when
   * it was actually created in the target).
   */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the clone job was ended. */
  endTime:
    | Date
    | undefined;
  /** Output only. The name of the clone. */
  name: string;
  /** Output only. State of the clone job. */
  state: CloneJob_State;
  /** Output only. The time the state was last updated. */
  stateTime:
    | Date
    | undefined;
  /**
   * Output only. Provides details for the errors that led to the Clone Job's
   * state.
   */
  error:
    | Status
    | undefined;
  /** Output only. The clone steps list representing its progress. */
  steps: CloneStep[];
}

/** Possible states of the clone job. */
export enum CloneJob_State {
  /**
   * STATE_UNSPECIFIED - The state is unknown. This is used for API compatibility only and is not
   * used by the system.
   */
  STATE_UNSPECIFIED = 0,
  /** PENDING - The clone job has not yet started. */
  PENDING = 1,
  /** ACTIVE - The clone job is active and running. */
  ACTIVE = 2,
  /** FAILED - The clone job finished with errors. */
  FAILED = 3,
  /** SUCCEEDED - The clone job finished successfully. */
  SUCCEEDED = 4,
  /** CANCELLED - The clone job was cancelled. */
  CANCELLED = 5,
  /** CANCELLING - The clone job is being cancelled. */
  CANCELLING = 6,
  /** ADAPTING_OS - OS adaptation is running as part of the clone job to generate license. */
  ADAPTING_OS = 7,
  UNRECOGNIZED = -1,
}

export function cloneJob_StateFromJSON(object: any): CloneJob_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return CloneJob_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return CloneJob_State.PENDING;
    case 2:
    case "ACTIVE":
      return CloneJob_State.ACTIVE;
    case 3:
    case "FAILED":
      return CloneJob_State.FAILED;
    case 4:
    case "SUCCEEDED":
      return CloneJob_State.SUCCEEDED;
    case 5:
    case "CANCELLED":
      return CloneJob_State.CANCELLED;
    case 6:
    case "CANCELLING":
      return CloneJob_State.CANCELLING;
    case 7:
    case "ADAPTING_OS":
      return CloneJob_State.ADAPTING_OS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CloneJob_State.UNRECOGNIZED;
  }
}

export function cloneJob_StateToJSON(object: CloneJob_State): string {
  switch (object) {
    case CloneJob_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case CloneJob_State.PENDING:
      return "PENDING";
    case CloneJob_State.ACTIVE:
      return "ACTIVE";
    case CloneJob_State.FAILED:
      return "FAILED";
    case CloneJob_State.SUCCEEDED:
      return "SUCCEEDED";
    case CloneJob_State.CANCELLED:
      return "CANCELLED";
    case CloneJob_State.CANCELLING:
      return "CANCELLING";
    case CloneJob_State.ADAPTING_OS:
      return "ADAPTING_OS";
    case CloneJob_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** CloneStep holds information about the clone step progress. */
export interface CloneStep {
  /** Adapting OS step. */
  adaptingOs?:
    | AdaptingOSStep
    | undefined;
  /** Preparing VM disks step. */
  preparingVmDisks?:
    | PreparingVMDisksStep
    | undefined;
  /** Instantiating migrated VM step. */
  instantiatingMigratedVm?:
    | InstantiatingMigratedVMStep
    | undefined;
  /** The time the step has started. */
  startTime:
    | Date
    | undefined;
  /** The time the step has ended. */
  endTime: Date | undefined;
}

/** AdaptingOSStep contains specific step details. */
export interface AdaptingOSStep {
}

/** PreparingVMDisksStep contains specific step details. */
export interface PreparingVMDisksStep {
}

/** InstantiatingMigratedVMStep contains specific step details. */
export interface InstantiatingMigratedVMStep {
}

/**
 * CutoverJob message describes a cutover of a migrating VM. The CutoverJob is
 * the operation of shutting down the VM, creating a snapshot and
 * clonning the VM using the replicated snapshot.
 */
export interface CutoverJob {
  /** Output only. Details of the target VM in Compute Engine. */
  computeEngineTargetDetails?:
    | ComputeEngineTargetDetails
    | undefined;
  /**
   * Output only. The time the cutover job was created (as an API call, not when
   * it was actually created in the target).
   */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the cutover job had finished. */
  endTime:
    | Date
    | undefined;
  /** Output only. The name of the cutover job. */
  name: string;
  /** Output only. State of the cutover job. */
  state: CutoverJob_State;
  /** Output only. The time the state was last updated. */
  stateTime:
    | Date
    | undefined;
  /** Output only. The current progress in percentage of the cutover job. */
  progressPercent: number;
  /**
   * Output only. Provides details for the errors that led to the Cutover Job's
   * state.
   */
  error:
    | Status
    | undefined;
  /**
   * Output only. A message providing possible extra details about the current
   * state.
   */
  stateMessage: string;
  /** Output only. The cutover steps list representing its progress. */
  steps: CutoverStep[];
}

/** Possible states of the cutover job. */
export enum CutoverJob_State {
  /**
   * STATE_UNSPECIFIED - The state is unknown. This is used for API compatibility only and is not
   * used by the system.
   */
  STATE_UNSPECIFIED = 0,
  /** PENDING - The cutover job has not yet started. */
  PENDING = 1,
  /** FAILED - The cutover job finished with errors. */
  FAILED = 2,
  /** SUCCEEDED - The cutover job finished successfully. */
  SUCCEEDED = 3,
  /** CANCELLED - The cutover job was cancelled. */
  CANCELLED = 4,
  /** CANCELLING - The cutover job is being cancelled. */
  CANCELLING = 5,
  /** ACTIVE - The cutover job is active and running. */
  ACTIVE = 6,
  /** ADAPTING_OS - OS adaptation is running as part of the cutover job to generate license. */
  ADAPTING_OS = 7,
  UNRECOGNIZED = -1,
}

export function cutoverJob_StateFromJSON(object: any): CutoverJob_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return CutoverJob_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return CutoverJob_State.PENDING;
    case 2:
    case "FAILED":
      return CutoverJob_State.FAILED;
    case 3:
    case "SUCCEEDED":
      return CutoverJob_State.SUCCEEDED;
    case 4:
    case "CANCELLED":
      return CutoverJob_State.CANCELLED;
    case 5:
    case "CANCELLING":
      return CutoverJob_State.CANCELLING;
    case 6:
    case "ACTIVE":
      return CutoverJob_State.ACTIVE;
    case 7:
    case "ADAPTING_OS":
      return CutoverJob_State.ADAPTING_OS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CutoverJob_State.UNRECOGNIZED;
  }
}

export function cutoverJob_StateToJSON(object: CutoverJob_State): string {
  switch (object) {
    case CutoverJob_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case CutoverJob_State.PENDING:
      return "PENDING";
    case CutoverJob_State.FAILED:
      return "FAILED";
    case CutoverJob_State.SUCCEEDED:
      return "SUCCEEDED";
    case CutoverJob_State.CANCELLED:
      return "CANCELLED";
    case CutoverJob_State.CANCELLING:
      return "CANCELLING";
    case CutoverJob_State.ACTIVE:
      return "ACTIVE";
    case CutoverJob_State.ADAPTING_OS:
      return "ADAPTING_OS";
    case CutoverJob_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** CutoverStep holds information about the cutover step progress. */
export interface CutoverStep {
  /** A replication cycle prior cutover step. */
  previousReplicationCycle?:
    | ReplicationCycle
    | undefined;
  /** Shutting down VM step. */
  shuttingDownSourceVm?:
    | ShuttingDownSourceVMStep
    | undefined;
  /** Final sync step. */
  finalSync?:
    | ReplicationCycle
    | undefined;
  /** Preparing VM disks step. */
  preparingVmDisks?:
    | PreparingVMDisksStep
    | undefined;
  /** Instantiating migrated VM step. */
  instantiatingMigratedVm?:
    | InstantiatingMigratedVMStep
    | undefined;
  /** The time the step has started. */
  startTime:
    | Date
    | undefined;
  /** The time the step has ended. */
  endTime: Date | undefined;
}

/** ShuttingDownSourceVMStep contains specific step details. */
export interface ShuttingDownSourceVMStep {
}

/** Request message for 'CreateCloneJob' request. */
export interface CreateCloneJobRequest {
  /** Required. The Clone's parent. */
  parent: string;
  /** Required. The clone job identifier. */
  cloneJobId: string;
  /** Required. The clone request body. */
  cloneJob:
    | CloneJob
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for 'CancelCloneJob' request. */
export interface CancelCloneJobRequest {
  /** Required. The clone job id */
  name: string;
}

/** Response message for 'CancelCloneJob' request. */
export interface CancelCloneJobResponse {
}

/** Request message for 'ListCloneJobsRequest' request. */
export interface ListCloneJobsRequest {
  /** Required. The parent, which owns this collection of source VMs. */
  parent: string;
  /**
   * Optional. The maximum number of clone jobs to return. The service may
   * return fewer than this value. If unspecified, at most 500 clone jobs will
   * be returned. The maximum value is 1000; values above 1000 will be coerced
   * to 1000.
   */
  pageSize: number;
  /**
   * Required. A page token, received from a previous `ListCloneJobs` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListCloneJobs` must
   * match the call that provided the page token.
   */
  pageToken: string;
  /** Optional. The filter request. */
  filter: string;
  /** Optional. the order by fields for the result. */
  orderBy: string;
}

/** Response message for 'ListCloneJobs' request. */
export interface ListCloneJobsResponse {
  /** Output only. The list of clone jobs response. */
  cloneJobs: CloneJob[];
  /**
   * Output only. A token, which can be sent as `page_token` to retrieve the
   * next page. If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Output only. Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for 'GetCloneJob' request. */
export interface GetCloneJobRequest {
  /** Required. The name of the CloneJob. */
  name: string;
}

/**
 * Source message describes a specific vm migration Source resource. It contains
 * the source environment information.
 */
export interface Source {
  /** Vmware type source details. */
  vmware?:
    | VmwareSourceDetails
    | undefined;
  /** AWS type source details. */
  aws?:
    | AwsSourceDetails
    | undefined;
  /** Output only. The Source name. */
  name: string;
  /** Output only. The create time timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update time timestamp. */
  updateTime:
    | Date
    | undefined;
  /** The labels of the source. */
  labels: { [key: string]: string };
  /** User-provided description of the source. */
  description: string;
}

export interface Source_LabelsEntry {
  key: string;
  value: string;
}

/**
 * VmwareSourceDetails message describes a specific source details for the
 * vmware source type.
 */
export interface VmwareSourceDetails {
  /** The credentials username. */
  username: string;
  /**
   * Input only. The credentials password. This is write only and can not be
   * read in a GET operation.
   */
  password: string;
  /** The ip address of the vcenter this Source represents. */
  vcenterIp: string;
  /** The thumbprint representing the certificate for the vcenter. */
  thumbprint: string;
}

/**
 * AwsSourceDetails message describes a specific source details for the
 * AWS source type.
 */
export interface AwsSourceDetails {
  /** AWS Credentials using access key id and secret. */
  accessKeyCreds?:
    | AwsSourceDetails_AccessKeyCredentials
    | undefined;
  /** Immutable. The AWS region that the source VMs will be migrated from. */
  awsRegion: string;
  /** Output only. State of the source as determined by the health check. */
  state: AwsSourceDetails_State;
  /**
   * Output only. Provides details on the state of the Source in case of an
   * error.
   */
  error:
    | Status
    | undefined;
  /** AWS resource tags to limit the scope of the source inventory. */
  inventoryTagList: AwsSourceDetails_Tag[];
  /**
   * AWS security group names to limit the scope of the source
   * inventory.
   */
  inventorySecurityGroupNames: string[];
  /**
   * User specified tags to add to every M2VM generated resource in AWS.
   * These tags will be set in addition to the default tags that are set as part
   * of the migration process. The tags must not begin with the reserved prefix
   * `m2vm`.
   */
  migrationResourcesUserTags: { [key: string]: string };
  /**
   * Output only. The source's public IP. All communication initiated by this
   * source will originate from this IP.
   */
  publicIp: string;
}

/** The possible values of the state. */
export enum AwsSourceDetails_State {
  /**
   * STATE_UNSPECIFIED - The state is unknown. This is used for API compatibility only and is not
   * used by the system.
   */
  STATE_UNSPECIFIED = 0,
  /** PENDING - The state was not sampled by the health checks yet. */
  PENDING = 1,
  /**
   * FAILED - The source is available but might not be usable yet due to invalid
   * credentials or another reason.
   * The error message will contain further details.
   */
  FAILED = 2,
  /** ACTIVE - The source exists and its credentials were verified. */
  ACTIVE = 3,
  UNRECOGNIZED = -1,
}

export function awsSourceDetails_StateFromJSON(object: any): AwsSourceDetails_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return AwsSourceDetails_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return AwsSourceDetails_State.PENDING;
    case 2:
    case "FAILED":
      return AwsSourceDetails_State.FAILED;
    case 3:
    case "ACTIVE":
      return AwsSourceDetails_State.ACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AwsSourceDetails_State.UNRECOGNIZED;
  }
}

export function awsSourceDetails_StateToJSON(object: AwsSourceDetails_State): string {
  switch (object) {
    case AwsSourceDetails_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case AwsSourceDetails_State.PENDING:
      return "PENDING";
    case AwsSourceDetails_State.FAILED:
      return "FAILED";
    case AwsSourceDetails_State.ACTIVE:
      return "ACTIVE";
    case AwsSourceDetails_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message describing AWS Credentials using access key id and secret. */
export interface AwsSourceDetails_AccessKeyCredentials {
  /** AWS access key ID. */
  accessKeyId: string;
  /** Input only. AWS secret access key. */
  secretAccessKey: string;
}

/** Tag is an AWS tag representation. */
export interface AwsSourceDetails_Tag {
  /** Key of tag. */
  key: string;
  /** Value of tag. */
  value: string;
}

export interface AwsSourceDetails_MigrationResourcesUserTagsEntry {
  key: string;
  value: string;
}

/**
 * DatacenterConnector message describes a connector between the Source and
 * Google Cloud, which is installed on a vmware datacenter (an OVA vm installed
 * by the user) to connect the Datacenter to Google Cloud and support vm
 * migration data transfer.
 */
export interface DatacenterConnector {
  /**
   * Output only. The time the connector was created (as an API call, not when
   * it was actually installed).
   */
  createTime:
    | Date
    | undefined;
  /** Output only. The last time the connector was updated with an API call. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The connector's name. */
  name: string;
  /**
   * Immutable. A unique key for this connector. This key is internal to the OVA
   * connector and is supplied with its creation during the registration process
   * and can not be modified.
   */
  registrationId: string;
  /**
   * The service account to use in the connector when communicating with the
   * cloud.
   */
  serviceAccount: string;
  /**
   * The version running in the DatacenterConnector. This is supplied by the OVA
   * connector during the registration process and can not be modified.
   */
  version: string;
  /**
   * Output only. The communication channel between the datacenter connector and
   * Google Cloud.
   */
  bucket: string;
  /**
   * Output only. State of the DatacenterConnector, as determined by the health
   * checks.
   */
  state: DatacenterConnector_State;
  /** Output only. The time the state was last set. */
  stateTime:
    | Date
    | undefined;
  /**
   * Output only. Provides details on the state of the Datacenter Connector in
   * case of an error.
   */
  error:
    | Status
    | undefined;
  /**
   * Output only. Appliance OVA version.
   * This is the OVA which is manually installed by the user and contains the
   * infrastructure for the automatically updatable components on the appliance.
   */
  applianceInfrastructureVersion: string;
  /**
   * Output only. Appliance last installed update bundle version.
   * This is the version of the automatically updatable components on the
   * appliance.
   */
  applianceSoftwareVersion: string;
  /** Output only. The available versions for updating this appliance. */
  availableVersions:
    | AvailableUpdates
    | undefined;
  /** Output only. The status of the current / last upgradeAppliance operation. */
  upgradeStatus: UpgradeStatus | undefined;
}

/** The possible values of the state. */
export enum DatacenterConnector_State {
  /**
   * STATE_UNSPECIFIED - The state is unknown. This is used for API compatibility only and is not
   * used by the system.
   */
  STATE_UNSPECIFIED = 0,
  /** PENDING - The state was not sampled by the health checks yet. */
  PENDING = 1,
  /** OFFLINE - The source was sampled by health checks and is not available. */
  OFFLINE = 2,
  /**
   * FAILED - The source is available but might not be usable yet due to unvalidated
   * credentials or another reason. The credentials referred to are the ones
   * to the Source. The error message will contain further details.
   */
  FAILED = 3,
  /** ACTIVE - The source exists and its credentials were verified. */
  ACTIVE = 4,
  UNRECOGNIZED = -1,
}

export function datacenterConnector_StateFromJSON(object: any): DatacenterConnector_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return DatacenterConnector_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return DatacenterConnector_State.PENDING;
    case 2:
    case "OFFLINE":
      return DatacenterConnector_State.OFFLINE;
    case 3:
    case "FAILED":
      return DatacenterConnector_State.FAILED;
    case 4:
    case "ACTIVE":
      return DatacenterConnector_State.ACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatacenterConnector_State.UNRECOGNIZED;
  }
}

export function datacenterConnector_StateToJSON(object: DatacenterConnector_State): string {
  switch (object) {
    case DatacenterConnector_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case DatacenterConnector_State.PENDING:
      return "PENDING";
    case DatacenterConnector_State.OFFLINE:
      return "OFFLINE";
    case DatacenterConnector_State.FAILED:
      return "FAILED";
    case DatacenterConnector_State.ACTIVE:
      return "ACTIVE";
    case DatacenterConnector_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** UpgradeStatus contains information about upgradeAppliance operation. */
export interface UpgradeStatus {
  /** The version to upgrade to. */
  version: string;
  /** The state of the upgradeAppliance operation. */
  state: UpgradeStatus_State;
  /** Provides details on the state of the upgrade operation in case of an error. */
  error:
    | Status
    | undefined;
  /** The time the operation was started. */
  startTime:
    | Date
    | undefined;
  /** The version from which we upgraded. */
  previousVersion: string;
}

/** The possible values of the state. */
export enum UpgradeStatus_State {
  /** STATE_UNSPECIFIED - The state was not sampled by the health checks yet. */
  STATE_UNSPECIFIED = 0,
  /** RUNNING - The upgrade has started. */
  RUNNING = 1,
  /** FAILED - The upgrade failed. */
  FAILED = 2,
  /** SUCCEEDED - The upgrade finished successfully. */
  SUCCEEDED = 3,
  UNRECOGNIZED = -1,
}

export function upgradeStatus_StateFromJSON(object: any): UpgradeStatus_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return UpgradeStatus_State.STATE_UNSPECIFIED;
    case 1:
    case "RUNNING":
      return UpgradeStatus_State.RUNNING;
    case 2:
    case "FAILED":
      return UpgradeStatus_State.FAILED;
    case 3:
    case "SUCCEEDED":
      return UpgradeStatus_State.SUCCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UpgradeStatus_State.UNRECOGNIZED;
  }
}

export function upgradeStatus_StateToJSON(object: UpgradeStatus_State): string {
  switch (object) {
    case UpgradeStatus_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case UpgradeStatus_State.RUNNING:
      return "RUNNING";
    case UpgradeStatus_State.FAILED:
      return "FAILED";
    case UpgradeStatus_State.SUCCEEDED:
      return "SUCCEEDED";
    case UpgradeStatus_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Holds informatiom about the available versions for upgrade. */
export interface AvailableUpdates {
  /**
   * The newest deployable version of the appliance.
   * The current appliance can't be updated into this version, and the owner
   * must manually deploy this OVA to a new appliance.
   */
  newDeployableAppliance:
    | ApplianceVersion
    | undefined;
  /**
   * The latest version for in place update.
   * The current appliance can be updated to this version using the API or m4c
   * CLI.
   */
  inPlaceUpdate: ApplianceVersion | undefined;
}

/** Describes an appliance version. */
export interface ApplianceVersion {
  /** The appliance version. */
  version: string;
  /** A link for downloading the version. */
  uri: string;
  /** Determine whether it's critical to upgrade the appliance to this version. */
  critical: boolean;
  /** Link to a page that contains the version release notes. */
  releaseNotesUri: string;
}

/** Request message for 'ListSources' request. */
export interface ListSourcesRequest {
  /** Required. The parent, which owns this collection of sources. */
  parent: string;
  /**
   * Optional. The maximum number of sources to return. The service may return
   * fewer than this value. If unspecified, at most 500 sources will be
   * returned. The maximum value is 1000; values above 1000 will be coerced to
   * 1000.
   */
  pageSize: number;
  /**
   * Required. A page token, received from a previous `ListSources` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListSources` must
   * match the call that provided the page token.
   */
  pageToken: string;
  /** Optional. The filter request. */
  filter: string;
  /** Optional. the order by fields for the result. */
  orderBy: string;
}

/** Response message for 'ListSources' request. */
export interface ListSourcesResponse {
  /** Output only. The list of sources response. */
  sources: Source[];
  /**
   * Output only. A token, which can be sent as `page_token` to retrieve the
   * next page. If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Output only. Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for 'GetSource' request. */
export interface GetSourceRequest {
  /** Required. The Source name. */
  name: string;
}

/** Request message for 'CreateSource' request. */
export interface CreateSourceRequest {
  /** Required. The Source's parent. */
  parent: string;
  /** Required. The source identifier. */
  sourceId: string;
  /** Required. The create request body. */
  source:
    | Source
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Update message for 'UpdateSources' request. */
export interface UpdateSourceRequest {
  /**
   * Field mask is used to specify the fields to be overwritten in the
   * Source resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The update request body. */
  source:
    | Source
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for 'DeleteSource' request. */
export interface DeleteSourceRequest {
  /** Required. The Source name. */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [fetchInventory][google.cloud.vmmigration.v1.VmMigration.FetchInventory].
 */
export interface FetchInventoryRequest {
  /** Required. The name of the Source. */
  source: string;
  /**
   * If this flag is set to true, the source will be queried instead of using
   * cached results. Using this flag will make the call slower.
   */
  forceRefresh: boolean;
}

/** VmwareVmDetails describes a VM in vCenter. */
export interface VmwareVmDetails {
  /**
   * The VM's id in the source (note that this is not the MigratingVm's id).
   * This is the moref id of the VM.
   */
  vmId: string;
  /** The id of the vCenter's datacenter this VM is contained in. */
  datacenterId: string;
  /** The descriptive name of the vCenter's datacenter this VM is contained in. */
  datacenterDescription: string;
  /** The unique identifier of the VM in vCenter. */
  uuid: string;
  /** The display name of the VM. Note that this is not necessarily unique. */
  displayName: string;
  /** The power state of the VM at the moment list was taken. */
  powerState: VmwareVmDetails_PowerState;
  /** The number of cpus in the VM. */
  cpuCount: number;
  /** The size of the memory of the VM in MB. */
  memoryMb: number;
  /** The number of disks the VM has. */
  diskCount: number;
  /** The total size of the storage allocated to the VM in MB. */
  committedStorageMb: Long;
  /**
   * The VM's OS. See for example
   * https://vdc-repo.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html
   * for types of strings this might hold.
   */
  guestDescription: string;
  /** Output only. The VM Boot Option. */
  bootOption: VmwareVmDetails_BootOption;
}

/** Possible values for the power state of the VM. */
export enum VmwareVmDetails_PowerState {
  /** POWER_STATE_UNSPECIFIED - Power state is not specified. */
  POWER_STATE_UNSPECIFIED = 0,
  /** ON - The VM is turned ON. */
  ON = 1,
  /** OFF - The VM is turned OFF. */
  OFF = 2,
  /** SUSPENDED - The VM is suspended. This is similar to hibernation or sleep mode. */
  SUSPENDED = 3,
  UNRECOGNIZED = -1,
}

export function vmwareVmDetails_PowerStateFromJSON(object: any): VmwareVmDetails_PowerState {
  switch (object) {
    case 0:
    case "POWER_STATE_UNSPECIFIED":
      return VmwareVmDetails_PowerState.POWER_STATE_UNSPECIFIED;
    case 1:
    case "ON":
      return VmwareVmDetails_PowerState.ON;
    case 2:
    case "OFF":
      return VmwareVmDetails_PowerState.OFF;
    case 3:
    case "SUSPENDED":
      return VmwareVmDetails_PowerState.SUSPENDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VmwareVmDetails_PowerState.UNRECOGNIZED;
  }
}

export function vmwareVmDetails_PowerStateToJSON(object: VmwareVmDetails_PowerState): string {
  switch (object) {
    case VmwareVmDetails_PowerState.POWER_STATE_UNSPECIFIED:
      return "POWER_STATE_UNSPECIFIED";
    case VmwareVmDetails_PowerState.ON:
      return "ON";
    case VmwareVmDetails_PowerState.OFF:
      return "OFF";
    case VmwareVmDetails_PowerState.SUSPENDED:
      return "SUSPENDED";
    case VmwareVmDetails_PowerState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible values for vm boot option. */
export enum VmwareVmDetails_BootOption {
  /** BOOT_OPTION_UNSPECIFIED - The boot option is unknown. */
  BOOT_OPTION_UNSPECIFIED = 0,
  /** EFI - The boot option is EFI. */
  EFI = 1,
  /** BIOS - The boot option is BIOS. */
  BIOS = 2,
  UNRECOGNIZED = -1,
}

export function vmwareVmDetails_BootOptionFromJSON(object: any): VmwareVmDetails_BootOption {
  switch (object) {
    case 0:
    case "BOOT_OPTION_UNSPECIFIED":
      return VmwareVmDetails_BootOption.BOOT_OPTION_UNSPECIFIED;
    case 1:
    case "EFI":
      return VmwareVmDetails_BootOption.EFI;
    case 2:
    case "BIOS":
      return VmwareVmDetails_BootOption.BIOS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VmwareVmDetails_BootOption.UNRECOGNIZED;
  }
}

export function vmwareVmDetails_BootOptionToJSON(object: VmwareVmDetails_BootOption): string {
  switch (object) {
    case VmwareVmDetails_BootOption.BOOT_OPTION_UNSPECIFIED:
      return "BOOT_OPTION_UNSPECIFIED";
    case VmwareVmDetails_BootOption.EFI:
      return "EFI";
    case VmwareVmDetails_BootOption.BIOS:
      return "BIOS";
    case VmwareVmDetails_BootOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AwsVmDetails describes a VM in AWS. */
export interface AwsVmDetails {
  /** The VM ID in AWS. */
  vmId: string;
  /** The display name of the VM. Note that this value is not necessarily unique. */
  displayName: string;
  /** The id of the AWS's source this VM is connected to. */
  sourceId: string;
  /** The descriptive name of the AWS's source this VM is connected to. */
  sourceDescription: string;
  /** Output only. The power state of the VM at the moment list was taken. */
  powerState: AwsVmDetails_PowerState;
  /** The number of cpus the VM has. */
  cpuCount: number;
  /** The memory size of the VM in MB. */
  memoryMb: number;
  /** The number of disks the VM has. */
  diskCount: number;
  /** The total size of the storage allocated to the VM in MB. */
  committedStorageMb: Long;
  /** The VM's OS. */
  osDescription: string;
  /** The VM Boot Option. */
  bootOption: AwsVmDetails_BootOption;
  /** The instance type of the VM. */
  instanceType: string;
  /** The VPC ID the VM belongs to. */
  vpcId: string;
  /** The security groups the VM belongs to. */
  securityGroups: AwsSecurityGroup[];
  /** The tags of the VM. */
  tags: { [key: string]: string };
  /** The AWS zone of the VM. */
  zone: string;
  /** The virtualization type. */
  virtualizationType: AwsVmDetails_VmVirtualizationType;
  /** The CPU architecture. */
  architecture: AwsVmDetails_VmArchitecture;
}

/** Possible values for the power state of the VM. */
export enum AwsVmDetails_PowerState {
  /** POWER_STATE_UNSPECIFIED - Power state is not specified. */
  POWER_STATE_UNSPECIFIED = 0,
  /** ON - The VM is turned on. */
  ON = 1,
  /** OFF - The VM is turned off. */
  OFF = 2,
  /**
   * SUSPENDED - The VM is suspended. This is similar to hibernation or sleep
   * mode.
   */
  SUSPENDED = 3,
  /** PENDING - The VM is starting. */
  PENDING = 4,
  UNRECOGNIZED = -1,
}

export function awsVmDetails_PowerStateFromJSON(object: any): AwsVmDetails_PowerState {
  switch (object) {
    case 0:
    case "POWER_STATE_UNSPECIFIED":
      return AwsVmDetails_PowerState.POWER_STATE_UNSPECIFIED;
    case 1:
    case "ON":
      return AwsVmDetails_PowerState.ON;
    case 2:
    case "OFF":
      return AwsVmDetails_PowerState.OFF;
    case 3:
    case "SUSPENDED":
      return AwsVmDetails_PowerState.SUSPENDED;
    case 4:
    case "PENDING":
      return AwsVmDetails_PowerState.PENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AwsVmDetails_PowerState.UNRECOGNIZED;
  }
}

export function awsVmDetails_PowerStateToJSON(object: AwsVmDetails_PowerState): string {
  switch (object) {
    case AwsVmDetails_PowerState.POWER_STATE_UNSPECIFIED:
      return "POWER_STATE_UNSPECIFIED";
    case AwsVmDetails_PowerState.ON:
      return "ON";
    case AwsVmDetails_PowerState.OFF:
      return "OFF";
    case AwsVmDetails_PowerState.SUSPENDED:
      return "SUSPENDED";
    case AwsVmDetails_PowerState.PENDING:
      return "PENDING";
    case AwsVmDetails_PowerState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The possible values for the vm boot option. */
export enum AwsVmDetails_BootOption {
  /** BOOT_OPTION_UNSPECIFIED - The boot option is unknown. */
  BOOT_OPTION_UNSPECIFIED = 0,
  /** EFI - The boot option is UEFI. */
  EFI = 1,
  /** BIOS - The boot option is LEGACY-BIOS. */
  BIOS = 2,
  UNRECOGNIZED = -1,
}

export function awsVmDetails_BootOptionFromJSON(object: any): AwsVmDetails_BootOption {
  switch (object) {
    case 0:
    case "BOOT_OPTION_UNSPECIFIED":
      return AwsVmDetails_BootOption.BOOT_OPTION_UNSPECIFIED;
    case 1:
    case "EFI":
      return AwsVmDetails_BootOption.EFI;
    case 2:
    case "BIOS":
      return AwsVmDetails_BootOption.BIOS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AwsVmDetails_BootOption.UNRECOGNIZED;
  }
}

export function awsVmDetails_BootOptionToJSON(object: AwsVmDetails_BootOption): string {
  switch (object) {
    case AwsVmDetails_BootOption.BOOT_OPTION_UNSPECIFIED:
      return "BOOT_OPTION_UNSPECIFIED";
    case AwsVmDetails_BootOption.EFI:
      return "EFI";
    case AwsVmDetails_BootOption.BIOS:
      return "BIOS";
    case AwsVmDetails_BootOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible values for the virtualization types of the VM. */
export enum AwsVmDetails_VmVirtualizationType {
  /** VM_VIRTUALIZATION_TYPE_UNSPECIFIED - The virtualization type is unknown. */
  VM_VIRTUALIZATION_TYPE_UNSPECIFIED = 0,
  /** HVM - The virtualziation type is HVM. */
  HVM = 1,
  /** PARAVIRTUAL - The virtualziation type is PARAVIRTUAL. */
  PARAVIRTUAL = 2,
  UNRECOGNIZED = -1,
}

export function awsVmDetails_VmVirtualizationTypeFromJSON(object: any): AwsVmDetails_VmVirtualizationType {
  switch (object) {
    case 0:
    case "VM_VIRTUALIZATION_TYPE_UNSPECIFIED":
      return AwsVmDetails_VmVirtualizationType.VM_VIRTUALIZATION_TYPE_UNSPECIFIED;
    case 1:
    case "HVM":
      return AwsVmDetails_VmVirtualizationType.HVM;
    case 2:
    case "PARAVIRTUAL":
      return AwsVmDetails_VmVirtualizationType.PARAVIRTUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AwsVmDetails_VmVirtualizationType.UNRECOGNIZED;
  }
}

export function awsVmDetails_VmVirtualizationTypeToJSON(object: AwsVmDetails_VmVirtualizationType): string {
  switch (object) {
    case AwsVmDetails_VmVirtualizationType.VM_VIRTUALIZATION_TYPE_UNSPECIFIED:
      return "VM_VIRTUALIZATION_TYPE_UNSPECIFIED";
    case AwsVmDetails_VmVirtualizationType.HVM:
      return "HVM";
    case AwsVmDetails_VmVirtualizationType.PARAVIRTUAL:
      return "PARAVIRTUAL";
    case AwsVmDetails_VmVirtualizationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible values for the architectures of the VM. */
export enum AwsVmDetails_VmArchitecture {
  /** VM_ARCHITECTURE_UNSPECIFIED - The architecture is unknown. */
  VM_ARCHITECTURE_UNSPECIFIED = 0,
  /** I386 - The architecture is I386. */
  I386 = 1,
  /** X86_64 - The architecture is X86_64. */
  X86_64 = 2,
  /** ARM64 - The architecture is ARM64. */
  ARM64 = 3,
  /** X86_64_MAC - The architecture is X86_64_MAC. */
  X86_64_MAC = 4,
  UNRECOGNIZED = -1,
}

export function awsVmDetails_VmArchitectureFromJSON(object: any): AwsVmDetails_VmArchitecture {
  switch (object) {
    case 0:
    case "VM_ARCHITECTURE_UNSPECIFIED":
      return AwsVmDetails_VmArchitecture.VM_ARCHITECTURE_UNSPECIFIED;
    case 1:
    case "I386":
      return AwsVmDetails_VmArchitecture.I386;
    case 2:
    case "X86_64":
      return AwsVmDetails_VmArchitecture.X86_64;
    case 3:
    case "ARM64":
      return AwsVmDetails_VmArchitecture.ARM64;
    case 4:
    case "X86_64_MAC":
      return AwsVmDetails_VmArchitecture.X86_64_MAC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AwsVmDetails_VmArchitecture.UNRECOGNIZED;
  }
}

export function awsVmDetails_VmArchitectureToJSON(object: AwsVmDetails_VmArchitecture): string {
  switch (object) {
    case AwsVmDetails_VmArchitecture.VM_ARCHITECTURE_UNSPECIFIED:
      return "VM_ARCHITECTURE_UNSPECIFIED";
    case AwsVmDetails_VmArchitecture.I386:
      return "I386";
    case AwsVmDetails_VmArchitecture.X86_64:
      return "X86_64";
    case AwsVmDetails_VmArchitecture.ARM64:
      return "ARM64";
    case AwsVmDetails_VmArchitecture.X86_64_MAC:
      return "X86_64_MAC";
    case AwsVmDetails_VmArchitecture.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AwsVmDetails_TagsEntry {
  key: string;
  value: string;
}

/** AwsSecurityGroup describes a security group of an AWS VM. */
export interface AwsSecurityGroup {
  /** The AWS security group id. */
  id: string;
  /** The AWS security group name. */
  name: string;
}

/** VmwareVmsDetails describes VMs in vCenter. */
export interface VmwareVmsDetails {
  /** The details of the vmware VMs. */
  details: VmwareVmDetails[];
}

/** AWSVmsDetails describes VMs in AWS. */
export interface AwsVmsDetails {
  /** The details of the AWS VMs. */
  details: AwsVmDetails[];
}

/**
 * Response message for
 * [fetchInventory][google.cloud.vmmigration.v1.VmMigration.FetchInventory].
 */
export interface FetchInventoryResponse {
  /** The description of the VMs in a Source of type Vmware. */
  vmwareVms?:
    | VmwareVmsDetails
    | undefined;
  /** The description of the VMs in a Source of type AWS. */
  awsVms?:
    | AwsVmsDetails
    | undefined;
  /**
   * Output only. The timestamp when the source was last queried (if the result
   * is from the cache).
   */
  updateTime: Date | undefined;
}

/**
 * Utilization report details the utilization (CPU, memory, etc.) of selected
 * source VMs.
 */
export interface UtilizationReport {
  /** Output only. The report unique name. */
  name: string;
  /** The report display name, as assigned by the user. */
  displayName: string;
  /** Output only. Current state of the report. */
  state: UtilizationReport_State;
  /** Output only. The time the state was last set. */
  stateTime:
    | Date
    | undefined;
  /**
   * Output only. Provides details on the state of the report in case of an
   * error.
   */
  error:
    | Status
    | undefined;
  /**
   * Output only. The time the report was created (this refers to the time of
   * the request, not the time the report creation completed).
   */
  createTime:
    | Date
    | undefined;
  /** Time frame of the report. */
  timeFrame: UtilizationReport_TimeFrame;
  /**
   * Output only. The point in time when the time frame ends. Notice that the
   * time frame is counted backwards. For instance if the "frame_end_time" value
   * is 2021/01/20 and the time frame is WEEK then the report covers the week
   * between 2021/01/20 and 2021/01/14.
   */
  frameEndTime:
    | Date
    | undefined;
  /** Output only. Total number of VMs included in the report. */
  vmCount: number;
  /**
   * List of utilization information per VM.
   * When sent as part of the request, the "vm_id" field is used in order to
   * specify which VMs to include in the report. In that case all other fields
   * are ignored.
   */
  vms: VmUtilizationInfo[];
}

/** Utilization report state. */
export enum UtilizationReport_State {
  /** STATE_UNSPECIFIED - The state is unknown. This value is not in use. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The report is in the making. */
  CREATING = 1,
  /** SUCCEEDED - Report creation completed successfully. */
  SUCCEEDED = 2,
  /** FAILED - Report creation failed. */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function utilizationReport_StateFromJSON(object: any): UtilizationReport_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return UtilizationReport_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return UtilizationReport_State.CREATING;
    case 2:
    case "SUCCEEDED":
      return UtilizationReport_State.SUCCEEDED;
    case 3:
    case "FAILED":
      return UtilizationReport_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UtilizationReport_State.UNRECOGNIZED;
  }
}

export function utilizationReport_StateToJSON(object: UtilizationReport_State): string {
  switch (object) {
    case UtilizationReport_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case UtilizationReport_State.CREATING:
      return "CREATING";
    case UtilizationReport_State.SUCCEEDED:
      return "SUCCEEDED";
    case UtilizationReport_State.FAILED:
      return "FAILED";
    case UtilizationReport_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Report time frame options. */
export enum UtilizationReport_TimeFrame {
  /** TIME_FRAME_UNSPECIFIED - The time frame was not specified and will default to WEEK. */
  TIME_FRAME_UNSPECIFIED = 0,
  /** WEEK - One week. */
  WEEK = 1,
  /** MONTH - One month. */
  MONTH = 2,
  /** YEAR - One year. */
  YEAR = 3,
  UNRECOGNIZED = -1,
}

export function utilizationReport_TimeFrameFromJSON(object: any): UtilizationReport_TimeFrame {
  switch (object) {
    case 0:
    case "TIME_FRAME_UNSPECIFIED":
      return UtilizationReport_TimeFrame.TIME_FRAME_UNSPECIFIED;
    case 1:
    case "WEEK":
      return UtilizationReport_TimeFrame.WEEK;
    case 2:
    case "MONTH":
      return UtilizationReport_TimeFrame.MONTH;
    case 3:
    case "YEAR":
      return UtilizationReport_TimeFrame.YEAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UtilizationReport_TimeFrame.UNRECOGNIZED;
  }
}

export function utilizationReport_TimeFrameToJSON(object: UtilizationReport_TimeFrame): string {
  switch (object) {
    case UtilizationReport_TimeFrame.TIME_FRAME_UNSPECIFIED:
      return "TIME_FRAME_UNSPECIFIED";
    case UtilizationReport_TimeFrame.WEEK:
      return "WEEK";
    case UtilizationReport_TimeFrame.MONTH:
      return "MONTH";
    case UtilizationReport_TimeFrame.YEAR:
      return "YEAR";
    case UtilizationReport_TimeFrame.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Utilization information of a single VM. */
export interface VmUtilizationInfo {
  /** The description of the VM in a Source of type Vmware. */
  vmwareVmDetails?:
    | VmwareVmDetails
    | undefined;
  /** The VM's ID in the source. */
  vmId: string;
  /** Utilization metrics for this VM. */
  utilization: VmUtilizationMetrics | undefined;
}

/** Utilization metrics values for a single VM. */
export interface VmUtilizationMetrics {
  /** Max CPU usage, percent. */
  cpuMaxPercent: number;
  /** Average CPU usage, percent. */
  cpuAveragePercent: number;
  /** Max memory usage, percent. */
  memoryMaxPercent: number;
  /** Average memory usage, percent. */
  memoryAveragePercent: number;
  /** Max disk IO rate, in kilobytes per second. */
  diskIoRateMaxKbps: Long;
  /** Average disk IO rate, in kilobytes per second. */
  diskIoRateAverageKbps: Long;
  /**
   * Max network throughput (combined transmit-rates and receive-rates), in
   * kilobytes per second.
   */
  networkThroughputMaxKbps: Long;
  /**
   * Average network throughput (combined transmit-rates and receive-rates), in
   * kilobytes per second.
   */
  networkThroughputAverageKbps: Long;
}

/** Request message for 'ListUtilizationReports' request. */
export interface ListUtilizationReportsRequest {
  /** Required. The Utilization Reports parent. */
  parent: string;
  /**
   * Optional. The level of details of each report.
   * Defaults to BASIC.
   */
  view: UtilizationReportView;
  /**
   * Optional. The maximum number of reports to return. The service may return
   * fewer than this value. If unspecified, at most 500 reports will be
   * returned. The maximum value is 1000; values above 1000 will be coerced to
   * 1000.
   */
  pageSize: number;
  /**
   * Required. A page token, received from a previous `ListUtilizationReports`
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListUtilizationReports`
   * must match the call that provided the page token.
   */
  pageToken: string;
  /** Optional. The filter request. */
  filter: string;
  /** Optional. the order by fields for the result. */
  orderBy: string;
}

/** Response message for 'ListUtilizationReports' request. */
export interface ListUtilizationReportsResponse {
  /** Output only. The list of reports. */
  utilizationReports: UtilizationReport[];
  /**
   * Output only. A token, which can be sent as `page_token` to retrieve the
   * next page. If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Output only. Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for 'GetUtilizationReport' request. */
export interface GetUtilizationReportRequest {
  /** Required. The Utilization Report name. */
  name: string;
  /**
   * Optional. The level of details of the report.
   * Defaults to FULL
   */
  view: UtilizationReportView;
}

/** Request message for 'CreateUtilizationReport' request. */
export interface CreateUtilizationReportRequest {
  /** Required. The Utilization Report's parent. */
  parent: string;
  /** Required. The report to create. */
  utilizationReport:
    | UtilizationReport
    | undefined;
  /**
   * Required. The ID to use for the report, which will become the final
   * component of the reports's resource name.
   *
   * This value maximum length is 63 characters, and valid characters
   * are /[a-z][0-9]-/. It must start with an english letter and must not
   * end with a hyphen.
   */
  utilizationReportId: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for 'DeleteUtilizationReport' request. */
export interface DeleteUtilizationReportRequest {
  /** Required. The Utilization Report name. */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Response message for 'ListDatacenterConnectors' request. */
export interface ListDatacenterConnectorsResponse {
  /** Output only. The list of sources response. */
  datacenterConnectors: DatacenterConnector[];
  /**
   * Output only. A token, which can be sent as `page_token` to retrieve the
   * next page. If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Output only. Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for 'GetDatacenterConnector' request. */
export interface GetDatacenterConnectorRequest {
  /** Required. The name of the DatacenterConnector. */
  name: string;
}

/** Request message for 'CreateDatacenterConnector' request. */
export interface CreateDatacenterConnectorRequest {
  /**
   * Required. The DatacenterConnector's parent.
   * Required. The Source in where the new DatacenterConnector will be created.
   * For example:
   * `projects/my-project/locations/us-central1/sources/my-source`
   */
  parent: string;
  /** Required. The datacenterConnector identifier. */
  datacenterConnectorId: string;
  /** Required. The create request body. */
  datacenterConnector:
    | DatacenterConnector
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for 'DeleteDatacenterConnector' request. */
export interface DeleteDatacenterConnectorRequest {
  /** Required. The DatacenterConnector name. */
  name: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for 'UpgradeAppliance' request. */
export interface UpgradeApplianceRequest {
  /** Required. The DatacenterConnector name. */
  datacenterConnector: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Response message for 'UpgradeAppliance' request. */
export interface UpgradeApplianceResponse {
}

/** Request message for 'ListDatacenterConnectors' request. */
export interface ListDatacenterConnectorsRequest {
  /** Required. The parent, which owns this collection of connectors. */
  parent: string;
  /**
   * Optional. The maximum number of connectors to return. The service may
   * return fewer than this value. If unspecified, at most 500 sources will be
   * returned. The maximum value is 1000; values above 1000 will be coerced to
   * 1000.
   */
  pageSize: number;
  /**
   * Required. A page token, received from a previous `ListDatacenterConnectors`
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListDatacenterConnectors` must match the call that provided the page
   * token.
   */
  pageToken: string;
  /** Optional. The filter request. */
  filter: string;
  /** Optional. the order by fields for the result. */
  orderBy: string;
}

/**
 * ComputeEngineTargetDefaults is a collection of details for creating a VM in a
 * target Compute Engine project.
 */
export interface ComputeEngineTargetDefaults {
  /** The name of the VM to create. */
  vmName: string;
  /**
   * The full path of the resource of type TargetProject which represents the
   * Compute Engine project in which to create this VM.
   */
  targetProject: string;
  /** The zone in which to create the VM. */
  zone: string;
  /** The machine type series to create the VM with. */
  machineTypeSeries: string;
  /** The machine type to create the VM with. */
  machineType: string;
  /** A map of network tags to associate with the VM. */
  networkTags: string[];
  /** List of NICs connected to this VM. */
  networkInterfaces: NetworkInterface[];
  /** The service account to associate the VM with. */
  serviceAccount: string;
  /** The disk type to use in the VM. */
  diskType: ComputeEngineDiskType;
  /** A map of labels to associate with the VM. */
  labels: { [key: string]: string };
  /** The license type to use in OS adaptation. */
  licenseType: ComputeEngineLicenseType;
  /** Output only. The OS license returned from the adaptation module report. */
  appliedLicense:
    | AppliedLicense
    | undefined;
  /** Compute instance scheduling information (if empty default is used). */
  computeScheduling:
    | ComputeScheduling
    | undefined;
  /**
   * Defines whether the instance has Secure Boot enabled.
   * This can be set to true only if the vm boot option is EFI.
   */
  secureBoot: boolean;
  /** Output only. The VM Boot Option, as set in the source vm. */
  bootOption: ComputeEngineBootOption;
  /** The metadata key/value pairs to assign to the VM. */
  metadata: { [key: string]: string };
  /** Additional licenses to assign to the VM. */
  additionalLicenses: string[];
  /** The hostname to assign to the VM. */
  hostname: string;
}

export interface ComputeEngineTargetDefaults_LabelsEntry {
  key: string;
  value: string;
}

export interface ComputeEngineTargetDefaults_MetadataEntry {
  key: string;
  value: string;
}

/**
 * ComputeEngineTargetDetails is a collection of details for creating a VM in a
 * target Compute Engine project.
 */
export interface ComputeEngineTargetDetails {
  /** The name of the VM to create. */
  vmName: string;
  /** The Google Cloud target project ID or project name. */
  project: string;
  /** The zone in which to create the VM. */
  zone: string;
  /** The machine type series to create the VM with. */
  machineTypeSeries: string;
  /** The machine type to create the VM with. */
  machineType: string;
  /** A map of network tags to associate with the VM. */
  networkTags: string[];
  /** List of NICs connected to this VM. */
  networkInterfaces: NetworkInterface[];
  /** The service account to associate the VM with. */
  serviceAccount: string;
  /** The disk type to use in the VM. */
  diskType: ComputeEngineDiskType;
  /** A map of labels to associate with the VM. */
  labels: { [key: string]: string };
  /** The license type to use in OS adaptation. */
  licenseType: ComputeEngineLicenseType;
  /** The OS license returned from the adaptation module report. */
  appliedLicense:
    | AppliedLicense
    | undefined;
  /** Compute instance scheduling information (if empty default is used). */
  computeScheduling:
    | ComputeScheduling
    | undefined;
  /**
   * Defines whether the instance has Secure Boot enabled.
   * This can be set to true only if the vm boot option is EFI.
   */
  secureBoot: boolean;
  /** The VM Boot Option, as set in the source vm. */
  bootOption: ComputeEngineBootOption;
  /** The metadata key/value pairs to assign to the VM. */
  metadata: { [key: string]: string };
  /** Additional licenses to assign to the VM. */
  additionalLicenses: string[];
  /** The hostname to assign to the VM. */
  hostname: string;
}

export interface ComputeEngineTargetDetails_LabelsEntry {
  key: string;
  value: string;
}

export interface ComputeEngineTargetDetails_MetadataEntry {
  key: string;
  value: string;
}

/** NetworkInterface represents a NIC of a VM. */
export interface NetworkInterface {
  /** The network to connect the NIC to. */
  network: string;
  /** The subnetwork to connect the NIC to. */
  subnetwork: string;
  /**
   * The internal IP to define in the NIC.
   * The formats accepted are: `ephemeral` \ ipv4 address \ a named address
   * resource full path.
   */
  internalIp: string;
  /** The external IP to define in the NIC. */
  externalIp: string;
}

/** AppliedLicense holds the license data returned by adaptation module report. */
export interface AppliedLicense {
  /** The license type that was used in OS adaptation. */
  type: AppliedLicense_Type;
  /** The OS license returned from the adaptation module's report. */
  osLicense: string;
}

/** License types used in OS adaptation. */
export enum AppliedLicense_Type {
  /** TYPE_UNSPECIFIED - Unspecified license for the OS. */
  TYPE_UNSPECIFIED = 0,
  /** NONE - No license available for the OS. */
  NONE = 1,
  /** PAYG - The license type is Pay As You Go license type. */
  PAYG = 2,
  /** BYOL - The license type is Bring Your Own License type. */
  BYOL = 3,
  UNRECOGNIZED = -1,
}

export function appliedLicense_TypeFromJSON(object: any): AppliedLicense_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return AppliedLicense_Type.TYPE_UNSPECIFIED;
    case 1:
    case "NONE":
      return AppliedLicense_Type.NONE;
    case 2:
    case "PAYG":
      return AppliedLicense_Type.PAYG;
    case 3:
    case "BYOL":
      return AppliedLicense_Type.BYOL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AppliedLicense_Type.UNRECOGNIZED;
  }
}

export function appliedLicense_TypeToJSON(object: AppliedLicense_Type): string {
  switch (object) {
    case AppliedLicense_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case AppliedLicense_Type.NONE:
      return "NONE";
    case AppliedLicense_Type.PAYG:
      return "PAYG";
    case AppliedLicense_Type.BYOL:
      return "BYOL";
    case AppliedLicense_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Node Affinity: the configuration of desired nodes onto which this Instance
 * could be scheduled. Based on
 * https://cloud.google.com/compute/docs/reference/rest/v1/instances/setScheduling
 */
export interface SchedulingNodeAffinity {
  /** The label key of Node resource to reference. */
  key: string;
  /**
   * The operator to use for the node resources specified in the `values`
   * parameter.
   */
  operator: SchedulingNodeAffinity_Operator;
  /** Corresponds to the label values of Node resource. */
  values: string[];
}

/**
 * Possible types of node selection operators. Valid operators are IN for
 * affinity and NOT_IN for anti-affinity.
 */
export enum SchedulingNodeAffinity_Operator {
  /** OPERATOR_UNSPECIFIED - An unknown, unexpected behavior. */
  OPERATOR_UNSPECIFIED = 0,
  /** IN - The node resource group should be in these resources affinity. */
  IN = 1,
  /** NOT_IN - The node resource group should not be in these resources affinity. */
  NOT_IN = 2,
  UNRECOGNIZED = -1,
}

export function schedulingNodeAffinity_OperatorFromJSON(object: any): SchedulingNodeAffinity_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return SchedulingNodeAffinity_Operator.OPERATOR_UNSPECIFIED;
    case 1:
    case "IN":
      return SchedulingNodeAffinity_Operator.IN;
    case 2:
    case "NOT_IN":
      return SchedulingNodeAffinity_Operator.NOT_IN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SchedulingNodeAffinity_Operator.UNRECOGNIZED;
  }
}

export function schedulingNodeAffinity_OperatorToJSON(object: SchedulingNodeAffinity_Operator): string {
  switch (object) {
    case SchedulingNodeAffinity_Operator.OPERATOR_UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case SchedulingNodeAffinity_Operator.IN:
      return "IN";
    case SchedulingNodeAffinity_Operator.NOT_IN:
      return "NOT_IN";
    case SchedulingNodeAffinity_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Scheduling information for VM on maintenance/restart behaviour and
 * node allocation in sole tenant nodes.
 */
export interface ComputeScheduling {
  /**
   * How the instance should behave when the host machine undergoes
   * maintenance that may temporarily impact instance performance.
   */
  onHostMaintenance: ComputeScheduling_OnHostMaintenance;
  /**
   * Whether the Instance should be automatically restarted whenever it is
   * terminated by Compute Engine (not terminated by user).
   * This configuration is identical to `automaticRestart` field in Compute
   * Engine create instance under scheduling.
   * It was changed to an enum (instead of a boolean) to match the default
   * value in Compute Engine which is automatic restart.
   */
  restartType: ComputeScheduling_RestartType;
  /**
   * A set of node affinity and anti-affinity configurations for sole tenant
   * nodes.
   */
  nodeAffinities: SchedulingNodeAffinity[];
  /**
   * The minimum number of virtual CPUs this instance will consume when
   * running on a sole-tenant node. Ignored if no node_affinites are
   * configured.
   */
  minNodeCpus: number;
}

export enum ComputeScheduling_OnHostMaintenance {
  /** ON_HOST_MAINTENANCE_UNSPECIFIED - An unknown, unexpected behavior. */
  ON_HOST_MAINTENANCE_UNSPECIFIED = 0,
  /** TERMINATE - Terminate the instance when the host machine undergoes maintenance. */
  TERMINATE = 1,
  /** MIGRATE - Migrate the instance when the host machine undergoes maintenance. */
  MIGRATE = 2,
  UNRECOGNIZED = -1,
}

export function computeScheduling_OnHostMaintenanceFromJSON(object: any): ComputeScheduling_OnHostMaintenance {
  switch (object) {
    case 0:
    case "ON_HOST_MAINTENANCE_UNSPECIFIED":
      return ComputeScheduling_OnHostMaintenance.ON_HOST_MAINTENANCE_UNSPECIFIED;
    case 1:
    case "TERMINATE":
      return ComputeScheduling_OnHostMaintenance.TERMINATE;
    case 2:
    case "MIGRATE":
      return ComputeScheduling_OnHostMaintenance.MIGRATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComputeScheduling_OnHostMaintenance.UNRECOGNIZED;
  }
}

export function computeScheduling_OnHostMaintenanceToJSON(object: ComputeScheduling_OnHostMaintenance): string {
  switch (object) {
    case ComputeScheduling_OnHostMaintenance.ON_HOST_MAINTENANCE_UNSPECIFIED:
      return "ON_HOST_MAINTENANCE_UNSPECIFIED";
    case ComputeScheduling_OnHostMaintenance.TERMINATE:
      return "TERMINATE";
    case ComputeScheduling_OnHostMaintenance.MIGRATE:
      return "MIGRATE";
    case ComputeScheduling_OnHostMaintenance.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Defines whether the Instance should be automatically restarted whenever
 * it is terminated by Compute Engine (not terminated by user).
 */
export enum ComputeScheduling_RestartType {
  /** RESTART_TYPE_UNSPECIFIED - Unspecified behavior. This will use the default. */
  RESTART_TYPE_UNSPECIFIED = 0,
  /**
   * AUTOMATIC_RESTART - The Instance should be automatically restarted whenever it is
   * terminated by Compute Engine.
   */
  AUTOMATIC_RESTART = 1,
  /**
   * NO_AUTOMATIC_RESTART - The Instance isn't automatically restarted whenever it is
   * terminated by Compute Engine.
   */
  NO_AUTOMATIC_RESTART = 2,
  UNRECOGNIZED = -1,
}

export function computeScheduling_RestartTypeFromJSON(object: any): ComputeScheduling_RestartType {
  switch (object) {
    case 0:
    case "RESTART_TYPE_UNSPECIFIED":
      return ComputeScheduling_RestartType.RESTART_TYPE_UNSPECIFIED;
    case 1:
    case "AUTOMATIC_RESTART":
      return ComputeScheduling_RestartType.AUTOMATIC_RESTART;
    case 2:
    case "NO_AUTOMATIC_RESTART":
      return ComputeScheduling_RestartType.NO_AUTOMATIC_RESTART;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComputeScheduling_RestartType.UNRECOGNIZED;
  }
}

export function computeScheduling_RestartTypeToJSON(object: ComputeScheduling_RestartType): string {
  switch (object) {
    case ComputeScheduling_RestartType.RESTART_TYPE_UNSPECIFIED:
      return "RESTART_TYPE_UNSPECIFIED";
    case ComputeScheduling_RestartType.AUTOMATIC_RESTART:
      return "AUTOMATIC_RESTART";
    case ComputeScheduling_RestartType.NO_AUTOMATIC_RESTART:
      return "NO_AUTOMATIC_RESTART";
    case ComputeScheduling_RestartType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A policy for scheduling replications. */
export interface SchedulePolicy {
  /** The idle duration between replication stages. */
  idleDuration:
    | Duration
    | undefined;
  /**
   * A flag to indicate whether to skip OS adaptation during the replication
   * sync. OS adaptation is a process where the VM's operating system undergoes
   * changes and adaptations to fully function on Compute Engine.
   */
  skipOsAdaptation: boolean;
}

/** Request message for 'CreateMigratingVm' request. */
export interface CreateMigratingVmRequest {
  /** Required. The MigratingVm's parent. */
  parent: string;
  /** Required. The migratingVm identifier. */
  migratingVmId: string;
  /** Required. The create request body. */
  migratingVm:
    | MigratingVm
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for 'LisMigratingVmsRequest' request. */
export interface ListMigratingVmsRequest {
  /** Required. The parent, which owns this collection of MigratingVms. */
  parent: string;
  /**
   * Optional. The maximum number of migrating VMs to return. The service may
   * return fewer than this value. If unspecified, at most 500 migrating VMs
   * will be returned. The maximum value is 1000; values above 1000 will be
   * coerced to 1000.
   */
  pageSize: number;
  /**
   * Required. A page token, received from a previous `ListMigratingVms` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListMigratingVms`
   * must match the call that provided the page token.
   */
  pageToken: string;
  /** Optional. The filter request. */
  filter: string;
  /** Optional. the order by fields for the result. */
  orderBy: string;
  /** Optional. The level of details of each migrating VM. */
  view: MigratingVmView;
}

/** Response message for 'ListMigratingVms' request. */
export interface ListMigratingVmsResponse {
  /** Output only. The list of Migrating VMs response. */
  migratingVms: MigratingVm[];
  /**
   * Output only. A token, which can be sent as `page_token` to retrieve the
   * next page. If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Output only. Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for 'GetMigratingVm' request. */
export interface GetMigratingVmRequest {
  /** Required. The name of the MigratingVm. */
  name: string;
  /** Optional. The level of details of the migrating VM. */
  view: MigratingVmView;
}

/** Request message for 'UpdateMigratingVm' request. */
export interface UpdateMigratingVmRequest {
  /**
   * Field mask is used to specify the fields to be overwritten in the
   * MigratingVm resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The update request body. */
  migratingVm:
    | MigratingVm
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for 'DeleteMigratingVm' request. */
export interface DeleteMigratingVmRequest {
  /** Required. The name of the MigratingVm. */
  name: string;
}

/** Request message for 'StartMigrationRequest' request. */
export interface StartMigrationRequest {
  /** Required. The name of the MigratingVm. */
  migratingVm: string;
}

/** Response message for 'StartMigration' request. */
export interface StartMigrationResponse {
}

/** Request message for 'PauseMigration' request. */
export interface PauseMigrationRequest {
  /** Required. The name of the MigratingVm. */
  migratingVm: string;
}

/** Response message for 'PauseMigration' request. */
export interface PauseMigrationResponse {
}

/** Request message for 'ResumeMigration' request. */
export interface ResumeMigrationRequest {
  /** Required. The name of the MigratingVm. */
  migratingVm: string;
}

/** Response message for 'ResumeMigration' request. */
export interface ResumeMigrationResponse {
}

/** Request message for 'FinalizeMigration' request. */
export interface FinalizeMigrationRequest {
  /** Required. The name of the MigratingVm. */
  migratingVm: string;
}

/** Response message for 'FinalizeMigration' request. */
export interface FinalizeMigrationResponse {
}

/**
 * TargetProject message represents a target Compute Engine project for a
 * migration or a clone.
 */
export interface TargetProject {
  /** Output only. The name of the target project. */
  name: string;
  /** The target project ID (number) or project name. */
  project: string;
  /** The target project's description. */
  description: string;
  /**
   * Output only. The time this target project resource was created (not related
   * to when the Compute Engine project it points to was created).
   */
  createTime:
    | Date
    | undefined;
  /** Output only. The last time the target project resource was updated. */
  updateTime: Date | undefined;
}

/** Request message for 'GetTargetProject' call. */
export interface GetTargetProjectRequest {
  /** Required. The TargetProject name. */
  name: string;
}

/** Request message for 'ListTargetProjects' call. */
export interface ListTargetProjectsRequest {
  /** Required. The parent, which owns this collection of targets. */
  parent: string;
  /**
   * Optional. The maximum number of targets to return. The service may return
   * fewer than this value. If unspecified, at most 500 targets will be
   * returned. The maximum value is 1000; values above 1000 will be coerced to
   * 1000.
   */
  pageSize: number;
  /**
   * Required. A page token, received from a previous `ListTargets` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListTargets` must
   * match the call that provided the page token.
   */
  pageToken: string;
  /** Optional. The filter request. */
  filter: string;
  /** Optional. the order by fields for the result. */
  orderBy: string;
}

/** Response message for 'ListTargetProjects' call. */
export interface ListTargetProjectsResponse {
  /** Output only. The list of target response. */
  targetProjects: TargetProject[];
  /**
   * Output only. A token, which can be sent as `page_token` to retrieve the
   * next page. If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Output only. Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for 'CreateTargetProject' request. */
export interface CreateTargetProjectRequest {
  /** Required. The TargetProject's parent. */
  parent: string;
  /** Required. The target_project identifier. */
  targetProjectId: string;
  /** Required. The create request body. */
  targetProject:
    | TargetProject
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Update message for 'UpdateTargetProject' request. */
export interface UpdateTargetProjectRequest {
  /**
   * Field mask is used to specify the fields to be overwritten in the
   * TargetProject resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The update request body. */
  targetProject:
    | TargetProject
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for 'DeleteTargetProject' request. */
export interface DeleteTargetProjectRequest {
  /** Required. The TargetProject name. */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Describes message for 'Group' resource. The Group is a collections of several
 * MigratingVms.
 */
export interface Group {
  /** Output only. The Group name. */
  name: string;
  /** Output only. The create time timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update time timestamp. */
  updateTime:
    | Date
    | undefined;
  /** User-provided description of the group. */
  description: string;
  /** Display name is a user defined name for this group which can be updated. */
  displayName: string;
}

/** Request message for 'ListGroups' request. */
export interface ListGroupsRequest {
  /** Required. The parent, which owns this collection of groups. */
  parent: string;
  /**
   * Optional. The maximum number of groups to return. The service may return
   * fewer than this value. If unspecified, at most 500 groups will be
   * returned. The maximum value is 1000; values above 1000 will be coerced to
   * 1000.
   */
  pageSize: number;
  /**
   * Required. A page token, received from a previous `ListGroups` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListGroups` must
   * match the call that provided the page token.
   */
  pageToken: string;
  /** Optional. The filter request. */
  filter: string;
  /** Optional. the order by fields for the result. */
  orderBy: string;
}

/** Response message for 'ListGroups' request. */
export interface ListGroupsResponse {
  /** Output only. The list of groups response. */
  groups: Group[];
  /**
   * Output only. A token, which can be sent as `page_token` to retrieve the
   * next page. If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Output only. Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for 'GetGroup' request. */
export interface GetGroupRequest {
  /** Required. The group name. */
  name: string;
}

/** Request message for 'CreateGroup' request. */
export interface CreateGroupRequest {
  /** Required. The Group's parent. */
  parent: string;
  /** Required. The group identifier. */
  groupId: string;
  /** Required. The create request body. */
  group:
    | Group
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Update message for 'UpdateGroups' request. */
export interface UpdateGroupRequest {
  /**
   * Field mask is used to specify the fields to be overwritten in the
   * Group resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The update request body. */
  group:
    | Group
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for 'DeleteGroup' request. */
export interface DeleteGroupRequest {
  /** Required. The Group name. */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for 'AddGroupMigration' request. */
export interface AddGroupMigrationRequest {
  /** Required. The full path name of the Group to add to. */
  group: string;
  /** The full path name of the MigratingVm to add. */
  migratingVm: string;
}

/** Response message for 'AddGroupMigration' request. */
export interface AddGroupMigrationResponse {
}

/** Request message for 'RemoveMigration' request. */
export interface RemoveGroupMigrationRequest {
  /** Required. The name of the Group. */
  group: string;
  /** The MigratingVm to remove. */
  migratingVm: string;
}

/** Response message for 'RemoveMigration' request. */
export interface RemoveGroupMigrationResponse {
}

/** Request message for 'CreateCutoverJob' request. */
export interface CreateCutoverJobRequest {
  /** Required. The Cutover's parent. */
  parent: string;
  /** Required. The cutover job identifier. */
  cutoverJobId: string;
  /** Required. The cutover request body. */
  cutoverJob:
    | CutoverJob
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for 'CancelCutoverJob' request. */
export interface CancelCutoverJobRequest {
  /** Required. The cutover job id */
  name: string;
}

/** Response message for 'CancelCutoverJob' request. */
export interface CancelCutoverJobResponse {
}

/** Request message for 'ListCutoverJobsRequest' request. */
export interface ListCutoverJobsRequest {
  /** Required. The parent, which owns this collection of migrating VMs. */
  parent: string;
  /**
   * Optional. The maximum number of cutover jobs to return. The service may
   * return fewer than this value. If unspecified, at most 500 cutover jobs will
   * be returned. The maximum value is 1000; values above 1000 will be coerced
   * to 1000.
   */
  pageSize: number;
  /**
   * Required. A page token, received from a previous `ListCutoverJobs` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListCutoverJobs` must
   * match the call that provided the page token.
   */
  pageToken: string;
  /** Optional. The filter request. */
  filter: string;
  /** Optional. the order by fields for the result. */
  orderBy: string;
}

/** Response message for 'ListCutoverJobs' request. */
export interface ListCutoverJobsResponse {
  /** Output only. The list of cutover jobs response. */
  cutoverJobs: CutoverJob[];
  /**
   * Output only. A token, which can be sent as `page_token` to retrieve the
   * next page. If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Output only. Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for 'GetCutoverJob' request. */
export interface GetCutoverJobRequest {
  /** Required. The name of the CutoverJob. */
  name: string;
}

/** Represents the metadata of the long-running operation. */
export interface OperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /** Output only. Human-readable status of the operation, if any. */
  statusMessage: string;
  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have successfully been cancelled
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   */
  requestedCancellation: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

/**
 * Represents migration resource error information that can be used with
 * google.rpc.Status message. MigrationError is used to present the user with
 * error information in migration operations.
 */
export interface MigrationError {
  /** Output only. The error code. */
  code: MigrationError_ErrorCode;
  /** Output only. The localized error message. */
  errorMessage:
    | LocalizedMessage
    | undefined;
  /** Output only. Suggested action for solving the error. */
  actionItem:
    | LocalizedMessage
    | undefined;
  /**
   * Output only. URL(s) pointing to additional information on handling the
   * current error.
   */
  helpLinks: Help_Link[];
  /** Output only. The time the error occurred. */
  errorTime: Date | undefined;
}

/** Represents resource error codes. */
export enum MigrationError_ErrorCode {
  /** ERROR_CODE_UNSPECIFIED - Default value. This value is not used. */
  ERROR_CODE_UNSPECIFIED = 0,
  /** UNKNOWN_ERROR - Migrate for Compute encountered an unknown error. */
  UNKNOWN_ERROR = 1,
  /**
   * SOURCE_VALIDATION_ERROR - Migrate for Compute encountered an error while validating replication
   * source health.
   */
  SOURCE_VALIDATION_ERROR = 2,
  /** SOURCE_REPLICATION_ERROR - Migrate for Compute encountered an error during source data operation. */
  SOURCE_REPLICATION_ERROR = 3,
  /** TARGET_REPLICATION_ERROR - Migrate for Compute encountered an error during target data operation. */
  TARGET_REPLICATION_ERROR = 4,
  /** OS_ADAPTATION_ERROR - Migrate for Compute encountered an error during OS adaptation. */
  OS_ADAPTATION_ERROR = 5,
  /** CLONE_ERROR - Migrate for Compute encountered an error in clone operation. */
  CLONE_ERROR = 6,
  /** CUTOVER_ERROR - Migrate for Compute encountered an error in cutover operation. */
  CUTOVER_ERROR = 7,
  /**
   * UTILIZATION_REPORT_ERROR - Migrate for Compute encountered an error during utilization report
   * creation.
   */
  UTILIZATION_REPORT_ERROR = 8,
  /** APPLIANCE_UPGRADE_ERROR - Migrate for Compute encountered an error during appliance upgrade. */
  APPLIANCE_UPGRADE_ERROR = 9,
  UNRECOGNIZED = -1,
}

export function migrationError_ErrorCodeFromJSON(object: any): MigrationError_ErrorCode {
  switch (object) {
    case 0:
    case "ERROR_CODE_UNSPECIFIED":
      return MigrationError_ErrorCode.ERROR_CODE_UNSPECIFIED;
    case 1:
    case "UNKNOWN_ERROR":
      return MigrationError_ErrorCode.UNKNOWN_ERROR;
    case 2:
    case "SOURCE_VALIDATION_ERROR":
      return MigrationError_ErrorCode.SOURCE_VALIDATION_ERROR;
    case 3:
    case "SOURCE_REPLICATION_ERROR":
      return MigrationError_ErrorCode.SOURCE_REPLICATION_ERROR;
    case 4:
    case "TARGET_REPLICATION_ERROR":
      return MigrationError_ErrorCode.TARGET_REPLICATION_ERROR;
    case 5:
    case "OS_ADAPTATION_ERROR":
      return MigrationError_ErrorCode.OS_ADAPTATION_ERROR;
    case 6:
    case "CLONE_ERROR":
      return MigrationError_ErrorCode.CLONE_ERROR;
    case 7:
    case "CUTOVER_ERROR":
      return MigrationError_ErrorCode.CUTOVER_ERROR;
    case 8:
    case "UTILIZATION_REPORT_ERROR":
      return MigrationError_ErrorCode.UTILIZATION_REPORT_ERROR;
    case 9:
    case "APPLIANCE_UPGRADE_ERROR":
      return MigrationError_ErrorCode.APPLIANCE_UPGRADE_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MigrationError_ErrorCode.UNRECOGNIZED;
  }
}

export function migrationError_ErrorCodeToJSON(object: MigrationError_ErrorCode): string {
  switch (object) {
    case MigrationError_ErrorCode.ERROR_CODE_UNSPECIFIED:
      return "ERROR_CODE_UNSPECIFIED";
    case MigrationError_ErrorCode.UNKNOWN_ERROR:
      return "UNKNOWN_ERROR";
    case MigrationError_ErrorCode.SOURCE_VALIDATION_ERROR:
      return "SOURCE_VALIDATION_ERROR";
    case MigrationError_ErrorCode.SOURCE_REPLICATION_ERROR:
      return "SOURCE_REPLICATION_ERROR";
    case MigrationError_ErrorCode.TARGET_REPLICATION_ERROR:
      return "TARGET_REPLICATION_ERROR";
    case MigrationError_ErrorCode.OS_ADAPTATION_ERROR:
      return "OS_ADAPTATION_ERROR";
    case MigrationError_ErrorCode.CLONE_ERROR:
      return "CLONE_ERROR";
    case MigrationError_ErrorCode.CUTOVER_ERROR:
      return "CUTOVER_ERROR";
    case MigrationError_ErrorCode.UTILIZATION_REPORT_ERROR:
      return "UTILIZATION_REPORT_ERROR";
    case MigrationError_ErrorCode.APPLIANCE_UPGRADE_ERROR:
      return "APPLIANCE_UPGRADE_ERROR";
    case MigrationError_ErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represent the source AWS VM details. */
export interface AwsSourceVmDetails {
  /** The firmware type of the source VM. */
  firmware: AwsSourceVmDetails_Firmware;
  /** The total size of the disks being migrated in bytes. */
  committedStorageBytes: Long;
}

/** Possible values for AWS VM firmware. */
export enum AwsSourceVmDetails_Firmware {
  /** FIRMWARE_UNSPECIFIED - The firmware is unknown. */
  FIRMWARE_UNSPECIFIED = 0,
  /** EFI - The firmware is EFI. */
  EFI = 1,
  /** BIOS - The firmware is BIOS. */
  BIOS = 2,
  UNRECOGNIZED = -1,
}

export function awsSourceVmDetails_FirmwareFromJSON(object: any): AwsSourceVmDetails_Firmware {
  switch (object) {
    case 0:
    case "FIRMWARE_UNSPECIFIED":
      return AwsSourceVmDetails_Firmware.FIRMWARE_UNSPECIFIED;
    case 1:
    case "EFI":
      return AwsSourceVmDetails_Firmware.EFI;
    case 2:
    case "BIOS":
      return AwsSourceVmDetails_Firmware.BIOS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AwsSourceVmDetails_Firmware.UNRECOGNIZED;
  }
}

export function awsSourceVmDetails_FirmwareToJSON(object: AwsSourceVmDetails_Firmware): string {
  switch (object) {
    case AwsSourceVmDetails_Firmware.FIRMWARE_UNSPECIFIED:
      return "FIRMWARE_UNSPECIFIED";
    case AwsSourceVmDetails_Firmware.EFI:
      return "EFI";
    case AwsSourceVmDetails_Firmware.BIOS:
      return "BIOS";
    case AwsSourceVmDetails_Firmware.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for 'LisReplicationCyclesRequest' request. */
export interface ListReplicationCyclesRequest {
  /** Required. The parent, which owns this collection of ReplicationCycles. */
  parent: string;
  /**
   * Optional. The maximum number of replication cycles to return. The service
   * may return fewer than this value. If unspecified, at most 100 migrating VMs
   * will be returned. The maximum value is 100; values above 100 will be
   * coerced to 100.
   */
  pageSize: number;
  /**
   * Required. A page token, received from a previous `ListReplicationCycles`
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListReplicationCycles`
   * must match the call that provided the page token.
   */
  pageToken: string;
  /** Optional. The filter request. */
  filter: string;
  /** Optional. the order by fields for the result. */
  orderBy: string;
}

/** Response message for 'ListReplicationCycles' request. */
export interface ListReplicationCyclesResponse {
  /** Output only. The list of replication cycles response. */
  replicationCycles: ReplicationCycle[];
  /**
   * Output only. A token, which can be sent as `page_token` to retrieve the
   * next page. If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Output only. Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for 'GetReplicationCycle' request. */
export interface GetReplicationCycleRequest {
  /** Required. The name of the ReplicationCycle. */
  name: string;
}

function createBaseReplicationCycle(): ReplicationCycle {
  return {
    name: "",
    cycleNumber: 0,
    startTime: undefined,
    endTime: undefined,
    totalPauseDuration: undefined,
    progressPercent: 0,
    steps: [],
    state: 0,
    error: undefined,
  };
}

export const ReplicationCycle: MessageFns<ReplicationCycle> = {
  encode(message: ReplicationCycle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(106).string(message.name);
    }
    if (message.cycleNumber !== 0) {
      writer.uint32(80).int32(message.cycleNumber);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(50).fork()).join();
    }
    if (message.totalPauseDuration !== undefined) {
      Duration.encode(message.totalPauseDuration, writer.uint32(58).fork()).join();
    }
    if (message.progressPercent !== 0) {
      writer.uint32(40).int32(message.progressPercent);
    }
    for (const v of message.steps) {
      CycleStep.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(88).int32(message.state);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplicationCycle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplicationCycle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 13:
          if (tag !== 106) {
            break;
          }

          message.name = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.cycleNumber = reader.int32();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.totalPauseDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.progressPercent = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.steps.push(CycleStep.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplicationCycle {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cycleNumber: isSet(object.cycleNumber) ? globalThis.Number(object.cycleNumber) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      totalPauseDuration: isSet(object.totalPauseDuration) ? Duration.fromJSON(object.totalPauseDuration) : undefined,
      progressPercent: isSet(object.progressPercent) ? globalThis.Number(object.progressPercent) : 0,
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => CycleStep.fromJSON(e)) : [],
      state: isSet(object.state) ? replicationCycle_StateFromJSON(object.state) : 0,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ReplicationCycle): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.cycleNumber !== 0) {
      obj.cycleNumber = Math.round(message.cycleNumber);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.totalPauseDuration !== undefined) {
      obj.totalPauseDuration = Duration.toJSON(message.totalPauseDuration);
    }
    if (message.progressPercent !== 0) {
      obj.progressPercent = Math.round(message.progressPercent);
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => CycleStep.toJSON(e));
    }
    if (message.state !== 0) {
      obj.state = replicationCycle_StateToJSON(message.state);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<ReplicationCycle>): ReplicationCycle {
    return ReplicationCycle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplicationCycle>): ReplicationCycle {
    const message = createBaseReplicationCycle();
    message.name = object.name ?? "";
    message.cycleNumber = object.cycleNumber ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.totalPauseDuration = (object.totalPauseDuration !== undefined && object.totalPauseDuration !== null)
      ? Duration.fromPartial(object.totalPauseDuration)
      : undefined;
    message.progressPercent = object.progressPercent ?? 0;
    message.steps = object.steps?.map((e) => CycleStep.fromPartial(e)) || [];
    message.state = object.state ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseCycleStep(): CycleStep {
  return {
    initializingReplication: undefined,
    replicating: undefined,
    postProcessing: undefined,
    startTime: undefined,
    endTime: undefined,
  };
}

export const CycleStep: MessageFns<CycleStep> = {
  encode(message: CycleStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initializingReplication !== undefined) {
      InitializingReplicationStep.encode(message.initializingReplication, writer.uint32(26).fork()).join();
    }
    if (message.replicating !== undefined) {
      ReplicatingStep.encode(message.replicating, writer.uint32(34).fork()).join();
    }
    if (message.postProcessing !== undefined) {
      PostProcessingStep.encode(message.postProcessing, writer.uint32(42).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CycleStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCycleStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.initializingReplication = InitializingReplicationStep.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.replicating = ReplicatingStep.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.postProcessing = PostProcessingStep.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CycleStep {
    return {
      initializingReplication: isSet(object.initializingReplication)
        ? InitializingReplicationStep.fromJSON(object.initializingReplication)
        : undefined,
      replicating: isSet(object.replicating) ? ReplicatingStep.fromJSON(object.replicating) : undefined,
      postProcessing: isSet(object.postProcessing) ? PostProcessingStep.fromJSON(object.postProcessing) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: CycleStep): unknown {
    const obj: any = {};
    if (message.initializingReplication !== undefined) {
      obj.initializingReplication = InitializingReplicationStep.toJSON(message.initializingReplication);
    }
    if (message.replicating !== undefined) {
      obj.replicating = ReplicatingStep.toJSON(message.replicating);
    }
    if (message.postProcessing !== undefined) {
      obj.postProcessing = PostProcessingStep.toJSON(message.postProcessing);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CycleStep>): CycleStep {
    return CycleStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CycleStep>): CycleStep {
    const message = createBaseCycleStep();
    message.initializingReplication =
      (object.initializingReplication !== undefined && object.initializingReplication !== null)
        ? InitializingReplicationStep.fromPartial(object.initializingReplication)
        : undefined;
    message.replicating = (object.replicating !== undefined && object.replicating !== null)
      ? ReplicatingStep.fromPartial(object.replicating)
      : undefined;
    message.postProcessing = (object.postProcessing !== undefined && object.postProcessing !== null)
      ? PostProcessingStep.fromPartial(object.postProcessing)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseInitializingReplicationStep(): InitializingReplicationStep {
  return {};
}

export const InitializingReplicationStep: MessageFns<InitializingReplicationStep> = {
  encode(_: InitializingReplicationStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitializingReplicationStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitializingReplicationStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InitializingReplicationStep {
    return {};
  },

  toJSON(_: InitializingReplicationStep): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<InitializingReplicationStep>): InitializingReplicationStep {
    return InitializingReplicationStep.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<InitializingReplicationStep>): InitializingReplicationStep {
    const message = createBaseInitializingReplicationStep();
    return message;
  },
};

function createBaseReplicatingStep(): ReplicatingStep {
  return {
    totalBytes: Long.ZERO,
    replicatedBytes: Long.ZERO,
    lastTwoMinutesAverageBytesPerSecond: Long.ZERO,
    lastThirtyMinutesAverageBytesPerSecond: Long.ZERO,
  };
}

export const ReplicatingStep: MessageFns<ReplicatingStep> = {
  encode(message: ReplicatingStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.totalBytes.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.totalBytes.toString());
    }
    if (!message.replicatedBytes.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.replicatedBytes.toString());
    }
    if (!message.lastTwoMinutesAverageBytesPerSecond.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.lastTwoMinutesAverageBytesPerSecond.toString());
    }
    if (!message.lastThirtyMinutesAverageBytesPerSecond.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.lastThirtyMinutesAverageBytesPerSecond.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplicatingStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplicatingStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalBytes = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.replicatedBytes = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lastTwoMinutesAverageBytesPerSecond = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lastThirtyMinutesAverageBytesPerSecond = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplicatingStep {
    return {
      totalBytes: isSet(object.totalBytes) ? Long.fromValue(object.totalBytes) : Long.ZERO,
      replicatedBytes: isSet(object.replicatedBytes) ? Long.fromValue(object.replicatedBytes) : Long.ZERO,
      lastTwoMinutesAverageBytesPerSecond: isSet(object.lastTwoMinutesAverageBytesPerSecond)
        ? Long.fromValue(object.lastTwoMinutesAverageBytesPerSecond)
        : Long.ZERO,
      lastThirtyMinutesAverageBytesPerSecond: isSet(object.lastThirtyMinutesAverageBytesPerSecond)
        ? Long.fromValue(object.lastThirtyMinutesAverageBytesPerSecond)
        : Long.ZERO,
    };
  },

  toJSON(message: ReplicatingStep): unknown {
    const obj: any = {};
    if (!message.totalBytes.equals(Long.ZERO)) {
      obj.totalBytes = (message.totalBytes || Long.ZERO).toString();
    }
    if (!message.replicatedBytes.equals(Long.ZERO)) {
      obj.replicatedBytes = (message.replicatedBytes || Long.ZERO).toString();
    }
    if (!message.lastTwoMinutesAverageBytesPerSecond.equals(Long.ZERO)) {
      obj.lastTwoMinutesAverageBytesPerSecond = (message.lastTwoMinutesAverageBytesPerSecond || Long.ZERO).toString();
    }
    if (!message.lastThirtyMinutesAverageBytesPerSecond.equals(Long.ZERO)) {
      obj.lastThirtyMinutesAverageBytesPerSecond = (message.lastThirtyMinutesAverageBytesPerSecond || Long.ZERO)
        .toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ReplicatingStep>): ReplicatingStep {
    return ReplicatingStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplicatingStep>): ReplicatingStep {
    const message = createBaseReplicatingStep();
    message.totalBytes = (object.totalBytes !== undefined && object.totalBytes !== null)
      ? Long.fromValue(object.totalBytes)
      : Long.ZERO;
    message.replicatedBytes = (object.replicatedBytes !== undefined && object.replicatedBytes !== null)
      ? Long.fromValue(object.replicatedBytes)
      : Long.ZERO;
    message.lastTwoMinutesAverageBytesPerSecond =
      (object.lastTwoMinutesAverageBytesPerSecond !== undefined && object.lastTwoMinutesAverageBytesPerSecond !== null)
        ? Long.fromValue(object.lastTwoMinutesAverageBytesPerSecond)
        : Long.ZERO;
    message.lastThirtyMinutesAverageBytesPerSecond =
      (object.lastThirtyMinutesAverageBytesPerSecond !== undefined &&
          object.lastThirtyMinutesAverageBytesPerSecond !== null)
        ? Long.fromValue(object.lastThirtyMinutesAverageBytesPerSecond)
        : Long.ZERO;
    return message;
  },
};

function createBasePostProcessingStep(): PostProcessingStep {
  return {};
}

export const PostProcessingStep: MessageFns<PostProcessingStep> = {
  encode(_: PostProcessingStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostProcessingStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostProcessingStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PostProcessingStep {
    return {};
  },

  toJSON(_: PostProcessingStep): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PostProcessingStep>): PostProcessingStep {
    return PostProcessingStep.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PostProcessingStep>): PostProcessingStep {
    const message = createBasePostProcessingStep();
    return message;
  },
};

function createBaseReplicationSync(): ReplicationSync {
  return { lastSyncTime: undefined };
}

export const ReplicationSync: MessageFns<ReplicationSync> = {
  encode(message: ReplicationSync, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lastSyncTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastSyncTime), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplicationSync {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplicationSync();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lastSyncTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplicationSync {
    return { lastSyncTime: isSet(object.lastSyncTime) ? fromJsonTimestamp(object.lastSyncTime) : undefined };
  },

  toJSON(message: ReplicationSync): unknown {
    const obj: any = {};
    if (message.lastSyncTime !== undefined) {
      obj.lastSyncTime = message.lastSyncTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ReplicationSync>): ReplicationSync {
    return ReplicationSync.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplicationSync>): ReplicationSync {
    const message = createBaseReplicationSync();
    message.lastSyncTime = object.lastSyncTime ?? undefined;
    return message;
  },
};

function createBaseMigratingVm(): MigratingVm {
  return {
    computeEngineTargetDefaults: undefined,
    awsSourceVmDetails: undefined,
    name: "",
    sourceVmId: "",
    displayName: "",
    description: "",
    policy: undefined,
    createTime: undefined,
    updateTime: undefined,
    lastSync: undefined,
    state: 0,
    stateTime: undefined,
    currentSyncInfo: undefined,
    group: "",
    labels: {},
    recentCloneJobs: [],
    error: undefined,
    recentCutoverJobs: [],
  };
}

export const MigratingVm: MessageFns<MigratingVm> = {
  encode(message: MigratingVm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.computeEngineTargetDefaults !== undefined) {
      ComputeEngineTargetDefaults.encode(message.computeEngineTargetDefaults, writer.uint32(210).fork()).join();
    }
    if (message.awsSourceVmDetails !== undefined) {
      AwsSourceVmDetails.encode(message.awsSourceVmDetails, writer.uint32(234).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.sourceVmId !== "") {
      writer.uint32(18).string(message.sourceVmId);
    }
    if (message.displayName !== "") {
      writer.uint32(146).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.policy !== undefined) {
      SchedulePolicy.encode(message.policy, writer.uint32(66).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    if (message.lastSync !== undefined) {
      ReplicationSync.encode(message.lastSync, writer.uint32(90).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(184).int32(message.state);
    }
    if (message.stateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.stateTime), writer.uint32(178).fork()).join();
    }
    if (message.currentSyncInfo !== undefined) {
      ReplicationCycle.encode(message.currentSyncInfo, writer.uint32(106).fork()).join();
    }
    if (message.group !== "") {
      writer.uint32(122).string(message.group);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      MigratingVm_LabelsEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    for (const v of message.recentCloneJobs) {
      CloneJob.encode(v!, writer.uint32(138).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(154).fork()).join();
    }
    for (const v of message.recentCutoverJobs) {
      CutoverJob.encode(v!, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigratingVm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigratingVm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 26:
          if (tag !== 210) {
            break;
          }

          message.computeEngineTargetDefaults = ComputeEngineTargetDefaults.decode(reader, reader.uint32());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.awsSourceVmDetails = AwsSourceVmDetails.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceVmId = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.policy = SchedulePolicy.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.lastSync = ReplicationSync.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.stateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.currentSyncInfo = ReplicationCycle.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.group = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          const entry16 = MigratingVm_LabelsEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.labels[entry16.key] = entry16.value;
          }
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.recentCloneJobs.push(CloneJob.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.recentCutoverJobs.push(CutoverJob.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigratingVm {
    return {
      computeEngineTargetDefaults: isSet(object.computeEngineTargetDefaults)
        ? ComputeEngineTargetDefaults.fromJSON(object.computeEngineTargetDefaults)
        : undefined,
      awsSourceVmDetails: isSet(object.awsSourceVmDetails)
        ? AwsSourceVmDetails.fromJSON(object.awsSourceVmDetails)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sourceVmId: isSet(object.sourceVmId) ? globalThis.String(object.sourceVmId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      policy: isSet(object.policy) ? SchedulePolicy.fromJSON(object.policy) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      lastSync: isSet(object.lastSync) ? ReplicationSync.fromJSON(object.lastSync) : undefined,
      state: isSet(object.state) ? migratingVm_StateFromJSON(object.state) : 0,
      stateTime: isSet(object.stateTime) ? fromJsonTimestamp(object.stateTime) : undefined,
      currentSyncInfo: isSet(object.currentSyncInfo) ? ReplicationCycle.fromJSON(object.currentSyncInfo) : undefined,
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      recentCloneJobs: globalThis.Array.isArray(object?.recentCloneJobs)
        ? object.recentCloneJobs.map((e: any) => CloneJob.fromJSON(e))
        : [],
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      recentCutoverJobs: globalThis.Array.isArray(object?.recentCutoverJobs)
        ? object.recentCutoverJobs.map((e: any) => CutoverJob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MigratingVm): unknown {
    const obj: any = {};
    if (message.computeEngineTargetDefaults !== undefined) {
      obj.computeEngineTargetDefaults = ComputeEngineTargetDefaults.toJSON(message.computeEngineTargetDefaults);
    }
    if (message.awsSourceVmDetails !== undefined) {
      obj.awsSourceVmDetails = AwsSourceVmDetails.toJSON(message.awsSourceVmDetails);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sourceVmId !== "") {
      obj.sourceVmId = message.sourceVmId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.policy !== undefined) {
      obj.policy = SchedulePolicy.toJSON(message.policy);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.lastSync !== undefined) {
      obj.lastSync = ReplicationSync.toJSON(message.lastSync);
    }
    if (message.state !== 0) {
      obj.state = migratingVm_StateToJSON(message.state);
    }
    if (message.stateTime !== undefined) {
      obj.stateTime = message.stateTime.toISOString();
    }
    if (message.currentSyncInfo !== undefined) {
      obj.currentSyncInfo = ReplicationCycle.toJSON(message.currentSyncInfo);
    }
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.recentCloneJobs?.length) {
      obj.recentCloneJobs = message.recentCloneJobs.map((e) => CloneJob.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.recentCutoverJobs?.length) {
      obj.recentCutoverJobs = message.recentCutoverJobs.map((e) => CutoverJob.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MigratingVm>): MigratingVm {
    return MigratingVm.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigratingVm>): MigratingVm {
    const message = createBaseMigratingVm();
    message.computeEngineTargetDefaults =
      (object.computeEngineTargetDefaults !== undefined && object.computeEngineTargetDefaults !== null)
        ? ComputeEngineTargetDefaults.fromPartial(object.computeEngineTargetDefaults)
        : undefined;
    message.awsSourceVmDetails = (object.awsSourceVmDetails !== undefined && object.awsSourceVmDetails !== null)
      ? AwsSourceVmDetails.fromPartial(object.awsSourceVmDetails)
      : undefined;
    message.name = object.name ?? "";
    message.sourceVmId = object.sourceVmId ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? SchedulePolicy.fromPartial(object.policy)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.lastSync = (object.lastSync !== undefined && object.lastSync !== null)
      ? ReplicationSync.fromPartial(object.lastSync)
      : undefined;
    message.state = object.state ?? 0;
    message.stateTime = object.stateTime ?? undefined;
    message.currentSyncInfo = (object.currentSyncInfo !== undefined && object.currentSyncInfo !== null)
      ? ReplicationCycle.fromPartial(object.currentSyncInfo)
      : undefined;
    message.group = object.group ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.recentCloneJobs = object.recentCloneJobs?.map((e) => CloneJob.fromPartial(e)) || [];
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.recentCutoverJobs = object.recentCutoverJobs?.map((e) => CutoverJob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMigratingVm_LabelsEntry(): MigratingVm_LabelsEntry {
  return { key: "", value: "" };
}

export const MigratingVm_LabelsEntry: MessageFns<MigratingVm_LabelsEntry> = {
  encode(message: MigratingVm_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigratingVm_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigratingVm_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigratingVm_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MigratingVm_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<MigratingVm_LabelsEntry>): MigratingVm_LabelsEntry {
    return MigratingVm_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigratingVm_LabelsEntry>): MigratingVm_LabelsEntry {
    const message = createBaseMigratingVm_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCloneJob(): CloneJob {
  return {
    computeEngineTargetDetails: undefined,
    createTime: undefined,
    endTime: undefined,
    name: "",
    state: 0,
    stateTime: undefined,
    error: undefined,
    steps: [],
  };
}

export const CloneJob: MessageFns<CloneJob> = {
  encode(message: CloneJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.computeEngineTargetDetails !== undefined) {
      ComputeEngineTargetDetails.encode(message.computeEngineTargetDetails, writer.uint32(162).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(178).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(96).int32(message.state);
    }
    if (message.stateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.stateTime), writer.uint32(114).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(138).fork()).join();
    }
    for (const v of message.steps) {
      CloneStep.encode(v!, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloneJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloneJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 20:
          if (tag !== 162) {
            break;
          }

          message.computeEngineTargetDetails = ComputeEngineTargetDetails.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.stateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.steps.push(CloneStep.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloneJob {
    return {
      computeEngineTargetDetails: isSet(object.computeEngineTargetDetails)
        ? ComputeEngineTargetDetails.fromJSON(object.computeEngineTargetDetails)
        : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? cloneJob_StateFromJSON(object.state) : 0,
      stateTime: isSet(object.stateTime) ? fromJsonTimestamp(object.stateTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => CloneStep.fromJSON(e)) : [],
    };
  },

  toJSON(message: CloneJob): unknown {
    const obj: any = {};
    if (message.computeEngineTargetDetails !== undefined) {
      obj.computeEngineTargetDetails = ComputeEngineTargetDetails.toJSON(message.computeEngineTargetDetails);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = cloneJob_StateToJSON(message.state);
    }
    if (message.stateTime !== undefined) {
      obj.stateTime = message.stateTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => CloneStep.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CloneJob>): CloneJob {
    return CloneJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloneJob>): CloneJob {
    const message = createBaseCloneJob();
    message.computeEngineTargetDetails =
      (object.computeEngineTargetDetails !== undefined && object.computeEngineTargetDetails !== null)
        ? ComputeEngineTargetDetails.fromPartial(object.computeEngineTargetDetails)
        : undefined;
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.stateTime = object.stateTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.steps = object.steps?.map((e) => CloneStep.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCloneStep(): CloneStep {
  return {
    adaptingOs: undefined,
    preparingVmDisks: undefined,
    instantiatingMigratedVm: undefined,
    startTime: undefined,
    endTime: undefined,
  };
}

export const CloneStep: MessageFns<CloneStep> = {
  encode(message: CloneStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.adaptingOs !== undefined) {
      AdaptingOSStep.encode(message.adaptingOs, writer.uint32(26).fork()).join();
    }
    if (message.preparingVmDisks !== undefined) {
      PreparingVMDisksStep.encode(message.preparingVmDisks, writer.uint32(34).fork()).join();
    }
    if (message.instantiatingMigratedVm !== undefined) {
      InstantiatingMigratedVMStep.encode(message.instantiatingMigratedVm, writer.uint32(42).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloneStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloneStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.adaptingOs = AdaptingOSStep.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.preparingVmDisks = PreparingVMDisksStep.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.instantiatingMigratedVm = InstantiatingMigratedVMStep.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloneStep {
    return {
      adaptingOs: isSet(object.adaptingOs) ? AdaptingOSStep.fromJSON(object.adaptingOs) : undefined,
      preparingVmDisks: isSet(object.preparingVmDisks)
        ? PreparingVMDisksStep.fromJSON(object.preparingVmDisks)
        : undefined,
      instantiatingMigratedVm: isSet(object.instantiatingMigratedVm)
        ? InstantiatingMigratedVMStep.fromJSON(object.instantiatingMigratedVm)
        : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: CloneStep): unknown {
    const obj: any = {};
    if (message.adaptingOs !== undefined) {
      obj.adaptingOs = AdaptingOSStep.toJSON(message.adaptingOs);
    }
    if (message.preparingVmDisks !== undefined) {
      obj.preparingVmDisks = PreparingVMDisksStep.toJSON(message.preparingVmDisks);
    }
    if (message.instantiatingMigratedVm !== undefined) {
      obj.instantiatingMigratedVm = InstantiatingMigratedVMStep.toJSON(message.instantiatingMigratedVm);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CloneStep>): CloneStep {
    return CloneStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloneStep>): CloneStep {
    const message = createBaseCloneStep();
    message.adaptingOs = (object.adaptingOs !== undefined && object.adaptingOs !== null)
      ? AdaptingOSStep.fromPartial(object.adaptingOs)
      : undefined;
    message.preparingVmDisks = (object.preparingVmDisks !== undefined && object.preparingVmDisks !== null)
      ? PreparingVMDisksStep.fromPartial(object.preparingVmDisks)
      : undefined;
    message.instantiatingMigratedVm =
      (object.instantiatingMigratedVm !== undefined && object.instantiatingMigratedVm !== null)
        ? InstantiatingMigratedVMStep.fromPartial(object.instantiatingMigratedVm)
        : undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseAdaptingOSStep(): AdaptingOSStep {
  return {};
}

export const AdaptingOSStep: MessageFns<AdaptingOSStep> = {
  encode(_: AdaptingOSStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdaptingOSStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdaptingOSStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AdaptingOSStep {
    return {};
  },

  toJSON(_: AdaptingOSStep): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AdaptingOSStep>): AdaptingOSStep {
    return AdaptingOSStep.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AdaptingOSStep>): AdaptingOSStep {
    const message = createBaseAdaptingOSStep();
    return message;
  },
};

function createBasePreparingVMDisksStep(): PreparingVMDisksStep {
  return {};
}

export const PreparingVMDisksStep: MessageFns<PreparingVMDisksStep> = {
  encode(_: PreparingVMDisksStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreparingVMDisksStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreparingVMDisksStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PreparingVMDisksStep {
    return {};
  },

  toJSON(_: PreparingVMDisksStep): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PreparingVMDisksStep>): PreparingVMDisksStep {
    return PreparingVMDisksStep.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PreparingVMDisksStep>): PreparingVMDisksStep {
    const message = createBasePreparingVMDisksStep();
    return message;
  },
};

function createBaseInstantiatingMigratedVMStep(): InstantiatingMigratedVMStep {
  return {};
}

export const InstantiatingMigratedVMStep: MessageFns<InstantiatingMigratedVMStep> = {
  encode(_: InstantiatingMigratedVMStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstantiatingMigratedVMStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstantiatingMigratedVMStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InstantiatingMigratedVMStep {
    return {};
  },

  toJSON(_: InstantiatingMigratedVMStep): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<InstantiatingMigratedVMStep>): InstantiatingMigratedVMStep {
    return InstantiatingMigratedVMStep.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<InstantiatingMigratedVMStep>): InstantiatingMigratedVMStep {
    const message = createBaseInstantiatingMigratedVMStep();
    return message;
  },
};

function createBaseCutoverJob(): CutoverJob {
  return {
    computeEngineTargetDetails: undefined,
    createTime: undefined,
    endTime: undefined,
    name: "",
    state: 0,
    stateTime: undefined,
    progressPercent: 0,
    error: undefined,
    stateMessage: "",
    steps: [],
  };
}

export const CutoverJob: MessageFns<CutoverJob> = {
  encode(message: CutoverJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.computeEngineTargetDetails !== undefined) {
      ComputeEngineTargetDetails.encode(message.computeEngineTargetDetails, writer.uint32(114).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(130).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.stateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.stateTime), writer.uint32(50).fork()).join();
    }
    if (message.progressPercent !== 0) {
      writer.uint32(104).int32(message.progressPercent);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(74).fork()).join();
    }
    if (message.stateMessage !== "") {
      writer.uint32(82).string(message.stateMessage);
    }
    for (const v of message.steps) {
      CutoverStep.encode(v!, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CutoverJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCutoverJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 14:
          if (tag !== 114) {
            break;
          }

          message.computeEngineTargetDetails = ComputeEngineTargetDetails.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.stateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.progressPercent = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.stateMessage = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.steps.push(CutoverStep.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CutoverJob {
    return {
      computeEngineTargetDetails: isSet(object.computeEngineTargetDetails)
        ? ComputeEngineTargetDetails.fromJSON(object.computeEngineTargetDetails)
        : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? cutoverJob_StateFromJSON(object.state) : 0,
      stateTime: isSet(object.stateTime) ? fromJsonTimestamp(object.stateTime) : undefined,
      progressPercent: isSet(object.progressPercent) ? globalThis.Number(object.progressPercent) : 0,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      stateMessage: isSet(object.stateMessage) ? globalThis.String(object.stateMessage) : "",
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => CutoverStep.fromJSON(e)) : [],
    };
  },

  toJSON(message: CutoverJob): unknown {
    const obj: any = {};
    if (message.computeEngineTargetDetails !== undefined) {
      obj.computeEngineTargetDetails = ComputeEngineTargetDetails.toJSON(message.computeEngineTargetDetails);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = cutoverJob_StateToJSON(message.state);
    }
    if (message.stateTime !== undefined) {
      obj.stateTime = message.stateTime.toISOString();
    }
    if (message.progressPercent !== 0) {
      obj.progressPercent = Math.round(message.progressPercent);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.stateMessage !== "") {
      obj.stateMessage = message.stateMessage;
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => CutoverStep.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CutoverJob>): CutoverJob {
    return CutoverJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CutoverJob>): CutoverJob {
    const message = createBaseCutoverJob();
    message.computeEngineTargetDetails =
      (object.computeEngineTargetDetails !== undefined && object.computeEngineTargetDetails !== null)
        ? ComputeEngineTargetDetails.fromPartial(object.computeEngineTargetDetails)
        : undefined;
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.stateTime = object.stateTime ?? undefined;
    message.progressPercent = object.progressPercent ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.stateMessage = object.stateMessage ?? "";
    message.steps = object.steps?.map((e) => CutoverStep.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCutoverStep(): CutoverStep {
  return {
    previousReplicationCycle: undefined,
    shuttingDownSourceVm: undefined,
    finalSync: undefined,
    preparingVmDisks: undefined,
    instantiatingMigratedVm: undefined,
    startTime: undefined,
    endTime: undefined,
  };
}

export const CutoverStep: MessageFns<CutoverStep> = {
  encode(message: CutoverStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.previousReplicationCycle !== undefined) {
      ReplicationCycle.encode(message.previousReplicationCycle, writer.uint32(26).fork()).join();
    }
    if (message.shuttingDownSourceVm !== undefined) {
      ShuttingDownSourceVMStep.encode(message.shuttingDownSourceVm, writer.uint32(34).fork()).join();
    }
    if (message.finalSync !== undefined) {
      ReplicationCycle.encode(message.finalSync, writer.uint32(42).fork()).join();
    }
    if (message.preparingVmDisks !== undefined) {
      PreparingVMDisksStep.encode(message.preparingVmDisks, writer.uint32(50).fork()).join();
    }
    if (message.instantiatingMigratedVm !== undefined) {
      InstantiatingMigratedVMStep.encode(message.instantiatingMigratedVm, writer.uint32(58).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CutoverStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCutoverStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.previousReplicationCycle = ReplicationCycle.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.shuttingDownSourceVm = ShuttingDownSourceVMStep.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.finalSync = ReplicationCycle.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.preparingVmDisks = PreparingVMDisksStep.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.instantiatingMigratedVm = InstantiatingMigratedVMStep.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CutoverStep {
    return {
      previousReplicationCycle: isSet(object.previousReplicationCycle)
        ? ReplicationCycle.fromJSON(object.previousReplicationCycle)
        : undefined,
      shuttingDownSourceVm: isSet(object.shuttingDownSourceVm)
        ? ShuttingDownSourceVMStep.fromJSON(object.shuttingDownSourceVm)
        : undefined,
      finalSync: isSet(object.finalSync) ? ReplicationCycle.fromJSON(object.finalSync) : undefined,
      preparingVmDisks: isSet(object.preparingVmDisks)
        ? PreparingVMDisksStep.fromJSON(object.preparingVmDisks)
        : undefined,
      instantiatingMigratedVm: isSet(object.instantiatingMigratedVm)
        ? InstantiatingMigratedVMStep.fromJSON(object.instantiatingMigratedVm)
        : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: CutoverStep): unknown {
    const obj: any = {};
    if (message.previousReplicationCycle !== undefined) {
      obj.previousReplicationCycle = ReplicationCycle.toJSON(message.previousReplicationCycle);
    }
    if (message.shuttingDownSourceVm !== undefined) {
      obj.shuttingDownSourceVm = ShuttingDownSourceVMStep.toJSON(message.shuttingDownSourceVm);
    }
    if (message.finalSync !== undefined) {
      obj.finalSync = ReplicationCycle.toJSON(message.finalSync);
    }
    if (message.preparingVmDisks !== undefined) {
      obj.preparingVmDisks = PreparingVMDisksStep.toJSON(message.preparingVmDisks);
    }
    if (message.instantiatingMigratedVm !== undefined) {
      obj.instantiatingMigratedVm = InstantiatingMigratedVMStep.toJSON(message.instantiatingMigratedVm);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CutoverStep>): CutoverStep {
    return CutoverStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CutoverStep>): CutoverStep {
    const message = createBaseCutoverStep();
    message.previousReplicationCycle =
      (object.previousReplicationCycle !== undefined && object.previousReplicationCycle !== null)
        ? ReplicationCycle.fromPartial(object.previousReplicationCycle)
        : undefined;
    message.shuttingDownSourceVm = (object.shuttingDownSourceVm !== undefined && object.shuttingDownSourceVm !== null)
      ? ShuttingDownSourceVMStep.fromPartial(object.shuttingDownSourceVm)
      : undefined;
    message.finalSync = (object.finalSync !== undefined && object.finalSync !== null)
      ? ReplicationCycle.fromPartial(object.finalSync)
      : undefined;
    message.preparingVmDisks = (object.preparingVmDisks !== undefined && object.preparingVmDisks !== null)
      ? PreparingVMDisksStep.fromPartial(object.preparingVmDisks)
      : undefined;
    message.instantiatingMigratedVm =
      (object.instantiatingMigratedVm !== undefined && object.instantiatingMigratedVm !== null)
        ? InstantiatingMigratedVMStep.fromPartial(object.instantiatingMigratedVm)
        : undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseShuttingDownSourceVMStep(): ShuttingDownSourceVMStep {
  return {};
}

export const ShuttingDownSourceVMStep: MessageFns<ShuttingDownSourceVMStep> = {
  encode(_: ShuttingDownSourceVMStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShuttingDownSourceVMStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShuttingDownSourceVMStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ShuttingDownSourceVMStep {
    return {};
  },

  toJSON(_: ShuttingDownSourceVMStep): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ShuttingDownSourceVMStep>): ShuttingDownSourceVMStep {
    return ShuttingDownSourceVMStep.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ShuttingDownSourceVMStep>): ShuttingDownSourceVMStep {
    const message = createBaseShuttingDownSourceVMStep();
    return message;
  },
};

function createBaseCreateCloneJobRequest(): CreateCloneJobRequest {
  return { parent: "", cloneJobId: "", cloneJob: undefined, requestId: "" };
}

export const CreateCloneJobRequest: MessageFns<CreateCloneJobRequest> = {
  encode(message: CreateCloneJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.cloneJobId !== "") {
      writer.uint32(18).string(message.cloneJobId);
    }
    if (message.cloneJob !== undefined) {
      CloneJob.encode(message.cloneJob, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCloneJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCloneJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cloneJobId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cloneJob = CloneJob.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCloneJobRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      cloneJobId: isSet(object.cloneJobId) ? globalThis.String(object.cloneJobId) : "",
      cloneJob: isSet(object.cloneJob) ? CloneJob.fromJSON(object.cloneJob) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateCloneJobRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.cloneJobId !== "") {
      obj.cloneJobId = message.cloneJobId;
    }
    if (message.cloneJob !== undefined) {
      obj.cloneJob = CloneJob.toJSON(message.cloneJob);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCloneJobRequest>): CreateCloneJobRequest {
    return CreateCloneJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCloneJobRequest>): CreateCloneJobRequest {
    const message = createBaseCreateCloneJobRequest();
    message.parent = object.parent ?? "";
    message.cloneJobId = object.cloneJobId ?? "";
    message.cloneJob = (object.cloneJob !== undefined && object.cloneJob !== null)
      ? CloneJob.fromPartial(object.cloneJob)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseCancelCloneJobRequest(): CancelCloneJobRequest {
  return { name: "" };
}

export const CancelCloneJobRequest: MessageFns<CancelCloneJobRequest> = {
  encode(message: CancelCloneJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelCloneJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelCloneJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelCloneJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CancelCloneJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelCloneJobRequest>): CancelCloneJobRequest {
    return CancelCloneJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelCloneJobRequest>): CancelCloneJobRequest {
    const message = createBaseCancelCloneJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCancelCloneJobResponse(): CancelCloneJobResponse {
  return {};
}

export const CancelCloneJobResponse: MessageFns<CancelCloneJobResponse> = {
  encode(_: CancelCloneJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelCloneJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelCloneJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CancelCloneJobResponse {
    return {};
  },

  toJSON(_: CancelCloneJobResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CancelCloneJobResponse>): CancelCloneJobResponse {
    return CancelCloneJobResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CancelCloneJobResponse>): CancelCloneJobResponse {
    const message = createBaseCancelCloneJobResponse();
    return message;
  },
};

function createBaseListCloneJobsRequest(): ListCloneJobsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListCloneJobsRequest: MessageFns<ListCloneJobsRequest> = {
  encode(message: ListCloneJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCloneJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCloneJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCloneJobsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListCloneJobsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCloneJobsRequest>): ListCloneJobsRequest {
    return ListCloneJobsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCloneJobsRequest>): ListCloneJobsRequest {
    const message = createBaseListCloneJobsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListCloneJobsResponse(): ListCloneJobsResponse {
  return { cloneJobs: [], nextPageToken: "", unreachable: [] };
}

export const ListCloneJobsResponse: MessageFns<ListCloneJobsResponse> = {
  encode(message: ListCloneJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cloneJobs) {
      CloneJob.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCloneJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCloneJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cloneJobs.push(CloneJob.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCloneJobsResponse {
    return {
      cloneJobs: globalThis.Array.isArray(object?.cloneJobs)
        ? object.cloneJobs.map((e: any) => CloneJob.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListCloneJobsResponse): unknown {
    const obj: any = {};
    if (message.cloneJobs?.length) {
      obj.cloneJobs = message.cloneJobs.map((e) => CloneJob.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCloneJobsResponse>): ListCloneJobsResponse {
    return ListCloneJobsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCloneJobsResponse>): ListCloneJobsResponse {
    const message = createBaseListCloneJobsResponse();
    message.cloneJobs = object.cloneJobs?.map((e) => CloneJob.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetCloneJobRequest(): GetCloneJobRequest {
  return { name: "" };
}

export const GetCloneJobRequest: MessageFns<GetCloneJobRequest> = {
  encode(message: GetCloneJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCloneJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCloneJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCloneJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCloneJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCloneJobRequest>): GetCloneJobRequest {
    return GetCloneJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCloneJobRequest>): GetCloneJobRequest {
    const message = createBaseGetCloneJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSource(): Source {
  return {
    vmware: undefined,
    aws: undefined,
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
  };
}

export const Source: MessageFns<Source> = {
  encode(message: Source, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vmware !== undefined) {
      VmwareSourceDetails.encode(message.vmware, writer.uint32(82).fork()).join();
    }
    if (message.aws !== undefined) {
      AwsSourceDetails.encode(message.aws, writer.uint32(98).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Source_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Source {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10:
          if (tag !== 82) {
            break;
          }

          message.vmware = VmwareSourceDetails.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.aws = AwsSourceDetails.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Source_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Source {
    return {
      vmware: isSet(object.vmware) ? VmwareSourceDetails.fromJSON(object.vmware) : undefined,
      aws: isSet(object.aws) ? AwsSourceDetails.fromJSON(object.aws) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Source): unknown {
    const obj: any = {};
    if (message.vmware !== undefined) {
      obj.vmware = VmwareSourceDetails.toJSON(message.vmware);
    }
    if (message.aws !== undefined) {
      obj.aws = AwsSourceDetails.toJSON(message.aws);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<Source>): Source {
    return Source.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Source>): Source {
    const message = createBaseSource();
    message.vmware = (object.vmware !== undefined && object.vmware !== null)
      ? VmwareSourceDetails.fromPartial(object.vmware)
      : undefined;
    message.aws = (object.aws !== undefined && object.aws !== null)
      ? AwsSourceDetails.fromPartial(object.aws)
      : undefined;
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseSource_LabelsEntry(): Source_LabelsEntry {
  return { key: "", value: "" };
}

export const Source_LabelsEntry: MessageFns<Source_LabelsEntry> = {
  encode(message: Source_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Source_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Source_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Source_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Source_LabelsEntry>): Source_LabelsEntry {
    return Source_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Source_LabelsEntry>): Source_LabelsEntry {
    const message = createBaseSource_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseVmwareSourceDetails(): VmwareSourceDetails {
  return { username: "", password: "", vcenterIp: "", thumbprint: "" };
}

export const VmwareSourceDetails: MessageFns<VmwareSourceDetails> = {
  encode(message: VmwareSourceDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.vcenterIp !== "") {
      writer.uint32(26).string(message.vcenterIp);
    }
    if (message.thumbprint !== "") {
      writer.uint32(34).string(message.thumbprint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmwareSourceDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmwareSourceDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vcenterIp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.thumbprint = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmwareSourceDetails {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      vcenterIp: isSet(object.vcenterIp) ? globalThis.String(object.vcenterIp) : "",
      thumbprint: isSet(object.thumbprint) ? globalThis.String(object.thumbprint) : "",
    };
  },

  toJSON(message: VmwareSourceDetails): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.vcenterIp !== "") {
      obj.vcenterIp = message.vcenterIp;
    }
    if (message.thumbprint !== "") {
      obj.thumbprint = message.thumbprint;
    }
    return obj;
  },

  create(base?: DeepPartial<VmwareSourceDetails>): VmwareSourceDetails {
    return VmwareSourceDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VmwareSourceDetails>): VmwareSourceDetails {
    const message = createBaseVmwareSourceDetails();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.vcenterIp = object.vcenterIp ?? "";
    message.thumbprint = object.thumbprint ?? "";
    return message;
  },
};

function createBaseAwsSourceDetails(): AwsSourceDetails {
  return {
    accessKeyCreds: undefined,
    awsRegion: "",
    state: 0,
    error: undefined,
    inventoryTagList: [],
    inventorySecurityGroupNames: [],
    migrationResourcesUserTags: {},
    publicIp: "",
  };
}

export const AwsSourceDetails: MessageFns<AwsSourceDetails> = {
  encode(message: AwsSourceDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessKeyCreds !== undefined) {
      AwsSourceDetails_AccessKeyCredentials.encode(message.accessKeyCreds, writer.uint32(90).fork()).join();
    }
    if (message.awsRegion !== "") {
      writer.uint32(26).string(message.awsRegion);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(42).fork()).join();
    }
    for (const v of message.inventoryTagList) {
      AwsSourceDetails_Tag.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.inventorySecurityGroupNames) {
      writer.uint32(58).string(v!);
    }
    Object.entries(message.migrationResourcesUserTags).forEach(([key, value]) => {
      AwsSourceDetails_MigrationResourcesUserTagsEntry.encode({ key: key as any, value }, writer.uint32(66).fork())
        .join();
    });
    if (message.publicIp !== "") {
      writer.uint32(74).string(message.publicIp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsSourceDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsSourceDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 11:
          if (tag !== 90) {
            break;
          }

          message.accessKeyCreds = AwsSourceDetails_AccessKeyCredentials.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.awsRegion = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.inventoryTagList.push(AwsSourceDetails_Tag.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.inventorySecurityGroupNames.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = AwsSourceDetails_MigrationResourcesUserTagsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.migrationResourcesUserTags[entry8.key] = entry8.value;
          }
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.publicIp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsSourceDetails {
    return {
      accessKeyCreds: isSet(object.accessKeyCreds)
        ? AwsSourceDetails_AccessKeyCredentials.fromJSON(object.accessKeyCreds)
        : undefined,
      awsRegion: isSet(object.awsRegion) ? globalThis.String(object.awsRegion) : "",
      state: isSet(object.state) ? awsSourceDetails_StateFromJSON(object.state) : 0,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      inventoryTagList: globalThis.Array.isArray(object?.inventoryTagList)
        ? object.inventoryTagList.map((e: any) => AwsSourceDetails_Tag.fromJSON(e))
        : [],
      inventorySecurityGroupNames: globalThis.Array.isArray(object?.inventorySecurityGroupNames)
        ? object.inventorySecurityGroupNames.map((e: any) => globalThis.String(e))
        : [],
      migrationResourcesUserTags: isObject(object.migrationResourcesUserTags)
        ? Object.entries(object.migrationResourcesUserTags).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      publicIp: isSet(object.publicIp) ? globalThis.String(object.publicIp) : "",
    };
  },

  toJSON(message: AwsSourceDetails): unknown {
    const obj: any = {};
    if (message.accessKeyCreds !== undefined) {
      obj.accessKeyCreds = AwsSourceDetails_AccessKeyCredentials.toJSON(message.accessKeyCreds);
    }
    if (message.awsRegion !== "") {
      obj.awsRegion = message.awsRegion;
    }
    if (message.state !== 0) {
      obj.state = awsSourceDetails_StateToJSON(message.state);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.inventoryTagList?.length) {
      obj.inventoryTagList = message.inventoryTagList.map((e) => AwsSourceDetails_Tag.toJSON(e));
    }
    if (message.inventorySecurityGroupNames?.length) {
      obj.inventorySecurityGroupNames = message.inventorySecurityGroupNames;
    }
    if (message.migrationResourcesUserTags) {
      const entries = Object.entries(message.migrationResourcesUserTags);
      if (entries.length > 0) {
        obj.migrationResourcesUserTags = {};
        entries.forEach(([k, v]) => {
          obj.migrationResourcesUserTags[k] = v;
        });
      }
    }
    if (message.publicIp !== "") {
      obj.publicIp = message.publicIp;
    }
    return obj;
  },

  create(base?: DeepPartial<AwsSourceDetails>): AwsSourceDetails {
    return AwsSourceDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AwsSourceDetails>): AwsSourceDetails {
    const message = createBaseAwsSourceDetails();
    message.accessKeyCreds = (object.accessKeyCreds !== undefined && object.accessKeyCreds !== null)
      ? AwsSourceDetails_AccessKeyCredentials.fromPartial(object.accessKeyCreds)
      : undefined;
    message.awsRegion = object.awsRegion ?? "";
    message.state = object.state ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.inventoryTagList = object.inventoryTagList?.map((e) => AwsSourceDetails_Tag.fromPartial(e)) || [];
    message.inventorySecurityGroupNames = object.inventorySecurityGroupNames?.map((e) => e) || [];
    message.migrationResourcesUserTags = Object.entries(object.migrationResourcesUserTags ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.publicIp = object.publicIp ?? "";
    return message;
  },
};

function createBaseAwsSourceDetails_AccessKeyCredentials(): AwsSourceDetails_AccessKeyCredentials {
  return { accessKeyId: "", secretAccessKey: "" };
}

export const AwsSourceDetails_AccessKeyCredentials: MessageFns<AwsSourceDetails_AccessKeyCredentials> = {
  encode(message: AwsSourceDetails_AccessKeyCredentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessKeyId !== "") {
      writer.uint32(10).string(message.accessKeyId);
    }
    if (message.secretAccessKey !== "") {
      writer.uint32(18).string(message.secretAccessKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsSourceDetails_AccessKeyCredentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsSourceDetails_AccessKeyCredentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessKeyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.secretAccessKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsSourceDetails_AccessKeyCredentials {
    return {
      accessKeyId: isSet(object.accessKeyId) ? globalThis.String(object.accessKeyId) : "",
      secretAccessKey: isSet(object.secretAccessKey) ? globalThis.String(object.secretAccessKey) : "",
    };
  },

  toJSON(message: AwsSourceDetails_AccessKeyCredentials): unknown {
    const obj: any = {};
    if (message.accessKeyId !== "") {
      obj.accessKeyId = message.accessKeyId;
    }
    if (message.secretAccessKey !== "") {
      obj.secretAccessKey = message.secretAccessKey;
    }
    return obj;
  },

  create(base?: DeepPartial<AwsSourceDetails_AccessKeyCredentials>): AwsSourceDetails_AccessKeyCredentials {
    return AwsSourceDetails_AccessKeyCredentials.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AwsSourceDetails_AccessKeyCredentials>): AwsSourceDetails_AccessKeyCredentials {
    const message = createBaseAwsSourceDetails_AccessKeyCredentials();
    message.accessKeyId = object.accessKeyId ?? "";
    message.secretAccessKey = object.secretAccessKey ?? "";
    return message;
  },
};

function createBaseAwsSourceDetails_Tag(): AwsSourceDetails_Tag {
  return { key: "", value: "" };
}

export const AwsSourceDetails_Tag: MessageFns<AwsSourceDetails_Tag> = {
  encode(message: AwsSourceDetails_Tag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsSourceDetails_Tag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsSourceDetails_Tag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsSourceDetails_Tag {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AwsSourceDetails_Tag): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AwsSourceDetails_Tag>): AwsSourceDetails_Tag {
    return AwsSourceDetails_Tag.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AwsSourceDetails_Tag>): AwsSourceDetails_Tag {
    const message = createBaseAwsSourceDetails_Tag();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAwsSourceDetails_MigrationResourcesUserTagsEntry(): AwsSourceDetails_MigrationResourcesUserTagsEntry {
  return { key: "", value: "" };
}

export const AwsSourceDetails_MigrationResourcesUserTagsEntry: MessageFns<
  AwsSourceDetails_MigrationResourcesUserTagsEntry
> = {
  encode(
    message: AwsSourceDetails_MigrationResourcesUserTagsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsSourceDetails_MigrationResourcesUserTagsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsSourceDetails_MigrationResourcesUserTagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsSourceDetails_MigrationResourcesUserTagsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AwsSourceDetails_MigrationResourcesUserTagsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AwsSourceDetails_MigrationResourcesUserTagsEntry>,
  ): AwsSourceDetails_MigrationResourcesUserTagsEntry {
    return AwsSourceDetails_MigrationResourcesUserTagsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AwsSourceDetails_MigrationResourcesUserTagsEntry>,
  ): AwsSourceDetails_MigrationResourcesUserTagsEntry {
    const message = createBaseAwsSourceDetails_MigrationResourcesUserTagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDatacenterConnector(): DatacenterConnector {
  return {
    createTime: undefined,
    updateTime: undefined,
    name: "",
    registrationId: "",
    serviceAccount: "",
    version: "",
    bucket: "",
    state: 0,
    stateTime: undefined,
    error: undefined,
    applianceInfrastructureVersion: "",
    applianceSoftwareVersion: "",
    availableVersions: undefined,
    upgradeStatus: undefined,
  };
}

export const DatacenterConnector: MessageFns<DatacenterConnector> = {
  encode(message: DatacenterConnector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.registrationId !== "") {
      writer.uint32(98).string(message.registrationId);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(42).string(message.serviceAccount);
    }
    if (message.version !== "") {
      writer.uint32(50).string(message.version);
    }
    if (message.bucket !== "") {
      writer.uint32(82).string(message.bucket);
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    if (message.stateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.stateTime), writer.uint32(66).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(90).fork()).join();
    }
    if (message.applianceInfrastructureVersion !== "") {
      writer.uint32(106).string(message.applianceInfrastructureVersion);
    }
    if (message.applianceSoftwareVersion !== "") {
      writer.uint32(114).string(message.applianceSoftwareVersion);
    }
    if (message.availableVersions !== undefined) {
      AvailableUpdates.encode(message.availableVersions, writer.uint32(122).fork()).join();
    }
    if (message.upgradeStatus !== undefined) {
      UpgradeStatus.encode(message.upgradeStatus, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatacenterConnector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatacenterConnector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.registrationId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.version = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.bucket = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.stateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.applianceInfrastructureVersion = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.applianceSoftwareVersion = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.availableVersions = AvailableUpdates.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.upgradeStatus = UpgradeStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatacenterConnector {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      registrationId: isSet(object.registrationId) ? globalThis.String(object.registrationId) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      state: isSet(object.state) ? datacenterConnector_StateFromJSON(object.state) : 0,
      stateTime: isSet(object.stateTime) ? fromJsonTimestamp(object.stateTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      applianceInfrastructureVersion: isSet(object.applianceInfrastructureVersion)
        ? globalThis.String(object.applianceInfrastructureVersion)
        : "",
      applianceSoftwareVersion: isSet(object.applianceSoftwareVersion)
        ? globalThis.String(object.applianceSoftwareVersion)
        : "",
      availableVersions: isSet(object.availableVersions)
        ? AvailableUpdates.fromJSON(object.availableVersions)
        : undefined,
      upgradeStatus: isSet(object.upgradeStatus) ? UpgradeStatus.fromJSON(object.upgradeStatus) : undefined,
    };
  },

  toJSON(message: DatacenterConnector): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.registrationId !== "") {
      obj.registrationId = message.registrationId;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.state !== 0) {
      obj.state = datacenterConnector_StateToJSON(message.state);
    }
    if (message.stateTime !== undefined) {
      obj.stateTime = message.stateTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.applianceInfrastructureVersion !== "") {
      obj.applianceInfrastructureVersion = message.applianceInfrastructureVersion;
    }
    if (message.applianceSoftwareVersion !== "") {
      obj.applianceSoftwareVersion = message.applianceSoftwareVersion;
    }
    if (message.availableVersions !== undefined) {
      obj.availableVersions = AvailableUpdates.toJSON(message.availableVersions);
    }
    if (message.upgradeStatus !== undefined) {
      obj.upgradeStatus = UpgradeStatus.toJSON(message.upgradeStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<DatacenterConnector>): DatacenterConnector {
    return DatacenterConnector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatacenterConnector>): DatacenterConnector {
    const message = createBaseDatacenterConnector();
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.name = object.name ?? "";
    message.registrationId = object.registrationId ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    message.version = object.version ?? "";
    message.bucket = object.bucket ?? "";
    message.state = object.state ?? 0;
    message.stateTime = object.stateTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.applianceInfrastructureVersion = object.applianceInfrastructureVersion ?? "";
    message.applianceSoftwareVersion = object.applianceSoftwareVersion ?? "";
    message.availableVersions = (object.availableVersions !== undefined && object.availableVersions !== null)
      ? AvailableUpdates.fromPartial(object.availableVersions)
      : undefined;
    message.upgradeStatus = (object.upgradeStatus !== undefined && object.upgradeStatus !== null)
      ? UpgradeStatus.fromPartial(object.upgradeStatus)
      : undefined;
    return message;
  },
};

function createBaseUpgradeStatus(): UpgradeStatus {
  return { version: "", state: 0, error: undefined, startTime: undefined, previousVersion: "" };
}

export const UpgradeStatus: MessageFns<UpgradeStatus> = {
  encode(message: UpgradeStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).join();
    }
    if (message.previousVersion !== "") {
      writer.uint32(42).string(message.previousVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpgradeStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpgradeStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.previousVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpgradeStatus {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      state: isSet(object.state) ? upgradeStatus_StateFromJSON(object.state) : 0,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      previousVersion: isSet(object.previousVersion) ? globalThis.String(object.previousVersion) : "",
    };
  },

  toJSON(message: UpgradeStatus): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.state !== 0) {
      obj.state = upgradeStatus_StateToJSON(message.state);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.previousVersion !== "") {
      obj.previousVersion = message.previousVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<UpgradeStatus>): UpgradeStatus {
    return UpgradeStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpgradeStatus>): UpgradeStatus {
    const message = createBaseUpgradeStatus();
    message.version = object.version ?? "";
    message.state = object.state ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.previousVersion = object.previousVersion ?? "";
    return message;
  },
};

function createBaseAvailableUpdates(): AvailableUpdates {
  return { newDeployableAppliance: undefined, inPlaceUpdate: undefined };
}

export const AvailableUpdates: MessageFns<AvailableUpdates> = {
  encode(message: AvailableUpdates, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newDeployableAppliance !== undefined) {
      ApplianceVersion.encode(message.newDeployableAppliance, writer.uint32(10).fork()).join();
    }
    if (message.inPlaceUpdate !== undefined) {
      ApplianceVersion.encode(message.inPlaceUpdate, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvailableUpdates {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvailableUpdates();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.newDeployableAppliance = ApplianceVersion.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inPlaceUpdate = ApplianceVersion.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvailableUpdates {
    return {
      newDeployableAppliance: isSet(object.newDeployableAppliance)
        ? ApplianceVersion.fromJSON(object.newDeployableAppliance)
        : undefined,
      inPlaceUpdate: isSet(object.inPlaceUpdate) ? ApplianceVersion.fromJSON(object.inPlaceUpdate) : undefined,
    };
  },

  toJSON(message: AvailableUpdates): unknown {
    const obj: any = {};
    if (message.newDeployableAppliance !== undefined) {
      obj.newDeployableAppliance = ApplianceVersion.toJSON(message.newDeployableAppliance);
    }
    if (message.inPlaceUpdate !== undefined) {
      obj.inPlaceUpdate = ApplianceVersion.toJSON(message.inPlaceUpdate);
    }
    return obj;
  },

  create(base?: DeepPartial<AvailableUpdates>): AvailableUpdates {
    return AvailableUpdates.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvailableUpdates>): AvailableUpdates {
    const message = createBaseAvailableUpdates();
    message.newDeployableAppliance =
      (object.newDeployableAppliance !== undefined && object.newDeployableAppliance !== null)
        ? ApplianceVersion.fromPartial(object.newDeployableAppliance)
        : undefined;
    message.inPlaceUpdate = (object.inPlaceUpdate !== undefined && object.inPlaceUpdate !== null)
      ? ApplianceVersion.fromPartial(object.inPlaceUpdate)
      : undefined;
    return message;
  },
};

function createBaseApplianceVersion(): ApplianceVersion {
  return { version: "", uri: "", critical: false, releaseNotesUri: "" };
}

export const ApplianceVersion: MessageFns<ApplianceVersion> = {
  encode(message: ApplianceVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.critical !== false) {
      writer.uint32(24).bool(message.critical);
    }
    if (message.releaseNotesUri !== "") {
      writer.uint32(34).string(message.releaseNotesUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplianceVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplianceVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.critical = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.releaseNotesUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplianceVersion {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      critical: isSet(object.critical) ? globalThis.Boolean(object.critical) : false,
      releaseNotesUri: isSet(object.releaseNotesUri) ? globalThis.String(object.releaseNotesUri) : "",
    };
  },

  toJSON(message: ApplianceVersion): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.critical !== false) {
      obj.critical = message.critical;
    }
    if (message.releaseNotesUri !== "") {
      obj.releaseNotesUri = message.releaseNotesUri;
    }
    return obj;
  },

  create(base?: DeepPartial<ApplianceVersion>): ApplianceVersion {
    return ApplianceVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApplianceVersion>): ApplianceVersion {
    const message = createBaseApplianceVersion();
    message.version = object.version ?? "";
    message.uri = object.uri ?? "";
    message.critical = object.critical ?? false;
    message.releaseNotesUri = object.releaseNotesUri ?? "";
    return message;
  },
};

function createBaseListSourcesRequest(): ListSourcesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListSourcesRequest: MessageFns<ListSourcesRequest> = {
  encode(message: ListSourcesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSourcesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSourcesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListSourcesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSourcesRequest>): ListSourcesRequest {
    return ListSourcesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSourcesRequest>): ListSourcesRequest {
    const message = createBaseListSourcesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListSourcesResponse(): ListSourcesResponse {
  return { sources: [], nextPageToken: "", unreachable: [] };
}

export const ListSourcesResponse: MessageFns<ListSourcesResponse> = {
  encode(message: ListSourcesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sources) {
      Source.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSourcesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sources.push(Source.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSourcesResponse {
    return {
      sources: globalThis.Array.isArray(object?.sources) ? object.sources.map((e: any) => Source.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListSourcesResponse): unknown {
    const obj: any = {};
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => Source.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSourcesResponse>): ListSourcesResponse {
    return ListSourcesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSourcesResponse>): ListSourcesResponse {
    const message = createBaseListSourcesResponse();
    message.sources = object.sources?.map((e) => Source.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSourceRequest(): GetSourceRequest {
  return { name: "" };
}

export const GetSourceRequest: MessageFns<GetSourceRequest> = {
  encode(message: GetSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSourceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSourceRequest>): GetSourceRequest {
    return GetSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSourceRequest>): GetSourceRequest {
    const message = createBaseGetSourceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateSourceRequest(): CreateSourceRequest {
  return { parent: "", sourceId: "", source: undefined, requestId: "" };
}

export const CreateSourceRequest: MessageFns<CreateSourceRequest> = {
  encode(message: CreateSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.sourceId !== "") {
      writer.uint32(18).string(message.sourceId);
    }
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSourceRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      sourceId: isSet(object.sourceId) ? globalThis.String(object.sourceId) : "",
      source: isSet(object.source) ? Source.fromJSON(object.source) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateSourceRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.sourceId !== "") {
      obj.sourceId = message.sourceId;
    }
    if (message.source !== undefined) {
      obj.source = Source.toJSON(message.source);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSourceRequest>): CreateSourceRequest {
    return CreateSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSourceRequest>): CreateSourceRequest {
    const message = createBaseCreateSourceRequest();
    message.parent = object.parent ?? "";
    message.sourceId = object.sourceId ?? "";
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateSourceRequest(): UpdateSourceRequest {
  return { updateMask: undefined, source: undefined, requestId: "" };
}

export const UpdateSourceRequest: MessageFns<UpdateSourceRequest> = {
  encode(message: UpdateSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSourceRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      source: isSet(object.source) ? Source.fromJSON(object.source) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateSourceRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.source !== undefined) {
      obj.source = Source.toJSON(message.source);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSourceRequest>): UpdateSourceRequest {
    return UpdateSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSourceRequest>): UpdateSourceRequest {
    const message = createBaseUpdateSourceRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteSourceRequest(): DeleteSourceRequest {
  return { name: "", requestId: "" };
}

export const DeleteSourceRequest: MessageFns<DeleteSourceRequest> = {
  encode(message: DeleteSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSourceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteSourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSourceRequest>): DeleteSourceRequest {
    return DeleteSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSourceRequest>): DeleteSourceRequest {
    const message = createBaseDeleteSourceRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseFetchInventoryRequest(): FetchInventoryRequest {
  return { source: "", forceRefresh: false };
}

export const FetchInventoryRequest: MessageFns<FetchInventoryRequest> = {
  encode(message: FetchInventoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.forceRefresh !== false) {
      writer.uint32(16).bool(message.forceRefresh);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchInventoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchInventoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.forceRefresh = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchInventoryRequest {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      forceRefresh: isSet(object.forceRefresh) ? globalThis.Boolean(object.forceRefresh) : false,
    };
  },

  toJSON(message: FetchInventoryRequest): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.forceRefresh !== false) {
      obj.forceRefresh = message.forceRefresh;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchInventoryRequest>): FetchInventoryRequest {
    return FetchInventoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchInventoryRequest>): FetchInventoryRequest {
    const message = createBaseFetchInventoryRequest();
    message.source = object.source ?? "";
    message.forceRefresh = object.forceRefresh ?? false;
    return message;
  },
};

function createBaseVmwareVmDetails(): VmwareVmDetails {
  return {
    vmId: "",
    datacenterId: "",
    datacenterDescription: "",
    uuid: "",
    displayName: "",
    powerState: 0,
    cpuCount: 0,
    memoryMb: 0,
    diskCount: 0,
    committedStorageMb: Long.ZERO,
    guestDescription: "",
    bootOption: 0,
  };
}

export const VmwareVmDetails: MessageFns<VmwareVmDetails> = {
  encode(message: VmwareVmDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vmId !== "") {
      writer.uint32(10).string(message.vmId);
    }
    if (message.datacenterId !== "") {
      writer.uint32(18).string(message.datacenterId);
    }
    if (message.datacenterDescription !== "") {
      writer.uint32(26).string(message.datacenterDescription);
    }
    if (message.uuid !== "") {
      writer.uint32(34).string(message.uuid);
    }
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.powerState !== 0) {
      writer.uint32(48).int32(message.powerState);
    }
    if (message.cpuCount !== 0) {
      writer.uint32(56).int32(message.cpuCount);
    }
    if (message.memoryMb !== 0) {
      writer.uint32(64).int32(message.memoryMb);
    }
    if (message.diskCount !== 0) {
      writer.uint32(72).int32(message.diskCount);
    }
    if (!message.committedStorageMb.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.committedStorageMb.toString());
    }
    if (message.guestDescription !== "") {
      writer.uint32(90).string(message.guestDescription);
    }
    if (message.bootOption !== 0) {
      writer.uint32(104).int32(message.bootOption);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmwareVmDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmwareVmDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vmId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.datacenterId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.datacenterDescription = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.powerState = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.cpuCount = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.memoryMb = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.diskCount = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.committedStorageMb = Long.fromString(reader.int64().toString());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.guestDescription = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.bootOption = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmwareVmDetails {
    return {
      vmId: isSet(object.vmId) ? globalThis.String(object.vmId) : "",
      datacenterId: isSet(object.datacenterId) ? globalThis.String(object.datacenterId) : "",
      datacenterDescription: isSet(object.datacenterDescription) ? globalThis.String(object.datacenterDescription) : "",
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      powerState: isSet(object.powerState) ? vmwareVmDetails_PowerStateFromJSON(object.powerState) : 0,
      cpuCount: isSet(object.cpuCount) ? globalThis.Number(object.cpuCount) : 0,
      memoryMb: isSet(object.memoryMb) ? globalThis.Number(object.memoryMb) : 0,
      diskCount: isSet(object.diskCount) ? globalThis.Number(object.diskCount) : 0,
      committedStorageMb: isSet(object.committedStorageMb) ? Long.fromValue(object.committedStorageMb) : Long.ZERO,
      guestDescription: isSet(object.guestDescription) ? globalThis.String(object.guestDescription) : "",
      bootOption: isSet(object.bootOption) ? vmwareVmDetails_BootOptionFromJSON(object.bootOption) : 0,
    };
  },

  toJSON(message: VmwareVmDetails): unknown {
    const obj: any = {};
    if (message.vmId !== "") {
      obj.vmId = message.vmId;
    }
    if (message.datacenterId !== "") {
      obj.datacenterId = message.datacenterId;
    }
    if (message.datacenterDescription !== "") {
      obj.datacenterDescription = message.datacenterDescription;
    }
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.powerState !== 0) {
      obj.powerState = vmwareVmDetails_PowerStateToJSON(message.powerState);
    }
    if (message.cpuCount !== 0) {
      obj.cpuCount = Math.round(message.cpuCount);
    }
    if (message.memoryMb !== 0) {
      obj.memoryMb = Math.round(message.memoryMb);
    }
    if (message.diskCount !== 0) {
      obj.diskCount = Math.round(message.diskCount);
    }
    if (!message.committedStorageMb.equals(Long.ZERO)) {
      obj.committedStorageMb = (message.committedStorageMb || Long.ZERO).toString();
    }
    if (message.guestDescription !== "") {
      obj.guestDescription = message.guestDescription;
    }
    if (message.bootOption !== 0) {
      obj.bootOption = vmwareVmDetails_BootOptionToJSON(message.bootOption);
    }
    return obj;
  },

  create(base?: DeepPartial<VmwareVmDetails>): VmwareVmDetails {
    return VmwareVmDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VmwareVmDetails>): VmwareVmDetails {
    const message = createBaseVmwareVmDetails();
    message.vmId = object.vmId ?? "";
    message.datacenterId = object.datacenterId ?? "";
    message.datacenterDescription = object.datacenterDescription ?? "";
    message.uuid = object.uuid ?? "";
    message.displayName = object.displayName ?? "";
    message.powerState = object.powerState ?? 0;
    message.cpuCount = object.cpuCount ?? 0;
    message.memoryMb = object.memoryMb ?? 0;
    message.diskCount = object.diskCount ?? 0;
    message.committedStorageMb = (object.committedStorageMb !== undefined && object.committedStorageMb !== null)
      ? Long.fromValue(object.committedStorageMb)
      : Long.ZERO;
    message.guestDescription = object.guestDescription ?? "";
    message.bootOption = object.bootOption ?? 0;
    return message;
  },
};

function createBaseAwsVmDetails(): AwsVmDetails {
  return {
    vmId: "",
    displayName: "",
    sourceId: "",
    sourceDescription: "",
    powerState: 0,
    cpuCount: 0,
    memoryMb: 0,
    diskCount: 0,
    committedStorageMb: Long.ZERO,
    osDescription: "",
    bootOption: 0,
    instanceType: "",
    vpcId: "",
    securityGroups: [],
    tags: {},
    zone: "",
    virtualizationType: 0,
    architecture: 0,
  };
}

export const AwsVmDetails: MessageFns<AwsVmDetails> = {
  encode(message: AwsVmDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vmId !== "") {
      writer.uint32(10).string(message.vmId);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.sourceId !== "") {
      writer.uint32(26).string(message.sourceId);
    }
    if (message.sourceDescription !== "") {
      writer.uint32(34).string(message.sourceDescription);
    }
    if (message.powerState !== 0) {
      writer.uint32(40).int32(message.powerState);
    }
    if (message.cpuCount !== 0) {
      writer.uint32(48).int32(message.cpuCount);
    }
    if (message.memoryMb !== 0) {
      writer.uint32(56).int32(message.memoryMb);
    }
    if (message.diskCount !== 0) {
      writer.uint32(64).int32(message.diskCount);
    }
    if (!message.committedStorageMb.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.committedStorageMb.toString());
    }
    if (message.osDescription !== "") {
      writer.uint32(82).string(message.osDescription);
    }
    if (message.bootOption !== 0) {
      writer.uint32(88).int32(message.bootOption);
    }
    if (message.instanceType !== "") {
      writer.uint32(98).string(message.instanceType);
    }
    if (message.vpcId !== "") {
      writer.uint32(106).string(message.vpcId);
    }
    for (const v of message.securityGroups) {
      AwsSecurityGroup.encode(v!, writer.uint32(114).fork()).join();
    }
    Object.entries(message.tags).forEach(([key, value]) => {
      AwsVmDetails_TagsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.zone !== "") {
      writer.uint32(130).string(message.zone);
    }
    if (message.virtualizationType !== 0) {
      writer.uint32(136).int32(message.virtualizationType);
    }
    if (message.architecture !== 0) {
      writer.uint32(144).int32(message.architecture);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsVmDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsVmDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vmId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sourceDescription = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.powerState = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cpuCount = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.memoryMb = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.diskCount = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.committedStorageMb = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.osDescription = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.bootOption = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.instanceType = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.vpcId = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.securityGroups.push(AwsSecurityGroup.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = AwsVmDetails_TagsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.tags[entry15.key] = entry15.value;
          }
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.virtualizationType = reader.int32() as any;
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.architecture = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsVmDetails {
    return {
      vmId: isSet(object.vmId) ? globalThis.String(object.vmId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      sourceId: isSet(object.sourceId) ? globalThis.String(object.sourceId) : "",
      sourceDescription: isSet(object.sourceDescription) ? globalThis.String(object.sourceDescription) : "",
      powerState: isSet(object.powerState) ? awsVmDetails_PowerStateFromJSON(object.powerState) : 0,
      cpuCount: isSet(object.cpuCount) ? globalThis.Number(object.cpuCount) : 0,
      memoryMb: isSet(object.memoryMb) ? globalThis.Number(object.memoryMb) : 0,
      diskCount: isSet(object.diskCount) ? globalThis.Number(object.diskCount) : 0,
      committedStorageMb: isSet(object.committedStorageMb) ? Long.fromValue(object.committedStorageMb) : Long.ZERO,
      osDescription: isSet(object.osDescription) ? globalThis.String(object.osDescription) : "",
      bootOption: isSet(object.bootOption) ? awsVmDetails_BootOptionFromJSON(object.bootOption) : 0,
      instanceType: isSet(object.instanceType) ? globalThis.String(object.instanceType) : "",
      vpcId: isSet(object.vpcId) ? globalThis.String(object.vpcId) : "",
      securityGroups: globalThis.Array.isArray(object?.securityGroups)
        ? object.securityGroups.map((e: any) => AwsSecurityGroup.fromJSON(e))
        : [],
      tags: isObject(object.tags)
        ? Object.entries(object.tags).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      virtualizationType: isSet(object.virtualizationType)
        ? awsVmDetails_VmVirtualizationTypeFromJSON(object.virtualizationType)
        : 0,
      architecture: isSet(object.architecture) ? awsVmDetails_VmArchitectureFromJSON(object.architecture) : 0,
    };
  },

  toJSON(message: AwsVmDetails): unknown {
    const obj: any = {};
    if (message.vmId !== "") {
      obj.vmId = message.vmId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.sourceId !== "") {
      obj.sourceId = message.sourceId;
    }
    if (message.sourceDescription !== "") {
      obj.sourceDescription = message.sourceDescription;
    }
    if (message.powerState !== 0) {
      obj.powerState = awsVmDetails_PowerStateToJSON(message.powerState);
    }
    if (message.cpuCount !== 0) {
      obj.cpuCount = Math.round(message.cpuCount);
    }
    if (message.memoryMb !== 0) {
      obj.memoryMb = Math.round(message.memoryMb);
    }
    if (message.diskCount !== 0) {
      obj.diskCount = Math.round(message.diskCount);
    }
    if (!message.committedStorageMb.equals(Long.ZERO)) {
      obj.committedStorageMb = (message.committedStorageMb || Long.ZERO).toString();
    }
    if (message.osDescription !== "") {
      obj.osDescription = message.osDescription;
    }
    if (message.bootOption !== 0) {
      obj.bootOption = awsVmDetails_BootOptionToJSON(message.bootOption);
    }
    if (message.instanceType !== "") {
      obj.instanceType = message.instanceType;
    }
    if (message.vpcId !== "") {
      obj.vpcId = message.vpcId;
    }
    if (message.securityGroups?.length) {
      obj.securityGroups = message.securityGroups.map((e) => AwsSecurityGroup.toJSON(e));
    }
    if (message.tags) {
      const entries = Object.entries(message.tags);
      if (entries.length > 0) {
        obj.tags = {};
        entries.forEach(([k, v]) => {
          obj.tags[k] = v;
        });
      }
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.virtualizationType !== 0) {
      obj.virtualizationType = awsVmDetails_VmVirtualizationTypeToJSON(message.virtualizationType);
    }
    if (message.architecture !== 0) {
      obj.architecture = awsVmDetails_VmArchitectureToJSON(message.architecture);
    }
    return obj;
  },

  create(base?: DeepPartial<AwsVmDetails>): AwsVmDetails {
    return AwsVmDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AwsVmDetails>): AwsVmDetails {
    const message = createBaseAwsVmDetails();
    message.vmId = object.vmId ?? "";
    message.displayName = object.displayName ?? "";
    message.sourceId = object.sourceId ?? "";
    message.sourceDescription = object.sourceDescription ?? "";
    message.powerState = object.powerState ?? 0;
    message.cpuCount = object.cpuCount ?? 0;
    message.memoryMb = object.memoryMb ?? 0;
    message.diskCount = object.diskCount ?? 0;
    message.committedStorageMb = (object.committedStorageMb !== undefined && object.committedStorageMb !== null)
      ? Long.fromValue(object.committedStorageMb)
      : Long.ZERO;
    message.osDescription = object.osDescription ?? "";
    message.bootOption = object.bootOption ?? 0;
    message.instanceType = object.instanceType ?? "";
    message.vpcId = object.vpcId ?? "";
    message.securityGroups = object.securityGroups?.map((e) => AwsSecurityGroup.fromPartial(e)) || [];
    message.tags = Object.entries(object.tags ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.zone = object.zone ?? "";
    message.virtualizationType = object.virtualizationType ?? 0;
    message.architecture = object.architecture ?? 0;
    return message;
  },
};

function createBaseAwsVmDetails_TagsEntry(): AwsVmDetails_TagsEntry {
  return { key: "", value: "" };
}

export const AwsVmDetails_TagsEntry: MessageFns<AwsVmDetails_TagsEntry> = {
  encode(message: AwsVmDetails_TagsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsVmDetails_TagsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsVmDetails_TagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsVmDetails_TagsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AwsVmDetails_TagsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AwsVmDetails_TagsEntry>): AwsVmDetails_TagsEntry {
    return AwsVmDetails_TagsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AwsVmDetails_TagsEntry>): AwsVmDetails_TagsEntry {
    const message = createBaseAwsVmDetails_TagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAwsSecurityGroup(): AwsSecurityGroup {
  return { id: "", name: "" };
}

export const AwsSecurityGroup: MessageFns<AwsSecurityGroup> = {
  encode(message: AwsSecurityGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsSecurityGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsSecurityGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsSecurityGroup {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: AwsSecurityGroup): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<AwsSecurityGroup>): AwsSecurityGroup {
    return AwsSecurityGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AwsSecurityGroup>): AwsSecurityGroup {
    const message = createBaseAwsSecurityGroup();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseVmwareVmsDetails(): VmwareVmsDetails {
  return { details: [] };
}

export const VmwareVmsDetails: MessageFns<VmwareVmsDetails> = {
  encode(message: VmwareVmsDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.details) {
      VmwareVmDetails.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmwareVmsDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmwareVmsDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details.push(VmwareVmDetails.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmwareVmsDetails {
    return {
      details: globalThis.Array.isArray(object?.details)
        ? object.details.map((e: any) => VmwareVmDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VmwareVmsDetails): unknown {
    const obj: any = {};
    if (message.details?.length) {
      obj.details = message.details.map((e) => VmwareVmDetails.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VmwareVmsDetails>): VmwareVmsDetails {
    return VmwareVmsDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VmwareVmsDetails>): VmwareVmsDetails {
    const message = createBaseVmwareVmsDetails();
    message.details = object.details?.map((e) => VmwareVmDetails.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAwsVmsDetails(): AwsVmsDetails {
  return { details: [] };
}

export const AwsVmsDetails: MessageFns<AwsVmsDetails> = {
  encode(message: AwsVmsDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.details) {
      AwsVmDetails.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsVmsDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsVmsDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details.push(AwsVmDetails.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsVmsDetails {
    return {
      details: globalThis.Array.isArray(object?.details)
        ? object.details.map((e: any) => AwsVmDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AwsVmsDetails): unknown {
    const obj: any = {};
    if (message.details?.length) {
      obj.details = message.details.map((e) => AwsVmDetails.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AwsVmsDetails>): AwsVmsDetails {
    return AwsVmsDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AwsVmsDetails>): AwsVmsDetails {
    const message = createBaseAwsVmsDetails();
    message.details = object.details?.map((e) => AwsVmDetails.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFetchInventoryResponse(): FetchInventoryResponse {
  return { vmwareVms: undefined, awsVms: undefined, updateTime: undefined };
}

export const FetchInventoryResponse: MessageFns<FetchInventoryResponse> = {
  encode(message: FetchInventoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vmwareVms !== undefined) {
      VmwareVmsDetails.encode(message.vmwareVms, writer.uint32(10).fork()).join();
    }
    if (message.awsVms !== undefined) {
      AwsVmsDetails.encode(message.awsVms, writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchInventoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchInventoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vmwareVms = VmwareVmsDetails.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.awsVms = AwsVmsDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchInventoryResponse {
    return {
      vmwareVms: isSet(object.vmwareVms) ? VmwareVmsDetails.fromJSON(object.vmwareVms) : undefined,
      awsVms: isSet(object.awsVms) ? AwsVmsDetails.fromJSON(object.awsVms) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: FetchInventoryResponse): unknown {
    const obj: any = {};
    if (message.vmwareVms !== undefined) {
      obj.vmwareVms = VmwareVmsDetails.toJSON(message.vmwareVms);
    }
    if (message.awsVms !== undefined) {
      obj.awsVms = AwsVmsDetails.toJSON(message.awsVms);
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<FetchInventoryResponse>): FetchInventoryResponse {
    return FetchInventoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchInventoryResponse>): FetchInventoryResponse {
    const message = createBaseFetchInventoryResponse();
    message.vmwareVms = (object.vmwareVms !== undefined && object.vmwareVms !== null)
      ? VmwareVmsDetails.fromPartial(object.vmwareVms)
      : undefined;
    message.awsVms = (object.awsVms !== undefined && object.awsVms !== null)
      ? AwsVmsDetails.fromPartial(object.awsVms)
      : undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseUtilizationReport(): UtilizationReport {
  return {
    name: "",
    displayName: "",
    state: 0,
    stateTime: undefined,
    error: undefined,
    createTime: undefined,
    timeFrame: 0,
    frameEndTime: undefined,
    vmCount: 0,
    vms: [],
  };
}

export const UtilizationReport: MessageFns<UtilizationReport> = {
  encode(message: UtilizationReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.stateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.stateTime), writer.uint32(34).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(42).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.timeFrame !== 0) {
      writer.uint32(56).int32(message.timeFrame);
    }
    if (message.frameEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.frameEndTime), writer.uint32(66).fork()).join();
    }
    if (message.vmCount !== 0) {
      writer.uint32(72).int32(message.vmCount);
    }
    for (const v of message.vms) {
      VmUtilizationInfo.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UtilizationReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUtilizationReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.timeFrame = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.frameEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.vmCount = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.vms.push(VmUtilizationInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UtilizationReport {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      state: isSet(object.state) ? utilizationReport_StateFromJSON(object.state) : 0,
      stateTime: isSet(object.stateTime) ? fromJsonTimestamp(object.stateTime) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      timeFrame: isSet(object.timeFrame) ? utilizationReport_TimeFrameFromJSON(object.timeFrame) : 0,
      frameEndTime: isSet(object.frameEndTime) ? fromJsonTimestamp(object.frameEndTime) : undefined,
      vmCount: isSet(object.vmCount) ? globalThis.Number(object.vmCount) : 0,
      vms: globalThis.Array.isArray(object?.vms) ? object.vms.map((e: any) => VmUtilizationInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: UtilizationReport): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.state !== 0) {
      obj.state = utilizationReport_StateToJSON(message.state);
    }
    if (message.stateTime !== undefined) {
      obj.stateTime = message.stateTime.toISOString();
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.timeFrame !== 0) {
      obj.timeFrame = utilizationReport_TimeFrameToJSON(message.timeFrame);
    }
    if (message.frameEndTime !== undefined) {
      obj.frameEndTime = message.frameEndTime.toISOString();
    }
    if (message.vmCount !== 0) {
      obj.vmCount = Math.round(message.vmCount);
    }
    if (message.vms?.length) {
      obj.vms = message.vms.map((e) => VmUtilizationInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UtilizationReport>): UtilizationReport {
    return UtilizationReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UtilizationReport>): UtilizationReport {
    const message = createBaseUtilizationReport();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.state = object.state ?? 0;
    message.stateTime = object.stateTime ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.timeFrame = object.timeFrame ?? 0;
    message.frameEndTime = object.frameEndTime ?? undefined;
    message.vmCount = object.vmCount ?? 0;
    message.vms = object.vms?.map((e) => VmUtilizationInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVmUtilizationInfo(): VmUtilizationInfo {
  return { vmwareVmDetails: undefined, vmId: "", utilization: undefined };
}

export const VmUtilizationInfo: MessageFns<VmUtilizationInfo> = {
  encode(message: VmUtilizationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vmwareVmDetails !== undefined) {
      VmwareVmDetails.encode(message.vmwareVmDetails, writer.uint32(10).fork()).join();
    }
    if (message.vmId !== "") {
      writer.uint32(26).string(message.vmId);
    }
    if (message.utilization !== undefined) {
      VmUtilizationMetrics.encode(message.utilization, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmUtilizationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmUtilizationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vmwareVmDetails = VmwareVmDetails.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vmId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.utilization = VmUtilizationMetrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmUtilizationInfo {
    return {
      vmwareVmDetails: isSet(object.vmwareVmDetails) ? VmwareVmDetails.fromJSON(object.vmwareVmDetails) : undefined,
      vmId: isSet(object.vmId) ? globalThis.String(object.vmId) : "",
      utilization: isSet(object.utilization) ? VmUtilizationMetrics.fromJSON(object.utilization) : undefined,
    };
  },

  toJSON(message: VmUtilizationInfo): unknown {
    const obj: any = {};
    if (message.vmwareVmDetails !== undefined) {
      obj.vmwareVmDetails = VmwareVmDetails.toJSON(message.vmwareVmDetails);
    }
    if (message.vmId !== "") {
      obj.vmId = message.vmId;
    }
    if (message.utilization !== undefined) {
      obj.utilization = VmUtilizationMetrics.toJSON(message.utilization);
    }
    return obj;
  },

  create(base?: DeepPartial<VmUtilizationInfo>): VmUtilizationInfo {
    return VmUtilizationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VmUtilizationInfo>): VmUtilizationInfo {
    const message = createBaseVmUtilizationInfo();
    message.vmwareVmDetails = (object.vmwareVmDetails !== undefined && object.vmwareVmDetails !== null)
      ? VmwareVmDetails.fromPartial(object.vmwareVmDetails)
      : undefined;
    message.vmId = object.vmId ?? "";
    message.utilization = (object.utilization !== undefined && object.utilization !== null)
      ? VmUtilizationMetrics.fromPartial(object.utilization)
      : undefined;
    return message;
  },
};

function createBaseVmUtilizationMetrics(): VmUtilizationMetrics {
  return {
    cpuMaxPercent: 0,
    cpuAveragePercent: 0,
    memoryMaxPercent: 0,
    memoryAveragePercent: 0,
    diskIoRateMaxKbps: Long.ZERO,
    diskIoRateAverageKbps: Long.ZERO,
    networkThroughputMaxKbps: Long.ZERO,
    networkThroughputAverageKbps: Long.ZERO,
  };
}

export const VmUtilizationMetrics: MessageFns<VmUtilizationMetrics> = {
  encode(message: VmUtilizationMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuMaxPercent !== 0) {
      writer.uint32(72).int32(message.cpuMaxPercent);
    }
    if (message.cpuAveragePercent !== 0) {
      writer.uint32(80).int32(message.cpuAveragePercent);
    }
    if (message.memoryMaxPercent !== 0) {
      writer.uint32(88).int32(message.memoryMaxPercent);
    }
    if (message.memoryAveragePercent !== 0) {
      writer.uint32(96).int32(message.memoryAveragePercent);
    }
    if (!message.diskIoRateMaxKbps.equals(Long.ZERO)) {
      writer.uint32(104).int64(message.diskIoRateMaxKbps.toString());
    }
    if (!message.diskIoRateAverageKbps.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.diskIoRateAverageKbps.toString());
    }
    if (!message.networkThroughputMaxKbps.equals(Long.ZERO)) {
      writer.uint32(120).int64(message.networkThroughputMaxKbps.toString());
    }
    if (!message.networkThroughputAverageKbps.equals(Long.ZERO)) {
      writer.uint32(128).int64(message.networkThroughputAverageKbps.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmUtilizationMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmUtilizationMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 9:
          if (tag !== 72) {
            break;
          }

          message.cpuMaxPercent = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.cpuAveragePercent = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.memoryMaxPercent = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.memoryAveragePercent = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.diskIoRateMaxKbps = Long.fromString(reader.int64().toString());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.diskIoRateAverageKbps = Long.fromString(reader.int64().toString());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.networkThroughputMaxKbps = Long.fromString(reader.int64().toString());
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.networkThroughputAverageKbps = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmUtilizationMetrics {
    return {
      cpuMaxPercent: isSet(object.cpuMaxPercent) ? globalThis.Number(object.cpuMaxPercent) : 0,
      cpuAveragePercent: isSet(object.cpuAveragePercent) ? globalThis.Number(object.cpuAveragePercent) : 0,
      memoryMaxPercent: isSet(object.memoryMaxPercent) ? globalThis.Number(object.memoryMaxPercent) : 0,
      memoryAveragePercent: isSet(object.memoryAveragePercent) ? globalThis.Number(object.memoryAveragePercent) : 0,
      diskIoRateMaxKbps: isSet(object.diskIoRateMaxKbps) ? Long.fromValue(object.diskIoRateMaxKbps) : Long.ZERO,
      diskIoRateAverageKbps: isSet(object.diskIoRateAverageKbps)
        ? Long.fromValue(object.diskIoRateAverageKbps)
        : Long.ZERO,
      networkThroughputMaxKbps: isSet(object.networkThroughputMaxKbps)
        ? Long.fromValue(object.networkThroughputMaxKbps)
        : Long.ZERO,
      networkThroughputAverageKbps: isSet(object.networkThroughputAverageKbps)
        ? Long.fromValue(object.networkThroughputAverageKbps)
        : Long.ZERO,
    };
  },

  toJSON(message: VmUtilizationMetrics): unknown {
    const obj: any = {};
    if (message.cpuMaxPercent !== 0) {
      obj.cpuMaxPercent = Math.round(message.cpuMaxPercent);
    }
    if (message.cpuAveragePercent !== 0) {
      obj.cpuAveragePercent = Math.round(message.cpuAveragePercent);
    }
    if (message.memoryMaxPercent !== 0) {
      obj.memoryMaxPercent = Math.round(message.memoryMaxPercent);
    }
    if (message.memoryAveragePercent !== 0) {
      obj.memoryAveragePercent = Math.round(message.memoryAveragePercent);
    }
    if (!message.diskIoRateMaxKbps.equals(Long.ZERO)) {
      obj.diskIoRateMaxKbps = (message.diskIoRateMaxKbps || Long.ZERO).toString();
    }
    if (!message.diskIoRateAverageKbps.equals(Long.ZERO)) {
      obj.diskIoRateAverageKbps = (message.diskIoRateAverageKbps || Long.ZERO).toString();
    }
    if (!message.networkThroughputMaxKbps.equals(Long.ZERO)) {
      obj.networkThroughputMaxKbps = (message.networkThroughputMaxKbps || Long.ZERO).toString();
    }
    if (!message.networkThroughputAverageKbps.equals(Long.ZERO)) {
      obj.networkThroughputAverageKbps = (message.networkThroughputAverageKbps || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<VmUtilizationMetrics>): VmUtilizationMetrics {
    return VmUtilizationMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VmUtilizationMetrics>): VmUtilizationMetrics {
    const message = createBaseVmUtilizationMetrics();
    message.cpuMaxPercent = object.cpuMaxPercent ?? 0;
    message.cpuAveragePercent = object.cpuAveragePercent ?? 0;
    message.memoryMaxPercent = object.memoryMaxPercent ?? 0;
    message.memoryAveragePercent = object.memoryAveragePercent ?? 0;
    message.diskIoRateMaxKbps = (object.diskIoRateMaxKbps !== undefined && object.diskIoRateMaxKbps !== null)
      ? Long.fromValue(object.diskIoRateMaxKbps)
      : Long.ZERO;
    message.diskIoRateAverageKbps =
      (object.diskIoRateAverageKbps !== undefined && object.diskIoRateAverageKbps !== null)
        ? Long.fromValue(object.diskIoRateAverageKbps)
        : Long.ZERO;
    message.networkThroughputMaxKbps =
      (object.networkThroughputMaxKbps !== undefined && object.networkThroughputMaxKbps !== null)
        ? Long.fromValue(object.networkThroughputMaxKbps)
        : Long.ZERO;
    message.networkThroughputAverageKbps =
      (object.networkThroughputAverageKbps !== undefined && object.networkThroughputAverageKbps !== null)
        ? Long.fromValue(object.networkThroughputAverageKbps)
        : Long.ZERO;
    return message;
  },
};

function createBaseListUtilizationReportsRequest(): ListUtilizationReportsRequest {
  return { parent: "", view: 0, pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListUtilizationReportsRequest: MessageFns<ListUtilizationReportsRequest> = {
  encode(message: ListUtilizationReportsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(50).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUtilizationReportsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUtilizationReportsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUtilizationReportsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      view: isSet(object.view) ? utilizationReportViewFromJSON(object.view) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListUtilizationReportsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.view !== 0) {
      obj.view = utilizationReportViewToJSON(message.view);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUtilizationReportsRequest>): ListUtilizationReportsRequest {
    return ListUtilizationReportsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUtilizationReportsRequest>): ListUtilizationReportsRequest {
    const message = createBaseListUtilizationReportsRequest();
    message.parent = object.parent ?? "";
    message.view = object.view ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListUtilizationReportsResponse(): ListUtilizationReportsResponse {
  return { utilizationReports: [], nextPageToken: "", unreachable: [] };
}

export const ListUtilizationReportsResponse: MessageFns<ListUtilizationReportsResponse> = {
  encode(message: ListUtilizationReportsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.utilizationReports) {
      UtilizationReport.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUtilizationReportsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUtilizationReportsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.utilizationReports.push(UtilizationReport.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUtilizationReportsResponse {
    return {
      utilizationReports: globalThis.Array.isArray(object?.utilizationReports)
        ? object.utilizationReports.map((e: any) => UtilizationReport.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListUtilizationReportsResponse): unknown {
    const obj: any = {};
    if (message.utilizationReports?.length) {
      obj.utilizationReports = message.utilizationReports.map((e) => UtilizationReport.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUtilizationReportsResponse>): ListUtilizationReportsResponse {
    return ListUtilizationReportsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUtilizationReportsResponse>): ListUtilizationReportsResponse {
    const message = createBaseListUtilizationReportsResponse();
    message.utilizationReports = object.utilizationReports?.map((e) => UtilizationReport.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetUtilizationReportRequest(): GetUtilizationReportRequest {
  return { name: "", view: 0 };
}

export const GetUtilizationReportRequest: MessageFns<GetUtilizationReportRequest> = {
  encode(message: GetUtilizationReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUtilizationReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUtilizationReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUtilizationReportRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? utilizationReportViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetUtilizationReportRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = utilizationReportViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetUtilizationReportRequest>): GetUtilizationReportRequest {
    return GetUtilizationReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUtilizationReportRequest>): GetUtilizationReportRequest {
    const message = createBaseGetUtilizationReportRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseCreateUtilizationReportRequest(): CreateUtilizationReportRequest {
  return { parent: "", utilizationReport: undefined, utilizationReportId: "", requestId: "" };
}

export const CreateUtilizationReportRequest: MessageFns<CreateUtilizationReportRequest> = {
  encode(message: CreateUtilizationReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.utilizationReport !== undefined) {
      UtilizationReport.encode(message.utilizationReport, writer.uint32(18).fork()).join();
    }
    if (message.utilizationReportId !== "") {
      writer.uint32(26).string(message.utilizationReportId);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUtilizationReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUtilizationReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.utilizationReport = UtilizationReport.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.utilizationReportId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUtilizationReportRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      utilizationReport: isSet(object.utilizationReport)
        ? UtilizationReport.fromJSON(object.utilizationReport)
        : undefined,
      utilizationReportId: isSet(object.utilizationReportId) ? globalThis.String(object.utilizationReportId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateUtilizationReportRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.utilizationReport !== undefined) {
      obj.utilizationReport = UtilizationReport.toJSON(message.utilizationReport);
    }
    if (message.utilizationReportId !== "") {
      obj.utilizationReportId = message.utilizationReportId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateUtilizationReportRequest>): CreateUtilizationReportRequest {
    return CreateUtilizationReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateUtilizationReportRequest>): CreateUtilizationReportRequest {
    const message = createBaseCreateUtilizationReportRequest();
    message.parent = object.parent ?? "";
    message.utilizationReport = (object.utilizationReport !== undefined && object.utilizationReport !== null)
      ? UtilizationReport.fromPartial(object.utilizationReport)
      : undefined;
    message.utilizationReportId = object.utilizationReportId ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteUtilizationReportRequest(): DeleteUtilizationReportRequest {
  return { name: "", requestId: "" };
}

export const DeleteUtilizationReportRequest: MessageFns<DeleteUtilizationReportRequest> = {
  encode(message: DeleteUtilizationReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUtilizationReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUtilizationReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUtilizationReportRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteUtilizationReportRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteUtilizationReportRequest>): DeleteUtilizationReportRequest {
    return DeleteUtilizationReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteUtilizationReportRequest>): DeleteUtilizationReportRequest {
    const message = createBaseDeleteUtilizationReportRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListDatacenterConnectorsResponse(): ListDatacenterConnectorsResponse {
  return { datacenterConnectors: [], nextPageToken: "", unreachable: [] };
}

export const ListDatacenterConnectorsResponse: MessageFns<ListDatacenterConnectorsResponse> = {
  encode(message: ListDatacenterConnectorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.datacenterConnectors) {
      DatacenterConnector.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatacenterConnectorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatacenterConnectorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datacenterConnectors.push(DatacenterConnector.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatacenterConnectorsResponse {
    return {
      datacenterConnectors: globalThis.Array.isArray(object?.datacenterConnectors)
        ? object.datacenterConnectors.map((e: any) => DatacenterConnector.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListDatacenterConnectorsResponse): unknown {
    const obj: any = {};
    if (message.datacenterConnectors?.length) {
      obj.datacenterConnectors = message.datacenterConnectors.map((e) => DatacenterConnector.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDatacenterConnectorsResponse>): ListDatacenterConnectorsResponse {
    return ListDatacenterConnectorsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDatacenterConnectorsResponse>): ListDatacenterConnectorsResponse {
    const message = createBaseListDatacenterConnectorsResponse();
    message.datacenterConnectors = object.datacenterConnectors?.map((e) => DatacenterConnector.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetDatacenterConnectorRequest(): GetDatacenterConnectorRequest {
  return { name: "" };
}

export const GetDatacenterConnectorRequest: MessageFns<GetDatacenterConnectorRequest> = {
  encode(message: GetDatacenterConnectorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatacenterConnectorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatacenterConnectorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatacenterConnectorRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDatacenterConnectorRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDatacenterConnectorRequest>): GetDatacenterConnectorRequest {
    return GetDatacenterConnectorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDatacenterConnectorRequest>): GetDatacenterConnectorRequest {
    const message = createBaseGetDatacenterConnectorRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateDatacenterConnectorRequest(): CreateDatacenterConnectorRequest {
  return { parent: "", datacenterConnectorId: "", datacenterConnector: undefined, requestId: "" };
}

export const CreateDatacenterConnectorRequest: MessageFns<CreateDatacenterConnectorRequest> = {
  encode(message: CreateDatacenterConnectorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.datacenterConnectorId !== "") {
      writer.uint32(18).string(message.datacenterConnectorId);
    }
    if (message.datacenterConnector !== undefined) {
      DatacenterConnector.encode(message.datacenterConnector, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDatacenterConnectorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDatacenterConnectorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.datacenterConnectorId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.datacenterConnector = DatacenterConnector.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDatacenterConnectorRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      datacenterConnectorId: isSet(object.datacenterConnectorId) ? globalThis.String(object.datacenterConnectorId) : "",
      datacenterConnector: isSet(object.datacenterConnector)
        ? DatacenterConnector.fromJSON(object.datacenterConnector)
        : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateDatacenterConnectorRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.datacenterConnectorId !== "") {
      obj.datacenterConnectorId = message.datacenterConnectorId;
    }
    if (message.datacenterConnector !== undefined) {
      obj.datacenterConnector = DatacenterConnector.toJSON(message.datacenterConnector);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDatacenterConnectorRequest>): CreateDatacenterConnectorRequest {
    return CreateDatacenterConnectorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDatacenterConnectorRequest>): CreateDatacenterConnectorRequest {
    const message = createBaseCreateDatacenterConnectorRequest();
    message.parent = object.parent ?? "";
    message.datacenterConnectorId = object.datacenterConnectorId ?? "";
    message.datacenterConnector = (object.datacenterConnector !== undefined && object.datacenterConnector !== null)
      ? DatacenterConnector.fromPartial(object.datacenterConnector)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteDatacenterConnectorRequest(): DeleteDatacenterConnectorRequest {
  return { name: "", requestId: "" };
}

export const DeleteDatacenterConnectorRequest: MessageFns<DeleteDatacenterConnectorRequest> = {
  encode(message: DeleteDatacenterConnectorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDatacenterConnectorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDatacenterConnectorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDatacenterConnectorRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteDatacenterConnectorRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDatacenterConnectorRequest>): DeleteDatacenterConnectorRequest {
    return DeleteDatacenterConnectorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDatacenterConnectorRequest>): DeleteDatacenterConnectorRequest {
    const message = createBaseDeleteDatacenterConnectorRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpgradeApplianceRequest(): UpgradeApplianceRequest {
  return { datacenterConnector: "", requestId: "" };
}

export const UpgradeApplianceRequest: MessageFns<UpgradeApplianceRequest> = {
  encode(message: UpgradeApplianceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.datacenterConnector !== "") {
      writer.uint32(10).string(message.datacenterConnector);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpgradeApplianceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpgradeApplianceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datacenterConnector = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpgradeApplianceRequest {
    return {
      datacenterConnector: isSet(object.datacenterConnector) ? globalThis.String(object.datacenterConnector) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpgradeApplianceRequest): unknown {
    const obj: any = {};
    if (message.datacenterConnector !== "") {
      obj.datacenterConnector = message.datacenterConnector;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpgradeApplianceRequest>): UpgradeApplianceRequest {
    return UpgradeApplianceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpgradeApplianceRequest>): UpgradeApplianceRequest {
    const message = createBaseUpgradeApplianceRequest();
    message.datacenterConnector = object.datacenterConnector ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpgradeApplianceResponse(): UpgradeApplianceResponse {
  return {};
}

export const UpgradeApplianceResponse: MessageFns<UpgradeApplianceResponse> = {
  encode(_: UpgradeApplianceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpgradeApplianceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpgradeApplianceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpgradeApplianceResponse {
    return {};
  },

  toJSON(_: UpgradeApplianceResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UpgradeApplianceResponse>): UpgradeApplianceResponse {
    return UpgradeApplianceResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UpgradeApplianceResponse>): UpgradeApplianceResponse {
    const message = createBaseUpgradeApplianceResponse();
    return message;
  },
};

function createBaseListDatacenterConnectorsRequest(): ListDatacenterConnectorsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListDatacenterConnectorsRequest: MessageFns<ListDatacenterConnectorsRequest> = {
  encode(message: ListDatacenterConnectorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatacenterConnectorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatacenterConnectorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatacenterConnectorsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListDatacenterConnectorsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDatacenterConnectorsRequest>): ListDatacenterConnectorsRequest {
    return ListDatacenterConnectorsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDatacenterConnectorsRequest>): ListDatacenterConnectorsRequest {
    const message = createBaseListDatacenterConnectorsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseComputeEngineTargetDefaults(): ComputeEngineTargetDefaults {
  return {
    vmName: "",
    targetProject: "",
    zone: "",
    machineTypeSeries: "",
    machineType: "",
    networkTags: [],
    networkInterfaces: [],
    serviceAccount: "",
    diskType: 0,
    labels: {},
    licenseType: 0,
    appliedLicense: undefined,
    computeScheduling: undefined,
    secureBoot: false,
    bootOption: 0,
    metadata: {},
    additionalLicenses: [],
    hostname: "",
  };
}

export const ComputeEngineTargetDefaults: MessageFns<ComputeEngineTargetDefaults> = {
  encode(message: ComputeEngineTargetDefaults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vmName !== "") {
      writer.uint32(10).string(message.vmName);
    }
    if (message.targetProject !== "") {
      writer.uint32(18).string(message.targetProject);
    }
    if (message.zone !== "") {
      writer.uint32(26).string(message.zone);
    }
    if (message.machineTypeSeries !== "") {
      writer.uint32(34).string(message.machineTypeSeries);
    }
    if (message.machineType !== "") {
      writer.uint32(42).string(message.machineType);
    }
    for (const v of message.networkTags) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.networkInterfaces) {
      NetworkInterface.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.serviceAccount !== "") {
      writer.uint32(66).string(message.serviceAccount);
    }
    if (message.diskType !== 0) {
      writer.uint32(72).int32(message.diskType);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ComputeEngineTargetDefaults_LabelsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.licenseType !== 0) {
      writer.uint32(88).int32(message.licenseType);
    }
    if (message.appliedLicense !== undefined) {
      AppliedLicense.encode(message.appliedLicense, writer.uint32(98).fork()).join();
    }
    if (message.computeScheduling !== undefined) {
      ComputeScheduling.encode(message.computeScheduling, writer.uint32(106).fork()).join();
    }
    if (message.secureBoot !== false) {
      writer.uint32(112).bool(message.secureBoot);
    }
    if (message.bootOption !== 0) {
      writer.uint32(120).int32(message.bootOption);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ComputeEngineTargetDefaults_MetadataEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    for (const v of message.additionalLicenses) {
      writer.uint32(138).string(v!);
    }
    if (message.hostname !== "") {
      writer.uint32(146).string(message.hostname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeEngineTargetDefaults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeEngineTargetDefaults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vmName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetProject = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.machineTypeSeries = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.networkTags.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.networkInterfaces.push(NetworkInterface.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.diskType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = ComputeEngineTargetDefaults_LabelsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.labels[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.licenseType = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.appliedLicense = AppliedLicense.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.computeScheduling = ComputeScheduling.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.secureBoot = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.bootOption = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          const entry16 = ComputeEngineTargetDefaults_MetadataEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.metadata[entry16.key] = entry16.value;
          }
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.additionalLicenses.push(reader.string());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.hostname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeEngineTargetDefaults {
    return {
      vmName: isSet(object.vmName) ? globalThis.String(object.vmName) : "",
      targetProject: isSet(object.targetProject) ? globalThis.String(object.targetProject) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      machineTypeSeries: isSet(object.machineTypeSeries) ? globalThis.String(object.machineTypeSeries) : "",
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      networkTags: globalThis.Array.isArray(object?.networkTags)
        ? object.networkTags.map((e: any) => globalThis.String(e))
        : [],
      networkInterfaces: globalThis.Array.isArray(object?.networkInterfaces)
        ? object.networkInterfaces.map((e: any) => NetworkInterface.fromJSON(e))
        : [],
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      diskType: isSet(object.diskType) ? computeEngineDiskTypeFromJSON(object.diskType) : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      licenseType: isSet(object.licenseType) ? computeEngineLicenseTypeFromJSON(object.licenseType) : 0,
      appliedLicense: isSet(object.appliedLicense) ? AppliedLicense.fromJSON(object.appliedLicense) : undefined,
      computeScheduling: isSet(object.computeScheduling)
        ? ComputeScheduling.fromJSON(object.computeScheduling)
        : undefined,
      secureBoot: isSet(object.secureBoot) ? globalThis.Boolean(object.secureBoot) : false,
      bootOption: isSet(object.bootOption) ? computeEngineBootOptionFromJSON(object.bootOption) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      additionalLicenses: globalThis.Array.isArray(object?.additionalLicenses)
        ? object.additionalLicenses.map((e: any) => globalThis.String(e))
        : [],
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
    };
  },

  toJSON(message: ComputeEngineTargetDefaults): unknown {
    const obj: any = {};
    if (message.vmName !== "") {
      obj.vmName = message.vmName;
    }
    if (message.targetProject !== "") {
      obj.targetProject = message.targetProject;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.machineTypeSeries !== "") {
      obj.machineTypeSeries = message.machineTypeSeries;
    }
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.networkTags?.length) {
      obj.networkTags = message.networkTags;
    }
    if (message.networkInterfaces?.length) {
      obj.networkInterfaces = message.networkInterfaces.map((e) => NetworkInterface.toJSON(e));
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.diskType !== 0) {
      obj.diskType = computeEngineDiskTypeToJSON(message.diskType);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.licenseType !== 0) {
      obj.licenseType = computeEngineLicenseTypeToJSON(message.licenseType);
    }
    if (message.appliedLicense !== undefined) {
      obj.appliedLicense = AppliedLicense.toJSON(message.appliedLicense);
    }
    if (message.computeScheduling !== undefined) {
      obj.computeScheduling = ComputeScheduling.toJSON(message.computeScheduling);
    }
    if (message.secureBoot !== false) {
      obj.secureBoot = message.secureBoot;
    }
    if (message.bootOption !== 0) {
      obj.bootOption = computeEngineBootOptionToJSON(message.bootOption);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.additionalLicenses?.length) {
      obj.additionalLicenses = message.additionalLicenses;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeEngineTargetDefaults>): ComputeEngineTargetDefaults {
    return ComputeEngineTargetDefaults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeEngineTargetDefaults>): ComputeEngineTargetDefaults {
    const message = createBaseComputeEngineTargetDefaults();
    message.vmName = object.vmName ?? "";
    message.targetProject = object.targetProject ?? "";
    message.zone = object.zone ?? "";
    message.machineTypeSeries = object.machineTypeSeries ?? "";
    message.machineType = object.machineType ?? "";
    message.networkTags = object.networkTags?.map((e) => e) || [];
    message.networkInterfaces = object.networkInterfaces?.map((e) => NetworkInterface.fromPartial(e)) || [];
    message.serviceAccount = object.serviceAccount ?? "";
    message.diskType = object.diskType ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.licenseType = object.licenseType ?? 0;
    message.appliedLicense = (object.appliedLicense !== undefined && object.appliedLicense !== null)
      ? AppliedLicense.fromPartial(object.appliedLicense)
      : undefined;
    message.computeScheduling = (object.computeScheduling !== undefined && object.computeScheduling !== null)
      ? ComputeScheduling.fromPartial(object.computeScheduling)
      : undefined;
    message.secureBoot = object.secureBoot ?? false;
    message.bootOption = object.bootOption ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.additionalLicenses = object.additionalLicenses?.map((e) => e) || [];
    message.hostname = object.hostname ?? "";
    return message;
  },
};

function createBaseComputeEngineTargetDefaults_LabelsEntry(): ComputeEngineTargetDefaults_LabelsEntry {
  return { key: "", value: "" };
}

export const ComputeEngineTargetDefaults_LabelsEntry: MessageFns<ComputeEngineTargetDefaults_LabelsEntry> = {
  encode(message: ComputeEngineTargetDefaults_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeEngineTargetDefaults_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeEngineTargetDefaults_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeEngineTargetDefaults_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ComputeEngineTargetDefaults_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeEngineTargetDefaults_LabelsEntry>): ComputeEngineTargetDefaults_LabelsEntry {
    return ComputeEngineTargetDefaults_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeEngineTargetDefaults_LabelsEntry>): ComputeEngineTargetDefaults_LabelsEntry {
    const message = createBaseComputeEngineTargetDefaults_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseComputeEngineTargetDefaults_MetadataEntry(): ComputeEngineTargetDefaults_MetadataEntry {
  return { key: "", value: "" };
}

export const ComputeEngineTargetDefaults_MetadataEntry: MessageFns<ComputeEngineTargetDefaults_MetadataEntry> = {
  encode(message: ComputeEngineTargetDefaults_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeEngineTargetDefaults_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeEngineTargetDefaults_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeEngineTargetDefaults_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ComputeEngineTargetDefaults_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeEngineTargetDefaults_MetadataEntry>): ComputeEngineTargetDefaults_MetadataEntry {
    return ComputeEngineTargetDefaults_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ComputeEngineTargetDefaults_MetadataEntry>,
  ): ComputeEngineTargetDefaults_MetadataEntry {
    const message = createBaseComputeEngineTargetDefaults_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseComputeEngineTargetDetails(): ComputeEngineTargetDetails {
  return {
    vmName: "",
    project: "",
    zone: "",
    machineTypeSeries: "",
    machineType: "",
    networkTags: [],
    networkInterfaces: [],
    serviceAccount: "",
    diskType: 0,
    labels: {},
    licenseType: 0,
    appliedLicense: undefined,
    computeScheduling: undefined,
    secureBoot: false,
    bootOption: 0,
    metadata: {},
    additionalLicenses: [],
    hostname: "",
  };
}

export const ComputeEngineTargetDetails: MessageFns<ComputeEngineTargetDetails> = {
  encode(message: ComputeEngineTargetDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vmName !== "") {
      writer.uint32(10).string(message.vmName);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.zone !== "") {
      writer.uint32(26).string(message.zone);
    }
    if (message.machineTypeSeries !== "") {
      writer.uint32(34).string(message.machineTypeSeries);
    }
    if (message.machineType !== "") {
      writer.uint32(42).string(message.machineType);
    }
    for (const v of message.networkTags) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.networkInterfaces) {
      NetworkInterface.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.serviceAccount !== "") {
      writer.uint32(66).string(message.serviceAccount);
    }
    if (message.diskType !== 0) {
      writer.uint32(72).int32(message.diskType);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ComputeEngineTargetDetails_LabelsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.licenseType !== 0) {
      writer.uint32(88).int32(message.licenseType);
    }
    if (message.appliedLicense !== undefined) {
      AppliedLicense.encode(message.appliedLicense, writer.uint32(98).fork()).join();
    }
    if (message.computeScheduling !== undefined) {
      ComputeScheduling.encode(message.computeScheduling, writer.uint32(106).fork()).join();
    }
    if (message.secureBoot !== false) {
      writer.uint32(112).bool(message.secureBoot);
    }
    if (message.bootOption !== 0) {
      writer.uint32(120).int32(message.bootOption);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ComputeEngineTargetDetails_MetadataEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    for (const v of message.additionalLicenses) {
      writer.uint32(138).string(v!);
    }
    if (message.hostname !== "") {
      writer.uint32(146).string(message.hostname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeEngineTargetDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeEngineTargetDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vmName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.machineTypeSeries = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.networkTags.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.networkInterfaces.push(NetworkInterface.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.diskType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = ComputeEngineTargetDetails_LabelsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.labels[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.licenseType = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.appliedLicense = AppliedLicense.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.computeScheduling = ComputeScheduling.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.secureBoot = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.bootOption = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          const entry16 = ComputeEngineTargetDetails_MetadataEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.metadata[entry16.key] = entry16.value;
          }
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.additionalLicenses.push(reader.string());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.hostname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeEngineTargetDetails {
    return {
      vmName: isSet(object.vmName) ? globalThis.String(object.vmName) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      machineTypeSeries: isSet(object.machineTypeSeries) ? globalThis.String(object.machineTypeSeries) : "",
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      networkTags: globalThis.Array.isArray(object?.networkTags)
        ? object.networkTags.map((e: any) => globalThis.String(e))
        : [],
      networkInterfaces: globalThis.Array.isArray(object?.networkInterfaces)
        ? object.networkInterfaces.map((e: any) => NetworkInterface.fromJSON(e))
        : [],
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      diskType: isSet(object.diskType) ? computeEngineDiskTypeFromJSON(object.diskType) : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      licenseType: isSet(object.licenseType) ? computeEngineLicenseTypeFromJSON(object.licenseType) : 0,
      appliedLicense: isSet(object.appliedLicense) ? AppliedLicense.fromJSON(object.appliedLicense) : undefined,
      computeScheduling: isSet(object.computeScheduling)
        ? ComputeScheduling.fromJSON(object.computeScheduling)
        : undefined,
      secureBoot: isSet(object.secureBoot) ? globalThis.Boolean(object.secureBoot) : false,
      bootOption: isSet(object.bootOption) ? computeEngineBootOptionFromJSON(object.bootOption) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      additionalLicenses: globalThis.Array.isArray(object?.additionalLicenses)
        ? object.additionalLicenses.map((e: any) => globalThis.String(e))
        : [],
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
    };
  },

  toJSON(message: ComputeEngineTargetDetails): unknown {
    const obj: any = {};
    if (message.vmName !== "") {
      obj.vmName = message.vmName;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.machineTypeSeries !== "") {
      obj.machineTypeSeries = message.machineTypeSeries;
    }
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.networkTags?.length) {
      obj.networkTags = message.networkTags;
    }
    if (message.networkInterfaces?.length) {
      obj.networkInterfaces = message.networkInterfaces.map((e) => NetworkInterface.toJSON(e));
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.diskType !== 0) {
      obj.diskType = computeEngineDiskTypeToJSON(message.diskType);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.licenseType !== 0) {
      obj.licenseType = computeEngineLicenseTypeToJSON(message.licenseType);
    }
    if (message.appliedLicense !== undefined) {
      obj.appliedLicense = AppliedLicense.toJSON(message.appliedLicense);
    }
    if (message.computeScheduling !== undefined) {
      obj.computeScheduling = ComputeScheduling.toJSON(message.computeScheduling);
    }
    if (message.secureBoot !== false) {
      obj.secureBoot = message.secureBoot;
    }
    if (message.bootOption !== 0) {
      obj.bootOption = computeEngineBootOptionToJSON(message.bootOption);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.additionalLicenses?.length) {
      obj.additionalLicenses = message.additionalLicenses;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeEngineTargetDetails>): ComputeEngineTargetDetails {
    return ComputeEngineTargetDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeEngineTargetDetails>): ComputeEngineTargetDetails {
    const message = createBaseComputeEngineTargetDetails();
    message.vmName = object.vmName ?? "";
    message.project = object.project ?? "";
    message.zone = object.zone ?? "";
    message.machineTypeSeries = object.machineTypeSeries ?? "";
    message.machineType = object.machineType ?? "";
    message.networkTags = object.networkTags?.map((e) => e) || [];
    message.networkInterfaces = object.networkInterfaces?.map((e) => NetworkInterface.fromPartial(e)) || [];
    message.serviceAccount = object.serviceAccount ?? "";
    message.diskType = object.diskType ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.licenseType = object.licenseType ?? 0;
    message.appliedLicense = (object.appliedLicense !== undefined && object.appliedLicense !== null)
      ? AppliedLicense.fromPartial(object.appliedLicense)
      : undefined;
    message.computeScheduling = (object.computeScheduling !== undefined && object.computeScheduling !== null)
      ? ComputeScheduling.fromPartial(object.computeScheduling)
      : undefined;
    message.secureBoot = object.secureBoot ?? false;
    message.bootOption = object.bootOption ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.additionalLicenses = object.additionalLicenses?.map((e) => e) || [];
    message.hostname = object.hostname ?? "";
    return message;
  },
};

function createBaseComputeEngineTargetDetails_LabelsEntry(): ComputeEngineTargetDetails_LabelsEntry {
  return { key: "", value: "" };
}

export const ComputeEngineTargetDetails_LabelsEntry: MessageFns<ComputeEngineTargetDetails_LabelsEntry> = {
  encode(message: ComputeEngineTargetDetails_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeEngineTargetDetails_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeEngineTargetDetails_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeEngineTargetDetails_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ComputeEngineTargetDetails_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeEngineTargetDetails_LabelsEntry>): ComputeEngineTargetDetails_LabelsEntry {
    return ComputeEngineTargetDetails_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeEngineTargetDetails_LabelsEntry>): ComputeEngineTargetDetails_LabelsEntry {
    const message = createBaseComputeEngineTargetDetails_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseComputeEngineTargetDetails_MetadataEntry(): ComputeEngineTargetDetails_MetadataEntry {
  return { key: "", value: "" };
}

export const ComputeEngineTargetDetails_MetadataEntry: MessageFns<ComputeEngineTargetDetails_MetadataEntry> = {
  encode(message: ComputeEngineTargetDetails_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeEngineTargetDetails_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeEngineTargetDetails_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeEngineTargetDetails_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ComputeEngineTargetDetails_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeEngineTargetDetails_MetadataEntry>): ComputeEngineTargetDetails_MetadataEntry {
    return ComputeEngineTargetDetails_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeEngineTargetDetails_MetadataEntry>): ComputeEngineTargetDetails_MetadataEntry {
    const message = createBaseComputeEngineTargetDetails_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNetworkInterface(): NetworkInterface {
  return { network: "", subnetwork: "", internalIp: "", externalIp: "" };
}

export const NetworkInterface: MessageFns<NetworkInterface> = {
  encode(message: NetworkInterface, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.subnetwork !== "") {
      writer.uint32(18).string(message.subnetwork);
    }
    if (message.internalIp !== "") {
      writer.uint32(26).string(message.internalIp);
    }
    if (message.externalIp !== "") {
      writer.uint32(34).string(message.externalIp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkInterface {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkInterface();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.internalIp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.externalIp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkInterface {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
      internalIp: isSet(object.internalIp) ? globalThis.String(object.internalIp) : "",
      externalIp: isSet(object.externalIp) ? globalThis.String(object.externalIp) : "",
    };
  },

  toJSON(message: NetworkInterface): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    if (message.internalIp !== "") {
      obj.internalIp = message.internalIp;
    }
    if (message.externalIp !== "") {
      obj.externalIp = message.externalIp;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkInterface>): NetworkInterface {
    return NetworkInterface.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkInterface>): NetworkInterface {
    const message = createBaseNetworkInterface();
    message.network = object.network ?? "";
    message.subnetwork = object.subnetwork ?? "";
    message.internalIp = object.internalIp ?? "";
    message.externalIp = object.externalIp ?? "";
    return message;
  },
};

function createBaseAppliedLicense(): AppliedLicense {
  return { type: 0, osLicense: "" };
}

export const AppliedLicense: MessageFns<AppliedLicense> = {
  encode(message: AppliedLicense, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.osLicense !== "") {
      writer.uint32(18).string(message.osLicense);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppliedLicense {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppliedLicense();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.osLicense = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppliedLicense {
    return {
      type: isSet(object.type) ? appliedLicense_TypeFromJSON(object.type) : 0,
      osLicense: isSet(object.osLicense) ? globalThis.String(object.osLicense) : "",
    };
  },

  toJSON(message: AppliedLicense): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = appliedLicense_TypeToJSON(message.type);
    }
    if (message.osLicense !== "") {
      obj.osLicense = message.osLicense;
    }
    return obj;
  },

  create(base?: DeepPartial<AppliedLicense>): AppliedLicense {
    return AppliedLicense.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppliedLicense>): AppliedLicense {
    const message = createBaseAppliedLicense();
    message.type = object.type ?? 0;
    message.osLicense = object.osLicense ?? "";
    return message;
  },
};

function createBaseSchedulingNodeAffinity(): SchedulingNodeAffinity {
  return { key: "", operator: 0, values: [] };
}

export const SchedulingNodeAffinity: MessageFns<SchedulingNodeAffinity> = {
  encode(message: SchedulingNodeAffinity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.operator !== 0) {
      writer.uint32(16).int32(message.operator);
    }
    for (const v of message.values) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchedulingNodeAffinity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchedulingNodeAffinity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchedulingNodeAffinity {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      operator: isSet(object.operator) ? schedulingNodeAffinity_OperatorFromJSON(object.operator) : 0,
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: SchedulingNodeAffinity): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.operator !== 0) {
      obj.operator = schedulingNodeAffinity_OperatorToJSON(message.operator);
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<SchedulingNodeAffinity>): SchedulingNodeAffinity {
    return SchedulingNodeAffinity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchedulingNodeAffinity>): SchedulingNodeAffinity {
    const message = createBaseSchedulingNodeAffinity();
    message.key = object.key ?? "";
    message.operator = object.operator ?? 0;
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseComputeScheduling(): ComputeScheduling {
  return { onHostMaintenance: 0, restartType: 0, nodeAffinities: [], minNodeCpus: 0 };
}

export const ComputeScheduling: MessageFns<ComputeScheduling> = {
  encode(message: ComputeScheduling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.onHostMaintenance !== 0) {
      writer.uint32(8).int32(message.onHostMaintenance);
    }
    if (message.restartType !== 0) {
      writer.uint32(40).int32(message.restartType);
    }
    for (const v of message.nodeAffinities) {
      SchedulingNodeAffinity.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.minNodeCpus !== 0) {
      writer.uint32(32).int32(message.minNodeCpus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeScheduling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeScheduling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.onHostMaintenance = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.restartType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodeAffinities.push(SchedulingNodeAffinity.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.minNodeCpus = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeScheduling {
    return {
      onHostMaintenance: isSet(object.onHostMaintenance)
        ? computeScheduling_OnHostMaintenanceFromJSON(object.onHostMaintenance)
        : 0,
      restartType: isSet(object.restartType) ? computeScheduling_RestartTypeFromJSON(object.restartType) : 0,
      nodeAffinities: globalThis.Array.isArray(object?.nodeAffinities)
        ? object.nodeAffinities.map((e: any) => SchedulingNodeAffinity.fromJSON(e))
        : [],
      minNodeCpus: isSet(object.minNodeCpus) ? globalThis.Number(object.minNodeCpus) : 0,
    };
  },

  toJSON(message: ComputeScheduling): unknown {
    const obj: any = {};
    if (message.onHostMaintenance !== 0) {
      obj.onHostMaintenance = computeScheduling_OnHostMaintenanceToJSON(message.onHostMaintenance);
    }
    if (message.restartType !== 0) {
      obj.restartType = computeScheduling_RestartTypeToJSON(message.restartType);
    }
    if (message.nodeAffinities?.length) {
      obj.nodeAffinities = message.nodeAffinities.map((e) => SchedulingNodeAffinity.toJSON(e));
    }
    if (message.minNodeCpus !== 0) {
      obj.minNodeCpus = Math.round(message.minNodeCpus);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeScheduling>): ComputeScheduling {
    return ComputeScheduling.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeScheduling>): ComputeScheduling {
    const message = createBaseComputeScheduling();
    message.onHostMaintenance = object.onHostMaintenance ?? 0;
    message.restartType = object.restartType ?? 0;
    message.nodeAffinities = object.nodeAffinities?.map((e) => SchedulingNodeAffinity.fromPartial(e)) || [];
    message.minNodeCpus = object.minNodeCpus ?? 0;
    return message;
  },
};

function createBaseSchedulePolicy(): SchedulePolicy {
  return { idleDuration: undefined, skipOsAdaptation: false };
}

export const SchedulePolicy: MessageFns<SchedulePolicy> = {
  encode(message: SchedulePolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.idleDuration !== undefined) {
      Duration.encode(message.idleDuration, writer.uint32(10).fork()).join();
    }
    if (message.skipOsAdaptation !== false) {
      writer.uint32(16).bool(message.skipOsAdaptation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchedulePolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchedulePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.idleDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.skipOsAdaptation = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchedulePolicy {
    return {
      idleDuration: isSet(object.idleDuration) ? Duration.fromJSON(object.idleDuration) : undefined,
      skipOsAdaptation: isSet(object.skipOsAdaptation) ? globalThis.Boolean(object.skipOsAdaptation) : false,
    };
  },

  toJSON(message: SchedulePolicy): unknown {
    const obj: any = {};
    if (message.idleDuration !== undefined) {
      obj.idleDuration = Duration.toJSON(message.idleDuration);
    }
    if (message.skipOsAdaptation !== false) {
      obj.skipOsAdaptation = message.skipOsAdaptation;
    }
    return obj;
  },

  create(base?: DeepPartial<SchedulePolicy>): SchedulePolicy {
    return SchedulePolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchedulePolicy>): SchedulePolicy {
    const message = createBaseSchedulePolicy();
    message.idleDuration = (object.idleDuration !== undefined && object.idleDuration !== null)
      ? Duration.fromPartial(object.idleDuration)
      : undefined;
    message.skipOsAdaptation = object.skipOsAdaptation ?? false;
    return message;
  },
};

function createBaseCreateMigratingVmRequest(): CreateMigratingVmRequest {
  return { parent: "", migratingVmId: "", migratingVm: undefined, requestId: "" };
}

export const CreateMigratingVmRequest: MessageFns<CreateMigratingVmRequest> = {
  encode(message: CreateMigratingVmRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.migratingVmId !== "") {
      writer.uint32(18).string(message.migratingVmId);
    }
    if (message.migratingVm !== undefined) {
      MigratingVm.encode(message.migratingVm, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMigratingVmRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMigratingVmRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.migratingVmId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.migratingVm = MigratingVm.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateMigratingVmRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      migratingVmId: isSet(object.migratingVmId) ? globalThis.String(object.migratingVmId) : "",
      migratingVm: isSet(object.migratingVm) ? MigratingVm.fromJSON(object.migratingVm) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateMigratingVmRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.migratingVmId !== "") {
      obj.migratingVmId = message.migratingVmId;
    }
    if (message.migratingVm !== undefined) {
      obj.migratingVm = MigratingVm.toJSON(message.migratingVm);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateMigratingVmRequest>): CreateMigratingVmRequest {
    return CreateMigratingVmRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateMigratingVmRequest>): CreateMigratingVmRequest {
    const message = createBaseCreateMigratingVmRequest();
    message.parent = object.parent ?? "";
    message.migratingVmId = object.migratingVmId ?? "";
    message.migratingVm = (object.migratingVm !== undefined && object.migratingVm !== null)
      ? MigratingVm.fromPartial(object.migratingVm)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListMigratingVmsRequest(): ListMigratingVmsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "", view: 0 };
}

export const ListMigratingVmsRequest: MessageFns<ListMigratingVmsRequest> = {
  encode(message: ListMigratingVmsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    if (message.view !== 0) {
      writer.uint32(48).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMigratingVmsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMigratingVmsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMigratingVmsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      view: isSet(object.view) ? migratingVmViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: ListMigratingVmsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.view !== 0) {
      obj.view = migratingVmViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<ListMigratingVmsRequest>): ListMigratingVmsRequest {
    return ListMigratingVmsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMigratingVmsRequest>): ListMigratingVmsRequest {
    const message = createBaseListMigratingVmsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListMigratingVmsResponse(): ListMigratingVmsResponse {
  return { migratingVms: [], nextPageToken: "", unreachable: [] };
}

export const ListMigratingVmsResponse: MessageFns<ListMigratingVmsResponse> = {
  encode(message: ListMigratingVmsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.migratingVms) {
      MigratingVm.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMigratingVmsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMigratingVmsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.migratingVms.push(MigratingVm.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMigratingVmsResponse {
    return {
      migratingVms: globalThis.Array.isArray(object?.migratingVms)
        ? object.migratingVms.map((e: any) => MigratingVm.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListMigratingVmsResponse): unknown {
    const obj: any = {};
    if (message.migratingVms?.length) {
      obj.migratingVms = message.migratingVms.map((e) => MigratingVm.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMigratingVmsResponse>): ListMigratingVmsResponse {
    return ListMigratingVmsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMigratingVmsResponse>): ListMigratingVmsResponse {
    const message = createBaseListMigratingVmsResponse();
    message.migratingVms = object.migratingVms?.map((e) => MigratingVm.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetMigratingVmRequest(): GetMigratingVmRequest {
  return { name: "", view: 0 };
}

export const GetMigratingVmRequest: MessageFns<GetMigratingVmRequest> = {
  encode(message: GetMigratingVmRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMigratingVmRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMigratingVmRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMigratingVmRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? migratingVmViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetMigratingVmRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = migratingVmViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetMigratingVmRequest>): GetMigratingVmRequest {
    return GetMigratingVmRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMigratingVmRequest>): GetMigratingVmRequest {
    const message = createBaseGetMigratingVmRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseUpdateMigratingVmRequest(): UpdateMigratingVmRequest {
  return { updateMask: undefined, migratingVm: undefined, requestId: "" };
}

export const UpdateMigratingVmRequest: MessageFns<UpdateMigratingVmRequest> = {
  encode(message: UpdateMigratingVmRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.migratingVm !== undefined) {
      MigratingVm.encode(message.migratingVm, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateMigratingVmRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMigratingVmRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.migratingVm = MigratingVm.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateMigratingVmRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      migratingVm: isSet(object.migratingVm) ? MigratingVm.fromJSON(object.migratingVm) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateMigratingVmRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.migratingVm !== undefined) {
      obj.migratingVm = MigratingVm.toJSON(message.migratingVm);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateMigratingVmRequest>): UpdateMigratingVmRequest {
    return UpdateMigratingVmRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateMigratingVmRequest>): UpdateMigratingVmRequest {
    const message = createBaseUpdateMigratingVmRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.migratingVm = (object.migratingVm !== undefined && object.migratingVm !== null)
      ? MigratingVm.fromPartial(object.migratingVm)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteMigratingVmRequest(): DeleteMigratingVmRequest {
  return { name: "" };
}

export const DeleteMigratingVmRequest: MessageFns<DeleteMigratingVmRequest> = {
  encode(message: DeleteMigratingVmRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMigratingVmRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMigratingVmRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMigratingVmRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteMigratingVmRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteMigratingVmRequest>): DeleteMigratingVmRequest {
    return DeleteMigratingVmRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteMigratingVmRequest>): DeleteMigratingVmRequest {
    const message = createBaseDeleteMigratingVmRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStartMigrationRequest(): StartMigrationRequest {
  return { migratingVm: "" };
}

export const StartMigrationRequest: MessageFns<StartMigrationRequest> = {
  encode(message: StartMigrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.migratingVm !== "") {
      writer.uint32(10).string(message.migratingVm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartMigrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartMigrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.migratingVm = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartMigrationRequest {
    return { migratingVm: isSet(object.migratingVm) ? globalThis.String(object.migratingVm) : "" };
  },

  toJSON(message: StartMigrationRequest): unknown {
    const obj: any = {};
    if (message.migratingVm !== "") {
      obj.migratingVm = message.migratingVm;
    }
    return obj;
  },

  create(base?: DeepPartial<StartMigrationRequest>): StartMigrationRequest {
    return StartMigrationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartMigrationRequest>): StartMigrationRequest {
    const message = createBaseStartMigrationRequest();
    message.migratingVm = object.migratingVm ?? "";
    return message;
  },
};

function createBaseStartMigrationResponse(): StartMigrationResponse {
  return {};
}

export const StartMigrationResponse: MessageFns<StartMigrationResponse> = {
  encode(_: StartMigrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartMigrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartMigrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StartMigrationResponse {
    return {};
  },

  toJSON(_: StartMigrationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<StartMigrationResponse>): StartMigrationResponse {
    return StartMigrationResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<StartMigrationResponse>): StartMigrationResponse {
    const message = createBaseStartMigrationResponse();
    return message;
  },
};

function createBasePauseMigrationRequest(): PauseMigrationRequest {
  return { migratingVm: "" };
}

export const PauseMigrationRequest: MessageFns<PauseMigrationRequest> = {
  encode(message: PauseMigrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.migratingVm !== "") {
      writer.uint32(10).string(message.migratingVm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PauseMigrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePauseMigrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.migratingVm = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PauseMigrationRequest {
    return { migratingVm: isSet(object.migratingVm) ? globalThis.String(object.migratingVm) : "" };
  },

  toJSON(message: PauseMigrationRequest): unknown {
    const obj: any = {};
    if (message.migratingVm !== "") {
      obj.migratingVm = message.migratingVm;
    }
    return obj;
  },

  create(base?: DeepPartial<PauseMigrationRequest>): PauseMigrationRequest {
    return PauseMigrationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PauseMigrationRequest>): PauseMigrationRequest {
    const message = createBasePauseMigrationRequest();
    message.migratingVm = object.migratingVm ?? "";
    return message;
  },
};

function createBasePauseMigrationResponse(): PauseMigrationResponse {
  return {};
}

export const PauseMigrationResponse: MessageFns<PauseMigrationResponse> = {
  encode(_: PauseMigrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PauseMigrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePauseMigrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PauseMigrationResponse {
    return {};
  },

  toJSON(_: PauseMigrationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PauseMigrationResponse>): PauseMigrationResponse {
    return PauseMigrationResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PauseMigrationResponse>): PauseMigrationResponse {
    const message = createBasePauseMigrationResponse();
    return message;
  },
};

function createBaseResumeMigrationRequest(): ResumeMigrationRequest {
  return { migratingVm: "" };
}

export const ResumeMigrationRequest: MessageFns<ResumeMigrationRequest> = {
  encode(message: ResumeMigrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.migratingVm !== "") {
      writer.uint32(10).string(message.migratingVm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResumeMigrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResumeMigrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.migratingVm = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResumeMigrationRequest {
    return { migratingVm: isSet(object.migratingVm) ? globalThis.String(object.migratingVm) : "" };
  },

  toJSON(message: ResumeMigrationRequest): unknown {
    const obj: any = {};
    if (message.migratingVm !== "") {
      obj.migratingVm = message.migratingVm;
    }
    return obj;
  },

  create(base?: DeepPartial<ResumeMigrationRequest>): ResumeMigrationRequest {
    return ResumeMigrationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResumeMigrationRequest>): ResumeMigrationRequest {
    const message = createBaseResumeMigrationRequest();
    message.migratingVm = object.migratingVm ?? "";
    return message;
  },
};

function createBaseResumeMigrationResponse(): ResumeMigrationResponse {
  return {};
}

export const ResumeMigrationResponse: MessageFns<ResumeMigrationResponse> = {
  encode(_: ResumeMigrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResumeMigrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResumeMigrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResumeMigrationResponse {
    return {};
  },

  toJSON(_: ResumeMigrationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ResumeMigrationResponse>): ResumeMigrationResponse {
    return ResumeMigrationResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ResumeMigrationResponse>): ResumeMigrationResponse {
    const message = createBaseResumeMigrationResponse();
    return message;
  },
};

function createBaseFinalizeMigrationRequest(): FinalizeMigrationRequest {
  return { migratingVm: "" };
}

export const FinalizeMigrationRequest: MessageFns<FinalizeMigrationRequest> = {
  encode(message: FinalizeMigrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.migratingVm !== "") {
      writer.uint32(10).string(message.migratingVm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeMigrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeMigrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.migratingVm = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeMigrationRequest {
    return { migratingVm: isSet(object.migratingVm) ? globalThis.String(object.migratingVm) : "" };
  },

  toJSON(message: FinalizeMigrationRequest): unknown {
    const obj: any = {};
    if (message.migratingVm !== "") {
      obj.migratingVm = message.migratingVm;
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeMigrationRequest>): FinalizeMigrationRequest {
    return FinalizeMigrationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeMigrationRequest>): FinalizeMigrationRequest {
    const message = createBaseFinalizeMigrationRequest();
    message.migratingVm = object.migratingVm ?? "";
    return message;
  },
};

function createBaseFinalizeMigrationResponse(): FinalizeMigrationResponse {
  return {};
}

export const FinalizeMigrationResponse: MessageFns<FinalizeMigrationResponse> = {
  encode(_: FinalizeMigrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeMigrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeMigrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FinalizeMigrationResponse {
    return {};
  },

  toJSON(_: FinalizeMigrationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<FinalizeMigrationResponse>): FinalizeMigrationResponse {
    return FinalizeMigrationResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<FinalizeMigrationResponse>): FinalizeMigrationResponse {
    const message = createBaseFinalizeMigrationResponse();
    return message;
  },
};

function createBaseTargetProject(): TargetProject {
  return { name: "", project: "", description: "", createTime: undefined, updateTime: undefined };
}

export const TargetProject: MessageFns<TargetProject> = {
  encode(message: TargetProject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetProject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetProject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetProject {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: TargetProject): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TargetProject>): TargetProject {
    return TargetProject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetProject>): TargetProject {
    const message = createBaseTargetProject();
    message.name = object.name ?? "";
    message.project = object.project ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseGetTargetProjectRequest(): GetTargetProjectRequest {
  return { name: "" };
}

export const GetTargetProjectRequest: MessageFns<GetTargetProjectRequest> = {
  encode(message: GetTargetProjectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTargetProjectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTargetProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTargetProjectRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTargetProjectRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTargetProjectRequest>): GetTargetProjectRequest {
    return GetTargetProjectRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTargetProjectRequest>): GetTargetProjectRequest {
    const message = createBaseGetTargetProjectRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTargetProjectsRequest(): ListTargetProjectsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListTargetProjectsRequest: MessageFns<ListTargetProjectsRequest> = {
  encode(message: ListTargetProjectsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTargetProjectsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTargetProjectsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTargetProjectsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListTargetProjectsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTargetProjectsRequest>): ListTargetProjectsRequest {
    return ListTargetProjectsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTargetProjectsRequest>): ListTargetProjectsRequest {
    const message = createBaseListTargetProjectsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListTargetProjectsResponse(): ListTargetProjectsResponse {
  return { targetProjects: [], nextPageToken: "", unreachable: [] };
}

export const ListTargetProjectsResponse: MessageFns<ListTargetProjectsResponse> = {
  encode(message: ListTargetProjectsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.targetProjects) {
      TargetProject.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTargetProjectsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTargetProjectsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetProjects.push(TargetProject.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTargetProjectsResponse {
    return {
      targetProjects: globalThis.Array.isArray(object?.targetProjects)
        ? object.targetProjects.map((e: any) => TargetProject.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListTargetProjectsResponse): unknown {
    const obj: any = {};
    if (message.targetProjects?.length) {
      obj.targetProjects = message.targetProjects.map((e) => TargetProject.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTargetProjectsResponse>): ListTargetProjectsResponse {
    return ListTargetProjectsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTargetProjectsResponse>): ListTargetProjectsResponse {
    const message = createBaseListTargetProjectsResponse();
    message.targetProjects = object.targetProjects?.map((e) => TargetProject.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateTargetProjectRequest(): CreateTargetProjectRequest {
  return { parent: "", targetProjectId: "", targetProject: undefined, requestId: "" };
}

export const CreateTargetProjectRequest: MessageFns<CreateTargetProjectRequest> = {
  encode(message: CreateTargetProjectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.targetProjectId !== "") {
      writer.uint32(18).string(message.targetProjectId);
    }
    if (message.targetProject !== undefined) {
      TargetProject.encode(message.targetProject, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTargetProjectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTargetProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetProjectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetProject = TargetProject.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTargetProjectRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      targetProjectId: isSet(object.targetProjectId) ? globalThis.String(object.targetProjectId) : "",
      targetProject: isSet(object.targetProject) ? TargetProject.fromJSON(object.targetProject) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateTargetProjectRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.targetProjectId !== "") {
      obj.targetProjectId = message.targetProjectId;
    }
    if (message.targetProject !== undefined) {
      obj.targetProject = TargetProject.toJSON(message.targetProject);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTargetProjectRequest>): CreateTargetProjectRequest {
    return CreateTargetProjectRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTargetProjectRequest>): CreateTargetProjectRequest {
    const message = createBaseCreateTargetProjectRequest();
    message.parent = object.parent ?? "";
    message.targetProjectId = object.targetProjectId ?? "";
    message.targetProject = (object.targetProject !== undefined && object.targetProject !== null)
      ? TargetProject.fromPartial(object.targetProject)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateTargetProjectRequest(): UpdateTargetProjectRequest {
  return { updateMask: undefined, targetProject: undefined, requestId: "" };
}

export const UpdateTargetProjectRequest: MessageFns<UpdateTargetProjectRequest> = {
  encode(message: UpdateTargetProjectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.targetProject !== undefined) {
      TargetProject.encode(message.targetProject, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTargetProjectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTargetProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetProject = TargetProject.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTargetProjectRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      targetProject: isSet(object.targetProject) ? TargetProject.fromJSON(object.targetProject) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateTargetProjectRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.targetProject !== undefined) {
      obj.targetProject = TargetProject.toJSON(message.targetProject);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTargetProjectRequest>): UpdateTargetProjectRequest {
    return UpdateTargetProjectRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTargetProjectRequest>): UpdateTargetProjectRequest {
    const message = createBaseUpdateTargetProjectRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.targetProject = (object.targetProject !== undefined && object.targetProject !== null)
      ? TargetProject.fromPartial(object.targetProject)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteTargetProjectRequest(): DeleteTargetProjectRequest {
  return { name: "", requestId: "" };
}

export const DeleteTargetProjectRequest: MessageFns<DeleteTargetProjectRequest> = {
  encode(message: DeleteTargetProjectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTargetProjectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTargetProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTargetProjectRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteTargetProjectRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTargetProjectRequest>): DeleteTargetProjectRequest {
    return DeleteTargetProjectRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTargetProjectRequest>): DeleteTargetProjectRequest {
    const message = createBaseDeleteTargetProjectRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseGroup(): Group {
  return { name: "", createTime: undefined, updateTime: undefined, description: "", displayName: "" };
}

export const Group: MessageFns<Group> = {
  encode(message: Group, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Group {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Group {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: Group): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<Group>): Group {
    return Group.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Group>): Group {
    const message = createBaseGroup();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.description = object.description ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseListGroupsRequest(): ListGroupsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListGroupsRequest: MessageFns<ListGroupsRequest> = {
  encode(message: ListGroupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGroupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGroupsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListGroupsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListGroupsRequest>): ListGroupsRequest {
    return ListGroupsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGroupsRequest>): ListGroupsRequest {
    const message = createBaseListGroupsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListGroupsResponse(): ListGroupsResponse {
  return { groups: [], nextPageToken: "", unreachable: [] };
}

export const ListGroupsResponse: MessageFns<ListGroupsResponse> = {
  encode(message: ListGroupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groups) {
      Group.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGroupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGroupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.groups.push(Group.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGroupsResponse {
    return {
      groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => Group.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListGroupsResponse): unknown {
    const obj: any = {};
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => Group.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListGroupsResponse>): ListGroupsResponse {
    return ListGroupsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGroupsResponse>): ListGroupsResponse {
    const message = createBaseListGroupsResponse();
    message.groups = object.groups?.map((e) => Group.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetGroupRequest(): GetGroupRequest {
  return { name: "" };
}

export const GetGroupRequest: MessageFns<GetGroupRequest> = {
  encode(message: GetGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetGroupRequest>): GetGroupRequest {
    return GetGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetGroupRequest>): GetGroupRequest {
    const message = createBaseGetGroupRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateGroupRequest(): CreateGroupRequest {
  return { parent: "", groupId: "", group: undefined, requestId: "" };
}

export const CreateGroupRequest: MessageFns<CreateGroupRequest> = {
  encode(message: CreateGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    if (message.group !== undefined) {
      Group.encode(message.group, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.group = Group.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGroupRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      group: isSet(object.group) ? Group.fromJSON(object.group) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateGroupRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.group !== undefined) {
      obj.group = Group.toJSON(message.group);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateGroupRequest>): CreateGroupRequest {
    return CreateGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateGroupRequest>): CreateGroupRequest {
    const message = createBaseCreateGroupRequest();
    message.parent = object.parent ?? "";
    message.groupId = object.groupId ?? "";
    message.group = (object.group !== undefined && object.group !== null) ? Group.fromPartial(object.group) : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateGroupRequest(): UpdateGroupRequest {
  return { updateMask: undefined, group: undefined, requestId: "" };
}

export const UpdateGroupRequest: MessageFns<UpdateGroupRequest> = {
  encode(message: UpdateGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.group !== undefined) {
      Group.encode(message.group, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.group = Group.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateGroupRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      group: isSet(object.group) ? Group.fromJSON(object.group) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateGroupRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.group !== undefined) {
      obj.group = Group.toJSON(message.group);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateGroupRequest>): UpdateGroupRequest {
    return UpdateGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateGroupRequest>): UpdateGroupRequest {
    const message = createBaseUpdateGroupRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.group = (object.group !== undefined && object.group !== null) ? Group.fromPartial(object.group) : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteGroupRequest(): DeleteGroupRequest {
  return { name: "", requestId: "" };
}

export const DeleteGroupRequest: MessageFns<DeleteGroupRequest> = {
  encode(message: DeleteGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteGroupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteGroupRequest>): DeleteGroupRequest {
    return DeleteGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteGroupRequest>): DeleteGroupRequest {
    const message = createBaseDeleteGroupRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseAddGroupMigrationRequest(): AddGroupMigrationRequest {
  return { group: "", migratingVm: "" };
}

export const AddGroupMigrationRequest: MessageFns<AddGroupMigrationRequest> = {
  encode(message: AddGroupMigrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== "") {
      writer.uint32(10).string(message.group);
    }
    if (message.migratingVm !== "") {
      writer.uint32(18).string(message.migratingVm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddGroupMigrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddGroupMigrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.migratingVm = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddGroupMigrationRequest {
    return {
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      migratingVm: isSet(object.migratingVm) ? globalThis.String(object.migratingVm) : "",
    };
  },

  toJSON(message: AddGroupMigrationRequest): unknown {
    const obj: any = {};
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.migratingVm !== "") {
      obj.migratingVm = message.migratingVm;
    }
    return obj;
  },

  create(base?: DeepPartial<AddGroupMigrationRequest>): AddGroupMigrationRequest {
    return AddGroupMigrationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddGroupMigrationRequest>): AddGroupMigrationRequest {
    const message = createBaseAddGroupMigrationRequest();
    message.group = object.group ?? "";
    message.migratingVm = object.migratingVm ?? "";
    return message;
  },
};

function createBaseAddGroupMigrationResponse(): AddGroupMigrationResponse {
  return {};
}

export const AddGroupMigrationResponse: MessageFns<AddGroupMigrationResponse> = {
  encode(_: AddGroupMigrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddGroupMigrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddGroupMigrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AddGroupMigrationResponse {
    return {};
  },

  toJSON(_: AddGroupMigrationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AddGroupMigrationResponse>): AddGroupMigrationResponse {
    return AddGroupMigrationResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AddGroupMigrationResponse>): AddGroupMigrationResponse {
    const message = createBaseAddGroupMigrationResponse();
    return message;
  },
};

function createBaseRemoveGroupMigrationRequest(): RemoveGroupMigrationRequest {
  return { group: "", migratingVm: "" };
}

export const RemoveGroupMigrationRequest: MessageFns<RemoveGroupMigrationRequest> = {
  encode(message: RemoveGroupMigrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== "") {
      writer.uint32(10).string(message.group);
    }
    if (message.migratingVm !== "") {
      writer.uint32(18).string(message.migratingVm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveGroupMigrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveGroupMigrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.migratingVm = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveGroupMigrationRequest {
    return {
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      migratingVm: isSet(object.migratingVm) ? globalThis.String(object.migratingVm) : "",
    };
  },

  toJSON(message: RemoveGroupMigrationRequest): unknown {
    const obj: any = {};
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.migratingVm !== "") {
      obj.migratingVm = message.migratingVm;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveGroupMigrationRequest>): RemoveGroupMigrationRequest {
    return RemoveGroupMigrationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveGroupMigrationRequest>): RemoveGroupMigrationRequest {
    const message = createBaseRemoveGroupMigrationRequest();
    message.group = object.group ?? "";
    message.migratingVm = object.migratingVm ?? "";
    return message;
  },
};

function createBaseRemoveGroupMigrationResponse(): RemoveGroupMigrationResponse {
  return {};
}

export const RemoveGroupMigrationResponse: MessageFns<RemoveGroupMigrationResponse> = {
  encode(_: RemoveGroupMigrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveGroupMigrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveGroupMigrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveGroupMigrationResponse {
    return {};
  },

  toJSON(_: RemoveGroupMigrationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RemoveGroupMigrationResponse>): RemoveGroupMigrationResponse {
    return RemoveGroupMigrationResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RemoveGroupMigrationResponse>): RemoveGroupMigrationResponse {
    const message = createBaseRemoveGroupMigrationResponse();
    return message;
  },
};

function createBaseCreateCutoverJobRequest(): CreateCutoverJobRequest {
  return { parent: "", cutoverJobId: "", cutoverJob: undefined, requestId: "" };
}

export const CreateCutoverJobRequest: MessageFns<CreateCutoverJobRequest> = {
  encode(message: CreateCutoverJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.cutoverJobId !== "") {
      writer.uint32(18).string(message.cutoverJobId);
    }
    if (message.cutoverJob !== undefined) {
      CutoverJob.encode(message.cutoverJob, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCutoverJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCutoverJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cutoverJobId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cutoverJob = CutoverJob.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCutoverJobRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      cutoverJobId: isSet(object.cutoverJobId) ? globalThis.String(object.cutoverJobId) : "",
      cutoverJob: isSet(object.cutoverJob) ? CutoverJob.fromJSON(object.cutoverJob) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateCutoverJobRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.cutoverJobId !== "") {
      obj.cutoverJobId = message.cutoverJobId;
    }
    if (message.cutoverJob !== undefined) {
      obj.cutoverJob = CutoverJob.toJSON(message.cutoverJob);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCutoverJobRequest>): CreateCutoverJobRequest {
    return CreateCutoverJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCutoverJobRequest>): CreateCutoverJobRequest {
    const message = createBaseCreateCutoverJobRequest();
    message.parent = object.parent ?? "";
    message.cutoverJobId = object.cutoverJobId ?? "";
    message.cutoverJob = (object.cutoverJob !== undefined && object.cutoverJob !== null)
      ? CutoverJob.fromPartial(object.cutoverJob)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseCancelCutoverJobRequest(): CancelCutoverJobRequest {
  return { name: "" };
}

export const CancelCutoverJobRequest: MessageFns<CancelCutoverJobRequest> = {
  encode(message: CancelCutoverJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelCutoverJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelCutoverJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelCutoverJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CancelCutoverJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelCutoverJobRequest>): CancelCutoverJobRequest {
    return CancelCutoverJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelCutoverJobRequest>): CancelCutoverJobRequest {
    const message = createBaseCancelCutoverJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCancelCutoverJobResponse(): CancelCutoverJobResponse {
  return {};
}

export const CancelCutoverJobResponse: MessageFns<CancelCutoverJobResponse> = {
  encode(_: CancelCutoverJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelCutoverJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelCutoverJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CancelCutoverJobResponse {
    return {};
  },

  toJSON(_: CancelCutoverJobResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CancelCutoverJobResponse>): CancelCutoverJobResponse {
    return CancelCutoverJobResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CancelCutoverJobResponse>): CancelCutoverJobResponse {
    const message = createBaseCancelCutoverJobResponse();
    return message;
  },
};

function createBaseListCutoverJobsRequest(): ListCutoverJobsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListCutoverJobsRequest: MessageFns<ListCutoverJobsRequest> = {
  encode(message: ListCutoverJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCutoverJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCutoverJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCutoverJobsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListCutoverJobsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCutoverJobsRequest>): ListCutoverJobsRequest {
    return ListCutoverJobsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCutoverJobsRequest>): ListCutoverJobsRequest {
    const message = createBaseListCutoverJobsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListCutoverJobsResponse(): ListCutoverJobsResponse {
  return { cutoverJobs: [], nextPageToken: "", unreachable: [] };
}

export const ListCutoverJobsResponse: MessageFns<ListCutoverJobsResponse> = {
  encode(message: ListCutoverJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cutoverJobs) {
      CutoverJob.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCutoverJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCutoverJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cutoverJobs.push(CutoverJob.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCutoverJobsResponse {
    return {
      cutoverJobs: globalThis.Array.isArray(object?.cutoverJobs)
        ? object.cutoverJobs.map((e: any) => CutoverJob.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListCutoverJobsResponse): unknown {
    const obj: any = {};
    if (message.cutoverJobs?.length) {
      obj.cutoverJobs = message.cutoverJobs.map((e) => CutoverJob.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCutoverJobsResponse>): ListCutoverJobsResponse {
    return ListCutoverJobsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCutoverJobsResponse>): ListCutoverJobsResponse {
    const message = createBaseListCutoverJobsResponse();
    message.cutoverJobs = object.cutoverJobs?.map((e) => CutoverJob.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetCutoverJobRequest(): GetCutoverJobRequest {
  return { name: "" };
}

export const GetCutoverJobRequest: MessageFns<GetCutoverJobRequest> = {
  encode(message: GetCutoverJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCutoverJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCutoverJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCutoverJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCutoverJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCutoverJobRequest>): GetCutoverJobRequest {
    return GetCutoverJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCutoverJobRequest>): GetCutoverJobRequest {
    const message = createBaseGetCutoverJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusMessage: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(48).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseMigrationError(): MigrationError {
  return { code: 0, errorMessage: undefined, actionItem: undefined, helpLinks: [], errorTime: undefined };
}

export const MigrationError: MessageFns<MigrationError> = {
  encode(message: MigrationError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.errorMessage !== undefined) {
      LocalizedMessage.encode(message.errorMessage, writer.uint32(18).fork()).join();
    }
    if (message.actionItem !== undefined) {
      LocalizedMessage.encode(message.actionItem, writer.uint32(26).fork()).join();
    }
    for (const v of message.helpLinks) {
      Help_Link.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.errorTime !== undefined) {
      Timestamp.encode(toTimestamp(message.errorTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = LocalizedMessage.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.actionItem = LocalizedMessage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.helpLinks.push(Help_Link.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.errorTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationError {
    return {
      code: isSet(object.code) ? migrationError_ErrorCodeFromJSON(object.code) : 0,
      errorMessage: isSet(object.errorMessage) ? LocalizedMessage.fromJSON(object.errorMessage) : undefined,
      actionItem: isSet(object.actionItem) ? LocalizedMessage.fromJSON(object.actionItem) : undefined,
      helpLinks: globalThis.Array.isArray(object?.helpLinks)
        ? object.helpLinks.map((e: any) => Help_Link.fromJSON(e))
        : [],
      errorTime: isSet(object.errorTime) ? fromJsonTimestamp(object.errorTime) : undefined,
    };
  },

  toJSON(message: MigrationError): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = migrationError_ErrorCodeToJSON(message.code);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = LocalizedMessage.toJSON(message.errorMessage);
    }
    if (message.actionItem !== undefined) {
      obj.actionItem = LocalizedMessage.toJSON(message.actionItem);
    }
    if (message.helpLinks?.length) {
      obj.helpLinks = message.helpLinks.map((e) => Help_Link.toJSON(e));
    }
    if (message.errorTime !== undefined) {
      obj.errorTime = message.errorTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<MigrationError>): MigrationError {
    return MigrationError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigrationError>): MigrationError {
    const message = createBaseMigrationError();
    message.code = object.code ?? 0;
    message.errorMessage = (object.errorMessage !== undefined && object.errorMessage !== null)
      ? LocalizedMessage.fromPartial(object.errorMessage)
      : undefined;
    message.actionItem = (object.actionItem !== undefined && object.actionItem !== null)
      ? LocalizedMessage.fromPartial(object.actionItem)
      : undefined;
    message.helpLinks = object.helpLinks?.map((e) => Help_Link.fromPartial(e)) || [];
    message.errorTime = object.errorTime ?? undefined;
    return message;
  },
};

function createBaseAwsSourceVmDetails(): AwsSourceVmDetails {
  return { firmware: 0, committedStorageBytes: Long.ZERO };
}

export const AwsSourceVmDetails: MessageFns<AwsSourceVmDetails> = {
  encode(message: AwsSourceVmDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firmware !== 0) {
      writer.uint32(8).int32(message.firmware);
    }
    if (!message.committedStorageBytes.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.committedStorageBytes.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsSourceVmDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsSourceVmDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.firmware = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.committedStorageBytes = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsSourceVmDetails {
    return {
      firmware: isSet(object.firmware) ? awsSourceVmDetails_FirmwareFromJSON(object.firmware) : 0,
      committedStorageBytes: isSet(object.committedStorageBytes)
        ? Long.fromValue(object.committedStorageBytes)
        : Long.ZERO,
    };
  },

  toJSON(message: AwsSourceVmDetails): unknown {
    const obj: any = {};
    if (message.firmware !== 0) {
      obj.firmware = awsSourceVmDetails_FirmwareToJSON(message.firmware);
    }
    if (!message.committedStorageBytes.equals(Long.ZERO)) {
      obj.committedStorageBytes = (message.committedStorageBytes || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<AwsSourceVmDetails>): AwsSourceVmDetails {
    return AwsSourceVmDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AwsSourceVmDetails>): AwsSourceVmDetails {
    const message = createBaseAwsSourceVmDetails();
    message.firmware = object.firmware ?? 0;
    message.committedStorageBytes =
      (object.committedStorageBytes !== undefined && object.committedStorageBytes !== null)
        ? Long.fromValue(object.committedStorageBytes)
        : Long.ZERO;
    return message;
  },
};

function createBaseListReplicationCyclesRequest(): ListReplicationCyclesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListReplicationCyclesRequest: MessageFns<ListReplicationCyclesRequest> = {
  encode(message: ListReplicationCyclesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReplicationCyclesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReplicationCyclesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReplicationCyclesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListReplicationCyclesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReplicationCyclesRequest>): ListReplicationCyclesRequest {
    return ListReplicationCyclesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReplicationCyclesRequest>): ListReplicationCyclesRequest {
    const message = createBaseListReplicationCyclesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListReplicationCyclesResponse(): ListReplicationCyclesResponse {
  return { replicationCycles: [], nextPageToken: "", unreachable: [] };
}

export const ListReplicationCyclesResponse: MessageFns<ListReplicationCyclesResponse> = {
  encode(message: ListReplicationCyclesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.replicationCycles) {
      ReplicationCycle.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReplicationCyclesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReplicationCyclesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.replicationCycles.push(ReplicationCycle.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReplicationCyclesResponse {
    return {
      replicationCycles: globalThis.Array.isArray(object?.replicationCycles)
        ? object.replicationCycles.map((e: any) => ReplicationCycle.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListReplicationCyclesResponse): unknown {
    const obj: any = {};
    if (message.replicationCycles?.length) {
      obj.replicationCycles = message.replicationCycles.map((e) => ReplicationCycle.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReplicationCyclesResponse>): ListReplicationCyclesResponse {
    return ListReplicationCyclesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReplicationCyclesResponse>): ListReplicationCyclesResponse {
    const message = createBaseListReplicationCyclesResponse();
    message.replicationCycles = object.replicationCycles?.map((e) => ReplicationCycle.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetReplicationCycleRequest(): GetReplicationCycleRequest {
  return { name: "" };
}

export const GetReplicationCycleRequest: MessageFns<GetReplicationCycleRequest> = {
  encode(message: GetReplicationCycleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReplicationCycleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReplicationCycleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReplicationCycleRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetReplicationCycleRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReplicationCycleRequest>): GetReplicationCycleRequest {
    return GetReplicationCycleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReplicationCycleRequest>): GetReplicationCycleRequest {
    const message = createBaseGetReplicationCycleRequest();
    message.name = object.name ?? "";
    return message;
  },
};

/** VM Migration Service */
export type VmMigrationDefinition = typeof VmMigrationDefinition;
export const VmMigrationDefinition = {
  name: "VmMigration",
  fullName: "google.cloud.vmmigration.v1.VmMigration",
  methods: {
    /** Lists Sources in a given project and location. */
    listSources: {
      name: "ListSources",
      requestType: ListSourcesRequest,
      requestStream: false,
      responseType: ListSourcesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Source. */
    getSource: {
      name: "GetSource",
      requestType: GetSourceRequest,
      requestStream: false,
      responseType: Source,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new Source in a given project and location. */
    createSource: {
      name: "CreateSource",
      requestType: CreateSourceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              27,
              10,
              6,
              83,
              111,
              117,
              114,
              99,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              115,
              111,
              117,
              114,
              99,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              53,
              58,
              6,
              115,
              111,
              117,
              114,
              99,
              101,
              34,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a single Source. */
    updateSource: {
      name: "UpdateSource",
      requestType: UpdateSourceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              27,
              10,
              6,
              83,
              111,
              117,
              114,
              99,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([18, 115, 111, 117, 114, 99, 101, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              60,
              58,
              6,
              115,
              111,
              117,
              114,
              99,
              101,
              50,
              50,
              47,
              118,
              49,
              47,
              123,
              115,
              111,
              117,
              114,
              99,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single Source. */
    deleteSource: {
      name: "DeleteSource",
      requestType: DeleteSourceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              42,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * List remote source's inventory of VMs.
     * The remote source is the onprem vCenter (remote in the sense it's not in
     * Compute Engine). The inventory describes the list of existing VMs in that
     * source. Note that this operation lists the VMs on the remote source, as
     * opposed to listing the MigratingVms resources in the vmmigration service.
     */
    fetchInventory: {
      name: "FetchInventory",
      requestType: FetchInventoryRequest,
      requestStream: false,
      responseType: FetchInventoryResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              62,
              18,
              60,
              47,
              118,
              49,
              47,
              123,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              102,
              101,
              116,
              99,
              104,
              73,
              110,
              118,
              101,
              110,
              116,
              111,
              114,
              121,
            ]),
          ],
        },
      },
    },
    /** Lists Utilization Reports of the given Source. */
    listUtilizationReports: {
      name: "ListUtilizationReports",
      requestType: ListUtilizationReportsRequest,
      requestStream: false,
      responseType: ListUtilizationReportsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              66,
              18,
              64,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              117,
              116,
              105,
              108,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              112,
              111,
              114,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a single Utilization Report. */
    getUtilizationReport: {
      name: "GetUtilizationReport",
      requestType: GetUtilizationReportRequest,
      requestStream: false,
      responseType: UtilizationReport,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              66,
              18,
              64,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              117,
              116,
              105,
              108,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              112,
              111,
              114,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new UtilizationReport. */
    createUtilizationReport: {
      name: "CreateUtilizationReport",
      requestType: CreateUtilizationReportRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              17,
              85,
              116,
              105,
              108,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              112,
              111,
              114,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              47,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              117,
              116,
              105,
              108,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              114,
              101,
              112,
              111,
              114,
              116,
              44,
              117,
              116,
              105,
              108,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              114,
              101,
              112,
              111,
              114,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              86,
              58,
              18,
              117,
              116,
              105,
              108,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              114,
              101,
              112,
              111,
              114,
              116,
              34,
              64,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              117,
              116,
              105,
              108,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              112,
              111,
              114,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a single Utilization Report. */
    deleteUtilizationReport: {
      name: "DeleteUtilizationReport",
      requestType: DeleteUtilizationReportRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              66,
              42,
              64,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              117,
              116,
              105,
              108,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              112,
              111,
              114,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists DatacenterConnectors in a given Source. */
    listDatacenterConnectors: {
      name: "ListDatacenterConnectors",
      requestType: ListDatacenterConnectorsRequest,
      requestStream: false,
      responseType: ListDatacenterConnectorsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              68,
              18,
              66,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              99,
              101,
              110,
              116,
              101,
              114,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              111,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single DatacenterConnector. */
    getDatacenterConnector: {
      name: "GetDatacenterConnector",
      requestType: GetDatacenterConnectorRequest,
      requestStream: false,
      responseType: DatacenterConnector,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              68,
              18,
              66,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              99,
              101,
              110,
              116,
              101,
              114,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              111,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new DatacenterConnector in a given Source. */
    createDatacenterConnector: {
      name: "CreateDatacenterConnector",
      requestType: CreateDatacenterConnectorRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              40,
              10,
              19,
              68,
              97,
              116,
              97,
              99,
              101,
              110,
              116,
              101,
              114,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              111,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              51,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              100,
              97,
              116,
              97,
              99,
              101,
              110,
              116,
              101,
              114,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              111,
              114,
              44,
              100,
              97,
              116,
              97,
              99,
              101,
              110,
              116,
              101,
              114,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              111,
              114,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              90,
              58,
              20,
              100,
              97,
              116,
              97,
              99,
              101,
              110,
              116,
              101,
              114,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              111,
              114,
              34,
              66,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              99,
              101,
              110,
              116,
              101,
              114,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              111,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a single DatacenterConnector. */
    deleteDatacenterConnector: {
      name: "DeleteDatacenterConnector",
      requestType: DeleteDatacenterConnectorRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              68,
              42,
              66,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              99,
              101,
              110,
              116,
              101,
              114,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              111,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Upgrades the appliance relate to this DatacenterConnector to the in-place
     * updateable version.
     */
    upgradeAppliance: {
      name: "UpgradeAppliance",
      requestType: UpgradeApplianceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              45,
              10,
              24,
              85,
              112,
              103,
              114,
              97,
              100,
              101,
              65,
              112,
              112,
              108,
              105,
              97,
              110,
              99,
              101,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              104,
              58,
              1,
              42,
              34,
              99,
              47,
              118,
              49,
              47,
              123,
              100,
              97,
              116,
              97,
              99,
              101,
              110,
              116,
              101,
              114,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              111,
              114,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              99,
              101,
              110,
              116,
              101,
              114,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              111,
              114,
              115,
              47,
              42,
              125,
              58,
              117,
              112,
              103,
              114,
              97,
              100,
              101,
              65,
              112,
              112,
              108,
              105,
              97,
              110,
              99,
              101,
            ]),
          ],
        },
      },
    },
    /** Creates a new MigratingVm in a given Source. */
    createMigratingVm: {
      name: "CreateMigratingVm",
      requestType: CreateMigratingVmRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              35,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              95,
              118,
              109,
              44,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              95,
              118,
              109,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              74,
              58,
              12,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              95,
              118,
              109,
              34,
              58,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists MigratingVms in a given Source. */
    listMigratingVms: {
      name: "ListMigratingVms",
      requestType: ListMigratingVmsRequest,
      requestStream: false,
      responseType: ListMigratingVmsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single MigratingVm. */
    getMigratingVm: {
      name: "GetMigratingVm",
      requestType: GetMigratingVmRequest,
      requestStream: false,
      responseType: MigratingVm,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a single MigratingVm. */
    updateMigratingVm: {
      name: "UpdateMigratingVm",
      requestType: UpdateMigratingVmRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              24,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              95,
              118,
              109,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              87,
              58,
              12,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              95,
              118,
              109,
              50,
              71,
              47,
              118,
              49,
              47,
              123,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              95,
              118,
              109,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single MigratingVm. */
    deleteMigratingVm: {
      name: "DeleteMigratingVm",
      requestType: DeleteMigratingVmRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              42,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Starts migration for a VM. Starts the process of uploading
     * data and creating snapshots, in replication cycles scheduled by the policy.
     */
    startMigration: {
      name: "StartMigration",
      requestType: StartMigrationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              43,
              10,
              22,
              83,
              116,
              97,
              114,
              116,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([12, 109, 105, 103, 114, 97, 116, 105, 110, 103, 95, 118, 109])],
          578365826: [
            Buffer.from([
              86,
              58,
              1,
              42,
              34,
              81,
              47,
              118,
              49,
              47,
              123,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              95,
              118,
              109,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              97,
              114,
              116,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * Resumes a migration for a VM. When called on a paused migration, will start
     * the process of uploading data and creating snapshots; when called on a
     * completed cut-over migration, will update the migration to active state and
     * start the process of uploading data and creating snapshots.
     */
    resumeMigration: {
      name: "ResumeMigration",
      requestType: ResumeMigrationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              44,
              10,
              23,
              82,
              101,
              115,
              117,
              109,
              101,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              87,
              58,
              1,
              42,
              34,
              82,
              47,
              118,
              49,
              47,
              123,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              95,
              118,
              109,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              115,
              117,
              109,
              101,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * Pauses a migration for a VM. If cycle tasks are running they will be
     * cancelled, preserving source task data. Further replication cycles will not
     * be triggered while the VM is paused.
     */
    pauseMigration: {
      name: "PauseMigration",
      requestType: PauseMigrationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              43,
              10,
              22,
              80,
              97,
              117,
              115,
              101,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              86,
              58,
              1,
              42,
              34,
              81,
              47,
              118,
              49,
              47,
              123,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              95,
              118,
              109,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              125,
              58,
              112,
              97,
              117,
              115,
              101,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * Marks a migration as completed, deleting migration resources that are no
     * longer being used. Only applicable after cutover is done.
     */
    finalizeMigration: {
      name: "FinalizeMigration",
      requestType: FinalizeMigrationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              46,
              10,
              25,
              70,
              105,
              110,
              97,
              108,
              105,
              122,
              101,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([12, 109, 105, 103, 114, 97, 116, 105, 110, 103, 95, 118, 109])],
          578365826: [
            Buffer.from([
              89,
              58,
              1,
              42,
              34,
              84,
              47,
              118,
              49,
              47,
              123,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              95,
              118,
              109,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              125,
              58,
              102,
              105,
              110,
              97,
              108,
              105,
              122,
              101,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /** Initiates a Clone of a specific migrating VM. */
    createCloneJob: {
      name: "CreateCloneJob",
      requestType: CreateCloneJobRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              29,
              10,
              8,
              67,
              108,
              111,
              110,
              101,
              74,
              111,
              98,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              29,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              108,
              111,
              110,
              101,
              95,
              106,
              111,
              98,
              44,
              99,
              108,
              111,
              110,
              101,
              95,
              106,
              111,
              98,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              83,
              58,
              9,
              99,
              108,
              111,
              110,
              101,
              95,
              106,
              111,
              98,
              34,
              70,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              125,
              47,
              99,
              108,
              111,
              110,
              101,
              74,
              111,
              98,
              115,
            ]),
          ],
        },
      },
    },
    /** Initiates the cancellation of a running clone job. */
    cancelCloneJob: {
      name: "CancelCloneJob",
      requestType: CancelCloneJobRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              43,
              10,
              22,
              67,
              97,
              110,
              99,
              101,
              108,
              67,
              108,
              111,
              110,
              101,
              74,
              111,
              98,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              82,
              58,
              1,
              42,
              34,
              77,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              47,
              99,
              108,
              111,
              110,
              101,
              74,
              111,
              98,
              115,
              47,
              42,
              125,
              58,
              99,
              97,
              110,
              99,
              101,
              108,
            ]),
          ],
        },
      },
    },
    /** Lists CloneJobs of a given migrating VM. */
    listCloneJobs: {
      name: "ListCloneJobs",
      requestType: ListCloneJobsRequest,
      requestStream: false,
      responseType: ListCloneJobsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              72,
              18,
              70,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              125,
              47,
              99,
              108,
              111,
              110,
              101,
              74,
              111,
              98,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single CloneJob. */
    getCloneJob: {
      name: "GetCloneJob",
      requestType: GetCloneJobRequest,
      requestStream: false,
      responseType: CloneJob,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              72,
              18,
              70,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              47,
              99,
              108,
              111,
              110,
              101,
              74,
              111,
              98,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Initiates a Cutover of a specific migrating VM.
     * The returned LRO is completed when the cutover job resource is created
     * and the job is initiated.
     */
    createCutoverJob: {
      name: "CreateCutoverJob",
      requestType: CreateCutoverJobRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              31,
              10,
              10,
              67,
              117,
              116,
              111,
              118,
              101,
              114,
              74,
              111,
              98,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              33,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              117,
              116,
              111,
              118,
              101,
              114,
              95,
              106,
              111,
              98,
              44,
              99,
              117,
              116,
              111,
              118,
              101,
              114,
              95,
              106,
              111,
              98,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              87,
              58,
              11,
              99,
              117,
              116,
              111,
              118,
              101,
              114,
              95,
              106,
              111,
              98,
              34,
              72,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              125,
              47,
              99,
              117,
              116,
              111,
              118,
              101,
              114,
              74,
              111,
              98,
              115,
            ]),
          ],
        },
      },
    },
    /** Initiates the cancellation of a running cutover job. */
    cancelCutoverJob: {
      name: "CancelCutoverJob",
      requestType: CancelCutoverJobRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              45,
              10,
              24,
              67,
              97,
              110,
              99,
              101,
              108,
              67,
              117,
              116,
              111,
              118,
              101,
              114,
              74,
              111,
              98,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              84,
              58,
              1,
              42,
              34,
              79,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              47,
              99,
              117,
              116,
              111,
              118,
              101,
              114,
              74,
              111,
              98,
              115,
              47,
              42,
              125,
              58,
              99,
              97,
              110,
              99,
              101,
              108,
            ]),
          ],
        },
      },
    },
    /** Lists CutoverJobs of a given migrating VM. */
    listCutoverJobs: {
      name: "ListCutoverJobs",
      requestType: ListCutoverJobsRequest,
      requestStream: false,
      responseType: ListCutoverJobsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              74,
              18,
              72,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              125,
              47,
              99,
              117,
              116,
              111,
              118,
              101,
              114,
              74,
              111,
              98,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single CutoverJob. */
    getCutoverJob: {
      name: "GetCutoverJob",
      requestType: GetCutoverJobRequest,
      requestStream: false,
      responseType: CutoverJob,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              74,
              18,
              72,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              47,
              99,
              117,
              116,
              111,
              118,
              101,
              114,
              74,
              111,
              98,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Groups in a given project and location. */
    listGroups: {
      name: "ListGroups",
      requestType: ListGroupsRequest,
      requestStream: false,
      responseType: ListGroupsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Group. */
    getGroup: {
      name: "GetGroup",
      requestType: GetGroupRequest,
      requestStream: false,
      responseType: Group,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new Group in a given project and location. */
    createGroup: {
      name: "CreateGroup",
      requestType: CreateGroupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              26,
              10,
              5,
              71,
              114,
              111,
              117,
              112,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              21,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              103,
              114,
              111,
              117,
              112,
              44,
              103,
              114,
              111,
              117,
              112,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              51,
              58,
              5,
              103,
              114,
              111,
              117,
              112,
              34,
              42,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a single Group. */
    updateGroup: {
      name: "UpdateGroup",
      requestType: UpdateGroupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              26,
              10,
              5,
              71,
              114,
              111,
              117,
              112,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([17, 103, 114, 111, 117, 112, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              57,
              58,
              5,
              103,
              114,
              111,
              117,
              112,
              50,
              48,
              47,
              118,
              49,
              47,
              123,
              103,
              114,
              111,
              117,
              112,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single Group. */
    deleteGroup: {
      name: "DeleteGroup",
      requestType: DeleteGroupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              42,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Adds a MigratingVm to a Group. */
    addGroupMigration: {
      name: "AddGroupMigration",
      requestType: AddGroupMigrationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              46,
              10,
              25,
              65,
              100,
              100,
              71,
              114,
              111,
              117,
              112,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([5, 103, 114, 111, 117, 112])],
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              47,
              123,
              103,
              114,
              111,
              117,
              112,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
              58,
              97,
              100,
              100,
              71,
              114,
              111,
              117,
              112,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /** Removes a MigratingVm from a Group. */
    removeGroupMigration: {
      name: "RemoveGroupMigration",
      requestType: RemoveGroupMigrationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              49,
              10,
              28,
              82,
              101,
              109,
              111,
              118,
              101,
              71,
              114,
              111,
              117,
              112,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([5, 103, 114, 111, 117, 112])],
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              49,
              47,
              123,
              103,
              114,
              111,
              117,
              112,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              109,
              111,
              118,
              101,
              71,
              114,
              111,
              117,
              112,
              77,
              105,
              103,
              114,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * Lists TargetProjects in a given project.
     *
     * NOTE: TargetProject is a global resource; hence the only supported value
     * for location is `global`.
     */
    listTargetProjects: {
      name: "ListTargetProjects",
      requestType: ListTargetProjectsRequest,
      requestStream: false,
      responseType: ListTargetProjectsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              80,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets details of a single TargetProject.
     *
     * NOTE: TargetProject is a global resource; hence the only supported value
     * for location is `global`.
     */
    getTargetProject: {
      name: "GetTargetProject",
      requestType: GetTargetProjectRequest,
      requestStream: false,
      responseType: TargetProject,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              80,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new TargetProject in a given project.
     *
     * NOTE: TargetProject is a global resource; hence the only supported value
     * for location is `global`.
     */
    createTargetProject: {
      name: "CreateTargetProject",
      requestType: CreateTargetProjectRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              34,
              10,
              13,
              84,
              97,
              114,
              103,
              101,
              116,
              80,
              114,
              111,
              106,
              101,
              99,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              39,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              44,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              14,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              34,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              80,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the parameters of a single TargetProject.
     *
     * NOTE: TargetProject is a global resource; hence the only supported value
     * for location is `global`.
     */
    updateTargetProject: {
      name: "UpdateTargetProject",
      requestType: UpdateTargetProjectRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              34,
              10,
              13,
              84,
              97,
              114,
              103,
              101,
              116,
              80,
              114,
              111,
              106,
              101,
              99,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              26,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              83,
              58,
              14,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              50,
              65,
              47,
              118,
              49,
              47,
              123,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              80,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a single TargetProject.
     *
     * NOTE: TargetProject is a global resource; hence the only supported value
     * for location is `global`.
     */
    deleteTargetProject: {
      name: "DeleteTargetProject",
      requestType: DeleteTargetProjectRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              42,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              80,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists ReplicationCycles in a given MigratingVM. */
    listReplicationCycles: {
      name: "ListReplicationCycles",
      requestType: ListReplicationCyclesRequest,
      requestStream: false,
      responseType: ListReplicationCyclesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              80,
              18,
              78,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              121,
              99,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single ReplicationCycle. */
    getReplicationCycle: {
      name: "GetReplicationCycle",
      requestType: GetReplicationCycleRequest,
      requestStream: false,
      responseType: ReplicationCycle,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              80,
              18,
              78,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              109,
              105,
              103,
              114,
              97,
              116,
              105,
              110,
              103,
              86,
              109,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              108,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              121,
              99,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface VmMigrationServiceImplementation<CallContextExt = {}> {
  /** Lists Sources in a given project and location. */
  listSources(
    request: ListSourcesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSourcesResponse>>;
  /** Gets details of a single Source. */
  getSource(request: GetSourceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Source>>;
  /** Creates a new Source in a given project and location. */
  createSource(request: CreateSourceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a single Source. */
  updateSource(request: UpdateSourceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a single Source. */
  deleteSource(request: DeleteSourceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * List remote source's inventory of VMs.
   * The remote source is the onprem vCenter (remote in the sense it's not in
   * Compute Engine). The inventory describes the list of existing VMs in that
   * source. Note that this operation lists the VMs on the remote source, as
   * opposed to listing the MigratingVms resources in the vmmigration service.
   */
  fetchInventory(
    request: FetchInventoryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FetchInventoryResponse>>;
  /** Lists Utilization Reports of the given Source. */
  listUtilizationReports(
    request: ListUtilizationReportsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListUtilizationReportsResponse>>;
  /** Gets a single Utilization Report. */
  getUtilizationReport(
    request: GetUtilizationReportRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UtilizationReport>>;
  /** Creates a new UtilizationReport. */
  createUtilizationReport(
    request: CreateUtilizationReportRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single Utilization Report. */
  deleteUtilizationReport(
    request: DeleteUtilizationReportRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists DatacenterConnectors in a given Source. */
  listDatacenterConnectors(
    request: ListDatacenterConnectorsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDatacenterConnectorsResponse>>;
  /** Gets details of a single DatacenterConnector. */
  getDatacenterConnector(
    request: GetDatacenterConnectorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DatacenterConnector>>;
  /** Creates a new DatacenterConnector in a given Source. */
  createDatacenterConnector(
    request: CreateDatacenterConnectorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single DatacenterConnector. */
  deleteDatacenterConnector(
    request: DeleteDatacenterConnectorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Upgrades the appliance relate to this DatacenterConnector to the in-place
   * updateable version.
   */
  upgradeAppliance(
    request: UpgradeApplianceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Creates a new MigratingVm in a given Source. */
  createMigratingVm(
    request: CreateMigratingVmRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists MigratingVms in a given Source. */
  listMigratingVms(
    request: ListMigratingVmsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListMigratingVmsResponse>>;
  /** Gets details of a single MigratingVm. */
  getMigratingVm(
    request: GetMigratingVmRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<MigratingVm>>;
  /** Updates the parameters of a single MigratingVm. */
  updateMigratingVm(
    request: UpdateMigratingVmRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single MigratingVm. */
  deleteMigratingVm(
    request: DeleteMigratingVmRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Starts migration for a VM. Starts the process of uploading
   * data and creating snapshots, in replication cycles scheduled by the policy.
   */
  startMigration(
    request: StartMigrationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Resumes a migration for a VM. When called on a paused migration, will start
   * the process of uploading data and creating snapshots; when called on a
   * completed cut-over migration, will update the migration to active state and
   * start the process of uploading data and creating snapshots.
   */
  resumeMigration(
    request: ResumeMigrationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Pauses a migration for a VM. If cycle tasks are running they will be
   * cancelled, preserving source task data. Further replication cycles will not
   * be triggered while the VM is paused.
   */
  pauseMigration(
    request: PauseMigrationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Marks a migration as completed, deleting migration resources that are no
   * longer being used. Only applicable after cutover is done.
   */
  finalizeMigration(
    request: FinalizeMigrationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Initiates a Clone of a specific migrating VM. */
  createCloneJob(
    request: CreateCloneJobRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Initiates the cancellation of a running clone job. */
  cancelCloneJob(
    request: CancelCloneJobRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists CloneJobs of a given migrating VM. */
  listCloneJobs(
    request: ListCloneJobsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCloneJobsResponse>>;
  /** Gets details of a single CloneJob. */
  getCloneJob(request: GetCloneJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<CloneJob>>;
  /**
   * Initiates a Cutover of a specific migrating VM.
   * The returned LRO is completed when the cutover job resource is created
   * and the job is initiated.
   */
  createCutoverJob(
    request: CreateCutoverJobRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Initiates the cancellation of a running cutover job. */
  cancelCutoverJob(
    request: CancelCutoverJobRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists CutoverJobs of a given migrating VM. */
  listCutoverJobs(
    request: ListCutoverJobsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCutoverJobsResponse>>;
  /** Gets details of a single CutoverJob. */
  getCutoverJob(request: GetCutoverJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<CutoverJob>>;
  /** Lists Groups in a given project and location. */
  listGroups(
    request: ListGroupsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListGroupsResponse>>;
  /** Gets details of a single Group. */
  getGroup(request: GetGroupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Group>>;
  /** Creates a new Group in a given project and location. */
  createGroup(request: CreateGroupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a single Group. */
  updateGroup(request: UpdateGroupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a single Group. */
  deleteGroup(request: DeleteGroupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Adds a MigratingVm to a Group. */
  addGroupMigration(
    request: AddGroupMigrationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Removes a MigratingVm from a Group. */
  removeGroupMigration(
    request: RemoveGroupMigrationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Lists TargetProjects in a given project.
   *
   * NOTE: TargetProject is a global resource; hence the only supported value
   * for location is `global`.
   */
  listTargetProjects(
    request: ListTargetProjectsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTargetProjectsResponse>>;
  /**
   * Gets details of a single TargetProject.
   *
   * NOTE: TargetProject is a global resource; hence the only supported value
   * for location is `global`.
   */
  getTargetProject(
    request: GetTargetProjectRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TargetProject>>;
  /**
   * Creates a new TargetProject in a given project.
   *
   * NOTE: TargetProject is a global resource; hence the only supported value
   * for location is `global`.
   */
  createTargetProject(
    request: CreateTargetProjectRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates the parameters of a single TargetProject.
   *
   * NOTE: TargetProject is a global resource; hence the only supported value
   * for location is `global`.
   */
  updateTargetProject(
    request: UpdateTargetProjectRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes a single TargetProject.
   *
   * NOTE: TargetProject is a global resource; hence the only supported value
   * for location is `global`.
   */
  deleteTargetProject(
    request: DeleteTargetProjectRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists ReplicationCycles in a given MigratingVM. */
  listReplicationCycles(
    request: ListReplicationCyclesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListReplicationCyclesResponse>>;
  /** Gets details of a single ReplicationCycle. */
  getReplicationCycle(
    request: GetReplicationCycleRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReplicationCycle>>;
}

export interface VmMigrationClient<CallOptionsExt = {}> {
  /** Lists Sources in a given project and location. */
  listSources(
    request: DeepPartial<ListSourcesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSourcesResponse>;
  /** Gets details of a single Source. */
  getSource(request: DeepPartial<GetSourceRequest>, options?: CallOptions & CallOptionsExt): Promise<Source>;
  /** Creates a new Source in a given project and location. */
  createSource(request: DeepPartial<CreateSourceRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the parameters of a single Source. */
  updateSource(request: DeepPartial<UpdateSourceRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a single Source. */
  deleteSource(request: DeepPartial<DeleteSourceRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * List remote source's inventory of VMs.
   * The remote source is the onprem vCenter (remote in the sense it's not in
   * Compute Engine). The inventory describes the list of existing VMs in that
   * source. Note that this operation lists the VMs on the remote source, as
   * opposed to listing the MigratingVms resources in the vmmigration service.
   */
  fetchInventory(
    request: DeepPartial<FetchInventoryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FetchInventoryResponse>;
  /** Lists Utilization Reports of the given Source. */
  listUtilizationReports(
    request: DeepPartial<ListUtilizationReportsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListUtilizationReportsResponse>;
  /** Gets a single Utilization Report. */
  getUtilizationReport(
    request: DeepPartial<GetUtilizationReportRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UtilizationReport>;
  /** Creates a new UtilizationReport. */
  createUtilizationReport(
    request: DeepPartial<CreateUtilizationReportRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single Utilization Report. */
  deleteUtilizationReport(
    request: DeepPartial<DeleteUtilizationReportRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists DatacenterConnectors in a given Source. */
  listDatacenterConnectors(
    request: DeepPartial<ListDatacenterConnectorsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDatacenterConnectorsResponse>;
  /** Gets details of a single DatacenterConnector. */
  getDatacenterConnector(
    request: DeepPartial<GetDatacenterConnectorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DatacenterConnector>;
  /** Creates a new DatacenterConnector in a given Source. */
  createDatacenterConnector(
    request: DeepPartial<CreateDatacenterConnectorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single DatacenterConnector. */
  deleteDatacenterConnector(
    request: DeepPartial<DeleteDatacenterConnectorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Upgrades the appliance relate to this DatacenterConnector to the in-place
   * updateable version.
   */
  upgradeAppliance(
    request: DeepPartial<UpgradeApplianceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Creates a new MigratingVm in a given Source. */
  createMigratingVm(
    request: DeepPartial<CreateMigratingVmRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists MigratingVms in a given Source. */
  listMigratingVms(
    request: DeepPartial<ListMigratingVmsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListMigratingVmsResponse>;
  /** Gets details of a single MigratingVm. */
  getMigratingVm(
    request: DeepPartial<GetMigratingVmRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<MigratingVm>;
  /** Updates the parameters of a single MigratingVm. */
  updateMigratingVm(
    request: DeepPartial<UpdateMigratingVmRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single MigratingVm. */
  deleteMigratingVm(
    request: DeepPartial<DeleteMigratingVmRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Starts migration for a VM. Starts the process of uploading
   * data and creating snapshots, in replication cycles scheduled by the policy.
   */
  startMigration(
    request: DeepPartial<StartMigrationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Resumes a migration for a VM. When called on a paused migration, will start
   * the process of uploading data and creating snapshots; when called on a
   * completed cut-over migration, will update the migration to active state and
   * start the process of uploading data and creating snapshots.
   */
  resumeMigration(
    request: DeepPartial<ResumeMigrationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Pauses a migration for a VM. If cycle tasks are running they will be
   * cancelled, preserving source task data. Further replication cycles will not
   * be triggered while the VM is paused.
   */
  pauseMigration(
    request: DeepPartial<PauseMigrationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Marks a migration as completed, deleting migration resources that are no
   * longer being used. Only applicable after cutover is done.
   */
  finalizeMigration(
    request: DeepPartial<FinalizeMigrationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Initiates a Clone of a specific migrating VM. */
  createCloneJob(
    request: DeepPartial<CreateCloneJobRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Initiates the cancellation of a running clone job. */
  cancelCloneJob(
    request: DeepPartial<CancelCloneJobRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists CloneJobs of a given migrating VM. */
  listCloneJobs(
    request: DeepPartial<ListCloneJobsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCloneJobsResponse>;
  /** Gets details of a single CloneJob. */
  getCloneJob(request: DeepPartial<GetCloneJobRequest>, options?: CallOptions & CallOptionsExt): Promise<CloneJob>;
  /**
   * Initiates a Cutover of a specific migrating VM.
   * The returned LRO is completed when the cutover job resource is created
   * and the job is initiated.
   */
  createCutoverJob(
    request: DeepPartial<CreateCutoverJobRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Initiates the cancellation of a running cutover job. */
  cancelCutoverJob(
    request: DeepPartial<CancelCutoverJobRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists CutoverJobs of a given migrating VM. */
  listCutoverJobs(
    request: DeepPartial<ListCutoverJobsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCutoverJobsResponse>;
  /** Gets details of a single CutoverJob. */
  getCutoverJob(
    request: DeepPartial<GetCutoverJobRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CutoverJob>;
  /** Lists Groups in a given project and location. */
  listGroups(
    request: DeepPartial<ListGroupsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListGroupsResponse>;
  /** Gets details of a single Group. */
  getGroup(request: DeepPartial<GetGroupRequest>, options?: CallOptions & CallOptionsExt): Promise<Group>;
  /** Creates a new Group in a given project and location. */
  createGroup(request: DeepPartial<CreateGroupRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the parameters of a single Group. */
  updateGroup(request: DeepPartial<UpdateGroupRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a single Group. */
  deleteGroup(request: DeepPartial<DeleteGroupRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Adds a MigratingVm to a Group. */
  addGroupMigration(
    request: DeepPartial<AddGroupMigrationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Removes a MigratingVm from a Group. */
  removeGroupMigration(
    request: DeepPartial<RemoveGroupMigrationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Lists TargetProjects in a given project.
   *
   * NOTE: TargetProject is a global resource; hence the only supported value
   * for location is `global`.
   */
  listTargetProjects(
    request: DeepPartial<ListTargetProjectsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTargetProjectsResponse>;
  /**
   * Gets details of a single TargetProject.
   *
   * NOTE: TargetProject is a global resource; hence the only supported value
   * for location is `global`.
   */
  getTargetProject(
    request: DeepPartial<GetTargetProjectRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TargetProject>;
  /**
   * Creates a new TargetProject in a given project.
   *
   * NOTE: TargetProject is a global resource; hence the only supported value
   * for location is `global`.
   */
  createTargetProject(
    request: DeepPartial<CreateTargetProjectRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates the parameters of a single TargetProject.
   *
   * NOTE: TargetProject is a global resource; hence the only supported value
   * for location is `global`.
   */
  updateTargetProject(
    request: DeepPartial<UpdateTargetProjectRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes a single TargetProject.
   *
   * NOTE: TargetProject is a global resource; hence the only supported value
   * for location is `global`.
   */
  deleteTargetProject(
    request: DeepPartial<DeleteTargetProjectRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists ReplicationCycles in a given MigratingVM. */
  listReplicationCycles(
    request: DeepPartial<ListReplicationCyclesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListReplicationCyclesResponse>;
  /** Gets details of a single ReplicationCycle. */
  getReplicationCycle(
    request: DeepPartial<GetReplicationCycleRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReplicationCycle>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
