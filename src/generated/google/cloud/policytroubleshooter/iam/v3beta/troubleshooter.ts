// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/policytroubleshooter/iam/v3beta/troubleshooter.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Policy } from "../../../../iam/v1/policy.js";
import { Policy as Policy1 } from "../../../../iam/v2/policy.js";
import { Value } from "../../../../protobuf/struct.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { Status } from "../../../../rpc/status.js";
import { Expr } from "../../../../type/expr.js";

export const protobufPackage = "google.cloud.policytroubleshooter.iam.v3beta";

/** Whether IAM allow policies gives the principal the permission. */
export enum AllowAccessState {
  /** ALLOW_ACCESS_STATE_UNSPECIFIED - Not specified. */
  ALLOW_ACCESS_STATE_UNSPECIFIED = 0,
  /** ALLOW_ACCESS_STATE_GRANTED - The allow policy gives the principal the permission. */
  ALLOW_ACCESS_STATE_GRANTED = 1,
  /** ALLOW_ACCESS_STATE_NOT_GRANTED - The allow policy doesn't give the principal the permission. */
  ALLOW_ACCESS_STATE_NOT_GRANTED = 2,
  /**
   * ALLOW_ACCESS_STATE_UNKNOWN_CONDITIONAL - The allow policy gives the principal the permission if a condition
   * expression evaluate to `true`. However, the sender of the request didn't
   * provide enough context for Policy Troubleshooter to evaluate the condition
   * expression.
   */
  ALLOW_ACCESS_STATE_UNKNOWN_CONDITIONAL = 3,
  /**
   * ALLOW_ACCESS_STATE_UNKNOWN_INFO - The sender of the request doesn't have access to all of the allow policies
   * that Policy Troubleshooter needs to evaluate the principal's access.
   */
  ALLOW_ACCESS_STATE_UNKNOWN_INFO = 4,
  UNRECOGNIZED = -1,
}

export function allowAccessStateFromJSON(object: any): AllowAccessState {
  switch (object) {
    case 0:
    case "ALLOW_ACCESS_STATE_UNSPECIFIED":
      return AllowAccessState.ALLOW_ACCESS_STATE_UNSPECIFIED;
    case 1:
    case "ALLOW_ACCESS_STATE_GRANTED":
      return AllowAccessState.ALLOW_ACCESS_STATE_GRANTED;
    case 2:
    case "ALLOW_ACCESS_STATE_NOT_GRANTED":
      return AllowAccessState.ALLOW_ACCESS_STATE_NOT_GRANTED;
    case 3:
    case "ALLOW_ACCESS_STATE_UNKNOWN_CONDITIONAL":
      return AllowAccessState.ALLOW_ACCESS_STATE_UNKNOWN_CONDITIONAL;
    case 4:
    case "ALLOW_ACCESS_STATE_UNKNOWN_INFO":
      return AllowAccessState.ALLOW_ACCESS_STATE_UNKNOWN_INFO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AllowAccessState.UNRECOGNIZED;
  }
}

export function allowAccessStateToJSON(object: AllowAccessState): string {
  switch (object) {
    case AllowAccessState.ALLOW_ACCESS_STATE_UNSPECIFIED:
      return "ALLOW_ACCESS_STATE_UNSPECIFIED";
    case AllowAccessState.ALLOW_ACCESS_STATE_GRANTED:
      return "ALLOW_ACCESS_STATE_GRANTED";
    case AllowAccessState.ALLOW_ACCESS_STATE_NOT_GRANTED:
      return "ALLOW_ACCESS_STATE_NOT_GRANTED";
    case AllowAccessState.ALLOW_ACCESS_STATE_UNKNOWN_CONDITIONAL:
      return "ALLOW_ACCESS_STATE_UNKNOWN_CONDITIONAL";
    case AllowAccessState.ALLOW_ACCESS_STATE_UNKNOWN_INFO:
      return "ALLOW_ACCESS_STATE_UNKNOWN_INFO";
    case AllowAccessState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Whether IAM deny policies deny the principal the permission. */
export enum DenyAccessState {
  /** DENY_ACCESS_STATE_UNSPECIFIED - Not specified. */
  DENY_ACCESS_STATE_UNSPECIFIED = 0,
  /** DENY_ACCESS_STATE_DENIED - The deny policy denies the principal the permission. */
  DENY_ACCESS_STATE_DENIED = 1,
  /** DENY_ACCESS_STATE_NOT_DENIED - The deny policy doesn't deny the principal the permission. */
  DENY_ACCESS_STATE_NOT_DENIED = 2,
  /**
   * DENY_ACCESS_STATE_UNKNOWN_CONDITIONAL - The deny policy denies the principal the permission if a condition
   * expression evaluates to `true`. However, the sender of the request didn't
   * provide enough context for Policy Troubleshooter to evaluate the condition
   * expression.
   */
  DENY_ACCESS_STATE_UNKNOWN_CONDITIONAL = 3,
  /**
   * DENY_ACCESS_STATE_UNKNOWN_INFO - The sender of the request does not have access to all of the deny policies
   * that Policy Troubleshooter needs to evaluate the principal's access.
   */
  DENY_ACCESS_STATE_UNKNOWN_INFO = 4,
  UNRECOGNIZED = -1,
}

export function denyAccessStateFromJSON(object: any): DenyAccessState {
  switch (object) {
    case 0:
    case "DENY_ACCESS_STATE_UNSPECIFIED":
      return DenyAccessState.DENY_ACCESS_STATE_UNSPECIFIED;
    case 1:
    case "DENY_ACCESS_STATE_DENIED":
      return DenyAccessState.DENY_ACCESS_STATE_DENIED;
    case 2:
    case "DENY_ACCESS_STATE_NOT_DENIED":
      return DenyAccessState.DENY_ACCESS_STATE_NOT_DENIED;
    case 3:
    case "DENY_ACCESS_STATE_UNKNOWN_CONDITIONAL":
      return DenyAccessState.DENY_ACCESS_STATE_UNKNOWN_CONDITIONAL;
    case 4:
    case "DENY_ACCESS_STATE_UNKNOWN_INFO":
      return DenyAccessState.DENY_ACCESS_STATE_UNKNOWN_INFO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DenyAccessState.UNRECOGNIZED;
  }
}

export function denyAccessStateToJSON(object: DenyAccessState): string {
  switch (object) {
    case DenyAccessState.DENY_ACCESS_STATE_UNSPECIFIED:
      return "DENY_ACCESS_STATE_UNSPECIFIED";
    case DenyAccessState.DENY_ACCESS_STATE_DENIED:
      return "DENY_ACCESS_STATE_DENIED";
    case DenyAccessState.DENY_ACCESS_STATE_NOT_DENIED:
      return "DENY_ACCESS_STATE_NOT_DENIED";
    case DenyAccessState.DENY_ACCESS_STATE_UNKNOWN_CONDITIONAL:
      return "DENY_ACCESS_STATE_UNKNOWN_CONDITIONAL";
    case DenyAccessState.DENY_ACCESS_STATE_UNKNOWN_INFO:
      return "DENY_ACCESS_STATE_UNKNOWN_INFO";
    case DenyAccessState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Whether a role includes a specific permission. */
export enum RolePermissionInclusionState {
  /** ROLE_PERMISSION_INCLUSION_STATE_UNSPECIFIED - Not specified. */
  ROLE_PERMISSION_INCLUSION_STATE_UNSPECIFIED = 0,
  /** ROLE_PERMISSION_INCLUDED - The permission is included in the role. */
  ROLE_PERMISSION_INCLUDED = 1,
  /** ROLE_PERMISSION_NOT_INCLUDED - The permission is not included in the role. */
  ROLE_PERMISSION_NOT_INCLUDED = 2,
  /** ROLE_PERMISSION_UNKNOWN_INFO - The sender of the request is not allowed to access the role definition. */
  ROLE_PERMISSION_UNKNOWN_INFO = 3,
  UNRECOGNIZED = -1,
}

export function rolePermissionInclusionStateFromJSON(object: any): RolePermissionInclusionState {
  switch (object) {
    case 0:
    case "ROLE_PERMISSION_INCLUSION_STATE_UNSPECIFIED":
      return RolePermissionInclusionState.ROLE_PERMISSION_INCLUSION_STATE_UNSPECIFIED;
    case 1:
    case "ROLE_PERMISSION_INCLUDED":
      return RolePermissionInclusionState.ROLE_PERMISSION_INCLUDED;
    case 2:
    case "ROLE_PERMISSION_NOT_INCLUDED":
      return RolePermissionInclusionState.ROLE_PERMISSION_NOT_INCLUDED;
    case 3:
    case "ROLE_PERMISSION_UNKNOWN_INFO":
      return RolePermissionInclusionState.ROLE_PERMISSION_UNKNOWN_INFO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RolePermissionInclusionState.UNRECOGNIZED;
  }
}

export function rolePermissionInclusionStateToJSON(object: RolePermissionInclusionState): string {
  switch (object) {
    case RolePermissionInclusionState.ROLE_PERMISSION_INCLUSION_STATE_UNSPECIFIED:
      return "ROLE_PERMISSION_INCLUSION_STATE_UNSPECIFIED";
    case RolePermissionInclusionState.ROLE_PERMISSION_INCLUDED:
      return "ROLE_PERMISSION_INCLUDED";
    case RolePermissionInclusionState.ROLE_PERMISSION_NOT_INCLUDED:
      return "ROLE_PERMISSION_NOT_INCLUDED";
    case RolePermissionInclusionState.ROLE_PERMISSION_UNKNOWN_INFO:
      return "ROLE_PERMISSION_UNKNOWN_INFO";
    case RolePermissionInclusionState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Whether the permission in the request matches the permission in the policy. */
export enum PermissionPatternMatchingState {
  /** PERMISSION_PATTERN_MATCHING_STATE_UNSPECIFIED - Not specified. */
  PERMISSION_PATTERN_MATCHING_STATE_UNSPECIFIED = 0,
  /** PERMISSION_PATTERN_MATCHED - The permission in the request matches the permission in the policy. */
  PERMISSION_PATTERN_MATCHED = 1,
  /** PERMISSION_PATTERN_NOT_MATCHED - The permission in the request matches the permission in the policy. */
  PERMISSION_PATTERN_NOT_MATCHED = 2,
  UNRECOGNIZED = -1,
}

export function permissionPatternMatchingStateFromJSON(object: any): PermissionPatternMatchingState {
  switch (object) {
    case 0:
    case "PERMISSION_PATTERN_MATCHING_STATE_UNSPECIFIED":
      return PermissionPatternMatchingState.PERMISSION_PATTERN_MATCHING_STATE_UNSPECIFIED;
    case 1:
    case "PERMISSION_PATTERN_MATCHED":
      return PermissionPatternMatchingState.PERMISSION_PATTERN_MATCHED;
    case 2:
    case "PERMISSION_PATTERN_NOT_MATCHED":
      return PermissionPatternMatchingState.PERMISSION_PATTERN_NOT_MATCHED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PermissionPatternMatchingState.UNRECOGNIZED;
  }
}

export function permissionPatternMatchingStateToJSON(object: PermissionPatternMatchingState): string {
  switch (object) {
    case PermissionPatternMatchingState.PERMISSION_PATTERN_MATCHING_STATE_UNSPECIFIED:
      return "PERMISSION_PATTERN_MATCHING_STATE_UNSPECIFIED";
    case PermissionPatternMatchingState.PERMISSION_PATTERN_MATCHED:
      return "PERMISSION_PATTERN_MATCHED";
    case PermissionPatternMatchingState.PERMISSION_PATTERN_NOT_MATCHED:
      return "PERMISSION_PATTERN_NOT_MATCHED";
    case PermissionPatternMatchingState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Whether the principal in the request matches the principal in the policy. */
export enum MembershipMatchingState {
  /** MEMBERSHIP_MATCHING_STATE_UNSPECIFIED - Not specified. */
  MEMBERSHIP_MATCHING_STATE_UNSPECIFIED = 0,
  /**
   * MEMBERSHIP_MATCHED - The principal in the request matches the principal in the policy. The
   * principal can be included directly or indirectly:
   *
   * * A principal is included directly if that principal is listed in the
   *   role binding.
   * * A principal is included indirectly if that principal is in a Google
   *   group, Google Workspace account, or Cloud Identity domain that is listed
   *   in the policy.
   */
  MEMBERSHIP_MATCHED = 1,
  /** MEMBERSHIP_NOT_MATCHED - The principal in the request doesn't match the principal in the policy. */
  MEMBERSHIP_NOT_MATCHED = 2,
  /**
   * MEMBERSHIP_UNKNOWN_INFO - The principal in the policy is a group or domain, and the sender of the
   * request doesn't have permission to view whether the principal in the
   * request is a member of the group or domain.
   */
  MEMBERSHIP_UNKNOWN_INFO = 3,
  /** MEMBERSHIP_UNKNOWN_UNSUPPORTED - The principal is an unsupported type. */
  MEMBERSHIP_UNKNOWN_UNSUPPORTED = 4,
  UNRECOGNIZED = -1,
}

export function membershipMatchingStateFromJSON(object: any): MembershipMatchingState {
  switch (object) {
    case 0:
    case "MEMBERSHIP_MATCHING_STATE_UNSPECIFIED":
      return MembershipMatchingState.MEMBERSHIP_MATCHING_STATE_UNSPECIFIED;
    case 1:
    case "MEMBERSHIP_MATCHED":
      return MembershipMatchingState.MEMBERSHIP_MATCHED;
    case 2:
    case "MEMBERSHIP_NOT_MATCHED":
      return MembershipMatchingState.MEMBERSHIP_NOT_MATCHED;
    case 3:
    case "MEMBERSHIP_UNKNOWN_INFO":
      return MembershipMatchingState.MEMBERSHIP_UNKNOWN_INFO;
    case 4:
    case "MEMBERSHIP_UNKNOWN_UNSUPPORTED":
      return MembershipMatchingState.MEMBERSHIP_UNKNOWN_UNSUPPORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MembershipMatchingState.UNRECOGNIZED;
  }
}

export function membershipMatchingStateToJSON(object: MembershipMatchingState): string {
  switch (object) {
    case MembershipMatchingState.MEMBERSHIP_MATCHING_STATE_UNSPECIFIED:
      return "MEMBERSHIP_MATCHING_STATE_UNSPECIFIED";
    case MembershipMatchingState.MEMBERSHIP_MATCHED:
      return "MEMBERSHIP_MATCHED";
    case MembershipMatchingState.MEMBERSHIP_NOT_MATCHED:
      return "MEMBERSHIP_NOT_MATCHED";
    case MembershipMatchingState.MEMBERSHIP_UNKNOWN_INFO:
      return "MEMBERSHIP_UNKNOWN_INFO";
    case MembershipMatchingState.MEMBERSHIP_UNKNOWN_UNSUPPORTED:
      return "MEMBERSHIP_UNKNOWN_UNSUPPORTED";
    case MembershipMatchingState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The extent to which a single data point contributes to an overall
 * determination.
 */
export enum HeuristicRelevance {
  /** HEURISTIC_RELEVANCE_UNSPECIFIED - Not specified. */
  HEURISTIC_RELEVANCE_UNSPECIFIED = 0,
  /**
   * HEURISTIC_RELEVANCE_NORMAL - The data point has a limited effect on the result. Changing the data point
   * is unlikely to affect the overall determination.
   */
  HEURISTIC_RELEVANCE_NORMAL = 1,
  /**
   * HEURISTIC_RELEVANCE_HIGH - The data point has a strong effect on the result. Changing the data point
   * is likely to affect the overall determination.
   */
  HEURISTIC_RELEVANCE_HIGH = 2,
  UNRECOGNIZED = -1,
}

export function heuristicRelevanceFromJSON(object: any): HeuristicRelevance {
  switch (object) {
    case 0:
    case "HEURISTIC_RELEVANCE_UNSPECIFIED":
      return HeuristicRelevance.HEURISTIC_RELEVANCE_UNSPECIFIED;
    case 1:
    case "HEURISTIC_RELEVANCE_NORMAL":
      return HeuristicRelevance.HEURISTIC_RELEVANCE_NORMAL;
    case 2:
    case "HEURISTIC_RELEVANCE_HIGH":
      return HeuristicRelevance.HEURISTIC_RELEVANCE_HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HeuristicRelevance.UNRECOGNIZED;
  }
}

export function heuristicRelevanceToJSON(object: HeuristicRelevance): string {
  switch (object) {
    case HeuristicRelevance.HEURISTIC_RELEVANCE_UNSPECIFIED:
      return "HEURISTIC_RELEVANCE_UNSPECIFIED";
    case HeuristicRelevance.HEURISTIC_RELEVANCE_NORMAL:
      return "HEURISTIC_RELEVANCE_NORMAL";
    case HeuristicRelevance.HEURISTIC_RELEVANCE_HIGH:
      return "HEURISTIC_RELEVANCE_HIGH";
    case HeuristicRelevance.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Request for
 * [TroubleshootIamPolicy][google.cloud.policytroubleshooter.iam.v3beta.PolicyTroubleshooter.TroubleshootIamPolicy].
 */
export interface TroubleshootIamPolicyRequest {
  /**
   * The information to use for checking whether a principal has a permission
   * for a resource.
   */
  accessTuple: AccessTuple | undefined;
}

/**
 * Response for
 * [TroubleshootIamPolicy][google.cloud.policytroubleshooter.iam.v3beta.PolicyTroubleshooter.TroubleshootIamPolicy].
 */
export interface TroubleshootIamPolicyResponse {
  /**
   * Indicates whether the principal has the specified permission for the
   * specified resource, based on evaluating all types of the applicable IAM
   * policies.
   */
  overallAccessState: TroubleshootIamPolicyResponse_OverallAccessState;
  /**
   * The access tuple from the request, including any provided context used to
   * evaluate the condition.
   */
  accessTuple:
    | AccessTuple
    | undefined;
  /**
   * An explanation of how the applicable IAM allow policies affect the final
   * access state.
   */
  allowPolicyExplanation:
    | AllowPolicyExplanation
    | undefined;
  /**
   * An explanation of how the applicable IAM deny policies affect the final
   * access state.
   */
  denyPolicyExplanation: DenyPolicyExplanation | undefined;
}

/** Whether the principal has the permission on the resource. */
export enum TroubleshootIamPolicyResponse_OverallAccessState {
  /** OVERALL_ACCESS_STATE_UNSPECIFIED - Not specified. */
  OVERALL_ACCESS_STATE_UNSPECIFIED = 0,
  /** CAN_ACCESS - The principal has the permission. */
  CAN_ACCESS = 1,
  /** CANNOT_ACCESS - The principal doesn't have the permission. */
  CANNOT_ACCESS = 2,
  /**
   * UNKNOWN_INFO - The principal might have the permission, but the sender can't access all
   * of the information needed to fully evaluate the principal's access.
   */
  UNKNOWN_INFO = 3,
  /**
   * UNKNOWN_CONDITIONAL - The principal might have the permission, but Policy Troubleshooter can't
   * fully evaluate the principal's access because the sender didn't provide
   * the required context to evaluate the condition.
   */
  UNKNOWN_CONDITIONAL = 4,
  UNRECOGNIZED = -1,
}

export function troubleshootIamPolicyResponse_OverallAccessStateFromJSON(
  object: any,
): TroubleshootIamPolicyResponse_OverallAccessState {
  switch (object) {
    case 0:
    case "OVERALL_ACCESS_STATE_UNSPECIFIED":
      return TroubleshootIamPolicyResponse_OverallAccessState.OVERALL_ACCESS_STATE_UNSPECIFIED;
    case 1:
    case "CAN_ACCESS":
      return TroubleshootIamPolicyResponse_OverallAccessState.CAN_ACCESS;
    case 2:
    case "CANNOT_ACCESS":
      return TroubleshootIamPolicyResponse_OverallAccessState.CANNOT_ACCESS;
    case 3:
    case "UNKNOWN_INFO":
      return TroubleshootIamPolicyResponse_OverallAccessState.UNKNOWN_INFO;
    case 4:
    case "UNKNOWN_CONDITIONAL":
      return TroubleshootIamPolicyResponse_OverallAccessState.UNKNOWN_CONDITIONAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TroubleshootIamPolicyResponse_OverallAccessState.UNRECOGNIZED;
  }
}

export function troubleshootIamPolicyResponse_OverallAccessStateToJSON(
  object: TroubleshootIamPolicyResponse_OverallAccessState,
): string {
  switch (object) {
    case TroubleshootIamPolicyResponse_OverallAccessState.OVERALL_ACCESS_STATE_UNSPECIFIED:
      return "OVERALL_ACCESS_STATE_UNSPECIFIED";
    case TroubleshootIamPolicyResponse_OverallAccessState.CAN_ACCESS:
      return "CAN_ACCESS";
    case TroubleshootIamPolicyResponse_OverallAccessState.CANNOT_ACCESS:
      return "CANNOT_ACCESS";
    case TroubleshootIamPolicyResponse_OverallAccessState.UNKNOWN_INFO:
      return "UNKNOWN_INFO";
    case TroubleshootIamPolicyResponse_OverallAccessState.UNKNOWN_CONDITIONAL:
      return "UNKNOWN_CONDITIONAL";
    case TroubleshootIamPolicyResponse_OverallAccessState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about the principal, resource, and permission to check. */
export interface AccessTuple {
  /**
   * Required. The email address of the principal whose access you want to
   * check. For example, `alice@example.com` or
   * `my-service-account@my-project.iam.gserviceaccount.com`.
   *
   * The principal must be a Google Account or a service account. Other types of
   * principals are not supported.
   */
  principal: string;
  /**
   * Required. The full resource name that identifies the resource. For example,
   * `//compute.googleapis.com/projects/my-project/zones/us-central1-a/instances/my-instance`.
   *
   * For examples of full resource names for Google Cloud services, see
   * https://cloud.google.com/iam/help/troubleshooter/full-resource-names.
   */
  fullResourceName: string;
  /**
   * Required. The IAM permission to check for, either in the `v1` permission
   * format or the `v2` permission format.
   *
   * For a complete list of IAM permissions in the `v1` format, see
   * https://cloud.google.com/iam/help/permissions/reference.
   *
   * For a list of IAM permissions in the `v2` format, see
   * https://cloud.google.com/iam/help/deny/supported-permissions.
   *
   * For a complete list of predefined IAM roles and the permissions in each
   * role, see https://cloud.google.com/iam/help/roles/reference.
   */
  permission: string;
  /**
   * Output only. The permission that Policy Troubleshooter checked for, in
   * the `v2` format.
   */
  permissionFqdn: string;
  /**
   * Optional. Additional context for the request, such as the request time or
   * IP address. This context allows Policy Troubleshooter to troubleshoot
   * conditional role bindings and deny rules.
   */
  conditionContext: ConditionContext | undefined;
}

/**
 * Additional context for troubleshooting conditional role bindings and deny
 * rules.
 */
export interface ConditionContext {
  /**
   * Represents a target resource that is involved with a network activity.
   * If multiple resources are involved with an activity, this must be the
   * primary one.
   */
  resource:
    | ConditionContext_Resource
    | undefined;
  /**
   * The destination of a network activity, such as accepting a TCP connection.
   * In a multi-hop network activity, the destination represents the receiver of
   * the last hop.
   */
  destination:
    | ConditionContext_Peer
    | undefined;
  /** Represents a network request, such as an HTTP request. */
  request:
    | ConditionContext_Request
    | undefined;
  /**
   * Output only. The effective tags on the resource. The effective tags are
   * fetched during troubleshooting.
   */
  effectiveTags: ConditionContext_EffectiveTag[];
}

/**
 * Core attributes for a resource. A resource is an
 * addressable (named) entity provided by the destination service. For
 * example, a Compute Engine instance.
 */
export interface ConditionContext_Resource {
  /**
   * The name of the service that this resource belongs to, such as
   * `compute.googleapis.com`. The service name might not match the DNS
   * hostname that actually serves the request.
   *
   * For a full list of resource service values, see
   * https://cloud.google.com/iam/help/conditions/resource-services
   */
  service: string;
  /**
   * The stable identifier (name) of a resource on the `service`. A resource
   * can be logically identified as `//{resource.service}/{resource.name}`.
   * Unlike the resource URI, the resource name doesn't contain any protocol
   * and version information.
   *
   * For a list of full resource name formats, see
   * https://cloud.google.com/iam/help/troubleshooter/full-resource-names
   */
  name: string;
  /**
   * The type of the resource, in the format `{service}/{kind}`.
   *
   * For a full list of resource type values, see
   * https://cloud.google.com/iam/help/conditions/resource-types
   */
  type: string;
}

/**
 * This message defines attributes for a node that handles a network request.
 * The node can be either a service or an application that sends, forwards,
 * or receives the request. Service peers should fill in
 * `principal` and `labels` as appropriate.
 */
export interface ConditionContext_Peer {
  /** The IPv4 or IPv6 address of the peer. */
  ip: string;
  /** The network port of the peer. */
  port: Long;
}

/**
 * This message defines attributes for an HTTP request. If the actual
 * request is not an HTTP request, the runtime system should try to map
 * the actual request to an equivalent HTTP request.
 */
export interface ConditionContext_Request {
  /**
   * Optional. The timestamp when the destination service receives the first
   * byte of the request.
   */
  receiveTime: Date | undefined;
}

/**
 * A tag that applies to a resource during policy evaluation. Tags can be
 * either directly bound to a resource or inherited from its ancestor.
 * `EffectiveTag` contains the `name` and `namespaced_name` of the tag value
 * and tag key, with additional fields of `inherited` to indicate the
 * inheritance status of the effective tag.
 */
export interface ConditionContext_EffectiveTag {
  /** Output only. Resource name for TagValue in the format `tagValues/456`. */
  tagValue: string;
  /**
   * Output only. The namespaced name of the TagValue. Can be in the form
   * `{organization_id}/{tag_key_short_name}/{tag_value_short_name}` or
   * `{project_id}/{tag_key_short_name}/{tag_value_short_name}` or
   * `{project_number}/{tag_key_short_name}/{tag_value_short_name}`.
   */
  namespacedTagValue: string;
  /**
   * Output only. The name of the TagKey, in the format `tagKeys/{id}`, such
   * as `tagKeys/123`.
   */
  tagKey: string;
  /**
   * Output only. The namespaced name of the TagKey. Can be in the form
   * `{organization_id}/{tag_key_short_name}` or
   * `{project_id}/{tag_key_short_name}` or
   * `{project_number}/{tag_key_short_name}`.
   */
  namespacedTagKey: string;
  /**
   * The parent name of the tag key.
   * Must be in the format `organizations/{organization_id}` or
   * `projects/{project_number}`
   */
  tagKeyParentName: string;
  /**
   * Output only. Indicates the inheritance status of a tag value
   * attached to the given resource. If the tag value is inherited from one of
   * the resource's ancestors, inherited will be true. If false, then the tag
   * value is directly attached to the resource, inherited will be false.
   */
  inherited: boolean;
}

/**
 * Details about how the relevant IAM allow policies affect the final access
 * state.
 */
export interface AllowPolicyExplanation {
  /**
   * Indicates whether the principal has the specified permission for the
   * specified resource, based on evaluating all applicable IAM allow policies.
   */
  allowAccessState: AllowAccessState;
  /**
   * List of IAM allow policies that were evaluated to check the principal's
   * permissions, with annotations to indicate how each policy contributed to
   * the final result.
   *
   * The list of policies includes the policy for the resource itself, as well
   * as allow policies that are inherited from higher levels of the resource
   * hierarchy, including the organization, the folder, and the project.
   *
   * To learn more about the resource hierarchy, see
   * https://cloud.google.com/iam/help/resource-hierarchy.
   */
  explainedPolicies: ExplainedAllowPolicy[];
  /** The relevance of the allow policy type to the overall access state. */
  relevance: HeuristicRelevance;
}

/**
 * Details about how a specific IAM allow policy contributed to the final access
 * state.
 */
export interface ExplainedAllowPolicy {
  /**
   * Required. Indicates whether _this policy_ provides the specified permission
   * to the specified principal for the specified resource.
   *
   * This field does _not_ indicate whether the principal actually has the
   * permission for the resource. There might be another policy that overrides
   * this policy. To determine whether the principal actually has the
   * permission, use the `overall_access_state` field in the
   * [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3beta.TroubleshootIamPolicyResponse].
   */
  allowAccessState: AllowAccessState;
  /**
   * The full resource name that identifies the resource. For example,
   * `//compute.googleapis.com/projects/my-project/zones/us-central1-a/instances/my-instance`.
   *
   * If the sender of the request does not have access to the policy, this field
   * is omitted.
   *
   * For examples of full resource names for Google Cloud services, see
   * https://cloud.google.com/iam/help/troubleshooter/full-resource-names.
   */
  fullResourceName: string;
  /**
   * Details about how each role binding in the policy affects the principal's
   * ability, or inability, to use the permission for the resource. The order of
   * the role bindings matches the role binding order in the policy.
   *
   * If the sender of the request does not have access to the policy, this field
   * is omitted.
   */
  bindingExplanations: AllowBindingExplanation[];
  /**
   * The relevance of this policy to the overall access state in the
   * [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3beta.TroubleshootIamPolicyResponse].
   *
   * If the sender of the request does not have access to the policy, this field
   * is omitted.
   */
  relevance: HeuristicRelevance;
  /**
   * The IAM allow policy attached to the resource.
   *
   * If the sender of the request does not have access to the policy, this field
   * is empty.
   */
  policy: Policy | undefined;
}

/**
 * Details about how a role binding in an allow policy affects a principal's
 * ability to use a permission.
 */
export interface AllowBindingExplanation {
  /**
   * Required. Indicates whether _this role binding_ gives the specified
   * permission to the specified principal on the specified resource.
   *
   * This field does _not_ indicate whether the principal actually has the
   * permission on the resource. There might be another role binding that
   * overrides this role binding. To determine whether the principal actually
   * has the permission, use the `overall_access_state` field in the
   * [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3beta.TroubleshootIamPolicyResponse].
   */
  allowAccessState: AllowAccessState;
  /**
   * The role that this role binding grants. For example,
   * `roles/compute.admin`.
   *
   * For a complete list of predefined IAM roles, as well as the permissions in
   * each role, see https://cloud.google.com/iam/help/roles/reference.
   */
  role: string;
  /**
   * Indicates whether the role granted by this role binding contains the
   * specified permission.
   */
  rolePermission: RolePermissionInclusionState;
  /**
   * The relevance of the permission's existence, or nonexistence, in the role
   * to the overall determination for the entire policy.
   */
  rolePermissionRelevance: HeuristicRelevance;
  /**
   * The combined result of all memberships. Indicates if the principal is
   * included in any role binding, either directly or indirectly.
   */
  combinedMembership:
    | AllowBindingExplanation_AnnotatedAllowMembership
    | undefined;
  /**
   * Indicates whether each role binding includes the principal specified in the
   * request, either directly or indirectly. Each key identifies a principal in
   * the role binding, and each value indicates whether the principal in the
   * role binding includes the principal in the request.
   *
   * For example, suppose that a role binding includes the following principals:
   *
   * * `user:alice@example.com`
   * * `group:product-eng@example.com`
   *
   * You want to troubleshoot access for `user:bob@example.com`. This user is a
   * member of the group `group:product-eng@example.com`.
   *
   * For the first principal in the role binding, the key is
   * `user:alice@example.com`, and the `membership` field in the value is set to
   * `NOT_INCLUDED`.
   *
   * For the second principal in the role binding, the key is
   * `group:product-eng@example.com`, and the `membership` field in the value is
   * set to `INCLUDED`.
   */
  memberships: { [key: string]: AllowBindingExplanation_AnnotatedAllowMembership };
  /**
   * The relevance of this role binding to the overall determination for the
   * entire policy.
   */
  relevance: HeuristicRelevance;
  /**
   * A condition expression that specifies when the role binding grants access.
   *
   * To learn about IAM Conditions, see
   * https://cloud.google.com/iam/help/conditions/overview.
   */
  condition:
    | Expr
    | undefined;
  /** Condition evaluation state for this role binding. */
  conditionExplanation: ConditionExplanation | undefined;
}

/** Details about whether the role binding includes the principal. */
export interface AllowBindingExplanation_AnnotatedAllowMembership {
  /** Indicates whether the role binding includes the principal. */
  membership: MembershipMatchingState;
  /**
   * The relevance of the principal's status to the overall determination for
   * the role binding.
   */
  relevance: HeuristicRelevance;
}

export interface AllowBindingExplanation_MembershipsEntry {
  key: string;
  value: AllowBindingExplanation_AnnotatedAllowMembership | undefined;
}

/**
 * Details about how the relevant IAM deny policies affect the final access
 * state.
 */
export interface DenyPolicyExplanation {
  /**
   * Indicates whether the principal is denied the specified permission for
   * the specified resource, based on evaluating all applicable IAM deny
   * policies.
   */
  denyAccessState: DenyAccessState;
  /**
   * List of resources with IAM deny policies that were evaluated to check the
   * principal's denied permissions, with annotations to indicate how each
   * policy contributed to the final result.
   *
   * The list of resources includes the policy for the resource itself, as well
   * as policies that are inherited from higher levels of the resource
   * hierarchy, including the organization, the folder, and the project. The
   * order of the resources starts from the resource and climbs up the resource
   * hierarchy.
   *
   * To learn more about the resource hierarchy, see
   * https://cloud.google.com/iam/help/resource-hierarchy.
   */
  explainedResources: ExplainedDenyResource[];
  /** The relevance of the deny policy result to the overall access state. */
  relevance: HeuristicRelevance;
  /**
   * Indicates whether the permission to troubleshoot is supported in deny
   * policies.
   */
  permissionDeniable: boolean;
}

/**
 * Details about how a specific resource contributed to the deny policy
 * evaluation.
 */
export interface ExplainedDenyResource {
  /**
   * Required. Indicates whether any policies attached to _this resource_ deny
   * the specific permission to the specified principal for the specified
   * resource.
   *
   * This field does _not_ indicate whether the principal actually has the
   * permission for the resource. There might be another policy that overrides
   * this policy. To determine whether the principal actually has the
   * permission, use the `overall_access_state` field in the
   * [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3beta.TroubleshootIamPolicyResponse].
   */
  denyAccessState: DenyAccessState;
  /**
   * The full resource name that identifies the resource. For example,
   * `//compute.googleapis.com/projects/my-project/zones/us-central1-a/instances/my-instance`.
   *
   * If the sender of the request does not have access to the policy, this field
   * is omitted.
   *
   * For examples of full resource names for Google Cloud services, see
   * https://cloud.google.com/iam/help/troubleshooter/full-resource-names.
   */
  fullResourceName: string;
  /**
   * List of IAM deny policies that were evaluated to check the principal's
   * denied permissions, with annotations to indicate how each policy
   * contributed to the final result.
   */
  explainedPolicies: ExplainedDenyPolicy[];
  /**
   * The relevance of this policy to the overall access state in the
   * [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3beta.TroubleshootIamPolicyResponse].
   *
   * If the sender of the request does not have access to the policy, this field
   * is omitted.
   */
  relevance: HeuristicRelevance;
}

/**
 * Details about how a specific IAM deny policy [Policy][google.iam.v2.Policy]
 * contributed to the access check.
 */
export interface ExplainedDenyPolicy {
  /**
   * Required. Indicates whether _this policy_ denies the specified permission
   * to the specified principal for the specified resource.
   *
   * This field does _not_ indicate whether the principal actually has the
   * permission for the resource. There might be another policy that overrides
   * this policy. To determine whether the principal actually has the
   * permission, use the `overall_access_state` field in the
   * [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3beta.TroubleshootIamPolicyResponse].
   */
  denyAccessState: DenyAccessState;
  /**
   * The IAM deny policy attached to the resource.
   *
   * If the sender of the request does not have access to the policy, this field
   * is omitted.
   */
  policy:
    | Policy1
    | undefined;
  /**
   * Details about how each rule in the policy affects the principal's inability
   * to use the permission for the resource. The order of the deny rule matches
   * the order of the rules in the deny policy.
   *
   * If the sender of the request does not have access to the policy, this field
   * is omitted.
   */
  ruleExplanations: DenyRuleExplanation[];
  /**
   * The relevance of this policy to the overall access state in the
   * [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3beta.TroubleshootIamPolicyResponse].
   *
   * If the sender of the request does not have access to the policy, this field
   * is omitted.
   */
  relevance: HeuristicRelevance;
}

/**
 * Details about how a deny rule in a deny policy affects a principal's ability
 * to use a permission.
 */
export interface DenyRuleExplanation {
  /**
   * Required. Indicates whether _this rule_ denies the specified permission to
   * the specified principal for the specified resource.
   *
   * This field does _not_ indicate whether the principal is actually denied on
   * the permission for the resource. There might be another rule that overrides
   * this rule. To determine whether the principal actually has the permission,
   * use the `overall_access_state` field in the
   * [TroubleshootIamPolicyResponse][google.cloud.policytroubleshooter.iam.v3beta.TroubleshootIamPolicyResponse].
   */
  denyAccessState: DenyAccessState;
  /**
   * Indicates whether the permission in the request is listed as a denied
   * permission in the deny rule.
   */
  combinedDeniedPermission:
    | DenyRuleExplanation_AnnotatedPermissionMatching
    | undefined;
  /**
   * Lists all denied permissions in the deny rule and indicates whether each
   * permission matches the permission in the request.
   *
   * Each key identifies a denied permission in the rule, and each value
   * indicates whether the denied permission matches the permission in the
   * request.
   */
  deniedPermissions: { [key: string]: DenyRuleExplanation_AnnotatedPermissionMatching };
  /**
   * Indicates whether the permission in the request is listed as an exception
   * permission in the deny rule.
   */
  combinedExceptionPermission:
    | DenyRuleExplanation_AnnotatedPermissionMatching
    | undefined;
  /**
   * Lists all exception permissions in the deny rule and indicates whether each
   * permission matches the permission in the request.
   *
   * Each key identifies a exception permission in the rule, and each value
   * indicates whether the exception permission matches the permission in the
   * request.
   */
  exceptionPermissions: { [key: string]: DenyRuleExplanation_AnnotatedPermissionMatching };
  /**
   * Indicates whether the principal is listed as a denied principal in the
   * deny rule, either directly or through membership in a principal set.
   */
  combinedDeniedPrincipal:
    | DenyRuleExplanation_AnnotatedDenyPrincipalMatching
    | undefined;
  /**
   * Lists all denied principals in the deny rule and indicates whether each
   * principal matches the principal in the request, either directly or through
   * membership in a principal set.
   *
   * Each key identifies a denied principal in the rule, and each value
   * indicates whether the denied principal matches the principal in the
   * request.
   */
  deniedPrincipals: { [key: string]: DenyRuleExplanation_AnnotatedDenyPrincipalMatching };
  /**
   * Indicates whether the principal is listed as an exception principal in the
   * deny rule, either directly or through membership in a principal set.
   */
  combinedExceptionPrincipal:
    | DenyRuleExplanation_AnnotatedDenyPrincipalMatching
    | undefined;
  /**
   * Lists all exception principals in the deny rule and indicates whether each
   * principal matches the principal in the request, either directly or through
   * membership in a principal set.
   *
   * Each key identifies a exception principal in the rule, and each value
   * indicates whether the exception principal matches the principal in the
   * request.
   */
  exceptionPrincipals: { [key: string]: DenyRuleExplanation_AnnotatedDenyPrincipalMatching };
  /**
   * The relevance of this role binding to the overall determination for the
   * entire policy.
   */
  relevance: HeuristicRelevance;
  /**
   * A condition expression that specifies when the deny rule denies the
   * principal access.
   *
   * To learn about IAM Conditions, see
   * https://cloud.google.com/iam/help/conditions/overview.
   */
  condition:
    | Expr
    | undefined;
  /** Condition evaluation state for this role binding. */
  conditionExplanation: ConditionExplanation | undefined;
}

/**
 * Details about whether the permission in the request is denied by the
 * deny rule.
 */
export interface DenyRuleExplanation_AnnotatedPermissionMatching {
  /**
   * Indicates whether the permission in the request is denied by the deny
   * rule.
   */
  permissionMatchingState: PermissionPatternMatchingState;
  /**
   * The relevance of the permission status to the overall determination for
   * the rule.
   */
  relevance: HeuristicRelevance;
}

/**
 * Details about whether the principal in the request is listed as a denied
 * principal in the deny rule, either directly or through membership in a
 * principal set.
 */
export interface DenyRuleExplanation_AnnotatedDenyPrincipalMatching {
  /**
   * Indicates whether the principal is listed as a denied principal in the
   * deny rule, either directly or through membership in a principal set.
   */
  membership: MembershipMatchingState;
  /**
   * The relevance of the principal's status to the overall determination for
   * the role binding.
   */
  relevance: HeuristicRelevance;
}

export interface DenyRuleExplanation_DeniedPermissionsEntry {
  key: string;
  value: DenyRuleExplanation_AnnotatedPermissionMatching | undefined;
}

export interface DenyRuleExplanation_ExceptionPermissionsEntry {
  key: string;
  value: DenyRuleExplanation_AnnotatedPermissionMatching | undefined;
}

export interface DenyRuleExplanation_DeniedPrincipalsEntry {
  key: string;
  value: DenyRuleExplanation_AnnotatedDenyPrincipalMatching | undefined;
}

export interface DenyRuleExplanation_ExceptionPrincipalsEntry {
  key: string;
  value: DenyRuleExplanation_AnnotatedDenyPrincipalMatching | undefined;
}

/** Explanation for how a condition affects a principal's access */
export interface ConditionExplanation {
  /** Value of the condition. */
  value:
    | any
    | undefined;
  /** Any errors that prevented complete evaluation of the condition expression. */
  errors: Status[];
  /**
   * The value of each statement of the condition expression. The value can be
   * `true`, `false`, or `null`. The value is `null` if the statement can't be
   * evaluated.
   */
  evaluationStates: ConditionExplanation_EvaluationState[];
}

/** Evaluated state of a condition expression. */
export interface ConditionExplanation_EvaluationState {
  /** Start position of an expression in the condition, by character. */
  start: number;
  /**
   * End position of an expression in the condition, by character,
   * end included, for example: the end position of the first part of
   * `a==b || c==d` would be 4.
   */
  end: number;
  /** Value of this expression. */
  value:
    | any
    | undefined;
  /**
   * Any errors that prevented complete evaluation of the condition
   * expression.
   */
  errors: Status[];
}

function createBaseTroubleshootIamPolicyRequest(): TroubleshootIamPolicyRequest {
  return { accessTuple: undefined };
}

export const TroubleshootIamPolicyRequest: MessageFns<TroubleshootIamPolicyRequest> = {
  encode(message: TroubleshootIamPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessTuple !== undefined) {
      AccessTuple.encode(message.accessTuple, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TroubleshootIamPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTroubleshootIamPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessTuple = AccessTuple.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TroubleshootIamPolicyRequest {
    return { accessTuple: isSet(object.accessTuple) ? AccessTuple.fromJSON(object.accessTuple) : undefined };
  },

  toJSON(message: TroubleshootIamPolicyRequest): unknown {
    const obj: any = {};
    if (message.accessTuple !== undefined) {
      obj.accessTuple = AccessTuple.toJSON(message.accessTuple);
    }
    return obj;
  },

  create(base?: DeepPartial<TroubleshootIamPolicyRequest>): TroubleshootIamPolicyRequest {
    return TroubleshootIamPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TroubleshootIamPolicyRequest>): TroubleshootIamPolicyRequest {
    const message = createBaseTroubleshootIamPolicyRequest();
    message.accessTuple = (object.accessTuple !== undefined && object.accessTuple !== null)
      ? AccessTuple.fromPartial(object.accessTuple)
      : undefined;
    return message;
  },
};

function createBaseTroubleshootIamPolicyResponse(): TroubleshootIamPolicyResponse {
  return {
    overallAccessState: 0,
    accessTuple: undefined,
    allowPolicyExplanation: undefined,
    denyPolicyExplanation: undefined,
  };
}

export const TroubleshootIamPolicyResponse: MessageFns<TroubleshootIamPolicyResponse> = {
  encode(message: TroubleshootIamPolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overallAccessState !== 0) {
      writer.uint32(8).int32(message.overallAccessState);
    }
    if (message.accessTuple !== undefined) {
      AccessTuple.encode(message.accessTuple, writer.uint32(18).fork()).join();
    }
    if (message.allowPolicyExplanation !== undefined) {
      AllowPolicyExplanation.encode(message.allowPolicyExplanation, writer.uint32(26).fork()).join();
    }
    if (message.denyPolicyExplanation !== undefined) {
      DenyPolicyExplanation.encode(message.denyPolicyExplanation, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TroubleshootIamPolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTroubleshootIamPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.overallAccessState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessTuple = AccessTuple.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.allowPolicyExplanation = AllowPolicyExplanation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.denyPolicyExplanation = DenyPolicyExplanation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TroubleshootIamPolicyResponse {
    return {
      overallAccessState: isSet(object.overallAccessState)
        ? troubleshootIamPolicyResponse_OverallAccessStateFromJSON(object.overallAccessState)
        : 0,
      accessTuple: isSet(object.accessTuple) ? AccessTuple.fromJSON(object.accessTuple) : undefined,
      allowPolicyExplanation: isSet(object.allowPolicyExplanation)
        ? AllowPolicyExplanation.fromJSON(object.allowPolicyExplanation)
        : undefined,
      denyPolicyExplanation: isSet(object.denyPolicyExplanation)
        ? DenyPolicyExplanation.fromJSON(object.denyPolicyExplanation)
        : undefined,
    };
  },

  toJSON(message: TroubleshootIamPolicyResponse): unknown {
    const obj: any = {};
    if (message.overallAccessState !== 0) {
      obj.overallAccessState = troubleshootIamPolicyResponse_OverallAccessStateToJSON(message.overallAccessState);
    }
    if (message.accessTuple !== undefined) {
      obj.accessTuple = AccessTuple.toJSON(message.accessTuple);
    }
    if (message.allowPolicyExplanation !== undefined) {
      obj.allowPolicyExplanation = AllowPolicyExplanation.toJSON(message.allowPolicyExplanation);
    }
    if (message.denyPolicyExplanation !== undefined) {
      obj.denyPolicyExplanation = DenyPolicyExplanation.toJSON(message.denyPolicyExplanation);
    }
    return obj;
  },

  create(base?: DeepPartial<TroubleshootIamPolicyResponse>): TroubleshootIamPolicyResponse {
    return TroubleshootIamPolicyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TroubleshootIamPolicyResponse>): TroubleshootIamPolicyResponse {
    const message = createBaseTroubleshootIamPolicyResponse();
    message.overallAccessState = object.overallAccessState ?? 0;
    message.accessTuple = (object.accessTuple !== undefined && object.accessTuple !== null)
      ? AccessTuple.fromPartial(object.accessTuple)
      : undefined;
    message.allowPolicyExplanation =
      (object.allowPolicyExplanation !== undefined && object.allowPolicyExplanation !== null)
        ? AllowPolicyExplanation.fromPartial(object.allowPolicyExplanation)
        : undefined;
    message.denyPolicyExplanation =
      (object.denyPolicyExplanation !== undefined && object.denyPolicyExplanation !== null)
        ? DenyPolicyExplanation.fromPartial(object.denyPolicyExplanation)
        : undefined;
    return message;
  },
};

function createBaseAccessTuple(): AccessTuple {
  return { principal: "", fullResourceName: "", permission: "", permissionFqdn: "", conditionContext: undefined };
}

export const AccessTuple: MessageFns<AccessTuple> = {
  encode(message: AccessTuple, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.principal !== "") {
      writer.uint32(10).string(message.principal);
    }
    if (message.fullResourceName !== "") {
      writer.uint32(18).string(message.fullResourceName);
    }
    if (message.permission !== "") {
      writer.uint32(26).string(message.permission);
    }
    if (message.permissionFqdn !== "") {
      writer.uint32(34).string(message.permissionFqdn);
    }
    if (message.conditionContext !== undefined) {
      ConditionContext.encode(message.conditionContext, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessTuple {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessTuple();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.principal = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fullResourceName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.permission = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.permissionFqdn = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.conditionContext = ConditionContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessTuple {
    return {
      principal: isSet(object.principal) ? globalThis.String(object.principal) : "",
      fullResourceName: isSet(object.fullResourceName) ? globalThis.String(object.fullResourceName) : "",
      permission: isSet(object.permission) ? globalThis.String(object.permission) : "",
      permissionFqdn: isSet(object.permissionFqdn) ? globalThis.String(object.permissionFqdn) : "",
      conditionContext: isSet(object.conditionContext) ? ConditionContext.fromJSON(object.conditionContext) : undefined,
    };
  },

  toJSON(message: AccessTuple): unknown {
    const obj: any = {};
    if (message.principal !== "") {
      obj.principal = message.principal;
    }
    if (message.fullResourceName !== "") {
      obj.fullResourceName = message.fullResourceName;
    }
    if (message.permission !== "") {
      obj.permission = message.permission;
    }
    if (message.permissionFqdn !== "") {
      obj.permissionFqdn = message.permissionFqdn;
    }
    if (message.conditionContext !== undefined) {
      obj.conditionContext = ConditionContext.toJSON(message.conditionContext);
    }
    return obj;
  },

  create(base?: DeepPartial<AccessTuple>): AccessTuple {
    return AccessTuple.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessTuple>): AccessTuple {
    const message = createBaseAccessTuple();
    message.principal = object.principal ?? "";
    message.fullResourceName = object.fullResourceName ?? "";
    message.permission = object.permission ?? "";
    message.permissionFqdn = object.permissionFqdn ?? "";
    message.conditionContext = (object.conditionContext !== undefined && object.conditionContext !== null)
      ? ConditionContext.fromPartial(object.conditionContext)
      : undefined;
    return message;
  },
};

function createBaseConditionContext(): ConditionContext {
  return { resource: undefined, destination: undefined, request: undefined, effectiveTags: [] };
}

export const ConditionContext: MessageFns<ConditionContext> = {
  encode(message: ConditionContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== undefined) {
      ConditionContext_Resource.encode(message.resource, writer.uint32(10).fork()).join();
    }
    if (message.destination !== undefined) {
      ConditionContext_Peer.encode(message.destination, writer.uint32(18).fork()).join();
    }
    if (message.request !== undefined) {
      ConditionContext_Request.encode(message.request, writer.uint32(26).fork()).join();
    }
    for (const v of message.effectiveTags) {
      ConditionContext_EffectiveTag.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = ConditionContext_Resource.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destination = ConditionContext_Peer.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.request = ConditionContext_Request.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.effectiveTags.push(ConditionContext_EffectiveTag.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConditionContext {
    return {
      resource: isSet(object.resource) ? ConditionContext_Resource.fromJSON(object.resource) : undefined,
      destination: isSet(object.destination) ? ConditionContext_Peer.fromJSON(object.destination) : undefined,
      request: isSet(object.request) ? ConditionContext_Request.fromJSON(object.request) : undefined,
      effectiveTags: globalThis.Array.isArray(object?.effectiveTags)
        ? object.effectiveTags.map((e: any) => ConditionContext_EffectiveTag.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ConditionContext): unknown {
    const obj: any = {};
    if (message.resource !== undefined) {
      obj.resource = ConditionContext_Resource.toJSON(message.resource);
    }
    if (message.destination !== undefined) {
      obj.destination = ConditionContext_Peer.toJSON(message.destination);
    }
    if (message.request !== undefined) {
      obj.request = ConditionContext_Request.toJSON(message.request);
    }
    if (message.effectiveTags?.length) {
      obj.effectiveTags = message.effectiveTags.map((e) => ConditionContext_EffectiveTag.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ConditionContext>): ConditionContext {
    return ConditionContext.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConditionContext>): ConditionContext {
    const message = createBaseConditionContext();
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? ConditionContext_Resource.fromPartial(object.resource)
      : undefined;
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? ConditionContext_Peer.fromPartial(object.destination)
      : undefined;
    message.request = (object.request !== undefined && object.request !== null)
      ? ConditionContext_Request.fromPartial(object.request)
      : undefined;
    message.effectiveTags = object.effectiveTags?.map((e) => ConditionContext_EffectiveTag.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConditionContext_Resource(): ConditionContext_Resource {
  return { service: "", name: "", type: "" };
}

export const ConditionContext_Resource: MessageFns<ConditionContext_Resource> = {
  encode(message: ConditionContext_Resource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionContext_Resource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionContext_Resource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConditionContext_Resource {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: ConditionContext_Resource): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<ConditionContext_Resource>): ConditionContext_Resource {
    return ConditionContext_Resource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConditionContext_Resource>): ConditionContext_Resource {
    const message = createBaseConditionContext_Resource();
    message.service = object.service ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseConditionContext_Peer(): ConditionContext_Peer {
  return { ip: "", port: Long.ZERO };
}

export const ConditionContext_Peer: MessageFns<ConditionContext_Peer> = {
  encode(message: ConditionContext_Peer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ip !== "") {
      writer.uint32(10).string(message.ip);
    }
    if (!message.port.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.port.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionContext_Peer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionContext_Peer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConditionContext_Peer {
    return {
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      port: isSet(object.port) ? Long.fromValue(object.port) : Long.ZERO,
    };
  },

  toJSON(message: ConditionContext_Peer): unknown {
    const obj: any = {};
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (!message.port.equals(Long.ZERO)) {
      obj.port = (message.port || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ConditionContext_Peer>): ConditionContext_Peer {
    return ConditionContext_Peer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConditionContext_Peer>): ConditionContext_Peer {
    const message = createBaseConditionContext_Peer();
    message.ip = object.ip ?? "";
    message.port = (object.port !== undefined && object.port !== null) ? Long.fromValue(object.port) : Long.ZERO;
    return message;
  },
};

function createBaseConditionContext_Request(): ConditionContext_Request {
  return { receiveTime: undefined };
}

export const ConditionContext_Request: MessageFns<ConditionContext_Request> = {
  encode(message: ConditionContext_Request, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.receiveTime !== undefined) {
      Timestamp.encode(toTimestamp(message.receiveTime), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionContext_Request {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionContext_Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.receiveTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConditionContext_Request {
    return { receiveTime: isSet(object.receiveTime) ? fromJsonTimestamp(object.receiveTime) : undefined };
  },

  toJSON(message: ConditionContext_Request): unknown {
    const obj: any = {};
    if (message.receiveTime !== undefined) {
      obj.receiveTime = message.receiveTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ConditionContext_Request>): ConditionContext_Request {
    return ConditionContext_Request.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConditionContext_Request>): ConditionContext_Request {
    const message = createBaseConditionContext_Request();
    message.receiveTime = object.receiveTime ?? undefined;
    return message;
  },
};

function createBaseConditionContext_EffectiveTag(): ConditionContext_EffectiveTag {
  return {
    tagValue: "",
    namespacedTagValue: "",
    tagKey: "",
    namespacedTagKey: "",
    tagKeyParentName: "",
    inherited: false,
  };
}

export const ConditionContext_EffectiveTag: MessageFns<ConditionContext_EffectiveTag> = {
  encode(message: ConditionContext_EffectiveTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagValue !== "") {
      writer.uint32(10).string(message.tagValue);
    }
    if (message.namespacedTagValue !== "") {
      writer.uint32(18).string(message.namespacedTagValue);
    }
    if (message.tagKey !== "") {
      writer.uint32(26).string(message.tagKey);
    }
    if (message.namespacedTagKey !== "") {
      writer.uint32(34).string(message.namespacedTagKey);
    }
    if (message.tagKeyParentName !== "") {
      writer.uint32(50).string(message.tagKeyParentName);
    }
    if (message.inherited !== false) {
      writer.uint32(40).bool(message.inherited);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionContext_EffectiveTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionContext_EffectiveTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tagValue = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.namespacedTagValue = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tagKey = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.namespacedTagKey = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tagKeyParentName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.inherited = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConditionContext_EffectiveTag {
    return {
      tagValue: isSet(object.tagValue) ? globalThis.String(object.tagValue) : "",
      namespacedTagValue: isSet(object.namespacedTagValue) ? globalThis.String(object.namespacedTagValue) : "",
      tagKey: isSet(object.tagKey) ? globalThis.String(object.tagKey) : "",
      namespacedTagKey: isSet(object.namespacedTagKey) ? globalThis.String(object.namespacedTagKey) : "",
      tagKeyParentName: isSet(object.tagKeyParentName) ? globalThis.String(object.tagKeyParentName) : "",
      inherited: isSet(object.inherited) ? globalThis.Boolean(object.inherited) : false,
    };
  },

  toJSON(message: ConditionContext_EffectiveTag): unknown {
    const obj: any = {};
    if (message.tagValue !== "") {
      obj.tagValue = message.tagValue;
    }
    if (message.namespacedTagValue !== "") {
      obj.namespacedTagValue = message.namespacedTagValue;
    }
    if (message.tagKey !== "") {
      obj.tagKey = message.tagKey;
    }
    if (message.namespacedTagKey !== "") {
      obj.namespacedTagKey = message.namespacedTagKey;
    }
    if (message.tagKeyParentName !== "") {
      obj.tagKeyParentName = message.tagKeyParentName;
    }
    if (message.inherited !== false) {
      obj.inherited = message.inherited;
    }
    return obj;
  },

  create(base?: DeepPartial<ConditionContext_EffectiveTag>): ConditionContext_EffectiveTag {
    return ConditionContext_EffectiveTag.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConditionContext_EffectiveTag>): ConditionContext_EffectiveTag {
    const message = createBaseConditionContext_EffectiveTag();
    message.tagValue = object.tagValue ?? "";
    message.namespacedTagValue = object.namespacedTagValue ?? "";
    message.tagKey = object.tagKey ?? "";
    message.namespacedTagKey = object.namespacedTagKey ?? "";
    message.tagKeyParentName = object.tagKeyParentName ?? "";
    message.inherited = object.inherited ?? false;
    return message;
  },
};

function createBaseAllowPolicyExplanation(): AllowPolicyExplanation {
  return { allowAccessState: 0, explainedPolicies: [], relevance: 0 };
}

export const AllowPolicyExplanation: MessageFns<AllowPolicyExplanation> = {
  encode(message: AllowPolicyExplanation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowAccessState !== 0) {
      writer.uint32(8).int32(message.allowAccessState);
    }
    for (const v of message.explainedPolicies) {
      ExplainedAllowPolicy.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.relevance !== 0) {
      writer.uint32(24).int32(message.relevance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowPolicyExplanation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowPolicyExplanation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.allowAccessState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explainedPolicies.push(ExplainedAllowPolicy.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.relevance = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowPolicyExplanation {
    return {
      allowAccessState: isSet(object.allowAccessState) ? allowAccessStateFromJSON(object.allowAccessState) : 0,
      explainedPolicies: globalThis.Array.isArray(object?.explainedPolicies)
        ? object.explainedPolicies.map((e: any) => ExplainedAllowPolicy.fromJSON(e))
        : [],
      relevance: isSet(object.relevance) ? heuristicRelevanceFromJSON(object.relevance) : 0,
    };
  },

  toJSON(message: AllowPolicyExplanation): unknown {
    const obj: any = {};
    if (message.allowAccessState !== 0) {
      obj.allowAccessState = allowAccessStateToJSON(message.allowAccessState);
    }
    if (message.explainedPolicies?.length) {
      obj.explainedPolicies = message.explainedPolicies.map((e) => ExplainedAllowPolicy.toJSON(e));
    }
    if (message.relevance !== 0) {
      obj.relevance = heuristicRelevanceToJSON(message.relevance);
    }
    return obj;
  },

  create(base?: DeepPartial<AllowPolicyExplanation>): AllowPolicyExplanation {
    return AllowPolicyExplanation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AllowPolicyExplanation>): AllowPolicyExplanation {
    const message = createBaseAllowPolicyExplanation();
    message.allowAccessState = object.allowAccessState ?? 0;
    message.explainedPolicies = object.explainedPolicies?.map((e) => ExplainedAllowPolicy.fromPartial(e)) || [];
    message.relevance = object.relevance ?? 0;
    return message;
  },
};

function createBaseExplainedAllowPolicy(): ExplainedAllowPolicy {
  return { allowAccessState: 0, fullResourceName: "", bindingExplanations: [], relevance: 0, policy: undefined };
}

export const ExplainedAllowPolicy: MessageFns<ExplainedAllowPolicy> = {
  encode(message: ExplainedAllowPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowAccessState !== 0) {
      writer.uint32(8).int32(message.allowAccessState);
    }
    if (message.fullResourceName !== "") {
      writer.uint32(18).string(message.fullResourceName);
    }
    for (const v of message.bindingExplanations) {
      AllowBindingExplanation.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.relevance !== 0) {
      writer.uint32(32).int32(message.relevance);
    }
    if (message.policy !== undefined) {
      Policy.encode(message.policy, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExplainedAllowPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExplainedAllowPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.allowAccessState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fullResourceName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bindingExplanations.push(AllowBindingExplanation.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.relevance = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.policy = Policy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExplainedAllowPolicy {
    return {
      allowAccessState: isSet(object.allowAccessState) ? allowAccessStateFromJSON(object.allowAccessState) : 0,
      fullResourceName: isSet(object.fullResourceName) ? globalThis.String(object.fullResourceName) : "",
      bindingExplanations: globalThis.Array.isArray(object?.bindingExplanations)
        ? object.bindingExplanations.map((e: any) => AllowBindingExplanation.fromJSON(e))
        : [],
      relevance: isSet(object.relevance) ? heuristicRelevanceFromJSON(object.relevance) : 0,
      policy: isSet(object.policy) ? Policy.fromJSON(object.policy) : undefined,
    };
  },

  toJSON(message: ExplainedAllowPolicy): unknown {
    const obj: any = {};
    if (message.allowAccessState !== 0) {
      obj.allowAccessState = allowAccessStateToJSON(message.allowAccessState);
    }
    if (message.fullResourceName !== "") {
      obj.fullResourceName = message.fullResourceName;
    }
    if (message.bindingExplanations?.length) {
      obj.bindingExplanations = message.bindingExplanations.map((e) => AllowBindingExplanation.toJSON(e));
    }
    if (message.relevance !== 0) {
      obj.relevance = heuristicRelevanceToJSON(message.relevance);
    }
    if (message.policy !== undefined) {
      obj.policy = Policy.toJSON(message.policy);
    }
    return obj;
  },

  create(base?: DeepPartial<ExplainedAllowPolicy>): ExplainedAllowPolicy {
    return ExplainedAllowPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExplainedAllowPolicy>): ExplainedAllowPolicy {
    const message = createBaseExplainedAllowPolicy();
    message.allowAccessState = object.allowAccessState ?? 0;
    message.fullResourceName = object.fullResourceName ?? "";
    message.bindingExplanations = object.bindingExplanations?.map((e) => AllowBindingExplanation.fromPartial(e)) || [];
    message.relevance = object.relevance ?? 0;
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? Policy.fromPartial(object.policy)
      : undefined;
    return message;
  },
};

function createBaseAllowBindingExplanation(): AllowBindingExplanation {
  return {
    allowAccessState: 0,
    role: "",
    rolePermission: 0,
    rolePermissionRelevance: 0,
    combinedMembership: undefined,
    memberships: {},
    relevance: 0,
    condition: undefined,
    conditionExplanation: undefined,
  };
}

export const AllowBindingExplanation: MessageFns<AllowBindingExplanation> = {
  encode(message: AllowBindingExplanation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowAccessState !== 0) {
      writer.uint32(8).int32(message.allowAccessState);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    if (message.rolePermission !== 0) {
      writer.uint32(24).int32(message.rolePermission);
    }
    if (message.rolePermissionRelevance !== 0) {
      writer.uint32(32).int32(message.rolePermissionRelevance);
    }
    if (message.combinedMembership !== undefined) {
      AllowBindingExplanation_AnnotatedAllowMembership.encode(message.combinedMembership, writer.uint32(42).fork())
        .join();
    }
    Object.entries(message.memberships).forEach(([key, value]) => {
      AllowBindingExplanation_MembershipsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.relevance !== 0) {
      writer.uint32(56).int32(message.relevance);
    }
    if (message.condition !== undefined) {
      Expr.encode(message.condition, writer.uint32(66).fork()).join();
    }
    if (message.conditionExplanation !== undefined) {
      ConditionExplanation.encode(message.conditionExplanation, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowBindingExplanation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowBindingExplanation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.allowAccessState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rolePermission = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.rolePermissionRelevance = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.combinedMembership = AllowBindingExplanation_AnnotatedAllowMembership.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = AllowBindingExplanation_MembershipsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.memberships[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.relevance = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.condition = Expr.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.conditionExplanation = ConditionExplanation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowBindingExplanation {
    return {
      allowAccessState: isSet(object.allowAccessState) ? allowAccessStateFromJSON(object.allowAccessState) : 0,
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      rolePermission: isSet(object.rolePermission) ? rolePermissionInclusionStateFromJSON(object.rolePermission) : 0,
      rolePermissionRelevance: isSet(object.rolePermissionRelevance)
        ? heuristicRelevanceFromJSON(object.rolePermissionRelevance)
        : 0,
      combinedMembership: isSet(object.combinedMembership)
        ? AllowBindingExplanation_AnnotatedAllowMembership.fromJSON(object.combinedMembership)
        : undefined,
      memberships: isObject(object.memberships)
        ? Object.entries(object.memberships).reduce<
          { [key: string]: AllowBindingExplanation_AnnotatedAllowMembership }
        >((acc, [key, value]) => {
          acc[key] = AllowBindingExplanation_AnnotatedAllowMembership.fromJSON(value);
          return acc;
        }, {})
        : {},
      relevance: isSet(object.relevance) ? heuristicRelevanceFromJSON(object.relevance) : 0,
      condition: isSet(object.condition) ? Expr.fromJSON(object.condition) : undefined,
      conditionExplanation: isSet(object.conditionExplanation)
        ? ConditionExplanation.fromJSON(object.conditionExplanation)
        : undefined,
    };
  },

  toJSON(message: AllowBindingExplanation): unknown {
    const obj: any = {};
    if (message.allowAccessState !== 0) {
      obj.allowAccessState = allowAccessStateToJSON(message.allowAccessState);
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.rolePermission !== 0) {
      obj.rolePermission = rolePermissionInclusionStateToJSON(message.rolePermission);
    }
    if (message.rolePermissionRelevance !== 0) {
      obj.rolePermissionRelevance = heuristicRelevanceToJSON(message.rolePermissionRelevance);
    }
    if (message.combinedMembership !== undefined) {
      obj.combinedMembership = AllowBindingExplanation_AnnotatedAllowMembership.toJSON(message.combinedMembership);
    }
    if (message.memberships) {
      const entries = Object.entries(message.memberships);
      if (entries.length > 0) {
        obj.memberships = {};
        entries.forEach(([k, v]) => {
          obj.memberships[k] = AllowBindingExplanation_AnnotatedAllowMembership.toJSON(v);
        });
      }
    }
    if (message.relevance !== 0) {
      obj.relevance = heuristicRelevanceToJSON(message.relevance);
    }
    if (message.condition !== undefined) {
      obj.condition = Expr.toJSON(message.condition);
    }
    if (message.conditionExplanation !== undefined) {
      obj.conditionExplanation = ConditionExplanation.toJSON(message.conditionExplanation);
    }
    return obj;
  },

  create(base?: DeepPartial<AllowBindingExplanation>): AllowBindingExplanation {
    return AllowBindingExplanation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AllowBindingExplanation>): AllowBindingExplanation {
    const message = createBaseAllowBindingExplanation();
    message.allowAccessState = object.allowAccessState ?? 0;
    message.role = object.role ?? "";
    message.rolePermission = object.rolePermission ?? 0;
    message.rolePermissionRelevance = object.rolePermissionRelevance ?? 0;
    message.combinedMembership = (object.combinedMembership !== undefined && object.combinedMembership !== null)
      ? AllowBindingExplanation_AnnotatedAllowMembership.fromPartial(object.combinedMembership)
      : undefined;
    message.memberships = Object.entries(object.memberships ?? {}).reduce<
      { [key: string]: AllowBindingExplanation_AnnotatedAllowMembership }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = AllowBindingExplanation_AnnotatedAllowMembership.fromPartial(value);
      }
      return acc;
    }, {});
    message.relevance = object.relevance ?? 0;
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? Expr.fromPartial(object.condition)
      : undefined;
    message.conditionExplanation = (object.conditionExplanation !== undefined && object.conditionExplanation !== null)
      ? ConditionExplanation.fromPartial(object.conditionExplanation)
      : undefined;
    return message;
  },
};

function createBaseAllowBindingExplanation_AnnotatedAllowMembership(): AllowBindingExplanation_AnnotatedAllowMembership {
  return { membership: 0, relevance: 0 };
}

export const AllowBindingExplanation_AnnotatedAllowMembership: MessageFns<
  AllowBindingExplanation_AnnotatedAllowMembership
> = {
  encode(
    message: AllowBindingExplanation_AnnotatedAllowMembership,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.membership !== 0) {
      writer.uint32(8).int32(message.membership);
    }
    if (message.relevance !== 0) {
      writer.uint32(16).int32(message.relevance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowBindingExplanation_AnnotatedAllowMembership {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowBindingExplanation_AnnotatedAllowMembership();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.membership = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.relevance = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowBindingExplanation_AnnotatedAllowMembership {
    return {
      membership: isSet(object.membership) ? membershipMatchingStateFromJSON(object.membership) : 0,
      relevance: isSet(object.relevance) ? heuristicRelevanceFromJSON(object.relevance) : 0,
    };
  },

  toJSON(message: AllowBindingExplanation_AnnotatedAllowMembership): unknown {
    const obj: any = {};
    if (message.membership !== 0) {
      obj.membership = membershipMatchingStateToJSON(message.membership);
    }
    if (message.relevance !== 0) {
      obj.relevance = heuristicRelevanceToJSON(message.relevance);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AllowBindingExplanation_AnnotatedAllowMembership>,
  ): AllowBindingExplanation_AnnotatedAllowMembership {
    return AllowBindingExplanation_AnnotatedAllowMembership.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AllowBindingExplanation_AnnotatedAllowMembership>,
  ): AllowBindingExplanation_AnnotatedAllowMembership {
    const message = createBaseAllowBindingExplanation_AnnotatedAllowMembership();
    message.membership = object.membership ?? 0;
    message.relevance = object.relevance ?? 0;
    return message;
  },
};

function createBaseAllowBindingExplanation_MembershipsEntry(): AllowBindingExplanation_MembershipsEntry {
  return { key: "", value: undefined };
}

export const AllowBindingExplanation_MembershipsEntry: MessageFns<AllowBindingExplanation_MembershipsEntry> = {
  encode(message: AllowBindingExplanation_MembershipsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AllowBindingExplanation_AnnotatedAllowMembership.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowBindingExplanation_MembershipsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowBindingExplanation_MembershipsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AllowBindingExplanation_AnnotatedAllowMembership.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowBindingExplanation_MembershipsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AllowBindingExplanation_AnnotatedAllowMembership.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AllowBindingExplanation_MembershipsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AllowBindingExplanation_AnnotatedAllowMembership.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<AllowBindingExplanation_MembershipsEntry>): AllowBindingExplanation_MembershipsEntry {
    return AllowBindingExplanation_MembershipsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AllowBindingExplanation_MembershipsEntry>): AllowBindingExplanation_MembershipsEntry {
    const message = createBaseAllowBindingExplanation_MembershipsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AllowBindingExplanation_AnnotatedAllowMembership.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDenyPolicyExplanation(): DenyPolicyExplanation {
  return { denyAccessState: 0, explainedResources: [], relevance: 0, permissionDeniable: false };
}

export const DenyPolicyExplanation: MessageFns<DenyPolicyExplanation> = {
  encode(message: DenyPolicyExplanation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denyAccessState !== 0) {
      writer.uint32(8).int32(message.denyAccessState);
    }
    for (const v of message.explainedResources) {
      ExplainedDenyResource.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.relevance !== 0) {
      writer.uint32(24).int32(message.relevance);
    }
    if (message.permissionDeniable !== false) {
      writer.uint32(32).bool(message.permissionDeniable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DenyPolicyExplanation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDenyPolicyExplanation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.denyAccessState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.explainedResources.push(ExplainedDenyResource.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.relevance = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.permissionDeniable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DenyPolicyExplanation {
    return {
      denyAccessState: isSet(object.denyAccessState) ? denyAccessStateFromJSON(object.denyAccessState) : 0,
      explainedResources: globalThis.Array.isArray(object?.explainedResources)
        ? object.explainedResources.map((e: any) => ExplainedDenyResource.fromJSON(e))
        : [],
      relevance: isSet(object.relevance) ? heuristicRelevanceFromJSON(object.relevance) : 0,
      permissionDeniable: isSet(object.permissionDeniable) ? globalThis.Boolean(object.permissionDeniable) : false,
    };
  },

  toJSON(message: DenyPolicyExplanation): unknown {
    const obj: any = {};
    if (message.denyAccessState !== 0) {
      obj.denyAccessState = denyAccessStateToJSON(message.denyAccessState);
    }
    if (message.explainedResources?.length) {
      obj.explainedResources = message.explainedResources.map((e) => ExplainedDenyResource.toJSON(e));
    }
    if (message.relevance !== 0) {
      obj.relevance = heuristicRelevanceToJSON(message.relevance);
    }
    if (message.permissionDeniable !== false) {
      obj.permissionDeniable = message.permissionDeniable;
    }
    return obj;
  },

  create(base?: DeepPartial<DenyPolicyExplanation>): DenyPolicyExplanation {
    return DenyPolicyExplanation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DenyPolicyExplanation>): DenyPolicyExplanation {
    const message = createBaseDenyPolicyExplanation();
    message.denyAccessState = object.denyAccessState ?? 0;
    message.explainedResources = object.explainedResources?.map((e) => ExplainedDenyResource.fromPartial(e)) || [];
    message.relevance = object.relevance ?? 0;
    message.permissionDeniable = object.permissionDeniable ?? false;
    return message;
  },
};

function createBaseExplainedDenyResource(): ExplainedDenyResource {
  return { denyAccessState: 0, fullResourceName: "", explainedPolicies: [], relevance: 0 };
}

export const ExplainedDenyResource: MessageFns<ExplainedDenyResource> = {
  encode(message: ExplainedDenyResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denyAccessState !== 0) {
      writer.uint32(8).int32(message.denyAccessState);
    }
    if (message.fullResourceName !== "") {
      writer.uint32(18).string(message.fullResourceName);
    }
    for (const v of message.explainedPolicies) {
      ExplainedDenyPolicy.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.relevance !== 0) {
      writer.uint32(32).int32(message.relevance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExplainedDenyResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExplainedDenyResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.denyAccessState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fullResourceName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.explainedPolicies.push(ExplainedDenyPolicy.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.relevance = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExplainedDenyResource {
    return {
      denyAccessState: isSet(object.denyAccessState) ? denyAccessStateFromJSON(object.denyAccessState) : 0,
      fullResourceName: isSet(object.fullResourceName) ? globalThis.String(object.fullResourceName) : "",
      explainedPolicies: globalThis.Array.isArray(object?.explainedPolicies)
        ? object.explainedPolicies.map((e: any) => ExplainedDenyPolicy.fromJSON(e))
        : [],
      relevance: isSet(object.relevance) ? heuristicRelevanceFromJSON(object.relevance) : 0,
    };
  },

  toJSON(message: ExplainedDenyResource): unknown {
    const obj: any = {};
    if (message.denyAccessState !== 0) {
      obj.denyAccessState = denyAccessStateToJSON(message.denyAccessState);
    }
    if (message.fullResourceName !== "") {
      obj.fullResourceName = message.fullResourceName;
    }
    if (message.explainedPolicies?.length) {
      obj.explainedPolicies = message.explainedPolicies.map((e) => ExplainedDenyPolicy.toJSON(e));
    }
    if (message.relevance !== 0) {
      obj.relevance = heuristicRelevanceToJSON(message.relevance);
    }
    return obj;
  },

  create(base?: DeepPartial<ExplainedDenyResource>): ExplainedDenyResource {
    return ExplainedDenyResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExplainedDenyResource>): ExplainedDenyResource {
    const message = createBaseExplainedDenyResource();
    message.denyAccessState = object.denyAccessState ?? 0;
    message.fullResourceName = object.fullResourceName ?? "";
    message.explainedPolicies = object.explainedPolicies?.map((e) => ExplainedDenyPolicy.fromPartial(e)) || [];
    message.relevance = object.relevance ?? 0;
    return message;
  },
};

function createBaseExplainedDenyPolicy(): ExplainedDenyPolicy {
  return { denyAccessState: 0, policy: undefined, ruleExplanations: [], relevance: 0 };
}

export const ExplainedDenyPolicy: MessageFns<ExplainedDenyPolicy> = {
  encode(message: ExplainedDenyPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denyAccessState !== 0) {
      writer.uint32(8).int32(message.denyAccessState);
    }
    if (message.policy !== undefined) {
      Policy1.encode(message.policy, writer.uint32(18).fork()).join();
    }
    for (const v of message.ruleExplanations) {
      DenyRuleExplanation.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.relevance !== 0) {
      writer.uint32(32).int32(message.relevance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExplainedDenyPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExplainedDenyPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.denyAccessState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.policy = Policy1.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ruleExplanations.push(DenyRuleExplanation.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.relevance = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExplainedDenyPolicy {
    return {
      denyAccessState: isSet(object.denyAccessState) ? denyAccessStateFromJSON(object.denyAccessState) : 0,
      policy: isSet(object.policy) ? Policy1.fromJSON(object.policy) : undefined,
      ruleExplanations: globalThis.Array.isArray(object?.ruleExplanations)
        ? object.ruleExplanations.map((e: any) => DenyRuleExplanation.fromJSON(e))
        : [],
      relevance: isSet(object.relevance) ? heuristicRelevanceFromJSON(object.relevance) : 0,
    };
  },

  toJSON(message: ExplainedDenyPolicy): unknown {
    const obj: any = {};
    if (message.denyAccessState !== 0) {
      obj.denyAccessState = denyAccessStateToJSON(message.denyAccessState);
    }
    if (message.policy !== undefined) {
      obj.policy = Policy1.toJSON(message.policy);
    }
    if (message.ruleExplanations?.length) {
      obj.ruleExplanations = message.ruleExplanations.map((e) => DenyRuleExplanation.toJSON(e));
    }
    if (message.relevance !== 0) {
      obj.relevance = heuristicRelevanceToJSON(message.relevance);
    }
    return obj;
  },

  create(base?: DeepPartial<ExplainedDenyPolicy>): ExplainedDenyPolicy {
    return ExplainedDenyPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExplainedDenyPolicy>): ExplainedDenyPolicy {
    const message = createBaseExplainedDenyPolicy();
    message.denyAccessState = object.denyAccessState ?? 0;
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? Policy1.fromPartial(object.policy)
      : undefined;
    message.ruleExplanations = object.ruleExplanations?.map((e) => DenyRuleExplanation.fromPartial(e)) || [];
    message.relevance = object.relevance ?? 0;
    return message;
  },
};

function createBaseDenyRuleExplanation(): DenyRuleExplanation {
  return {
    denyAccessState: 0,
    combinedDeniedPermission: undefined,
    deniedPermissions: {},
    combinedExceptionPermission: undefined,
    exceptionPermissions: {},
    combinedDeniedPrincipal: undefined,
    deniedPrincipals: {},
    combinedExceptionPrincipal: undefined,
    exceptionPrincipals: {},
    relevance: 0,
    condition: undefined,
    conditionExplanation: undefined,
  };
}

export const DenyRuleExplanation: MessageFns<DenyRuleExplanation> = {
  encode(message: DenyRuleExplanation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denyAccessState !== 0) {
      writer.uint32(8).int32(message.denyAccessState);
    }
    if (message.combinedDeniedPermission !== undefined) {
      DenyRuleExplanation_AnnotatedPermissionMatching.encode(message.combinedDeniedPermission, writer.uint32(18).fork())
        .join();
    }
    Object.entries(message.deniedPermissions).forEach(([key, value]) => {
      DenyRuleExplanation_DeniedPermissionsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.combinedExceptionPermission !== undefined) {
      DenyRuleExplanation_AnnotatedPermissionMatching.encode(
        message.combinedExceptionPermission,
        writer.uint32(34).fork(),
      ).join();
    }
    Object.entries(message.exceptionPermissions).forEach(([key, value]) => {
      DenyRuleExplanation_ExceptionPermissionsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.combinedDeniedPrincipal !== undefined) {
      DenyRuleExplanation_AnnotatedDenyPrincipalMatching.encode(
        message.combinedDeniedPrincipal,
        writer.uint32(50).fork(),
      ).join();
    }
    Object.entries(message.deniedPrincipals).forEach(([key, value]) => {
      DenyRuleExplanation_DeniedPrincipalsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.combinedExceptionPrincipal !== undefined) {
      DenyRuleExplanation_AnnotatedDenyPrincipalMatching.encode(
        message.combinedExceptionPrincipal,
        writer.uint32(66).fork(),
      ).join();
    }
    Object.entries(message.exceptionPrincipals).forEach(([key, value]) => {
      DenyRuleExplanation_ExceptionPrincipalsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    if (message.relevance !== 0) {
      writer.uint32(80).int32(message.relevance);
    }
    if (message.condition !== undefined) {
      Expr.encode(message.condition, writer.uint32(90).fork()).join();
    }
    if (message.conditionExplanation !== undefined) {
      ConditionExplanation.encode(message.conditionExplanation, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DenyRuleExplanation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDenyRuleExplanation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.denyAccessState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.combinedDeniedPermission = DenyRuleExplanation_AnnotatedPermissionMatching.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = DenyRuleExplanation_DeniedPermissionsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.deniedPermissions[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.combinedExceptionPermission = DenyRuleExplanation_AnnotatedPermissionMatching.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = DenyRuleExplanation_ExceptionPermissionsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.exceptionPermissions[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.combinedDeniedPrincipal = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = DenyRuleExplanation_DeniedPrincipalsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.deniedPrincipals[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.combinedExceptionPrincipal = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = DenyRuleExplanation_ExceptionPrincipalsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.exceptionPrincipals[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.relevance = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.condition = Expr.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.conditionExplanation = ConditionExplanation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DenyRuleExplanation {
    return {
      denyAccessState: isSet(object.denyAccessState) ? denyAccessStateFromJSON(object.denyAccessState) : 0,
      combinedDeniedPermission: isSet(object.combinedDeniedPermission)
        ? DenyRuleExplanation_AnnotatedPermissionMatching.fromJSON(object.combinedDeniedPermission)
        : undefined,
      deniedPermissions: isObject(object.deniedPermissions)
        ? Object.entries(object.deniedPermissions).reduce<
          { [key: string]: DenyRuleExplanation_AnnotatedPermissionMatching }
        >((acc, [key, value]) => {
          acc[key] = DenyRuleExplanation_AnnotatedPermissionMatching.fromJSON(value);
          return acc;
        }, {})
        : {},
      combinedExceptionPermission: isSet(object.combinedExceptionPermission)
        ? DenyRuleExplanation_AnnotatedPermissionMatching.fromJSON(object.combinedExceptionPermission)
        : undefined,
      exceptionPermissions: isObject(object.exceptionPermissions)
        ? Object.entries(object.exceptionPermissions).reduce<
          { [key: string]: DenyRuleExplanation_AnnotatedPermissionMatching }
        >((acc, [key, value]) => {
          acc[key] = DenyRuleExplanation_AnnotatedPermissionMatching.fromJSON(value);
          return acc;
        }, {})
        : {},
      combinedDeniedPrincipal: isSet(object.combinedDeniedPrincipal)
        ? DenyRuleExplanation_AnnotatedDenyPrincipalMatching.fromJSON(object.combinedDeniedPrincipal)
        : undefined,
      deniedPrincipals: isObject(object.deniedPrincipals)
        ? Object.entries(object.deniedPrincipals).reduce<
          { [key: string]: DenyRuleExplanation_AnnotatedDenyPrincipalMatching }
        >((acc, [key, value]) => {
          acc[key] = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.fromJSON(value);
          return acc;
        }, {})
        : {},
      combinedExceptionPrincipal: isSet(object.combinedExceptionPrincipal)
        ? DenyRuleExplanation_AnnotatedDenyPrincipalMatching.fromJSON(object.combinedExceptionPrincipal)
        : undefined,
      exceptionPrincipals: isObject(object.exceptionPrincipals)
        ? Object.entries(object.exceptionPrincipals).reduce<
          { [key: string]: DenyRuleExplanation_AnnotatedDenyPrincipalMatching }
        >((acc, [key, value]) => {
          acc[key] = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.fromJSON(value);
          return acc;
        }, {})
        : {},
      relevance: isSet(object.relevance) ? heuristicRelevanceFromJSON(object.relevance) : 0,
      condition: isSet(object.condition) ? Expr.fromJSON(object.condition) : undefined,
      conditionExplanation: isSet(object.conditionExplanation)
        ? ConditionExplanation.fromJSON(object.conditionExplanation)
        : undefined,
    };
  },

  toJSON(message: DenyRuleExplanation): unknown {
    const obj: any = {};
    if (message.denyAccessState !== 0) {
      obj.denyAccessState = denyAccessStateToJSON(message.denyAccessState);
    }
    if (message.combinedDeniedPermission !== undefined) {
      obj.combinedDeniedPermission = DenyRuleExplanation_AnnotatedPermissionMatching.toJSON(
        message.combinedDeniedPermission,
      );
    }
    if (message.deniedPermissions) {
      const entries = Object.entries(message.deniedPermissions);
      if (entries.length > 0) {
        obj.deniedPermissions = {};
        entries.forEach(([k, v]) => {
          obj.deniedPermissions[k] = DenyRuleExplanation_AnnotatedPermissionMatching.toJSON(v);
        });
      }
    }
    if (message.combinedExceptionPermission !== undefined) {
      obj.combinedExceptionPermission = DenyRuleExplanation_AnnotatedPermissionMatching.toJSON(
        message.combinedExceptionPermission,
      );
    }
    if (message.exceptionPermissions) {
      const entries = Object.entries(message.exceptionPermissions);
      if (entries.length > 0) {
        obj.exceptionPermissions = {};
        entries.forEach(([k, v]) => {
          obj.exceptionPermissions[k] = DenyRuleExplanation_AnnotatedPermissionMatching.toJSON(v);
        });
      }
    }
    if (message.combinedDeniedPrincipal !== undefined) {
      obj.combinedDeniedPrincipal = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.toJSON(
        message.combinedDeniedPrincipal,
      );
    }
    if (message.deniedPrincipals) {
      const entries = Object.entries(message.deniedPrincipals);
      if (entries.length > 0) {
        obj.deniedPrincipals = {};
        entries.forEach(([k, v]) => {
          obj.deniedPrincipals[k] = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.toJSON(v);
        });
      }
    }
    if (message.combinedExceptionPrincipal !== undefined) {
      obj.combinedExceptionPrincipal = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.toJSON(
        message.combinedExceptionPrincipal,
      );
    }
    if (message.exceptionPrincipals) {
      const entries = Object.entries(message.exceptionPrincipals);
      if (entries.length > 0) {
        obj.exceptionPrincipals = {};
        entries.forEach(([k, v]) => {
          obj.exceptionPrincipals[k] = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.toJSON(v);
        });
      }
    }
    if (message.relevance !== 0) {
      obj.relevance = heuristicRelevanceToJSON(message.relevance);
    }
    if (message.condition !== undefined) {
      obj.condition = Expr.toJSON(message.condition);
    }
    if (message.conditionExplanation !== undefined) {
      obj.conditionExplanation = ConditionExplanation.toJSON(message.conditionExplanation);
    }
    return obj;
  },

  create(base?: DeepPartial<DenyRuleExplanation>): DenyRuleExplanation {
    return DenyRuleExplanation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DenyRuleExplanation>): DenyRuleExplanation {
    const message = createBaseDenyRuleExplanation();
    message.denyAccessState = object.denyAccessState ?? 0;
    message.combinedDeniedPermission =
      (object.combinedDeniedPermission !== undefined && object.combinedDeniedPermission !== null)
        ? DenyRuleExplanation_AnnotatedPermissionMatching.fromPartial(object.combinedDeniedPermission)
        : undefined;
    message.deniedPermissions = Object.entries(object.deniedPermissions ?? {}).reduce<
      { [key: string]: DenyRuleExplanation_AnnotatedPermissionMatching }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = DenyRuleExplanation_AnnotatedPermissionMatching.fromPartial(value);
      }
      return acc;
    }, {});
    message.combinedExceptionPermission =
      (object.combinedExceptionPermission !== undefined && object.combinedExceptionPermission !== null)
        ? DenyRuleExplanation_AnnotatedPermissionMatching.fromPartial(object.combinedExceptionPermission)
        : undefined;
    message.exceptionPermissions = Object.entries(object.exceptionPermissions ?? {}).reduce<
      { [key: string]: DenyRuleExplanation_AnnotatedPermissionMatching }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = DenyRuleExplanation_AnnotatedPermissionMatching.fromPartial(value);
      }
      return acc;
    }, {});
    message.combinedDeniedPrincipal =
      (object.combinedDeniedPrincipal !== undefined && object.combinedDeniedPrincipal !== null)
        ? DenyRuleExplanation_AnnotatedDenyPrincipalMatching.fromPartial(object.combinedDeniedPrincipal)
        : undefined;
    message.deniedPrincipals = Object.entries(object.deniedPrincipals ?? {}).reduce<
      { [key: string]: DenyRuleExplanation_AnnotatedDenyPrincipalMatching }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.fromPartial(value);
      }
      return acc;
    }, {});
    message.combinedExceptionPrincipal =
      (object.combinedExceptionPrincipal !== undefined && object.combinedExceptionPrincipal !== null)
        ? DenyRuleExplanation_AnnotatedDenyPrincipalMatching.fromPartial(object.combinedExceptionPrincipal)
        : undefined;
    message.exceptionPrincipals = Object.entries(object.exceptionPrincipals ?? {}).reduce<
      { [key: string]: DenyRuleExplanation_AnnotatedDenyPrincipalMatching }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.fromPartial(value);
      }
      return acc;
    }, {});
    message.relevance = object.relevance ?? 0;
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? Expr.fromPartial(object.condition)
      : undefined;
    message.conditionExplanation = (object.conditionExplanation !== undefined && object.conditionExplanation !== null)
      ? ConditionExplanation.fromPartial(object.conditionExplanation)
      : undefined;
    return message;
  },
};

function createBaseDenyRuleExplanation_AnnotatedPermissionMatching(): DenyRuleExplanation_AnnotatedPermissionMatching {
  return { permissionMatchingState: 0, relevance: 0 };
}

export const DenyRuleExplanation_AnnotatedPermissionMatching: MessageFns<
  DenyRuleExplanation_AnnotatedPermissionMatching
> = {
  encode(
    message: DenyRuleExplanation_AnnotatedPermissionMatching,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.permissionMatchingState !== 0) {
      writer.uint32(8).int32(message.permissionMatchingState);
    }
    if (message.relevance !== 0) {
      writer.uint32(16).int32(message.relevance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DenyRuleExplanation_AnnotatedPermissionMatching {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDenyRuleExplanation_AnnotatedPermissionMatching();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.permissionMatchingState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.relevance = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DenyRuleExplanation_AnnotatedPermissionMatching {
    return {
      permissionMatchingState: isSet(object.permissionMatchingState)
        ? permissionPatternMatchingStateFromJSON(object.permissionMatchingState)
        : 0,
      relevance: isSet(object.relevance) ? heuristicRelevanceFromJSON(object.relevance) : 0,
    };
  },

  toJSON(message: DenyRuleExplanation_AnnotatedPermissionMatching): unknown {
    const obj: any = {};
    if (message.permissionMatchingState !== 0) {
      obj.permissionMatchingState = permissionPatternMatchingStateToJSON(message.permissionMatchingState);
    }
    if (message.relevance !== 0) {
      obj.relevance = heuristicRelevanceToJSON(message.relevance);
    }
    return obj;
  },

  create(
    base?: DeepPartial<DenyRuleExplanation_AnnotatedPermissionMatching>,
  ): DenyRuleExplanation_AnnotatedPermissionMatching {
    return DenyRuleExplanation_AnnotatedPermissionMatching.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DenyRuleExplanation_AnnotatedPermissionMatching>,
  ): DenyRuleExplanation_AnnotatedPermissionMatching {
    const message = createBaseDenyRuleExplanation_AnnotatedPermissionMatching();
    message.permissionMatchingState = object.permissionMatchingState ?? 0;
    message.relevance = object.relevance ?? 0;
    return message;
  },
};

function createBaseDenyRuleExplanation_AnnotatedDenyPrincipalMatching(): DenyRuleExplanation_AnnotatedDenyPrincipalMatching {
  return { membership: 0, relevance: 0 };
}

export const DenyRuleExplanation_AnnotatedDenyPrincipalMatching: MessageFns<
  DenyRuleExplanation_AnnotatedDenyPrincipalMatching
> = {
  encode(
    message: DenyRuleExplanation_AnnotatedDenyPrincipalMatching,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.membership !== 0) {
      writer.uint32(8).int32(message.membership);
    }
    if (message.relevance !== 0) {
      writer.uint32(16).int32(message.relevance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DenyRuleExplanation_AnnotatedDenyPrincipalMatching {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDenyRuleExplanation_AnnotatedDenyPrincipalMatching();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.membership = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.relevance = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DenyRuleExplanation_AnnotatedDenyPrincipalMatching {
    return {
      membership: isSet(object.membership) ? membershipMatchingStateFromJSON(object.membership) : 0,
      relevance: isSet(object.relevance) ? heuristicRelevanceFromJSON(object.relevance) : 0,
    };
  },

  toJSON(message: DenyRuleExplanation_AnnotatedDenyPrincipalMatching): unknown {
    const obj: any = {};
    if (message.membership !== 0) {
      obj.membership = membershipMatchingStateToJSON(message.membership);
    }
    if (message.relevance !== 0) {
      obj.relevance = heuristicRelevanceToJSON(message.relevance);
    }
    return obj;
  },

  create(
    base?: DeepPartial<DenyRuleExplanation_AnnotatedDenyPrincipalMatching>,
  ): DenyRuleExplanation_AnnotatedDenyPrincipalMatching {
    return DenyRuleExplanation_AnnotatedDenyPrincipalMatching.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DenyRuleExplanation_AnnotatedDenyPrincipalMatching>,
  ): DenyRuleExplanation_AnnotatedDenyPrincipalMatching {
    const message = createBaseDenyRuleExplanation_AnnotatedDenyPrincipalMatching();
    message.membership = object.membership ?? 0;
    message.relevance = object.relevance ?? 0;
    return message;
  },
};

function createBaseDenyRuleExplanation_DeniedPermissionsEntry(): DenyRuleExplanation_DeniedPermissionsEntry {
  return { key: "", value: undefined };
}

export const DenyRuleExplanation_DeniedPermissionsEntry: MessageFns<DenyRuleExplanation_DeniedPermissionsEntry> = {
  encode(message: DenyRuleExplanation_DeniedPermissionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DenyRuleExplanation_AnnotatedPermissionMatching.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DenyRuleExplanation_DeniedPermissionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDenyRuleExplanation_DeniedPermissionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = DenyRuleExplanation_AnnotatedPermissionMatching.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DenyRuleExplanation_DeniedPermissionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DenyRuleExplanation_AnnotatedPermissionMatching.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: DenyRuleExplanation_DeniedPermissionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DenyRuleExplanation_AnnotatedPermissionMatching.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<DenyRuleExplanation_DeniedPermissionsEntry>): DenyRuleExplanation_DeniedPermissionsEntry {
    return DenyRuleExplanation_DeniedPermissionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DenyRuleExplanation_DeniedPermissionsEntry>,
  ): DenyRuleExplanation_DeniedPermissionsEntry {
    const message = createBaseDenyRuleExplanation_DeniedPermissionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DenyRuleExplanation_AnnotatedPermissionMatching.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDenyRuleExplanation_ExceptionPermissionsEntry(): DenyRuleExplanation_ExceptionPermissionsEntry {
  return { key: "", value: undefined };
}

export const DenyRuleExplanation_ExceptionPermissionsEntry: MessageFns<DenyRuleExplanation_ExceptionPermissionsEntry> =
  {
    encode(
      message: DenyRuleExplanation_ExceptionPermissionsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        DenyRuleExplanation_AnnotatedPermissionMatching.encode(message.value, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): DenyRuleExplanation_ExceptionPermissionsEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseDenyRuleExplanation_ExceptionPermissionsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.value = DenyRuleExplanation_AnnotatedPermissionMatching.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): DenyRuleExplanation_ExceptionPermissionsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? DenyRuleExplanation_AnnotatedPermissionMatching.fromJSON(object.value) : undefined,
      };
    },

    toJSON(message: DenyRuleExplanation_ExceptionPermissionsEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = DenyRuleExplanation_AnnotatedPermissionMatching.toJSON(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<DenyRuleExplanation_ExceptionPermissionsEntry>,
    ): DenyRuleExplanation_ExceptionPermissionsEntry {
      return DenyRuleExplanation_ExceptionPermissionsEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<DenyRuleExplanation_ExceptionPermissionsEntry>,
    ): DenyRuleExplanation_ExceptionPermissionsEntry {
      const message = createBaseDenyRuleExplanation_ExceptionPermissionsEntry();
      message.key = object.key ?? "";
      message.value = (object.value !== undefined && object.value !== null)
        ? DenyRuleExplanation_AnnotatedPermissionMatching.fromPartial(object.value)
        : undefined;
      return message;
    },
  };

function createBaseDenyRuleExplanation_DeniedPrincipalsEntry(): DenyRuleExplanation_DeniedPrincipalsEntry {
  return { key: "", value: undefined };
}

export const DenyRuleExplanation_DeniedPrincipalsEntry: MessageFns<DenyRuleExplanation_DeniedPrincipalsEntry> = {
  encode(message: DenyRuleExplanation_DeniedPrincipalsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DenyRuleExplanation_AnnotatedDenyPrincipalMatching.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DenyRuleExplanation_DeniedPrincipalsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDenyRuleExplanation_DeniedPrincipalsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DenyRuleExplanation_DeniedPrincipalsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value)
        ? DenyRuleExplanation_AnnotatedDenyPrincipalMatching.fromJSON(object.value)
        : undefined,
    };
  },

  toJSON(message: DenyRuleExplanation_DeniedPrincipalsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<DenyRuleExplanation_DeniedPrincipalsEntry>): DenyRuleExplanation_DeniedPrincipalsEntry {
    return DenyRuleExplanation_DeniedPrincipalsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DenyRuleExplanation_DeniedPrincipalsEntry>,
  ): DenyRuleExplanation_DeniedPrincipalsEntry {
    const message = createBaseDenyRuleExplanation_DeniedPrincipalsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DenyRuleExplanation_AnnotatedDenyPrincipalMatching.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDenyRuleExplanation_ExceptionPrincipalsEntry(): DenyRuleExplanation_ExceptionPrincipalsEntry {
  return { key: "", value: undefined };
}

export const DenyRuleExplanation_ExceptionPrincipalsEntry: MessageFns<DenyRuleExplanation_ExceptionPrincipalsEntry> = {
  encode(
    message: DenyRuleExplanation_ExceptionPrincipalsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DenyRuleExplanation_AnnotatedDenyPrincipalMatching.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DenyRuleExplanation_ExceptionPrincipalsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDenyRuleExplanation_ExceptionPrincipalsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DenyRuleExplanation_ExceptionPrincipalsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value)
        ? DenyRuleExplanation_AnnotatedDenyPrincipalMatching.fromJSON(object.value)
        : undefined,
    };
  },

  toJSON(message: DenyRuleExplanation_ExceptionPrincipalsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DenyRuleExplanation_AnnotatedDenyPrincipalMatching.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<DenyRuleExplanation_ExceptionPrincipalsEntry>,
  ): DenyRuleExplanation_ExceptionPrincipalsEntry {
    return DenyRuleExplanation_ExceptionPrincipalsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DenyRuleExplanation_ExceptionPrincipalsEntry>,
  ): DenyRuleExplanation_ExceptionPrincipalsEntry {
    const message = createBaseDenyRuleExplanation_ExceptionPrincipalsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DenyRuleExplanation_AnnotatedDenyPrincipalMatching.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseConditionExplanation(): ConditionExplanation {
  return { value: undefined, errors: [], evaluationStates: [] };
}

export const ConditionExplanation: MessageFns<ConditionExplanation> = {
  encode(message: ConditionExplanation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(10).fork()).join();
    }
    for (const v of message.errors) {
      Status.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.evaluationStates) {
      ConditionExplanation_EvaluationState.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionExplanation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionExplanation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errors.push(Status.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.evaluationStates.push(ConditionExplanation_EvaluationState.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConditionExplanation {
    return {
      value: isSet(object?.value) ? object.value : undefined,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Status.fromJSON(e)) : [],
      evaluationStates: globalThis.Array.isArray(object?.evaluationStates)
        ? object.evaluationStates.map((e: any) => ConditionExplanation_EvaluationState.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ConditionExplanation): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Status.toJSON(e));
    }
    if (message.evaluationStates?.length) {
      obj.evaluationStates = message.evaluationStates.map((e) => ConditionExplanation_EvaluationState.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ConditionExplanation>): ConditionExplanation {
    return ConditionExplanation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConditionExplanation>): ConditionExplanation {
    const message = createBaseConditionExplanation();
    message.value = object.value ?? undefined;
    message.errors = object.errors?.map((e) => Status.fromPartial(e)) || [];
    message.evaluationStates =
      object.evaluationStates?.map((e) => ConditionExplanation_EvaluationState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConditionExplanation_EvaluationState(): ConditionExplanation_EvaluationState {
  return { start: 0, end: 0, value: undefined, errors: [] };
}

export const ConditionExplanation_EvaluationState: MessageFns<ConditionExplanation_EvaluationState> = {
  encode(message: ConditionExplanation_EvaluationState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(26).fork()).join();
    }
    for (const v of message.errors) {
      Status.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionExplanation_EvaluationState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionExplanation_EvaluationState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errors.push(Status.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConditionExplanation_EvaluationState {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
      value: isSet(object?.value) ? object.value : undefined,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Status.fromJSON(e)) : [],
    };
  },

  toJSON(message: ConditionExplanation_EvaluationState): unknown {
    const obj: any = {};
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Status.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ConditionExplanation_EvaluationState>): ConditionExplanation_EvaluationState {
    return ConditionExplanation_EvaluationState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConditionExplanation_EvaluationState>): ConditionExplanation_EvaluationState {
    const message = createBaseConditionExplanation_EvaluationState();
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    message.value = object.value ?? undefined;
    message.errors = object.errors?.map((e) => Status.fromPartial(e)) || [];
    return message;
  },
};

/**
 * IAM Policy Troubleshooter service.
 *
 * This service helps you troubleshoot access issues for Google Cloud resources.
 */
export type PolicyTroubleshooterDefinition = typeof PolicyTroubleshooterDefinition;
export const PolicyTroubleshooterDefinition = {
  name: "PolicyTroubleshooter",
  fullName: "google.cloud.policytroubleshooter.iam.v3beta.PolicyTroubleshooter",
  methods: {
    /**
     * Checks whether a principal has a specific permission for a specific
     * resource, and explains why the principal does or doesn't have that
     * permission.
     */
    troubleshootIamPolicy: {
      name: "TroubleshootIamPolicy",
      requestType: TroubleshootIamPolicyRequest,
      requestStream: false,
      responseType: TroubleshootIamPolicyResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              29,
              58,
              1,
              42,
              34,
              24,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              47,
              105,
              97,
              109,
              58,
              116,
              114,
              111,
              117,
              98,
              108,
              101,
              115,
              104,
              111,
              111,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface PolicyTroubleshooterServiceImplementation<CallContextExt = {}> {
  /**
   * Checks whether a principal has a specific permission for a specific
   * resource, and explains why the principal does or doesn't have that
   * permission.
   */
  troubleshootIamPolicy(
    request: TroubleshootIamPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TroubleshootIamPolicyResponse>>;
}

export interface PolicyTroubleshooterClient<CallOptionsExt = {}> {
  /**
   * Checks whether a principal has a specific permission for a specific
   * resource, and explains why the principal does or doesn't have that
   * permission.
   */
  troubleshootIamPolicy(
    request: DeepPartial<TroubleshootIamPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TroubleshootIamPolicyResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
