// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/recommender/v1/insight.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Struct } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.recommender.v1";

/**
 * An insight along with the information used to derive the insight. The insight
 * may have associated recommendations as well.
 */
export interface Insight {
  /** Name of the insight. */
  name: string;
  /**
   * Free-form human readable summary in English. The maximum length is 500
   * characters.
   */
  description: string;
  /** Fully qualified resource names that this insight is targeting. */
  targetResources: string[];
  /** Insight subtype. Insight content schema will be stable for a given subtype. */
  insightSubtype: string;
  /**
   * A struct of custom fields to explain the insight.
   * Example: "grantedPermissionsCount": "1000"
   */
  content:
    | { [key: string]: any }
    | undefined;
  /** Timestamp of the latest data used to generate the insight. */
  lastRefreshTime:
    | Date
    | undefined;
  /**
   * Observation period that led to the insight. The source data used to
   * generate the insight ends at last_refresh_time and begins at
   * (last_refresh_time - observation_period).
   */
  observationPeriod:
    | Duration
    | undefined;
  /** Information state and metadata. */
  stateInfo:
    | InsightStateInfo
    | undefined;
  /** Category being targeted by the insight. */
  category: Insight_Category;
  /** Insight's severity. */
  severity: Insight_Severity;
  /**
   * Fingerprint of the Insight. Provides optimistic locking when updating
   * states.
   */
  etag: string;
  /** Recommendations derived from this insight. */
  associatedRecommendations: Insight_RecommendationReference[];
}

/** Insight category. */
export enum Insight_Category {
  /** CATEGORY_UNSPECIFIED - Unspecified category. */
  CATEGORY_UNSPECIFIED = 0,
  /** COST - The insight is related to cost. */
  COST = 1,
  /** SECURITY - The insight is related to security. */
  SECURITY = 2,
  /** PERFORMANCE - The insight is related to performance. */
  PERFORMANCE = 3,
  /** MANAGEABILITY - This insight is related to manageability. */
  MANAGEABILITY = 4,
  /** SUSTAINABILITY - The insight is related to sustainability. */
  SUSTAINABILITY = 5,
  /** RELIABILITY - This insight is related to reliability. */
  RELIABILITY = 6,
  UNRECOGNIZED = -1,
}

export function insight_CategoryFromJSON(object: any): Insight_Category {
  switch (object) {
    case 0:
    case "CATEGORY_UNSPECIFIED":
      return Insight_Category.CATEGORY_UNSPECIFIED;
    case 1:
    case "COST":
      return Insight_Category.COST;
    case 2:
    case "SECURITY":
      return Insight_Category.SECURITY;
    case 3:
    case "PERFORMANCE":
      return Insight_Category.PERFORMANCE;
    case 4:
    case "MANAGEABILITY":
      return Insight_Category.MANAGEABILITY;
    case 5:
    case "SUSTAINABILITY":
      return Insight_Category.SUSTAINABILITY;
    case 6:
    case "RELIABILITY":
      return Insight_Category.RELIABILITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Insight_Category.UNRECOGNIZED;
  }
}

export function insight_CategoryToJSON(object: Insight_Category): string {
  switch (object) {
    case Insight_Category.CATEGORY_UNSPECIFIED:
      return "CATEGORY_UNSPECIFIED";
    case Insight_Category.COST:
      return "COST";
    case Insight_Category.SECURITY:
      return "SECURITY";
    case Insight_Category.PERFORMANCE:
      return "PERFORMANCE";
    case Insight_Category.MANAGEABILITY:
      return "MANAGEABILITY";
    case Insight_Category.SUSTAINABILITY:
      return "SUSTAINABILITY";
    case Insight_Category.RELIABILITY:
      return "RELIABILITY";
    case Insight_Category.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Insight severity levels. */
export enum Insight_Severity {
  /** SEVERITY_UNSPECIFIED - Insight has unspecified severity. */
  SEVERITY_UNSPECIFIED = 0,
  /** LOW - Insight has low severity. */
  LOW = 1,
  /** MEDIUM - Insight has medium severity. */
  MEDIUM = 2,
  /** HIGH - Insight has high severity. */
  HIGH = 3,
  /** CRITICAL - Insight has critical severity. */
  CRITICAL = 4,
  UNRECOGNIZED = -1,
}

export function insight_SeverityFromJSON(object: any): Insight_Severity {
  switch (object) {
    case 0:
    case "SEVERITY_UNSPECIFIED":
      return Insight_Severity.SEVERITY_UNSPECIFIED;
    case 1:
    case "LOW":
      return Insight_Severity.LOW;
    case 2:
    case "MEDIUM":
      return Insight_Severity.MEDIUM;
    case 3:
    case "HIGH":
      return Insight_Severity.HIGH;
    case 4:
    case "CRITICAL":
      return Insight_Severity.CRITICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Insight_Severity.UNRECOGNIZED;
  }
}

export function insight_SeverityToJSON(object: Insight_Severity): string {
  switch (object) {
    case Insight_Severity.SEVERITY_UNSPECIFIED:
      return "SEVERITY_UNSPECIFIED";
    case Insight_Severity.LOW:
      return "LOW";
    case Insight_Severity.MEDIUM:
      return "MEDIUM";
    case Insight_Severity.HIGH:
      return "HIGH";
    case Insight_Severity.CRITICAL:
      return "CRITICAL";
    case Insight_Severity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Reference to an associated recommendation. */
export interface Insight_RecommendationReference {
  /**
   * Recommendation resource name, e.g.
   * projects/[PROJECT_NUMBER]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]/recommendations/[RECOMMENDATION_ID]
   */
  recommendation: string;
}

/** Information related to insight state. */
export interface InsightStateInfo {
  /** Insight state. */
  state: InsightStateInfo_State;
  /** A map of metadata for the state, provided by user or automations systems. */
  stateMetadata: { [key: string]: string };
}

/** Represents insight state. */
export enum InsightStateInfo_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /**
   * ACTIVE - Insight is active. Content for ACTIVE insights can be updated by Google.
   * ACTIVE insights can be marked DISMISSED OR ACCEPTED.
   */
  ACTIVE = 1,
  /**
   * ACCEPTED - Some action has been taken based on this insight. Insights become
   * accepted when a recommendation derived from the insight has been marked
   * CLAIMED, SUCCEEDED, or FAILED. ACTIVE insights can also be marked
   * ACCEPTED explicitly. Content for ACCEPTED insights is immutable. ACCEPTED
   * insights can only be marked ACCEPTED (which may update state metadata).
   */
  ACCEPTED = 2,
  /**
   * DISMISSED - Insight is dismissed. Content for DISMISSED insights can be updated by
   * Google. DISMISSED insights can be marked as ACTIVE.
   */
  DISMISSED = 3,
  UNRECOGNIZED = -1,
}

export function insightStateInfo_StateFromJSON(object: any): InsightStateInfo_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return InsightStateInfo_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return InsightStateInfo_State.ACTIVE;
    case 2:
    case "ACCEPTED":
      return InsightStateInfo_State.ACCEPTED;
    case 3:
    case "DISMISSED":
      return InsightStateInfo_State.DISMISSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InsightStateInfo_State.UNRECOGNIZED;
  }
}

export function insightStateInfo_StateToJSON(object: InsightStateInfo_State): string {
  switch (object) {
    case InsightStateInfo_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case InsightStateInfo_State.ACTIVE:
      return "ACTIVE";
    case InsightStateInfo_State.ACCEPTED:
      return "ACCEPTED";
    case InsightStateInfo_State.DISMISSED:
      return "DISMISSED";
    case InsightStateInfo_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface InsightStateInfo_StateMetadataEntry {
  key: string;
  value: string;
}

function createBaseInsight(): Insight {
  return {
    name: "",
    description: "",
    targetResources: [],
    insightSubtype: "",
    content: undefined,
    lastRefreshTime: undefined,
    observationPeriod: undefined,
    stateInfo: undefined,
    category: 0,
    severity: 0,
    etag: "",
    associatedRecommendations: [],
  };
}

export const Insight: MessageFns<Insight> = {
  encode(message: Insight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.targetResources) {
      writer.uint32(74).string(v!);
    }
    if (message.insightSubtype !== "") {
      writer.uint32(82).string(message.insightSubtype);
    }
    if (message.content !== undefined) {
      Struct.encode(Struct.wrap(message.content), writer.uint32(26).fork()).join();
    }
    if (message.lastRefreshTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastRefreshTime), writer.uint32(34).fork()).join();
    }
    if (message.observationPeriod !== undefined) {
      Duration.encode(message.observationPeriod, writer.uint32(42).fork()).join();
    }
    if (message.stateInfo !== undefined) {
      InsightStateInfo.encode(message.stateInfo, writer.uint32(50).fork()).join();
    }
    if (message.category !== 0) {
      writer.uint32(56).int32(message.category);
    }
    if (message.severity !== 0) {
      writer.uint32(120).int32(message.severity);
    }
    if (message.etag !== "") {
      writer.uint32(90).string(message.etag);
    }
    for (const v of message.associatedRecommendations) {
      Insight_RecommendationReference.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Insight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.targetResources.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.insightSubtype = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastRefreshTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.observationPeriod = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.stateInfo = InsightStateInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.associatedRecommendations.push(Insight_RecommendationReference.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Insight {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      targetResources: globalThis.Array.isArray(object?.targetResources)
        ? object.targetResources.map((e: any) => globalThis.String(e))
        : [],
      insightSubtype: isSet(object.insightSubtype) ? globalThis.String(object.insightSubtype) : "",
      content: isObject(object.content) ? object.content : undefined,
      lastRefreshTime: isSet(object.lastRefreshTime) ? fromJsonTimestamp(object.lastRefreshTime) : undefined,
      observationPeriod: isSet(object.observationPeriod) ? Duration.fromJSON(object.observationPeriod) : undefined,
      stateInfo: isSet(object.stateInfo) ? InsightStateInfo.fromJSON(object.stateInfo) : undefined,
      category: isSet(object.category) ? insight_CategoryFromJSON(object.category) : 0,
      severity: isSet(object.severity) ? insight_SeverityFromJSON(object.severity) : 0,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      associatedRecommendations: globalThis.Array.isArray(object?.associatedRecommendations)
        ? object.associatedRecommendations.map((e: any) => Insight_RecommendationReference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Insight): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.targetResources?.length) {
      obj.targetResources = message.targetResources;
    }
    if (message.insightSubtype !== "") {
      obj.insightSubtype = message.insightSubtype;
    }
    if (message.content !== undefined) {
      obj.content = message.content;
    }
    if (message.lastRefreshTime !== undefined) {
      obj.lastRefreshTime = message.lastRefreshTime.toISOString();
    }
    if (message.observationPeriod !== undefined) {
      obj.observationPeriod = Duration.toJSON(message.observationPeriod);
    }
    if (message.stateInfo !== undefined) {
      obj.stateInfo = InsightStateInfo.toJSON(message.stateInfo);
    }
    if (message.category !== 0) {
      obj.category = insight_CategoryToJSON(message.category);
    }
    if (message.severity !== 0) {
      obj.severity = insight_SeverityToJSON(message.severity);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.associatedRecommendations?.length) {
      obj.associatedRecommendations = message.associatedRecommendations.map((e) =>
        Insight_RecommendationReference.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<Insight>): Insight {
    return Insight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Insight>): Insight {
    const message = createBaseInsight();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.targetResources = object.targetResources?.map((e) => e) || [];
    message.insightSubtype = object.insightSubtype ?? "";
    message.content = object.content ?? undefined;
    message.lastRefreshTime = object.lastRefreshTime ?? undefined;
    message.observationPeriod = (object.observationPeriod !== undefined && object.observationPeriod !== null)
      ? Duration.fromPartial(object.observationPeriod)
      : undefined;
    message.stateInfo = (object.stateInfo !== undefined && object.stateInfo !== null)
      ? InsightStateInfo.fromPartial(object.stateInfo)
      : undefined;
    message.category = object.category ?? 0;
    message.severity = object.severity ?? 0;
    message.etag = object.etag ?? "";
    message.associatedRecommendations =
      object.associatedRecommendations?.map((e) => Insight_RecommendationReference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInsight_RecommendationReference(): Insight_RecommendationReference {
  return { recommendation: "" };
}

export const Insight_RecommendationReference: MessageFns<Insight_RecommendationReference> = {
  encode(message: Insight_RecommendationReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recommendation !== "") {
      writer.uint32(10).string(message.recommendation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Insight_RecommendationReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsight_RecommendationReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.recommendation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Insight_RecommendationReference {
    return { recommendation: isSet(object.recommendation) ? globalThis.String(object.recommendation) : "" };
  },

  toJSON(message: Insight_RecommendationReference): unknown {
    const obj: any = {};
    if (message.recommendation !== "") {
      obj.recommendation = message.recommendation;
    }
    return obj;
  },

  create(base?: DeepPartial<Insight_RecommendationReference>): Insight_RecommendationReference {
    return Insight_RecommendationReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Insight_RecommendationReference>): Insight_RecommendationReference {
    const message = createBaseInsight_RecommendationReference();
    message.recommendation = object.recommendation ?? "";
    return message;
  },
};

function createBaseInsightStateInfo(): InsightStateInfo {
  return { state: 0, stateMetadata: {} };
}

export const InsightStateInfo: MessageFns<InsightStateInfo> = {
  encode(message: InsightStateInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    Object.entries(message.stateMetadata).forEach(([key, value]) => {
      InsightStateInfo_StateMetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsightStateInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsightStateInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = InsightStateInfo_StateMetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.stateMetadata[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsightStateInfo {
    return {
      state: isSet(object.state) ? insightStateInfo_StateFromJSON(object.state) : 0,
      stateMetadata: isObject(object.stateMetadata)
        ? Object.entries(object.stateMetadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: InsightStateInfo): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = insightStateInfo_StateToJSON(message.state);
    }
    if (message.stateMetadata) {
      const entries = Object.entries(message.stateMetadata);
      if (entries.length > 0) {
        obj.stateMetadata = {};
        entries.forEach(([k, v]) => {
          obj.stateMetadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<InsightStateInfo>): InsightStateInfo {
    return InsightStateInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsightStateInfo>): InsightStateInfo {
    const message = createBaseInsightStateInfo();
    message.state = object.state ?? 0;
    message.stateMetadata = Object.entries(object.stateMetadata ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseInsightStateInfo_StateMetadataEntry(): InsightStateInfo_StateMetadataEntry {
  return { key: "", value: "" };
}

export const InsightStateInfo_StateMetadataEntry: MessageFns<InsightStateInfo_StateMetadataEntry> = {
  encode(message: InsightStateInfo_StateMetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsightStateInfo_StateMetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsightStateInfo_StateMetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsightStateInfo_StateMetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: InsightStateInfo_StateMetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<InsightStateInfo_StateMetadataEntry>): InsightStateInfo_StateMetadataEntry {
    return InsightStateInfo_StateMetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsightStateInfo_StateMetadataEntry>): InsightStateInfo_StateMetadataEntry {
    const message = createBaseInsightStateInfo_StateMetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
