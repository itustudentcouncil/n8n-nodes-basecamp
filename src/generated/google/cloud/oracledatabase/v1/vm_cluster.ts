// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/oracledatabase/v1/vm_cluster.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { TimeZone } from "../../../type/datetime.js";

export const protobufPackage = "google.cloud.oracledatabase.v1";

/**
 * Details of the Cloud VM Cluster resource.
 * https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/CloudVmCluster/
 */
export interface CloudVmCluster {
  /**
   * Identifier. The name of the VM Cluster resource with the format:
   * projects/{project}/locations/{region}/cloudVmClusters/{cloud_vm_cluster}
   */
  name: string;
  /**
   * Required. The name of the Exadata Infrastructure resource on which VM
   * cluster resource is created, in the following format:
   * projects/{project}/locations/{region}/cloudExadataInfrastuctures/{cloud_extradata_infrastructure}
   */
  exadataInfrastructure: string;
  /** Optional. User friendly name for this resource. */
  displayName: string;
  /**
   * Output only. Google Cloud Platform location where Oracle Exadata is hosted.
   * It is same as Google Cloud Platform Oracle zone of Exadata infrastructure.
   */
  gcpOracleZone: string;
  /** Optional. Various properties of the VM Cluster. */
  properties:
    | CloudVmClusterProperties
    | undefined;
  /** Optional. Labels or tags associated with the VM Cluster. */
  labels: { [key: string]: string };
  /** Output only. The date and time that the VM cluster was created. */
  createTime:
    | Date
    | undefined;
  /** Required. Network settings. CIDR to use for cluster IP allocation. */
  cidr: string;
  /** Required. CIDR range of the backup subnet. */
  backupSubnetCidr: string;
  /**
   * Required. The name of the VPC network.
   * Format: projects/{project}/global/networks/{network}
   */
  network: string;
}

export interface CloudVmCluster_LabelsEntry {
  key: string;
  value: string;
}

/** Various properties and settings associated with Exadata VM cluster. */
export interface CloudVmClusterProperties {
  /** Output only. Oracle Cloud Infrastructure ID of VM Cluster. */
  ocid: string;
  /** Required. License type of VM Cluster. */
  licenseType: CloudVmClusterProperties_LicenseType;
  /** Optional. Grid Infrastructure Version. */
  giVersion: string;
  /** Optional. Time zone of VM Cluster to set. Defaults to UTC if not specified. */
  timeZone:
    | TimeZone
    | undefined;
  /** Optional. SSH public keys to be stored with cluster. */
  sshPublicKeys: string[];
  /** Optional. Number of database servers. */
  nodeCount: number;
  /** Output only. Shape of VM Cluster. */
  shape: string;
  /** Optional. OCPU count per VM. Minimum is 0.1. */
  ocpuCount: number;
  /** Optional. Memory allocated in GBs. */
  memorySizeGb: number;
  /** Optional. Local storage per VM. */
  dbNodeStorageSizeGb: number;
  /** Output only. The storage allocation for the disk group, in gigabytes (GB). */
  storageSizeGb: number;
  /** Optional. The data disk group size to be allocated in TBs. */
  dataStorageSizeTb: number;
  /** Optional. The type of redundancy. */
  diskRedundancy: CloudVmClusterProperties_DiskRedundancy;
  /** Optional. Use exadata sparse snapshots. */
  sparseDiskgroupEnabled: boolean;
  /** Optional. Use local backup. */
  localBackupEnabled: boolean;
  /** Optional. Prefix for VM cluster host names. */
  hostnamePrefix: string;
  /** Optional. Data collection options for diagnostics. */
  diagnosticsDataCollectionOptions:
    | DataCollectionOptions
    | undefined;
  /** Output only. State of the cluster. */
  state: CloudVmClusterProperties_State;
  /** Output only. SCAN listener port - TCP */
  scanListenerPortTcp: number;
  /** Output only. SCAN listener port - TLS */
  scanListenerPortTcpSsl: number;
  /**
   * Output only. Parent DNS domain where SCAN DNS and hosts names are
   * qualified. ex: ocispdelegated.ocisp10jvnet.oraclevcn.com
   */
  domain: string;
  /**
   * Output only. SCAN DNS name.
   * ex: sp2-yi0xq-scan.ocispdelegated.ocisp10jvnet.oraclevcn.com
   */
  scanDns: string;
  /**
   * Output only. host name without domain.
   * format: "<hostname_prefix>-" with some suffix.
   * ex: sp2-yi0xq where "sp2" is the hostname_prefix.
   */
  hostname: string;
  /** Required. Number of enabled CPU cores. */
  cpuCoreCount: number;
  /** Output only. Operating system version of the image. */
  systemVersion: string;
  /** Output only. OCIDs of scan IPs. */
  scanIpIds: string[];
  /** Output only. OCID of scan DNS record. */
  scanDnsRecordId: string;
  /** Output only. Deep link to the OCI console to view this resource. */
  ociUrl: string;
  /** Optional. OCID of database servers. */
  dbServerOcids: string[];
  /** Output only. Compartment ID of cluster. */
  compartmentId: string;
  /** Output only. DNS listener IP. */
  dnsListenerIp: string;
  /** Optional. OCI Cluster name. */
  clusterName: string;
}

/** Different licenses supported. */
export enum CloudVmClusterProperties_LicenseType {
  /** LICENSE_TYPE_UNSPECIFIED - Unspecified */
  LICENSE_TYPE_UNSPECIFIED = 0,
  /** LICENSE_INCLUDED - License included part of offer */
  LICENSE_INCLUDED = 1,
  /** BRING_YOUR_OWN_LICENSE - Bring your own license */
  BRING_YOUR_OWN_LICENSE = 2,
  UNRECOGNIZED = -1,
}

export function cloudVmClusterProperties_LicenseTypeFromJSON(object: any): CloudVmClusterProperties_LicenseType {
  switch (object) {
    case 0:
    case "LICENSE_TYPE_UNSPECIFIED":
      return CloudVmClusterProperties_LicenseType.LICENSE_TYPE_UNSPECIFIED;
    case 1:
    case "LICENSE_INCLUDED":
      return CloudVmClusterProperties_LicenseType.LICENSE_INCLUDED;
    case 2:
    case "BRING_YOUR_OWN_LICENSE":
      return CloudVmClusterProperties_LicenseType.BRING_YOUR_OWN_LICENSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CloudVmClusterProperties_LicenseType.UNRECOGNIZED;
  }
}

export function cloudVmClusterProperties_LicenseTypeToJSON(object: CloudVmClusterProperties_LicenseType): string {
  switch (object) {
    case CloudVmClusterProperties_LicenseType.LICENSE_TYPE_UNSPECIFIED:
      return "LICENSE_TYPE_UNSPECIFIED";
    case CloudVmClusterProperties_LicenseType.LICENSE_INCLUDED:
      return "LICENSE_INCLUDED";
    case CloudVmClusterProperties_LicenseType.BRING_YOUR_OWN_LICENSE:
      return "BRING_YOUR_OWN_LICENSE";
    case CloudVmClusterProperties_LicenseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Types of disk redundancy provided by Oracle. */
export enum CloudVmClusterProperties_DiskRedundancy {
  /** DISK_REDUNDANCY_UNSPECIFIED - Unspecified. */
  DISK_REDUNDANCY_UNSPECIFIED = 0,
  /** HIGH - High -  3 way mirror. */
  HIGH = 1,
  /** NORMAL - Normal - 2 way mirror. */
  NORMAL = 2,
  UNRECOGNIZED = -1,
}

export function cloudVmClusterProperties_DiskRedundancyFromJSON(object: any): CloudVmClusterProperties_DiskRedundancy {
  switch (object) {
    case 0:
    case "DISK_REDUNDANCY_UNSPECIFIED":
      return CloudVmClusterProperties_DiskRedundancy.DISK_REDUNDANCY_UNSPECIFIED;
    case 1:
    case "HIGH":
      return CloudVmClusterProperties_DiskRedundancy.HIGH;
    case 2:
    case "NORMAL":
      return CloudVmClusterProperties_DiskRedundancy.NORMAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CloudVmClusterProperties_DiskRedundancy.UNRECOGNIZED;
  }
}

export function cloudVmClusterProperties_DiskRedundancyToJSON(object: CloudVmClusterProperties_DiskRedundancy): string {
  switch (object) {
    case CloudVmClusterProperties_DiskRedundancy.DISK_REDUNDANCY_UNSPECIFIED:
      return "DISK_REDUNDANCY_UNSPECIFIED";
    case CloudVmClusterProperties_DiskRedundancy.HIGH:
      return "HIGH";
    case CloudVmClusterProperties_DiskRedundancy.NORMAL:
      return "NORMAL";
    case CloudVmClusterProperties_DiskRedundancy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The various lifecycle states of the VM cluster. */
export enum CloudVmClusterProperties_State {
  /** STATE_UNSPECIFIED - Default unspecified value. */
  STATE_UNSPECIFIED = 0,
  /** PROVISIONING - Indicates that the resource is in provisioning state. */
  PROVISIONING = 1,
  /** AVAILABLE - Indicates that the resource is in available state. */
  AVAILABLE = 2,
  /** UPDATING - Indicates that the resource is in updating state. */
  UPDATING = 3,
  /** TERMINATING - Indicates that the resource is in terminating state. */
  TERMINATING = 4,
  /** TERMINATED - Indicates that the resource is in terminated state. */
  TERMINATED = 5,
  /** FAILED - Indicates that the resource is in failed state. */
  FAILED = 6,
  /** MAINTENANCE_IN_PROGRESS - Indicates that the resource is in maintenance in progress state. */
  MAINTENANCE_IN_PROGRESS = 7,
  UNRECOGNIZED = -1,
}

export function cloudVmClusterProperties_StateFromJSON(object: any): CloudVmClusterProperties_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return CloudVmClusterProperties_State.STATE_UNSPECIFIED;
    case 1:
    case "PROVISIONING":
      return CloudVmClusterProperties_State.PROVISIONING;
    case 2:
    case "AVAILABLE":
      return CloudVmClusterProperties_State.AVAILABLE;
    case 3:
    case "UPDATING":
      return CloudVmClusterProperties_State.UPDATING;
    case 4:
    case "TERMINATING":
      return CloudVmClusterProperties_State.TERMINATING;
    case 5:
    case "TERMINATED":
      return CloudVmClusterProperties_State.TERMINATED;
    case 6:
    case "FAILED":
      return CloudVmClusterProperties_State.FAILED;
    case 7:
    case "MAINTENANCE_IN_PROGRESS":
      return CloudVmClusterProperties_State.MAINTENANCE_IN_PROGRESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CloudVmClusterProperties_State.UNRECOGNIZED;
  }
}

export function cloudVmClusterProperties_StateToJSON(object: CloudVmClusterProperties_State): string {
  switch (object) {
    case CloudVmClusterProperties_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case CloudVmClusterProperties_State.PROVISIONING:
      return "PROVISIONING";
    case CloudVmClusterProperties_State.AVAILABLE:
      return "AVAILABLE";
    case CloudVmClusterProperties_State.UPDATING:
      return "UPDATING";
    case CloudVmClusterProperties_State.TERMINATING:
      return "TERMINATING";
    case CloudVmClusterProperties_State.TERMINATED:
      return "TERMINATED";
    case CloudVmClusterProperties_State.FAILED:
      return "FAILED";
    case CloudVmClusterProperties_State.MAINTENANCE_IN_PROGRESS:
      return "MAINTENANCE_IN_PROGRESS";
    case CloudVmClusterProperties_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Data collection options for diagnostics. */
export interface DataCollectionOptions {
  /**
   * Optional. Indicates whether diagnostic collection is enabled for the VM
   * cluster
   */
  diagnosticsEventsEnabled: boolean;
  /** Optional. Indicates whether health monitoring is enabled for the VM cluster */
  healthMonitoringEnabled: boolean;
  /**
   * Optional. Indicates whether incident logs and trace collection are enabled
   * for the VM cluster
   */
  incidentLogsEnabled: boolean;
}

function createBaseCloudVmCluster(): CloudVmCluster {
  return {
    name: "",
    exadataInfrastructure: "",
    displayName: "",
    gcpOracleZone: "",
    properties: undefined,
    labels: {},
    createTime: undefined,
    cidr: "",
    backupSubnetCidr: "",
    network: "",
  };
}

export const CloudVmCluster: MessageFns<CloudVmCluster> = {
  encode(message: CloudVmCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.exadataInfrastructure !== "") {
      writer.uint32(18).string(message.exadataInfrastructure);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.gcpOracleZone !== "") {
      writer.uint32(98).string(message.gcpOracleZone);
    }
    if (message.properties !== undefined) {
      CloudVmClusterProperties.encode(message.properties, writer.uint32(50).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CloudVmCluster_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.cidr !== "") {
      writer.uint32(74).string(message.cidr);
    }
    if (message.backupSubnetCidr !== "") {
      writer.uint32(82).string(message.backupSubnetCidr);
    }
    if (message.network !== "") {
      writer.uint32(90).string(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudVmCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudVmCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exadataInfrastructure = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.gcpOracleZone = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.properties = CloudVmClusterProperties.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = CloudVmCluster_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.cidr = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.backupSubnetCidr = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.network = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudVmCluster {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      exadataInfrastructure: isSet(object.exadataInfrastructure) ? globalThis.String(object.exadataInfrastructure) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      gcpOracleZone: isSet(object.gcpOracleZone) ? globalThis.String(object.gcpOracleZone) : "",
      properties: isSet(object.properties) ? CloudVmClusterProperties.fromJSON(object.properties) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      cidr: isSet(object.cidr) ? globalThis.String(object.cidr) : "",
      backupSubnetCidr: isSet(object.backupSubnetCidr) ? globalThis.String(object.backupSubnetCidr) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
    };
  },

  toJSON(message: CloudVmCluster): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.exadataInfrastructure !== "") {
      obj.exadataInfrastructure = message.exadataInfrastructure;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.gcpOracleZone !== "") {
      obj.gcpOracleZone = message.gcpOracleZone;
    }
    if (message.properties !== undefined) {
      obj.properties = CloudVmClusterProperties.toJSON(message.properties);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.cidr !== "") {
      obj.cidr = message.cidr;
    }
    if (message.backupSubnetCidr !== "") {
      obj.backupSubnetCidr = message.backupSubnetCidr;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudVmCluster>): CloudVmCluster {
    return CloudVmCluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudVmCluster>): CloudVmCluster {
    const message = createBaseCloudVmCluster();
    message.name = object.name ?? "";
    message.exadataInfrastructure = object.exadataInfrastructure ?? "";
    message.displayName = object.displayName ?? "";
    message.gcpOracleZone = object.gcpOracleZone ?? "";
    message.properties = (object.properties !== undefined && object.properties !== null)
      ? CloudVmClusterProperties.fromPartial(object.properties)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.cidr = object.cidr ?? "";
    message.backupSubnetCidr = object.backupSubnetCidr ?? "";
    message.network = object.network ?? "";
    return message;
  },
};

function createBaseCloudVmCluster_LabelsEntry(): CloudVmCluster_LabelsEntry {
  return { key: "", value: "" };
}

export const CloudVmCluster_LabelsEntry: MessageFns<CloudVmCluster_LabelsEntry> = {
  encode(message: CloudVmCluster_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudVmCluster_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudVmCluster_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudVmCluster_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CloudVmCluster_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudVmCluster_LabelsEntry>): CloudVmCluster_LabelsEntry {
    return CloudVmCluster_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudVmCluster_LabelsEntry>): CloudVmCluster_LabelsEntry {
    const message = createBaseCloudVmCluster_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCloudVmClusterProperties(): CloudVmClusterProperties {
  return {
    ocid: "",
    licenseType: 0,
    giVersion: "",
    timeZone: undefined,
    sshPublicKeys: [],
    nodeCount: 0,
    shape: "",
    ocpuCount: 0,
    memorySizeGb: 0,
    dbNodeStorageSizeGb: 0,
    storageSizeGb: 0,
    dataStorageSizeTb: 0,
    diskRedundancy: 0,
    sparseDiskgroupEnabled: false,
    localBackupEnabled: false,
    hostnamePrefix: "",
    diagnosticsDataCollectionOptions: undefined,
    state: 0,
    scanListenerPortTcp: 0,
    scanListenerPortTcpSsl: 0,
    domain: "",
    scanDns: "",
    hostname: "",
    cpuCoreCount: 0,
    systemVersion: "",
    scanIpIds: [],
    scanDnsRecordId: "",
    ociUrl: "",
    dbServerOcids: [],
    compartmentId: "",
    dnsListenerIp: "",
    clusterName: "",
  };
}

export const CloudVmClusterProperties: MessageFns<CloudVmClusterProperties> = {
  encode(message: CloudVmClusterProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ocid !== "") {
      writer.uint32(10).string(message.ocid);
    }
    if (message.licenseType !== 0) {
      writer.uint32(16).int32(message.licenseType);
    }
    if (message.giVersion !== "") {
      writer.uint32(26).string(message.giVersion);
    }
    if (message.timeZone !== undefined) {
      TimeZone.encode(message.timeZone, writer.uint32(34).fork()).join();
    }
    for (const v of message.sshPublicKeys) {
      writer.uint32(42).string(v!);
    }
    if (message.nodeCount !== 0) {
      writer.uint32(48).int32(message.nodeCount);
    }
    if (message.shape !== "") {
      writer.uint32(58).string(message.shape);
    }
    if (message.ocpuCount !== 0) {
      writer.uint32(69).float(message.ocpuCount);
    }
    if (message.memorySizeGb !== 0) {
      writer.uint32(72).int32(message.memorySizeGb);
    }
    if (message.dbNodeStorageSizeGb !== 0) {
      writer.uint32(80).int32(message.dbNodeStorageSizeGb);
    }
    if (message.storageSizeGb !== 0) {
      writer.uint32(88).int32(message.storageSizeGb);
    }
    if (message.dataStorageSizeTb !== 0) {
      writer.uint32(97).double(message.dataStorageSizeTb);
    }
    if (message.diskRedundancy !== 0) {
      writer.uint32(104).int32(message.diskRedundancy);
    }
    if (message.sparseDiskgroupEnabled !== false) {
      writer.uint32(112).bool(message.sparseDiskgroupEnabled);
    }
    if (message.localBackupEnabled !== false) {
      writer.uint32(120).bool(message.localBackupEnabled);
    }
    if (message.hostnamePrefix !== "") {
      writer.uint32(130).string(message.hostnamePrefix);
    }
    if (message.diagnosticsDataCollectionOptions !== undefined) {
      DataCollectionOptions.encode(message.diagnosticsDataCollectionOptions, writer.uint32(154).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(160).int32(message.state);
    }
    if (message.scanListenerPortTcp !== 0) {
      writer.uint32(168).int32(message.scanListenerPortTcp);
    }
    if (message.scanListenerPortTcpSsl !== 0) {
      writer.uint32(176).int32(message.scanListenerPortTcpSsl);
    }
    if (message.domain !== "") {
      writer.uint32(186).string(message.domain);
    }
    if (message.scanDns !== "") {
      writer.uint32(194).string(message.scanDns);
    }
    if (message.hostname !== "") {
      writer.uint32(202).string(message.hostname);
    }
    if (message.cpuCoreCount !== 0) {
      writer.uint32(208).int32(message.cpuCoreCount);
    }
    if (message.systemVersion !== "") {
      writer.uint32(218).string(message.systemVersion);
    }
    for (const v of message.scanIpIds) {
      writer.uint32(226).string(v!);
    }
    if (message.scanDnsRecordId !== "") {
      writer.uint32(234).string(message.scanDnsRecordId);
    }
    if (message.ociUrl !== "") {
      writer.uint32(242).string(message.ociUrl);
    }
    for (const v of message.dbServerOcids) {
      writer.uint32(250).string(v!);
    }
    if (message.compartmentId !== "") {
      writer.uint32(258).string(message.compartmentId);
    }
    if (message.dnsListenerIp !== "") {
      writer.uint32(282).string(message.dnsListenerIp);
    }
    if (message.clusterName !== "") {
      writer.uint32(290).string(message.clusterName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudVmClusterProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudVmClusterProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ocid = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.licenseType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.giVersion = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timeZone = TimeZone.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sshPublicKeys.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.shape = reader.string();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.ocpuCount = reader.float();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.memorySizeGb = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.dbNodeStorageSizeGb = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.storageSizeGb = reader.int32();
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.dataStorageSizeTb = reader.double();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.diskRedundancy = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.sparseDiskgroupEnabled = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.localBackupEnabled = reader.bool();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.hostnamePrefix = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.diagnosticsDataCollectionOptions = DataCollectionOptions.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.scanListenerPortTcp = reader.int32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.scanListenerPortTcpSsl = reader.int32();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.domain = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.scanDns = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.cpuCoreCount = reader.int32();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.systemVersion = reader.string();
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.scanIpIds.push(reader.string());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.scanDnsRecordId = reader.string();
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.ociUrl = reader.string();
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.dbServerOcids.push(reader.string());
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.compartmentId = reader.string();
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.dnsListenerIp = reader.string();
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.clusterName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudVmClusterProperties {
    return {
      ocid: isSet(object.ocid) ? globalThis.String(object.ocid) : "",
      licenseType: isSet(object.licenseType) ? cloudVmClusterProperties_LicenseTypeFromJSON(object.licenseType) : 0,
      giVersion: isSet(object.giVersion) ? globalThis.String(object.giVersion) : "",
      timeZone: isSet(object.timeZone) ? TimeZone.fromJSON(object.timeZone) : undefined,
      sshPublicKeys: globalThis.Array.isArray(object?.sshPublicKeys)
        ? object.sshPublicKeys.map((e: any) => globalThis.String(e))
        : [],
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      shape: isSet(object.shape) ? globalThis.String(object.shape) : "",
      ocpuCount: isSet(object.ocpuCount) ? globalThis.Number(object.ocpuCount) : 0,
      memorySizeGb: isSet(object.memorySizeGb) ? globalThis.Number(object.memorySizeGb) : 0,
      dbNodeStorageSizeGb: isSet(object.dbNodeStorageSizeGb) ? globalThis.Number(object.dbNodeStorageSizeGb) : 0,
      storageSizeGb: isSet(object.storageSizeGb) ? globalThis.Number(object.storageSizeGb) : 0,
      dataStorageSizeTb: isSet(object.dataStorageSizeTb) ? globalThis.Number(object.dataStorageSizeTb) : 0,
      diskRedundancy: isSet(object.diskRedundancy)
        ? cloudVmClusterProperties_DiskRedundancyFromJSON(object.diskRedundancy)
        : 0,
      sparseDiskgroupEnabled: isSet(object.sparseDiskgroupEnabled)
        ? globalThis.Boolean(object.sparseDiskgroupEnabled)
        : false,
      localBackupEnabled: isSet(object.localBackupEnabled) ? globalThis.Boolean(object.localBackupEnabled) : false,
      hostnamePrefix: isSet(object.hostnamePrefix) ? globalThis.String(object.hostnamePrefix) : "",
      diagnosticsDataCollectionOptions: isSet(object.diagnosticsDataCollectionOptions)
        ? DataCollectionOptions.fromJSON(object.diagnosticsDataCollectionOptions)
        : undefined,
      state: isSet(object.state) ? cloudVmClusterProperties_StateFromJSON(object.state) : 0,
      scanListenerPortTcp: isSet(object.scanListenerPortTcp) ? globalThis.Number(object.scanListenerPortTcp) : 0,
      scanListenerPortTcpSsl: isSet(object.scanListenerPortTcpSsl)
        ? globalThis.Number(object.scanListenerPortTcpSsl)
        : 0,
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      scanDns: isSet(object.scanDns) ? globalThis.String(object.scanDns) : "",
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      cpuCoreCount: isSet(object.cpuCoreCount) ? globalThis.Number(object.cpuCoreCount) : 0,
      systemVersion: isSet(object.systemVersion) ? globalThis.String(object.systemVersion) : "",
      scanIpIds: globalThis.Array.isArray(object?.scanIpIds)
        ? object.scanIpIds.map((e: any) => globalThis.String(e))
        : [],
      scanDnsRecordId: isSet(object.scanDnsRecordId) ? globalThis.String(object.scanDnsRecordId) : "",
      ociUrl: isSet(object.ociUrl) ? globalThis.String(object.ociUrl) : "",
      dbServerOcids: globalThis.Array.isArray(object?.dbServerOcids)
        ? object.dbServerOcids.map((e: any) => globalThis.String(e))
        : [],
      compartmentId: isSet(object.compartmentId) ? globalThis.String(object.compartmentId) : "",
      dnsListenerIp: isSet(object.dnsListenerIp) ? globalThis.String(object.dnsListenerIp) : "",
      clusterName: isSet(object.clusterName) ? globalThis.String(object.clusterName) : "",
    };
  },

  toJSON(message: CloudVmClusterProperties): unknown {
    const obj: any = {};
    if (message.ocid !== "") {
      obj.ocid = message.ocid;
    }
    if (message.licenseType !== 0) {
      obj.licenseType = cloudVmClusterProperties_LicenseTypeToJSON(message.licenseType);
    }
    if (message.giVersion !== "") {
      obj.giVersion = message.giVersion;
    }
    if (message.timeZone !== undefined) {
      obj.timeZone = TimeZone.toJSON(message.timeZone);
    }
    if (message.sshPublicKeys?.length) {
      obj.sshPublicKeys = message.sshPublicKeys;
    }
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.shape !== "") {
      obj.shape = message.shape;
    }
    if (message.ocpuCount !== 0) {
      obj.ocpuCount = message.ocpuCount;
    }
    if (message.memorySizeGb !== 0) {
      obj.memorySizeGb = Math.round(message.memorySizeGb);
    }
    if (message.dbNodeStorageSizeGb !== 0) {
      obj.dbNodeStorageSizeGb = Math.round(message.dbNodeStorageSizeGb);
    }
    if (message.storageSizeGb !== 0) {
      obj.storageSizeGb = Math.round(message.storageSizeGb);
    }
    if (message.dataStorageSizeTb !== 0) {
      obj.dataStorageSizeTb = message.dataStorageSizeTb;
    }
    if (message.diskRedundancy !== 0) {
      obj.diskRedundancy = cloudVmClusterProperties_DiskRedundancyToJSON(message.diskRedundancy);
    }
    if (message.sparseDiskgroupEnabled !== false) {
      obj.sparseDiskgroupEnabled = message.sparseDiskgroupEnabled;
    }
    if (message.localBackupEnabled !== false) {
      obj.localBackupEnabled = message.localBackupEnabled;
    }
    if (message.hostnamePrefix !== "") {
      obj.hostnamePrefix = message.hostnamePrefix;
    }
    if (message.diagnosticsDataCollectionOptions !== undefined) {
      obj.diagnosticsDataCollectionOptions = DataCollectionOptions.toJSON(message.diagnosticsDataCollectionOptions);
    }
    if (message.state !== 0) {
      obj.state = cloudVmClusterProperties_StateToJSON(message.state);
    }
    if (message.scanListenerPortTcp !== 0) {
      obj.scanListenerPortTcp = Math.round(message.scanListenerPortTcp);
    }
    if (message.scanListenerPortTcpSsl !== 0) {
      obj.scanListenerPortTcpSsl = Math.round(message.scanListenerPortTcpSsl);
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.scanDns !== "") {
      obj.scanDns = message.scanDns;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.cpuCoreCount !== 0) {
      obj.cpuCoreCount = Math.round(message.cpuCoreCount);
    }
    if (message.systemVersion !== "") {
      obj.systemVersion = message.systemVersion;
    }
    if (message.scanIpIds?.length) {
      obj.scanIpIds = message.scanIpIds;
    }
    if (message.scanDnsRecordId !== "") {
      obj.scanDnsRecordId = message.scanDnsRecordId;
    }
    if (message.ociUrl !== "") {
      obj.ociUrl = message.ociUrl;
    }
    if (message.dbServerOcids?.length) {
      obj.dbServerOcids = message.dbServerOcids;
    }
    if (message.compartmentId !== "") {
      obj.compartmentId = message.compartmentId;
    }
    if (message.dnsListenerIp !== "") {
      obj.dnsListenerIp = message.dnsListenerIp;
    }
    if (message.clusterName !== "") {
      obj.clusterName = message.clusterName;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudVmClusterProperties>): CloudVmClusterProperties {
    return CloudVmClusterProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudVmClusterProperties>): CloudVmClusterProperties {
    const message = createBaseCloudVmClusterProperties();
    message.ocid = object.ocid ?? "";
    message.licenseType = object.licenseType ?? 0;
    message.giVersion = object.giVersion ?? "";
    message.timeZone = (object.timeZone !== undefined && object.timeZone !== null)
      ? TimeZone.fromPartial(object.timeZone)
      : undefined;
    message.sshPublicKeys = object.sshPublicKeys?.map((e) => e) || [];
    message.nodeCount = object.nodeCount ?? 0;
    message.shape = object.shape ?? "";
    message.ocpuCount = object.ocpuCount ?? 0;
    message.memorySizeGb = object.memorySizeGb ?? 0;
    message.dbNodeStorageSizeGb = object.dbNodeStorageSizeGb ?? 0;
    message.storageSizeGb = object.storageSizeGb ?? 0;
    message.dataStorageSizeTb = object.dataStorageSizeTb ?? 0;
    message.diskRedundancy = object.diskRedundancy ?? 0;
    message.sparseDiskgroupEnabled = object.sparseDiskgroupEnabled ?? false;
    message.localBackupEnabled = object.localBackupEnabled ?? false;
    message.hostnamePrefix = object.hostnamePrefix ?? "";
    message.diagnosticsDataCollectionOptions =
      (object.diagnosticsDataCollectionOptions !== undefined && object.diagnosticsDataCollectionOptions !== null)
        ? DataCollectionOptions.fromPartial(object.diagnosticsDataCollectionOptions)
        : undefined;
    message.state = object.state ?? 0;
    message.scanListenerPortTcp = object.scanListenerPortTcp ?? 0;
    message.scanListenerPortTcpSsl = object.scanListenerPortTcpSsl ?? 0;
    message.domain = object.domain ?? "";
    message.scanDns = object.scanDns ?? "";
    message.hostname = object.hostname ?? "";
    message.cpuCoreCount = object.cpuCoreCount ?? 0;
    message.systemVersion = object.systemVersion ?? "";
    message.scanIpIds = object.scanIpIds?.map((e) => e) || [];
    message.scanDnsRecordId = object.scanDnsRecordId ?? "";
    message.ociUrl = object.ociUrl ?? "";
    message.dbServerOcids = object.dbServerOcids?.map((e) => e) || [];
    message.compartmentId = object.compartmentId ?? "";
    message.dnsListenerIp = object.dnsListenerIp ?? "";
    message.clusterName = object.clusterName ?? "";
    return message;
  },
};

function createBaseDataCollectionOptions(): DataCollectionOptions {
  return { diagnosticsEventsEnabled: false, healthMonitoringEnabled: false, incidentLogsEnabled: false };
}

export const DataCollectionOptions: MessageFns<DataCollectionOptions> = {
  encode(message: DataCollectionOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.diagnosticsEventsEnabled !== false) {
      writer.uint32(8).bool(message.diagnosticsEventsEnabled);
    }
    if (message.healthMonitoringEnabled !== false) {
      writer.uint32(16).bool(message.healthMonitoringEnabled);
    }
    if (message.incidentLogsEnabled !== false) {
      writer.uint32(24).bool(message.incidentLogsEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataCollectionOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataCollectionOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.diagnosticsEventsEnabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.healthMonitoringEnabled = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.incidentLogsEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataCollectionOptions {
    return {
      diagnosticsEventsEnabled: isSet(object.diagnosticsEventsEnabled)
        ? globalThis.Boolean(object.diagnosticsEventsEnabled)
        : false,
      healthMonitoringEnabled: isSet(object.healthMonitoringEnabled)
        ? globalThis.Boolean(object.healthMonitoringEnabled)
        : false,
      incidentLogsEnabled: isSet(object.incidentLogsEnabled) ? globalThis.Boolean(object.incidentLogsEnabled) : false,
    };
  },

  toJSON(message: DataCollectionOptions): unknown {
    const obj: any = {};
    if (message.diagnosticsEventsEnabled !== false) {
      obj.diagnosticsEventsEnabled = message.diagnosticsEventsEnabled;
    }
    if (message.healthMonitoringEnabled !== false) {
      obj.healthMonitoringEnabled = message.healthMonitoringEnabled;
    }
    if (message.incidentLogsEnabled !== false) {
      obj.incidentLogsEnabled = message.incidentLogsEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<DataCollectionOptions>): DataCollectionOptions {
    return DataCollectionOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataCollectionOptions>): DataCollectionOptions {
    const message = createBaseDataCollectionOptions();
    message.diagnosticsEventsEnabled = object.diagnosticsEventsEnabled ?? false;
    message.healthMonitoringEnabled = object.healthMonitoringEnabled ?? false;
    message.incidentLogsEnabled = object.incidentLogsEnabled ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
