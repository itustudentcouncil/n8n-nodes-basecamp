// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/iap/v1/service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  GetIamPolicyRequest,
  SetIamPolicyRequest,
  TestIamPermissionsRequest,
  TestIamPermissionsResponse,
} from "../../../iam/v1/iam_policy.js";
import { Policy } from "../../../iam/v1/policy.js";
import { Duration } from "../../../protobuf/duration.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { BoolValue, StringValue } from "../../../protobuf/wrappers.js";

export const protobufPackage = "google.cloud.iap.v1";

/** The request to ListTunnelDestGroups. */
export interface ListTunnelDestGroupsRequest {
  /**
   * Required. Google Cloud Project ID and location.
   * In the following format:
   * `projects/{project_number/id}/iap_tunnel/locations/{location}`.
   * A `-` can be used for the location to group across all locations.
   */
  parent: string;
  /**
   * The maximum number of groups to return. The service might return fewer than
   * this value.
   * If unspecified, at most 100 groups are returned.
   * The maximum value is 1000; values above 1000 are coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListTunnelDestGroups`
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListTunnelDestGroups` must match the call that provided the page
   * token.
   */
  pageToken: string;
}

/** The response from ListTunnelDestGroups. */
export interface ListTunnelDestGroupsResponse {
  /** TunnelDestGroup existing in the project. */
  tunnelDestGroups: TunnelDestGroup[];
  /**
   * A token that you can send as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** The request to CreateTunnelDestGroup. */
export interface CreateTunnelDestGroupRequest {
  /**
   * Required. Google Cloud Project ID and location.
   * In the following format:
   * `projects/{project_number/id}/iap_tunnel/locations/{location}`.
   */
  parent: string;
  /** Required. The TunnelDestGroup to create. */
  tunnelDestGroup:
    | TunnelDestGroup
    | undefined;
  /**
   * Required. The ID to use for the TunnelDestGroup, which becomes the final
   * component of the resource name.
   *
   * This value must be 4-63 characters, and valid characters
   * are `[a-z]-`.
   */
  tunnelDestGroupId: string;
}

/** The request to GetTunnelDestGroup. */
export interface GetTunnelDestGroupRequest {
  /**
   * Required. Name of the TunnelDestGroup to be fetched.
   * In the following format:
   * `projects/{project_number/id}/iap_tunnel/locations/{location}/destGroups/{dest_group}`.
   */
  name: string;
}

/** The request to DeleteTunnelDestGroup. */
export interface DeleteTunnelDestGroupRequest {
  /**
   * Required. Name of the TunnelDestGroup to delete.
   * In the following format:
   * `projects/{project_number/id}/iap_tunnel/locations/{location}/destGroups/{dest_group}`.
   */
  name: string;
}

/** The request to UpdateTunnelDestGroup. */
export interface UpdateTunnelDestGroupRequest {
  /** Required. The new values for the TunnelDestGroup. */
  tunnelDestGroup:
    | TunnelDestGroup
    | undefined;
  /**
   * A field mask that specifies which IAP settings to update.
   * If omitted, then all of the settings are updated. See
   * https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask
   */
  updateMask: string[] | undefined;
}

/** A TunnelDestGroup. */
export interface TunnelDestGroup {
  /**
   * Required. Immutable. Identifier for the TunnelDestGroup. Must be unique
   * within the project and contain only lower case letters (a-z) and dashes
   * (-).
   */
  name: string;
  /** Unordered list. List of CIDRs that this group applies to. */
  cidrs: string[];
  /** Unordered list. List of FQDNs that this group applies to. */
  fqdns: string[];
}

/** The request sent to GetIapSettings. */
export interface GetIapSettingsRequest {
  /**
   * Required. The resource name for which to retrieve the settings.
   * Authorization: Requires the `getSettings` permission for the associated
   * resource.
   */
  name: string;
}

/** The request sent to UpdateIapSettings. */
export interface UpdateIapSettingsRequest {
  /**
   * Required. The new values for the IAP settings to be updated.
   * Authorization: Requires the `updateSettings` permission for the associated
   * resource.
   */
  iapSettings:
    | IapSettings
    | undefined;
  /**
   * The field mask specifying which IAP settings should be updated.
   * If omitted, then all of the settings are updated. See
   * https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask.
   *
   * Note: All IAP reauth settings must always be set together, using the
   * field mask: `iapSettings.accessSettings.reauthSettings`.
   */
  updateMask: string[] | undefined;
}

/** The IAP configurable settings. */
export interface IapSettings {
  /** Required. The resource name of the IAP protected resource. */
  name: string;
  /** Top level wrapper for all access related setting in IAP */
  accessSettings:
    | AccessSettings
    | undefined;
  /** Top level wrapper for all application related settings in IAP */
  applicationSettings: ApplicationSettings | undefined;
}

/** Access related settings for IAP protected apps. */
export interface AccessSettings {
  /** GCIP claims and endpoint configurations for 3p identity providers. */
  gcipSettings:
    | GcipSettings
    | undefined;
  /** Configuration to allow cross-origin requests via IAP. */
  corsSettings:
    | CorsSettings
    | undefined;
  /** Settings to configure IAP's OAuth behavior. */
  oauthSettings:
    | OAuthSettings
    | undefined;
  /** Settings to configure reauthentication policies in IAP. */
  reauthSettings:
    | ReauthSettings
    | undefined;
  /** Settings to configure and enable allowed domains. */
  allowedDomainsSettings: AllowedDomainsSettings | undefined;
}

/** Allows customers to configure tenant_id for GCIP instance per-app. */
export interface GcipSettings {
  /**
   * GCIP tenant ids that are linked to the IAP resource.
   * tenant_ids could be a string beginning with a number character to indicate
   * authenticating with GCIP tenant flow, or in the format of _<ProjectNumber>
   * to indicate authenticating with GCIP agent flow.
   * If agent flow is used, tenant_ids should only contain one single element,
   * while for tenant flow, tenant_ids can contain multiple elements.
   */
  tenantIds: string[];
  /**
   * Login page URI associated with the GCIP tenants.
   * Typically, all resources within the same project share the same login page,
   * though it could be overridden at the sub resource level.
   */
  loginPageUri: string | undefined;
}

/**
 * Allows customers to configure HTTP request paths that'll allow HTTP OPTIONS
 * call to bypass authentication and authorization.
 */
export interface CorsSettings {
  /**
   * Configuration to allow HTTP OPTIONS calls to skip authorization. If
   * undefined, IAP will not apply any special logic to OPTIONS requests.
   */
  allowHttpOptions: boolean | undefined;
}

/**
 * Configuration for OAuth login&consent flow behavior as well as for OAuth
 * Credentials.
 */
export interface OAuthSettings {
  /**
   * Domain hint to send as hd=? parameter in OAuth request flow. Enables
   * redirect to primary IDP by skipping Google's login screen.
   * https://developers.google.com/identity/protocols/OpenIDConnect#hd-param
   * Note: IAP does not verify that the id token's hd claim matches this value
   * since access behavior is managed by IAM policies.
   */
  loginHint:
    | string
    | undefined;
  /** List of OAuth client IDs allowed to programmatically authenticate with IAP. */
  programmaticClients: string[];
}

/** Configuration for IAP reauthentication policies. */
export interface ReauthSettings {
  /** Reauth method requested. */
  method: ReauthSettings_Method;
  /**
   * Reauth session lifetime, how long before a user has to reauthenticate
   * again.
   */
  maxAge:
    | Duration
    | undefined;
  /**
   * How IAP determines the effective policy in cases of hierarchial policies.
   * Policies are merged from higher in the hierarchy to lower in the hierarchy.
   */
  policyType: ReauthSettings_PolicyType;
}

/** Types of reauthentication methods supported by IAP. */
export enum ReauthSettings_Method {
  /** METHOD_UNSPECIFIED - Reauthentication disabled. */
  METHOD_UNSPECIFIED = 0,
  /** LOGIN - Prompts the user to log in again. */
  LOGIN = 1,
  /** @deprecated */
  PASSWORD = 2,
  /** SECURE_KEY - User must use their secure key 2nd factor device. */
  SECURE_KEY = 3,
  /** ENROLLED_SECOND_FACTORS - User can use any enabled 2nd factor. */
  ENROLLED_SECOND_FACTORS = 4,
  UNRECOGNIZED = -1,
}

export function reauthSettings_MethodFromJSON(object: any): ReauthSettings_Method {
  switch (object) {
    case 0:
    case "METHOD_UNSPECIFIED":
      return ReauthSettings_Method.METHOD_UNSPECIFIED;
    case 1:
    case "LOGIN":
      return ReauthSettings_Method.LOGIN;
    case 2:
    case "PASSWORD":
      return ReauthSettings_Method.PASSWORD;
    case 3:
    case "SECURE_KEY":
      return ReauthSettings_Method.SECURE_KEY;
    case 4:
    case "ENROLLED_SECOND_FACTORS":
      return ReauthSettings_Method.ENROLLED_SECOND_FACTORS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReauthSettings_Method.UNRECOGNIZED;
  }
}

export function reauthSettings_MethodToJSON(object: ReauthSettings_Method): string {
  switch (object) {
    case ReauthSettings_Method.METHOD_UNSPECIFIED:
      return "METHOD_UNSPECIFIED";
    case ReauthSettings_Method.LOGIN:
      return "LOGIN";
    case ReauthSettings_Method.PASSWORD:
      return "PASSWORD";
    case ReauthSettings_Method.SECURE_KEY:
      return "SECURE_KEY";
    case ReauthSettings_Method.ENROLLED_SECOND_FACTORS:
      return "ENROLLED_SECOND_FACTORS";
    case ReauthSettings_Method.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of policy in the case of hierarchial policies. */
export enum ReauthSettings_PolicyType {
  /** POLICY_TYPE_UNSPECIFIED - Default value. This value is unused. */
  POLICY_TYPE_UNSPECIFIED = 0,
  /**
   * MINIMUM - This policy acts as a minimum to other policies, lower in the hierarchy.
   * Effective policy may only be the same or stricter.
   */
  MINIMUM = 1,
  /** DEFAULT - This policy acts as a default if no other reauth policy is set. */
  DEFAULT = 2,
  UNRECOGNIZED = -1,
}

export function reauthSettings_PolicyTypeFromJSON(object: any): ReauthSettings_PolicyType {
  switch (object) {
    case 0:
    case "POLICY_TYPE_UNSPECIFIED":
      return ReauthSettings_PolicyType.POLICY_TYPE_UNSPECIFIED;
    case 1:
    case "MINIMUM":
      return ReauthSettings_PolicyType.MINIMUM;
    case 2:
    case "DEFAULT":
      return ReauthSettings_PolicyType.DEFAULT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReauthSettings_PolicyType.UNRECOGNIZED;
  }
}

export function reauthSettings_PolicyTypeToJSON(object: ReauthSettings_PolicyType): string {
  switch (object) {
    case ReauthSettings_PolicyType.POLICY_TYPE_UNSPECIFIED:
      return "POLICY_TYPE_UNSPECIFIED";
    case ReauthSettings_PolicyType.MINIMUM:
      return "MINIMUM";
    case ReauthSettings_PolicyType.DEFAULT:
      return "DEFAULT";
    case ReauthSettings_PolicyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Configuration for IAP allowed domains. Lets you to restrict access to an app
 * and allow access to only the domains that you list.
 */
export interface AllowedDomainsSettings {
  /** Configuration for customers to opt in for the feature. */
  enable?:
    | boolean
    | undefined;
  /** List of trusted domains. */
  domains: string[];
}

/** Wrapper over application specific settings for IAP. */
export interface ApplicationSettings {
  /** Settings to configure IAP's behavior for a service mesh. */
  csmSettings:
    | CsmSettings
    | undefined;
  /** Customization for Access Denied page. */
  accessDeniedPageSettings:
    | AccessDeniedPageSettings
    | undefined;
  /**
   * The Domain value to set for cookies generated by IAP. This value is not
   * validated by the API, but will be ignored at runtime if invalid.
   */
  cookieDomain:
    | string
    | undefined;
  /** Settings to configure attribute propagation. */
  attributePropagationSettings: AttributePropagationSettings | undefined;
}

/**
 * Configuration for RCToken generated for service mesh workloads protected by
 * IAP. RCToken are IAP generated JWTs that can be verified at the application.
 * The RCToken is primarily used for service mesh deployments, and can be scoped
 * to a single mesh by configuring the audience field accordingly.
 */
export interface CsmSettings {
  /**
   * Audience claim set in the generated RCToken. This value is not validated by
   * IAP.
   */
  rctokenAud: string | undefined;
}

/**
 * Custom content configuration for access denied page.
 * IAP allows customers to define a custom URI to use as the error page when
 * access is denied to users. If IAP prevents access to this page, the default
 * IAP error page will be displayed instead.
 */
export interface AccessDeniedPageSettings {
  /** The URI to be redirected to when access is denied. */
  accessDeniedPageUri:
    | string
    | undefined;
  /**
   * Whether to generate a troubleshooting URL on access denied events to this
   * application.
   */
  generateTroubleshootingUri:
    | boolean
    | undefined;
  /**
   * Whether to generate remediation token on access denied events to this
   * application.
   */
  remediationTokenGenerationEnabled?: boolean | undefined;
}

/**
 * Configuration for propagating attributes to applications protected
 * by IAP.
 */
export interface AttributePropagationSettings {
  /**
   * Raw string CEL expression. Must return a list of attributes. A maximum of
   * 45 attributes can be selected. Expressions can select different attribute
   * types from `attributes`: `attributes.saml_attributes`,
   * `attributes.iap_attributes`. The following functions are supported:
   *
   *  - filter `<list>.filter(<iter_var>, <predicate>)`: Returns a subset of
   *  `<list>` where `<predicate>` is true for every item.
   *
   *  - in `<var> in <list>`: Returns true if `<list>` contains `<var>`.
   *
   *  - selectByName `<list>.selectByName(<string>)`: Returns the attribute
   *  in
   *  `<list>` with the given `<string>` name, otherwise returns empty.
   *
   *  - emitAs `<attribute>.emitAs(<string>)`: Sets the `<attribute>` name
   *  field to the given `<string>` for propagation in selected output
   *  credentials.
   *
   *  - strict `<attribute>.strict()`: Ignores the `x-goog-iap-attr-` prefix
   *  for the provided `<attribute>` when propagating with the `HEADER` output
   *  credential, such as request headers.
   *
   *  - append `<target_list>.append(<attribute>)` OR
   *  `<target_list>.append(<list>)`: Appends the provided `<attribute>` or
   *  `<list>` to the end of `<target_list>`.
   *
   * Example expression: `attributes.saml_attributes.filter(x, x.name in
   * ['test']).append(attributes.iap_attributes.selectByName('exact').emitAs('custom').strict())`
   */
  expression?:
    | string
    | undefined;
  /**
   * Which output credentials attributes selected by the CEL expression should
   * be propagated in. All attributes will be fully duplicated in each selected
   * output credential.
   */
  outputCredentials: AttributePropagationSettings_OutputCredentials[];
  /**
   * Whether the provided attribute propagation settings should be evaluated on
   * user requests. If set to true, attributes returned from the expression will
   * be propagated in the set output credentials.
   */
  enable?: boolean | undefined;
}

/**
 * Supported output credentials for attribute propagation. Each output
 * credential maps to a "field" in the response. For example, selecting JWT
 * will propagate all attributes in the IAP JWT, header in the headers, etc.
 */
export enum AttributePropagationSettings_OutputCredentials {
  /** OUTPUT_CREDENTIALS_UNSPECIFIED - An output credential is required. */
  OUTPUT_CREDENTIALS_UNSPECIFIED = 0,
  /** HEADER - Propagate attributes in the headers with "x-goog-iap-attr-" prefix. */
  HEADER = 1,
  /**
   * JWT - Propagate attributes in the JWT of the form: `"additional_claims": {
   * "my_attribute": ["value1", "value2"] }`
   */
  JWT = 2,
  /**
   * RCTOKEN - Propagate attributes in the RCToken of the form: `"additional_claims": {
   * "my_attribute": ["value1", "value2"] }`
   */
  RCTOKEN = 3,
  UNRECOGNIZED = -1,
}

export function attributePropagationSettings_OutputCredentialsFromJSON(
  object: any,
): AttributePropagationSettings_OutputCredentials {
  switch (object) {
    case 0:
    case "OUTPUT_CREDENTIALS_UNSPECIFIED":
      return AttributePropagationSettings_OutputCredentials.OUTPUT_CREDENTIALS_UNSPECIFIED;
    case 1:
    case "HEADER":
      return AttributePropagationSettings_OutputCredentials.HEADER;
    case 2:
    case "JWT":
      return AttributePropagationSettings_OutputCredentials.JWT;
    case 3:
    case "RCTOKEN":
      return AttributePropagationSettings_OutputCredentials.RCTOKEN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttributePropagationSettings_OutputCredentials.UNRECOGNIZED;
  }
}

export function attributePropagationSettings_OutputCredentialsToJSON(
  object: AttributePropagationSettings_OutputCredentials,
): string {
  switch (object) {
    case AttributePropagationSettings_OutputCredentials.OUTPUT_CREDENTIALS_UNSPECIFIED:
      return "OUTPUT_CREDENTIALS_UNSPECIFIED";
    case AttributePropagationSettings_OutputCredentials.HEADER:
      return "HEADER";
    case AttributePropagationSettings_OutputCredentials.JWT:
      return "JWT";
    case AttributePropagationSettings_OutputCredentials.RCTOKEN:
      return "RCTOKEN";
    case AttributePropagationSettings_OutputCredentials.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The request sent to ListBrands. */
export interface ListBrandsRequest {
  /**
   * Required. GCP Project number/id.
   * In the following format: projects/{project_number/id}.
   */
  parent: string;
}

/** Response message for ListBrands. */
export interface ListBrandsResponse {
  /** Brands existing in the project. */
  brands: Brand[];
}

/** The request sent to CreateBrand. */
export interface CreateBrandRequest {
  /**
   * Required. GCP Project number/id under which the brand is to be created.
   * In the following format: projects/{project_number/id}.
   */
  parent: string;
  /** Required. The brand to be created. */
  brand: Brand | undefined;
}

/** The request sent to GetBrand. */
export interface GetBrandRequest {
  /**
   * Required. Name of the brand to be fetched.
   * In the following format: projects/{project_number/id}/brands/{brand}.
   */
  name: string;
}

/** The request sent to ListIdentityAwareProxyClients. */
export interface ListIdentityAwareProxyClientsRequest {
  /**
   * Required. Full brand path.
   * In the following format: projects/{project_number/id}/brands/{brand}.
   */
  parent: string;
  /**
   * The maximum number of clients to return. The service may return fewer than
   * this value.
   * If unspecified, at most 100 clients will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListIdentityAwareProxyClients`
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListIdentityAwareProxyClients` must match the call that provided the page
   * token.
   */
  pageToken: string;
}

/** Response message for ListIdentityAwareProxyClients. */
export interface ListIdentityAwareProxyClientsResponse {
  /** Clients existing in the brand. */
  identityAwareProxyClients: IdentityAwareProxyClient[];
  /**
   * A token, which can be send as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** The request sent to CreateIdentityAwareProxyClient. */
export interface CreateIdentityAwareProxyClientRequest {
  /**
   * Required. Path to create the client in.
   * In the following format:
   * projects/{project_number/id}/brands/{brand}.
   * The project must belong to a G Suite account.
   */
  parent: string;
  /** Required. Identity Aware Proxy Client to be created. */
  identityAwareProxyClient: IdentityAwareProxyClient | undefined;
}

/** The request sent to GetIdentityAwareProxyClient. */
export interface GetIdentityAwareProxyClientRequest {
  /**
   * Required. Name of the Identity Aware Proxy client to be fetched.
   * In the following format:
   * projects/{project_number/id}/brands/{brand}/identityAwareProxyClients/{client_id}.
   */
  name: string;
}

/** The request sent to ResetIdentityAwareProxyClientSecret. */
export interface ResetIdentityAwareProxyClientSecretRequest {
  /**
   * Required. Name of the Identity Aware Proxy client to that will have its
   * secret reset. In the following format:
   * projects/{project_number/id}/brands/{brand}/identityAwareProxyClients/{client_id}.
   */
  name: string;
}

/** The request sent to DeleteIdentityAwareProxyClient. */
export interface DeleteIdentityAwareProxyClientRequest {
  /**
   * Required. Name of the Identity Aware Proxy client to be deleted.
   * In the following format:
   * projects/{project_number/id}/brands/{brand}/identityAwareProxyClients/{client_id}.
   */
  name: string;
}

/**
 * OAuth brand data.
 * NOTE: Only contains a portion of the data that describes a brand.
 */
export interface Brand {
  /**
   * Output only. Identifier of the brand.
   * NOTE: GCP project number achieves the same brand identification purpose as
   * only one brand per project can be created.
   */
  name: string;
  /** Support email displayed on the OAuth consent screen. */
  supportEmail: string;
  /** Application name displayed on OAuth consent screen. */
  applicationTitle: string;
  /**
   * Output only. Whether the brand is only intended for usage inside the
   * G Suite organization only.
   */
  orgInternalOnly: boolean;
}

/** Contains the data that describes an Identity Aware Proxy owned client. */
export interface IdentityAwareProxyClient {
  /** Output only. Unique identifier of the OAuth client. */
  name: string;
  /** Output only. Client secret of the OAuth client. */
  secret: string;
  /** Human-friendly name given to the OAuth client. */
  displayName: string;
}

function createBaseListTunnelDestGroupsRequest(): ListTunnelDestGroupsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListTunnelDestGroupsRequest: MessageFns<ListTunnelDestGroupsRequest> = {
  encode(message: ListTunnelDestGroupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTunnelDestGroupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTunnelDestGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTunnelDestGroupsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTunnelDestGroupsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTunnelDestGroupsRequest>): ListTunnelDestGroupsRequest {
    return ListTunnelDestGroupsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTunnelDestGroupsRequest>): ListTunnelDestGroupsRequest {
    const message = createBaseListTunnelDestGroupsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTunnelDestGroupsResponse(): ListTunnelDestGroupsResponse {
  return { tunnelDestGroups: [], nextPageToken: "" };
}

export const ListTunnelDestGroupsResponse: MessageFns<ListTunnelDestGroupsResponse> = {
  encode(message: ListTunnelDestGroupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tunnelDestGroups) {
      TunnelDestGroup.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTunnelDestGroupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTunnelDestGroupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tunnelDestGroups.push(TunnelDestGroup.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTunnelDestGroupsResponse {
    return {
      tunnelDestGroups: globalThis.Array.isArray(object?.tunnelDestGroups)
        ? object.tunnelDestGroups.map((e: any) => TunnelDestGroup.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTunnelDestGroupsResponse): unknown {
    const obj: any = {};
    if (message.tunnelDestGroups?.length) {
      obj.tunnelDestGroups = message.tunnelDestGroups.map((e) => TunnelDestGroup.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTunnelDestGroupsResponse>): ListTunnelDestGroupsResponse {
    return ListTunnelDestGroupsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTunnelDestGroupsResponse>): ListTunnelDestGroupsResponse {
    const message = createBaseListTunnelDestGroupsResponse();
    message.tunnelDestGroups = object.tunnelDestGroups?.map((e) => TunnelDestGroup.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateTunnelDestGroupRequest(): CreateTunnelDestGroupRequest {
  return { parent: "", tunnelDestGroup: undefined, tunnelDestGroupId: "" };
}

export const CreateTunnelDestGroupRequest: MessageFns<CreateTunnelDestGroupRequest> = {
  encode(message: CreateTunnelDestGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.tunnelDestGroup !== undefined) {
      TunnelDestGroup.encode(message.tunnelDestGroup, writer.uint32(18).fork()).join();
    }
    if (message.tunnelDestGroupId !== "") {
      writer.uint32(26).string(message.tunnelDestGroupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTunnelDestGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTunnelDestGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tunnelDestGroup = TunnelDestGroup.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tunnelDestGroupId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTunnelDestGroupRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      tunnelDestGroup: isSet(object.tunnelDestGroup) ? TunnelDestGroup.fromJSON(object.tunnelDestGroup) : undefined,
      tunnelDestGroupId: isSet(object.tunnelDestGroupId) ? globalThis.String(object.tunnelDestGroupId) : "",
    };
  },

  toJSON(message: CreateTunnelDestGroupRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.tunnelDestGroup !== undefined) {
      obj.tunnelDestGroup = TunnelDestGroup.toJSON(message.tunnelDestGroup);
    }
    if (message.tunnelDestGroupId !== "") {
      obj.tunnelDestGroupId = message.tunnelDestGroupId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTunnelDestGroupRequest>): CreateTunnelDestGroupRequest {
    return CreateTunnelDestGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTunnelDestGroupRequest>): CreateTunnelDestGroupRequest {
    const message = createBaseCreateTunnelDestGroupRequest();
    message.parent = object.parent ?? "";
    message.tunnelDestGroup = (object.tunnelDestGroup !== undefined && object.tunnelDestGroup !== null)
      ? TunnelDestGroup.fromPartial(object.tunnelDestGroup)
      : undefined;
    message.tunnelDestGroupId = object.tunnelDestGroupId ?? "";
    return message;
  },
};

function createBaseGetTunnelDestGroupRequest(): GetTunnelDestGroupRequest {
  return { name: "" };
}

export const GetTunnelDestGroupRequest: MessageFns<GetTunnelDestGroupRequest> = {
  encode(message: GetTunnelDestGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTunnelDestGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTunnelDestGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTunnelDestGroupRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTunnelDestGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTunnelDestGroupRequest>): GetTunnelDestGroupRequest {
    return GetTunnelDestGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTunnelDestGroupRequest>): GetTunnelDestGroupRequest {
    const message = createBaseGetTunnelDestGroupRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteTunnelDestGroupRequest(): DeleteTunnelDestGroupRequest {
  return { name: "" };
}

export const DeleteTunnelDestGroupRequest: MessageFns<DeleteTunnelDestGroupRequest> = {
  encode(message: DeleteTunnelDestGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTunnelDestGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTunnelDestGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTunnelDestGroupRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteTunnelDestGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTunnelDestGroupRequest>): DeleteTunnelDestGroupRequest {
    return DeleteTunnelDestGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTunnelDestGroupRequest>): DeleteTunnelDestGroupRequest {
    const message = createBaseDeleteTunnelDestGroupRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateTunnelDestGroupRequest(): UpdateTunnelDestGroupRequest {
  return { tunnelDestGroup: undefined, updateMask: undefined };
}

export const UpdateTunnelDestGroupRequest: MessageFns<UpdateTunnelDestGroupRequest> = {
  encode(message: UpdateTunnelDestGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tunnelDestGroup !== undefined) {
      TunnelDestGroup.encode(message.tunnelDestGroup, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTunnelDestGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTunnelDestGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tunnelDestGroup = TunnelDestGroup.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTunnelDestGroupRequest {
    return {
      tunnelDestGroup: isSet(object.tunnelDestGroup) ? TunnelDestGroup.fromJSON(object.tunnelDestGroup) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateTunnelDestGroupRequest): unknown {
    const obj: any = {};
    if (message.tunnelDestGroup !== undefined) {
      obj.tunnelDestGroup = TunnelDestGroup.toJSON(message.tunnelDestGroup);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTunnelDestGroupRequest>): UpdateTunnelDestGroupRequest {
    return UpdateTunnelDestGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTunnelDestGroupRequest>): UpdateTunnelDestGroupRequest {
    const message = createBaseUpdateTunnelDestGroupRequest();
    message.tunnelDestGroup = (object.tunnelDestGroup !== undefined && object.tunnelDestGroup !== null)
      ? TunnelDestGroup.fromPartial(object.tunnelDestGroup)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseTunnelDestGroup(): TunnelDestGroup {
  return { name: "", cidrs: [], fqdns: [] };
}

export const TunnelDestGroup: MessageFns<TunnelDestGroup> = {
  encode(message: TunnelDestGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.cidrs) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.fqdns) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunnelDestGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelDestGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cidrs.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fqdns.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelDestGroup {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cidrs: globalThis.Array.isArray(object?.cidrs) ? object.cidrs.map((e: any) => globalThis.String(e)) : [],
      fqdns: globalThis.Array.isArray(object?.fqdns) ? object.fqdns.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: TunnelDestGroup): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.cidrs?.length) {
      obj.cidrs = message.cidrs;
    }
    if (message.fqdns?.length) {
      obj.fqdns = message.fqdns;
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelDestGroup>): TunnelDestGroup {
    return TunnelDestGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelDestGroup>): TunnelDestGroup {
    const message = createBaseTunnelDestGroup();
    message.name = object.name ?? "";
    message.cidrs = object.cidrs?.map((e) => e) || [];
    message.fqdns = object.fqdns?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetIapSettingsRequest(): GetIapSettingsRequest {
  return { name: "" };
}

export const GetIapSettingsRequest: MessageFns<GetIapSettingsRequest> = {
  encode(message: GetIapSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIapSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIapSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIapSettingsRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetIapSettingsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetIapSettingsRequest>): GetIapSettingsRequest {
    return GetIapSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetIapSettingsRequest>): GetIapSettingsRequest {
    const message = createBaseGetIapSettingsRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateIapSettingsRequest(): UpdateIapSettingsRequest {
  return { iapSettings: undefined, updateMask: undefined };
}

export const UpdateIapSettingsRequest: MessageFns<UpdateIapSettingsRequest> = {
  encode(message: UpdateIapSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iapSettings !== undefined) {
      IapSettings.encode(message.iapSettings, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateIapSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateIapSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.iapSettings = IapSettings.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateIapSettingsRequest {
    return {
      iapSettings: isSet(object.iapSettings) ? IapSettings.fromJSON(object.iapSettings) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateIapSettingsRequest): unknown {
    const obj: any = {};
    if (message.iapSettings !== undefined) {
      obj.iapSettings = IapSettings.toJSON(message.iapSettings);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateIapSettingsRequest>): UpdateIapSettingsRequest {
    return UpdateIapSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateIapSettingsRequest>): UpdateIapSettingsRequest {
    const message = createBaseUpdateIapSettingsRequest();
    message.iapSettings = (object.iapSettings !== undefined && object.iapSettings !== null)
      ? IapSettings.fromPartial(object.iapSettings)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseIapSettings(): IapSettings {
  return { name: "", accessSettings: undefined, applicationSettings: undefined };
}

export const IapSettings: MessageFns<IapSettings> = {
  encode(message: IapSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.accessSettings !== undefined) {
      AccessSettings.encode(message.accessSettings, writer.uint32(42).fork()).join();
    }
    if (message.applicationSettings !== undefined) {
      ApplicationSettings.encode(message.applicationSettings, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IapSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIapSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.accessSettings = AccessSettings.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.applicationSettings = ApplicationSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IapSettings {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      accessSettings: isSet(object.accessSettings) ? AccessSettings.fromJSON(object.accessSettings) : undefined,
      applicationSettings: isSet(object.applicationSettings)
        ? ApplicationSettings.fromJSON(object.applicationSettings)
        : undefined,
    };
  },

  toJSON(message: IapSettings): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.accessSettings !== undefined) {
      obj.accessSettings = AccessSettings.toJSON(message.accessSettings);
    }
    if (message.applicationSettings !== undefined) {
      obj.applicationSettings = ApplicationSettings.toJSON(message.applicationSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<IapSettings>): IapSettings {
    return IapSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IapSettings>): IapSettings {
    const message = createBaseIapSettings();
    message.name = object.name ?? "";
    message.accessSettings = (object.accessSettings !== undefined && object.accessSettings !== null)
      ? AccessSettings.fromPartial(object.accessSettings)
      : undefined;
    message.applicationSettings = (object.applicationSettings !== undefined && object.applicationSettings !== null)
      ? ApplicationSettings.fromPartial(object.applicationSettings)
      : undefined;
    return message;
  },
};

function createBaseAccessSettings(): AccessSettings {
  return {
    gcipSettings: undefined,
    corsSettings: undefined,
    oauthSettings: undefined,
    reauthSettings: undefined,
    allowedDomainsSettings: undefined,
  };
}

export const AccessSettings: MessageFns<AccessSettings> = {
  encode(message: AccessSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcipSettings !== undefined) {
      GcipSettings.encode(message.gcipSettings, writer.uint32(10).fork()).join();
    }
    if (message.corsSettings !== undefined) {
      CorsSettings.encode(message.corsSettings, writer.uint32(18).fork()).join();
    }
    if (message.oauthSettings !== undefined) {
      OAuthSettings.encode(message.oauthSettings, writer.uint32(26).fork()).join();
    }
    if (message.reauthSettings !== undefined) {
      ReauthSettings.encode(message.reauthSettings, writer.uint32(50).fork()).join();
    }
    if (message.allowedDomainsSettings !== undefined) {
      AllowedDomainsSettings.encode(message.allowedDomainsSettings, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcipSettings = GcipSettings.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.corsSettings = CorsSettings.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.oauthSettings = OAuthSettings.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.reauthSettings = ReauthSettings.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.allowedDomainsSettings = AllowedDomainsSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessSettings {
    return {
      gcipSettings: isSet(object.gcipSettings) ? GcipSettings.fromJSON(object.gcipSettings) : undefined,
      corsSettings: isSet(object.corsSettings) ? CorsSettings.fromJSON(object.corsSettings) : undefined,
      oauthSettings: isSet(object.oauthSettings) ? OAuthSettings.fromJSON(object.oauthSettings) : undefined,
      reauthSettings: isSet(object.reauthSettings) ? ReauthSettings.fromJSON(object.reauthSettings) : undefined,
      allowedDomainsSettings: isSet(object.allowedDomainsSettings)
        ? AllowedDomainsSettings.fromJSON(object.allowedDomainsSettings)
        : undefined,
    };
  },

  toJSON(message: AccessSettings): unknown {
    const obj: any = {};
    if (message.gcipSettings !== undefined) {
      obj.gcipSettings = GcipSettings.toJSON(message.gcipSettings);
    }
    if (message.corsSettings !== undefined) {
      obj.corsSettings = CorsSettings.toJSON(message.corsSettings);
    }
    if (message.oauthSettings !== undefined) {
      obj.oauthSettings = OAuthSettings.toJSON(message.oauthSettings);
    }
    if (message.reauthSettings !== undefined) {
      obj.reauthSettings = ReauthSettings.toJSON(message.reauthSettings);
    }
    if (message.allowedDomainsSettings !== undefined) {
      obj.allowedDomainsSettings = AllowedDomainsSettings.toJSON(message.allowedDomainsSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<AccessSettings>): AccessSettings {
    return AccessSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessSettings>): AccessSettings {
    const message = createBaseAccessSettings();
    message.gcipSettings = (object.gcipSettings !== undefined && object.gcipSettings !== null)
      ? GcipSettings.fromPartial(object.gcipSettings)
      : undefined;
    message.corsSettings = (object.corsSettings !== undefined && object.corsSettings !== null)
      ? CorsSettings.fromPartial(object.corsSettings)
      : undefined;
    message.oauthSettings = (object.oauthSettings !== undefined && object.oauthSettings !== null)
      ? OAuthSettings.fromPartial(object.oauthSettings)
      : undefined;
    message.reauthSettings = (object.reauthSettings !== undefined && object.reauthSettings !== null)
      ? ReauthSettings.fromPartial(object.reauthSettings)
      : undefined;
    message.allowedDomainsSettings =
      (object.allowedDomainsSettings !== undefined && object.allowedDomainsSettings !== null)
        ? AllowedDomainsSettings.fromPartial(object.allowedDomainsSettings)
        : undefined;
    return message;
  },
};

function createBaseGcipSettings(): GcipSettings {
  return { tenantIds: [], loginPageUri: undefined };
}

export const GcipSettings: MessageFns<GcipSettings> = {
  encode(message: GcipSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tenantIds) {
      writer.uint32(10).string(v!);
    }
    if (message.loginPageUri !== undefined) {
      StringValue.encode({ value: message.loginPageUri! }, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcipSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcipSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tenantIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.loginPageUri = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcipSettings {
    return {
      tenantIds: globalThis.Array.isArray(object?.tenantIds)
        ? object.tenantIds.map((e: any) => globalThis.String(e))
        : [],
      loginPageUri: isSet(object.loginPageUri) ? String(object.loginPageUri) : undefined,
    };
  },

  toJSON(message: GcipSettings): unknown {
    const obj: any = {};
    if (message.tenantIds?.length) {
      obj.tenantIds = message.tenantIds;
    }
    if (message.loginPageUri !== undefined) {
      obj.loginPageUri = message.loginPageUri;
    }
    return obj;
  },

  create(base?: DeepPartial<GcipSettings>): GcipSettings {
    return GcipSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcipSettings>): GcipSettings {
    const message = createBaseGcipSettings();
    message.tenantIds = object.tenantIds?.map((e) => e) || [];
    message.loginPageUri = object.loginPageUri ?? undefined;
    return message;
  },
};

function createBaseCorsSettings(): CorsSettings {
  return { allowHttpOptions: undefined };
}

export const CorsSettings: MessageFns<CorsSettings> = {
  encode(message: CorsSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowHttpOptions !== undefined) {
      BoolValue.encode({ value: message.allowHttpOptions! }, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CorsSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCorsSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowHttpOptions = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CorsSettings {
    return { allowHttpOptions: isSet(object.allowHttpOptions) ? Boolean(object.allowHttpOptions) : undefined };
  },

  toJSON(message: CorsSettings): unknown {
    const obj: any = {};
    if (message.allowHttpOptions !== undefined) {
      obj.allowHttpOptions = message.allowHttpOptions;
    }
    return obj;
  },

  create(base?: DeepPartial<CorsSettings>): CorsSettings {
    return CorsSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CorsSettings>): CorsSettings {
    const message = createBaseCorsSettings();
    message.allowHttpOptions = object.allowHttpOptions ?? undefined;
    return message;
  },
};

function createBaseOAuthSettings(): OAuthSettings {
  return { loginHint: undefined, programmaticClients: [] };
}

export const OAuthSettings: MessageFns<OAuthSettings> = {
  encode(message: OAuthSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loginHint !== undefined) {
      StringValue.encode({ value: message.loginHint! }, writer.uint32(18).fork()).join();
    }
    for (const v of message.programmaticClients) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.loginHint = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.programmaticClients.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthSettings {
    return {
      loginHint: isSet(object.loginHint) ? String(object.loginHint) : undefined,
      programmaticClients: globalThis.Array.isArray(object?.programmaticClients)
        ? object.programmaticClients.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OAuthSettings): unknown {
    const obj: any = {};
    if (message.loginHint !== undefined) {
      obj.loginHint = message.loginHint;
    }
    if (message.programmaticClients?.length) {
      obj.programmaticClients = message.programmaticClients;
    }
    return obj;
  },

  create(base?: DeepPartial<OAuthSettings>): OAuthSettings {
    return OAuthSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OAuthSettings>): OAuthSettings {
    const message = createBaseOAuthSettings();
    message.loginHint = object.loginHint ?? undefined;
    message.programmaticClients = object.programmaticClients?.map((e) => e) || [];
    return message;
  },
};

function createBaseReauthSettings(): ReauthSettings {
  return { method: 0, maxAge: undefined, policyType: 0 };
}

export const ReauthSettings: MessageFns<ReauthSettings> = {
  encode(message: ReauthSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== 0) {
      writer.uint32(8).int32(message.method);
    }
    if (message.maxAge !== undefined) {
      Duration.encode(message.maxAge, writer.uint32(18).fork()).join();
    }
    if (message.policyType !== 0) {
      writer.uint32(24).int32(message.policyType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReauthSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReauthSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxAge = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.policyType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReauthSettings {
    return {
      method: isSet(object.method) ? reauthSettings_MethodFromJSON(object.method) : 0,
      maxAge: isSet(object.maxAge) ? Duration.fromJSON(object.maxAge) : undefined,
      policyType: isSet(object.policyType) ? reauthSettings_PolicyTypeFromJSON(object.policyType) : 0,
    };
  },

  toJSON(message: ReauthSettings): unknown {
    const obj: any = {};
    if (message.method !== 0) {
      obj.method = reauthSettings_MethodToJSON(message.method);
    }
    if (message.maxAge !== undefined) {
      obj.maxAge = Duration.toJSON(message.maxAge);
    }
    if (message.policyType !== 0) {
      obj.policyType = reauthSettings_PolicyTypeToJSON(message.policyType);
    }
    return obj;
  },

  create(base?: DeepPartial<ReauthSettings>): ReauthSettings {
    return ReauthSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReauthSettings>): ReauthSettings {
    const message = createBaseReauthSettings();
    message.method = object.method ?? 0;
    message.maxAge = (object.maxAge !== undefined && object.maxAge !== null)
      ? Duration.fromPartial(object.maxAge)
      : undefined;
    message.policyType = object.policyType ?? 0;
    return message;
  },
};

function createBaseAllowedDomainsSettings(): AllowedDomainsSettings {
  return { enable: undefined, domains: [] };
}

export const AllowedDomainsSettings: MessageFns<AllowedDomainsSettings> = {
  encode(message: AllowedDomainsSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enable !== undefined) {
      writer.uint32(8).bool(message.enable);
    }
    for (const v of message.domains) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowedDomainsSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowedDomainsSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enable = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.domains.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowedDomainsSettings {
    return {
      enable: isSet(object.enable) ? globalThis.Boolean(object.enable) : undefined,
      domains: globalThis.Array.isArray(object?.domains) ? object.domains.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AllowedDomainsSettings): unknown {
    const obj: any = {};
    if (message.enable !== undefined) {
      obj.enable = message.enable;
    }
    if (message.domains?.length) {
      obj.domains = message.domains;
    }
    return obj;
  },

  create(base?: DeepPartial<AllowedDomainsSettings>): AllowedDomainsSettings {
    return AllowedDomainsSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AllowedDomainsSettings>): AllowedDomainsSettings {
    const message = createBaseAllowedDomainsSettings();
    message.enable = object.enable ?? undefined;
    message.domains = object.domains?.map((e) => e) || [];
    return message;
  },
};

function createBaseApplicationSettings(): ApplicationSettings {
  return {
    csmSettings: undefined,
    accessDeniedPageSettings: undefined,
    cookieDomain: undefined,
    attributePropagationSettings: undefined,
  };
}

export const ApplicationSettings: MessageFns<ApplicationSettings> = {
  encode(message: ApplicationSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.csmSettings !== undefined) {
      CsmSettings.encode(message.csmSettings, writer.uint32(10).fork()).join();
    }
    if (message.accessDeniedPageSettings !== undefined) {
      AccessDeniedPageSettings.encode(message.accessDeniedPageSettings, writer.uint32(18).fork()).join();
    }
    if (message.cookieDomain !== undefined) {
      StringValue.encode({ value: message.cookieDomain! }, writer.uint32(26).fork()).join();
    }
    if (message.attributePropagationSettings !== undefined) {
      AttributePropagationSettings.encode(message.attributePropagationSettings, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.csmSettings = CsmSettings.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessDeniedPageSettings = AccessDeniedPageSettings.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cookieDomain = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.attributePropagationSettings = AttributePropagationSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationSettings {
    return {
      csmSettings: isSet(object.csmSettings) ? CsmSettings.fromJSON(object.csmSettings) : undefined,
      accessDeniedPageSettings: isSet(object.accessDeniedPageSettings)
        ? AccessDeniedPageSettings.fromJSON(object.accessDeniedPageSettings)
        : undefined,
      cookieDomain: isSet(object.cookieDomain) ? String(object.cookieDomain) : undefined,
      attributePropagationSettings: isSet(object.attributePropagationSettings)
        ? AttributePropagationSettings.fromJSON(object.attributePropagationSettings)
        : undefined,
    };
  },

  toJSON(message: ApplicationSettings): unknown {
    const obj: any = {};
    if (message.csmSettings !== undefined) {
      obj.csmSettings = CsmSettings.toJSON(message.csmSettings);
    }
    if (message.accessDeniedPageSettings !== undefined) {
      obj.accessDeniedPageSettings = AccessDeniedPageSettings.toJSON(message.accessDeniedPageSettings);
    }
    if (message.cookieDomain !== undefined) {
      obj.cookieDomain = message.cookieDomain;
    }
    if (message.attributePropagationSettings !== undefined) {
      obj.attributePropagationSettings = AttributePropagationSettings.toJSON(message.attributePropagationSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<ApplicationSettings>): ApplicationSettings {
    return ApplicationSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApplicationSettings>): ApplicationSettings {
    const message = createBaseApplicationSettings();
    message.csmSettings = (object.csmSettings !== undefined && object.csmSettings !== null)
      ? CsmSettings.fromPartial(object.csmSettings)
      : undefined;
    message.accessDeniedPageSettings =
      (object.accessDeniedPageSettings !== undefined && object.accessDeniedPageSettings !== null)
        ? AccessDeniedPageSettings.fromPartial(object.accessDeniedPageSettings)
        : undefined;
    message.cookieDomain = object.cookieDomain ?? undefined;
    message.attributePropagationSettings =
      (object.attributePropagationSettings !== undefined && object.attributePropagationSettings !== null)
        ? AttributePropagationSettings.fromPartial(object.attributePropagationSettings)
        : undefined;
    return message;
  },
};

function createBaseCsmSettings(): CsmSettings {
  return { rctokenAud: undefined };
}

export const CsmSettings: MessageFns<CsmSettings> = {
  encode(message: CsmSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rctokenAud !== undefined) {
      StringValue.encode({ value: message.rctokenAud! }, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CsmSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCsmSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rctokenAud = StringValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CsmSettings {
    return { rctokenAud: isSet(object.rctokenAud) ? String(object.rctokenAud) : undefined };
  },

  toJSON(message: CsmSettings): unknown {
    const obj: any = {};
    if (message.rctokenAud !== undefined) {
      obj.rctokenAud = message.rctokenAud;
    }
    return obj;
  },

  create(base?: DeepPartial<CsmSettings>): CsmSettings {
    return CsmSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CsmSettings>): CsmSettings {
    const message = createBaseCsmSettings();
    message.rctokenAud = object.rctokenAud ?? undefined;
    return message;
  },
};

function createBaseAccessDeniedPageSettings(): AccessDeniedPageSettings {
  return {
    accessDeniedPageUri: undefined,
    generateTroubleshootingUri: undefined,
    remediationTokenGenerationEnabled: undefined,
  };
}

export const AccessDeniedPageSettings: MessageFns<AccessDeniedPageSettings> = {
  encode(message: AccessDeniedPageSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessDeniedPageUri !== undefined) {
      StringValue.encode({ value: message.accessDeniedPageUri! }, writer.uint32(10).fork()).join();
    }
    if (message.generateTroubleshootingUri !== undefined) {
      BoolValue.encode({ value: message.generateTroubleshootingUri! }, writer.uint32(18).fork()).join();
    }
    if (message.remediationTokenGenerationEnabled !== undefined) {
      BoolValue.encode({ value: message.remediationTokenGenerationEnabled! }, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessDeniedPageSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessDeniedPageSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessDeniedPageUri = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.generateTroubleshootingUri = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.remediationTokenGenerationEnabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessDeniedPageSettings {
    return {
      accessDeniedPageUri: isSet(object.accessDeniedPageUri) ? String(object.accessDeniedPageUri) : undefined,
      generateTroubleshootingUri: isSet(object.generateTroubleshootingUri)
        ? Boolean(object.generateTroubleshootingUri)
        : undefined,
      remediationTokenGenerationEnabled: isSet(object.remediationTokenGenerationEnabled)
        ? Boolean(object.remediationTokenGenerationEnabled)
        : undefined,
    };
  },

  toJSON(message: AccessDeniedPageSettings): unknown {
    const obj: any = {};
    if (message.accessDeniedPageUri !== undefined) {
      obj.accessDeniedPageUri = message.accessDeniedPageUri;
    }
    if (message.generateTroubleshootingUri !== undefined) {
      obj.generateTroubleshootingUri = message.generateTroubleshootingUri;
    }
    if (message.remediationTokenGenerationEnabled !== undefined) {
      obj.remediationTokenGenerationEnabled = message.remediationTokenGenerationEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessDeniedPageSettings>): AccessDeniedPageSettings {
    return AccessDeniedPageSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessDeniedPageSettings>): AccessDeniedPageSettings {
    const message = createBaseAccessDeniedPageSettings();
    message.accessDeniedPageUri = object.accessDeniedPageUri ?? undefined;
    message.generateTroubleshootingUri = object.generateTroubleshootingUri ?? undefined;
    message.remediationTokenGenerationEnabled = object.remediationTokenGenerationEnabled ?? undefined;
    return message;
  },
};

function createBaseAttributePropagationSettings(): AttributePropagationSettings {
  return { expression: undefined, outputCredentials: [], enable: undefined };
}

export const AttributePropagationSettings: MessageFns<AttributePropagationSettings> = {
  encode(message: AttributePropagationSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expression !== undefined) {
      writer.uint32(10).string(message.expression);
    }
    writer.uint32(18).fork();
    for (const v of message.outputCredentials) {
      writer.int32(v);
    }
    writer.join();
    if (message.enable !== undefined) {
      writer.uint32(24).bool(message.enable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributePropagationSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributePropagationSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expression = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.outputCredentials.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.outputCredentials.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributePropagationSettings {
    return {
      expression: isSet(object.expression) ? globalThis.String(object.expression) : undefined,
      outputCredentials: globalThis.Array.isArray(object?.outputCredentials)
        ? object.outputCredentials.map((e: any) => attributePropagationSettings_OutputCredentialsFromJSON(e))
        : [],
      enable: isSet(object.enable) ? globalThis.Boolean(object.enable) : undefined,
    };
  },

  toJSON(message: AttributePropagationSettings): unknown {
    const obj: any = {};
    if (message.expression !== undefined) {
      obj.expression = message.expression;
    }
    if (message.outputCredentials?.length) {
      obj.outputCredentials = message.outputCredentials.map((e) =>
        attributePropagationSettings_OutputCredentialsToJSON(e)
      );
    }
    if (message.enable !== undefined) {
      obj.enable = message.enable;
    }
    return obj;
  },

  create(base?: DeepPartial<AttributePropagationSettings>): AttributePropagationSettings {
    return AttributePropagationSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttributePropagationSettings>): AttributePropagationSettings {
    const message = createBaseAttributePropagationSettings();
    message.expression = object.expression ?? undefined;
    message.outputCredentials = object.outputCredentials?.map((e) => e) || [];
    message.enable = object.enable ?? undefined;
    return message;
  },
};

function createBaseListBrandsRequest(): ListBrandsRequest {
  return { parent: "" };
}

export const ListBrandsRequest: MessageFns<ListBrandsRequest> = {
  encode(message: ListBrandsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBrandsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBrandsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBrandsRequest {
    return { parent: isSet(object.parent) ? globalThis.String(object.parent) : "" };
  },

  toJSON(message: ListBrandsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBrandsRequest>): ListBrandsRequest {
    return ListBrandsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBrandsRequest>): ListBrandsRequest {
    const message = createBaseListBrandsRequest();
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseListBrandsResponse(): ListBrandsResponse {
  return { brands: [] };
}

export const ListBrandsResponse: MessageFns<ListBrandsResponse> = {
  encode(message: ListBrandsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.brands) {
      Brand.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBrandsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBrandsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.brands.push(Brand.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBrandsResponse {
    return { brands: globalThis.Array.isArray(object?.brands) ? object.brands.map((e: any) => Brand.fromJSON(e)) : [] };
  },

  toJSON(message: ListBrandsResponse): unknown {
    const obj: any = {};
    if (message.brands?.length) {
      obj.brands = message.brands.map((e) => Brand.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListBrandsResponse>): ListBrandsResponse {
    return ListBrandsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBrandsResponse>): ListBrandsResponse {
    const message = createBaseListBrandsResponse();
    message.brands = object.brands?.map((e) => Brand.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateBrandRequest(): CreateBrandRequest {
  return { parent: "", brand: undefined };
}

export const CreateBrandRequest: MessageFns<CreateBrandRequest> = {
  encode(message: CreateBrandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.brand !== undefined) {
      Brand.encode(message.brand, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBrandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBrandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.brand = Brand.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBrandRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      brand: isSet(object.brand) ? Brand.fromJSON(object.brand) : undefined,
    };
  },

  toJSON(message: CreateBrandRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.brand !== undefined) {
      obj.brand = Brand.toJSON(message.brand);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateBrandRequest>): CreateBrandRequest {
    return CreateBrandRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateBrandRequest>): CreateBrandRequest {
    const message = createBaseCreateBrandRequest();
    message.parent = object.parent ?? "";
    message.brand = (object.brand !== undefined && object.brand !== null) ? Brand.fromPartial(object.brand) : undefined;
    return message;
  },
};

function createBaseGetBrandRequest(): GetBrandRequest {
  return { name: "" };
}

export const GetBrandRequest: MessageFns<GetBrandRequest> = {
  encode(message: GetBrandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBrandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBrandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBrandRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetBrandRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBrandRequest>): GetBrandRequest {
    return GetBrandRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBrandRequest>): GetBrandRequest {
    const message = createBaseGetBrandRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListIdentityAwareProxyClientsRequest(): ListIdentityAwareProxyClientsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListIdentityAwareProxyClientsRequest: MessageFns<ListIdentityAwareProxyClientsRequest> = {
  encode(message: ListIdentityAwareProxyClientsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIdentityAwareProxyClientsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIdentityAwareProxyClientsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIdentityAwareProxyClientsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListIdentityAwareProxyClientsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIdentityAwareProxyClientsRequest>): ListIdentityAwareProxyClientsRequest {
    return ListIdentityAwareProxyClientsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIdentityAwareProxyClientsRequest>): ListIdentityAwareProxyClientsRequest {
    const message = createBaseListIdentityAwareProxyClientsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListIdentityAwareProxyClientsResponse(): ListIdentityAwareProxyClientsResponse {
  return { identityAwareProxyClients: [], nextPageToken: "" };
}

export const ListIdentityAwareProxyClientsResponse: MessageFns<ListIdentityAwareProxyClientsResponse> = {
  encode(message: ListIdentityAwareProxyClientsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.identityAwareProxyClients) {
      IdentityAwareProxyClient.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIdentityAwareProxyClientsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIdentityAwareProxyClientsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.identityAwareProxyClients.push(IdentityAwareProxyClient.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIdentityAwareProxyClientsResponse {
    return {
      identityAwareProxyClients: globalThis.Array.isArray(object?.identityAwareProxyClients)
        ? object.identityAwareProxyClients.map((e: any) => IdentityAwareProxyClient.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListIdentityAwareProxyClientsResponse): unknown {
    const obj: any = {};
    if (message.identityAwareProxyClients?.length) {
      obj.identityAwareProxyClients = message.identityAwareProxyClients.map((e) => IdentityAwareProxyClient.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIdentityAwareProxyClientsResponse>): ListIdentityAwareProxyClientsResponse {
    return ListIdentityAwareProxyClientsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIdentityAwareProxyClientsResponse>): ListIdentityAwareProxyClientsResponse {
    const message = createBaseListIdentityAwareProxyClientsResponse();
    message.identityAwareProxyClients =
      object.identityAwareProxyClients?.map((e) => IdentityAwareProxyClient.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateIdentityAwareProxyClientRequest(): CreateIdentityAwareProxyClientRequest {
  return { parent: "", identityAwareProxyClient: undefined };
}

export const CreateIdentityAwareProxyClientRequest: MessageFns<CreateIdentityAwareProxyClientRequest> = {
  encode(message: CreateIdentityAwareProxyClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.identityAwareProxyClient !== undefined) {
      IdentityAwareProxyClient.encode(message.identityAwareProxyClient, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateIdentityAwareProxyClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIdentityAwareProxyClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.identityAwareProxyClient = IdentityAwareProxyClient.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIdentityAwareProxyClientRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      identityAwareProxyClient: isSet(object.identityAwareProxyClient)
        ? IdentityAwareProxyClient.fromJSON(object.identityAwareProxyClient)
        : undefined,
    };
  },

  toJSON(message: CreateIdentityAwareProxyClientRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.identityAwareProxyClient !== undefined) {
      obj.identityAwareProxyClient = IdentityAwareProxyClient.toJSON(message.identityAwareProxyClient);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateIdentityAwareProxyClientRequest>): CreateIdentityAwareProxyClientRequest {
    return CreateIdentityAwareProxyClientRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateIdentityAwareProxyClientRequest>): CreateIdentityAwareProxyClientRequest {
    const message = createBaseCreateIdentityAwareProxyClientRequest();
    message.parent = object.parent ?? "";
    message.identityAwareProxyClient =
      (object.identityAwareProxyClient !== undefined && object.identityAwareProxyClient !== null)
        ? IdentityAwareProxyClient.fromPartial(object.identityAwareProxyClient)
        : undefined;
    return message;
  },
};

function createBaseGetIdentityAwareProxyClientRequest(): GetIdentityAwareProxyClientRequest {
  return { name: "" };
}

export const GetIdentityAwareProxyClientRequest: MessageFns<GetIdentityAwareProxyClientRequest> = {
  encode(message: GetIdentityAwareProxyClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIdentityAwareProxyClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIdentityAwareProxyClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIdentityAwareProxyClientRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetIdentityAwareProxyClientRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetIdentityAwareProxyClientRequest>): GetIdentityAwareProxyClientRequest {
    return GetIdentityAwareProxyClientRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetIdentityAwareProxyClientRequest>): GetIdentityAwareProxyClientRequest {
    const message = createBaseGetIdentityAwareProxyClientRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseResetIdentityAwareProxyClientSecretRequest(): ResetIdentityAwareProxyClientSecretRequest {
  return { name: "" };
}

export const ResetIdentityAwareProxyClientSecretRequest: MessageFns<ResetIdentityAwareProxyClientSecretRequest> = {
  encode(message: ResetIdentityAwareProxyClientSecretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetIdentityAwareProxyClientSecretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetIdentityAwareProxyClientSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetIdentityAwareProxyClientSecretRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: ResetIdentityAwareProxyClientSecretRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ResetIdentityAwareProxyClientSecretRequest>): ResetIdentityAwareProxyClientSecretRequest {
    return ResetIdentityAwareProxyClientSecretRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ResetIdentityAwareProxyClientSecretRequest>,
  ): ResetIdentityAwareProxyClientSecretRequest {
    const message = createBaseResetIdentityAwareProxyClientSecretRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteIdentityAwareProxyClientRequest(): DeleteIdentityAwareProxyClientRequest {
  return { name: "" };
}

export const DeleteIdentityAwareProxyClientRequest: MessageFns<DeleteIdentityAwareProxyClientRequest> = {
  encode(message: DeleteIdentityAwareProxyClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteIdentityAwareProxyClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIdentityAwareProxyClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteIdentityAwareProxyClientRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteIdentityAwareProxyClientRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteIdentityAwareProxyClientRequest>): DeleteIdentityAwareProxyClientRequest {
    return DeleteIdentityAwareProxyClientRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteIdentityAwareProxyClientRequest>): DeleteIdentityAwareProxyClientRequest {
    const message = createBaseDeleteIdentityAwareProxyClientRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseBrand(): Brand {
  return { name: "", supportEmail: "", applicationTitle: "", orgInternalOnly: false };
}

export const Brand: MessageFns<Brand> = {
  encode(message: Brand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.supportEmail !== "") {
      writer.uint32(18).string(message.supportEmail);
    }
    if (message.applicationTitle !== "") {
      writer.uint32(26).string(message.applicationTitle);
    }
    if (message.orgInternalOnly !== false) {
      writer.uint32(32).bool(message.orgInternalOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Brand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.supportEmail = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.applicationTitle = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.orgInternalOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Brand {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      supportEmail: isSet(object.supportEmail) ? globalThis.String(object.supportEmail) : "",
      applicationTitle: isSet(object.applicationTitle) ? globalThis.String(object.applicationTitle) : "",
      orgInternalOnly: isSet(object.orgInternalOnly) ? globalThis.Boolean(object.orgInternalOnly) : false,
    };
  },

  toJSON(message: Brand): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.supportEmail !== "") {
      obj.supportEmail = message.supportEmail;
    }
    if (message.applicationTitle !== "") {
      obj.applicationTitle = message.applicationTitle;
    }
    if (message.orgInternalOnly !== false) {
      obj.orgInternalOnly = message.orgInternalOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<Brand>): Brand {
    return Brand.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Brand>): Brand {
    const message = createBaseBrand();
    message.name = object.name ?? "";
    message.supportEmail = object.supportEmail ?? "";
    message.applicationTitle = object.applicationTitle ?? "";
    message.orgInternalOnly = object.orgInternalOnly ?? false;
    return message;
  },
};

function createBaseIdentityAwareProxyClient(): IdentityAwareProxyClient {
  return { name: "", secret: "", displayName: "" };
}

export const IdentityAwareProxyClient: MessageFns<IdentityAwareProxyClient> = {
  encode(message: IdentityAwareProxyClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.secret !== "") {
      writer.uint32(18).string(message.secret);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdentityAwareProxyClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentityAwareProxyClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.secret = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentityAwareProxyClient {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      secret: isSet(object.secret) ? globalThis.String(object.secret) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: IdentityAwareProxyClient): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.secret !== "") {
      obj.secret = message.secret;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<IdentityAwareProxyClient>): IdentityAwareProxyClient {
    return IdentityAwareProxyClient.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IdentityAwareProxyClient>): IdentityAwareProxyClient {
    const message = createBaseIdentityAwareProxyClient();
    message.name = object.name ?? "";
    message.secret = object.secret ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

/** APIs for Identity-Aware Proxy Admin configurations. */
export type IdentityAwareProxyAdminServiceDefinition = typeof IdentityAwareProxyAdminServiceDefinition;
export const IdentityAwareProxyAdminServiceDefinition = {
  name: "IdentityAwareProxyAdminService",
  fullName: "google.cloud.iap.v1.IdentityAwareProxyAdminService",
  methods: {
    /**
     * Sets the access control policy for an Identity-Aware Proxy protected
     * resource. Replaces any existing policy.
     * More information about managing access via IAP can be found at:
     * https://cloud.google.com/iap/docs/managing-access#managing_access_via_the_api
     */
    setIamPolicy: {
      name: "SetIamPolicy",
      requestType: SetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              35,
              58,
              1,
              42,
              34,
              30,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              42,
              42,
              125,
              58,
              115,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the access control policy for an Identity-Aware Proxy protected
     * resource.
     * More information about managing access via IAP can be found at:
     * https://cloud.google.com/iap/docs/managing-access#managing_access_via_the_api
     */
    getIamPolicy: {
      name: "GetIamPolicy",
      requestType: GetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              35,
              58,
              1,
              42,
              34,
              30,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              42,
              42,
              125,
              58,
              103,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Returns permissions that a caller has on the Identity-Aware Proxy protected
     * resource.
     * More information about managing access via IAP can be found at:
     * https://cloud.google.com/iap/docs/managing-access#managing_access_via_the_api
     */
    testIamPermissions: {
      name: "TestIamPermissions",
      requestType: TestIamPermissionsRequest,
      requestStream: false,
      responseType: TestIamPermissionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              41,
              58,
              1,
              42,
              34,
              36,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              42,
              42,
              125,
              58,
              116,
              101,
              115,
              116,
              73,
              97,
              109,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the IAP settings on a particular IAP protected resource. */
    getIapSettings: {
      name: "GetIapSettings",
      requestType: GetIapSettingsRequest,
      requestStream: false,
      responseType: IapSettings,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              27,
              18,
              25,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              42,
              42,
              125,
              58,
              105,
              97,
              112,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the IAP settings on a particular IAP protected resource. It
     * replaces all fields unless the `update_mask` is set.
     */
    updateIapSettings: {
      name: "UpdateIapSettings",
      requestType: UpdateIapSettingsRequest,
      requestStream: false,
      responseType: IapSettings,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              54,
              58,
              12,
              105,
              97,
              112,
              95,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              50,
              38,
              47,
              118,
              49,
              47,
              123,
              105,
              97,
              112,
              95,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              42,
              42,
              125,
              58,
              105,
              97,
              112,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the existing TunnelDestGroups. To group across all locations, use a
     * `-` as the location ID. For example:
     * `/v1/projects/123/iap_tunnel/locations/-/destGroups`
     */
    listTunnelDestGroups: {
      name: "ListTunnelDestGroups",
      requestType: ListTunnelDestGroupsRequest,
      requestStream: false,
      responseType: ListTunnelDestGroupsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              97,
              112,
              95,
              116,
              117,
              110,
              110,
              101,
              108,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              100,
              101,
              115,
              116,
              71,
              114,
              111,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates a new TunnelDestGroup. */
    createTunnelDestGroup: {
      name: "CreateTunnelDestGroup",
      requestType: CreateTunnelDestGroupRequest,
      requestStream: false,
      responseType: TunnelDestGroup,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              45,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              116,
              117,
              110,
              110,
              101,
              108,
              95,
              100,
              101,
              115,
              116,
              95,
              103,
              114,
              111,
              117,
              112,
              44,
              116,
              117,
              110,
              110,
              101,
              108,
              95,
              100,
              101,
              115,
              116,
              95,
              103,
              114,
              111,
              117,
              112,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              78,
              58,
              17,
              116,
              117,
              110,
              110,
              101,
              108,
              95,
              100,
              101,
              115,
              116,
              95,
              103,
              114,
              111,
              117,
              112,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              97,
              112,
              95,
              116,
              117,
              110,
              110,
              101,
              108,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              100,
              101,
              115,
              116,
              71,
              114,
              111,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves an existing TunnelDestGroup. */
    getTunnelDestGroup: {
      name: "GetTunnelDestGroup",
      requestType: GetTunnelDestGroupRequest,
      requestStream: false,
      responseType: TunnelDestGroup,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              97,
              112,
              95,
              116,
              117,
              110,
              110,
              101,
              108,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              115,
              116,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a TunnelDestGroup. */
    deleteTunnelDestGroup: {
      name: "DeleteTunnelDestGroup",
      requestType: DeleteTunnelDestGroupRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              42,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              97,
              112,
              95,
              116,
              117,
              110,
              110,
              101,
              108,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              115,
              116,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates a TunnelDestGroup. */
    updateTunnelDestGroup: {
      name: "UpdateTunnelDestGroup",
      requestType: UpdateTunnelDestGroupRequest,
      requestStream: false,
      responseType: TunnelDestGroup,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              29,
              116,
              117,
              110,
              110,
              101,
              108,
              95,
              100,
              101,
              115,
              116,
              95,
              103,
              114,
              111,
              117,
              112,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              96,
              58,
              17,
              116,
              117,
              110,
              110,
              101,
              108,
              95,
              100,
              101,
              115,
              116,
              95,
              103,
              114,
              111,
              117,
              112,
              50,
              75,
              47,
              118,
              49,
              47,
              123,
              116,
              117,
              110,
              110,
              101,
              108,
              95,
              100,
              101,
              115,
              116,
              95,
              103,
              114,
              111,
              117,
              112,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              105,
              97,
              112,
              95,
              116,
              117,
              110,
              110,
              101,
              108,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              115,
              116,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface IdentityAwareProxyAdminServiceImplementation<CallContextExt = {}> {
  /**
   * Sets the access control policy for an Identity-Aware Proxy protected
   * resource. Replaces any existing policy.
   * More information about managing access via IAP can be found at:
   * https://cloud.google.com/iap/docs/managing-access#managing_access_via_the_api
   */
  setIamPolicy(request: SetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Gets the access control policy for an Identity-Aware Proxy protected
   * resource.
   * More information about managing access via IAP can be found at:
   * https://cloud.google.com/iap/docs/managing-access#managing_access_via_the_api
   */
  getIamPolicy(request: GetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Returns permissions that a caller has on the Identity-Aware Proxy protected
   * resource.
   * More information about managing access via IAP can be found at:
   * https://cloud.google.com/iap/docs/managing-access#managing_access_via_the_api
   */
  testIamPermissions(
    request: TestIamPermissionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestIamPermissionsResponse>>;
  /** Gets the IAP settings on a particular IAP protected resource. */
  getIapSettings(
    request: GetIapSettingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<IapSettings>>;
  /**
   * Updates the IAP settings on a particular IAP protected resource. It
   * replaces all fields unless the `update_mask` is set.
   */
  updateIapSettings(
    request: UpdateIapSettingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<IapSettings>>;
  /**
   * Lists the existing TunnelDestGroups. To group across all locations, use a
   * `-` as the location ID. For example:
   * `/v1/projects/123/iap_tunnel/locations/-/destGroups`
   */
  listTunnelDestGroups(
    request: ListTunnelDestGroupsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTunnelDestGroupsResponse>>;
  /** Creates a new TunnelDestGroup. */
  createTunnelDestGroup(
    request: CreateTunnelDestGroupRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TunnelDestGroup>>;
  /** Retrieves an existing TunnelDestGroup. */
  getTunnelDestGroup(
    request: GetTunnelDestGroupRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TunnelDestGroup>>;
  /** Deletes a TunnelDestGroup. */
  deleteTunnelDestGroup(
    request: DeleteTunnelDestGroupRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Updates a TunnelDestGroup. */
  updateTunnelDestGroup(
    request: UpdateTunnelDestGroupRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TunnelDestGroup>>;
}

export interface IdentityAwareProxyAdminServiceClient<CallOptionsExt = {}> {
  /**
   * Sets the access control policy for an Identity-Aware Proxy protected
   * resource. Replaces any existing policy.
   * More information about managing access via IAP can be found at:
   * https://cloud.google.com/iap/docs/managing-access#managing_access_via_the_api
   */
  setIamPolicy(request: DeepPartial<SetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Gets the access control policy for an Identity-Aware Proxy protected
   * resource.
   * More information about managing access via IAP can be found at:
   * https://cloud.google.com/iap/docs/managing-access#managing_access_via_the_api
   */
  getIamPolicy(request: DeepPartial<GetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Returns permissions that a caller has on the Identity-Aware Proxy protected
   * resource.
   * More information about managing access via IAP can be found at:
   * https://cloud.google.com/iap/docs/managing-access#managing_access_via_the_api
   */
  testIamPermissions(
    request: DeepPartial<TestIamPermissionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestIamPermissionsResponse>;
  /** Gets the IAP settings on a particular IAP protected resource. */
  getIapSettings(
    request: DeepPartial<GetIapSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<IapSettings>;
  /**
   * Updates the IAP settings on a particular IAP protected resource. It
   * replaces all fields unless the `update_mask` is set.
   */
  updateIapSettings(
    request: DeepPartial<UpdateIapSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<IapSettings>;
  /**
   * Lists the existing TunnelDestGroups. To group across all locations, use a
   * `-` as the location ID. For example:
   * `/v1/projects/123/iap_tunnel/locations/-/destGroups`
   */
  listTunnelDestGroups(
    request: DeepPartial<ListTunnelDestGroupsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTunnelDestGroupsResponse>;
  /** Creates a new TunnelDestGroup. */
  createTunnelDestGroup(
    request: DeepPartial<CreateTunnelDestGroupRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TunnelDestGroup>;
  /** Retrieves an existing TunnelDestGroup. */
  getTunnelDestGroup(
    request: DeepPartial<GetTunnelDestGroupRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TunnelDestGroup>;
  /** Deletes a TunnelDestGroup. */
  deleteTunnelDestGroup(
    request: DeepPartial<DeleteTunnelDestGroupRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Updates a TunnelDestGroup. */
  updateTunnelDestGroup(
    request: DeepPartial<UpdateTunnelDestGroupRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TunnelDestGroup>;
}

/**
 * API to programmatically create, list and retrieve Identity Aware Proxy (IAP)
 * OAuth brands; and create, retrieve, delete and reset-secret of IAP OAuth
 * clients.
 */
export type IdentityAwareProxyOAuthServiceDefinition = typeof IdentityAwareProxyOAuthServiceDefinition;
export const IdentityAwareProxyOAuthServiceDefinition = {
  name: "IdentityAwareProxyOAuthService",
  fullName: "google.cloud.iap.v1.IdentityAwareProxyOAuthService",
  methods: {
    /** Lists the existing brands for the project. */
    listBrands: {
      name: "ListBrands",
      requestType: ListBrandsRequest,
      requestStream: false,
      responseType: ListBrandsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              32,
              18,
              30,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              98,
              114,
              97,
              110,
              100,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Constructs a new OAuth brand for the project if one does not exist.
     * The created brand is "internal only", meaning that OAuth clients created
     * under it only accept requests from users who belong to the same Google
     * Workspace organization as the project. The brand is created in an
     * un-reviewed status. NOTE: The "internal only" status can be manually
     * changed in the Google Cloud Console. Requires that a brand does not already
     * exist for the project, and that the specified support email is owned by the
     * caller.
     */
    createBrand: {
      name: "CreateBrand",
      requestType: CreateBrandRequest,
      requestStream: false,
      responseType: Brand,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              39,
              58,
              5,
              98,
              114,
              97,
              110,
              100,
              34,
              30,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              98,
              114,
              97,
              110,
              100,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves the OAuth brand of the project. */
    getBrand: {
      name: "GetBrand",
      requestType: GetBrandRequest,
      requestStream: false,
      responseType: Brand,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              32,
              18,
              30,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              98,
              114,
              97,
              110,
              100,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates an Identity Aware Proxy (IAP) OAuth client. The client is owned
     * by IAP. Requires that the brand for the project exists and that it is
     * set for internal-only use.
     */
    createIdentityAwareProxyClient: {
      name: "CreateIdentityAwareProxyClient",
      requestType: CreateIdentityAwareProxyClientRequest,
      requestStream: false,
      responseType: IdentityAwareProxyClient,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              89,
              58,
              27,
              105,
              100,
              101,
              110,
              116,
              105,
              116,
              121,
              95,
              97,
              119,
              97,
              114,
              101,
              95,
              112,
              114,
              111,
              120,
              121,
              95,
              99,
              108,
              105,
              101,
              110,
              116,
              34,
              58,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              98,
              114,
              97,
              110,
              100,
              115,
              47,
              42,
              125,
              47,
              105,
              100,
              101,
              110,
              116,
              105,
              116,
              121,
              65,
              119,
              97,
              114,
              101,
              80,
              114,
              111,
              120,
              121,
              67,
              108,
              105,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists the existing clients for the brand. */
    listIdentityAwareProxyClients: {
      name: "ListIdentityAwareProxyClients",
      requestType: ListIdentityAwareProxyClientsRequest,
      requestStream: false,
      responseType: ListIdentityAwareProxyClientsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              98,
              114,
              97,
              110,
              100,
              115,
              47,
              42,
              125,
              47,
              105,
              100,
              101,
              110,
              116,
              105,
              116,
              121,
              65,
              119,
              97,
              114,
              101,
              80,
              114,
              111,
              120,
              121,
              67,
              108,
              105,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves an Identity Aware Proxy (IAP) OAuth client.
     * Requires that the client is owned by IAP.
     */
    getIdentityAwareProxyClient: {
      name: "GetIdentityAwareProxyClient",
      requestType: GetIdentityAwareProxyClientRequest,
      requestStream: false,
      responseType: IdentityAwareProxyClient,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              98,
              114,
              97,
              110,
              100,
              115,
              47,
              42,
              47,
              105,
              100,
              101,
              110,
              116,
              105,
              116,
              121,
              65,
              119,
              97,
              114,
              101,
              80,
              114,
              111,
              120,
              121,
              67,
              108,
              105,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Resets an Identity Aware Proxy (IAP) OAuth client secret. Useful if the
     * secret was compromised. Requires that the client is owned by IAP.
     */
    resetIdentityAwareProxyClientSecret: {
      name: "ResetIdentityAwareProxyClientSecret",
      requestType: ResetIdentityAwareProxyClientSecretRequest,
      requestStream: false,
      responseType: IdentityAwareProxyClient,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              75,
              58,
              1,
              42,
              34,
              70,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              98,
              114,
              97,
              110,
              100,
              115,
              47,
              42,
              47,
              105,
              100,
              101,
              110,
              116,
              105,
              116,
              121,
              65,
              119,
              97,
              114,
              101,
              80,
              114,
              111,
              120,
              121,
              67,
              108,
              105,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              115,
              101,
              116,
              83,
              101,
              99,
              114,
              101,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes an Identity Aware Proxy (IAP) OAuth client. Useful for removing
     * obsolete clients, managing the number of clients in a given project, and
     * cleaning up after tests. Requires that the client is owned by IAP.
     */
    deleteIdentityAwareProxyClient: {
      name: "DeleteIdentityAwareProxyClient",
      requestType: DeleteIdentityAwareProxyClientRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              60,
              42,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              98,
              114,
              97,
              110,
              100,
              115,
              47,
              42,
              47,
              105,
              100,
              101,
              110,
              116,
              105,
              116,
              121,
              65,
              119,
              97,
              114,
              101,
              80,
              114,
              111,
              120,
              121,
              67,
              108,
              105,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface IdentityAwareProxyOAuthServiceImplementation<CallContextExt = {}> {
  /** Lists the existing brands for the project. */
  listBrands(
    request: ListBrandsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListBrandsResponse>>;
  /**
   * Constructs a new OAuth brand for the project if one does not exist.
   * The created brand is "internal only", meaning that OAuth clients created
   * under it only accept requests from users who belong to the same Google
   * Workspace organization as the project. The brand is created in an
   * un-reviewed status. NOTE: The "internal only" status can be manually
   * changed in the Google Cloud Console. Requires that a brand does not already
   * exist for the project, and that the specified support email is owned by the
   * caller.
   */
  createBrand(request: CreateBrandRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Brand>>;
  /** Retrieves the OAuth brand of the project. */
  getBrand(request: GetBrandRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Brand>>;
  /**
   * Creates an Identity Aware Proxy (IAP) OAuth client. The client is owned
   * by IAP. Requires that the brand for the project exists and that it is
   * set for internal-only use.
   */
  createIdentityAwareProxyClient(
    request: CreateIdentityAwareProxyClientRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<IdentityAwareProxyClient>>;
  /** Lists the existing clients for the brand. */
  listIdentityAwareProxyClients(
    request: ListIdentityAwareProxyClientsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListIdentityAwareProxyClientsResponse>>;
  /**
   * Retrieves an Identity Aware Proxy (IAP) OAuth client.
   * Requires that the client is owned by IAP.
   */
  getIdentityAwareProxyClient(
    request: GetIdentityAwareProxyClientRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<IdentityAwareProxyClient>>;
  /**
   * Resets an Identity Aware Proxy (IAP) OAuth client secret. Useful if the
   * secret was compromised. Requires that the client is owned by IAP.
   */
  resetIdentityAwareProxyClientSecret(
    request: ResetIdentityAwareProxyClientSecretRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<IdentityAwareProxyClient>>;
  /**
   * Deletes an Identity Aware Proxy (IAP) OAuth client. Useful for removing
   * obsolete clients, managing the number of clients in a given project, and
   * cleaning up after tests. Requires that the client is owned by IAP.
   */
  deleteIdentityAwareProxyClient(
    request: DeleteIdentityAwareProxyClientRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface IdentityAwareProxyOAuthServiceClient<CallOptionsExt = {}> {
  /** Lists the existing brands for the project. */
  listBrands(
    request: DeepPartial<ListBrandsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListBrandsResponse>;
  /**
   * Constructs a new OAuth brand for the project if one does not exist.
   * The created brand is "internal only", meaning that OAuth clients created
   * under it only accept requests from users who belong to the same Google
   * Workspace organization as the project. The brand is created in an
   * un-reviewed status. NOTE: The "internal only" status can be manually
   * changed in the Google Cloud Console. Requires that a brand does not already
   * exist for the project, and that the specified support email is owned by the
   * caller.
   */
  createBrand(request: DeepPartial<CreateBrandRequest>, options?: CallOptions & CallOptionsExt): Promise<Brand>;
  /** Retrieves the OAuth brand of the project. */
  getBrand(request: DeepPartial<GetBrandRequest>, options?: CallOptions & CallOptionsExt): Promise<Brand>;
  /**
   * Creates an Identity Aware Proxy (IAP) OAuth client. The client is owned
   * by IAP. Requires that the brand for the project exists and that it is
   * set for internal-only use.
   */
  createIdentityAwareProxyClient(
    request: DeepPartial<CreateIdentityAwareProxyClientRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<IdentityAwareProxyClient>;
  /** Lists the existing clients for the brand. */
  listIdentityAwareProxyClients(
    request: DeepPartial<ListIdentityAwareProxyClientsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListIdentityAwareProxyClientsResponse>;
  /**
   * Retrieves an Identity Aware Proxy (IAP) OAuth client.
   * Requires that the client is owned by IAP.
   */
  getIdentityAwareProxyClient(
    request: DeepPartial<GetIdentityAwareProxyClientRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<IdentityAwareProxyClient>;
  /**
   * Resets an Identity Aware Proxy (IAP) OAuth client secret. Useful if the
   * secret was compromised. Requires that the client is owned by IAP.
   */
  resetIdentityAwareProxyClientSecret(
    request: DeepPartial<ResetIdentityAwareProxyClientSecretRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<IdentityAwareProxyClient>;
  /**
   * Deletes an Identity Aware Proxy (IAP) OAuth client. Useful for removing
   * obsolete clients, managing the number of clients in a given project, and
   * cleaning up after tests. Requires that the client is owned by IAP.
   */
  deleteIdentityAwareProxyClient(
    request: DeepPartial<DeleteIdentityAwareProxyClientRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
