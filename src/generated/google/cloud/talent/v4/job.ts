// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/talent/v4/job.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  CompensationInfo,
  CustomAttribute,
  DegreeType,
  degreeTypeFromJSON,
  degreeTypeToJSON,
  EmploymentType,
  employmentTypeFromJSON,
  employmentTypeToJSON,
  HtmlSanitization,
  htmlSanitizationFromJSON,
  htmlSanitizationToJSON,
  JobBenefit,
  jobBenefitFromJSON,
  jobBenefitToJSON,
  JobCategory,
  jobCategoryFromJSON,
  jobCategoryToJSON,
  JobLevel,
  jobLevelFromJSON,
  jobLevelToJSON,
  Location,
  PostingRegion,
  postingRegionFromJSON,
  postingRegionToJSON,
  Visibility,
  visibilityFromJSON,
  visibilityToJSON,
} from "./common.js";

export const protobufPackage = "google.cloud.talent.v4";

/**
 * A Job resource represents a job posting (also referred to as a "job listing"
 * or "job requisition"). A job belongs to a
 * [Company][google.cloud.talent.v4.Company], which is the hiring entity
 * responsible for the job.
 */
export interface Job {
  /**
   * Required during job update.
   *
   * The resource name for the job. This is generated by the service when a
   * job is created.
   *
   * The format is
   * "projects/{project_id}/tenants/{tenant_id}/jobs/{job_id}". For
   * example, "projects/foo/tenants/bar/jobs/baz".
   *
   * Use of this field in job queries and API calls is preferred over the use of
   * [requisition_id][google.cloud.talent.v4.Job.requisition_id] since this
   * value is unique.
   */
  name: string;
  /**
   * Required. The resource name of the company listing the job.
   *
   * The format is
   * "projects/{project_id}/tenants/{tenant_id}/companies/{company_id}". For
   * example, "projects/foo/tenants/bar/companies/baz".
   */
  company: string;
  /**
   * Required. The requisition ID, also referred to as the posting ID, is
   * assigned by the client to identify a job. This field is intended to be used
   * by clients for client identification and tracking of postings. A job isn't
   * allowed to be created if there is another job with the same
   * [company][google.cloud.talent.v4.Job.name],
   * [language_code][google.cloud.talent.v4.Job.language_code] and
   * [requisition_id][google.cloud.talent.v4.Job.requisition_id].
   *
   * The maximum number of allowed characters is 255.
   */
  requisitionId: string;
  /**
   * Required. The title of the job, such as "Software Engineer"
   *
   * The maximum number of allowed characters is 500.
   */
  title: string;
  /**
   * Required. The description of the job, which typically includes a
   * multi-paragraph description of the company and related information.
   * Separate fields are provided on the job object for
   * [responsibilities][google.cloud.talent.v4.Job.responsibilities],
   * [qualifications][google.cloud.talent.v4.Job.qualifications], and other job
   * characteristics. Use of these separate job fields is recommended.
   *
   * This field accepts and sanitizes HTML input, and also accepts
   * bold, italic, ordered list, and unordered list markup tags.
   *
   * The maximum number of allowed characters is 100,000.
   */
  description: string;
  /**
   * Strongly recommended for the best service experience.
   *
   * Location(s) where the employer is looking to hire for this job posting.
   *
   * Specifying the full street address(es) of the hiring location enables
   * better API results, especially job searches by commute time.
   *
   * At most 50 locations are allowed for best search performance. If a job has
   * more locations, it is suggested to split it into multiple jobs with unique
   * [requisition_id][google.cloud.talent.v4.Job.requisition_id]s (e.g. 'ReqA'
   * becomes 'ReqA-1', 'ReqA-2', and so on.) as multiple jobs with the same
   * [company][google.cloud.talent.v4.Job.company],
   * [language_code][google.cloud.talent.v4.Job.language_code] and
   * [requisition_id][google.cloud.talent.v4.Job.requisition_id] are not
   * allowed. If the original
   * [requisition_id][google.cloud.talent.v4.Job.requisition_id] must be
   * preserved, a custom field should be used for storage. It is also suggested
   * to group the locations that close to each other in the same job for better
   * search experience.
   *
   * Jobs with multiple addresses must have their addresses with the same
   * [LocationType][] to allow location filtering to work properly. (For
   * example, a Job with addresses "1600 Amphitheatre Parkway, Mountain View,
   * CA, USA" and "London, UK" may not have location filters applied correctly
   * at search time since the first is a [LocationType.STREET_ADDRESS][] and the
   * second is a [LocationType.LOCALITY][].) If a job needs to have multiple
   * addresses, it is suggested to split it into multiple jobs with same
   * LocationTypes.
   *
   * The maximum number of allowed characters is 500.
   */
  addresses: string[];
  /** Job application information. */
  applicationInfo:
    | Job_ApplicationInfo
    | undefined;
  /** The benefits included with the job. */
  jobBenefits: JobBenefit[];
  /**
   * Job compensation information (a.k.a. "pay rate") i.e., the compensation
   * that will paid to the employee.
   */
  compensationInfo:
    | CompensationInfo
    | undefined;
  /**
   * A map of fields to hold both filterable and non-filterable custom job
   * attributes that are not covered by the provided structured fields.
   *
   * The keys of the map are strings up to 64 bytes and must match the
   * pattern: `[a-zA-Z][a-zA-Z0-9_]*`. For example, key0LikeThis or
   * KEY_1_LIKE_THIS.
   *
   * At most 100 filterable and at most 100 unfilterable keys are supported.
   * For filterable `string_values`, across all keys at most 200 values are
   * allowed, with each string no more than 255 characters. For unfilterable
   * `string_values`, the maximum total size of `string_values` across all keys
   * is 50KB.
   */
  customAttributes: { [key: string]: CustomAttribute };
  /** The desired education degrees for the job, such as Bachelors, Masters. */
  degreeTypes: DegreeType[];
  /**
   * The department or functional area within the company with the open
   * position.
   *
   * The maximum number of allowed characters is 255.
   */
  department: string;
  /**
   * The employment type(s) of a job, for example,
   * [full time][google.cloud.talent.v4.EmploymentType.FULL_TIME] or
   * [part time][google.cloud.talent.v4.EmploymentType.PART_TIME].
   */
  employmentTypes: EmploymentType[];
  /**
   * A description of bonus, commission, and other compensation
   * incentives associated with the job not including salary or pay.
   *
   * The maximum number of allowed characters is 10,000.
   */
  incentives: string;
  /**
   * The language of the posting. This field is distinct from
   * any requirements for fluency that are associated with the job.
   *
   * Language codes must be in BCP-47 format, such as "en-US" or "sr-Latn".
   * For more information, see
   * [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47){:
   * class="external" target="_blank" }.
   *
   * If this field is unspecified and
   * [Job.description][google.cloud.talent.v4.Job.description] is present,
   * detected language code based on
   * [Job.description][google.cloud.talent.v4.Job.description] is assigned,
   * otherwise defaults to 'en_US'.
   */
  languageCode: string;
  /** The experience level associated with the job, such as "Entry Level". */
  jobLevel: JobLevel;
  /**
   * A promotion value of the job, as determined by the client.
   * The value determines the sort order of the jobs returned when searching for
   * jobs using the featured jobs search call, with higher promotional values
   * being returned first and ties being resolved by relevance sort. Only the
   * jobs with a promotionValue >0 are returned in a FEATURED_JOB_SEARCH.
   *
   * Default value is 0, and negative values are treated as 0.
   */
  promotionValue: number;
  /**
   * A description of the qualifications required to perform the
   * job. The use of this field is recommended
   * as an alternative to using the more general
   * [description][google.cloud.talent.v4.Job.description] field.
   *
   * This field accepts and sanitizes HTML input, and also accepts
   * bold, italic, ordered list, and unordered list markup tags.
   *
   * The maximum number of allowed characters is 10,000.
   */
  qualifications: string;
  /**
   * A description of job responsibilities. The use of this field is
   * recommended as an alternative to using the more general
   * [description][google.cloud.talent.v4.Job.description] field.
   *
   * This field accepts and sanitizes HTML input, and also accepts
   * bold, italic, ordered list, and unordered list markup tags.
   *
   * The maximum number of allowed characters is 10,000.
   */
  responsibilities: string;
  /**
   * The job [PostingRegion][google.cloud.talent.v4.PostingRegion] (for example,
   * state, country) throughout which the job is available. If this field is
   * set, a [LocationFilter][google.cloud.talent.v4.LocationFilter] in a search
   * query within the job region finds this job posting if an exact location
   * match isn't specified. If this field is set to
   * [PostingRegion.NATION][google.cloud.talent.v4.PostingRegion.NATION] or
   * [PostingRegion.ADMINISTRATIVE_AREA][google.cloud.talent.v4.PostingRegion.ADMINISTRATIVE_AREA],
   * setting job [Job.addresses][google.cloud.talent.v4.Job.addresses] to the
   * same location level as this field is strongly recommended.
   */
  postingRegion: PostingRegion;
  /**
   * Deprecated. The job is only visible to the owner.
   *
   * The visibility of the job.
   *
   * Defaults to
   * [Visibility.ACCOUNT_ONLY][google.cloud.talent.v4.Visibility.ACCOUNT_ONLY]
   * if not specified.
   *
   * @deprecated
   */
  visibility: Visibility;
  /**
   * The start timestamp of the job in UTC time zone. Typically this field
   * is used for contracting engagements. Invalid timestamps are ignored.
   */
  jobStartTime:
    | Date
    | undefined;
  /**
   * The end timestamp of the job. Typically this field is used for contracting
   * engagements. Invalid timestamps are ignored.
   */
  jobEndTime:
    | Date
    | undefined;
  /**
   * The timestamp this job posting was most recently published. The default
   * value is the time the request arrives at the server. Invalid timestamps are
   * ignored.
   */
  postingPublishTime:
    | Date
    | undefined;
  /**
   * Strongly recommended for the best service experience.
   *
   * The expiration timestamp of the job. After this timestamp, the
   * job is marked as expired, and it no longer appears in search results. The
   * expired job can't be listed by the
   * [ListJobs][google.cloud.talent.v4.JobService.ListJobs] API, but it can be
   * retrieved with the [GetJob][google.cloud.talent.v4.JobService.GetJob] API
   * or updated with the
   * [UpdateJob][google.cloud.talent.v4.JobService.UpdateJob] API or deleted
   * with the [DeleteJob][google.cloud.talent.v4.JobService.DeleteJob] API. An
   * expired job can be updated and opened again by using a future expiration
   * timestamp. Updating an expired job fails if there is another existing open
   * job with same [company][google.cloud.talent.v4.Job.company],
   * [language_code][google.cloud.talent.v4.Job.language_code] and
   * [requisition_id][google.cloud.talent.v4.Job.requisition_id].
   *
   * The expired jobs are retained in our system for 90 days. However, the
   * overall expired job count cannot exceed 3 times the maximum number of
   * open jobs over previous 7 days. If this threshold is exceeded,
   * expired jobs are cleaned out in order of earliest expire time.
   * Expired jobs are no longer accessible after they are cleaned
   * out.
   *
   * Invalid timestamps are ignored, and treated as expire time not provided.
   *
   * If the timestamp is before the instant request is made, the job
   * is treated as expired immediately on creation. This kind of job can
   * not be updated. And when creating a job with past timestamp, the
   * [posting_publish_time][google.cloud.talent.v4.Job.posting_publish_time]
   * must be set before
   * [posting_expire_time][google.cloud.talent.v4.Job.posting_expire_time]. The
   * purpose of this feature is to allow other objects, such as [Application][],
   * to refer a job that didn't exist in the system prior to becoming expired.
   * If you want to modify a job that was expired on creation, delete it and
   * create a new one.
   *
   * If this value isn't provided at the time of job creation or is invalid,
   * the job posting expires after 30 days from the job's creation time. For
   * example, if the job was created on 2017/01/01 13:00AM UTC with an
   * unspecified expiration date, the job expires after 2017/01/31 13:00AM UTC.
   *
   * If this value isn't provided on job update, it depends on the field masks
   * set by
   * [UpdateJobRequest.update_mask][google.cloud.talent.v4.UpdateJobRequest.update_mask].
   * If the field masks include
   * [job_end_time][google.cloud.talent.v4.Job.job_end_time], or the masks are
   * empty meaning that every field is updated, the job posting expires after 30
   * days from the job's last update time. Otherwise the expiration date isn't
   * updated.
   */
  postingExpireTime:
    | Date
    | undefined;
  /** Output only. The timestamp when this job posting was created. */
  postingCreateTime:
    | Date
    | undefined;
  /** Output only. The timestamp when this job posting was last updated. */
  postingUpdateTime:
    | Date
    | undefined;
  /** Output only. Display name of the company listing the job. */
  companyDisplayName: string;
  /** Output only. Derived details about the job posting. */
  derivedInfo:
    | Job_DerivedInfo
    | undefined;
  /** Options for job processing. */
  processingOptions: Job_ProcessingOptions | undefined;
}

/** Application related details of a job posting. */
export interface Job_ApplicationInfo {
  /**
   * Use this field to specify email address(es) to which resumes or
   * applications can be sent.
   *
   * The maximum number of allowed characters for each entry is 255.
   */
  emails: string[];
  /**
   * Use this field to provide instructions, such as "Mail your application
   * to ...", that a candidate can follow to apply for the job.
   *
   * This field accepts and sanitizes HTML input, and also accepts
   * bold, italic, ordered list, and unordered list markup tags.
   *
   * The maximum number of allowed characters is 3,000.
   */
  instruction: string;
  /**
   * Use this URI field to direct an applicant to a website, for example to
   * link to an online application form.
   *
   * The maximum number of allowed characters for each entry is 2,000.
   */
  uris: string[];
}

/** Derived details about the job posting. */
export interface Job_DerivedInfo {
  /**
   * Structured locations of the job, resolved from
   * [Job.addresses][google.cloud.talent.v4.Job.addresses].
   *
   * [locations][google.cloud.talent.v4.Job.DerivedInfo.locations] are exactly
   * matched to [Job.addresses][google.cloud.talent.v4.Job.addresses] in the
   * same order.
   */
  locations: Location[];
  /**
   * Job categories derived from [Job.title][google.cloud.talent.v4.Job.title]
   * and [Job.description][google.cloud.talent.v4.Job.description].
   */
  jobCategories: JobCategory[];
}

/** Options for job processing. */
export interface Job_ProcessingOptions {
  /**
   * If set to `true`, the service does not attempt to resolve a
   * more precise address for the job.
   */
  disableStreetAddressResolution: boolean;
  /**
   * Option for job HTML content sanitization. Applied fields are:
   *
   * * description
   * * applicationInfo.instruction
   * * incentives
   * * qualifications
   * * responsibilities
   *
   * HTML tags in these fields may be stripped if sanitiazation isn't
   * disabled.
   *
   * Defaults to
   * [HtmlSanitization.SIMPLE_FORMATTING_ONLY][google.cloud.talent.v4.HtmlSanitization.SIMPLE_FORMATTING_ONLY].
   */
  htmlSanitization: HtmlSanitization;
}

export interface Job_CustomAttributesEntry {
  key: string;
  value: CustomAttribute | undefined;
}

function createBaseJob(): Job {
  return {
    name: "",
    company: "",
    requisitionId: "",
    title: "",
    description: "",
    addresses: [],
    applicationInfo: undefined,
    jobBenefits: [],
    compensationInfo: undefined,
    customAttributes: {},
    degreeTypes: [],
    department: "",
    employmentTypes: [],
    incentives: "",
    languageCode: "",
    jobLevel: 0,
    promotionValue: 0,
    qualifications: "",
    responsibilities: "",
    postingRegion: 0,
    visibility: 0,
    jobStartTime: undefined,
    jobEndTime: undefined,
    postingPublishTime: undefined,
    postingExpireTime: undefined,
    postingCreateTime: undefined,
    postingUpdateTime: undefined,
    companyDisplayName: "",
    derivedInfo: undefined,
    processingOptions: undefined,
  };
}

export const Job: MessageFns<Job> = {
  encode(message: Job, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.company !== "") {
      writer.uint32(18).string(message.company);
    }
    if (message.requisitionId !== "") {
      writer.uint32(26).string(message.requisitionId);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.addresses) {
      writer.uint32(50).string(v!);
    }
    if (message.applicationInfo !== undefined) {
      Job_ApplicationInfo.encode(message.applicationInfo, writer.uint32(58).fork()).join();
    }
    writer.uint32(66).fork();
    for (const v of message.jobBenefits) {
      writer.int32(v);
    }
    writer.join();
    if (message.compensationInfo !== undefined) {
      CompensationInfo.encode(message.compensationInfo, writer.uint32(74).fork()).join();
    }
    Object.entries(message.customAttributes).forEach(([key, value]) => {
      Job_CustomAttributesEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    writer.uint32(90).fork();
    for (const v of message.degreeTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.department !== "") {
      writer.uint32(98).string(message.department);
    }
    writer.uint32(106).fork();
    for (const v of message.employmentTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.incentives !== "") {
      writer.uint32(114).string(message.incentives);
    }
    if (message.languageCode !== "") {
      writer.uint32(122).string(message.languageCode);
    }
    if (message.jobLevel !== 0) {
      writer.uint32(128).int32(message.jobLevel);
    }
    if (message.promotionValue !== 0) {
      writer.uint32(136).int32(message.promotionValue);
    }
    if (message.qualifications !== "") {
      writer.uint32(146).string(message.qualifications);
    }
    if (message.responsibilities !== "") {
      writer.uint32(154).string(message.responsibilities);
    }
    if (message.postingRegion !== 0) {
      writer.uint32(160).int32(message.postingRegion);
    }
    if (message.visibility !== 0) {
      writer.uint32(168).int32(message.visibility);
    }
    if (message.jobStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.jobStartTime), writer.uint32(178).fork()).join();
    }
    if (message.jobEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.jobEndTime), writer.uint32(186).fork()).join();
    }
    if (message.postingPublishTime !== undefined) {
      Timestamp.encode(toTimestamp(message.postingPublishTime), writer.uint32(194).fork()).join();
    }
    if (message.postingExpireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.postingExpireTime), writer.uint32(202).fork()).join();
    }
    if (message.postingCreateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.postingCreateTime), writer.uint32(210).fork()).join();
    }
    if (message.postingUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.postingUpdateTime), writer.uint32(218).fork()).join();
    }
    if (message.companyDisplayName !== "") {
      writer.uint32(226).string(message.companyDisplayName);
    }
    if (message.derivedInfo !== undefined) {
      Job_DerivedInfo.encode(message.derivedInfo, writer.uint32(234).fork()).join();
    }
    if (message.processingOptions !== undefined) {
      Job_ProcessingOptions.encode(message.processingOptions, writer.uint32(242).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.company = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requisitionId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.applicationInfo = Job_ApplicationInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag === 64) {
            message.jobBenefits.push(reader.int32() as any);

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.jobBenefits.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.compensationInfo = CompensationInfo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = Job_CustomAttributesEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.customAttributes[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag === 88) {
            message.degreeTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.degreeTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.department = reader.string();
          continue;
        case 13:
          if (tag === 104) {
            message.employmentTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.employmentTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.incentives = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.jobLevel = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.promotionValue = reader.int32();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.qualifications = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.responsibilities = reader.string();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.postingRegion = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.visibility = reader.int32() as any;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.jobStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.jobEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.postingPublishTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.postingExpireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.postingCreateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.postingUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.companyDisplayName = reader.string();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.derivedInfo = Job_DerivedInfo.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.processingOptions = Job_ProcessingOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      company: isSet(object.company) ? globalThis.String(object.company) : "",
      requisitionId: isSet(object.requisitionId) ? globalThis.String(object.requisitionId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => globalThis.String(e))
        : [],
      applicationInfo: isSet(object.applicationInfo) ? Job_ApplicationInfo.fromJSON(object.applicationInfo) : undefined,
      jobBenefits: globalThis.Array.isArray(object?.jobBenefits)
        ? object.jobBenefits.map((e: any) => jobBenefitFromJSON(e))
        : [],
      compensationInfo: isSet(object.compensationInfo) ? CompensationInfo.fromJSON(object.compensationInfo) : undefined,
      customAttributes: isObject(object.customAttributes)
        ? Object.entries(object.customAttributes).reduce<{ [key: string]: CustomAttribute }>((acc, [key, value]) => {
          acc[key] = CustomAttribute.fromJSON(value);
          return acc;
        }, {})
        : {},
      degreeTypes: globalThis.Array.isArray(object?.degreeTypes)
        ? object.degreeTypes.map((e: any) => degreeTypeFromJSON(e))
        : [],
      department: isSet(object.department) ? globalThis.String(object.department) : "",
      employmentTypes: globalThis.Array.isArray(object?.employmentTypes)
        ? object.employmentTypes.map((e: any) => employmentTypeFromJSON(e))
        : [],
      incentives: isSet(object.incentives) ? globalThis.String(object.incentives) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      jobLevel: isSet(object.jobLevel) ? jobLevelFromJSON(object.jobLevel) : 0,
      promotionValue: isSet(object.promotionValue) ? globalThis.Number(object.promotionValue) : 0,
      qualifications: isSet(object.qualifications) ? globalThis.String(object.qualifications) : "",
      responsibilities: isSet(object.responsibilities) ? globalThis.String(object.responsibilities) : "",
      postingRegion: isSet(object.postingRegion) ? postingRegionFromJSON(object.postingRegion) : 0,
      visibility: isSet(object.visibility) ? visibilityFromJSON(object.visibility) : 0,
      jobStartTime: isSet(object.jobStartTime) ? fromJsonTimestamp(object.jobStartTime) : undefined,
      jobEndTime: isSet(object.jobEndTime) ? fromJsonTimestamp(object.jobEndTime) : undefined,
      postingPublishTime: isSet(object.postingPublishTime) ? fromJsonTimestamp(object.postingPublishTime) : undefined,
      postingExpireTime: isSet(object.postingExpireTime) ? fromJsonTimestamp(object.postingExpireTime) : undefined,
      postingCreateTime: isSet(object.postingCreateTime) ? fromJsonTimestamp(object.postingCreateTime) : undefined,
      postingUpdateTime: isSet(object.postingUpdateTime) ? fromJsonTimestamp(object.postingUpdateTime) : undefined,
      companyDisplayName: isSet(object.companyDisplayName) ? globalThis.String(object.companyDisplayName) : "",
      derivedInfo: isSet(object.derivedInfo) ? Job_DerivedInfo.fromJSON(object.derivedInfo) : undefined,
      processingOptions: isSet(object.processingOptions)
        ? Job_ProcessingOptions.fromJSON(object.processingOptions)
        : undefined,
    };
  },

  toJSON(message: Job): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.company !== "") {
      obj.company = message.company;
    }
    if (message.requisitionId !== "") {
      obj.requisitionId = message.requisitionId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses;
    }
    if (message.applicationInfo !== undefined) {
      obj.applicationInfo = Job_ApplicationInfo.toJSON(message.applicationInfo);
    }
    if (message.jobBenefits?.length) {
      obj.jobBenefits = message.jobBenefits.map((e) => jobBenefitToJSON(e));
    }
    if (message.compensationInfo !== undefined) {
      obj.compensationInfo = CompensationInfo.toJSON(message.compensationInfo);
    }
    if (message.customAttributes) {
      const entries = Object.entries(message.customAttributes);
      if (entries.length > 0) {
        obj.customAttributes = {};
        entries.forEach(([k, v]) => {
          obj.customAttributes[k] = CustomAttribute.toJSON(v);
        });
      }
    }
    if (message.degreeTypes?.length) {
      obj.degreeTypes = message.degreeTypes.map((e) => degreeTypeToJSON(e));
    }
    if (message.department !== "") {
      obj.department = message.department;
    }
    if (message.employmentTypes?.length) {
      obj.employmentTypes = message.employmentTypes.map((e) => employmentTypeToJSON(e));
    }
    if (message.incentives !== "") {
      obj.incentives = message.incentives;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.jobLevel !== 0) {
      obj.jobLevel = jobLevelToJSON(message.jobLevel);
    }
    if (message.promotionValue !== 0) {
      obj.promotionValue = Math.round(message.promotionValue);
    }
    if (message.qualifications !== "") {
      obj.qualifications = message.qualifications;
    }
    if (message.responsibilities !== "") {
      obj.responsibilities = message.responsibilities;
    }
    if (message.postingRegion !== 0) {
      obj.postingRegion = postingRegionToJSON(message.postingRegion);
    }
    if (message.visibility !== 0) {
      obj.visibility = visibilityToJSON(message.visibility);
    }
    if (message.jobStartTime !== undefined) {
      obj.jobStartTime = message.jobStartTime.toISOString();
    }
    if (message.jobEndTime !== undefined) {
      obj.jobEndTime = message.jobEndTime.toISOString();
    }
    if (message.postingPublishTime !== undefined) {
      obj.postingPublishTime = message.postingPublishTime.toISOString();
    }
    if (message.postingExpireTime !== undefined) {
      obj.postingExpireTime = message.postingExpireTime.toISOString();
    }
    if (message.postingCreateTime !== undefined) {
      obj.postingCreateTime = message.postingCreateTime.toISOString();
    }
    if (message.postingUpdateTime !== undefined) {
      obj.postingUpdateTime = message.postingUpdateTime.toISOString();
    }
    if (message.companyDisplayName !== "") {
      obj.companyDisplayName = message.companyDisplayName;
    }
    if (message.derivedInfo !== undefined) {
      obj.derivedInfo = Job_DerivedInfo.toJSON(message.derivedInfo);
    }
    if (message.processingOptions !== undefined) {
      obj.processingOptions = Job_ProcessingOptions.toJSON(message.processingOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<Job>): Job {
    return Job.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Job>): Job {
    const message = createBaseJob();
    message.name = object.name ?? "";
    message.company = object.company ?? "";
    message.requisitionId = object.requisitionId ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.addresses = object.addresses?.map((e) => e) || [];
    message.applicationInfo = (object.applicationInfo !== undefined && object.applicationInfo !== null)
      ? Job_ApplicationInfo.fromPartial(object.applicationInfo)
      : undefined;
    message.jobBenefits = object.jobBenefits?.map((e) => e) || [];
    message.compensationInfo = (object.compensationInfo !== undefined && object.compensationInfo !== null)
      ? CompensationInfo.fromPartial(object.compensationInfo)
      : undefined;
    message.customAttributes = Object.entries(object.customAttributes ?? {}).reduce<{ [key: string]: CustomAttribute }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = CustomAttribute.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.degreeTypes = object.degreeTypes?.map((e) => e) || [];
    message.department = object.department ?? "";
    message.employmentTypes = object.employmentTypes?.map((e) => e) || [];
    message.incentives = object.incentives ?? "";
    message.languageCode = object.languageCode ?? "";
    message.jobLevel = object.jobLevel ?? 0;
    message.promotionValue = object.promotionValue ?? 0;
    message.qualifications = object.qualifications ?? "";
    message.responsibilities = object.responsibilities ?? "";
    message.postingRegion = object.postingRegion ?? 0;
    message.visibility = object.visibility ?? 0;
    message.jobStartTime = object.jobStartTime ?? undefined;
    message.jobEndTime = object.jobEndTime ?? undefined;
    message.postingPublishTime = object.postingPublishTime ?? undefined;
    message.postingExpireTime = object.postingExpireTime ?? undefined;
    message.postingCreateTime = object.postingCreateTime ?? undefined;
    message.postingUpdateTime = object.postingUpdateTime ?? undefined;
    message.companyDisplayName = object.companyDisplayName ?? "";
    message.derivedInfo = (object.derivedInfo !== undefined && object.derivedInfo !== null)
      ? Job_DerivedInfo.fromPartial(object.derivedInfo)
      : undefined;
    message.processingOptions = (object.processingOptions !== undefined && object.processingOptions !== null)
      ? Job_ProcessingOptions.fromPartial(object.processingOptions)
      : undefined;
    return message;
  },
};

function createBaseJob_ApplicationInfo(): Job_ApplicationInfo {
  return { emails: [], instruction: "", uris: [] };
}

export const Job_ApplicationInfo: MessageFns<Job_ApplicationInfo> = {
  encode(message: Job_ApplicationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.emails) {
      writer.uint32(10).string(v!);
    }
    if (message.instruction !== "") {
      writer.uint32(18).string(message.instruction);
    }
    for (const v of message.uris) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job_ApplicationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob_ApplicationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.emails.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instruction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uris.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job_ApplicationInfo {
    return {
      emails: globalThis.Array.isArray(object?.emails) ? object.emails.map((e: any) => globalThis.String(e)) : [],
      instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : "",
      uris: globalThis.Array.isArray(object?.uris) ? object.uris.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Job_ApplicationInfo): unknown {
    const obj: any = {};
    if (message.emails?.length) {
      obj.emails = message.emails;
    }
    if (message.instruction !== "") {
      obj.instruction = message.instruction;
    }
    if (message.uris?.length) {
      obj.uris = message.uris;
    }
    return obj;
  },

  create(base?: DeepPartial<Job_ApplicationInfo>): Job_ApplicationInfo {
    return Job_ApplicationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Job_ApplicationInfo>): Job_ApplicationInfo {
    const message = createBaseJob_ApplicationInfo();
    message.emails = object.emails?.map((e) => e) || [];
    message.instruction = object.instruction ?? "";
    message.uris = object.uris?.map((e) => e) || [];
    return message;
  },
};

function createBaseJob_DerivedInfo(): Job_DerivedInfo {
  return { locations: [], jobCategories: [] };
}

export const Job_DerivedInfo: MessageFns<Job_DerivedInfo> = {
  encode(message: Job_DerivedInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.locations) {
      Location.encode(v!, writer.uint32(10).fork()).join();
    }
    writer.uint32(26).fork();
    for (const v of message.jobCategories) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job_DerivedInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob_DerivedInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.locations.push(Location.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag === 24) {
            message.jobCategories.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.jobCategories.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job_DerivedInfo {
    return {
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => Location.fromJSON(e))
        : [],
      jobCategories: globalThis.Array.isArray(object?.jobCategories)
        ? object.jobCategories.map((e: any) => jobCategoryFromJSON(e))
        : [],
    };
  },

  toJSON(message: Job_DerivedInfo): unknown {
    const obj: any = {};
    if (message.locations?.length) {
      obj.locations = message.locations.map((e) => Location.toJSON(e));
    }
    if (message.jobCategories?.length) {
      obj.jobCategories = message.jobCategories.map((e) => jobCategoryToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Job_DerivedInfo>): Job_DerivedInfo {
    return Job_DerivedInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Job_DerivedInfo>): Job_DerivedInfo {
    const message = createBaseJob_DerivedInfo();
    message.locations = object.locations?.map((e) => Location.fromPartial(e)) || [];
    message.jobCategories = object.jobCategories?.map((e) => e) || [];
    return message;
  },
};

function createBaseJob_ProcessingOptions(): Job_ProcessingOptions {
  return { disableStreetAddressResolution: false, htmlSanitization: 0 };
}

export const Job_ProcessingOptions: MessageFns<Job_ProcessingOptions> = {
  encode(message: Job_ProcessingOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disableStreetAddressResolution !== false) {
      writer.uint32(8).bool(message.disableStreetAddressResolution);
    }
    if (message.htmlSanitization !== 0) {
      writer.uint32(16).int32(message.htmlSanitization);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job_ProcessingOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob_ProcessingOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disableStreetAddressResolution = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.htmlSanitization = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job_ProcessingOptions {
    return {
      disableStreetAddressResolution: isSet(object.disableStreetAddressResolution)
        ? globalThis.Boolean(object.disableStreetAddressResolution)
        : false,
      htmlSanitization: isSet(object.htmlSanitization) ? htmlSanitizationFromJSON(object.htmlSanitization) : 0,
    };
  },

  toJSON(message: Job_ProcessingOptions): unknown {
    const obj: any = {};
    if (message.disableStreetAddressResolution !== false) {
      obj.disableStreetAddressResolution = message.disableStreetAddressResolution;
    }
    if (message.htmlSanitization !== 0) {
      obj.htmlSanitization = htmlSanitizationToJSON(message.htmlSanitization);
    }
    return obj;
  },

  create(base?: DeepPartial<Job_ProcessingOptions>): Job_ProcessingOptions {
    return Job_ProcessingOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Job_ProcessingOptions>): Job_ProcessingOptions {
    const message = createBaseJob_ProcessingOptions();
    message.disableStreetAddressResolution = object.disableStreetAddressResolution ?? false;
    message.htmlSanitization = object.htmlSanitization ?? 0;
    return message;
  },
};

function createBaseJob_CustomAttributesEntry(): Job_CustomAttributesEntry {
  return { key: "", value: undefined };
}

export const Job_CustomAttributesEntry: MessageFns<Job_CustomAttributesEntry> = {
  encode(message: Job_CustomAttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CustomAttribute.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job_CustomAttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob_CustomAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = CustomAttribute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job_CustomAttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CustomAttribute.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Job_CustomAttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CustomAttribute.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Job_CustomAttributesEntry>): Job_CustomAttributesEntry {
    return Job_CustomAttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Job_CustomAttributesEntry>): Job_CustomAttributesEntry {
    const message = createBaseJob_CustomAttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CustomAttribute.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
