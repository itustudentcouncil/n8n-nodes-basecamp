// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/talent/v4/job_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Duration } from "../../../protobuf/duration.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Status } from "../../../rpc/status.js";
import { Location, RequestMetadata, ResponseMetadata, SpellingCorrection } from "./common.js";
import { JobQuery } from "./filters.js";
import { HistogramQuery, HistogramQueryResult } from "./histogram.js";
import { Job } from "./job.js";

export const protobufPackage = "google.cloud.talent.v4";

/**
 * An enum that specifies the job attributes that are returned in the
 * [MatchingJob.job][google.cloud.talent.v4.SearchJobsResponse.MatchingJob.job]
 * or [ListJobsResponse.jobs][google.cloud.talent.v4.ListJobsResponse.jobs]
 * fields.
 */
export enum JobView {
  /** JOB_VIEW_UNSPECIFIED - Default value. */
  JOB_VIEW_UNSPECIFIED = 0,
  /**
   * JOB_VIEW_ID_ONLY - A ID only view of job, with following attributes:
   * [Job.name][google.cloud.talent.v4.Job.name],
   * [Job.requisition_id][google.cloud.talent.v4.Job.requisition_id],
   * [Job.language_code][google.cloud.talent.v4.Job.language_code].
   */
  JOB_VIEW_ID_ONLY = 1,
  /**
   * JOB_VIEW_MINIMAL - A minimal view of the job, with the following attributes:
   * [Job.name][google.cloud.talent.v4.Job.name],
   * [Job.requisition_id][google.cloud.talent.v4.Job.requisition_id],
   * [Job.title][google.cloud.talent.v4.Job.title],
   * [Job.company][google.cloud.talent.v4.Job.company],
   * [Job.DerivedInfo.locations][google.cloud.talent.v4.Job.DerivedInfo.locations],
   * [Job.language_code][google.cloud.talent.v4.Job.language_code].
   */
  JOB_VIEW_MINIMAL = 2,
  /**
   * JOB_VIEW_SMALL - A small view of the job, with the following attributes in the search
   * results: [Job.name][google.cloud.talent.v4.Job.name],
   * [Job.requisition_id][google.cloud.talent.v4.Job.requisition_id],
   * [Job.title][google.cloud.talent.v4.Job.title],
   * [Job.company][google.cloud.talent.v4.Job.company],
   * [Job.DerivedInfo.locations][google.cloud.talent.v4.Job.DerivedInfo.locations],
   * [Job.visibility][google.cloud.talent.v4.Job.visibility],
   * [Job.language_code][google.cloud.talent.v4.Job.language_code],
   * [Job.description][google.cloud.talent.v4.Job.description].
   */
  JOB_VIEW_SMALL = 3,
  /** JOB_VIEW_FULL - All available attributes are included in the search results. */
  JOB_VIEW_FULL = 4,
  UNRECOGNIZED = -1,
}

export function jobViewFromJSON(object: any): JobView {
  switch (object) {
    case 0:
    case "JOB_VIEW_UNSPECIFIED":
      return JobView.JOB_VIEW_UNSPECIFIED;
    case 1:
    case "JOB_VIEW_ID_ONLY":
      return JobView.JOB_VIEW_ID_ONLY;
    case 2:
    case "JOB_VIEW_MINIMAL":
      return JobView.JOB_VIEW_MINIMAL;
    case 3:
    case "JOB_VIEW_SMALL":
      return JobView.JOB_VIEW_SMALL;
    case 4:
    case "JOB_VIEW_FULL":
      return JobView.JOB_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JobView.UNRECOGNIZED;
  }
}

export function jobViewToJSON(object: JobView): string {
  switch (object) {
    case JobView.JOB_VIEW_UNSPECIFIED:
      return "JOB_VIEW_UNSPECIFIED";
    case JobView.JOB_VIEW_ID_ONLY:
      return "JOB_VIEW_ID_ONLY";
    case JobView.JOB_VIEW_MINIMAL:
      return "JOB_VIEW_MINIMAL";
    case JobView.JOB_VIEW_SMALL:
      return "JOB_VIEW_SMALL";
    case JobView.JOB_VIEW_FULL:
      return "JOB_VIEW_FULL";
    case JobView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Create job request. */
export interface CreateJobRequest {
  /**
   * Required. The resource name of the tenant under which the job is created.
   *
   * The format is "projects/{project_id}/tenants/{tenant_id}". For example,
   * "projects/foo/tenants/bar".
   */
  parent: string;
  /** Required. The Job to be created. */
  job: Job | undefined;
}

/** Get job request. */
export interface GetJobRequest {
  /**
   * Required. The resource name of the job to retrieve.
   *
   * The format is
   * "projects/{project_id}/tenants/{tenant_id}/jobs/{job_id}". For
   * example, "projects/foo/tenants/bar/jobs/baz".
   */
  name: string;
}

/** Update job request. */
export interface UpdateJobRequest {
  /** Required. The Job to be updated. */
  job:
    | Job
    | undefined;
  /**
   * Strongly recommended for the best service experience.
   *
   * If [update_mask][google.cloud.talent.v4.UpdateJobRequest.update_mask] is
   * provided, only the specified fields in
   * [job][google.cloud.talent.v4.UpdateJobRequest.job] are updated. Otherwise
   * all the fields are updated.
   *
   * A field mask to restrict the fields that are updated. Only
   * top level fields of [Job][google.cloud.talent.v4.Job] are supported.
   */
  updateMask: string[] | undefined;
}

/** Delete job request. */
export interface DeleteJobRequest {
  /**
   * Required. The resource name of the job to be deleted.
   *
   * The format is
   * "projects/{project_id}/tenants/{tenant_id}/jobs/{job_id}". For
   * example, "projects/foo/tenants/bar/jobs/baz".
   */
  name: string;
}

/** List jobs request. */
export interface ListJobsRequest {
  /**
   * Required. The resource name of the tenant under which the job is created.
   *
   * The format is "projects/{project_id}/tenants/{tenant_id}". For example,
   * "projects/foo/tenants/bar".
   */
  parent: string;
  /**
   * Required. The filter string specifies the jobs to be enumerated.
   *
   * Supported operator: =, AND
   *
   * The fields eligible for filtering are:
   *
   * * `companyName`
   * * `requisitionId`
   * * `status` Available values: OPEN, EXPIRED, ALL. Defaults to
   * OPEN if no value is specified.
   *
   * At least one of `companyName` and `requisitionId` must present or an
   * INVALID_ARGUMENT error is thrown.
   *
   * Sample Query:
   *
   * * companyName = "projects/foo/tenants/bar/companies/baz"
   * * companyName = "projects/foo/tenants/bar/companies/baz" AND
   * requisitionId = "req-1"
   * * companyName = "projects/foo/tenants/bar/companies/baz" AND
   * status = "EXPIRED"
   * * requisitionId = "req-1"
   * * requisitionId = "req-1" AND status = "EXPIRED"
   */
  filter: string;
  /** The starting point of a query result. */
  pageToken: string;
  /**
   * The maximum number of jobs to be returned per page of results.
   *
   * If [job_view][google.cloud.talent.v4.ListJobsRequest.job_view] is set to
   * [JobView.JOB_VIEW_ID_ONLY][google.cloud.talent.v4.JobView.JOB_VIEW_ID_ONLY],
   * the maximum allowed page size is 1000. Otherwise, the maximum allowed page
   * size is 100.
   *
   * Default is 100 if empty or a number < 1 is specified.
   */
  pageSize: number;
  /**
   * The desired job attributes returned for jobs in the
   * search response. Defaults to
   * [JobView.JOB_VIEW_FULL][google.cloud.talent.v4.JobView.JOB_VIEW_FULL] if no
   * value is specified.
   */
  jobView: JobView;
}

/** List jobs response. */
export interface ListJobsResponse {
  /**
   * The Jobs for a given company.
   *
   * The maximum number of items returned is based on the limit field
   * provided in the request.
   */
  jobs: Job[];
  /** A token to retrieve the next page of results. */
  nextPageToken: string;
  /**
   * Additional information for the API invocation, such as the request
   * tracking id.
   */
  metadata: ResponseMetadata | undefined;
}

/** The Request body of the `SearchJobs` call. */
export interface SearchJobsRequest {
  /**
   * Required. The resource name of the tenant to search within.
   *
   * The format is "projects/{project_id}/tenants/{tenant_id}". For example,
   * "projects/foo/tenants/bar".
   */
  parent: string;
  /**
   * Mode of a search.
   *
   * Defaults to
   * [SearchMode.JOB_SEARCH][google.cloud.talent.v4.SearchJobsRequest.SearchMode.JOB_SEARCH].
   */
  searchMode: SearchJobsRequest_SearchMode;
  /**
   * Required. The meta information collected about the job searcher, used to
   * improve the search quality of the service. The identifiers (such as
   * `user_id`) are provided by users, and must be unique and consistent.
   */
  requestMetadata:
    | RequestMetadata
    | undefined;
  /** Query used to search against jobs, such as keyword, location filters, etc. */
  jobQuery:
    | JobQuery
    | undefined;
  /**
   * Controls whether to broaden the search when it produces sparse results.
   * Broadened queries append results to the end of the matching results
   * list.
   *
   * Defaults to false.
   */
  enableBroadening: boolean;
  /**
   * An expression specifies a histogram request against matching jobs.
   *
   * Expression syntax is an aggregation function call with histogram facets and
   * other options.
   *
   * Available aggregation function calls are:
   * * `count(string_histogram_facet)`: Count the number of matching entities,
   * for each distinct attribute value.
   * * `count(numeric_histogram_facet, list of buckets)`: Count the number of
   * matching entities within each bucket.
   *
   * A maximum of 200 histogram buckets are supported.
   *
   * Data types:
   *
   * * Histogram facet: facet names with format `[a-zA-Z][a-zA-Z0-9_]+`.
   * * String: string like "any string with backslash escape for quote(\")."
   * * Number: whole number and floating point number like 10, -1 and -0.01.
   * * List: list of elements with comma(,) separator surrounded by square
   * brackets, for example, [1, 2, 3] and ["one", "two", "three"].
   *
   * Built-in constants:
   *
   * * MIN (minimum number similar to java Double.MIN_VALUE)
   * * MAX (maximum number similar to java Double.MAX_VALUE)
   *
   * Built-in functions:
   *
   * * bucket(start, end[, label]): bucket built-in function creates a bucket
   * with range of [start, end). Note that the end is exclusive, for example,
   * bucket(1, MAX, "positive number") or bucket(1, 10).
   *
   * Job histogram facets:
   *
   * * company_display_name: histogram by
   * [Job.company_display_name][google.cloud.talent.v4.Job.company_display_name].
   * * employment_type: histogram by
   * [Job.employment_types][google.cloud.talent.v4.Job.employment_types], for
   * example,
   *   "FULL_TIME", "PART_TIME".
   * * company_size (DEPRECATED): histogram by
   * [CompanySize][google.cloud.talent.v4.CompanySize], for example, "SMALL",
   * "MEDIUM", "BIG".
   * * publish_time_in_day: histogram by the
   * [Job.posting_publish_time][google.cloud.talent.v4.Job.posting_publish_time]
   *   in days.
   *   Must specify list of numeric buckets in spec.
   * * publish_time_in_month: histogram by the
   * [Job.posting_publish_time][google.cloud.talent.v4.Job.posting_publish_time]
   *   in months.
   *   Must specify list of numeric buckets in spec.
   * * publish_time_in_year: histogram by the
   * [Job.posting_publish_time][google.cloud.talent.v4.Job.posting_publish_time]
   *   in years.
   *   Must specify list of numeric buckets in spec.
   * * degree_types: histogram by the
   * [Job.degree_types][google.cloud.talent.v4.Job.degree_types], for example,
   *   "Bachelors", "Masters".
   * * job_level: histogram by the
   * [Job.job_level][google.cloud.talent.v4.Job.job_level], for example, "Entry
   *   Level".
   * * country: histogram by the country code of jobs, for example, "US", "FR".
   * * admin1: histogram by the admin1 code of jobs, which is a global
   *   placeholder referring to the state, province, or the particular term a
   *   country uses to define the geographic structure below the country level,
   *   for example, "CA", "IL".
   * * city: histogram by a combination of the "city name, admin1 code". For
   *   example,  "Mountain View, CA", "New York, NY".
   * * admin1_country: histogram by a combination of the "admin1 code, country",
   *   for example, "CA, US", "IL, US".
   * * city_coordinate: histogram by the city center's GPS coordinates (latitude
   *   and longitude), for example, 37.4038522,-122.0987765. Since the
   *   coordinates of a city center can change, customers may need to refresh
   *   them periodically.
   * * locale: histogram by the
   * [Job.language_code][google.cloud.talent.v4.Job.language_code], for example,
   * "en-US",
   *   "fr-FR".
   * * language: histogram by the language subtag of the
   * [Job.language_code][google.cloud.talent.v4.Job.language_code],
   *   for example, "en", "fr".
   * * category: histogram by the
   * [JobCategory][google.cloud.talent.v4.JobCategory], for example,
   *   "COMPUTER_AND_IT", "HEALTHCARE".
   * * base_compensation_unit: histogram by the
   *   [CompensationInfo.CompensationUnit][google.cloud.talent.v4.CompensationInfo.CompensationUnit]
   *   of base salary, for example, "WEEKLY", "MONTHLY".
   * * base_compensation: histogram by the base salary. Must specify list of
   *   numeric buckets to group results by.
   * * annualized_base_compensation: histogram by the base annualized salary.
   *   Must specify list of numeric buckets to group results by.
   * * annualized_total_compensation: histogram by the total annualized salary.
   *   Must specify list of numeric buckets to group results by.
   * * string_custom_attribute: histogram by string
   * [Job.custom_attributes][google.cloud.talent.v4.Job.custom_attributes].
   *   Values can be accessed via square bracket notations like
   *   string_custom_attribute["key1"].
   * * numeric_custom_attribute: histogram by numeric
   * [Job.custom_attributes][google.cloud.talent.v4.Job.custom_attributes].
   *   Values can be accessed via square bracket notations like
   *   numeric_custom_attribute["key1"]. Must specify list of numeric buckets to
   *   group results by.
   *
   * Example expressions:
   *
   * * `count(admin1)`
   * * `count(base_compensation, [bucket(1000, 10000), bucket(10000, 100000),
   * bucket(100000, MAX)])`
   * * `count(string_custom_attribute["some-string-custom-attribute"])`
   * * `count(numeric_custom_attribute["some-numeric-custom-attribute"],
   *   [bucket(MIN, 0, "negative"), bucket(0, MAX, "non-negative")])`
   */
  histogramQueries: HistogramQuery[];
  /**
   * The desired job attributes returned for jobs in the search response.
   * Defaults to
   * [JobView.JOB_VIEW_SMALL][google.cloud.talent.v4.JobView.JOB_VIEW_SMALL] if
   * no value is specified.
   */
  jobView: JobView;
  /**
   * An integer that specifies the current offset (that is, starting result
   * location, amongst the jobs deemed by the API as relevant) in search
   * results. This field is only considered if
   * [page_token][google.cloud.talent.v4.SearchJobsRequest.page_token] is unset.
   *
   * The maximum allowed value is 5000. Otherwise an error is thrown.
   *
   * For example, 0 means to  return results starting from the first matching
   * job, and 10 means to return from the 11th job. This can be used for
   * pagination, (for example, pageSize = 10 and offset = 10 means to return
   * from the second page).
   */
  offset: number;
  /**
   * A limit on the number of jobs returned in the search results.
   * Increasing this value above the default value of 10 can increase search
   * response time. The value can be between 1 and 100.
   */
  maxPageSize: number;
  /**
   * The token specifying the current offset within
   * search results. See
   * [SearchJobsResponse.next_page_token][google.cloud.talent.v4.SearchJobsResponse.next_page_token]
   * for an explanation of how to obtain the next set of query results.
   */
  pageToken: string;
  /**
   * The criteria determining how search results are sorted. Default is
   * `"relevance desc"`.
   *
   * Supported options are:
   *
   * * `"relevance desc"`: By relevance descending, as determined by the API
   *   algorithms. Relevance thresholding of query results is only available
   *   with this ordering.
   * * `"posting_publish_time desc"`: By
   * [Job.posting_publish_time][google.cloud.talent.v4.Job.posting_publish_time]
   *   descending.
   * * `"posting_update_time desc"`: By
   * [Job.posting_update_time][google.cloud.talent.v4.Job.posting_update_time]
   *   descending.
   * * `"title"`: By [Job.title][google.cloud.talent.v4.Job.title] ascending.
   * * `"title desc"`: By [Job.title][google.cloud.talent.v4.Job.title]
   * descending.
   * * `"annualized_base_compensation"`: By job's
   *   [CompensationInfo.annualized_base_compensation_range][google.cloud.talent.v4.CompensationInfo.annualized_base_compensation_range]
   *   ascending. Jobs whose annualized base compensation is unspecified are put
   *   at the end of search results.
   * * `"annualized_base_compensation desc"`: By job's
   *   [CompensationInfo.annualized_base_compensation_range][google.cloud.talent.v4.CompensationInfo.annualized_base_compensation_range]
   *   descending. Jobs whose annualized base compensation is unspecified are
   *   put at the end of search results.
   * * `"annualized_total_compensation"`: By job's
   *   [CompensationInfo.annualized_total_compensation_range][google.cloud.talent.v4.CompensationInfo.annualized_total_compensation_range]
   *   ascending. Jobs whose annualized base compensation is unspecified are put
   *   at the end of search results.
   * * `"annualized_total_compensation desc"`: By job's
   *   [CompensationInfo.annualized_total_compensation_range][google.cloud.talent.v4.CompensationInfo.annualized_total_compensation_range]
   *   descending. Jobs whose annualized base compensation is unspecified are
   *   put at the end of search results.
   * * `"custom_ranking desc"`: By the relevance score adjusted to the
   *   [SearchJobsRequest.CustomRankingInfo.ranking_expression][google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo.ranking_expression]
   *   with weight factor assigned by
   *   [SearchJobsRequest.CustomRankingInfo.importance_level][google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo.importance_level]
   *   in descending order.
   * * Location sorting: Use the special syntax to order jobs by distance:<br>
   *   `"distance_from('Hawaii')"`: Order by distance from Hawaii.<br>
   *   `"distance_from(19.89, 155.5)"`: Order by distance from a coordinate.<br>
   *   `"distance_from('Hawaii'), distance_from('Puerto Rico')"`: Order by
   *   multiple locations. See details below.<br>
   *   `"distance_from('Hawaii'), distance_from(19.89, 155.5)"`: Order by
   *   multiple locations. See details below.<br>
   *   The string can have a maximum of 256 characters. When multiple distance
   *   centers are provided, a job that is close to any of the distance centers
   *   would have a high rank. When a job has multiple locations, the job
   *   location closest to one of the distance centers will be used. Jobs that
   *   don't have locations will be ranked at the bottom. Distance is calculated
   *   with a precision of 11.3 meters (37.4 feet). Diversification strategy is
   *   still applied unless explicitly disabled in
   *   [diversification_level][google.cloud.talent.v4.SearchJobsRequest.diversification_level].
   */
  orderBy: string;
  /**
   * Controls whether highly similar jobs are returned next to each other in
   * the search results. Jobs are identified as highly similar based on
   * their titles, job categories, and locations. Highly similar results are
   * clustered so that only one representative job of the cluster is
   * displayed to the job seeker higher up in the results, with the other jobs
   * being displayed lower down in the results.
   *
   * Defaults to
   * [DiversificationLevel.SIMPLE][google.cloud.talent.v4.SearchJobsRequest.DiversificationLevel.SIMPLE]
   * if no value is specified.
   */
  diversificationLevel: SearchJobsRequest_DiversificationLevel;
  /**
   * Controls over how job documents get ranked on top of existing relevance
   * score (determined by API algorithm).
   */
  customRankingInfo:
    | SearchJobsRequest_CustomRankingInfo
    | undefined;
  /**
   * This field is deprecated. Please use
   * [SearchJobsRequest.keyword_match_mode][google.cloud.talent.v4.SearchJobsRequest.keyword_match_mode]
   * going forward.
   *
   * To migrate, disable_keyword_match set to false maps to
   * [KeywordMatchMode.KEYWORD_MATCH_ALL][google.cloud.talent.v4.SearchJobsRequest.KeywordMatchMode.KEYWORD_MATCH_ALL],
   * and disable_keyword_match set to true maps to
   * [KeywordMatchMode.KEYWORD_MATCH_DISABLED][google.cloud.talent.v4.SearchJobsRequest.KeywordMatchMode.KEYWORD_MATCH_DISABLED].
   * If
   * [SearchJobsRequest.keyword_match_mode][google.cloud.talent.v4.SearchJobsRequest.keyword_match_mode]
   * is set, this field is ignored.
   *
   * Controls whether to disable exact keyword match on
   * [Job.title][google.cloud.talent.v4.Job.title],
   * [Job.description][google.cloud.talent.v4.Job.description],
   * [Job.company_display_name][google.cloud.talent.v4.Job.company_display_name],
   * [Job.addresses][google.cloud.talent.v4.Job.addresses],
   * [Job.qualifications][google.cloud.talent.v4.Job.qualifications]. When
   * disable keyword match is turned off, a keyword match returns jobs that do
   * not match given category filters when there are matching keywords. For
   * example, for the query "program manager," a result is returned even if the
   * job posting has the title "software developer," which doesn't fall into
   * "program manager" ontology, but does have "program manager" appearing in
   * its description.
   *
   * For queries like "cloud" that don't contain title or
   * location specific ontology, jobs with "cloud" keyword matches are returned
   * regardless of this flag's value.
   *
   * Use
   * [Company.keyword_searchable_job_custom_attributes][google.cloud.talent.v4.Company.keyword_searchable_job_custom_attributes]
   * if company-specific globally matched custom field/attribute string values
   * are needed. Enabling keyword match improves recall of subsequent search
   * requests.
   *
   * Defaults to false.
   *
   * @deprecated
   */
  disableKeywordMatch: boolean;
  /**
   * Controls what keyword match options to use. If both keyword_match_mode and
   * disable_keyword_match are set, keyword_match_mode will take precedence.
   *
   * Defaults to
   * [KeywordMatchMode.KEYWORD_MATCH_ALL][google.cloud.talent.v4.SearchJobsRequest.KeywordMatchMode.KEYWORD_MATCH_ALL]
   * if no value is specified.
   */
  keywordMatchMode: SearchJobsRequest_KeywordMatchMode;
}

/**
 * A string-represented enumeration of the job search mode. The service
 * operate differently for different modes of service.
 */
export enum SearchJobsRequest_SearchMode {
  /**
   * SEARCH_MODE_UNSPECIFIED - The mode of the search method isn't specified. The default search
   * behavior is identical to JOB_SEARCH search behavior.
   */
  SEARCH_MODE_UNSPECIFIED = 0,
  /**
   * JOB_SEARCH - The job search matches against all jobs, and featured jobs
   * (jobs with promotionValue > 0) are not specially handled.
   */
  JOB_SEARCH = 1,
  /**
   * FEATURED_JOB_SEARCH - The job search matches only against featured jobs (jobs with a
   * promotionValue > 0). This method doesn't return any jobs having a
   * promotionValue <= 0. The search results order is determined by the
   * promotionValue (jobs with a higher promotionValue are returned higher up
   * in the search results), with relevance being used as a tiebreaker.
   */
  FEATURED_JOB_SEARCH = 2,
  UNRECOGNIZED = -1,
}

export function searchJobsRequest_SearchModeFromJSON(object: any): SearchJobsRequest_SearchMode {
  switch (object) {
    case 0:
    case "SEARCH_MODE_UNSPECIFIED":
      return SearchJobsRequest_SearchMode.SEARCH_MODE_UNSPECIFIED;
    case 1:
    case "JOB_SEARCH":
      return SearchJobsRequest_SearchMode.JOB_SEARCH;
    case 2:
    case "FEATURED_JOB_SEARCH":
      return SearchJobsRequest_SearchMode.FEATURED_JOB_SEARCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchJobsRequest_SearchMode.UNRECOGNIZED;
  }
}

export function searchJobsRequest_SearchModeToJSON(object: SearchJobsRequest_SearchMode): string {
  switch (object) {
    case SearchJobsRequest_SearchMode.SEARCH_MODE_UNSPECIFIED:
      return "SEARCH_MODE_UNSPECIFIED";
    case SearchJobsRequest_SearchMode.JOB_SEARCH:
      return "JOB_SEARCH";
    case SearchJobsRequest_SearchMode.FEATURED_JOB_SEARCH:
      return "FEATURED_JOB_SEARCH";
    case SearchJobsRequest_SearchMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Controls whether highly similar jobs are returned next to each other in
 * the search results. Jobs are identified as highly similar based on
 * their titles, job categories, and locations. Highly similar results are
 * clustered so that only one representative job of the cluster is
 * displayed to the job seeker higher up in the results, with the other jobs
 * being displayed lower down in the results.
 *
 * If you are using pageToken to page through the result set,
 * latency might be lower but we can't guarantee that all results are
 * returned. If you are using page offset, latency might be higher but all
 * results are returned.
 */
export enum SearchJobsRequest_DiversificationLevel {
  /** DIVERSIFICATION_LEVEL_UNSPECIFIED - The diversification level isn't specified. */
  DIVERSIFICATION_LEVEL_UNSPECIFIED = 0,
  /**
   * DISABLED - Disables diversification. Jobs that would normally be pushed to the last
   * page would not have their positions altered. This may result in highly
   * similar jobs appearing in sequence in the search results.
   */
  DISABLED = 1,
  /**
   * SIMPLE - Default diversifying behavior. The result list is ordered so that
   * highly similar results are pushed to the end of the last page of search
   * results.
   */
  SIMPLE = 2,
  /**
   * ONE_PER_COMPANY - Only one job from the same company will be shown at once, other jobs
   * under same company are pushed to the end of the last page of search
   * result.
   */
  ONE_PER_COMPANY = 3,
  /**
   * TWO_PER_COMPANY - Similar to ONE_PER_COMPANY, but it allows at most two jobs in the
   * same company to be shown at once, the other jobs under same company are
   * pushed to the end of the last page of search result.
   */
  TWO_PER_COMPANY = 4,
  /**
   * MAX_THREE_PER_COMPANY - Similar to ONE_PER_COMPANY, but it allows at most three jobs in the
   * same company to be shown at once, the other jobs under same company are
   * dropped.
   */
  MAX_THREE_PER_COMPANY = 6,
  /**
   * DIVERSIFY_BY_LOOSER_SIMILARITY - The result list is ordered such that somewhat similar results are pushed
   * to the end of the last page of the search results. This option is
   * recommended if SIMPLE diversification does not diversify enough.
   */
  DIVERSIFY_BY_LOOSER_SIMILARITY = 5,
  UNRECOGNIZED = -1,
}

export function searchJobsRequest_DiversificationLevelFromJSON(object: any): SearchJobsRequest_DiversificationLevel {
  switch (object) {
    case 0:
    case "DIVERSIFICATION_LEVEL_UNSPECIFIED":
      return SearchJobsRequest_DiversificationLevel.DIVERSIFICATION_LEVEL_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return SearchJobsRequest_DiversificationLevel.DISABLED;
    case 2:
    case "SIMPLE":
      return SearchJobsRequest_DiversificationLevel.SIMPLE;
    case 3:
    case "ONE_PER_COMPANY":
      return SearchJobsRequest_DiversificationLevel.ONE_PER_COMPANY;
    case 4:
    case "TWO_PER_COMPANY":
      return SearchJobsRequest_DiversificationLevel.TWO_PER_COMPANY;
    case 6:
    case "MAX_THREE_PER_COMPANY":
      return SearchJobsRequest_DiversificationLevel.MAX_THREE_PER_COMPANY;
    case 5:
    case "DIVERSIFY_BY_LOOSER_SIMILARITY":
      return SearchJobsRequest_DiversificationLevel.DIVERSIFY_BY_LOOSER_SIMILARITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchJobsRequest_DiversificationLevel.UNRECOGNIZED;
  }
}

export function searchJobsRequest_DiversificationLevelToJSON(object: SearchJobsRequest_DiversificationLevel): string {
  switch (object) {
    case SearchJobsRequest_DiversificationLevel.DIVERSIFICATION_LEVEL_UNSPECIFIED:
      return "DIVERSIFICATION_LEVEL_UNSPECIFIED";
    case SearchJobsRequest_DiversificationLevel.DISABLED:
      return "DISABLED";
    case SearchJobsRequest_DiversificationLevel.SIMPLE:
      return "SIMPLE";
    case SearchJobsRequest_DiversificationLevel.ONE_PER_COMPANY:
      return "ONE_PER_COMPANY";
    case SearchJobsRequest_DiversificationLevel.TWO_PER_COMPANY:
      return "TWO_PER_COMPANY";
    case SearchJobsRequest_DiversificationLevel.MAX_THREE_PER_COMPANY:
      return "MAX_THREE_PER_COMPANY";
    case SearchJobsRequest_DiversificationLevel.DIVERSIFY_BY_LOOSER_SIMILARITY:
      return "DIVERSIFY_BY_LOOSER_SIMILARITY";
    case SearchJobsRequest_DiversificationLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Controls what keyword matching behavior the search has. When keyword
 * matching is enabled, a keyword match returns jobs that may not match given
 * category filters when there are matching keywords. For example, for the
 * query "program manager" with KeywordMatchMode set to KEYWORD_MATCH_ALL, a
 * job posting with the title "software developer," which doesn't fall into
 * "program manager" ontology, and "program manager" appearing in its
 * description will be surfaced.
 *
 * For queries like "cloud" that don't contain title or
 * location specific ontology, jobs with "cloud" keyword matches are returned
 * regardless of this enum's value.
 *
 * Use
 * [Company.keyword_searchable_job_custom_attributes][google.cloud.talent.v4.Company.keyword_searchable_job_custom_attributes]
 * if company-specific globally matched custom field/attribute string values
 * are needed. Enabling keyword match improves recall of subsequent search
 * requests.
 */
export enum SearchJobsRequest_KeywordMatchMode {
  /**
   * KEYWORD_MATCH_MODE_UNSPECIFIED - The keyword match option isn't specified. Defaults to
   * [KeywordMatchMode.KEYWORD_MATCH_ALL][google.cloud.talent.v4.SearchJobsRequest.KeywordMatchMode.KEYWORD_MATCH_ALL]
   * behavior.
   */
  KEYWORD_MATCH_MODE_UNSPECIFIED = 0,
  /** KEYWORD_MATCH_DISABLED - Disables keyword matching. */
  KEYWORD_MATCH_DISABLED = 1,
  /**
   * KEYWORD_MATCH_ALL - Enable keyword matching over
   * [Job.title][google.cloud.talent.v4.Job.title],
   * [Job.description][google.cloud.talent.v4.Job.description],
   * [Job.company_display_name][google.cloud.talent.v4.Job.company_display_name],
   * [Job.addresses][google.cloud.talent.v4.Job.addresses],
   * [Job.qualifications][google.cloud.talent.v4.Job.qualifications], and
   * keyword searchable
   * [Job.custom_attributes][google.cloud.talent.v4.Job.custom_attributes]
   * fields.
   */
  KEYWORD_MATCH_ALL = 2,
  /**
   * KEYWORD_MATCH_TITLE_ONLY - Only enable keyword matching over
   * [Job.title][google.cloud.talent.v4.Job.title].
   */
  KEYWORD_MATCH_TITLE_ONLY = 3,
  UNRECOGNIZED = -1,
}

export function searchJobsRequest_KeywordMatchModeFromJSON(object: any): SearchJobsRequest_KeywordMatchMode {
  switch (object) {
    case 0:
    case "KEYWORD_MATCH_MODE_UNSPECIFIED":
      return SearchJobsRequest_KeywordMatchMode.KEYWORD_MATCH_MODE_UNSPECIFIED;
    case 1:
    case "KEYWORD_MATCH_DISABLED":
      return SearchJobsRequest_KeywordMatchMode.KEYWORD_MATCH_DISABLED;
    case 2:
    case "KEYWORD_MATCH_ALL":
      return SearchJobsRequest_KeywordMatchMode.KEYWORD_MATCH_ALL;
    case 3:
    case "KEYWORD_MATCH_TITLE_ONLY":
      return SearchJobsRequest_KeywordMatchMode.KEYWORD_MATCH_TITLE_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchJobsRequest_KeywordMatchMode.UNRECOGNIZED;
  }
}

export function searchJobsRequest_KeywordMatchModeToJSON(object: SearchJobsRequest_KeywordMatchMode): string {
  switch (object) {
    case SearchJobsRequest_KeywordMatchMode.KEYWORD_MATCH_MODE_UNSPECIFIED:
      return "KEYWORD_MATCH_MODE_UNSPECIFIED";
    case SearchJobsRequest_KeywordMatchMode.KEYWORD_MATCH_DISABLED:
      return "KEYWORD_MATCH_DISABLED";
    case SearchJobsRequest_KeywordMatchMode.KEYWORD_MATCH_ALL:
      return "KEYWORD_MATCH_ALL";
    case SearchJobsRequest_KeywordMatchMode.KEYWORD_MATCH_TITLE_ONLY:
      return "KEYWORD_MATCH_TITLE_ONLY";
    case SearchJobsRequest_KeywordMatchMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Custom ranking information for
 * [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
 */
export interface SearchJobsRequest_CustomRankingInfo {
  /**
   * Required. Controls over how important the score of
   * [CustomRankingInfo.ranking_expression][google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo.ranking_expression]
   * gets applied to job's final ranking position.
   *
   * An error is thrown if not specified.
   */
  importanceLevel: SearchJobsRequest_CustomRankingInfo_ImportanceLevel;
  /**
   * Required. Controls over how job documents get ranked on top of existing
   * relevance score (determined by API algorithm). A combination of the
   * ranking expression and relevance score is used to determine job's final
   * ranking position.
   *
   * The syntax for this expression is a subset of Google SQL syntax.
   *
   * Supported operators are: +, -, *, /, where the left and right side of
   * the operator is either a numeric
   * [Job.custom_attributes][google.cloud.talent.v4.Job.custom_attributes]
   * key, integer/double value or an expression that can be evaluated to a
   * number.
   *
   * Parenthesis are supported to adjust calculation precedence. The
   * expression must be < 200 characters in length.
   *
   * The expression is considered invalid for a job if the expression
   * references custom attributes that are not populated on the job or if the
   * expression results in a divide by zero. If an expression is invalid for a
   * job, that job is demoted to the end of the results.
   *
   * Sample ranking expression
   * (year + 25) * 0.25 - (freshness / 0.5)
   */
  rankingExpression: string;
}

/**
 * The importance level for
 * [CustomRankingInfo.ranking_expression][google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo.ranking_expression].
 */
export enum SearchJobsRequest_CustomRankingInfo_ImportanceLevel {
  /** IMPORTANCE_LEVEL_UNSPECIFIED - Default value if the importance level isn't specified. */
  IMPORTANCE_LEVEL_UNSPECIFIED = 0,
  /**
   * NONE - The given ranking expression is of None importance, existing relevance
   * score (determined by API algorithm) dominates job's final ranking
   * position.
   */
  NONE = 1,
  /**
   * LOW - The given ranking expression is of Low importance in terms of job's
   * final ranking position compared to existing relevance
   * score (determined by API algorithm).
   */
  LOW = 2,
  /**
   * MILD - The given ranking expression is of Mild importance in terms of job's
   * final ranking position compared to existing relevance
   * score (determined by API algorithm).
   */
  MILD = 3,
  /**
   * MEDIUM - The given ranking expression is of Medium importance in terms of job's
   * final ranking position compared to existing relevance
   * score (determined by API algorithm).
   */
  MEDIUM = 4,
  /**
   * HIGH - The given ranking expression is of High importance in terms of job's
   * final ranking position compared to existing relevance
   * score (determined by API algorithm).
   */
  HIGH = 5,
  /**
   * EXTREME - The given ranking expression is of Extreme importance, and dominates
   * job's final ranking position with existing relevance
   * score (determined by API algorithm) ignored.
   */
  EXTREME = 6,
  UNRECOGNIZED = -1,
}

export function searchJobsRequest_CustomRankingInfo_ImportanceLevelFromJSON(
  object: any,
): SearchJobsRequest_CustomRankingInfo_ImportanceLevel {
  switch (object) {
    case 0:
    case "IMPORTANCE_LEVEL_UNSPECIFIED":
      return SearchJobsRequest_CustomRankingInfo_ImportanceLevel.IMPORTANCE_LEVEL_UNSPECIFIED;
    case 1:
    case "NONE":
      return SearchJobsRequest_CustomRankingInfo_ImportanceLevel.NONE;
    case 2:
    case "LOW":
      return SearchJobsRequest_CustomRankingInfo_ImportanceLevel.LOW;
    case 3:
    case "MILD":
      return SearchJobsRequest_CustomRankingInfo_ImportanceLevel.MILD;
    case 4:
    case "MEDIUM":
      return SearchJobsRequest_CustomRankingInfo_ImportanceLevel.MEDIUM;
    case 5:
    case "HIGH":
      return SearchJobsRequest_CustomRankingInfo_ImportanceLevel.HIGH;
    case 6:
    case "EXTREME":
      return SearchJobsRequest_CustomRankingInfo_ImportanceLevel.EXTREME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchJobsRequest_CustomRankingInfo_ImportanceLevel.UNRECOGNIZED;
  }
}

export function searchJobsRequest_CustomRankingInfo_ImportanceLevelToJSON(
  object: SearchJobsRequest_CustomRankingInfo_ImportanceLevel,
): string {
  switch (object) {
    case SearchJobsRequest_CustomRankingInfo_ImportanceLevel.IMPORTANCE_LEVEL_UNSPECIFIED:
      return "IMPORTANCE_LEVEL_UNSPECIFIED";
    case SearchJobsRequest_CustomRankingInfo_ImportanceLevel.NONE:
      return "NONE";
    case SearchJobsRequest_CustomRankingInfo_ImportanceLevel.LOW:
      return "LOW";
    case SearchJobsRequest_CustomRankingInfo_ImportanceLevel.MILD:
      return "MILD";
    case SearchJobsRequest_CustomRankingInfo_ImportanceLevel.MEDIUM:
      return "MEDIUM";
    case SearchJobsRequest_CustomRankingInfo_ImportanceLevel.HIGH:
      return "HIGH";
    case SearchJobsRequest_CustomRankingInfo_ImportanceLevel.EXTREME:
      return "EXTREME";
    case SearchJobsRequest_CustomRankingInfo_ImportanceLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Response for SearchJob method. */
export interface SearchJobsResponse {
  /**
   * The Job entities that match the specified
   * [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
   */
  matchingJobs: SearchJobsResponse_MatchingJob[];
  /**
   * The histogram results that match with specified
   * [SearchJobsRequest.histogram_queries][google.cloud.talent.v4.SearchJobsRequest.histogram_queries].
   */
  histogramQueryResults: HistogramQueryResult[];
  /**
   * The token that specifies the starting position of the next page of results.
   * This field is empty if there are no more results.
   */
  nextPageToken: string;
  /**
   * The location filters that the service applied to the specified query. If
   * any filters are lat-lng based, the
   * [Location.location_type][google.cloud.talent.v4.Location.location_type] is
   * [Location.LocationType.LOCATION_TYPE_UNSPECIFIED][google.cloud.talent.v4.Location.LocationType.LOCATION_TYPE_UNSPECIFIED].
   */
  locationFilters: Location[];
  /**
   * Number of jobs that match the specified query.
   *
   * Note: This size is precise only if the total is less than 100,000.
   */
  totalSize: number;
  /**
   * Additional information for the API invocation, such as the request
   * tracking id.
   */
  metadata:
    | ResponseMetadata
    | undefined;
  /**
   * If query broadening is enabled, we may append additional results from the
   * broadened query. This number indicates how many of the jobs returned in the
   * jobs field are from the broadened query. These results are always at the
   * end of the jobs list. In particular, a value of 0, or if the field isn't
   * set, all the jobs in the jobs list are from the original
   * (without broadening) query. If this field is non-zero, subsequent requests
   * with offset after this result set should contain all broadened results.
   */
  broadenedQueryJobsCount: number;
  /** The spell checking result, and correction. */
  spellCorrection: SpellingCorrection | undefined;
}

/**
 * Job entry with metadata inside
 * [SearchJobsResponse][google.cloud.talent.v4.SearchJobsResponse].
 */
export interface SearchJobsResponse_MatchingJob {
  /**
   * Job resource that matches the specified
   * [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
   */
  job:
    | Job
    | undefined;
  /**
   * A summary of the job with core information that's displayed on the search
   * results listing page.
   */
  jobSummary: string;
  /**
   * Contains snippets of text from the
   * [Job.title][google.cloud.talent.v4.Job.title] field most closely matching
   * a search query's keywords, if available. The matching query keywords are
   * enclosed in HTML bold tags.
   */
  jobTitleSnippet: string;
  /**
   * Contains snippets of text from the
   * [Job.description][google.cloud.talent.v4.Job.description] and similar
   * fields that most closely match a search query's keywords, if available.
   * All HTML tags in the original fields are stripped when returned in this
   * field, and matching query keywords are enclosed in HTML bold tags.
   */
  searchTextSnippet: string;
  /**
   * Commute information which is generated based on specified
   *  [CommuteFilter][google.cloud.talent.v4.CommuteFilter].
   */
  commuteInfo: SearchJobsResponse_CommuteInfo | undefined;
}

/** Commute details related to this job. */
export interface SearchJobsResponse_CommuteInfo {
  /** Location used as the destination in the commute calculation. */
  jobLocation:
    | Location
    | undefined;
  /**
   * The number of seconds required to travel to the job location from the
   * query location. A duration of 0 seconds indicates that the job isn't
   * reachable within the requested duration, but was returned as part of an
   * expanded query.
   */
  travelDuration: Duration | undefined;
}

/** Request to create a batch of jobs. */
export interface BatchCreateJobsRequest {
  /**
   * Required. The resource name of the tenant under which the job is created.
   *
   * The format is "projects/{project_id}/tenants/{tenant_id}". For example,
   * "projects/foo/tenants/bar".
   */
  parent: string;
  /**
   * Required. The jobs to be created.
   * A maximum of 200 jobs can be created in a batch.
   */
  jobs: Job[];
}

/** Request to update a batch of jobs. */
export interface BatchUpdateJobsRequest {
  /**
   * Required. The resource name of the tenant under which the job is created.
   *
   * The format is "projects/{project_id}/tenants/{tenant_id}". For example,
   * "projects/foo/tenants/bar".
   */
  parent: string;
  /**
   * Required. The jobs to be updated.
   * A maximum of 200 jobs can be updated in a batch.
   */
  jobs: Job[];
  /**
   * Strongly recommended for the best service experience. Be aware that it will
   * also increase latency when checking the status of a batch operation.
   *
   * If [update_mask][google.cloud.talent.v4.BatchUpdateJobsRequest.update_mask]
   * is provided, only the specified fields in [Job][google.cloud.talent.v4.Job]
   * are updated. Otherwise all the fields are updated.
   *
   * A field mask to restrict the fields that are updated. Only
   * top level fields of [Job][google.cloud.talent.v4.Job] are supported.
   *
   * If [update_mask][google.cloud.talent.v4.BatchUpdateJobsRequest.update_mask]
   * is provided, The [Job][google.cloud.talent.v4.Job] inside
   * [JobResult][JobOperationResult.JobResult]
   * will only contains fields that is updated, plus the Id of the Job.
   * Otherwise,  [Job][google.cloud.talent.v4.Job] will include all fields,
   * which can yield a very large response.
   */
  updateMask: string[] | undefined;
}

/** Request to delete a batch of jobs. */
export interface BatchDeleteJobsRequest {
  /**
   * Required. The resource name of the tenant under which the job is created.
   *
   * The format is "projects/{project_id}/tenants/{tenant_id}". For example,
   * "projects/foo/tenants/bar".
   *
   * The parent of all of the jobs specified in `names` must match this field.
   */
  parent: string;
  /**
   * The names of the jobs to delete.
   *
   * The format is "projects/{project_id}/tenants/{tenant_id}/jobs/{job_id}".
   * For example, "projects/foo/tenants/bar/jobs/baz".
   *
   * A maximum of 200 jobs can be deleted in a batch.
   */
  names: string[];
}

/** Mutation result of a job from a batch operation. */
export interface JobResult {
  /**
   * Here [Job][google.cloud.talent.v4.Job] only contains basic information
   * including [name][google.cloud.talent.v4.Job.name],
   * [company][google.cloud.talent.v4.Job.company],
   * [language_code][google.cloud.talent.v4.Job.language_code] and
   * [requisition_id][google.cloud.talent.v4.Job.requisition_id], use getJob
   * method to retrieve detailed information of the created/updated job.
   */
  job:
    | Job
    | undefined;
  /**
   * The status of the job processed. This field is populated if the
   * processing of the [job][google.cloud.talent.v4.JobResult.job] fails.
   */
  status: Status | undefined;
}

/**
 * The result of
 * [JobService.BatchCreateJobs][google.cloud.talent.v4.JobService.BatchCreateJobs].
 * It's used to replace
 * [google.longrunning.Operation.response][google.longrunning.Operation.response]
 * in case of success.
 */
export interface BatchCreateJobsResponse {
  /**
   * List of job mutation results from a batch create operation. It can change
   * until operation status is FINISHED, FAILED or CANCELLED.
   */
  jobResults: JobResult[];
}

/**
 * The result of
 * [JobService.BatchUpdateJobs][google.cloud.talent.v4.JobService.BatchUpdateJobs].
 * It's used to replace
 * [google.longrunning.Operation.response][google.longrunning.Operation.response]
 * in case of success.
 */
export interface BatchUpdateJobsResponse {
  /**
   * List of job mutation results from a batch update operation. It can change
   * until operation status is FINISHED, FAILED or CANCELLED.
   */
  jobResults: JobResult[];
}

/**
 * The result of
 * [JobService.BatchDeleteJobs][google.cloud.talent.v4.JobService.BatchDeleteJobs].
 * It's used to replace
 * [google.longrunning.Operation.response][google.longrunning.Operation.response]
 * in case of success.
 */
export interface BatchDeleteJobsResponse {
  /**
   * List of job mutation results from a batch delete operation. It can change
   * until operation status is FINISHED, FAILED or CANCELLED.
   */
  jobResults: JobResult[];
}

function createBaseCreateJobRequest(): CreateJobRequest {
  return { parent: "", job: undefined };
}

export const CreateJobRequest: MessageFns<CreateJobRequest> = {
  encode(message: CreateJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.job !== undefined) {
      Job.encode(message.job, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.job = Job.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateJobRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      job: isSet(object.job) ? Job.fromJSON(object.job) : undefined,
    };
  },

  toJSON(message: CreateJobRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.job !== undefined) {
      obj.job = Job.toJSON(message.job);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateJobRequest>): CreateJobRequest {
    return CreateJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateJobRequest>): CreateJobRequest {
    const message = createBaseCreateJobRequest();
    message.parent = object.parent ?? "";
    message.job = (object.job !== undefined && object.job !== null) ? Job.fromPartial(object.job) : undefined;
    return message;
  },
};

function createBaseGetJobRequest(): GetJobRequest {
  return { name: "" };
}

export const GetJobRequest: MessageFns<GetJobRequest> = {
  encode(message: GetJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetJobRequest>): GetJobRequest {
    return GetJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetJobRequest>): GetJobRequest {
    const message = createBaseGetJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateJobRequest(): UpdateJobRequest {
  return { job: undefined, updateMask: undefined };
}

export const UpdateJobRequest: MessageFns<UpdateJobRequest> = {
  encode(message: UpdateJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.job !== undefined) {
      Job.encode(message.job, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.job = Job.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateJobRequest {
    return {
      job: isSet(object.job) ? Job.fromJSON(object.job) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateJobRequest): unknown {
    const obj: any = {};
    if (message.job !== undefined) {
      obj.job = Job.toJSON(message.job);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateJobRequest>): UpdateJobRequest {
    return UpdateJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateJobRequest>): UpdateJobRequest {
    const message = createBaseUpdateJobRequest();
    message.job = (object.job !== undefined && object.job !== null) ? Job.fromPartial(object.job) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteJobRequest(): DeleteJobRequest {
  return { name: "" };
}

export const DeleteJobRequest: MessageFns<DeleteJobRequest> = {
  encode(message: DeleteJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteJobRequest>): DeleteJobRequest {
    return DeleteJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteJobRequest>): DeleteJobRequest {
    const message = createBaseDeleteJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListJobsRequest(): ListJobsRequest {
  return { parent: "", filter: "", pageToken: "", pageSize: 0, jobView: 0 };
}

export const ListJobsRequest: MessageFns<ListJobsRequest> = {
  encode(message: ListJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.jobView !== 0) {
      writer.uint32(40).int32(message.jobView);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.jobView = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListJobsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      jobView: isSet(object.jobView) ? jobViewFromJSON(object.jobView) : 0,
    };
  },

  toJSON(message: ListJobsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.jobView !== 0) {
      obj.jobView = jobViewToJSON(message.jobView);
    }
    return obj;
  },

  create(base?: DeepPartial<ListJobsRequest>): ListJobsRequest {
    return ListJobsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListJobsRequest>): ListJobsRequest {
    const message = createBaseListJobsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.jobView = object.jobView ?? 0;
    return message;
  },
};

function createBaseListJobsResponse(): ListJobsResponse {
  return { jobs: [], nextPageToken: "", metadata: undefined };
}

export const ListJobsResponse: MessageFns<ListJobsResponse> = {
  encode(message: ListJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      Job.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jobs.push(Job.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListJobsResponse {
    return {
      jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => Job.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ListJobsResponse): unknown {
    const obj: any = {};
    if (message.jobs?.length) {
      obj.jobs = message.jobs.map((e) => Job.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<ListJobsResponse>): ListJobsResponse {
    return ListJobsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListJobsResponse>): ListJobsResponse {
    const message = createBaseListJobsResponse();
    message.jobs = object.jobs?.map((e) => Job.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseSearchJobsRequest(): SearchJobsRequest {
  return {
    parent: "",
    searchMode: 0,
    requestMetadata: undefined,
    jobQuery: undefined,
    enableBroadening: false,
    histogramQueries: [],
    jobView: 0,
    offset: 0,
    maxPageSize: 0,
    pageToken: "",
    orderBy: "",
    diversificationLevel: 0,
    customRankingInfo: undefined,
    disableKeywordMatch: false,
    keywordMatchMode: 0,
  };
}

export const SearchJobsRequest: MessageFns<SearchJobsRequest> = {
  encode(message: SearchJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.searchMode !== 0) {
      writer.uint32(16).int32(message.searchMode);
    }
    if (message.requestMetadata !== undefined) {
      RequestMetadata.encode(message.requestMetadata, writer.uint32(26).fork()).join();
    }
    if (message.jobQuery !== undefined) {
      JobQuery.encode(message.jobQuery, writer.uint32(34).fork()).join();
    }
    if (message.enableBroadening !== false) {
      writer.uint32(40).bool(message.enableBroadening);
    }
    for (const v of message.histogramQueries) {
      HistogramQuery.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.jobView !== 0) {
      writer.uint32(64).int32(message.jobView);
    }
    if (message.offset !== 0) {
      writer.uint32(72).int32(message.offset);
    }
    if (message.maxPageSize !== 0) {
      writer.uint32(80).int32(message.maxPageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(90).string(message.pageToken);
    }
    if (message.orderBy !== "") {
      writer.uint32(98).string(message.orderBy);
    }
    if (message.diversificationLevel !== 0) {
      writer.uint32(104).int32(message.diversificationLevel);
    }
    if (message.customRankingInfo !== undefined) {
      SearchJobsRequest_CustomRankingInfo.encode(message.customRankingInfo, writer.uint32(114).fork()).join();
    }
    if (message.disableKeywordMatch !== false) {
      writer.uint32(128).bool(message.disableKeywordMatch);
    }
    if (message.keywordMatchMode !== 0) {
      writer.uint32(144).int32(message.keywordMatchMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.searchMode = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestMetadata = RequestMetadata.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.jobQuery = JobQuery.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.enableBroadening = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.histogramQueries.push(HistogramQuery.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.jobView = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.offset = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.maxPageSize = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.diversificationLevel = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.customRankingInfo = SearchJobsRequest_CustomRankingInfo.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.disableKeywordMatch = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.keywordMatchMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchJobsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      searchMode: isSet(object.searchMode) ? searchJobsRequest_SearchModeFromJSON(object.searchMode) : 0,
      requestMetadata: isSet(object.requestMetadata) ? RequestMetadata.fromJSON(object.requestMetadata) : undefined,
      jobQuery: isSet(object.jobQuery) ? JobQuery.fromJSON(object.jobQuery) : undefined,
      enableBroadening: isSet(object.enableBroadening) ? globalThis.Boolean(object.enableBroadening) : false,
      histogramQueries: globalThis.Array.isArray(object?.histogramQueries)
        ? object.histogramQueries.map((e: any) => HistogramQuery.fromJSON(e))
        : [],
      jobView: isSet(object.jobView) ? jobViewFromJSON(object.jobView) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      maxPageSize: isSet(object.maxPageSize) ? globalThis.Number(object.maxPageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      diversificationLevel: isSet(object.diversificationLevel)
        ? searchJobsRequest_DiversificationLevelFromJSON(object.diversificationLevel)
        : 0,
      customRankingInfo: isSet(object.customRankingInfo)
        ? SearchJobsRequest_CustomRankingInfo.fromJSON(object.customRankingInfo)
        : undefined,
      disableKeywordMatch: isSet(object.disableKeywordMatch) ? globalThis.Boolean(object.disableKeywordMatch) : false,
      keywordMatchMode: isSet(object.keywordMatchMode)
        ? searchJobsRequest_KeywordMatchModeFromJSON(object.keywordMatchMode)
        : 0,
    };
  },

  toJSON(message: SearchJobsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.searchMode !== 0) {
      obj.searchMode = searchJobsRequest_SearchModeToJSON(message.searchMode);
    }
    if (message.requestMetadata !== undefined) {
      obj.requestMetadata = RequestMetadata.toJSON(message.requestMetadata);
    }
    if (message.jobQuery !== undefined) {
      obj.jobQuery = JobQuery.toJSON(message.jobQuery);
    }
    if (message.enableBroadening !== false) {
      obj.enableBroadening = message.enableBroadening;
    }
    if (message.histogramQueries?.length) {
      obj.histogramQueries = message.histogramQueries.map((e) => HistogramQuery.toJSON(e));
    }
    if (message.jobView !== 0) {
      obj.jobView = jobViewToJSON(message.jobView);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.maxPageSize !== 0) {
      obj.maxPageSize = Math.round(message.maxPageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.diversificationLevel !== 0) {
      obj.diversificationLevel = searchJobsRequest_DiversificationLevelToJSON(message.diversificationLevel);
    }
    if (message.customRankingInfo !== undefined) {
      obj.customRankingInfo = SearchJobsRequest_CustomRankingInfo.toJSON(message.customRankingInfo);
    }
    if (message.disableKeywordMatch !== false) {
      obj.disableKeywordMatch = message.disableKeywordMatch;
    }
    if (message.keywordMatchMode !== 0) {
      obj.keywordMatchMode = searchJobsRequest_KeywordMatchModeToJSON(message.keywordMatchMode);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchJobsRequest>): SearchJobsRequest {
    return SearchJobsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchJobsRequest>): SearchJobsRequest {
    const message = createBaseSearchJobsRequest();
    message.parent = object.parent ?? "";
    message.searchMode = object.searchMode ?? 0;
    message.requestMetadata = (object.requestMetadata !== undefined && object.requestMetadata !== null)
      ? RequestMetadata.fromPartial(object.requestMetadata)
      : undefined;
    message.jobQuery = (object.jobQuery !== undefined && object.jobQuery !== null)
      ? JobQuery.fromPartial(object.jobQuery)
      : undefined;
    message.enableBroadening = object.enableBroadening ?? false;
    message.histogramQueries = object.histogramQueries?.map((e) => HistogramQuery.fromPartial(e)) || [];
    message.jobView = object.jobView ?? 0;
    message.offset = object.offset ?? 0;
    message.maxPageSize = object.maxPageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.orderBy = object.orderBy ?? "";
    message.diversificationLevel = object.diversificationLevel ?? 0;
    message.customRankingInfo = (object.customRankingInfo !== undefined && object.customRankingInfo !== null)
      ? SearchJobsRequest_CustomRankingInfo.fromPartial(object.customRankingInfo)
      : undefined;
    message.disableKeywordMatch = object.disableKeywordMatch ?? false;
    message.keywordMatchMode = object.keywordMatchMode ?? 0;
    return message;
  },
};

function createBaseSearchJobsRequest_CustomRankingInfo(): SearchJobsRequest_CustomRankingInfo {
  return { importanceLevel: 0, rankingExpression: "" };
}

export const SearchJobsRequest_CustomRankingInfo: MessageFns<SearchJobsRequest_CustomRankingInfo> = {
  encode(message: SearchJobsRequest_CustomRankingInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.importanceLevel !== 0) {
      writer.uint32(8).int32(message.importanceLevel);
    }
    if (message.rankingExpression !== "") {
      writer.uint32(18).string(message.rankingExpression);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchJobsRequest_CustomRankingInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchJobsRequest_CustomRankingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.importanceLevel = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rankingExpression = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchJobsRequest_CustomRankingInfo {
    return {
      importanceLevel: isSet(object.importanceLevel)
        ? searchJobsRequest_CustomRankingInfo_ImportanceLevelFromJSON(object.importanceLevel)
        : 0,
      rankingExpression: isSet(object.rankingExpression) ? globalThis.String(object.rankingExpression) : "",
    };
  },

  toJSON(message: SearchJobsRequest_CustomRankingInfo): unknown {
    const obj: any = {};
    if (message.importanceLevel !== 0) {
      obj.importanceLevel = searchJobsRequest_CustomRankingInfo_ImportanceLevelToJSON(message.importanceLevel);
    }
    if (message.rankingExpression !== "") {
      obj.rankingExpression = message.rankingExpression;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchJobsRequest_CustomRankingInfo>): SearchJobsRequest_CustomRankingInfo {
    return SearchJobsRequest_CustomRankingInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchJobsRequest_CustomRankingInfo>): SearchJobsRequest_CustomRankingInfo {
    const message = createBaseSearchJobsRequest_CustomRankingInfo();
    message.importanceLevel = object.importanceLevel ?? 0;
    message.rankingExpression = object.rankingExpression ?? "";
    return message;
  },
};

function createBaseSearchJobsResponse(): SearchJobsResponse {
  return {
    matchingJobs: [],
    histogramQueryResults: [],
    nextPageToken: "",
    locationFilters: [],
    totalSize: 0,
    metadata: undefined,
    broadenedQueryJobsCount: 0,
    spellCorrection: undefined,
  };
}

export const SearchJobsResponse: MessageFns<SearchJobsResponse> = {
  encode(message: SearchJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matchingJobs) {
      SearchJobsResponse_MatchingJob.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.histogramQueryResults) {
      HistogramQueryResult.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    for (const v of message.locationFilters) {
      Location.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.totalSize !== 0) {
      writer.uint32(48).int32(message.totalSize);
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(58).fork()).join();
    }
    if (message.broadenedQueryJobsCount !== 0) {
      writer.uint32(64).int32(message.broadenedQueryJobsCount);
    }
    if (message.spellCorrection !== undefined) {
      SpellingCorrection.encode(message.spellCorrection, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.matchingJobs.push(SearchJobsResponse_MatchingJob.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.histogramQueryResults.push(HistogramQueryResult.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.locationFilters.push(Location.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.broadenedQueryJobsCount = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.spellCorrection = SpellingCorrection.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchJobsResponse {
    return {
      matchingJobs: globalThis.Array.isArray(object?.matchingJobs)
        ? object.matchingJobs.map((e: any) => SearchJobsResponse_MatchingJob.fromJSON(e))
        : [],
      histogramQueryResults: globalThis.Array.isArray(object?.histogramQueryResults)
        ? object.histogramQueryResults.map((e: any) => HistogramQueryResult.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      locationFilters: globalThis.Array.isArray(object?.locationFilters)
        ? object.locationFilters.map((e: any) => Location.fromJSON(e))
        : [],
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
      broadenedQueryJobsCount: isSet(object.broadenedQueryJobsCount)
        ? globalThis.Number(object.broadenedQueryJobsCount)
        : 0,
      spellCorrection: isSet(object.spellCorrection) ? SpellingCorrection.fromJSON(object.spellCorrection) : undefined,
    };
  },

  toJSON(message: SearchJobsResponse): unknown {
    const obj: any = {};
    if (message.matchingJobs?.length) {
      obj.matchingJobs = message.matchingJobs.map((e) => SearchJobsResponse_MatchingJob.toJSON(e));
    }
    if (message.histogramQueryResults?.length) {
      obj.histogramQueryResults = message.histogramQueryResults.map((e) => HistogramQueryResult.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.locationFilters?.length) {
      obj.locationFilters = message.locationFilters.map((e) => Location.toJSON(e));
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    if (message.broadenedQueryJobsCount !== 0) {
      obj.broadenedQueryJobsCount = Math.round(message.broadenedQueryJobsCount);
    }
    if (message.spellCorrection !== undefined) {
      obj.spellCorrection = SpellingCorrection.toJSON(message.spellCorrection);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchJobsResponse>): SearchJobsResponse {
    return SearchJobsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchJobsResponse>): SearchJobsResponse {
    const message = createBaseSearchJobsResponse();
    message.matchingJobs = object.matchingJobs?.map((e) => SearchJobsResponse_MatchingJob.fromPartial(e)) || [];
    message.histogramQueryResults = object.histogramQueryResults?.map((e) => HistogramQueryResult.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.locationFilters = object.locationFilters?.map((e) => Location.fromPartial(e)) || [];
    message.totalSize = object.totalSize ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    message.broadenedQueryJobsCount = object.broadenedQueryJobsCount ?? 0;
    message.spellCorrection = (object.spellCorrection !== undefined && object.spellCorrection !== null)
      ? SpellingCorrection.fromPartial(object.spellCorrection)
      : undefined;
    return message;
  },
};

function createBaseSearchJobsResponse_MatchingJob(): SearchJobsResponse_MatchingJob {
  return { job: undefined, jobSummary: "", jobTitleSnippet: "", searchTextSnippet: "", commuteInfo: undefined };
}

export const SearchJobsResponse_MatchingJob: MessageFns<SearchJobsResponse_MatchingJob> = {
  encode(message: SearchJobsResponse_MatchingJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.job !== undefined) {
      Job.encode(message.job, writer.uint32(10).fork()).join();
    }
    if (message.jobSummary !== "") {
      writer.uint32(18).string(message.jobSummary);
    }
    if (message.jobTitleSnippet !== "") {
      writer.uint32(26).string(message.jobTitleSnippet);
    }
    if (message.searchTextSnippet !== "") {
      writer.uint32(34).string(message.searchTextSnippet);
    }
    if (message.commuteInfo !== undefined) {
      SearchJobsResponse_CommuteInfo.encode(message.commuteInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchJobsResponse_MatchingJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchJobsResponse_MatchingJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.job = Job.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.jobSummary = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.jobTitleSnippet = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.searchTextSnippet = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.commuteInfo = SearchJobsResponse_CommuteInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchJobsResponse_MatchingJob {
    return {
      job: isSet(object.job) ? Job.fromJSON(object.job) : undefined,
      jobSummary: isSet(object.jobSummary) ? globalThis.String(object.jobSummary) : "",
      jobTitleSnippet: isSet(object.jobTitleSnippet) ? globalThis.String(object.jobTitleSnippet) : "",
      searchTextSnippet: isSet(object.searchTextSnippet) ? globalThis.String(object.searchTextSnippet) : "",
      commuteInfo: isSet(object.commuteInfo) ? SearchJobsResponse_CommuteInfo.fromJSON(object.commuteInfo) : undefined,
    };
  },

  toJSON(message: SearchJobsResponse_MatchingJob): unknown {
    const obj: any = {};
    if (message.job !== undefined) {
      obj.job = Job.toJSON(message.job);
    }
    if (message.jobSummary !== "") {
      obj.jobSummary = message.jobSummary;
    }
    if (message.jobTitleSnippet !== "") {
      obj.jobTitleSnippet = message.jobTitleSnippet;
    }
    if (message.searchTextSnippet !== "") {
      obj.searchTextSnippet = message.searchTextSnippet;
    }
    if (message.commuteInfo !== undefined) {
      obj.commuteInfo = SearchJobsResponse_CommuteInfo.toJSON(message.commuteInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchJobsResponse_MatchingJob>): SearchJobsResponse_MatchingJob {
    return SearchJobsResponse_MatchingJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchJobsResponse_MatchingJob>): SearchJobsResponse_MatchingJob {
    const message = createBaseSearchJobsResponse_MatchingJob();
    message.job = (object.job !== undefined && object.job !== null) ? Job.fromPartial(object.job) : undefined;
    message.jobSummary = object.jobSummary ?? "";
    message.jobTitleSnippet = object.jobTitleSnippet ?? "";
    message.searchTextSnippet = object.searchTextSnippet ?? "";
    message.commuteInfo = (object.commuteInfo !== undefined && object.commuteInfo !== null)
      ? SearchJobsResponse_CommuteInfo.fromPartial(object.commuteInfo)
      : undefined;
    return message;
  },
};

function createBaseSearchJobsResponse_CommuteInfo(): SearchJobsResponse_CommuteInfo {
  return { jobLocation: undefined, travelDuration: undefined };
}

export const SearchJobsResponse_CommuteInfo: MessageFns<SearchJobsResponse_CommuteInfo> = {
  encode(message: SearchJobsResponse_CommuteInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobLocation !== undefined) {
      Location.encode(message.jobLocation, writer.uint32(10).fork()).join();
    }
    if (message.travelDuration !== undefined) {
      Duration.encode(message.travelDuration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchJobsResponse_CommuteInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchJobsResponse_CommuteInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jobLocation = Location.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.travelDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchJobsResponse_CommuteInfo {
    return {
      jobLocation: isSet(object.jobLocation) ? Location.fromJSON(object.jobLocation) : undefined,
      travelDuration: isSet(object.travelDuration) ? Duration.fromJSON(object.travelDuration) : undefined,
    };
  },

  toJSON(message: SearchJobsResponse_CommuteInfo): unknown {
    const obj: any = {};
    if (message.jobLocation !== undefined) {
      obj.jobLocation = Location.toJSON(message.jobLocation);
    }
    if (message.travelDuration !== undefined) {
      obj.travelDuration = Duration.toJSON(message.travelDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchJobsResponse_CommuteInfo>): SearchJobsResponse_CommuteInfo {
    return SearchJobsResponse_CommuteInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchJobsResponse_CommuteInfo>): SearchJobsResponse_CommuteInfo {
    const message = createBaseSearchJobsResponse_CommuteInfo();
    message.jobLocation = (object.jobLocation !== undefined && object.jobLocation !== null)
      ? Location.fromPartial(object.jobLocation)
      : undefined;
    message.travelDuration = (object.travelDuration !== undefined && object.travelDuration !== null)
      ? Duration.fromPartial(object.travelDuration)
      : undefined;
    return message;
  },
};

function createBaseBatchCreateJobsRequest(): BatchCreateJobsRequest {
  return { parent: "", jobs: [] };
}

export const BatchCreateJobsRequest: MessageFns<BatchCreateJobsRequest> = {
  encode(message: BatchCreateJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.jobs) {
      Job.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.jobs.push(Job.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateJobsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => Job.fromJSON(e)) : [],
    };
  },

  toJSON(message: BatchCreateJobsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.jobs?.length) {
      obj.jobs = message.jobs.map((e) => Job.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateJobsRequest>): BatchCreateJobsRequest {
    return BatchCreateJobsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateJobsRequest>): BatchCreateJobsRequest {
    const message = createBaseBatchCreateJobsRequest();
    message.parent = object.parent ?? "";
    message.jobs = object.jobs?.map((e) => Job.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchUpdateJobsRequest(): BatchUpdateJobsRequest {
  return { parent: "", jobs: [], updateMask: undefined };
}

export const BatchUpdateJobsRequest: MessageFns<BatchUpdateJobsRequest> = {
  encode(message: BatchUpdateJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.jobs) {
      Job.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.jobs.push(Job.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateJobsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => Job.fromJSON(e)) : [],
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: BatchUpdateJobsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.jobs?.length) {
      obj.jobs = message.jobs.map((e) => Job.toJSON(e));
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateJobsRequest>): BatchUpdateJobsRequest {
    return BatchUpdateJobsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateJobsRequest>): BatchUpdateJobsRequest {
    const message = createBaseBatchUpdateJobsRequest();
    message.parent = object.parent ?? "";
    message.jobs = object.jobs?.map((e) => Job.fromPartial(e)) || [];
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseBatchDeleteJobsRequest(): BatchDeleteJobsRequest {
  return { parent: "", names: [] };
}

export const BatchDeleteJobsRequest: MessageFns<BatchDeleteJobsRequest> = {
  encode(message: BatchDeleteJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.names) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDeleteJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeleteJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.names.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeleteJobsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BatchDeleteJobsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.names?.length) {
      obj.names = message.names;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeleteJobsRequest>): BatchDeleteJobsRequest {
    return BatchDeleteJobsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeleteJobsRequest>): BatchDeleteJobsRequest {
    const message = createBaseBatchDeleteJobsRequest();
    message.parent = object.parent ?? "";
    message.names = object.names?.map((e) => e) || [];
    return message;
  },
};

function createBaseJobResult(): JobResult {
  return { job: undefined, status: undefined };
}

export const JobResult: MessageFns<JobResult> = {
  encode(message: JobResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.job !== undefined) {
      Job.encode(message.job, writer.uint32(10).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.job = Job.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobResult {
    return {
      job: isSet(object.job) ? Job.fromJSON(object.job) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: JobResult): unknown {
    const obj: any = {};
    if (message.job !== undefined) {
      obj.job = Job.toJSON(message.job);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<JobResult>): JobResult {
    return JobResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobResult>): JobResult {
    const message = createBaseJobResult();
    message.job = (object.job !== undefined && object.job !== null) ? Job.fromPartial(object.job) : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseBatchCreateJobsResponse(): BatchCreateJobsResponse {
  return { jobResults: [] };
}

export const BatchCreateJobsResponse: MessageFns<BatchCreateJobsResponse> = {
  encode(message: BatchCreateJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobResults) {
      JobResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jobResults.push(JobResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateJobsResponse {
    return {
      jobResults: globalThis.Array.isArray(object?.jobResults)
        ? object.jobResults.map((e: any) => JobResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateJobsResponse): unknown {
    const obj: any = {};
    if (message.jobResults?.length) {
      obj.jobResults = message.jobResults.map((e) => JobResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateJobsResponse>): BatchCreateJobsResponse {
    return BatchCreateJobsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateJobsResponse>): BatchCreateJobsResponse {
    const message = createBaseBatchCreateJobsResponse();
    message.jobResults = object.jobResults?.map((e) => JobResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchUpdateJobsResponse(): BatchUpdateJobsResponse {
  return { jobResults: [] };
}

export const BatchUpdateJobsResponse: MessageFns<BatchUpdateJobsResponse> = {
  encode(message: BatchUpdateJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobResults) {
      JobResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jobResults.push(JobResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateJobsResponse {
    return {
      jobResults: globalThis.Array.isArray(object?.jobResults)
        ? object.jobResults.map((e: any) => JobResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdateJobsResponse): unknown {
    const obj: any = {};
    if (message.jobResults?.length) {
      obj.jobResults = message.jobResults.map((e) => JobResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateJobsResponse>): BatchUpdateJobsResponse {
    return BatchUpdateJobsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateJobsResponse>): BatchUpdateJobsResponse {
    const message = createBaseBatchUpdateJobsResponse();
    message.jobResults = object.jobResults?.map((e) => JobResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchDeleteJobsResponse(): BatchDeleteJobsResponse {
  return { jobResults: [] };
}

export const BatchDeleteJobsResponse: MessageFns<BatchDeleteJobsResponse> = {
  encode(message: BatchDeleteJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobResults) {
      JobResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDeleteJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeleteJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jobResults.push(JobResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeleteJobsResponse {
    return {
      jobResults: globalThis.Array.isArray(object?.jobResults)
        ? object.jobResults.map((e: any) => JobResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchDeleteJobsResponse): unknown {
    const obj: any = {};
    if (message.jobResults?.length) {
      obj.jobResults = message.jobResults.map((e) => JobResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeleteJobsResponse>): BatchDeleteJobsResponse {
    return BatchDeleteJobsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeleteJobsResponse>): BatchDeleteJobsResponse {
    const message = createBaseBatchDeleteJobsResponse();
    message.jobResults = object.jobResults?.map((e) => JobResult.fromPartial(e)) || [];
    return message;
  },
};

/** A service handles job management, including job CRUD, enumeration and search. */
export type JobServiceDefinition = typeof JobServiceDefinition;
export const JobServiceDefinition = {
  name: "JobService",
  fullName: "google.cloud.talent.v4.JobService",
  methods: {
    /**
     * Creates a new job.
     *
     * Typically, the job becomes searchable within 10 seconds, but it may take
     * up to 5 minutes.
     */
    createJob: {
      name: "CreateJob",
      requestType: CreateJobRequest,
      requestStream: false,
      responseType: Job,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([10, 112, 97, 114, 101, 110, 116, 44, 106, 111, 98])],
          578365826: [
            Buffer.from([
              45,
              58,
              3,
              106,
              111,
              98,
              34,
              38,
              47,
              118,
              52,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              110,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              106,
              111,
              98,
              115,
            ]),
          ],
        },
      },
    },
    /** Begins executing a batch create jobs operation. */
    batchCreateJobs: {
      name: "BatchCreateJobs",
      requestType: BatchCreateJobsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              49,
              10,
              23,
              66,
              97,
              116,
              99,
              104,
              67,
              114,
              101,
              97,
              116,
              101,
              74,
              111,
              98,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              22,
              66,
              97,
              116,
              99,
              104,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([11, 112, 97, 114, 101, 110, 116, 44, 106, 111, 98, 115])],
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              52,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              110,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              106,
              111,
              98,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              67,
              114,
              101,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves the specified job, whose status is OPEN or recently EXPIRED
     * within the last 90 days.
     */
    getJob: {
      name: "GetJob",
      requestType: GetJobRequest,
      requestStream: false,
      responseType: Job,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              40,
              18,
              38,
              47,
              118,
              52,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              110,
              97,
              110,
              116,
              115,
              47,
              42,
              47,
              106,
              111,
              98,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates specified job.
     *
     * Typically, updated contents become visible in search results within 10
     * seconds, but it may take up to 5 minutes.
     */
    updateJob: {
      name: "UpdateJob",
      requestType: UpdateJobRequest,
      requestStream: false,
      responseType: Job,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 106, 111, 98, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              49,
              58,
              3,
              106,
              111,
              98,
              50,
              42,
              47,
              118,
              52,
              47,
              123,
              106,
              111,
              98,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              110,
              97,
              110,
              116,
              115,
              47,
              42,
              47,
              106,
              111,
              98,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Begins executing a batch update jobs operation. */
    batchUpdateJobs: {
      name: "BatchUpdateJobs",
      requestType: BatchUpdateJobsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              49,
              10,
              23,
              66,
              97,
              116,
              99,
              104,
              85,
              112,
              100,
              97,
              116,
              101,
              74,
              111,
              98,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              22,
              66,
              97,
              116,
              99,
              104,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([11, 112, 97, 114, 101, 110, 116, 44, 106, 111, 98, 115])],
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              52,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              110,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              106,
              111,
              98,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              85,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the specified job.
     *
     * Typically, the job becomes unsearchable within 10 seconds, but it may take
     * up to 5 minutes.
     */
    deleteJob: {
      name: "DeleteJob",
      requestType: DeleteJobRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              40,
              42,
              38,
              47,
              118,
              52,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              110,
              97,
              110,
              116,
              115,
              47,
              42,
              47,
              106,
              111,
              98,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Begins executing a batch delete jobs operation. */
    batchDeleteJobs: {
      name: "BatchDeleteJobs",
      requestType: BatchDeleteJobsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              49,
              10,
              23,
              66,
              97,
              116,
              99,
              104,
              68,
              101,
              108,
              101,
              116,
              101,
              74,
              111,
              98,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              22,
              66,
              97,
              116,
              99,
              104,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([12, 112, 97, 114, 101, 110, 116, 44, 110, 97, 109, 101, 115])],
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              52,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              110,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              106,
              111,
              98,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              68,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Lists jobs by filter. */
    listJobs: {
      name: "ListJobs",
      requestType: ListJobsRequest,
      requestStream: false,
      responseType: ListJobsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([13, 112, 97, 114, 101, 110, 116, 44, 102, 105, 108, 116, 101, 114])],
          578365826: [
            Buffer.from([
              40,
              18,
              38,
              47,
              118,
              52,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              110,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              106,
              111,
              98,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Searches for jobs using the provided
     * [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
     *
     * This call constrains the
     * [visibility][google.cloud.talent.v4.Job.visibility] of jobs present in the
     * database, and only returns jobs that the caller has permission to search
     * against.
     */
    searchJobs: {
      name: "SearchJobs",
      requestType: SearchJobsRequest,
      requestStream: false,
      responseType: SearchJobsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              50,
              58,
              1,
              42,
              34,
              45,
              47,
              118,
              52,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              110,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              106,
              111,
              98,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Searches for jobs using the provided
     * [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
     *
     * This API call is intended for the use case of targeting passive job
     * seekers (for example, job seekers who have signed up to receive email
     * alerts about potential job opportunities), it has different algorithmic
     * adjustments that are designed to specifically target passive job seekers.
     *
     * This call constrains the
     * [visibility][google.cloud.talent.v4.Job.visibility] of jobs present in the
     * database, and only returns jobs the caller has permission to search
     * against.
     */
    searchJobsForAlert: {
      name: "SearchJobsForAlert",
      requestType: SearchJobsRequest,
      requestStream: false,
      responseType: SearchJobsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              58,
              58,
              1,
              42,
              34,
              53,
              47,
              118,
              52,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              110,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              106,
              111,
              98,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              70,
              111,
              114,
              65,
              108,
              101,
              114,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface JobServiceImplementation<CallContextExt = {}> {
  /**
   * Creates a new job.
   *
   * Typically, the job becomes searchable within 10 seconds, but it may take
   * up to 5 minutes.
   */
  createJob(request: CreateJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Job>>;
  /** Begins executing a batch create jobs operation. */
  batchCreateJobs(
    request: BatchCreateJobsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Retrieves the specified job, whose status is OPEN or recently EXPIRED
   * within the last 90 days.
   */
  getJob(request: GetJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Job>>;
  /**
   * Updates specified job.
   *
   * Typically, updated contents become visible in search results within 10
   * seconds, but it may take up to 5 minutes.
   */
  updateJob(request: UpdateJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Job>>;
  /** Begins executing a batch update jobs operation. */
  batchUpdateJobs(
    request: BatchUpdateJobsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes the specified job.
   *
   * Typically, the job becomes unsearchable within 10 seconds, but it may take
   * up to 5 minutes.
   */
  deleteJob(request: DeleteJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Begins executing a batch delete jobs operation. */
  batchDeleteJobs(
    request: BatchDeleteJobsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists jobs by filter. */
  listJobs(request: ListJobsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListJobsResponse>>;
  /**
   * Searches for jobs using the provided
   * [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
   *
   * This call constrains the
   * [visibility][google.cloud.talent.v4.Job.visibility] of jobs present in the
   * database, and only returns jobs that the caller has permission to search
   * against.
   */
  searchJobs(
    request: SearchJobsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchJobsResponse>>;
  /**
   * Searches for jobs using the provided
   * [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
   *
   * This API call is intended for the use case of targeting passive job
   * seekers (for example, job seekers who have signed up to receive email
   * alerts about potential job opportunities), it has different algorithmic
   * adjustments that are designed to specifically target passive job seekers.
   *
   * This call constrains the
   * [visibility][google.cloud.talent.v4.Job.visibility] of jobs present in the
   * database, and only returns jobs the caller has permission to search
   * against.
   */
  searchJobsForAlert(
    request: SearchJobsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchJobsResponse>>;
}

export interface JobServiceClient<CallOptionsExt = {}> {
  /**
   * Creates a new job.
   *
   * Typically, the job becomes searchable within 10 seconds, but it may take
   * up to 5 minutes.
   */
  createJob(request: DeepPartial<CreateJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Job>;
  /** Begins executing a batch create jobs operation. */
  batchCreateJobs(
    request: DeepPartial<BatchCreateJobsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Retrieves the specified job, whose status is OPEN or recently EXPIRED
   * within the last 90 days.
   */
  getJob(request: DeepPartial<GetJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Job>;
  /**
   * Updates specified job.
   *
   * Typically, updated contents become visible in search results within 10
   * seconds, but it may take up to 5 minutes.
   */
  updateJob(request: DeepPartial<UpdateJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Job>;
  /** Begins executing a batch update jobs operation. */
  batchUpdateJobs(
    request: DeepPartial<BatchUpdateJobsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes the specified job.
   *
   * Typically, the job becomes unsearchable within 10 seconds, but it may take
   * up to 5 minutes.
   */
  deleteJob(request: DeepPartial<DeleteJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Begins executing a batch delete jobs operation. */
  batchDeleteJobs(
    request: DeepPartial<BatchDeleteJobsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists jobs by filter. */
  listJobs(request: DeepPartial<ListJobsRequest>, options?: CallOptions & CallOptionsExt): Promise<ListJobsResponse>;
  /**
   * Searches for jobs using the provided
   * [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
   *
   * This call constrains the
   * [visibility][google.cloud.talent.v4.Job.visibility] of jobs present in the
   * database, and only returns jobs that the caller has permission to search
   * against.
   */
  searchJobs(
    request: DeepPartial<SearchJobsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchJobsResponse>;
  /**
   * Searches for jobs using the provided
   * [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
   *
   * This API call is intended for the use case of targeting passive job
   * seekers (for example, job seekers who have signed up to receive email
   * alerts about potential job opportunities), it has different algorithmic
   * adjustments that are designed to specifically target passive job seekers.
   *
   * This call constrains the
   * [visibility][google.cloud.talent.v4.Job.visibility] of jobs present in the
   * database, and only returns jobs the caller has permission to search
   * against.
   */
  searchJobsForAlert(
    request: DeepPartial<SearchJobsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchJobsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
