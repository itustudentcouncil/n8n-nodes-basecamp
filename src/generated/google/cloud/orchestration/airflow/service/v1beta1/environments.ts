// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/orchestration/airflow/service/v1beta1/environments.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../../../longrunning/operations.js";
import { Empty } from "../../../../../protobuf/empty.js";
import { FieldMask } from "../../../../../protobuf/field_mask.js";
import { Timestamp } from "../../../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.orchestration.airflow.service.v1beta1";

/** Create a new environment. */
export interface CreateEnvironmentRequest {
  /**
   * The parent must be of the form
   * "projects/{projectId}/locations/{locationId}".
   */
  parent: string;
  /** The environment to create. */
  environment: Environment | undefined;
}

/** Get an environment. */
export interface GetEnvironmentRequest {
  /**
   * The resource name of the environment to get, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  name: string;
}

/** List environments in a project and location. */
export interface ListEnvironmentsRequest {
  /**
   * List environments in the given project and location, in the form:
   * "projects/{projectId}/locations/{locationId}"
   */
  parent: string;
  /** The maximum number of environments to return. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
}

/** The environments in a project and location. */
export interface ListEnvironmentsResponse {
  /** The list of environments returned by a ListEnvironmentsRequest. */
  environments: Environment[];
  /** The page token used to query for the next page if one exists. */
  nextPageToken: string;
}

/** Delete an environment. */
export interface DeleteEnvironmentRequest {
  /**
   * The environment to delete, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  name: string;
}

/** Update an environment. */
export interface UpdateEnvironmentRequest {
  /**
   * The relative resource name of the environment to update, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  name: string;
  /**
   * A patch environment. Fields specified by the `updateMask` will be copied
   * from the patch environment into the environment under update.
   */
  environment:
    | Environment
    | undefined;
  /**
   * Required. A comma-separated list of paths, relative to `Environment`, of
   * fields to update.
   * For example, to set the version of scikit-learn to install in the
   * environment to 0.19.0 and to remove an existing installation of
   * argparse, the `updateMask` parameter would include the following two
   * `paths` values: "config.softwareConfig.pypiPackages.scikit-learn" and
   * "config.softwareConfig.pypiPackages.argparse". The included patch
   * environment would specify the scikit-learn version as follows:
   *
   *     {
   *       "config":{
   *         "softwareConfig":{
   *           "pypiPackages":{
   *             "scikit-learn":"==0.19.0"
   *           }
   *         }
   *       }
   *     }
   *
   * Note that in the above example, any existing PyPI packages
   * other than scikit-learn and argparse will be unaffected.
   *
   * Only one update type may be included in a single request's `updateMask`.
   * For example, one cannot update both the PyPI packages and
   * labels in the same request. However, it is possible to update multiple
   * members of a map field simultaneously in the same request. For example,
   * to set the labels "label1" and "label2" while clearing "label3" (assuming
   * it already exists), one can
   * provide the paths "labels.label1", "labels.label2", and "labels.label3"
   * and populate the patch environment as follows:
   *
   *     {
   *       "labels":{
   *         "label1":"new-label1-value"
   *         "label2":"new-label2-value"
   *       }
   *     }
   *
   * Note that in the above example, any existing labels that are not
   * included in the `updateMask` will be unaffected.
   *
   * It is also possible to replace an entire map field by providing the
   * map field's path in the `updateMask`. The new value of the field will
   * be that which is provided in the patch environment. For example, to
   * delete all pre-existing user-specified PyPI packages and
   * install botocore at version 1.7.14, the `updateMask` would contain
   * the path "config.softwareConfig.pypiPackages", and
   * the patch environment would be the following:
   *
   *     {
   *       "config":{
   *         "softwareConfig":{
   *           "pypiPackages":{
   *             "botocore":"==1.7.14"
   *           }
   *         }
   *       }
   *     }
   *
   * **Note:** Only the following fields can be updated:
   *
   * * `config.softwareConfig.pypiPackages`
   *     * Replace all custom custom PyPI packages. If a replacement
   *       package map is not included in `environment`, all custom
   *       PyPI packages are cleared. It is an error to provide both
   *       this mask and a mask specifying an individual package.
   * * `config.softwareConfig.pypiPackages.`packagename
   *     * Update the custom PyPI package *packagename*,
   *       preserving other packages. To delete the package, include it in
   *       `updateMask`, and omit the mapping for it in
   *       `environment.config.softwareConfig.pypiPackages`. It is an error
   *       to provide both a mask of this form and the
   *       `config.softwareConfig.pypiPackages` mask.
   * * `labels`
   *     * Replace all environment labels. If a replacement labels map is not
   *       included in `environment`, all labels are cleared. It is an error to
   *       provide both this mask and a mask specifying one or more individual
   *       labels.
   * * `labels.`labelName
   *     * Set the label named *labelName*, while preserving other
   *       labels. To delete the label, include it in `updateMask` and omit its
   *       mapping in `environment.labels`. It is an error to provide both a
   *       mask of this form and the `labels` mask.
   * * `config.nodeCount`
   *     * Horizontally scale the number of nodes in the environment. An integer
   *       greater than or equal to 3 must be provided in the `config.nodeCount`
   *       field. Supported for Cloud Composer environments in versions
   *       composer-1.*.*-airflow-*.*.*.
   * * `config.webServerNetworkAccessControl`
   *     * Replace the environment's current WebServerNetworkAccessControl.
   * * `config.softwareConfig.airflowConfigOverrides`
   *     * Replace all Apache Airflow config overrides. If a replacement config
   *       overrides map is not included in `environment`, all config overrides
   *       are cleared.
   *       It is an error to provide both this mask and a mask specifying one or
   *       more individual config overrides.
   * * `config.softwareConfig.airflowConfigOverrides.`section-name
   *     * Override the Apache Airflow config property *name* in the
   *       section named *section*, preserving other properties. To
   *       delete the property override, include it in `updateMask` and omit its
   *       mapping in
   *       `environment.config.softwareConfig.airflowConfigOverrides`.
   *       It is an error to provide both a mask of this form and the
   *       `config.softwareConfig.airflowConfigOverrides` mask.
   * * `config.softwareConfig.envVariables`
   *     * Replace all environment variables. If a replacement environment
   *       variable map is not included in `environment`, all custom environment
   *       variables are cleared.
   * * `config.softwareConfig.imageVersion`
   *     * Upgrade the version of the environment in-place. Refer to
   *       `SoftwareConfig.image_version` for information on how to format the
   *       new image version. Additionally, the new image version cannot effect
   *       a version downgrade, and must match the current image version's
   *       Composer and Airflow major versions. Consult the [Cloud Composer
   *       version list](/composer/docs/concepts/versioning/composer-versions)
   *       for valid values.
   * * `config.softwareConfig.schedulerCount`
   *     * Horizontally scale the number of schedulers in Airflow. A positive
   *       integer not greater than the number of nodes must be provided in the
   *       `config.softwareConfig.schedulerCount` field. Supported for Cloud
   *       Composer environments in versions composer-1.*.*-airflow-2.*.*.
   * * `config.softwareConfig.cloudDataLineageIntegration`
   *     * Configuration for Cloud Data Lineage integration.
   * * `config.databaseConfig.machineType`
   *     * Cloud SQL machine type used by Airflow database.
   *       It has to be one of: db-n1-standard-2, db-n1-standard-4,
   *       db-n1-standard-8 or db-n1-standard-16. Supported for Cloud Composer
   *       environments in versions composer-1.*.*-airflow-*.*.*.
   * * `config.webServerConfig.machineType`
   *     * Machine type on which Airflow web server is running.
   *       It has to be one of: composer-n1-webserver-2, composer-n1-webserver-4
   *       or composer-n1-webserver-8. Supported for Cloud Composer environments
   *       in versions composer-1.*.*-airflow-*.*.*.
   * * `config.maintenanceWindow`
   *     * Maintenance window during which Cloud Composer components may be
   *       under maintenance.
   * * `config.workloadsConfig`
   *     * The workloads configuration settings for the GKE cluster associated
   *       with the Cloud Composer environment. Supported for Cloud Composer
   *       environments in versions composer-2.*.*-airflow-*.*.* and newer.
   * * `config.environmentSize`
   *     * The size of the Cloud Composer environment. Supported for Cloud
   *       Composer environments in versions composer-2.*.*-airflow-*.*.* and
   *       newer.
   */
  updateMask: string[] | undefined;
}

/** Restart Airflow web server. */
export interface RestartWebServerRequest {
  /**
   * The resource name of the environment to restart the web server for, in the
   * form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  name: string;
}

/** Execute Airflow Command request. */
export interface ExecuteAirflowCommandRequest {
  /**
   * The resource name of the environment in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}".
   */
  environment: string;
  /** Airflow command. */
  command: string;
  /** Airflow subcommand. */
  subcommand: string;
  /**
   * Parameters for the Airflow command/subcommand as an array of arguments.
   * It may contain positional arguments like `["my-dag-id"]`, key-value
   * parameters like `["--foo=bar"]` or `["--foo","bar"]`,
   * or other flags like `["-f"]`.
   */
  parameters: string[];
}

/** Response to ExecuteAirflowCommandRequest. */
export interface ExecuteAirflowCommandResponse {
  /** The unique ID of the command execution for polling. */
  executionId: string;
  /** The name of the pod where the command is executed. */
  pod: string;
  /** The namespace of the pod where the command is executed. */
  podNamespace: string;
  /** Error message. Empty if there was no error. */
  error: string;
}

/** Stop Airflow Command request. */
export interface StopAirflowCommandRequest {
  /**
   * The resource name of the environment in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}".
   */
  environment: string;
  /** The unique ID of the command execution. */
  executionId: string;
  /** The name of the pod where the command is executed. */
  pod: string;
  /** The namespace of the pod where the command is executed. */
  podNamespace: string;
  /**
   * If true, the execution is terminated forcefully (SIGKILL). If false, the
   * execution is stopped gracefully, giving it time for cleanup.
   */
  force: boolean;
}

/** Response to StopAirflowCommandRequest. */
export interface StopAirflowCommandResponse {
  /** Whether the execution is still running. */
  isDone: boolean;
  /** Output message from stopping execution request. */
  output: string[];
}

/** Poll Airflow Command request. */
export interface PollAirflowCommandRequest {
  /**
   * The resource name of the environment in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  environment: string;
  /** The unique ID of the command execution. */
  executionId: string;
  /** The name of the pod where the command is executed. */
  pod: string;
  /** The namespace of the pod where the command is executed. */
  podNamespace: string;
  /** Line number from which new logs should be fetched. */
  nextLineNumber: number;
}

/** Response to PollAirflowCommandRequest. */
export interface PollAirflowCommandResponse {
  /**
   * Output from the command execution. It may not contain the full output
   * and the caller may need to poll for more lines.
   */
  output: PollAirflowCommandResponse_Line[];
  /** Whether the command execution has finished and there is no more output. */
  outputEnd: boolean;
  /** The result exit status of the command. */
  exitInfo: PollAirflowCommandResponse_ExitInfo | undefined;
}

/** Contains information about a single line from logs. */
export interface PollAirflowCommandResponse_Line {
  /** Number of the line. */
  lineNumber: number;
  /** Text content of the log line. */
  content: string;
}

/** Information about how a command ended. */
export interface PollAirflowCommandResponse_ExitInfo {
  /** The exit code from the command execution. */
  exitCode: number;
  /** Error message. Empty if there was no error. */
  error: string;
}

/** Create user workloads Secret request. */
export interface CreateUserWorkloadsSecretRequest {
  /**
   * Required. The environment name to create a Secret for, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  parent: string;
  /** Required. User workloads Secret to create. */
  userWorkloadsSecret: UserWorkloadsSecret | undefined;
}

/** Get user workloads Secret request. */
export interface GetUserWorkloadsSecretRequest {
  /**
   * Required. The resource name of the Secret to get, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsSecrets/{userWorkloadsSecretId}"
   */
  name: string;
}

/** List user workloads Secrets request. */
export interface ListUserWorkloadsSecretsRequest {
  /**
   * Required. List Secrets in the given environment, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  parent: string;
  /** Optional. The maximum number of Secrets to return. */
  pageSize: number;
  /**
   * Optional. The next_page_token value returned from a previous List request,
   * if any.
   */
  pageToken: string;
}

/** Update user workloads Secret request. */
export interface UpdateUserWorkloadsSecretRequest {
  /** Optional. User workloads Secret to override. */
  userWorkloadsSecret: UserWorkloadsSecret | undefined;
}

/** Delete user workloads Secret request. */
export interface DeleteUserWorkloadsSecretRequest {
  /**
   * Required. The Secret to delete, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsSecrets/{userWorkloadsSecretId}"
   */
  name: string;
}

/** Create user workloads ConfigMap request. */
export interface CreateUserWorkloadsConfigMapRequest {
  /**
   * Required. The environment name to create a ConfigMap for, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  parent: string;
  /** Required. User workloads ConfigMap to create. */
  userWorkloadsConfigMap: UserWorkloadsConfigMap | undefined;
}

/** Get user workloads ConfigMap request. */
export interface GetUserWorkloadsConfigMapRequest {
  /**
   * Required. The resource name of the ConfigMap to get, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsConfigMaps/{userWorkloadsConfigMapId}"
   */
  name: string;
}

/** List user workloads ConfigMaps request. */
export interface ListUserWorkloadsConfigMapsRequest {
  /**
   * Required. List ConfigMaps in the given environment, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  parent: string;
  /** Optional. The maximum number of ConfigMaps to return. */
  pageSize: number;
  /**
   * Optional. The next_page_token value returned from a previous List request,
   * if any.
   */
  pageToken: string;
}

/** Update user workloads ConfigMap request. */
export interface UpdateUserWorkloadsConfigMapRequest {
  /** Optional. User workloads ConfigMap to override. */
  userWorkloadsConfigMap: UserWorkloadsConfigMap | undefined;
}

/** Delete user workloads ConfigMap request. */
export interface DeleteUserWorkloadsConfigMapRequest {
  /**
   * Required. The ConfigMap to delete, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsConfigMaps/{userWorkloadsConfigMapId}"
   */
  name: string;
}

/**
 * User workloads Secret used by Airflow tasks that run with Kubernetes executor
 * or KubernetesPodOperator.
 */
export interface UserWorkloadsSecret {
  /**
   * Identifier. The resource name of the Secret, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsSecrets/{userWorkloadsSecretId}"
   */
  name: string;
  /**
   * Optional. The "data" field of Kubernetes Secret, organized in key-value
   * pairs, which can contain sensitive values such as a password, a token, or a
   * key. The values for all keys have to be base64-encoded strings. For details
   * see: https://kubernetes.io/docs/concepts/configuration/secret/
   */
  data: { [key: string]: string };
}

export interface UserWorkloadsSecret_DataEntry {
  key: string;
  value: string;
}

/** The user workloads Secrets for a given environment. */
export interface ListUserWorkloadsSecretsResponse {
  /** The list of Secrets returned by a ListUserWorkloadsSecretsRequest. */
  userWorkloadsSecrets: UserWorkloadsSecret[];
  /** The page token used to query for the next page if one exists. */
  nextPageToken: string;
}

/**
 * User workloads ConfigMap used by Airflow tasks that run with Kubernetes
 * executor or KubernetesPodOperator.
 */
export interface UserWorkloadsConfigMap {
  /**
   * Identifier. The resource name of the ConfigMap, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsConfigMaps/{userWorkloadsConfigMapId}"
   */
  name: string;
  /**
   * Optional. The "data" field of Kubernetes ConfigMap, organized in key-value
   * pairs. For details see:
   * https://kubernetes.io/docs/concepts/configuration/configmap/
   */
  data: { [key: string]: string };
}

export interface UserWorkloadsConfigMap_DataEntry {
  key: string;
  value: string;
}

/** The user workloads ConfigMaps for a given environment. */
export interface ListUserWorkloadsConfigMapsResponse {
  /** The list of ConfigMaps returned by a ListUserWorkloadsConfigMapsRequest. */
  userWorkloadsConfigMaps: UserWorkloadsConfigMap[];
  /** The page token used to query for the next page if one exists. */
  nextPageToken: string;
}

/** Request for listing workloads in a Cloud Composer environment. */
export interface ListWorkloadsRequest {
  /**
   * Required. The environment name to get workloads for, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  parent: string;
  /** Optional. The maximum number of environments to return. */
  pageSize: number;
  /**
   * Optional. The next_page_token value returned from a previous List request,
   * if any.
   */
  pageToken: string;
  /**
   * Optional. The list filter.
   * Currently only supports equality on the type field. The value of a field
   * specified in the filter expression must be one ComposerWorkloadType enum
   * option. It's possible to get multiple types using "OR" operator, e.g.:
   * "type=SCHEDULER OR type=CELERY_WORKER". If not specified, all items are
   * returned.
   */
  filter: string;
}

/** Response to ListWorkloadsRequest. */
export interface ListWorkloadsResponse {
  /** The list of environment workloads. */
  workloads: ListWorkloadsResponse_ComposerWorkload[];
  /** The page token used to query for the next page if one exists. */
  nextPageToken: string;
}

/** Supported workload types. */
export enum ListWorkloadsResponse_ComposerWorkloadType {
  /** COMPOSER_WORKLOAD_TYPE_UNSPECIFIED - Not able to determine the type of the workload. */
  COMPOSER_WORKLOAD_TYPE_UNSPECIFIED = 0,
  /** CELERY_WORKER - Celery worker. */
  CELERY_WORKER = 1,
  /** KUBERNETES_WORKER - Kubernetes worker. */
  KUBERNETES_WORKER = 2,
  /** KUBERNETES_OPERATOR_POD - Workload created by Kubernetes Pod Operator. */
  KUBERNETES_OPERATOR_POD = 3,
  /** SCHEDULER - Airflow scheduler. */
  SCHEDULER = 4,
  /** DAG_PROCESSOR - Airflow Dag processor. */
  DAG_PROCESSOR = 5,
  /** TRIGGERER - Airflow triggerer. */
  TRIGGERER = 6,
  /** WEB_SERVER - Airflow web server UI. */
  WEB_SERVER = 7,
  /** REDIS - Redis. */
  REDIS = 8,
  UNRECOGNIZED = -1,
}

export function listWorkloadsResponse_ComposerWorkloadTypeFromJSON(
  object: any,
): ListWorkloadsResponse_ComposerWorkloadType {
  switch (object) {
    case 0:
    case "COMPOSER_WORKLOAD_TYPE_UNSPECIFIED":
      return ListWorkloadsResponse_ComposerWorkloadType.COMPOSER_WORKLOAD_TYPE_UNSPECIFIED;
    case 1:
    case "CELERY_WORKER":
      return ListWorkloadsResponse_ComposerWorkloadType.CELERY_WORKER;
    case 2:
    case "KUBERNETES_WORKER":
      return ListWorkloadsResponse_ComposerWorkloadType.KUBERNETES_WORKER;
    case 3:
    case "KUBERNETES_OPERATOR_POD":
      return ListWorkloadsResponse_ComposerWorkloadType.KUBERNETES_OPERATOR_POD;
    case 4:
    case "SCHEDULER":
      return ListWorkloadsResponse_ComposerWorkloadType.SCHEDULER;
    case 5:
    case "DAG_PROCESSOR":
      return ListWorkloadsResponse_ComposerWorkloadType.DAG_PROCESSOR;
    case 6:
    case "TRIGGERER":
      return ListWorkloadsResponse_ComposerWorkloadType.TRIGGERER;
    case 7:
    case "WEB_SERVER":
      return ListWorkloadsResponse_ComposerWorkloadType.WEB_SERVER;
    case 8:
    case "REDIS":
      return ListWorkloadsResponse_ComposerWorkloadType.REDIS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ListWorkloadsResponse_ComposerWorkloadType.UNRECOGNIZED;
  }
}

export function listWorkloadsResponse_ComposerWorkloadTypeToJSON(
  object: ListWorkloadsResponse_ComposerWorkloadType,
): string {
  switch (object) {
    case ListWorkloadsResponse_ComposerWorkloadType.COMPOSER_WORKLOAD_TYPE_UNSPECIFIED:
      return "COMPOSER_WORKLOAD_TYPE_UNSPECIFIED";
    case ListWorkloadsResponse_ComposerWorkloadType.CELERY_WORKER:
      return "CELERY_WORKER";
    case ListWorkloadsResponse_ComposerWorkloadType.KUBERNETES_WORKER:
      return "KUBERNETES_WORKER";
    case ListWorkloadsResponse_ComposerWorkloadType.KUBERNETES_OPERATOR_POD:
      return "KUBERNETES_OPERATOR_POD";
    case ListWorkloadsResponse_ComposerWorkloadType.SCHEDULER:
      return "SCHEDULER";
    case ListWorkloadsResponse_ComposerWorkloadType.DAG_PROCESSOR:
      return "DAG_PROCESSOR";
    case ListWorkloadsResponse_ComposerWorkloadType.TRIGGERER:
      return "TRIGGERER";
    case ListWorkloadsResponse_ComposerWorkloadType.WEB_SERVER:
      return "WEB_SERVER";
    case ListWorkloadsResponse_ComposerWorkloadType.REDIS:
      return "REDIS";
    case ListWorkloadsResponse_ComposerWorkloadType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Workload states. */
export enum ListWorkloadsResponse_ComposerWorkloadState {
  /** COMPOSER_WORKLOAD_STATE_UNSPECIFIED - Not able to determine the status of the workload. */
  COMPOSER_WORKLOAD_STATE_UNSPECIFIED = 0,
  /** PENDING - Workload is in pending state and has not yet started. */
  PENDING = 1,
  /** OK - Workload is running fine. */
  OK = 2,
  /** WARNING - Workload is running but there are some non-critical problems. */
  WARNING = 3,
  /** ERROR - Workload is not running due to an error. */
  ERROR = 4,
  /** SUCCEEDED - Workload has finished execution with success. */
  SUCCEEDED = 5,
  /** FAILED - Workload has finished execution with failure. */
  FAILED = 6,
  UNRECOGNIZED = -1,
}

export function listWorkloadsResponse_ComposerWorkloadStateFromJSON(
  object: any,
): ListWorkloadsResponse_ComposerWorkloadState {
  switch (object) {
    case 0:
    case "COMPOSER_WORKLOAD_STATE_UNSPECIFIED":
      return ListWorkloadsResponse_ComposerWorkloadState.COMPOSER_WORKLOAD_STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return ListWorkloadsResponse_ComposerWorkloadState.PENDING;
    case 2:
    case "OK":
      return ListWorkloadsResponse_ComposerWorkloadState.OK;
    case 3:
    case "WARNING":
      return ListWorkloadsResponse_ComposerWorkloadState.WARNING;
    case 4:
    case "ERROR":
      return ListWorkloadsResponse_ComposerWorkloadState.ERROR;
    case 5:
    case "SUCCEEDED":
      return ListWorkloadsResponse_ComposerWorkloadState.SUCCEEDED;
    case 6:
    case "FAILED":
      return ListWorkloadsResponse_ComposerWorkloadState.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ListWorkloadsResponse_ComposerWorkloadState.UNRECOGNIZED;
  }
}

export function listWorkloadsResponse_ComposerWorkloadStateToJSON(
  object: ListWorkloadsResponse_ComposerWorkloadState,
): string {
  switch (object) {
    case ListWorkloadsResponse_ComposerWorkloadState.COMPOSER_WORKLOAD_STATE_UNSPECIFIED:
      return "COMPOSER_WORKLOAD_STATE_UNSPECIFIED";
    case ListWorkloadsResponse_ComposerWorkloadState.PENDING:
      return "PENDING";
    case ListWorkloadsResponse_ComposerWorkloadState.OK:
      return "OK";
    case ListWorkloadsResponse_ComposerWorkloadState.WARNING:
      return "WARNING";
    case ListWorkloadsResponse_ComposerWorkloadState.ERROR:
      return "ERROR";
    case ListWorkloadsResponse_ComposerWorkloadState.SUCCEEDED:
      return "SUCCEEDED";
    case ListWorkloadsResponse_ComposerWorkloadState.FAILED:
      return "FAILED";
    case ListWorkloadsResponse_ComposerWorkloadState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about a single workload. */
export interface ListWorkloadsResponse_ComposerWorkload {
  /** Name of a workload. */
  name: string;
  /** Type of a workload. */
  type: ListWorkloadsResponse_ComposerWorkloadType;
  /** Output only. Status of a workload. */
  status: ListWorkloadsResponse_ComposerWorkloadStatus | undefined;
}

/** Workload status. */
export interface ListWorkloadsResponse_ComposerWorkloadStatus {
  /** Output only. Workload state. */
  state: ListWorkloadsResponse_ComposerWorkloadState;
  /** Output only. Text to provide more descriptive status. */
  statusMessage: string;
  /** Output only. Detailed message of the status. */
  detailedStatusMessage: string;
}

/** Request to create a snapshot of a Cloud Composer environment. */
export interface SaveSnapshotRequest {
  /**
   * The resource name of the source environment in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  environment: string;
  /**
   * Location in a Cloud Storage where the snapshot is going to be stored, e.g.:
   * "gs://my-bucket/snapshots".
   */
  snapshotLocation: string;
}

/** Response to SaveSnapshotRequest. */
export interface SaveSnapshotResponse {
  /**
   * The fully-resolved Cloud Storage path of the created snapshot,
   * e.g.:
   * "gs://my-bucket/snapshots/project_location_environment_timestamp".
   * This field is populated only if the snapshot creation was successful.
   */
  snapshotPath: string;
}

/** Request to load a snapshot into a Cloud Composer environment. */
export interface LoadSnapshotRequest {
  /**
   * The resource name of the target environment in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  environment: string;
  /**
   * A Cloud Storage path to a snapshot to load, e.g.:
   * "gs://my-bucket/snapshots/project_location_environment_timestamp".
   */
  snapshotPath: string;
  /**
   * Whether or not to skip installing Pypi packages when loading the
   * environment's state.
   */
  skipPypiPackagesInstallation: boolean;
  /**
   * Whether or not to skip setting environment variables when loading the
   * environment's state.
   */
  skipEnvironmentVariablesSetting: boolean;
  /**
   * Whether or not to skip setting Airflow overrides when loading the
   * environment's state.
   */
  skipAirflowOverridesSetting: boolean;
  /**
   * Whether or not to skip copying Cloud Storage data when loading the
   * environment's state.
   */
  skipGcsDataCopying: boolean;
}

/** Response to LoadSnapshotRequest. */
export interface LoadSnapshotResponse {
}

/**
 * Request to trigger database failover (only for highly resilient
 * environments).
 */
export interface DatabaseFailoverRequest {
  /**
   * Target environment:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  environment: string;
}

/** Response for DatabaseFailoverRequest. */
export interface DatabaseFailoverResponse {
}

/** Request to fetch properties of environment's database. */
export interface FetchDatabasePropertiesRequest {
  /**
   * Required. The resource name of the environment, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  environment: string;
}

/** Response for FetchDatabasePropertiesRequest. */
export interface FetchDatabasePropertiesResponse {
  /** The Compute Engine zone that the instance is currently serving from. */
  primaryGceZone: string;
  /**
   * The Compute Engine zone that the failover instance is currently serving
   * from for a regional Cloud SQL instance.
   */
  secondaryGceZone: string;
  /**
   * The availability status of the failover replica. A false status indicates
   * that the failover replica is out of sync. The primary instance can only
   * fail over to the failover replica when the status is true.
   */
  isFailoverReplicaAvailable: boolean;
}

/** Configuration information for an environment. */
export interface EnvironmentConfig {
  /** Output only. The Kubernetes Engine cluster used to run this environment. */
  gkeCluster: string;
  /**
   * Output only. The Cloud Storage prefix of the DAGs for this environment.
   * Although Cloud Storage objects reside in a flat namespace, a hierarchical
   * file tree can be simulated using "/"-delimited object name prefixes. DAG
   * objects for this environment reside in a simulated directory with the given
   * prefix.
   */
  dagGcsPrefix: string;
  /**
   * The number of nodes in the Kubernetes Engine cluster that will be
   * used to run this environment.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-1.*.*-airflow-*.*.*.
   */
  nodeCount: number;
  /** The configuration settings for software inside the environment. */
  softwareConfig:
    | SoftwareConfig
    | undefined;
  /** The configuration used for the Kubernetes Engine cluster. */
  nodeConfig:
    | NodeConfig
    | undefined;
  /** The configuration used for the Private IP Cloud Composer environment. */
  privateEnvironmentConfig:
    | PrivateEnvironmentConfig
    | undefined;
  /**
   * Optional. The network-level access control policy for the Airflow web
   * server. If unspecified, no network-level access restrictions will be
   * applied.
   */
  webServerNetworkAccessControl:
    | WebServerNetworkAccessControl
    | undefined;
  /**
   * Optional. The configuration settings for Cloud SQL instance used internally
   * by Apache Airflow software.
   */
  databaseConfig:
    | DatabaseConfig
    | undefined;
  /**
   * Optional. The configuration settings for the Airflow web server App Engine
   * instance.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-1.*.*-airflow-*.*.*.
   */
  webServerConfig:
    | WebServerConfig
    | undefined;
  /**
   * Output only. The URI of the Apache Airflow Web UI hosted within this
   * environment (see [Airflow web
   * interface](/composer/docs/how-to/accessing/airflow-web-interface)).
   */
  airflowUri: string;
  /**
   * Output only. The 'bring your own identity' variant of the URI of the Apache
   * Airflow Web UI hosted within this environment, to be accessed with external
   * identities using workforce identity federation (see [Access environments
   * with workforce identity
   * federation](/composer/docs/composer-2/access-environments-with-workforce-identity-federation)).
   */
  airflowByoidUri: string;
  /**
   * Optional. The encryption options for the Cloud Composer environment and its
   * dependencies. Cannot be updated.
   */
  encryptionConfig:
    | EncryptionConfig
    | undefined;
  /**
   * Optional. The maintenance window is the period when Cloud Composer
   * components may undergo maintenance. It is defined so that maintenance is
   * not executed during peak hours or critical time periods.
   *
   * The system will not be under maintenance for every occurrence of this
   * window, but when maintenance is planned, it will be scheduled
   * during the window.
   *
   * The maintenance window period must encompass at least 12 hours per week.
   * This may be split into multiple chunks, each with a size of
   * at least 4 hours.
   *
   * If this value is omitted, the default value for maintenance window is
   * applied. By default, maintenance windows are from 00:00:00 to 04:00:00
   * (GMT) on Friday, Saturday, and Sunday every week.
   */
  maintenanceWindow:
    | MaintenanceWindow
    | undefined;
  /**
   * Optional. The workloads configuration settings for the GKE cluster
   * associated with the Cloud Composer environment. The GKE cluster runs
   * Airflow scheduler, web server and workers workloads.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-2.*.*-airflow-*.*.* and newer.
   */
  workloadsConfig:
    | WorkloadsConfig
    | undefined;
  /**
   * Optional. The size of the Cloud Composer environment.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-2.*.*-airflow-*.*.* and newer.
   */
  environmentSize: EnvironmentConfig_EnvironmentSize;
  /**
   * Optional. The configuration options for GKE cluster master authorized
   * networks. By default master authorized networks feature is:
   * - in case of private environment: enabled with no external networks
   * allowlisted.
   * - in case of public environment: disabled.
   */
  masterAuthorizedNetworksConfig:
    | MasterAuthorizedNetworksConfig
    | undefined;
  /**
   * Optional. The Recovery settings configuration of an environment.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-2.*.*-airflow-*.*.* and newer.
   */
  recoveryConfig:
    | RecoveryConfig
    | undefined;
  /**
   * Optional. The configuration setting for Airflow database data retention
   * mechanism.
   */
  dataRetentionConfig:
    | DataRetentionConfig
    | undefined;
  /**
   * Optional. Resilience mode of the Cloud Composer Environment.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-2.2.0-airflow-*.*.* and newer.
   */
  resilienceMode: EnvironmentConfig_ResilienceMode;
}

/** The size of the Cloud Composer environment. */
export enum EnvironmentConfig_EnvironmentSize {
  /** ENVIRONMENT_SIZE_UNSPECIFIED - The size of the environment is unspecified. */
  ENVIRONMENT_SIZE_UNSPECIFIED = 0,
  /** ENVIRONMENT_SIZE_SMALL - The environment size is small. */
  ENVIRONMENT_SIZE_SMALL = 1,
  /** ENVIRONMENT_SIZE_MEDIUM - The environment size is medium. */
  ENVIRONMENT_SIZE_MEDIUM = 2,
  /** ENVIRONMENT_SIZE_LARGE - The environment size is large. */
  ENVIRONMENT_SIZE_LARGE = 3,
  UNRECOGNIZED = -1,
}

export function environmentConfig_EnvironmentSizeFromJSON(object: any): EnvironmentConfig_EnvironmentSize {
  switch (object) {
    case 0:
    case "ENVIRONMENT_SIZE_UNSPECIFIED":
      return EnvironmentConfig_EnvironmentSize.ENVIRONMENT_SIZE_UNSPECIFIED;
    case 1:
    case "ENVIRONMENT_SIZE_SMALL":
      return EnvironmentConfig_EnvironmentSize.ENVIRONMENT_SIZE_SMALL;
    case 2:
    case "ENVIRONMENT_SIZE_MEDIUM":
      return EnvironmentConfig_EnvironmentSize.ENVIRONMENT_SIZE_MEDIUM;
    case 3:
    case "ENVIRONMENT_SIZE_LARGE":
      return EnvironmentConfig_EnvironmentSize.ENVIRONMENT_SIZE_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EnvironmentConfig_EnvironmentSize.UNRECOGNIZED;
  }
}

export function environmentConfig_EnvironmentSizeToJSON(object: EnvironmentConfig_EnvironmentSize): string {
  switch (object) {
    case EnvironmentConfig_EnvironmentSize.ENVIRONMENT_SIZE_UNSPECIFIED:
      return "ENVIRONMENT_SIZE_UNSPECIFIED";
    case EnvironmentConfig_EnvironmentSize.ENVIRONMENT_SIZE_SMALL:
      return "ENVIRONMENT_SIZE_SMALL";
    case EnvironmentConfig_EnvironmentSize.ENVIRONMENT_SIZE_MEDIUM:
      return "ENVIRONMENT_SIZE_MEDIUM";
    case EnvironmentConfig_EnvironmentSize.ENVIRONMENT_SIZE_LARGE:
      return "ENVIRONMENT_SIZE_LARGE";
    case EnvironmentConfig_EnvironmentSize.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Resilience mode of the Cloud Composer Environment. */
export enum EnvironmentConfig_ResilienceMode {
  /** RESILIENCE_MODE_UNSPECIFIED - Default mode doesn't change environment parameters. */
  RESILIENCE_MODE_UNSPECIFIED = 0,
  /** HIGH_RESILIENCE - Enabled High Resilience mode, including Cloud SQL HA. */
  HIGH_RESILIENCE = 1,
  UNRECOGNIZED = -1,
}

export function environmentConfig_ResilienceModeFromJSON(object: any): EnvironmentConfig_ResilienceMode {
  switch (object) {
    case 0:
    case "RESILIENCE_MODE_UNSPECIFIED":
      return EnvironmentConfig_ResilienceMode.RESILIENCE_MODE_UNSPECIFIED;
    case 1:
    case "HIGH_RESILIENCE":
      return EnvironmentConfig_ResilienceMode.HIGH_RESILIENCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EnvironmentConfig_ResilienceMode.UNRECOGNIZED;
  }
}

export function environmentConfig_ResilienceModeToJSON(object: EnvironmentConfig_ResilienceMode): string {
  switch (object) {
    case EnvironmentConfig_ResilienceMode.RESILIENCE_MODE_UNSPECIFIED:
      return "RESILIENCE_MODE_UNSPECIFIED";
    case EnvironmentConfig_ResilienceMode.HIGH_RESILIENCE:
      return "HIGH_RESILIENCE";
    case EnvironmentConfig_ResilienceMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Network-level access control policy for the Airflow web server. */
export interface WebServerNetworkAccessControl {
  /** A collection of allowed IP ranges with descriptions. */
  allowedIpRanges: WebServerNetworkAccessControl_AllowedIpRange[];
}

/** Allowed IP range with user-provided description. */
export interface WebServerNetworkAccessControl_AllowedIpRange {
  /**
   * IP address or range, defined using CIDR notation, of requests that this
   * rule applies to.
   * Examples: `192.168.1.1` or `192.168.0.0/16` or `2001:db8::/32`
   *           or `2001:0db8:0000:0042:0000:8a2e:0370:7334`.
   *
   * IP range prefixes should be properly truncated. For example,
   * `1.2.3.4/24` should be truncated to `1.2.3.0/24`. Similarly, for IPv6,
   * `2001:db8::1/32` should be truncated to `2001:db8::/32`.
   */
  value: string;
  /**
   * Optional. User-provided description. It must contain at most 300
   * characters.
   */
  description: string;
}

/** Specifies the selection and configuration of software inside the environment. */
export interface SoftwareConfig {
  /**
   * The version of the software running in the environment.
   * This encapsulates both the version of Cloud Composer functionality and the
   * version of Apache Airflow. It must match the regular expression
   * `composer-([0-9]+(\.[0-9]+\.[0-9]+(-preview\.[0-9]+)?)?|latest)-airflow-([0-9]+(\.[0-9]+(\.[0-9]+)?)?)`.
   * When used as input, the server also checks if the provided version is
   * supported and denies the request for an unsupported version.
   *
   * The Cloud Composer portion of the image version is a full
   * [semantic version](https://semver.org), or an alias in the form of major
   * version number or `latest`. When an alias is provided, the server replaces
   * it with the current Cloud Composer version that satisfies the alias.
   *
   * The Apache Airflow portion of the image version is a full semantic version
   * that points to one of the supported Apache Airflow versions, or an alias in
   * the form of only major or major.minor versions specified. When an alias is
   * provided, the server replaces it with the latest Apache Airflow version
   * that satisfies the alias and is supported in the given Cloud Composer
   * version.
   *
   * In all cases, the resolved image version is stored in the same field.
   *
   * See also [version
   * list](/composer/docs/concepts/versioning/composer-versions) and [versioning
   * overview](/composer/docs/concepts/versioning/composer-versioning-overview).
   */
  imageVersion: string;
  /**
   * Optional. Apache Airflow configuration properties to override.
   *
   * Property keys contain the section and property names, separated by a
   * hyphen, for example "core-dags_are_paused_at_creation". Section names must
   * not contain hyphens ("-"), opening square brackets ("["),  or closing
   * square brackets ("]"). The property name must not be empty and must not
   * contain an equals sign ("=") or semicolon (";"). Section and property names
   * must not contain a period ("."). Apache Airflow configuration property
   * names must be written in
   * [snake_case](https://en.wikipedia.org/wiki/Snake_case). Property values can
   * contain any character, and can be written in any lower/upper case format.
   *
   * Certain Apache Airflow configuration property values are
   * [blocked](/composer/docs/concepts/airflow-configurations),
   * and cannot be overridden.
   */
  airflowConfigOverrides: { [key: string]: string };
  /**
   * Optional. Custom Python Package Index (PyPI) packages to be installed in
   * the environment.
   *
   * Keys refer to the lowercase package name such as "numpy"
   * and values are the lowercase extras and version specifier such as
   * "==1.12.0", "[devel,gcp_api]", or "[devel]>=1.8.2, <1.9.2". To specify a
   * package without pinning it to a version specifier, use the empty string as
   * the value.
   */
  pypiPackages: { [key: string]: string };
  /**
   * Optional. Additional environment variables to provide to the Apache Airflow
   * scheduler, worker, and webserver processes.
   *
   * Environment variable names must match the regular expression
   * `[a-zA-Z_][a-zA-Z0-9_]*`. They cannot specify Apache Airflow
   * software configuration overrides (they cannot match the regular expression
   * `AIRFLOW__[A-Z0-9_]+__[A-Z0-9_]+`), and they cannot match any of the
   * following reserved names:
   *
   * * `AIRFLOW_HOME`
   * * `C_FORCE_ROOT`
   * * `CONTAINER_NAME`
   * * `DAGS_FOLDER`
   * * `GCP_PROJECT`
   * * `GCS_BUCKET`
   * * `GKE_CLUSTER_NAME`
   * * `SQL_DATABASE`
   * * `SQL_INSTANCE`
   * * `SQL_PASSWORD`
   * * `SQL_PROJECT`
   * * `SQL_REGION`
   * * `SQL_USER`
   */
  envVariables: { [key: string]: string };
  /**
   * Optional. The major version of Python used to run the Apache Airflow
   * scheduler, worker, and webserver processes.
   *
   * Can be set to '2' or '3'. If not specified, the default is '3'. Cannot be
   * updated.
   *
   * This field is only supported for Cloud Composer environments in versions
   * composer-1.*.*-airflow-*.*.*. Environments in newer versions always use
   * Python major version 3.
   */
  pythonVersion: string;
  /**
   * Optional. The number of schedulers for Airflow.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-1.*.*-airflow-2.*.*.
   */
  schedulerCount: number;
  /** Optional. The configuration for Cloud Data Lineage integration. */
  cloudDataLineageIntegration:
    | CloudDataLineageIntegration
    | undefined;
  /**
   * Optional. Whether or not the web server uses custom plugins.
   * If unspecified, the field defaults to `PLUGINS_ENABLED`.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  webServerPluginsMode: SoftwareConfig_WebServerPluginsMode;
}

/** Web server plugins mode of the Cloud Composer environment. */
export enum SoftwareConfig_WebServerPluginsMode {
  /** WEB_SERVER_PLUGINS_MODE_UNSPECIFIED - Default mode. */
  WEB_SERVER_PLUGINS_MODE_UNSPECIFIED = 0,
  /** PLUGINS_DISABLED - Web server plugins are not supported. */
  PLUGINS_DISABLED = 1,
  /** PLUGINS_ENABLED - Web server plugins are supported. */
  PLUGINS_ENABLED = 2,
  UNRECOGNIZED = -1,
}

export function softwareConfig_WebServerPluginsModeFromJSON(object: any): SoftwareConfig_WebServerPluginsMode {
  switch (object) {
    case 0:
    case "WEB_SERVER_PLUGINS_MODE_UNSPECIFIED":
      return SoftwareConfig_WebServerPluginsMode.WEB_SERVER_PLUGINS_MODE_UNSPECIFIED;
    case 1:
    case "PLUGINS_DISABLED":
      return SoftwareConfig_WebServerPluginsMode.PLUGINS_DISABLED;
    case 2:
    case "PLUGINS_ENABLED":
      return SoftwareConfig_WebServerPluginsMode.PLUGINS_ENABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SoftwareConfig_WebServerPluginsMode.UNRECOGNIZED;
  }
}

export function softwareConfig_WebServerPluginsModeToJSON(object: SoftwareConfig_WebServerPluginsMode): string {
  switch (object) {
    case SoftwareConfig_WebServerPluginsMode.WEB_SERVER_PLUGINS_MODE_UNSPECIFIED:
      return "WEB_SERVER_PLUGINS_MODE_UNSPECIFIED";
    case SoftwareConfig_WebServerPluginsMode.PLUGINS_DISABLED:
      return "PLUGINS_DISABLED";
    case SoftwareConfig_WebServerPluginsMode.PLUGINS_ENABLED:
      return "PLUGINS_ENABLED";
    case SoftwareConfig_WebServerPluginsMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SoftwareConfig_AirflowConfigOverridesEntry {
  key: string;
  value: string;
}

export interface SoftwareConfig_PypiPackagesEntry {
  key: string;
  value: string;
}

export interface SoftwareConfig_EnvVariablesEntry {
  key: string;
  value: string;
}

/**
 * Configuration for controlling how IPs are allocated in the
 * GKE cluster.
 */
export interface IPAllocationPolicy {
  /**
   * Optional. Whether or not to enable Alias IPs in the GKE cluster.
   * If `true`, a VPC-native cluster is created.
   *
   * This field is only supported for Cloud Composer environments in versions
   * composer-1.*.*-airflow-*.*.*. Environments in newer versions always use
   * VPC-native GKE clusters.
   */
  useIpAliases: boolean;
  /**
   * Optional. The name of the cluster's secondary range used to allocate
   * IP addresses to pods. Specify either `cluster_secondary_range_name`
   * or `cluster_ipv4_cidr_block` but not both.
   *
   * For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*,
   * this field is applicable only when `use_ip_aliases` is true.
   */
  clusterSecondaryRangeName: string;
  /**
   * Optional. The name of the services' secondary range used to allocate
   * IP addresses to the cluster. Specify either `services_secondary_range_name`
   * or `services_ipv4_cidr_block` but not both.
   *
   * For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*,
   * this field is applicable only when `use_ip_aliases` is true.
   */
  servicesSecondaryRangeName: string;
  /**
   * Optional. The IP address range used to allocate IP addresses to pods in
   * the cluster.
   *
   * For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*,
   * this field is applicable only when `use_ip_aliases` is true.
   *
   * Set to blank to have GKE choose a range with the default size.
   *
   * Set to /netmask (e.g. `/14`) to have GKE choose a range with a specific
   * netmask.
   *
   * Set to a
   * [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
   * `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
   * to use.
   * Specify `cluster_secondary_range_name` or `cluster_ipv4_cidr_block`
   * but not both.
   */
  clusterIpv4CidrBlock: string;
  /**
   * Optional. The IP address range of the services IP addresses in this
   * cluster.
   *
   * For Cloud Composer environments in versions composer-1.*.*-airflow-*.*.*,
   * this field is applicable only when `use_ip_aliases` is true.
   *
   * Set to blank to have GKE choose a range with the default size.
   *
   * Set to /netmask (e.g. `/14`) to have GKE choose a range with a specific
   * netmask.
   *
   * Set to a
   * [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
   * `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
   * to use.
   * Specify `services_secondary_range_name` or `services_ipv4_cidr_block`
   * but not both.
   */
  servicesIpv4CidrBlock: string;
}

/**
 * The configuration information for the Kubernetes Engine nodes running
 * the Apache Airflow software.
 */
export interface NodeConfig {
  /**
   * Optional. The Compute Engine [zone](/compute/docs/regions-zones) in which
   * to deploy the VMs used to run the Apache Airflow software, specified as a
   * [relative resource
   * name](/apis/design/resource_names#relative_resource_name). For example:
   * "projects/{projectId}/zones/{zoneId}".
   *
   * This `location` must belong to the enclosing environment's project and
   * location. If both this field and `nodeConfig.machineType` are specified,
   * `nodeConfig.machineType` must belong to this `location`; if both are
   * unspecified, the service will pick a zone in the Compute Engine region
   * corresponding to the Cloud Composer location, and propagate that choice to
   * both fields. If only one field (`location` or `nodeConfig.machineType`) is
   * specified, the location information from the specified field will be
   * propagated to the unspecified field.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-1.*.*-airflow-*.*.*.
   */
  location: string;
  /**
   * Optional. The Compute Engine
   * [machine type](/compute/docs/machine-types) used for cluster instances,
   * specified as a
   * [relative resource
   * name](/apis/design/resource_names#relative_resource_name). For example:
   * "projects/{projectId}/zones/{zoneId}/machineTypes/{machineTypeId}".
   *
   * The `machineType` must belong to the enclosing environment's project and
   * location. If both this field and `nodeConfig.location` are specified,
   * this `machineType` must belong to the `nodeConfig.location`; if both are
   * unspecified, the service will pick a zone in the Compute Engine region
   * corresponding to the Cloud Composer location, and propagate that choice to
   * both fields. If exactly one of this field and `nodeConfig.location` is
   * specified, the location information from the specified field will be
   * propagated to the unspecified field.
   *
   * The `machineTypeId` must not be a [shared-core machine
   * type](/compute/docs/machine-types#sharedcore).
   *
   * If this field is unspecified, the `machineTypeId` defaults
   * to "n1-standard-1".
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-1.*.*-airflow-*.*.*.
   */
  machineType: string;
  /**
   * Optional. The Compute Engine network to be used for machine
   * communications, specified as a
   * [relative resource
   * name](/apis/design/resource_names#relative_resource_name). For example:
   * "projects/{projectId}/global/networks/{networkId}".
   *
   * If unspecified, the default network in the environment's project is used.
   * If a [Custom Subnet Network](/vpc/docs/vpc#vpc_networks_and_subnets)
   * is provided, `nodeConfig.subnetwork` must also be provided. For
   * [Shared VPC](/vpc/docs/shared-vpc) subnetwork requirements, see
   * `nodeConfig.subnetwork`.
   */
  network: string;
  /**
   * Optional. The Compute Engine subnetwork to be used for machine
   * communications, specified as a
   * [relative resource
   * name](/apis/design/resource_names#relative_resource_name). For example:
   * "projects/{projectId}/regions/{regionId}/subnetworks/{subnetworkId}"
   *
   * If a subnetwork is provided, `nodeConfig.network` must also be provided,
   * and the subnetwork must belong to the enclosing environment's project and
   * location.
   */
  subnetwork: string;
  /**
   * Optional. The disk size in GB used for node VMs. Minimum size is 30GB.
   * If unspecified, defaults to 100GB. Cannot be updated.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-1.*.*-airflow-*.*.*.
   */
  diskSizeGb: number;
  /**
   * Optional. The set of Google API scopes to be made available on all
   * node VMs. If `oauth_scopes` is empty, defaults to
   * ["https://www.googleapis.com/auth/cloud-platform"]. Cannot be updated.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-1.*.*-airflow-*.*.*.
   */
  oauthScopes: string[];
  /**
   * Optional. The Google Cloud Platform Service Account to be used by the
   * workloads. If a service account is not specified, the "default" Compute
   * Engine service account is used. Cannot be updated.
   */
  serviceAccount: string;
  /**
   * Optional. The list of instance tags applied to all node VMs. Tags are used
   * to identify valid sources or targets for network firewalls. Each tag within
   * the list must comply with [RFC1035](https://www.ietf.org/rfc/rfc1035.txt).
   * Cannot be updated.
   */
  tags: string[];
  /** Optional. The IPAllocationPolicy fields for the GKE cluster. */
  ipAllocationPolicy:
    | IPAllocationPolicy
    | undefined;
  /**
   * Optional. The maximum number of pods per node in the Cloud Composer GKE
   * cluster. The value must be between 8 and 110 and it can be set only if the
   * environment is VPC-native. The default value is 32. Values of this field
   * will be propagated both to the `default-pool` node pool of the newly
   * created GKE cluster, and to the default "Maximum Pods per Node" value which
   * is used for newly created node pools if their value is not explicitly set
   * during node pool creation. For more information, see [Optimizing IP address
   * allocation]
   * (https://cloud.google.com/kubernetes-engine/docs/how-to/flexible-pod-cidr).
   * Cannot be updated.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-1.*.*-airflow-*.*.*.
   */
  maxPodsPerNode: number;
  /**
   * Optional. Deploys 'ip-masq-agent' daemon set in the GKE cluster and defines
   * nonMasqueradeCIDRs equals to pod IP range so IP masquerading is used for
   * all destination addresses, except between pods traffic.
   *
   * See:
   * https://cloud.google.com/kubernetes-engine/docs/how-to/ip-masquerade-agent
   */
  enableIpMasqAgent: boolean;
  /**
   * Optional. Network Attachment that Cloud Composer environment is connected
   * to, which provides connectivity with a user's VPC network. Takes precedence
   * over network and subnetwork settings. If not provided, but network and
   * subnetwork are defined during environment, it will be provisioned. If not
   * provided and network and subnetwork are also empty, then connectivity to
   * user's VPC network is disabled. Network attachment must be provided in
   * format
   * projects/{project}/regions/{region}/networkAttachments/{networkAttachment}.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  composerNetworkAttachment: string;
  /**
   * Optional. The IP range in CIDR notation to use internally by Cloud
   * Composer. IP addresses are not reserved - and the same range can be used by
   * multiple Cloud Composer environments. In case of overlap, IPs from this
   * range will not be accessible in the user's VPC network. Cannot be updated.
   * If not specified, the default value of '100.64.128.0/20' is used.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  composerInternalIpv4CidrBlock: string;
}

/**
 * Configuration options for the private GKE cluster in a Cloud Composer
 * environment.
 */
export interface PrivateClusterConfig {
  /**
   * Optional. If `true`, access to the public endpoint of the GKE cluster is
   * denied.
   */
  enablePrivateEndpoint: boolean;
  /**
   * Optional. The CIDR block from which IPv4 range for GKE master will be
   * reserved. If left blank, the default value of '172.16.0.0/23' is used.
   */
  masterIpv4CidrBlock: string;
  /**
   * Output only. The IP range in CIDR notation to use for the hosted master
   * network. This range is used for assigning internal IP addresses to the
   * cluster master or set of masters and to the internal load balancer virtual
   * IP. This range must not overlap with any other ranges in use within the
   * cluster's network.
   */
  masterIpv4ReservedRange: string;
}

/**
 * Configuration options for networking connections in the Composer 2
 * environment.
 */
export interface NetworkingConfig {
  /**
   * Optional. Indicates the user requested specifc connection type between
   * Tenant and Customer projects. You cannot set networking connection type in
   * public IP environment.
   */
  connectionType: NetworkingConfig_ConnectionType;
}

/**
 * Represents connection type between Composer environment in Customer
 * Project and the corresponding Tenant project, from a predefined list
 * of available connection modes.
 */
export enum NetworkingConfig_ConnectionType {
  /**
   * CONNECTION_TYPE_UNSPECIFIED - No specific connection type was requested, so the environment uses
   * the default value corresponding to the rest of its configuration.
   */
  CONNECTION_TYPE_UNSPECIFIED = 0,
  /**
   * VPC_PEERING - Requests the use of VPC peerings for connecting the Customer and Tenant
   * projects.
   */
  VPC_PEERING = 1,
  /**
   * PRIVATE_SERVICE_CONNECT - Requests the use of Private Service Connect for connecting the Customer
   * and Tenant projects.
   */
  PRIVATE_SERVICE_CONNECT = 2,
  UNRECOGNIZED = -1,
}

export function networkingConfig_ConnectionTypeFromJSON(object: any): NetworkingConfig_ConnectionType {
  switch (object) {
    case 0:
    case "CONNECTION_TYPE_UNSPECIFIED":
      return NetworkingConfig_ConnectionType.CONNECTION_TYPE_UNSPECIFIED;
    case 1:
    case "VPC_PEERING":
      return NetworkingConfig_ConnectionType.VPC_PEERING;
    case 2:
    case "PRIVATE_SERVICE_CONNECT":
      return NetworkingConfig_ConnectionType.PRIVATE_SERVICE_CONNECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkingConfig_ConnectionType.UNRECOGNIZED;
  }
}

export function networkingConfig_ConnectionTypeToJSON(object: NetworkingConfig_ConnectionType): string {
  switch (object) {
    case NetworkingConfig_ConnectionType.CONNECTION_TYPE_UNSPECIFIED:
      return "CONNECTION_TYPE_UNSPECIFIED";
    case NetworkingConfig_ConnectionType.VPC_PEERING:
      return "VPC_PEERING";
    case NetworkingConfig_ConnectionType.PRIVATE_SERVICE_CONNECT:
      return "PRIVATE_SERVICE_CONNECT";
    case NetworkingConfig_ConnectionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The configuration information for configuring a Private IP Cloud Composer
 * environment.
 */
export interface PrivateEnvironmentConfig {
  /**
   * Optional. If `true`, a Private IP Cloud Composer environment is created.
   * If this field is set to true, `IPAllocationPolicy.use_ip_aliases` must be
   * set to true for Cloud Composer environments in versions
   * composer-1.*.*-airflow-*.*.*.
   */
  enablePrivateEnvironment: boolean;
  /**
   * Optional. If `true`, builds performed during operations that install Python
   * packages have only private connectivity to Google services (including
   * Artifact Registry) and VPC network (if either `NodeConfig.network` and
   * `NodeConfig.subnetwork` fields or `NodeConfig.composer_network_attachment`
   * field are specified). If `false`, the builds also have access to the
   * internet.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  enablePrivateBuildsOnly: boolean;
  /**
   * Optional. Configuration for the private GKE cluster for a Private IP
   * Cloud Composer environment.
   */
  privateClusterConfig:
    | PrivateClusterConfig
    | undefined;
  /**
   * Optional. The CIDR block from which IP range for web server will be
   * reserved. Needs to be disjoint from
   * private_cluster_config.master_ipv4_cidr_block and
   * cloud_sql_ipv4_cidr_block.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-1.*.*-airflow-*.*.*.
   */
  webServerIpv4CidrBlock: string;
  /**
   * Optional. The CIDR block from which IP range in tenant project will be
   * reserved for Cloud SQL. Needs to be disjoint from
   * web_server_ipv4_cidr_block
   */
  cloudSqlIpv4CidrBlock: string;
  /**
   * Output only. The IP range reserved for the tenant project's App Engine VMs.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-1.*.*-airflow-*.*.*.
   */
  webServerIpv4ReservedRange: string;
  /**
   * Optional. The CIDR block from which IP range for Cloud Composer Network in
   * tenant project will be reserved. Needs to be disjoint from
   * private_cluster_config.master_ipv4_cidr_block and
   * cloud_sql_ipv4_cidr_block.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-2.*.*-airflow-*.*.* and newer.
   */
  cloudComposerNetworkIpv4CidrBlock: string;
  /**
   * Output only. The IP range reserved for the tenant project's Cloud Composer
   * network.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-2.*.*-airflow-*.*.* and newer.
   */
  cloudComposerNetworkIpv4ReservedRange: string;
  /**
   * Optional. When enabled, IPs from public (non-RFC1918) ranges can be used
   * for `IPAllocationPolicy.cluster_ipv4_cidr_block` and
   * `IPAllocationPolicy.service_ipv4_cidr_block`.
   */
  enablePrivatelyUsedPublicIps: boolean;
  /**
   * Optional. When specified, the environment will use Private Service Connect
   * instead of VPC peerings to connect to Cloud SQL in the Tenant Project,
   * and the PSC endpoint in the Customer Project will use an IP address from
   * this subnetwork.
   */
  cloudComposerConnectionSubnetwork: string;
  /**
   * Optional. Configuration for the network connections configuration in the
   * environment.
   */
  networkingConfig: NetworkingConfig | undefined;
}

/**
 * The configuration of Cloud SQL instance that is used by the Apache Airflow
 * software.
 */
export interface DatabaseConfig {
  /**
   * Optional. Cloud SQL machine type used by Airflow database.
   * It has to be one of: db-n1-standard-2, db-n1-standard-4, db-n1-standard-8
   * or db-n1-standard-16. If not specified, db-n1-standard-2 will be used.
   * Supported for Cloud Composer environments in versions
   * composer-1.*.*-airflow-*.*.*.
   */
  machineType: string;
  /**
   * Optional. The Compute Engine zone where the Airflow database is created. If
   * zone is provided, it must be in the region selected for the environment. If
   * zone is not provided, a zone is automatically selected. The zone can only
   * be set during environment creation. Supported for Cloud Composer
   * environments in versions composer-2.*.*-airflow-*.*.*.
   */
  zone: string;
}

/**
 * The configuration settings for the Airflow web server App Engine instance.
 * Supported for Cloud Composer environments in versions
 * composer-1.*.*-airflow-*.*.*.
 */
export interface WebServerConfig {
  /**
   * Optional. Machine type on which Airflow web server is running.
   * It has to be one of: composer-n1-webserver-2, composer-n1-webserver-4 or
   * composer-n1-webserver-8.
   * If not specified, composer-n1-webserver-2 will be used.
   * Value custom is returned only in response, if Airflow web server parameters
   * were manually changed to a non-standard values.
   */
  machineType: string;
}

/**
 * The encryption options for the Cloud Composer environment and its
 * dependencies. Supported for Cloud Composer environments in versions
 * composer-1.*.*-airflow-*.*.*.
 */
export interface EncryptionConfig {
  /**
   * Optional. Customer-managed Encryption Key available through Google's Key
   * Management Service. Cannot be updated. If not specified, Google-managed key
   * will be used.
   */
  kmsKeyName: string;
}

/**
 * The configuration settings for Cloud Composer maintenance window.
 * The following example:
 *
 * ```
 *    {
 *      "startTime":"2019-08-01T01:00:00Z"
 *      "endTime":"2019-08-01T07:00:00Z"
 *      "recurrence":"FREQ=WEEKLY;BYDAY=TU,WE"
 *    }
 * ```
 *
 * would define a maintenance window between 01 and 07 hours UTC during
 * each Tuesday and Wednesday.
 */
export interface MaintenanceWindow {
  /** Required. Start time of the first recurrence of the maintenance window. */
  startTime:
    | Date
    | undefined;
  /**
   * Required. Maintenance window end time. It is used only to calculate the
   * duration of the maintenance window. The value for end_time must be in the
   * future, relative to `start_time`.
   */
  endTime:
    | Date
    | undefined;
  /**
   * Required. Maintenance window recurrence. Format is a subset of
   * [RFC-5545](https://tools.ietf.org/html/rfc5545) `RRULE`. The only allowed
   * values for `FREQ` field are `FREQ=DAILY` and `FREQ=WEEKLY;BYDAY=...`
   * Example values: `FREQ=WEEKLY;BYDAY=TU,WE`, `FREQ=DAILY`.
   */
  recurrence: string;
}

/**
 * The Kubernetes workloads configuration for GKE cluster associated with the
 * Cloud Composer environment. Supported for Cloud Composer environments in
 * versions composer-2.*.*-airflow-*.*.* and newer.
 */
export interface WorkloadsConfig {
  /** Optional. Resources used by Airflow schedulers. */
  scheduler:
    | WorkloadsConfig_SchedulerResource
    | undefined;
  /** Optional. Resources used by Airflow web server. */
  webServer:
    | WorkloadsConfig_WebServerResource
    | undefined;
  /** Optional. Resources used by Airflow workers. */
  worker:
    | WorkloadsConfig_WorkerResource
    | undefined;
  /** Optional. Resources used by Airflow triggerers. */
  triggerer:
    | WorkloadsConfig_TriggererResource
    | undefined;
  /**
   * Optional. Resources used by Airflow DAG processors.
   *
   * This field is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  dagProcessor: WorkloadsConfig_DagProcessorResource | undefined;
}

/** Configuration for resources used by Airflow schedulers. */
export interface WorkloadsConfig_SchedulerResource {
  /** Optional. CPU request and limit for a single Airflow scheduler replica. */
  cpu: number;
  /**
   * Optional. Memory (GB) request and limit for a single Airflow scheduler
   * replica.
   */
  memoryGb: number;
  /**
   * Optional. Storage (GB) request and limit for a single Airflow scheduler
   * replica.
   */
  storageGb: number;
  /** Optional. The number of schedulers. */
  count: number;
}

/** Configuration for resources used by Airflow web server. */
export interface WorkloadsConfig_WebServerResource {
  /** Optional. CPU request and limit for Airflow web server. */
  cpu: number;
  /** Optional. Memory (GB) request and limit for Airflow web server. */
  memoryGb: number;
  /** Optional. Storage (GB) request and limit for Airflow web server. */
  storageGb: number;
}

/** Configuration for resources used by Airflow workers. */
export interface WorkloadsConfig_WorkerResource {
  /** Optional. CPU request and limit for a single Airflow worker replica. */
  cpu: number;
  /**
   * Optional. Memory (GB) request and limit for a single Airflow worker
   * replica.
   */
  memoryGb: number;
  /**
   * Optional. Storage (GB) request and limit for a single Airflow worker
   * replica.
   */
  storageGb: number;
  /** Optional. Minimum number of workers for autoscaling. */
  minCount: number;
  /** Optional. Maximum number of workers for autoscaling. */
  maxCount: number;
}

/** Configuration for resources used by Airflow triggerers. */
export interface WorkloadsConfig_TriggererResource {
  /** Optional. The number of triggerers. */
  count: number;
  /** Optional. CPU request and limit for a single Airflow triggerer replica. */
  cpu: number;
  /**
   * Optional. Memory (GB) request and limit for a single Airflow triggerer
   * replica.
   */
  memoryGb: number;
}

/**
 * Configuration for resources used by Airflow DAG processors.
 *
 * This field is supported for Cloud Composer environments in versions
 * composer-3.*.*-airflow-*.*.* and newer.
 */
export interface WorkloadsConfig_DagProcessorResource {
  /**
   * Optional. CPU request and limit for a single Airflow DAG processor
   * replica.
   */
  cpu: number;
  /**
   * Optional. Memory (GB) request and limit for a single Airflow DAG
   * processor replica.
   */
  memoryGb: number;
  /**
   * Optional. Storage (GB) request and limit for a single Airflow DAG
   * processor replica.
   */
  storageGb: number;
  /**
   * Optional. The number of DAG processors. If not provided or set to 0, a
   * single DAG processor instance will be created.
   */
  count: number;
}

/** The configuration setting for Airflow database data retention mechanism. */
export interface DataRetentionConfig {
  /**
   * Optional. The number of days describing for how long to store event-based
   * records in airflow database. If the retention mechanism is enabled this
   * value must be a positive integer otherwise, value should be set to 0.
   *
   * @deprecated
   */
  airflowDatabaseRetentionDays: number;
  /** Optional. The configuration settings for task logs retention */
  taskLogsRetentionConfig:
    | TaskLogsRetentionConfig
    | undefined;
  /** Optional. The retention policy for airflow metadata database. */
  airflowMetadataRetentionConfig: AirflowMetadataRetentionPolicyConfig | undefined;
}

/** The configuration setting for Task Logs. */
export interface TaskLogsRetentionConfig {
  /** Optional. The mode of storage for Airflow workers task logs. */
  storageMode: TaskLogsRetentionConfig_TaskLogsStorageMode;
}

/** The definition of task_logs_storage_mode. */
export enum TaskLogsRetentionConfig_TaskLogsStorageMode {
  /** TASK_LOGS_STORAGE_MODE_UNSPECIFIED - This configuration is not specified by the user. */
  TASK_LOGS_STORAGE_MODE_UNSPECIFIED = 0,
  /**
   * CLOUD_LOGGING_AND_CLOUD_STORAGE - Store task logs in Cloud Logging and in the environment's Cloud Storage
   * bucket.
   */
  CLOUD_LOGGING_AND_CLOUD_STORAGE = 1,
  /** CLOUD_LOGGING_ONLY - Store task logs in Cloud Logging only. */
  CLOUD_LOGGING_ONLY = 2,
  UNRECOGNIZED = -1,
}

export function taskLogsRetentionConfig_TaskLogsStorageModeFromJSON(
  object: any,
): TaskLogsRetentionConfig_TaskLogsStorageMode {
  switch (object) {
    case 0:
    case "TASK_LOGS_STORAGE_MODE_UNSPECIFIED":
      return TaskLogsRetentionConfig_TaskLogsStorageMode.TASK_LOGS_STORAGE_MODE_UNSPECIFIED;
    case 1:
    case "CLOUD_LOGGING_AND_CLOUD_STORAGE":
      return TaskLogsRetentionConfig_TaskLogsStorageMode.CLOUD_LOGGING_AND_CLOUD_STORAGE;
    case 2:
    case "CLOUD_LOGGING_ONLY":
      return TaskLogsRetentionConfig_TaskLogsStorageMode.CLOUD_LOGGING_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskLogsRetentionConfig_TaskLogsStorageMode.UNRECOGNIZED;
  }
}

export function taskLogsRetentionConfig_TaskLogsStorageModeToJSON(
  object: TaskLogsRetentionConfig_TaskLogsStorageMode,
): string {
  switch (object) {
    case TaskLogsRetentionConfig_TaskLogsStorageMode.TASK_LOGS_STORAGE_MODE_UNSPECIFIED:
      return "TASK_LOGS_STORAGE_MODE_UNSPECIFIED";
    case TaskLogsRetentionConfig_TaskLogsStorageMode.CLOUD_LOGGING_AND_CLOUD_STORAGE:
      return "CLOUD_LOGGING_AND_CLOUD_STORAGE";
    case TaskLogsRetentionConfig_TaskLogsStorageMode.CLOUD_LOGGING_ONLY:
      return "CLOUD_LOGGING_ONLY";
    case TaskLogsRetentionConfig_TaskLogsStorageMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The policy for airflow metadata database retention. */
export interface AirflowMetadataRetentionPolicyConfig {
  /** Optional. Retention can be either enabled or disabled. */
  retentionMode: AirflowMetadataRetentionPolicyConfig_RetentionMode;
  /** Optional. How many days data should be retained for. */
  retentionDays: number;
}

/** Describes retention policy. */
export enum AirflowMetadataRetentionPolicyConfig_RetentionMode {
  /** RETENTION_MODE_UNSPECIFIED - Default mode doesn't change environment parameters. */
  RETENTION_MODE_UNSPECIFIED = 0,
  /** RETENTION_MODE_ENABLED - Retention policy is enabled. */
  RETENTION_MODE_ENABLED = 1,
  /** RETENTION_MODE_DISABLED - Retention policy is disabled. */
  RETENTION_MODE_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function airflowMetadataRetentionPolicyConfig_RetentionModeFromJSON(
  object: any,
): AirflowMetadataRetentionPolicyConfig_RetentionMode {
  switch (object) {
    case 0:
    case "RETENTION_MODE_UNSPECIFIED":
      return AirflowMetadataRetentionPolicyConfig_RetentionMode.RETENTION_MODE_UNSPECIFIED;
    case 1:
    case "RETENTION_MODE_ENABLED":
      return AirflowMetadataRetentionPolicyConfig_RetentionMode.RETENTION_MODE_ENABLED;
    case 2:
    case "RETENTION_MODE_DISABLED":
      return AirflowMetadataRetentionPolicyConfig_RetentionMode.RETENTION_MODE_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AirflowMetadataRetentionPolicyConfig_RetentionMode.UNRECOGNIZED;
  }
}

export function airflowMetadataRetentionPolicyConfig_RetentionModeToJSON(
  object: AirflowMetadataRetentionPolicyConfig_RetentionMode,
): string {
  switch (object) {
    case AirflowMetadataRetentionPolicyConfig_RetentionMode.RETENTION_MODE_UNSPECIFIED:
      return "RETENTION_MODE_UNSPECIFIED";
    case AirflowMetadataRetentionPolicyConfig_RetentionMode.RETENTION_MODE_ENABLED:
      return "RETENTION_MODE_ENABLED";
    case AirflowMetadataRetentionPolicyConfig_RetentionMode.RETENTION_MODE_DISABLED:
      return "RETENTION_MODE_DISABLED";
    case AirflowMetadataRetentionPolicyConfig_RetentionMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The configuration for data storage in the environment. */
export interface StorageConfig {
  /**
   * Optional. The name of the Cloud Storage bucket used by the environment. No
   * `gs://` prefix.
   */
  bucket: string;
}

/** The Recovery settings of an environment. */
export interface RecoveryConfig {
  /** Optional. The configuration for scheduled snapshot creation mechanism. */
  scheduledSnapshotsConfig: ScheduledSnapshotsConfig | undefined;
}

/** The configuration for scheduled snapshot creation mechanism. */
export interface ScheduledSnapshotsConfig {
  /** Optional. Whether scheduled snapshots creation is enabled. */
  enabled: boolean;
  /**
   * Optional. The Cloud Storage location for storing automatically created
   * snapshots.
   */
  snapshotLocation: string;
  /**
   * Optional. The cron expression representing the time when snapshots creation
   * mechanism runs. This field is subject to additional validation around
   * frequency of execution.
   */
  snapshotCreationSchedule: string;
  /**
   * Optional. Time zone that sets the context to interpret
   * snapshot_creation_schedule.
   */
  timeZone: string;
}

/**
 * Configuration options for the master authorized networks feature. Enabled
 * master authorized networks will disallow all external traffic to access
 * Kubernetes master through HTTPS except traffic from the given CIDR blocks,
 * Google Compute Engine Public IPs and Google Prod IPs.
 */
export interface MasterAuthorizedNetworksConfig {
  /** Whether or not master authorized networks feature is enabled. */
  enabled: boolean;
  /**
   * Up to 50 external networks that could access Kubernetes master through
   * HTTPS.
   */
  cidrBlocks: MasterAuthorizedNetworksConfig_CidrBlock[];
}

/** CIDR block with an optional name. */
export interface MasterAuthorizedNetworksConfig_CidrBlock {
  /** User-defined name that identifies the CIDR block. */
  displayName: string;
  /** CIDR block that must be specified in CIDR notation. */
  cidrBlock: string;
}

/** Configuration for Cloud Data Lineage integration. */
export interface CloudDataLineageIntegration {
  /** Optional. Whether or not Cloud Data Lineage integration is enabled. */
  enabled: boolean;
}

/** An environment for running orchestration tasks. */
export interface Environment {
  /**
   * The resource name of the environment, in the form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   *
   * EnvironmentId must start with a lowercase letter followed by up to 63
   * lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
   */
  name: string;
  /** Configuration parameters for this environment. */
  config:
    | EnvironmentConfig
    | undefined;
  /**
   * Output only. The UUID (Universally Unique IDentifier) associated with this
   * environment. This value is generated when the environment is created.
   */
  uuid: string;
  /** The current state of the environment. */
  state: Environment_State;
  /** Output only. The time at which this environment was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which this environment was last modified. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. User-defined labels for this environment.
   * The labels map can contain no more than 64 entries. Entries of the labels
   * map are UTF8 strings that comply with the following restrictions:
   *
   * * Keys must conform to regexp: [\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}
   * * Values must conform to regexp:  [\p{Ll}\p{Lo}\p{N}_-]{0,63}
   * * Both keys and values are additionally constrained to be <= 128 bytes in
   * size.
   */
  labels: { [key: string]: string };
  /** Output only. Reserved for future use. */
  satisfiesPzs: boolean;
  /** Output only. Reserved for future use. */
  satisfiesPzi: boolean;
  /** Optional. Storage configuration for this environment. */
  storageConfig: StorageConfig | undefined;
}

/** State of the environment. */
export enum Environment_State {
  /** STATE_UNSPECIFIED - The state of the environment is unknown. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The environment is in the process of being created. */
  CREATING = 1,
  /** RUNNING - The environment is currently running and healthy. It is ready for use. */
  RUNNING = 2,
  /**
   * UPDATING - The environment is being updated. It remains usable but cannot receive
   * additional update requests or be deleted at this time.
   */
  UPDATING = 3,
  /** DELETING - The environment is undergoing deletion. It cannot be used. */
  DELETING = 4,
  /** ERROR - The environment has encountered an error and cannot be used. */
  ERROR = 5,
  UNRECOGNIZED = -1,
}

export function environment_StateFromJSON(object: any): Environment_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Environment_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Environment_State.CREATING;
    case 2:
    case "RUNNING":
      return Environment_State.RUNNING;
    case 3:
    case "UPDATING":
      return Environment_State.UPDATING;
    case 4:
    case "DELETING":
      return Environment_State.DELETING;
    case 5:
    case "ERROR":
      return Environment_State.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Environment_State.UNRECOGNIZED;
  }
}

export function environment_StateToJSON(object: Environment_State): string {
  switch (object) {
    case Environment_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Environment_State.CREATING:
      return "CREATING";
    case Environment_State.RUNNING:
      return "RUNNING";
    case Environment_State.UPDATING:
      return "UPDATING";
    case Environment_State.DELETING:
      return "DELETING";
    case Environment_State.ERROR:
      return "ERROR";
    case Environment_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Environment_LabelsEntry {
  key: string;
  value: string;
}

/** Request to check whether image upgrade will succeed. */
export interface CheckUpgradeRequest {
  /**
   * The resource name of the environment to check upgrade for, in the
   * form:
   * "projects/{projectId}/locations/{locationId}/environments/{environmentId}"
   */
  environment: string;
  /**
   * The version of the software running in the environment.
   * This encapsulates both the version of Cloud Composer functionality and the
   * version of Apache Airflow. It must match the regular expression
   * `composer-([0-9]+(\.[0-9]+\.[0-9]+(-preview\.[0-9]+)?)?|latest)-airflow-([0-9]+(\.[0-9]+(\.[0-9]+)?)?)`.
   * When used as input, the server also checks if the provided version is
   * supported and denies the request for an unsupported version.
   *
   * The Cloud Composer portion of the image version is a full
   * [semantic version](https://semver.org), or an alias in the form of major
   * version number or `latest`. When an alias is provided, the server replaces
   * it with the current Cloud Composer version that satisfies the alias.
   *
   * The Apache Airflow portion of the image version is a full semantic version
   * that points to one of the supported Apache Airflow versions, or an alias in
   * the form of only major or major.minor versions specified. When an alias is
   * provided, the server replaces it with the latest Apache Airflow version
   * that satisfies the alias and is supported in the given Cloud Composer
   * version.
   *
   * In all cases, the resolved image version is stored in the same field.
   *
   * See also [version
   * list](/composer/docs/concepts/versioning/composer-versions) and [versioning
   * overview](/composer/docs/concepts/versioning/composer-versioning-overview).
   */
  imageVersion: string;
}

/**
 * Message containing information about the result of an upgrade check
 * operation.
 */
export interface CheckUpgradeResponse {
  /** Output only. Url for a docker build log of an upgraded image. */
  buildLogUri: string;
  /** Output only. Whether build has succeeded or failed on modules conflicts. */
  containsPypiModulesConflict: CheckUpgradeResponse_ConflictResult;
  /**
   * Output only. Extract from a docker image build log containing information
   * about pypi modules conflicts.
   */
  pypiConflictBuildLogExtract: string;
  /** Composer image for which the build was happening. */
  imageVersion: string;
  /**
   * Pypi dependencies specified in the environment configuration, at the time
   * when the build was triggered.
   */
  pypiDependencies: { [key: string]: string };
}

/** Whether there were python modules conflict during image build. */
export enum CheckUpgradeResponse_ConflictResult {
  /** CONFLICT_RESULT_UNSPECIFIED - It is unknown whether build had conflicts or not. */
  CONFLICT_RESULT_UNSPECIFIED = 0,
  /** CONFLICT - There were python packages conflicts. */
  CONFLICT = 1,
  /** NO_CONFLICT - There were no python packages conflicts. */
  NO_CONFLICT = 2,
  UNRECOGNIZED = -1,
}

export function checkUpgradeResponse_ConflictResultFromJSON(object: any): CheckUpgradeResponse_ConflictResult {
  switch (object) {
    case 0:
    case "CONFLICT_RESULT_UNSPECIFIED":
      return CheckUpgradeResponse_ConflictResult.CONFLICT_RESULT_UNSPECIFIED;
    case 1:
    case "CONFLICT":
      return CheckUpgradeResponse_ConflictResult.CONFLICT;
    case 2:
    case "NO_CONFLICT":
      return CheckUpgradeResponse_ConflictResult.NO_CONFLICT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CheckUpgradeResponse_ConflictResult.UNRECOGNIZED;
  }
}

export function checkUpgradeResponse_ConflictResultToJSON(object: CheckUpgradeResponse_ConflictResult): string {
  switch (object) {
    case CheckUpgradeResponse_ConflictResult.CONFLICT_RESULT_UNSPECIFIED:
      return "CONFLICT_RESULT_UNSPECIFIED";
    case CheckUpgradeResponse_ConflictResult.CONFLICT:
      return "CONFLICT";
    case CheckUpgradeResponse_ConflictResult.NO_CONFLICT:
      return "NO_CONFLICT";
    case CheckUpgradeResponse_ConflictResult.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CheckUpgradeResponse_PypiDependenciesEntry {
  key: string;
  value: string;
}

function createBaseCreateEnvironmentRequest(): CreateEnvironmentRequest {
  return { parent: "", environment: undefined };
}

export const CreateEnvironmentRequest: MessageFns<CreateEnvironmentRequest> = {
  encode(message: CreateEnvironmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.environment !== undefined) {
      Environment.encode(message.environment, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEnvironmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEnvironmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.environment = Environment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEnvironmentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      environment: isSet(object.environment) ? Environment.fromJSON(object.environment) : undefined,
    };
  },

  toJSON(message: CreateEnvironmentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.environment !== undefined) {
      obj.environment = Environment.toJSON(message.environment);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateEnvironmentRequest>): CreateEnvironmentRequest {
    return CreateEnvironmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateEnvironmentRequest>): CreateEnvironmentRequest {
    const message = createBaseCreateEnvironmentRequest();
    message.parent = object.parent ?? "";
    message.environment = (object.environment !== undefined && object.environment !== null)
      ? Environment.fromPartial(object.environment)
      : undefined;
    return message;
  },
};

function createBaseGetEnvironmentRequest(): GetEnvironmentRequest {
  return { name: "" };
}

export const GetEnvironmentRequest: MessageFns<GetEnvironmentRequest> = {
  encode(message: GetEnvironmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEnvironmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEnvironmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEnvironmentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetEnvironmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetEnvironmentRequest>): GetEnvironmentRequest {
    return GetEnvironmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEnvironmentRequest>): GetEnvironmentRequest {
    const message = createBaseGetEnvironmentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListEnvironmentsRequest(): ListEnvironmentsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListEnvironmentsRequest: MessageFns<ListEnvironmentsRequest> = {
  encode(message: ListEnvironmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEnvironmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEnvironmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEnvironmentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListEnvironmentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEnvironmentsRequest>): ListEnvironmentsRequest {
    return ListEnvironmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEnvironmentsRequest>): ListEnvironmentsRequest {
    const message = createBaseListEnvironmentsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListEnvironmentsResponse(): ListEnvironmentsResponse {
  return { environments: [], nextPageToken: "" };
}

export const ListEnvironmentsResponse: MessageFns<ListEnvironmentsResponse> = {
  encode(message: ListEnvironmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.environments) {
      Environment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEnvironmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEnvironmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.environments.push(Environment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEnvironmentsResponse {
    return {
      environments: globalThis.Array.isArray(object?.environments)
        ? object.environments.map((e: any) => Environment.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListEnvironmentsResponse): unknown {
    const obj: any = {};
    if (message.environments?.length) {
      obj.environments = message.environments.map((e) => Environment.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEnvironmentsResponse>): ListEnvironmentsResponse {
    return ListEnvironmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEnvironmentsResponse>): ListEnvironmentsResponse {
    const message = createBaseListEnvironmentsResponse();
    message.environments = object.environments?.map((e) => Environment.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteEnvironmentRequest(): DeleteEnvironmentRequest {
  return { name: "" };
}

export const DeleteEnvironmentRequest: MessageFns<DeleteEnvironmentRequest> = {
  encode(message: DeleteEnvironmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEnvironmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEnvironmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteEnvironmentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteEnvironmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteEnvironmentRequest>): DeleteEnvironmentRequest {
    return DeleteEnvironmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteEnvironmentRequest>): DeleteEnvironmentRequest {
    const message = createBaseDeleteEnvironmentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateEnvironmentRequest(): UpdateEnvironmentRequest {
  return { name: "", environment: undefined, updateMask: undefined };
}

export const UpdateEnvironmentRequest: MessageFns<UpdateEnvironmentRequest> = {
  encode(message: UpdateEnvironmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.environment !== undefined) {
      Environment.encode(message.environment, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEnvironmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEnvironmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.environment = Environment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEnvironmentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      environment: isSet(object.environment) ? Environment.fromJSON(object.environment) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateEnvironmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.environment !== undefined) {
      obj.environment = Environment.toJSON(message.environment);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateEnvironmentRequest>): UpdateEnvironmentRequest {
    return UpdateEnvironmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateEnvironmentRequest>): UpdateEnvironmentRequest {
    const message = createBaseUpdateEnvironmentRequest();
    message.name = object.name ?? "";
    message.environment = (object.environment !== undefined && object.environment !== null)
      ? Environment.fromPartial(object.environment)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseRestartWebServerRequest(): RestartWebServerRequest {
  return { name: "" };
}

export const RestartWebServerRequest: MessageFns<RestartWebServerRequest> = {
  encode(message: RestartWebServerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestartWebServerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestartWebServerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestartWebServerRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: RestartWebServerRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<RestartWebServerRequest>): RestartWebServerRequest {
    return RestartWebServerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RestartWebServerRequest>): RestartWebServerRequest {
    const message = createBaseRestartWebServerRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseExecuteAirflowCommandRequest(): ExecuteAirflowCommandRequest {
  return { environment: "", command: "", subcommand: "", parameters: [] };
}

export const ExecuteAirflowCommandRequest: MessageFns<ExecuteAirflowCommandRequest> = {
  encode(message: ExecuteAirflowCommandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== "") {
      writer.uint32(10).string(message.environment);
    }
    if (message.command !== "") {
      writer.uint32(18).string(message.command);
    }
    if (message.subcommand !== "") {
      writer.uint32(26).string(message.subcommand);
    }
    for (const v of message.parameters) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteAirflowCommandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteAirflowCommandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.environment = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.command = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subcommand = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parameters.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteAirflowCommandRequest {
    return {
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      subcommand: isSet(object.subcommand) ? globalThis.String(object.subcommand) : "",
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ExecuteAirflowCommandRequest): unknown {
    const obj: any = {};
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.subcommand !== "") {
      obj.subcommand = message.subcommand;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteAirflowCommandRequest>): ExecuteAirflowCommandRequest {
    return ExecuteAirflowCommandRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteAirflowCommandRequest>): ExecuteAirflowCommandRequest {
    const message = createBaseExecuteAirflowCommandRequest();
    message.environment = object.environment ?? "";
    message.command = object.command ?? "";
    message.subcommand = object.subcommand ?? "";
    message.parameters = object.parameters?.map((e) => e) || [];
    return message;
  },
};

function createBaseExecuteAirflowCommandResponse(): ExecuteAirflowCommandResponse {
  return { executionId: "", pod: "", podNamespace: "", error: "" };
}

export const ExecuteAirflowCommandResponse: MessageFns<ExecuteAirflowCommandResponse> = {
  encode(message: ExecuteAirflowCommandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.executionId !== "") {
      writer.uint32(10).string(message.executionId);
    }
    if (message.pod !== "") {
      writer.uint32(18).string(message.pod);
    }
    if (message.podNamespace !== "") {
      writer.uint32(26).string(message.podNamespace);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteAirflowCommandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteAirflowCommandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pod = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.podNamespace = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteAirflowCommandResponse {
    return {
      executionId: isSet(object.executionId) ? globalThis.String(object.executionId) : "",
      pod: isSet(object.pod) ? globalThis.String(object.pod) : "",
      podNamespace: isSet(object.podNamespace) ? globalThis.String(object.podNamespace) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ExecuteAirflowCommandResponse): unknown {
    const obj: any = {};
    if (message.executionId !== "") {
      obj.executionId = message.executionId;
    }
    if (message.pod !== "") {
      obj.pod = message.pod;
    }
    if (message.podNamespace !== "") {
      obj.podNamespace = message.podNamespace;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteAirflowCommandResponse>): ExecuteAirflowCommandResponse {
    return ExecuteAirflowCommandResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteAirflowCommandResponse>): ExecuteAirflowCommandResponse {
    const message = createBaseExecuteAirflowCommandResponse();
    message.executionId = object.executionId ?? "";
    message.pod = object.pod ?? "";
    message.podNamespace = object.podNamespace ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseStopAirflowCommandRequest(): StopAirflowCommandRequest {
  return { environment: "", executionId: "", pod: "", podNamespace: "", force: false };
}

export const StopAirflowCommandRequest: MessageFns<StopAirflowCommandRequest> = {
  encode(message: StopAirflowCommandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== "") {
      writer.uint32(10).string(message.environment);
    }
    if (message.executionId !== "") {
      writer.uint32(18).string(message.executionId);
    }
    if (message.pod !== "") {
      writer.uint32(26).string(message.pod);
    }
    if (message.podNamespace !== "") {
      writer.uint32(34).string(message.podNamespace);
    }
    if (message.force !== false) {
      writer.uint32(40).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopAirflowCommandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopAirflowCommandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.environment = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.executionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pod = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.podNamespace = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopAirflowCommandRequest {
    return {
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      executionId: isSet(object.executionId) ? globalThis.String(object.executionId) : "",
      pod: isSet(object.pod) ? globalThis.String(object.pod) : "",
      podNamespace: isSet(object.podNamespace) ? globalThis.String(object.podNamespace) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: StopAirflowCommandRequest): unknown {
    const obj: any = {};
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.executionId !== "") {
      obj.executionId = message.executionId;
    }
    if (message.pod !== "") {
      obj.pod = message.pod;
    }
    if (message.podNamespace !== "") {
      obj.podNamespace = message.podNamespace;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<StopAirflowCommandRequest>): StopAirflowCommandRequest {
    return StopAirflowCommandRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopAirflowCommandRequest>): StopAirflowCommandRequest {
    const message = createBaseStopAirflowCommandRequest();
    message.environment = object.environment ?? "";
    message.executionId = object.executionId ?? "";
    message.pod = object.pod ?? "";
    message.podNamespace = object.podNamespace ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseStopAirflowCommandResponse(): StopAirflowCommandResponse {
  return { isDone: false, output: [] };
}

export const StopAirflowCommandResponse: MessageFns<StopAirflowCommandResponse> = {
  encode(message: StopAirflowCommandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isDone !== false) {
      writer.uint32(8).bool(message.isDone);
    }
    for (const v of message.output) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopAirflowCommandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopAirflowCommandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isDone = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.output.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopAirflowCommandResponse {
    return {
      isDone: isSet(object.isDone) ? globalThis.Boolean(object.isDone) : false,
      output: globalThis.Array.isArray(object?.output) ? object.output.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: StopAirflowCommandResponse): unknown {
    const obj: any = {};
    if (message.isDone !== false) {
      obj.isDone = message.isDone;
    }
    if (message.output?.length) {
      obj.output = message.output;
    }
    return obj;
  },

  create(base?: DeepPartial<StopAirflowCommandResponse>): StopAirflowCommandResponse {
    return StopAirflowCommandResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopAirflowCommandResponse>): StopAirflowCommandResponse {
    const message = createBaseStopAirflowCommandResponse();
    message.isDone = object.isDone ?? false;
    message.output = object.output?.map((e) => e) || [];
    return message;
  },
};

function createBasePollAirflowCommandRequest(): PollAirflowCommandRequest {
  return { environment: "", executionId: "", pod: "", podNamespace: "", nextLineNumber: 0 };
}

export const PollAirflowCommandRequest: MessageFns<PollAirflowCommandRequest> = {
  encode(message: PollAirflowCommandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== "") {
      writer.uint32(10).string(message.environment);
    }
    if (message.executionId !== "") {
      writer.uint32(18).string(message.executionId);
    }
    if (message.pod !== "") {
      writer.uint32(26).string(message.pod);
    }
    if (message.podNamespace !== "") {
      writer.uint32(34).string(message.podNamespace);
    }
    if (message.nextLineNumber !== 0) {
      writer.uint32(40).int32(message.nextLineNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollAirflowCommandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollAirflowCommandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.environment = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.executionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pod = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.podNamespace = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.nextLineNumber = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PollAirflowCommandRequest {
    return {
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      executionId: isSet(object.executionId) ? globalThis.String(object.executionId) : "",
      pod: isSet(object.pod) ? globalThis.String(object.pod) : "",
      podNamespace: isSet(object.podNamespace) ? globalThis.String(object.podNamespace) : "",
      nextLineNumber: isSet(object.nextLineNumber) ? globalThis.Number(object.nextLineNumber) : 0,
    };
  },

  toJSON(message: PollAirflowCommandRequest): unknown {
    const obj: any = {};
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.executionId !== "") {
      obj.executionId = message.executionId;
    }
    if (message.pod !== "") {
      obj.pod = message.pod;
    }
    if (message.podNamespace !== "") {
      obj.podNamespace = message.podNamespace;
    }
    if (message.nextLineNumber !== 0) {
      obj.nextLineNumber = Math.round(message.nextLineNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<PollAirflowCommandRequest>): PollAirflowCommandRequest {
    return PollAirflowCommandRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PollAirflowCommandRequest>): PollAirflowCommandRequest {
    const message = createBasePollAirflowCommandRequest();
    message.environment = object.environment ?? "";
    message.executionId = object.executionId ?? "";
    message.pod = object.pod ?? "";
    message.podNamespace = object.podNamespace ?? "";
    message.nextLineNumber = object.nextLineNumber ?? 0;
    return message;
  },
};

function createBasePollAirflowCommandResponse(): PollAirflowCommandResponse {
  return { output: [], outputEnd: false, exitInfo: undefined };
}

export const PollAirflowCommandResponse: MessageFns<PollAirflowCommandResponse> = {
  encode(message: PollAirflowCommandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.output) {
      PollAirflowCommandResponse_Line.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.outputEnd !== false) {
      writer.uint32(16).bool(message.outputEnd);
    }
    if (message.exitInfo !== undefined) {
      PollAirflowCommandResponse_ExitInfo.encode(message.exitInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollAirflowCommandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollAirflowCommandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.output.push(PollAirflowCommandResponse_Line.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.outputEnd = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.exitInfo = PollAirflowCommandResponse_ExitInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PollAirflowCommandResponse {
    return {
      output: globalThis.Array.isArray(object?.output)
        ? object.output.map((e: any) => PollAirflowCommandResponse_Line.fromJSON(e))
        : [],
      outputEnd: isSet(object.outputEnd) ? globalThis.Boolean(object.outputEnd) : false,
      exitInfo: isSet(object.exitInfo) ? PollAirflowCommandResponse_ExitInfo.fromJSON(object.exitInfo) : undefined,
    };
  },

  toJSON(message: PollAirflowCommandResponse): unknown {
    const obj: any = {};
    if (message.output?.length) {
      obj.output = message.output.map((e) => PollAirflowCommandResponse_Line.toJSON(e));
    }
    if (message.outputEnd !== false) {
      obj.outputEnd = message.outputEnd;
    }
    if (message.exitInfo !== undefined) {
      obj.exitInfo = PollAirflowCommandResponse_ExitInfo.toJSON(message.exitInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<PollAirflowCommandResponse>): PollAirflowCommandResponse {
    return PollAirflowCommandResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PollAirflowCommandResponse>): PollAirflowCommandResponse {
    const message = createBasePollAirflowCommandResponse();
    message.output = object.output?.map((e) => PollAirflowCommandResponse_Line.fromPartial(e)) || [];
    message.outputEnd = object.outputEnd ?? false;
    message.exitInfo = (object.exitInfo !== undefined && object.exitInfo !== null)
      ? PollAirflowCommandResponse_ExitInfo.fromPartial(object.exitInfo)
      : undefined;
    return message;
  },
};

function createBasePollAirflowCommandResponse_Line(): PollAirflowCommandResponse_Line {
  return { lineNumber: 0, content: "" };
}

export const PollAirflowCommandResponse_Line: MessageFns<PollAirflowCommandResponse_Line> = {
  encode(message: PollAirflowCommandResponse_Line, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lineNumber !== 0) {
      writer.uint32(8).int32(message.lineNumber);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollAirflowCommandResponse_Line {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollAirflowCommandResponse_Line();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lineNumber = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PollAirflowCommandResponse_Line {
    return {
      lineNumber: isSet(object.lineNumber) ? globalThis.Number(object.lineNumber) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: PollAirflowCommandResponse_Line): unknown {
    const obj: any = {};
    if (message.lineNumber !== 0) {
      obj.lineNumber = Math.round(message.lineNumber);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<PollAirflowCommandResponse_Line>): PollAirflowCommandResponse_Line {
    return PollAirflowCommandResponse_Line.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PollAirflowCommandResponse_Line>): PollAirflowCommandResponse_Line {
    const message = createBasePollAirflowCommandResponse_Line();
    message.lineNumber = object.lineNumber ?? 0;
    message.content = object.content ?? "";
    return message;
  },
};

function createBasePollAirflowCommandResponse_ExitInfo(): PollAirflowCommandResponse_ExitInfo {
  return { exitCode: 0, error: "" };
}

export const PollAirflowCommandResponse_ExitInfo: MessageFns<PollAirflowCommandResponse_ExitInfo> = {
  encode(message: PollAirflowCommandResponse_ExitInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exitCode !== 0) {
      writer.uint32(8).int32(message.exitCode);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollAirflowCommandResponse_ExitInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollAirflowCommandResponse_ExitInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PollAirflowCommandResponse_ExitInfo {
    return {
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: PollAirflowCommandResponse_ExitInfo): unknown {
    const obj: any = {};
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<PollAirflowCommandResponse_ExitInfo>): PollAirflowCommandResponse_ExitInfo {
    return PollAirflowCommandResponse_ExitInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PollAirflowCommandResponse_ExitInfo>): PollAirflowCommandResponse_ExitInfo {
    const message = createBasePollAirflowCommandResponse_ExitInfo();
    message.exitCode = object.exitCode ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCreateUserWorkloadsSecretRequest(): CreateUserWorkloadsSecretRequest {
  return { parent: "", userWorkloadsSecret: undefined };
}

export const CreateUserWorkloadsSecretRequest: MessageFns<CreateUserWorkloadsSecretRequest> = {
  encode(message: CreateUserWorkloadsSecretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.userWorkloadsSecret !== undefined) {
      UserWorkloadsSecret.encode(message.userWorkloadsSecret, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserWorkloadsSecretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserWorkloadsSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userWorkloadsSecret = UserWorkloadsSecret.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserWorkloadsSecretRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      userWorkloadsSecret: isSet(object.userWorkloadsSecret)
        ? UserWorkloadsSecret.fromJSON(object.userWorkloadsSecret)
        : undefined,
    };
  },

  toJSON(message: CreateUserWorkloadsSecretRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.userWorkloadsSecret !== undefined) {
      obj.userWorkloadsSecret = UserWorkloadsSecret.toJSON(message.userWorkloadsSecret);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateUserWorkloadsSecretRequest>): CreateUserWorkloadsSecretRequest {
    return CreateUserWorkloadsSecretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateUserWorkloadsSecretRequest>): CreateUserWorkloadsSecretRequest {
    const message = createBaseCreateUserWorkloadsSecretRequest();
    message.parent = object.parent ?? "";
    message.userWorkloadsSecret = (object.userWorkloadsSecret !== undefined && object.userWorkloadsSecret !== null)
      ? UserWorkloadsSecret.fromPartial(object.userWorkloadsSecret)
      : undefined;
    return message;
  },
};

function createBaseGetUserWorkloadsSecretRequest(): GetUserWorkloadsSecretRequest {
  return { name: "" };
}

export const GetUserWorkloadsSecretRequest: MessageFns<GetUserWorkloadsSecretRequest> = {
  encode(message: GetUserWorkloadsSecretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserWorkloadsSecretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserWorkloadsSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserWorkloadsSecretRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetUserWorkloadsSecretRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserWorkloadsSecretRequest>): GetUserWorkloadsSecretRequest {
    return GetUserWorkloadsSecretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserWorkloadsSecretRequest>): GetUserWorkloadsSecretRequest {
    const message = createBaseGetUserWorkloadsSecretRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListUserWorkloadsSecretsRequest(): ListUserWorkloadsSecretsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListUserWorkloadsSecretsRequest: MessageFns<ListUserWorkloadsSecretsRequest> = {
  encode(message: ListUserWorkloadsSecretsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserWorkloadsSecretsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserWorkloadsSecretsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserWorkloadsSecretsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListUserWorkloadsSecretsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUserWorkloadsSecretsRequest>): ListUserWorkloadsSecretsRequest {
    return ListUserWorkloadsSecretsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUserWorkloadsSecretsRequest>): ListUserWorkloadsSecretsRequest {
    const message = createBaseListUserWorkloadsSecretsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseUpdateUserWorkloadsSecretRequest(): UpdateUserWorkloadsSecretRequest {
  return { userWorkloadsSecret: undefined };
}

export const UpdateUserWorkloadsSecretRequest: MessageFns<UpdateUserWorkloadsSecretRequest> = {
  encode(message: UpdateUserWorkloadsSecretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userWorkloadsSecret !== undefined) {
      UserWorkloadsSecret.encode(message.userWorkloadsSecret, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserWorkloadsSecretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserWorkloadsSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userWorkloadsSecret = UserWorkloadsSecret.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserWorkloadsSecretRequest {
    return {
      userWorkloadsSecret: isSet(object.userWorkloadsSecret)
        ? UserWorkloadsSecret.fromJSON(object.userWorkloadsSecret)
        : undefined,
    };
  },

  toJSON(message: UpdateUserWorkloadsSecretRequest): unknown {
    const obj: any = {};
    if (message.userWorkloadsSecret !== undefined) {
      obj.userWorkloadsSecret = UserWorkloadsSecret.toJSON(message.userWorkloadsSecret);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateUserWorkloadsSecretRequest>): UpdateUserWorkloadsSecretRequest {
    return UpdateUserWorkloadsSecretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateUserWorkloadsSecretRequest>): UpdateUserWorkloadsSecretRequest {
    const message = createBaseUpdateUserWorkloadsSecretRequest();
    message.userWorkloadsSecret = (object.userWorkloadsSecret !== undefined && object.userWorkloadsSecret !== null)
      ? UserWorkloadsSecret.fromPartial(object.userWorkloadsSecret)
      : undefined;
    return message;
  },
};

function createBaseDeleteUserWorkloadsSecretRequest(): DeleteUserWorkloadsSecretRequest {
  return { name: "" };
}

export const DeleteUserWorkloadsSecretRequest: MessageFns<DeleteUserWorkloadsSecretRequest> = {
  encode(message: DeleteUserWorkloadsSecretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserWorkloadsSecretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserWorkloadsSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserWorkloadsSecretRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteUserWorkloadsSecretRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteUserWorkloadsSecretRequest>): DeleteUserWorkloadsSecretRequest {
    return DeleteUserWorkloadsSecretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteUserWorkloadsSecretRequest>): DeleteUserWorkloadsSecretRequest {
    const message = createBaseDeleteUserWorkloadsSecretRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateUserWorkloadsConfigMapRequest(): CreateUserWorkloadsConfigMapRequest {
  return { parent: "", userWorkloadsConfigMap: undefined };
}

export const CreateUserWorkloadsConfigMapRequest: MessageFns<CreateUserWorkloadsConfigMapRequest> = {
  encode(message: CreateUserWorkloadsConfigMapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.userWorkloadsConfigMap !== undefined) {
      UserWorkloadsConfigMap.encode(message.userWorkloadsConfigMap, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserWorkloadsConfigMapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserWorkloadsConfigMapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userWorkloadsConfigMap = UserWorkloadsConfigMap.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserWorkloadsConfigMapRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      userWorkloadsConfigMap: isSet(object.userWorkloadsConfigMap)
        ? UserWorkloadsConfigMap.fromJSON(object.userWorkloadsConfigMap)
        : undefined,
    };
  },

  toJSON(message: CreateUserWorkloadsConfigMapRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.userWorkloadsConfigMap !== undefined) {
      obj.userWorkloadsConfigMap = UserWorkloadsConfigMap.toJSON(message.userWorkloadsConfigMap);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateUserWorkloadsConfigMapRequest>): CreateUserWorkloadsConfigMapRequest {
    return CreateUserWorkloadsConfigMapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateUserWorkloadsConfigMapRequest>): CreateUserWorkloadsConfigMapRequest {
    const message = createBaseCreateUserWorkloadsConfigMapRequest();
    message.parent = object.parent ?? "";
    message.userWorkloadsConfigMap =
      (object.userWorkloadsConfigMap !== undefined && object.userWorkloadsConfigMap !== null)
        ? UserWorkloadsConfigMap.fromPartial(object.userWorkloadsConfigMap)
        : undefined;
    return message;
  },
};

function createBaseGetUserWorkloadsConfigMapRequest(): GetUserWorkloadsConfigMapRequest {
  return { name: "" };
}

export const GetUserWorkloadsConfigMapRequest: MessageFns<GetUserWorkloadsConfigMapRequest> = {
  encode(message: GetUserWorkloadsConfigMapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserWorkloadsConfigMapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserWorkloadsConfigMapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserWorkloadsConfigMapRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetUserWorkloadsConfigMapRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetUserWorkloadsConfigMapRequest>): GetUserWorkloadsConfigMapRequest {
    return GetUserWorkloadsConfigMapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserWorkloadsConfigMapRequest>): GetUserWorkloadsConfigMapRequest {
    const message = createBaseGetUserWorkloadsConfigMapRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListUserWorkloadsConfigMapsRequest(): ListUserWorkloadsConfigMapsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListUserWorkloadsConfigMapsRequest: MessageFns<ListUserWorkloadsConfigMapsRequest> = {
  encode(message: ListUserWorkloadsConfigMapsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserWorkloadsConfigMapsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserWorkloadsConfigMapsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserWorkloadsConfigMapsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListUserWorkloadsConfigMapsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUserWorkloadsConfigMapsRequest>): ListUserWorkloadsConfigMapsRequest {
    return ListUserWorkloadsConfigMapsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUserWorkloadsConfigMapsRequest>): ListUserWorkloadsConfigMapsRequest {
    const message = createBaseListUserWorkloadsConfigMapsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseUpdateUserWorkloadsConfigMapRequest(): UpdateUserWorkloadsConfigMapRequest {
  return { userWorkloadsConfigMap: undefined };
}

export const UpdateUserWorkloadsConfigMapRequest: MessageFns<UpdateUserWorkloadsConfigMapRequest> = {
  encode(message: UpdateUserWorkloadsConfigMapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userWorkloadsConfigMap !== undefined) {
      UserWorkloadsConfigMap.encode(message.userWorkloadsConfigMap, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserWorkloadsConfigMapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserWorkloadsConfigMapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userWorkloadsConfigMap = UserWorkloadsConfigMap.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserWorkloadsConfigMapRequest {
    return {
      userWorkloadsConfigMap: isSet(object.userWorkloadsConfigMap)
        ? UserWorkloadsConfigMap.fromJSON(object.userWorkloadsConfigMap)
        : undefined,
    };
  },

  toJSON(message: UpdateUserWorkloadsConfigMapRequest): unknown {
    const obj: any = {};
    if (message.userWorkloadsConfigMap !== undefined) {
      obj.userWorkloadsConfigMap = UserWorkloadsConfigMap.toJSON(message.userWorkloadsConfigMap);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateUserWorkloadsConfigMapRequest>): UpdateUserWorkloadsConfigMapRequest {
    return UpdateUserWorkloadsConfigMapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateUserWorkloadsConfigMapRequest>): UpdateUserWorkloadsConfigMapRequest {
    const message = createBaseUpdateUserWorkloadsConfigMapRequest();
    message.userWorkloadsConfigMap =
      (object.userWorkloadsConfigMap !== undefined && object.userWorkloadsConfigMap !== null)
        ? UserWorkloadsConfigMap.fromPartial(object.userWorkloadsConfigMap)
        : undefined;
    return message;
  },
};

function createBaseDeleteUserWorkloadsConfigMapRequest(): DeleteUserWorkloadsConfigMapRequest {
  return { name: "" };
}

export const DeleteUserWorkloadsConfigMapRequest: MessageFns<DeleteUserWorkloadsConfigMapRequest> = {
  encode(message: DeleteUserWorkloadsConfigMapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserWorkloadsConfigMapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserWorkloadsConfigMapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserWorkloadsConfigMapRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteUserWorkloadsConfigMapRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteUserWorkloadsConfigMapRequest>): DeleteUserWorkloadsConfigMapRequest {
    return DeleteUserWorkloadsConfigMapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteUserWorkloadsConfigMapRequest>): DeleteUserWorkloadsConfigMapRequest {
    const message = createBaseDeleteUserWorkloadsConfigMapRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUserWorkloadsSecret(): UserWorkloadsSecret {
  return { name: "", data: {} };
}

export const UserWorkloadsSecret: MessageFns<UserWorkloadsSecret> = {
  encode(message: UserWorkloadsSecret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.data).forEach(([key, value]) => {
      UserWorkloadsSecret_DataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserWorkloadsSecret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserWorkloadsSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = UserWorkloadsSecret_DataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.data[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserWorkloadsSecret {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      data: isObject(object.data)
        ? Object.entries(object.data).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UserWorkloadsSecret): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<UserWorkloadsSecret>): UserWorkloadsSecret {
    return UserWorkloadsSecret.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserWorkloadsSecret>): UserWorkloadsSecret {
    const message = createBaseUserWorkloadsSecret();
    message.name = object.name ?? "";
    message.data = Object.entries(object.data ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseUserWorkloadsSecret_DataEntry(): UserWorkloadsSecret_DataEntry {
  return { key: "", value: "" };
}

export const UserWorkloadsSecret_DataEntry: MessageFns<UserWorkloadsSecret_DataEntry> = {
  encode(message: UserWorkloadsSecret_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserWorkloadsSecret_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserWorkloadsSecret_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserWorkloadsSecret_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UserWorkloadsSecret_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<UserWorkloadsSecret_DataEntry>): UserWorkloadsSecret_DataEntry {
    return UserWorkloadsSecret_DataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserWorkloadsSecret_DataEntry>): UserWorkloadsSecret_DataEntry {
    const message = createBaseUserWorkloadsSecret_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListUserWorkloadsSecretsResponse(): ListUserWorkloadsSecretsResponse {
  return { userWorkloadsSecrets: [], nextPageToken: "" };
}

export const ListUserWorkloadsSecretsResponse: MessageFns<ListUserWorkloadsSecretsResponse> = {
  encode(message: ListUserWorkloadsSecretsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userWorkloadsSecrets) {
      UserWorkloadsSecret.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserWorkloadsSecretsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserWorkloadsSecretsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userWorkloadsSecrets.push(UserWorkloadsSecret.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserWorkloadsSecretsResponse {
    return {
      userWorkloadsSecrets: globalThis.Array.isArray(object?.userWorkloadsSecrets)
        ? object.userWorkloadsSecrets.map((e: any) => UserWorkloadsSecret.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListUserWorkloadsSecretsResponse): unknown {
    const obj: any = {};
    if (message.userWorkloadsSecrets?.length) {
      obj.userWorkloadsSecrets = message.userWorkloadsSecrets.map((e) => UserWorkloadsSecret.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUserWorkloadsSecretsResponse>): ListUserWorkloadsSecretsResponse {
    return ListUserWorkloadsSecretsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUserWorkloadsSecretsResponse>): ListUserWorkloadsSecretsResponse {
    const message = createBaseListUserWorkloadsSecretsResponse();
    message.userWorkloadsSecrets = object.userWorkloadsSecrets?.map((e) => UserWorkloadsSecret.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUserWorkloadsConfigMap(): UserWorkloadsConfigMap {
  return { name: "", data: {} };
}

export const UserWorkloadsConfigMap: MessageFns<UserWorkloadsConfigMap> = {
  encode(message: UserWorkloadsConfigMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.data).forEach(([key, value]) => {
      UserWorkloadsConfigMap_DataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserWorkloadsConfigMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserWorkloadsConfigMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = UserWorkloadsConfigMap_DataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.data[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserWorkloadsConfigMap {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      data: isObject(object.data)
        ? Object.entries(object.data).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UserWorkloadsConfigMap): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<UserWorkloadsConfigMap>): UserWorkloadsConfigMap {
    return UserWorkloadsConfigMap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserWorkloadsConfigMap>): UserWorkloadsConfigMap {
    const message = createBaseUserWorkloadsConfigMap();
    message.name = object.name ?? "";
    message.data = Object.entries(object.data ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseUserWorkloadsConfigMap_DataEntry(): UserWorkloadsConfigMap_DataEntry {
  return { key: "", value: "" };
}

export const UserWorkloadsConfigMap_DataEntry: MessageFns<UserWorkloadsConfigMap_DataEntry> = {
  encode(message: UserWorkloadsConfigMap_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserWorkloadsConfigMap_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserWorkloadsConfigMap_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserWorkloadsConfigMap_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UserWorkloadsConfigMap_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<UserWorkloadsConfigMap_DataEntry>): UserWorkloadsConfigMap_DataEntry {
    return UserWorkloadsConfigMap_DataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserWorkloadsConfigMap_DataEntry>): UserWorkloadsConfigMap_DataEntry {
    const message = createBaseUserWorkloadsConfigMap_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListUserWorkloadsConfigMapsResponse(): ListUserWorkloadsConfigMapsResponse {
  return { userWorkloadsConfigMaps: [], nextPageToken: "" };
}

export const ListUserWorkloadsConfigMapsResponse: MessageFns<ListUserWorkloadsConfigMapsResponse> = {
  encode(message: ListUserWorkloadsConfigMapsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userWorkloadsConfigMaps) {
      UserWorkloadsConfigMap.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserWorkloadsConfigMapsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserWorkloadsConfigMapsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userWorkloadsConfigMaps.push(UserWorkloadsConfigMap.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserWorkloadsConfigMapsResponse {
    return {
      userWorkloadsConfigMaps: globalThis.Array.isArray(object?.userWorkloadsConfigMaps)
        ? object.userWorkloadsConfigMaps.map((e: any) => UserWorkloadsConfigMap.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListUserWorkloadsConfigMapsResponse): unknown {
    const obj: any = {};
    if (message.userWorkloadsConfigMaps?.length) {
      obj.userWorkloadsConfigMaps = message.userWorkloadsConfigMaps.map((e) => UserWorkloadsConfigMap.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUserWorkloadsConfigMapsResponse>): ListUserWorkloadsConfigMapsResponse {
    return ListUserWorkloadsConfigMapsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUserWorkloadsConfigMapsResponse>): ListUserWorkloadsConfigMapsResponse {
    const message = createBaseListUserWorkloadsConfigMapsResponse();
    message.userWorkloadsConfigMaps =
      object.userWorkloadsConfigMaps?.map((e) => UserWorkloadsConfigMap.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListWorkloadsRequest(): ListWorkloadsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListWorkloadsRequest: MessageFns<ListWorkloadsRequest> = {
  encode(message: ListWorkloadsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkloadsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkloadsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkloadsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListWorkloadsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkloadsRequest>): ListWorkloadsRequest {
    return ListWorkloadsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkloadsRequest>): ListWorkloadsRequest {
    const message = createBaseListWorkloadsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListWorkloadsResponse(): ListWorkloadsResponse {
  return { workloads: [], nextPageToken: "" };
}

export const ListWorkloadsResponse: MessageFns<ListWorkloadsResponse> = {
  encode(message: ListWorkloadsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workloads) {
      ListWorkloadsResponse_ComposerWorkload.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkloadsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkloadsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workloads.push(ListWorkloadsResponse_ComposerWorkload.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkloadsResponse {
    return {
      workloads: globalThis.Array.isArray(object?.workloads)
        ? object.workloads.map((e: any) => ListWorkloadsResponse_ComposerWorkload.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListWorkloadsResponse): unknown {
    const obj: any = {};
    if (message.workloads?.length) {
      obj.workloads = message.workloads.map((e) => ListWorkloadsResponse_ComposerWorkload.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkloadsResponse>): ListWorkloadsResponse {
    return ListWorkloadsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkloadsResponse>): ListWorkloadsResponse {
    const message = createBaseListWorkloadsResponse();
    message.workloads = object.workloads?.map((e) => ListWorkloadsResponse_ComposerWorkload.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListWorkloadsResponse_ComposerWorkload(): ListWorkloadsResponse_ComposerWorkload {
  return { name: "", type: 0, status: undefined };
}

export const ListWorkloadsResponse_ComposerWorkload: MessageFns<ListWorkloadsResponse_ComposerWorkload> = {
  encode(message: ListWorkloadsResponse_ComposerWorkload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.status !== undefined) {
      ListWorkloadsResponse_ComposerWorkloadStatus.encode(message.status, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkloadsResponse_ComposerWorkload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkloadsResponse_ComposerWorkload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = ListWorkloadsResponse_ComposerWorkloadStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkloadsResponse_ComposerWorkload {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? listWorkloadsResponse_ComposerWorkloadTypeFromJSON(object.type) : 0,
      status: isSet(object.status) ? ListWorkloadsResponse_ComposerWorkloadStatus.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: ListWorkloadsResponse_ComposerWorkload): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = listWorkloadsResponse_ComposerWorkloadTypeToJSON(message.type);
    }
    if (message.status !== undefined) {
      obj.status = ListWorkloadsResponse_ComposerWorkloadStatus.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkloadsResponse_ComposerWorkload>): ListWorkloadsResponse_ComposerWorkload {
    return ListWorkloadsResponse_ComposerWorkload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkloadsResponse_ComposerWorkload>): ListWorkloadsResponse_ComposerWorkload {
    const message = createBaseListWorkloadsResponse_ComposerWorkload();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.status = (object.status !== undefined && object.status !== null)
      ? ListWorkloadsResponse_ComposerWorkloadStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseListWorkloadsResponse_ComposerWorkloadStatus(): ListWorkloadsResponse_ComposerWorkloadStatus {
  return { state: 0, statusMessage: "", detailedStatusMessage: "" };
}

export const ListWorkloadsResponse_ComposerWorkloadStatus: MessageFns<ListWorkloadsResponse_ComposerWorkloadStatus> = {
  encode(
    message: ListWorkloadsResponse_ComposerWorkloadStatus,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.statusMessage !== "") {
      writer.uint32(18).string(message.statusMessage);
    }
    if (message.detailedStatusMessage !== "") {
      writer.uint32(26).string(message.detailedStatusMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkloadsResponse_ComposerWorkloadStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkloadsResponse_ComposerWorkloadStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.detailedStatusMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkloadsResponse_ComposerWorkloadStatus {
    return {
      state: isSet(object.state) ? listWorkloadsResponse_ComposerWorkloadStateFromJSON(object.state) : 0,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      detailedStatusMessage: isSet(object.detailedStatusMessage) ? globalThis.String(object.detailedStatusMessage) : "",
    };
  },

  toJSON(message: ListWorkloadsResponse_ComposerWorkloadStatus): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = listWorkloadsResponse_ComposerWorkloadStateToJSON(message.state);
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.detailedStatusMessage !== "") {
      obj.detailedStatusMessage = message.detailedStatusMessage;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ListWorkloadsResponse_ComposerWorkloadStatus>,
  ): ListWorkloadsResponse_ComposerWorkloadStatus {
    return ListWorkloadsResponse_ComposerWorkloadStatus.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListWorkloadsResponse_ComposerWorkloadStatus>,
  ): ListWorkloadsResponse_ComposerWorkloadStatus {
    const message = createBaseListWorkloadsResponse_ComposerWorkloadStatus();
    message.state = object.state ?? 0;
    message.statusMessage = object.statusMessage ?? "";
    message.detailedStatusMessage = object.detailedStatusMessage ?? "";
    return message;
  },
};

function createBaseSaveSnapshotRequest(): SaveSnapshotRequest {
  return { environment: "", snapshotLocation: "" };
}

export const SaveSnapshotRequest: MessageFns<SaveSnapshotRequest> = {
  encode(message: SaveSnapshotRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== "") {
      writer.uint32(10).string(message.environment);
    }
    if (message.snapshotLocation !== "") {
      writer.uint32(18).string(message.snapshotLocation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SaveSnapshotRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.environment = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.snapshotLocation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveSnapshotRequest {
    return {
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      snapshotLocation: isSet(object.snapshotLocation) ? globalThis.String(object.snapshotLocation) : "",
    };
  },

  toJSON(message: SaveSnapshotRequest): unknown {
    const obj: any = {};
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.snapshotLocation !== "") {
      obj.snapshotLocation = message.snapshotLocation;
    }
    return obj;
  },

  create(base?: DeepPartial<SaveSnapshotRequest>): SaveSnapshotRequest {
    return SaveSnapshotRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SaveSnapshotRequest>): SaveSnapshotRequest {
    const message = createBaseSaveSnapshotRequest();
    message.environment = object.environment ?? "";
    message.snapshotLocation = object.snapshotLocation ?? "";
    return message;
  },
};

function createBaseSaveSnapshotResponse(): SaveSnapshotResponse {
  return { snapshotPath: "" };
}

export const SaveSnapshotResponse: MessageFns<SaveSnapshotResponse> = {
  encode(message: SaveSnapshotResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.snapshotPath !== "") {
      writer.uint32(10).string(message.snapshotPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SaveSnapshotResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveSnapshotResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.snapshotPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveSnapshotResponse {
    return { snapshotPath: isSet(object.snapshotPath) ? globalThis.String(object.snapshotPath) : "" };
  },

  toJSON(message: SaveSnapshotResponse): unknown {
    const obj: any = {};
    if (message.snapshotPath !== "") {
      obj.snapshotPath = message.snapshotPath;
    }
    return obj;
  },

  create(base?: DeepPartial<SaveSnapshotResponse>): SaveSnapshotResponse {
    return SaveSnapshotResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SaveSnapshotResponse>): SaveSnapshotResponse {
    const message = createBaseSaveSnapshotResponse();
    message.snapshotPath = object.snapshotPath ?? "";
    return message;
  },
};

function createBaseLoadSnapshotRequest(): LoadSnapshotRequest {
  return {
    environment: "",
    snapshotPath: "",
    skipPypiPackagesInstallation: false,
    skipEnvironmentVariablesSetting: false,
    skipAirflowOverridesSetting: false,
    skipGcsDataCopying: false,
  };
}

export const LoadSnapshotRequest: MessageFns<LoadSnapshotRequest> = {
  encode(message: LoadSnapshotRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== "") {
      writer.uint32(10).string(message.environment);
    }
    if (message.snapshotPath !== "") {
      writer.uint32(18).string(message.snapshotPath);
    }
    if (message.skipPypiPackagesInstallation !== false) {
      writer.uint32(24).bool(message.skipPypiPackagesInstallation);
    }
    if (message.skipEnvironmentVariablesSetting !== false) {
      writer.uint32(32).bool(message.skipEnvironmentVariablesSetting);
    }
    if (message.skipAirflowOverridesSetting !== false) {
      writer.uint32(40).bool(message.skipAirflowOverridesSetting);
    }
    if (message.skipGcsDataCopying !== false) {
      writer.uint32(48).bool(message.skipGcsDataCopying);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadSnapshotRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.environment = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.snapshotPath = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.skipPypiPackagesInstallation = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.skipEnvironmentVariablesSetting = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.skipAirflowOverridesSetting = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.skipGcsDataCopying = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadSnapshotRequest {
    return {
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      snapshotPath: isSet(object.snapshotPath) ? globalThis.String(object.snapshotPath) : "",
      skipPypiPackagesInstallation: isSet(object.skipPypiPackagesInstallation)
        ? globalThis.Boolean(object.skipPypiPackagesInstallation)
        : false,
      skipEnvironmentVariablesSetting: isSet(object.skipEnvironmentVariablesSetting)
        ? globalThis.Boolean(object.skipEnvironmentVariablesSetting)
        : false,
      skipAirflowOverridesSetting: isSet(object.skipAirflowOverridesSetting)
        ? globalThis.Boolean(object.skipAirflowOverridesSetting)
        : false,
      skipGcsDataCopying: isSet(object.skipGcsDataCopying) ? globalThis.Boolean(object.skipGcsDataCopying) : false,
    };
  },

  toJSON(message: LoadSnapshotRequest): unknown {
    const obj: any = {};
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.snapshotPath !== "") {
      obj.snapshotPath = message.snapshotPath;
    }
    if (message.skipPypiPackagesInstallation !== false) {
      obj.skipPypiPackagesInstallation = message.skipPypiPackagesInstallation;
    }
    if (message.skipEnvironmentVariablesSetting !== false) {
      obj.skipEnvironmentVariablesSetting = message.skipEnvironmentVariablesSetting;
    }
    if (message.skipAirflowOverridesSetting !== false) {
      obj.skipAirflowOverridesSetting = message.skipAirflowOverridesSetting;
    }
    if (message.skipGcsDataCopying !== false) {
      obj.skipGcsDataCopying = message.skipGcsDataCopying;
    }
    return obj;
  },

  create(base?: DeepPartial<LoadSnapshotRequest>): LoadSnapshotRequest {
    return LoadSnapshotRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoadSnapshotRequest>): LoadSnapshotRequest {
    const message = createBaseLoadSnapshotRequest();
    message.environment = object.environment ?? "";
    message.snapshotPath = object.snapshotPath ?? "";
    message.skipPypiPackagesInstallation = object.skipPypiPackagesInstallation ?? false;
    message.skipEnvironmentVariablesSetting = object.skipEnvironmentVariablesSetting ?? false;
    message.skipAirflowOverridesSetting = object.skipAirflowOverridesSetting ?? false;
    message.skipGcsDataCopying = object.skipGcsDataCopying ?? false;
    return message;
  },
};

function createBaseLoadSnapshotResponse(): LoadSnapshotResponse {
  return {};
}

export const LoadSnapshotResponse: MessageFns<LoadSnapshotResponse> = {
  encode(_: LoadSnapshotResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadSnapshotResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadSnapshotResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LoadSnapshotResponse {
    return {};
  },

  toJSON(_: LoadSnapshotResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<LoadSnapshotResponse>): LoadSnapshotResponse {
    return LoadSnapshotResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<LoadSnapshotResponse>): LoadSnapshotResponse {
    const message = createBaseLoadSnapshotResponse();
    return message;
  },
};

function createBaseDatabaseFailoverRequest(): DatabaseFailoverRequest {
  return { environment: "" };
}

export const DatabaseFailoverRequest: MessageFns<DatabaseFailoverRequest> = {
  encode(message: DatabaseFailoverRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== "") {
      writer.uint32(10).string(message.environment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseFailoverRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseFailoverRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.environment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseFailoverRequest {
    return { environment: isSet(object.environment) ? globalThis.String(object.environment) : "" };
  },

  toJSON(message: DatabaseFailoverRequest): unknown {
    const obj: any = {};
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseFailoverRequest>): DatabaseFailoverRequest {
    return DatabaseFailoverRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseFailoverRequest>): DatabaseFailoverRequest {
    const message = createBaseDatabaseFailoverRequest();
    message.environment = object.environment ?? "";
    return message;
  },
};

function createBaseDatabaseFailoverResponse(): DatabaseFailoverResponse {
  return {};
}

export const DatabaseFailoverResponse: MessageFns<DatabaseFailoverResponse> = {
  encode(_: DatabaseFailoverResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseFailoverResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseFailoverResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DatabaseFailoverResponse {
    return {};
  },

  toJSON(_: DatabaseFailoverResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DatabaseFailoverResponse>): DatabaseFailoverResponse {
    return DatabaseFailoverResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DatabaseFailoverResponse>): DatabaseFailoverResponse {
    const message = createBaseDatabaseFailoverResponse();
    return message;
  },
};

function createBaseFetchDatabasePropertiesRequest(): FetchDatabasePropertiesRequest {
  return { environment: "" };
}

export const FetchDatabasePropertiesRequest: MessageFns<FetchDatabasePropertiesRequest> = {
  encode(message: FetchDatabasePropertiesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== "") {
      writer.uint32(10).string(message.environment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchDatabasePropertiesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchDatabasePropertiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.environment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchDatabasePropertiesRequest {
    return { environment: isSet(object.environment) ? globalThis.String(object.environment) : "" };
  },

  toJSON(message: FetchDatabasePropertiesRequest): unknown {
    const obj: any = {};
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchDatabasePropertiesRequest>): FetchDatabasePropertiesRequest {
    return FetchDatabasePropertiesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchDatabasePropertiesRequest>): FetchDatabasePropertiesRequest {
    const message = createBaseFetchDatabasePropertiesRequest();
    message.environment = object.environment ?? "";
    return message;
  },
};

function createBaseFetchDatabasePropertiesResponse(): FetchDatabasePropertiesResponse {
  return { primaryGceZone: "", secondaryGceZone: "", isFailoverReplicaAvailable: false };
}

export const FetchDatabasePropertiesResponse: MessageFns<FetchDatabasePropertiesResponse> = {
  encode(message: FetchDatabasePropertiesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primaryGceZone !== "") {
      writer.uint32(10).string(message.primaryGceZone);
    }
    if (message.secondaryGceZone !== "") {
      writer.uint32(18).string(message.secondaryGceZone);
    }
    if (message.isFailoverReplicaAvailable !== false) {
      writer.uint32(24).bool(message.isFailoverReplicaAvailable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchDatabasePropertiesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchDatabasePropertiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.primaryGceZone = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.secondaryGceZone = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isFailoverReplicaAvailable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchDatabasePropertiesResponse {
    return {
      primaryGceZone: isSet(object.primaryGceZone) ? globalThis.String(object.primaryGceZone) : "",
      secondaryGceZone: isSet(object.secondaryGceZone) ? globalThis.String(object.secondaryGceZone) : "",
      isFailoverReplicaAvailable: isSet(object.isFailoverReplicaAvailable)
        ? globalThis.Boolean(object.isFailoverReplicaAvailable)
        : false,
    };
  },

  toJSON(message: FetchDatabasePropertiesResponse): unknown {
    const obj: any = {};
    if (message.primaryGceZone !== "") {
      obj.primaryGceZone = message.primaryGceZone;
    }
    if (message.secondaryGceZone !== "") {
      obj.secondaryGceZone = message.secondaryGceZone;
    }
    if (message.isFailoverReplicaAvailable !== false) {
      obj.isFailoverReplicaAvailable = message.isFailoverReplicaAvailable;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchDatabasePropertiesResponse>): FetchDatabasePropertiesResponse {
    return FetchDatabasePropertiesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchDatabasePropertiesResponse>): FetchDatabasePropertiesResponse {
    const message = createBaseFetchDatabasePropertiesResponse();
    message.primaryGceZone = object.primaryGceZone ?? "";
    message.secondaryGceZone = object.secondaryGceZone ?? "";
    message.isFailoverReplicaAvailable = object.isFailoverReplicaAvailable ?? false;
    return message;
  },
};

function createBaseEnvironmentConfig(): EnvironmentConfig {
  return {
    gkeCluster: "",
    dagGcsPrefix: "",
    nodeCount: 0,
    softwareConfig: undefined,
    nodeConfig: undefined,
    privateEnvironmentConfig: undefined,
    webServerNetworkAccessControl: undefined,
    databaseConfig: undefined,
    webServerConfig: undefined,
    airflowUri: "",
    airflowByoidUri: "",
    encryptionConfig: undefined,
    maintenanceWindow: undefined,
    workloadsConfig: undefined,
    environmentSize: 0,
    masterAuthorizedNetworksConfig: undefined,
    recoveryConfig: undefined,
    dataRetentionConfig: undefined,
    resilienceMode: 0,
  };
}

export const EnvironmentConfig: MessageFns<EnvironmentConfig> = {
  encode(message: EnvironmentConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gkeCluster !== "") {
      writer.uint32(10).string(message.gkeCluster);
    }
    if (message.dagGcsPrefix !== "") {
      writer.uint32(18).string(message.dagGcsPrefix);
    }
    if (message.nodeCount !== 0) {
      writer.uint32(24).int32(message.nodeCount);
    }
    if (message.softwareConfig !== undefined) {
      SoftwareConfig.encode(message.softwareConfig, writer.uint32(34).fork()).join();
    }
    if (message.nodeConfig !== undefined) {
      NodeConfig.encode(message.nodeConfig, writer.uint32(42).fork()).join();
    }
    if (message.privateEnvironmentConfig !== undefined) {
      PrivateEnvironmentConfig.encode(message.privateEnvironmentConfig, writer.uint32(58).fork()).join();
    }
    if (message.webServerNetworkAccessControl !== undefined) {
      WebServerNetworkAccessControl.encode(message.webServerNetworkAccessControl, writer.uint32(74).fork()).join();
    }
    if (message.databaseConfig !== undefined) {
      DatabaseConfig.encode(message.databaseConfig, writer.uint32(82).fork()).join();
    }
    if (message.webServerConfig !== undefined) {
      WebServerConfig.encode(message.webServerConfig, writer.uint32(90).fork()).join();
    }
    if (message.airflowUri !== "") {
      writer.uint32(50).string(message.airflowUri);
    }
    if (message.airflowByoidUri !== "") {
      writer.uint32(170).string(message.airflowByoidUri);
    }
    if (message.encryptionConfig !== undefined) {
      EncryptionConfig.encode(message.encryptionConfig, writer.uint32(98).fork()).join();
    }
    if (message.maintenanceWindow !== undefined) {
      MaintenanceWindow.encode(message.maintenanceWindow, writer.uint32(106).fork()).join();
    }
    if (message.workloadsConfig !== undefined) {
      WorkloadsConfig.encode(message.workloadsConfig, writer.uint32(122).fork()).join();
    }
    if (message.environmentSize !== 0) {
      writer.uint32(128).int32(message.environmentSize);
    }
    if (message.masterAuthorizedNetworksConfig !== undefined) {
      MasterAuthorizedNetworksConfig.encode(message.masterAuthorizedNetworksConfig, writer.uint32(138).fork()).join();
    }
    if (message.recoveryConfig !== undefined) {
      RecoveryConfig.encode(message.recoveryConfig, writer.uint32(146).fork()).join();
    }
    if (message.dataRetentionConfig !== undefined) {
      DataRetentionConfig.encode(message.dataRetentionConfig, writer.uint32(154).fork()).join();
    }
    if (message.resilienceMode !== 0) {
      writer.uint32(160).int32(message.resilienceMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvironmentConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gkeCluster = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dagGcsPrefix = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.softwareConfig = SoftwareConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nodeConfig = NodeConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.privateEnvironmentConfig = PrivateEnvironmentConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.webServerNetworkAccessControl = WebServerNetworkAccessControl.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.databaseConfig = DatabaseConfig.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.webServerConfig = WebServerConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.airflowUri = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.airflowByoidUri = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.encryptionConfig = EncryptionConfig.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.maintenanceWindow = MaintenanceWindow.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.workloadsConfig = WorkloadsConfig.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.environmentSize = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.masterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.recoveryConfig = RecoveryConfig.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.dataRetentionConfig = DataRetentionConfig.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.resilienceMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvironmentConfig {
    return {
      gkeCluster: isSet(object.gkeCluster) ? globalThis.String(object.gkeCluster) : "",
      dagGcsPrefix: isSet(object.dagGcsPrefix) ? globalThis.String(object.dagGcsPrefix) : "",
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      softwareConfig: isSet(object.softwareConfig) ? SoftwareConfig.fromJSON(object.softwareConfig) : undefined,
      nodeConfig: isSet(object.nodeConfig) ? NodeConfig.fromJSON(object.nodeConfig) : undefined,
      privateEnvironmentConfig: isSet(object.privateEnvironmentConfig)
        ? PrivateEnvironmentConfig.fromJSON(object.privateEnvironmentConfig)
        : undefined,
      webServerNetworkAccessControl: isSet(object.webServerNetworkAccessControl)
        ? WebServerNetworkAccessControl.fromJSON(object.webServerNetworkAccessControl)
        : undefined,
      databaseConfig: isSet(object.databaseConfig) ? DatabaseConfig.fromJSON(object.databaseConfig) : undefined,
      webServerConfig: isSet(object.webServerConfig) ? WebServerConfig.fromJSON(object.webServerConfig) : undefined,
      airflowUri: isSet(object.airflowUri) ? globalThis.String(object.airflowUri) : "",
      airflowByoidUri: isSet(object.airflowByoidUri) ? globalThis.String(object.airflowByoidUri) : "",
      encryptionConfig: isSet(object.encryptionConfig) ? EncryptionConfig.fromJSON(object.encryptionConfig) : undefined,
      maintenanceWindow: isSet(object.maintenanceWindow)
        ? MaintenanceWindow.fromJSON(object.maintenanceWindow)
        : undefined,
      workloadsConfig: isSet(object.workloadsConfig) ? WorkloadsConfig.fromJSON(object.workloadsConfig) : undefined,
      environmentSize: isSet(object.environmentSize)
        ? environmentConfig_EnvironmentSizeFromJSON(object.environmentSize)
        : 0,
      masterAuthorizedNetworksConfig: isSet(object.masterAuthorizedNetworksConfig)
        ? MasterAuthorizedNetworksConfig.fromJSON(object.masterAuthorizedNetworksConfig)
        : undefined,
      recoveryConfig: isSet(object.recoveryConfig) ? RecoveryConfig.fromJSON(object.recoveryConfig) : undefined,
      dataRetentionConfig: isSet(object.dataRetentionConfig)
        ? DataRetentionConfig.fromJSON(object.dataRetentionConfig)
        : undefined,
      resilienceMode: isSet(object.resilienceMode)
        ? environmentConfig_ResilienceModeFromJSON(object.resilienceMode)
        : 0,
    };
  },

  toJSON(message: EnvironmentConfig): unknown {
    const obj: any = {};
    if (message.gkeCluster !== "") {
      obj.gkeCluster = message.gkeCluster;
    }
    if (message.dagGcsPrefix !== "") {
      obj.dagGcsPrefix = message.dagGcsPrefix;
    }
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.softwareConfig !== undefined) {
      obj.softwareConfig = SoftwareConfig.toJSON(message.softwareConfig);
    }
    if (message.nodeConfig !== undefined) {
      obj.nodeConfig = NodeConfig.toJSON(message.nodeConfig);
    }
    if (message.privateEnvironmentConfig !== undefined) {
      obj.privateEnvironmentConfig = PrivateEnvironmentConfig.toJSON(message.privateEnvironmentConfig);
    }
    if (message.webServerNetworkAccessControl !== undefined) {
      obj.webServerNetworkAccessControl = WebServerNetworkAccessControl.toJSON(message.webServerNetworkAccessControl);
    }
    if (message.databaseConfig !== undefined) {
      obj.databaseConfig = DatabaseConfig.toJSON(message.databaseConfig);
    }
    if (message.webServerConfig !== undefined) {
      obj.webServerConfig = WebServerConfig.toJSON(message.webServerConfig);
    }
    if (message.airflowUri !== "") {
      obj.airflowUri = message.airflowUri;
    }
    if (message.airflowByoidUri !== "") {
      obj.airflowByoidUri = message.airflowByoidUri;
    }
    if (message.encryptionConfig !== undefined) {
      obj.encryptionConfig = EncryptionConfig.toJSON(message.encryptionConfig);
    }
    if (message.maintenanceWindow !== undefined) {
      obj.maintenanceWindow = MaintenanceWindow.toJSON(message.maintenanceWindow);
    }
    if (message.workloadsConfig !== undefined) {
      obj.workloadsConfig = WorkloadsConfig.toJSON(message.workloadsConfig);
    }
    if (message.environmentSize !== 0) {
      obj.environmentSize = environmentConfig_EnvironmentSizeToJSON(message.environmentSize);
    }
    if (message.masterAuthorizedNetworksConfig !== undefined) {
      obj.masterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.toJSON(
        message.masterAuthorizedNetworksConfig,
      );
    }
    if (message.recoveryConfig !== undefined) {
      obj.recoveryConfig = RecoveryConfig.toJSON(message.recoveryConfig);
    }
    if (message.dataRetentionConfig !== undefined) {
      obj.dataRetentionConfig = DataRetentionConfig.toJSON(message.dataRetentionConfig);
    }
    if (message.resilienceMode !== 0) {
      obj.resilienceMode = environmentConfig_ResilienceModeToJSON(message.resilienceMode);
    }
    return obj;
  },

  create(base?: DeepPartial<EnvironmentConfig>): EnvironmentConfig {
    return EnvironmentConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnvironmentConfig>): EnvironmentConfig {
    const message = createBaseEnvironmentConfig();
    message.gkeCluster = object.gkeCluster ?? "";
    message.dagGcsPrefix = object.dagGcsPrefix ?? "";
    message.nodeCount = object.nodeCount ?? 0;
    message.softwareConfig = (object.softwareConfig !== undefined && object.softwareConfig !== null)
      ? SoftwareConfig.fromPartial(object.softwareConfig)
      : undefined;
    message.nodeConfig = (object.nodeConfig !== undefined && object.nodeConfig !== null)
      ? NodeConfig.fromPartial(object.nodeConfig)
      : undefined;
    message.privateEnvironmentConfig =
      (object.privateEnvironmentConfig !== undefined && object.privateEnvironmentConfig !== null)
        ? PrivateEnvironmentConfig.fromPartial(object.privateEnvironmentConfig)
        : undefined;
    message.webServerNetworkAccessControl =
      (object.webServerNetworkAccessControl !== undefined && object.webServerNetworkAccessControl !== null)
        ? WebServerNetworkAccessControl.fromPartial(object.webServerNetworkAccessControl)
        : undefined;
    message.databaseConfig = (object.databaseConfig !== undefined && object.databaseConfig !== null)
      ? DatabaseConfig.fromPartial(object.databaseConfig)
      : undefined;
    message.webServerConfig = (object.webServerConfig !== undefined && object.webServerConfig !== null)
      ? WebServerConfig.fromPartial(object.webServerConfig)
      : undefined;
    message.airflowUri = object.airflowUri ?? "";
    message.airflowByoidUri = object.airflowByoidUri ?? "";
    message.encryptionConfig = (object.encryptionConfig !== undefined && object.encryptionConfig !== null)
      ? EncryptionConfig.fromPartial(object.encryptionConfig)
      : undefined;
    message.maintenanceWindow = (object.maintenanceWindow !== undefined && object.maintenanceWindow !== null)
      ? MaintenanceWindow.fromPartial(object.maintenanceWindow)
      : undefined;
    message.workloadsConfig = (object.workloadsConfig !== undefined && object.workloadsConfig !== null)
      ? WorkloadsConfig.fromPartial(object.workloadsConfig)
      : undefined;
    message.environmentSize = object.environmentSize ?? 0;
    message.masterAuthorizedNetworksConfig =
      (object.masterAuthorizedNetworksConfig !== undefined && object.masterAuthorizedNetworksConfig !== null)
        ? MasterAuthorizedNetworksConfig.fromPartial(object.masterAuthorizedNetworksConfig)
        : undefined;
    message.recoveryConfig = (object.recoveryConfig !== undefined && object.recoveryConfig !== null)
      ? RecoveryConfig.fromPartial(object.recoveryConfig)
      : undefined;
    message.dataRetentionConfig = (object.dataRetentionConfig !== undefined && object.dataRetentionConfig !== null)
      ? DataRetentionConfig.fromPartial(object.dataRetentionConfig)
      : undefined;
    message.resilienceMode = object.resilienceMode ?? 0;
    return message;
  },
};

function createBaseWebServerNetworkAccessControl(): WebServerNetworkAccessControl {
  return { allowedIpRanges: [] };
}

export const WebServerNetworkAccessControl: MessageFns<WebServerNetworkAccessControl> = {
  encode(message: WebServerNetworkAccessControl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allowedIpRanges) {
      WebServerNetworkAccessControl_AllowedIpRange.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebServerNetworkAccessControl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebServerNetworkAccessControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedIpRanges.push(WebServerNetworkAccessControl_AllowedIpRange.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebServerNetworkAccessControl {
    return {
      allowedIpRanges: globalThis.Array.isArray(object?.allowedIpRanges)
        ? object.allowedIpRanges.map((e: any) => WebServerNetworkAccessControl_AllowedIpRange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WebServerNetworkAccessControl): unknown {
    const obj: any = {};
    if (message.allowedIpRanges?.length) {
      obj.allowedIpRanges = message.allowedIpRanges.map((e) => WebServerNetworkAccessControl_AllowedIpRange.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WebServerNetworkAccessControl>): WebServerNetworkAccessControl {
    return WebServerNetworkAccessControl.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebServerNetworkAccessControl>): WebServerNetworkAccessControl {
    const message = createBaseWebServerNetworkAccessControl();
    message.allowedIpRanges =
      object.allowedIpRanges?.map((e) => WebServerNetworkAccessControl_AllowedIpRange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWebServerNetworkAccessControl_AllowedIpRange(): WebServerNetworkAccessControl_AllowedIpRange {
  return { value: "", description: "" };
}

export const WebServerNetworkAccessControl_AllowedIpRange: MessageFns<WebServerNetworkAccessControl_AllowedIpRange> = {
  encode(
    message: WebServerNetworkAccessControl_AllowedIpRange,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebServerNetworkAccessControl_AllowedIpRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebServerNetworkAccessControl_AllowedIpRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebServerNetworkAccessControl_AllowedIpRange {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: WebServerNetworkAccessControl_AllowedIpRange): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(
    base?: DeepPartial<WebServerNetworkAccessControl_AllowedIpRange>,
  ): WebServerNetworkAccessControl_AllowedIpRange {
    return WebServerNetworkAccessControl_AllowedIpRange.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WebServerNetworkAccessControl_AllowedIpRange>,
  ): WebServerNetworkAccessControl_AllowedIpRange {
    const message = createBaseWebServerNetworkAccessControl_AllowedIpRange();
    message.value = object.value ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseSoftwareConfig(): SoftwareConfig {
  return {
    imageVersion: "",
    airflowConfigOverrides: {},
    pypiPackages: {},
    envVariables: {},
    pythonVersion: "",
    schedulerCount: 0,
    cloudDataLineageIntegration: undefined,
    webServerPluginsMode: 0,
  };
}

export const SoftwareConfig: MessageFns<SoftwareConfig> = {
  encode(message: SoftwareConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageVersion !== "") {
      writer.uint32(10).string(message.imageVersion);
    }
    Object.entries(message.airflowConfigOverrides).forEach(([key, value]) => {
      SoftwareConfig_AirflowConfigOverridesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    Object.entries(message.pypiPackages).forEach(([key, value]) => {
      SoftwareConfig_PypiPackagesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    Object.entries(message.envVariables).forEach(([key, value]) => {
      SoftwareConfig_EnvVariablesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.pythonVersion !== "") {
      writer.uint32(50).string(message.pythonVersion);
    }
    if (message.schedulerCount !== 0) {
      writer.uint32(56).int32(message.schedulerCount);
    }
    if (message.cloudDataLineageIntegration !== undefined) {
      CloudDataLineageIntegration.encode(message.cloudDataLineageIntegration, writer.uint32(66).fork()).join();
    }
    if (message.webServerPluginsMode !== 0) {
      writer.uint32(80).int32(message.webServerPluginsMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imageVersion = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = SoftwareConfig_AirflowConfigOverridesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.airflowConfigOverrides[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = SoftwareConfig_PypiPackagesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.pypiPackages[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = SoftwareConfig_EnvVariablesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.envVariables[entry4.key] = entry4.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pythonVersion = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.schedulerCount = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cloudDataLineageIntegration = CloudDataLineageIntegration.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.webServerPluginsMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareConfig {
    return {
      imageVersion: isSet(object.imageVersion) ? globalThis.String(object.imageVersion) : "",
      airflowConfigOverrides: isObject(object.airflowConfigOverrides)
        ? Object.entries(object.airflowConfigOverrides).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      pypiPackages: isObject(object.pypiPackages)
        ? Object.entries(object.pypiPackages).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      envVariables: isObject(object.envVariables)
        ? Object.entries(object.envVariables).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      pythonVersion: isSet(object.pythonVersion) ? globalThis.String(object.pythonVersion) : "",
      schedulerCount: isSet(object.schedulerCount) ? globalThis.Number(object.schedulerCount) : 0,
      cloudDataLineageIntegration: isSet(object.cloudDataLineageIntegration)
        ? CloudDataLineageIntegration.fromJSON(object.cloudDataLineageIntegration)
        : undefined,
      webServerPluginsMode: isSet(object.webServerPluginsMode)
        ? softwareConfig_WebServerPluginsModeFromJSON(object.webServerPluginsMode)
        : 0,
    };
  },

  toJSON(message: SoftwareConfig): unknown {
    const obj: any = {};
    if (message.imageVersion !== "") {
      obj.imageVersion = message.imageVersion;
    }
    if (message.airflowConfigOverrides) {
      const entries = Object.entries(message.airflowConfigOverrides);
      if (entries.length > 0) {
        obj.airflowConfigOverrides = {};
        entries.forEach(([k, v]) => {
          obj.airflowConfigOverrides[k] = v;
        });
      }
    }
    if (message.pypiPackages) {
      const entries = Object.entries(message.pypiPackages);
      if (entries.length > 0) {
        obj.pypiPackages = {};
        entries.forEach(([k, v]) => {
          obj.pypiPackages[k] = v;
        });
      }
    }
    if (message.envVariables) {
      const entries = Object.entries(message.envVariables);
      if (entries.length > 0) {
        obj.envVariables = {};
        entries.forEach(([k, v]) => {
          obj.envVariables[k] = v;
        });
      }
    }
    if (message.pythonVersion !== "") {
      obj.pythonVersion = message.pythonVersion;
    }
    if (message.schedulerCount !== 0) {
      obj.schedulerCount = Math.round(message.schedulerCount);
    }
    if (message.cloudDataLineageIntegration !== undefined) {
      obj.cloudDataLineageIntegration = CloudDataLineageIntegration.toJSON(message.cloudDataLineageIntegration);
    }
    if (message.webServerPluginsMode !== 0) {
      obj.webServerPluginsMode = softwareConfig_WebServerPluginsModeToJSON(message.webServerPluginsMode);
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareConfig>): SoftwareConfig {
    return SoftwareConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareConfig>): SoftwareConfig {
    const message = createBaseSoftwareConfig();
    message.imageVersion = object.imageVersion ?? "";
    message.airflowConfigOverrides = Object.entries(object.airflowConfigOverrides ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.pypiPackages = Object.entries(object.pypiPackages ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.envVariables = Object.entries(object.envVariables ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.pythonVersion = object.pythonVersion ?? "";
    message.schedulerCount = object.schedulerCount ?? 0;
    message.cloudDataLineageIntegration =
      (object.cloudDataLineageIntegration !== undefined && object.cloudDataLineageIntegration !== null)
        ? CloudDataLineageIntegration.fromPartial(object.cloudDataLineageIntegration)
        : undefined;
    message.webServerPluginsMode = object.webServerPluginsMode ?? 0;
    return message;
  },
};

function createBaseSoftwareConfig_AirflowConfigOverridesEntry(): SoftwareConfig_AirflowConfigOverridesEntry {
  return { key: "", value: "" };
}

export const SoftwareConfig_AirflowConfigOverridesEntry: MessageFns<SoftwareConfig_AirflowConfigOverridesEntry> = {
  encode(message: SoftwareConfig_AirflowConfigOverridesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareConfig_AirflowConfigOverridesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareConfig_AirflowConfigOverridesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareConfig_AirflowConfigOverridesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SoftwareConfig_AirflowConfigOverridesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareConfig_AirflowConfigOverridesEntry>): SoftwareConfig_AirflowConfigOverridesEntry {
    return SoftwareConfig_AirflowConfigOverridesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SoftwareConfig_AirflowConfigOverridesEntry>,
  ): SoftwareConfig_AirflowConfigOverridesEntry {
    const message = createBaseSoftwareConfig_AirflowConfigOverridesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSoftwareConfig_PypiPackagesEntry(): SoftwareConfig_PypiPackagesEntry {
  return { key: "", value: "" };
}

export const SoftwareConfig_PypiPackagesEntry: MessageFns<SoftwareConfig_PypiPackagesEntry> = {
  encode(message: SoftwareConfig_PypiPackagesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareConfig_PypiPackagesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareConfig_PypiPackagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareConfig_PypiPackagesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SoftwareConfig_PypiPackagesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareConfig_PypiPackagesEntry>): SoftwareConfig_PypiPackagesEntry {
    return SoftwareConfig_PypiPackagesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareConfig_PypiPackagesEntry>): SoftwareConfig_PypiPackagesEntry {
    const message = createBaseSoftwareConfig_PypiPackagesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSoftwareConfig_EnvVariablesEntry(): SoftwareConfig_EnvVariablesEntry {
  return { key: "", value: "" };
}

export const SoftwareConfig_EnvVariablesEntry: MessageFns<SoftwareConfig_EnvVariablesEntry> = {
  encode(message: SoftwareConfig_EnvVariablesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareConfig_EnvVariablesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareConfig_EnvVariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareConfig_EnvVariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SoftwareConfig_EnvVariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareConfig_EnvVariablesEntry>): SoftwareConfig_EnvVariablesEntry {
    return SoftwareConfig_EnvVariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareConfig_EnvVariablesEntry>): SoftwareConfig_EnvVariablesEntry {
    const message = createBaseSoftwareConfig_EnvVariablesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseIPAllocationPolicy(): IPAllocationPolicy {
  return {
    useIpAliases: false,
    clusterSecondaryRangeName: "",
    servicesSecondaryRangeName: "",
    clusterIpv4CidrBlock: "",
    servicesIpv4CidrBlock: "",
  };
}

export const IPAllocationPolicy: MessageFns<IPAllocationPolicy> = {
  encode(message: IPAllocationPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useIpAliases !== false) {
      writer.uint32(8).bool(message.useIpAliases);
    }
    if (message.clusterSecondaryRangeName !== "") {
      writer.uint32(18).string(message.clusterSecondaryRangeName);
    }
    if (message.servicesSecondaryRangeName !== "") {
      writer.uint32(26).string(message.servicesSecondaryRangeName);
    }
    if (message.clusterIpv4CidrBlock !== "") {
      writer.uint32(34).string(message.clusterIpv4CidrBlock);
    }
    if (message.servicesIpv4CidrBlock !== "") {
      writer.uint32(42).string(message.servicesIpv4CidrBlock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IPAllocationPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIPAllocationPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useIpAliases = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clusterSecondaryRangeName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.servicesSecondaryRangeName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clusterIpv4CidrBlock = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.servicesIpv4CidrBlock = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IPAllocationPolicy {
    return {
      useIpAliases: isSet(object.useIpAliases) ? globalThis.Boolean(object.useIpAliases) : false,
      clusterSecondaryRangeName: isSet(object.clusterSecondaryRangeName)
        ? globalThis.String(object.clusterSecondaryRangeName)
        : "",
      servicesSecondaryRangeName: isSet(object.servicesSecondaryRangeName)
        ? globalThis.String(object.servicesSecondaryRangeName)
        : "",
      clusterIpv4CidrBlock: isSet(object.clusterIpv4CidrBlock) ? globalThis.String(object.clusterIpv4CidrBlock) : "",
      servicesIpv4CidrBlock: isSet(object.servicesIpv4CidrBlock) ? globalThis.String(object.servicesIpv4CidrBlock) : "",
    };
  },

  toJSON(message: IPAllocationPolicy): unknown {
    const obj: any = {};
    if (message.useIpAliases !== false) {
      obj.useIpAliases = message.useIpAliases;
    }
    if (message.clusterSecondaryRangeName !== "") {
      obj.clusterSecondaryRangeName = message.clusterSecondaryRangeName;
    }
    if (message.servicesSecondaryRangeName !== "") {
      obj.servicesSecondaryRangeName = message.servicesSecondaryRangeName;
    }
    if (message.clusterIpv4CidrBlock !== "") {
      obj.clusterIpv4CidrBlock = message.clusterIpv4CidrBlock;
    }
    if (message.servicesIpv4CidrBlock !== "") {
      obj.servicesIpv4CidrBlock = message.servicesIpv4CidrBlock;
    }
    return obj;
  },

  create(base?: DeepPartial<IPAllocationPolicy>): IPAllocationPolicy {
    return IPAllocationPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IPAllocationPolicy>): IPAllocationPolicy {
    const message = createBaseIPAllocationPolicy();
    message.useIpAliases = object.useIpAliases ?? false;
    message.clusterSecondaryRangeName = object.clusterSecondaryRangeName ?? "";
    message.servicesSecondaryRangeName = object.servicesSecondaryRangeName ?? "";
    message.clusterIpv4CidrBlock = object.clusterIpv4CidrBlock ?? "";
    message.servicesIpv4CidrBlock = object.servicesIpv4CidrBlock ?? "";
    return message;
  },
};

function createBaseNodeConfig(): NodeConfig {
  return {
    location: "",
    machineType: "",
    network: "",
    subnetwork: "",
    diskSizeGb: 0,
    oauthScopes: [],
    serviceAccount: "",
    tags: [],
    ipAllocationPolicy: undefined,
    maxPodsPerNode: 0,
    enableIpMasqAgent: false,
    composerNetworkAttachment: "",
    composerInternalIpv4CidrBlock: "",
  };
}

export const NodeConfig: MessageFns<NodeConfig> = {
  encode(message: NodeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    if (message.machineType !== "") {
      writer.uint32(18).string(message.machineType);
    }
    if (message.network !== "") {
      writer.uint32(26).string(message.network);
    }
    if (message.subnetwork !== "") {
      writer.uint32(34).string(message.subnetwork);
    }
    if (message.diskSizeGb !== 0) {
      writer.uint32(40).int32(message.diskSizeGb);
    }
    for (const v of message.oauthScopes) {
      writer.uint32(50).string(v!);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(58).string(message.serviceAccount);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.ipAllocationPolicy !== undefined) {
      IPAllocationPolicy.encode(message.ipAllocationPolicy, writer.uint32(74).fork()).join();
    }
    if (message.maxPodsPerNode !== 0) {
      writer.uint32(80).int32(message.maxPodsPerNode);
    }
    if (message.enableIpMasqAgent !== false) {
      writer.uint32(88).bool(message.enableIpMasqAgent);
    }
    if (message.composerNetworkAttachment !== "") {
      writer.uint32(98).string(message.composerNetworkAttachment);
    }
    if (message.composerInternalIpv4CidrBlock !== "") {
      writer.uint32(106).string(message.composerInternalIpv4CidrBlock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.network = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.diskSizeGb = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.oauthScopes.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.ipAllocationPolicy = IPAllocationPolicy.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.maxPodsPerNode = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.enableIpMasqAgent = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.composerNetworkAttachment = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.composerInternalIpv4CidrBlock = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfig {
    return {
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
      diskSizeGb: isSet(object.diskSizeGb) ? globalThis.Number(object.diskSizeGb) : 0,
      oauthScopes: globalThis.Array.isArray(object?.oauthScopes)
        ? object.oauthScopes.map((e: any) => globalThis.String(e))
        : [],
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      ipAllocationPolicy: isSet(object.ipAllocationPolicy)
        ? IPAllocationPolicy.fromJSON(object.ipAllocationPolicy)
        : undefined,
      maxPodsPerNode: isSet(object.maxPodsPerNode) ? globalThis.Number(object.maxPodsPerNode) : 0,
      enableIpMasqAgent: isSet(object.enableIpMasqAgent) ? globalThis.Boolean(object.enableIpMasqAgent) : false,
      composerNetworkAttachment: isSet(object.composerNetworkAttachment)
        ? globalThis.String(object.composerNetworkAttachment)
        : "",
      composerInternalIpv4CidrBlock: isSet(object.composerInternalIpv4CidrBlock)
        ? globalThis.String(object.composerInternalIpv4CidrBlock)
        : "",
    };
  },

  toJSON(message: NodeConfig): unknown {
    const obj: any = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    if (message.diskSizeGb !== 0) {
      obj.diskSizeGb = Math.round(message.diskSizeGb);
    }
    if (message.oauthScopes?.length) {
      obj.oauthScopes = message.oauthScopes;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.ipAllocationPolicy !== undefined) {
      obj.ipAllocationPolicy = IPAllocationPolicy.toJSON(message.ipAllocationPolicy);
    }
    if (message.maxPodsPerNode !== 0) {
      obj.maxPodsPerNode = Math.round(message.maxPodsPerNode);
    }
    if (message.enableIpMasqAgent !== false) {
      obj.enableIpMasqAgent = message.enableIpMasqAgent;
    }
    if (message.composerNetworkAttachment !== "") {
      obj.composerNetworkAttachment = message.composerNetworkAttachment;
    }
    if (message.composerInternalIpv4CidrBlock !== "") {
      obj.composerInternalIpv4CidrBlock = message.composerInternalIpv4CidrBlock;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeConfig>): NodeConfig {
    return NodeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeConfig>): NodeConfig {
    const message = createBaseNodeConfig();
    message.location = object.location ?? "";
    message.machineType = object.machineType ?? "";
    message.network = object.network ?? "";
    message.subnetwork = object.subnetwork ?? "";
    message.diskSizeGb = object.diskSizeGb ?? 0;
    message.oauthScopes = object.oauthScopes?.map((e) => e) || [];
    message.serviceAccount = object.serviceAccount ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.ipAllocationPolicy = (object.ipAllocationPolicy !== undefined && object.ipAllocationPolicy !== null)
      ? IPAllocationPolicy.fromPartial(object.ipAllocationPolicy)
      : undefined;
    message.maxPodsPerNode = object.maxPodsPerNode ?? 0;
    message.enableIpMasqAgent = object.enableIpMasqAgent ?? false;
    message.composerNetworkAttachment = object.composerNetworkAttachment ?? "";
    message.composerInternalIpv4CidrBlock = object.composerInternalIpv4CidrBlock ?? "";
    return message;
  },
};

function createBasePrivateClusterConfig(): PrivateClusterConfig {
  return { enablePrivateEndpoint: false, masterIpv4CidrBlock: "", masterIpv4ReservedRange: "" };
}

export const PrivateClusterConfig: MessageFns<PrivateClusterConfig> = {
  encode(message: PrivateClusterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enablePrivateEndpoint !== false) {
      writer.uint32(8).bool(message.enablePrivateEndpoint);
    }
    if (message.masterIpv4CidrBlock !== "") {
      writer.uint32(18).string(message.masterIpv4CidrBlock);
    }
    if (message.masterIpv4ReservedRange !== "") {
      writer.uint32(26).string(message.masterIpv4ReservedRange);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateClusterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateClusterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enablePrivateEndpoint = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.masterIpv4CidrBlock = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.masterIpv4ReservedRange = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateClusterConfig {
    return {
      enablePrivateEndpoint: isSet(object.enablePrivateEndpoint)
        ? globalThis.Boolean(object.enablePrivateEndpoint)
        : false,
      masterIpv4CidrBlock: isSet(object.masterIpv4CidrBlock) ? globalThis.String(object.masterIpv4CidrBlock) : "",
      masterIpv4ReservedRange: isSet(object.masterIpv4ReservedRange)
        ? globalThis.String(object.masterIpv4ReservedRange)
        : "",
    };
  },

  toJSON(message: PrivateClusterConfig): unknown {
    const obj: any = {};
    if (message.enablePrivateEndpoint !== false) {
      obj.enablePrivateEndpoint = message.enablePrivateEndpoint;
    }
    if (message.masterIpv4CidrBlock !== "") {
      obj.masterIpv4CidrBlock = message.masterIpv4CidrBlock;
    }
    if (message.masterIpv4ReservedRange !== "") {
      obj.masterIpv4ReservedRange = message.masterIpv4ReservedRange;
    }
    return obj;
  },

  create(base?: DeepPartial<PrivateClusterConfig>): PrivateClusterConfig {
    return PrivateClusterConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivateClusterConfig>): PrivateClusterConfig {
    const message = createBasePrivateClusterConfig();
    message.enablePrivateEndpoint = object.enablePrivateEndpoint ?? false;
    message.masterIpv4CidrBlock = object.masterIpv4CidrBlock ?? "";
    message.masterIpv4ReservedRange = object.masterIpv4ReservedRange ?? "";
    return message;
  },
};

function createBaseNetworkingConfig(): NetworkingConfig {
  return { connectionType: 0 };
}

export const NetworkingConfig: MessageFns<NetworkingConfig> = {
  encode(message: NetworkingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionType !== 0) {
      writer.uint32(8).int32(message.connectionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.connectionType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkingConfig {
    return {
      connectionType: isSet(object.connectionType) ? networkingConfig_ConnectionTypeFromJSON(object.connectionType) : 0,
    };
  },

  toJSON(message: NetworkingConfig): unknown {
    const obj: any = {};
    if (message.connectionType !== 0) {
      obj.connectionType = networkingConfig_ConnectionTypeToJSON(message.connectionType);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkingConfig>): NetworkingConfig {
    return NetworkingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkingConfig>): NetworkingConfig {
    const message = createBaseNetworkingConfig();
    message.connectionType = object.connectionType ?? 0;
    return message;
  },
};

function createBasePrivateEnvironmentConfig(): PrivateEnvironmentConfig {
  return {
    enablePrivateEnvironment: false,
    enablePrivateBuildsOnly: false,
    privateClusterConfig: undefined,
    webServerIpv4CidrBlock: "",
    cloudSqlIpv4CidrBlock: "",
    webServerIpv4ReservedRange: "",
    cloudComposerNetworkIpv4CidrBlock: "",
    cloudComposerNetworkIpv4ReservedRange: "",
    enablePrivatelyUsedPublicIps: false,
    cloudComposerConnectionSubnetwork: "",
    networkingConfig: undefined,
  };
}

export const PrivateEnvironmentConfig: MessageFns<PrivateEnvironmentConfig> = {
  encode(message: PrivateEnvironmentConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enablePrivateEnvironment !== false) {
      writer.uint32(8).bool(message.enablePrivateEnvironment);
    }
    if (message.enablePrivateBuildsOnly !== false) {
      writer.uint32(88).bool(message.enablePrivateBuildsOnly);
    }
    if (message.privateClusterConfig !== undefined) {
      PrivateClusterConfig.encode(message.privateClusterConfig, writer.uint32(18).fork()).join();
    }
    if (message.webServerIpv4CidrBlock !== "") {
      writer.uint32(26).string(message.webServerIpv4CidrBlock);
    }
    if (message.cloudSqlIpv4CidrBlock !== "") {
      writer.uint32(34).string(message.cloudSqlIpv4CidrBlock);
    }
    if (message.webServerIpv4ReservedRange !== "") {
      writer.uint32(42).string(message.webServerIpv4ReservedRange);
    }
    if (message.cloudComposerNetworkIpv4CidrBlock !== "") {
      writer.uint32(58).string(message.cloudComposerNetworkIpv4CidrBlock);
    }
    if (message.cloudComposerNetworkIpv4ReservedRange !== "") {
      writer.uint32(66).string(message.cloudComposerNetworkIpv4ReservedRange);
    }
    if (message.enablePrivatelyUsedPublicIps !== false) {
      writer.uint32(48).bool(message.enablePrivatelyUsedPublicIps);
    }
    if (message.cloudComposerConnectionSubnetwork !== "") {
      writer.uint32(74).string(message.cloudComposerConnectionSubnetwork);
    }
    if (message.networkingConfig !== undefined) {
      NetworkingConfig.encode(message.networkingConfig, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateEnvironmentConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateEnvironmentConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enablePrivateEnvironment = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.enablePrivateBuildsOnly = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.privateClusterConfig = PrivateClusterConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.webServerIpv4CidrBlock = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cloudSqlIpv4CidrBlock = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.webServerIpv4ReservedRange = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.cloudComposerNetworkIpv4CidrBlock = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cloudComposerNetworkIpv4ReservedRange = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.enablePrivatelyUsedPublicIps = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.cloudComposerConnectionSubnetwork = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.networkingConfig = NetworkingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateEnvironmentConfig {
    return {
      enablePrivateEnvironment: isSet(object.enablePrivateEnvironment)
        ? globalThis.Boolean(object.enablePrivateEnvironment)
        : false,
      enablePrivateBuildsOnly: isSet(object.enablePrivateBuildsOnly)
        ? globalThis.Boolean(object.enablePrivateBuildsOnly)
        : false,
      privateClusterConfig: isSet(object.privateClusterConfig)
        ? PrivateClusterConfig.fromJSON(object.privateClusterConfig)
        : undefined,
      webServerIpv4CidrBlock: isSet(object.webServerIpv4CidrBlock)
        ? globalThis.String(object.webServerIpv4CidrBlock)
        : "",
      cloudSqlIpv4CidrBlock: isSet(object.cloudSqlIpv4CidrBlock) ? globalThis.String(object.cloudSqlIpv4CidrBlock) : "",
      webServerIpv4ReservedRange: isSet(object.webServerIpv4ReservedRange)
        ? globalThis.String(object.webServerIpv4ReservedRange)
        : "",
      cloudComposerNetworkIpv4CidrBlock: isSet(object.cloudComposerNetworkIpv4CidrBlock)
        ? globalThis.String(object.cloudComposerNetworkIpv4CidrBlock)
        : "",
      cloudComposerNetworkIpv4ReservedRange: isSet(object.cloudComposerNetworkIpv4ReservedRange)
        ? globalThis.String(object.cloudComposerNetworkIpv4ReservedRange)
        : "",
      enablePrivatelyUsedPublicIps: isSet(object.enablePrivatelyUsedPublicIps)
        ? globalThis.Boolean(object.enablePrivatelyUsedPublicIps)
        : false,
      cloudComposerConnectionSubnetwork: isSet(object.cloudComposerConnectionSubnetwork)
        ? globalThis.String(object.cloudComposerConnectionSubnetwork)
        : "",
      networkingConfig: isSet(object.networkingConfig) ? NetworkingConfig.fromJSON(object.networkingConfig) : undefined,
    };
  },

  toJSON(message: PrivateEnvironmentConfig): unknown {
    const obj: any = {};
    if (message.enablePrivateEnvironment !== false) {
      obj.enablePrivateEnvironment = message.enablePrivateEnvironment;
    }
    if (message.enablePrivateBuildsOnly !== false) {
      obj.enablePrivateBuildsOnly = message.enablePrivateBuildsOnly;
    }
    if (message.privateClusterConfig !== undefined) {
      obj.privateClusterConfig = PrivateClusterConfig.toJSON(message.privateClusterConfig);
    }
    if (message.webServerIpv4CidrBlock !== "") {
      obj.webServerIpv4CidrBlock = message.webServerIpv4CidrBlock;
    }
    if (message.cloudSqlIpv4CidrBlock !== "") {
      obj.cloudSqlIpv4CidrBlock = message.cloudSqlIpv4CidrBlock;
    }
    if (message.webServerIpv4ReservedRange !== "") {
      obj.webServerIpv4ReservedRange = message.webServerIpv4ReservedRange;
    }
    if (message.cloudComposerNetworkIpv4CidrBlock !== "") {
      obj.cloudComposerNetworkIpv4CidrBlock = message.cloudComposerNetworkIpv4CidrBlock;
    }
    if (message.cloudComposerNetworkIpv4ReservedRange !== "") {
      obj.cloudComposerNetworkIpv4ReservedRange = message.cloudComposerNetworkIpv4ReservedRange;
    }
    if (message.enablePrivatelyUsedPublicIps !== false) {
      obj.enablePrivatelyUsedPublicIps = message.enablePrivatelyUsedPublicIps;
    }
    if (message.cloudComposerConnectionSubnetwork !== "") {
      obj.cloudComposerConnectionSubnetwork = message.cloudComposerConnectionSubnetwork;
    }
    if (message.networkingConfig !== undefined) {
      obj.networkingConfig = NetworkingConfig.toJSON(message.networkingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<PrivateEnvironmentConfig>): PrivateEnvironmentConfig {
    return PrivateEnvironmentConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivateEnvironmentConfig>): PrivateEnvironmentConfig {
    const message = createBasePrivateEnvironmentConfig();
    message.enablePrivateEnvironment = object.enablePrivateEnvironment ?? false;
    message.enablePrivateBuildsOnly = object.enablePrivateBuildsOnly ?? false;
    message.privateClusterConfig = (object.privateClusterConfig !== undefined && object.privateClusterConfig !== null)
      ? PrivateClusterConfig.fromPartial(object.privateClusterConfig)
      : undefined;
    message.webServerIpv4CidrBlock = object.webServerIpv4CidrBlock ?? "";
    message.cloudSqlIpv4CidrBlock = object.cloudSqlIpv4CidrBlock ?? "";
    message.webServerIpv4ReservedRange = object.webServerIpv4ReservedRange ?? "";
    message.cloudComposerNetworkIpv4CidrBlock = object.cloudComposerNetworkIpv4CidrBlock ?? "";
    message.cloudComposerNetworkIpv4ReservedRange = object.cloudComposerNetworkIpv4ReservedRange ?? "";
    message.enablePrivatelyUsedPublicIps = object.enablePrivatelyUsedPublicIps ?? false;
    message.cloudComposerConnectionSubnetwork = object.cloudComposerConnectionSubnetwork ?? "";
    message.networkingConfig = (object.networkingConfig !== undefined && object.networkingConfig !== null)
      ? NetworkingConfig.fromPartial(object.networkingConfig)
      : undefined;
    return message;
  },
};

function createBaseDatabaseConfig(): DatabaseConfig {
  return { machineType: "", zone: "" };
}

export const DatabaseConfig: MessageFns<DatabaseConfig> = {
  encode(message: DatabaseConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineType !== "") {
      writer.uint32(10).string(message.machineType);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseConfig {
    return {
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
    };
  },

  toJSON(message: DatabaseConfig): unknown {
    const obj: any = {};
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseConfig>): DatabaseConfig {
    return DatabaseConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseConfig>): DatabaseConfig {
    const message = createBaseDatabaseConfig();
    message.machineType = object.machineType ?? "";
    message.zone = object.zone ?? "";
    return message;
  },
};

function createBaseWebServerConfig(): WebServerConfig {
  return { machineType: "" };
}

export const WebServerConfig: MessageFns<WebServerConfig> = {
  encode(message: WebServerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineType !== "") {
      writer.uint32(10).string(message.machineType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebServerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebServerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.machineType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebServerConfig {
    return { machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "" };
  },

  toJSON(message: WebServerConfig): unknown {
    const obj: any = {};
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    return obj;
  },

  create(base?: DeepPartial<WebServerConfig>): WebServerConfig {
    return WebServerConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebServerConfig>): WebServerConfig {
    const message = createBaseWebServerConfig();
    message.machineType = object.machineType ?? "";
    return message;
  },
};

function createBaseEncryptionConfig(): EncryptionConfig {
  return { kmsKeyName: "" };
}

export const EncryptionConfig: MessageFns<EncryptionConfig> = {
  encode(message: EncryptionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kmsKeyName !== "") {
      writer.uint32(10).string(message.kmsKeyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kmsKeyName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptionConfig {
    return { kmsKeyName: isSet(object.kmsKeyName) ? globalThis.String(object.kmsKeyName) : "" };
  },

  toJSON(message: EncryptionConfig): unknown {
    const obj: any = {};
    if (message.kmsKeyName !== "") {
      obj.kmsKeyName = message.kmsKeyName;
    }
    return obj;
  },

  create(base?: DeepPartial<EncryptionConfig>): EncryptionConfig {
    return EncryptionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EncryptionConfig>): EncryptionConfig {
    const message = createBaseEncryptionConfig();
    message.kmsKeyName = object.kmsKeyName ?? "";
    return message;
  },
};

function createBaseMaintenanceWindow(): MaintenanceWindow {
  return { startTime: undefined, endTime: undefined, recurrence: "" };
}

export const MaintenanceWindow: MessageFns<MaintenanceWindow> = {
  encode(message: MaintenanceWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.recurrence !== "") {
      writer.uint32(26).string(message.recurrence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaintenanceWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaintenanceWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.recurrence = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaintenanceWindow {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      recurrence: isSet(object.recurrence) ? globalThis.String(object.recurrence) : "",
    };
  },

  toJSON(message: MaintenanceWindow): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.recurrence !== "") {
      obj.recurrence = message.recurrence;
    }
    return obj;
  },

  create(base?: DeepPartial<MaintenanceWindow>): MaintenanceWindow {
    return MaintenanceWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaintenanceWindow>): MaintenanceWindow {
    const message = createBaseMaintenanceWindow();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.recurrence = object.recurrence ?? "";
    return message;
  },
};

function createBaseWorkloadsConfig(): WorkloadsConfig {
  return {
    scheduler: undefined,
    webServer: undefined,
    worker: undefined,
    triggerer: undefined,
    dagProcessor: undefined,
  };
}

export const WorkloadsConfig: MessageFns<WorkloadsConfig> = {
  encode(message: WorkloadsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheduler !== undefined) {
      WorkloadsConfig_SchedulerResource.encode(message.scheduler, writer.uint32(10).fork()).join();
    }
    if (message.webServer !== undefined) {
      WorkloadsConfig_WebServerResource.encode(message.webServer, writer.uint32(18).fork()).join();
    }
    if (message.worker !== undefined) {
      WorkloadsConfig_WorkerResource.encode(message.worker, writer.uint32(26).fork()).join();
    }
    if (message.triggerer !== undefined) {
      WorkloadsConfig_TriggererResource.encode(message.triggerer, writer.uint32(34).fork()).join();
    }
    if (message.dagProcessor !== undefined) {
      WorkloadsConfig_DagProcessorResource.encode(message.dagProcessor, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkloadsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkloadsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.scheduler = WorkloadsConfig_SchedulerResource.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.webServer = WorkloadsConfig_WebServerResource.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.worker = WorkloadsConfig_WorkerResource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.triggerer = WorkloadsConfig_TriggererResource.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dagProcessor = WorkloadsConfig_DagProcessorResource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkloadsConfig {
    return {
      scheduler: isSet(object.scheduler) ? WorkloadsConfig_SchedulerResource.fromJSON(object.scheduler) : undefined,
      webServer: isSet(object.webServer) ? WorkloadsConfig_WebServerResource.fromJSON(object.webServer) : undefined,
      worker: isSet(object.worker) ? WorkloadsConfig_WorkerResource.fromJSON(object.worker) : undefined,
      triggerer: isSet(object.triggerer) ? WorkloadsConfig_TriggererResource.fromJSON(object.triggerer) : undefined,
      dagProcessor: isSet(object.dagProcessor)
        ? WorkloadsConfig_DagProcessorResource.fromJSON(object.dagProcessor)
        : undefined,
    };
  },

  toJSON(message: WorkloadsConfig): unknown {
    const obj: any = {};
    if (message.scheduler !== undefined) {
      obj.scheduler = WorkloadsConfig_SchedulerResource.toJSON(message.scheduler);
    }
    if (message.webServer !== undefined) {
      obj.webServer = WorkloadsConfig_WebServerResource.toJSON(message.webServer);
    }
    if (message.worker !== undefined) {
      obj.worker = WorkloadsConfig_WorkerResource.toJSON(message.worker);
    }
    if (message.triggerer !== undefined) {
      obj.triggerer = WorkloadsConfig_TriggererResource.toJSON(message.triggerer);
    }
    if (message.dagProcessor !== undefined) {
      obj.dagProcessor = WorkloadsConfig_DagProcessorResource.toJSON(message.dagProcessor);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkloadsConfig>): WorkloadsConfig {
    return WorkloadsConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkloadsConfig>): WorkloadsConfig {
    const message = createBaseWorkloadsConfig();
    message.scheduler = (object.scheduler !== undefined && object.scheduler !== null)
      ? WorkloadsConfig_SchedulerResource.fromPartial(object.scheduler)
      : undefined;
    message.webServer = (object.webServer !== undefined && object.webServer !== null)
      ? WorkloadsConfig_WebServerResource.fromPartial(object.webServer)
      : undefined;
    message.worker = (object.worker !== undefined && object.worker !== null)
      ? WorkloadsConfig_WorkerResource.fromPartial(object.worker)
      : undefined;
    message.triggerer = (object.triggerer !== undefined && object.triggerer !== null)
      ? WorkloadsConfig_TriggererResource.fromPartial(object.triggerer)
      : undefined;
    message.dagProcessor = (object.dagProcessor !== undefined && object.dagProcessor !== null)
      ? WorkloadsConfig_DagProcessorResource.fromPartial(object.dagProcessor)
      : undefined;
    return message;
  },
};

function createBaseWorkloadsConfig_SchedulerResource(): WorkloadsConfig_SchedulerResource {
  return { cpu: 0, memoryGb: 0, storageGb: 0, count: 0 };
}

export const WorkloadsConfig_SchedulerResource: MessageFns<WorkloadsConfig_SchedulerResource> = {
  encode(message: WorkloadsConfig_SchedulerResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpu !== 0) {
      writer.uint32(13).float(message.cpu);
    }
    if (message.memoryGb !== 0) {
      writer.uint32(21).float(message.memoryGb);
    }
    if (message.storageGb !== 0) {
      writer.uint32(29).float(message.storageGb);
    }
    if (message.count !== 0) {
      writer.uint32(32).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkloadsConfig_SchedulerResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkloadsConfig_SchedulerResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.cpu = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.memoryGb = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.storageGb = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkloadsConfig_SchedulerResource {
    return {
      cpu: isSet(object.cpu) ? globalThis.Number(object.cpu) : 0,
      memoryGb: isSet(object.memoryGb) ? globalThis.Number(object.memoryGb) : 0,
      storageGb: isSet(object.storageGb) ? globalThis.Number(object.storageGb) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: WorkloadsConfig_SchedulerResource): unknown {
    const obj: any = {};
    if (message.cpu !== 0) {
      obj.cpu = message.cpu;
    }
    if (message.memoryGb !== 0) {
      obj.memoryGb = message.memoryGb;
    }
    if (message.storageGb !== 0) {
      obj.storageGb = message.storageGb;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkloadsConfig_SchedulerResource>): WorkloadsConfig_SchedulerResource {
    return WorkloadsConfig_SchedulerResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkloadsConfig_SchedulerResource>): WorkloadsConfig_SchedulerResource {
    const message = createBaseWorkloadsConfig_SchedulerResource();
    message.cpu = object.cpu ?? 0;
    message.memoryGb = object.memoryGb ?? 0;
    message.storageGb = object.storageGb ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseWorkloadsConfig_WebServerResource(): WorkloadsConfig_WebServerResource {
  return { cpu: 0, memoryGb: 0, storageGb: 0 };
}

export const WorkloadsConfig_WebServerResource: MessageFns<WorkloadsConfig_WebServerResource> = {
  encode(message: WorkloadsConfig_WebServerResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpu !== 0) {
      writer.uint32(13).float(message.cpu);
    }
    if (message.memoryGb !== 0) {
      writer.uint32(21).float(message.memoryGb);
    }
    if (message.storageGb !== 0) {
      writer.uint32(29).float(message.storageGb);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkloadsConfig_WebServerResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkloadsConfig_WebServerResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.cpu = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.memoryGb = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.storageGb = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkloadsConfig_WebServerResource {
    return {
      cpu: isSet(object.cpu) ? globalThis.Number(object.cpu) : 0,
      memoryGb: isSet(object.memoryGb) ? globalThis.Number(object.memoryGb) : 0,
      storageGb: isSet(object.storageGb) ? globalThis.Number(object.storageGb) : 0,
    };
  },

  toJSON(message: WorkloadsConfig_WebServerResource): unknown {
    const obj: any = {};
    if (message.cpu !== 0) {
      obj.cpu = message.cpu;
    }
    if (message.memoryGb !== 0) {
      obj.memoryGb = message.memoryGb;
    }
    if (message.storageGb !== 0) {
      obj.storageGb = message.storageGb;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkloadsConfig_WebServerResource>): WorkloadsConfig_WebServerResource {
    return WorkloadsConfig_WebServerResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkloadsConfig_WebServerResource>): WorkloadsConfig_WebServerResource {
    const message = createBaseWorkloadsConfig_WebServerResource();
    message.cpu = object.cpu ?? 0;
    message.memoryGb = object.memoryGb ?? 0;
    message.storageGb = object.storageGb ?? 0;
    return message;
  },
};

function createBaseWorkloadsConfig_WorkerResource(): WorkloadsConfig_WorkerResource {
  return { cpu: 0, memoryGb: 0, storageGb: 0, minCount: 0, maxCount: 0 };
}

export const WorkloadsConfig_WorkerResource: MessageFns<WorkloadsConfig_WorkerResource> = {
  encode(message: WorkloadsConfig_WorkerResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpu !== 0) {
      writer.uint32(13).float(message.cpu);
    }
    if (message.memoryGb !== 0) {
      writer.uint32(21).float(message.memoryGb);
    }
    if (message.storageGb !== 0) {
      writer.uint32(29).float(message.storageGb);
    }
    if (message.minCount !== 0) {
      writer.uint32(32).int32(message.minCount);
    }
    if (message.maxCount !== 0) {
      writer.uint32(40).int32(message.maxCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkloadsConfig_WorkerResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkloadsConfig_WorkerResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.cpu = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.memoryGb = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.storageGb = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.minCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkloadsConfig_WorkerResource {
    return {
      cpu: isSet(object.cpu) ? globalThis.Number(object.cpu) : 0,
      memoryGb: isSet(object.memoryGb) ? globalThis.Number(object.memoryGb) : 0,
      storageGb: isSet(object.storageGb) ? globalThis.Number(object.storageGb) : 0,
      minCount: isSet(object.minCount) ? globalThis.Number(object.minCount) : 0,
      maxCount: isSet(object.maxCount) ? globalThis.Number(object.maxCount) : 0,
    };
  },

  toJSON(message: WorkloadsConfig_WorkerResource): unknown {
    const obj: any = {};
    if (message.cpu !== 0) {
      obj.cpu = message.cpu;
    }
    if (message.memoryGb !== 0) {
      obj.memoryGb = message.memoryGb;
    }
    if (message.storageGb !== 0) {
      obj.storageGb = message.storageGb;
    }
    if (message.minCount !== 0) {
      obj.minCount = Math.round(message.minCount);
    }
    if (message.maxCount !== 0) {
      obj.maxCount = Math.round(message.maxCount);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkloadsConfig_WorkerResource>): WorkloadsConfig_WorkerResource {
    return WorkloadsConfig_WorkerResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkloadsConfig_WorkerResource>): WorkloadsConfig_WorkerResource {
    const message = createBaseWorkloadsConfig_WorkerResource();
    message.cpu = object.cpu ?? 0;
    message.memoryGb = object.memoryGb ?? 0;
    message.storageGb = object.storageGb ?? 0;
    message.minCount = object.minCount ?? 0;
    message.maxCount = object.maxCount ?? 0;
    return message;
  },
};

function createBaseWorkloadsConfig_TriggererResource(): WorkloadsConfig_TriggererResource {
  return { count: 0, cpu: 0, memoryGb: 0 };
}

export const WorkloadsConfig_TriggererResource: MessageFns<WorkloadsConfig_TriggererResource> = {
  encode(message: WorkloadsConfig_TriggererResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== 0) {
      writer.uint32(8).int32(message.count);
    }
    if (message.cpu !== 0) {
      writer.uint32(21).float(message.cpu);
    }
    if (message.memoryGb !== 0) {
      writer.uint32(29).float(message.memoryGb);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkloadsConfig_TriggererResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkloadsConfig_TriggererResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.cpu = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.memoryGb = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkloadsConfig_TriggererResource {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      cpu: isSet(object.cpu) ? globalThis.Number(object.cpu) : 0,
      memoryGb: isSet(object.memoryGb) ? globalThis.Number(object.memoryGb) : 0,
    };
  },

  toJSON(message: WorkloadsConfig_TriggererResource): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.cpu !== 0) {
      obj.cpu = message.cpu;
    }
    if (message.memoryGb !== 0) {
      obj.memoryGb = message.memoryGb;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkloadsConfig_TriggererResource>): WorkloadsConfig_TriggererResource {
    return WorkloadsConfig_TriggererResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkloadsConfig_TriggererResource>): WorkloadsConfig_TriggererResource {
    const message = createBaseWorkloadsConfig_TriggererResource();
    message.count = object.count ?? 0;
    message.cpu = object.cpu ?? 0;
    message.memoryGb = object.memoryGb ?? 0;
    return message;
  },
};

function createBaseWorkloadsConfig_DagProcessorResource(): WorkloadsConfig_DagProcessorResource {
  return { cpu: 0, memoryGb: 0, storageGb: 0, count: 0 };
}

export const WorkloadsConfig_DagProcessorResource: MessageFns<WorkloadsConfig_DagProcessorResource> = {
  encode(message: WorkloadsConfig_DagProcessorResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpu !== 0) {
      writer.uint32(13).float(message.cpu);
    }
    if (message.memoryGb !== 0) {
      writer.uint32(21).float(message.memoryGb);
    }
    if (message.storageGb !== 0) {
      writer.uint32(29).float(message.storageGb);
    }
    if (message.count !== 0) {
      writer.uint32(32).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkloadsConfig_DagProcessorResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkloadsConfig_DagProcessorResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.cpu = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.memoryGb = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.storageGb = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkloadsConfig_DagProcessorResource {
    return {
      cpu: isSet(object.cpu) ? globalThis.Number(object.cpu) : 0,
      memoryGb: isSet(object.memoryGb) ? globalThis.Number(object.memoryGb) : 0,
      storageGb: isSet(object.storageGb) ? globalThis.Number(object.storageGb) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: WorkloadsConfig_DagProcessorResource): unknown {
    const obj: any = {};
    if (message.cpu !== 0) {
      obj.cpu = message.cpu;
    }
    if (message.memoryGb !== 0) {
      obj.memoryGb = message.memoryGb;
    }
    if (message.storageGb !== 0) {
      obj.storageGb = message.storageGb;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkloadsConfig_DagProcessorResource>): WorkloadsConfig_DagProcessorResource {
    return WorkloadsConfig_DagProcessorResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkloadsConfig_DagProcessorResource>): WorkloadsConfig_DagProcessorResource {
    const message = createBaseWorkloadsConfig_DagProcessorResource();
    message.cpu = object.cpu ?? 0;
    message.memoryGb = object.memoryGb ?? 0;
    message.storageGb = object.storageGb ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseDataRetentionConfig(): DataRetentionConfig {
  return {
    airflowDatabaseRetentionDays: 0,
    taskLogsRetentionConfig: undefined,
    airflowMetadataRetentionConfig: undefined,
  };
}

export const DataRetentionConfig: MessageFns<DataRetentionConfig> = {
  encode(message: DataRetentionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.airflowDatabaseRetentionDays !== 0) {
      writer.uint32(8).int32(message.airflowDatabaseRetentionDays);
    }
    if (message.taskLogsRetentionConfig !== undefined) {
      TaskLogsRetentionConfig.encode(message.taskLogsRetentionConfig, writer.uint32(34).fork()).join();
    }
    if (message.airflowMetadataRetentionConfig !== undefined) {
      AirflowMetadataRetentionPolicyConfig.encode(message.airflowMetadataRetentionConfig, writer.uint32(42).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataRetentionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataRetentionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.airflowDatabaseRetentionDays = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.taskLogsRetentionConfig = TaskLogsRetentionConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.airflowMetadataRetentionConfig = AirflowMetadataRetentionPolicyConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataRetentionConfig {
    return {
      airflowDatabaseRetentionDays: isSet(object.airflowDatabaseRetentionDays)
        ? globalThis.Number(object.airflowDatabaseRetentionDays)
        : 0,
      taskLogsRetentionConfig: isSet(object.taskLogsRetentionConfig)
        ? TaskLogsRetentionConfig.fromJSON(object.taskLogsRetentionConfig)
        : undefined,
      airflowMetadataRetentionConfig: isSet(object.airflowMetadataRetentionConfig)
        ? AirflowMetadataRetentionPolicyConfig.fromJSON(object.airflowMetadataRetentionConfig)
        : undefined,
    };
  },

  toJSON(message: DataRetentionConfig): unknown {
    const obj: any = {};
    if (message.airflowDatabaseRetentionDays !== 0) {
      obj.airflowDatabaseRetentionDays = Math.round(message.airflowDatabaseRetentionDays);
    }
    if (message.taskLogsRetentionConfig !== undefined) {
      obj.taskLogsRetentionConfig = TaskLogsRetentionConfig.toJSON(message.taskLogsRetentionConfig);
    }
    if (message.airflowMetadataRetentionConfig !== undefined) {
      obj.airflowMetadataRetentionConfig = AirflowMetadataRetentionPolicyConfig.toJSON(
        message.airflowMetadataRetentionConfig,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<DataRetentionConfig>): DataRetentionConfig {
    return DataRetentionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataRetentionConfig>): DataRetentionConfig {
    const message = createBaseDataRetentionConfig();
    message.airflowDatabaseRetentionDays = object.airflowDatabaseRetentionDays ?? 0;
    message.taskLogsRetentionConfig =
      (object.taskLogsRetentionConfig !== undefined && object.taskLogsRetentionConfig !== null)
        ? TaskLogsRetentionConfig.fromPartial(object.taskLogsRetentionConfig)
        : undefined;
    message.airflowMetadataRetentionConfig =
      (object.airflowMetadataRetentionConfig !== undefined && object.airflowMetadataRetentionConfig !== null)
        ? AirflowMetadataRetentionPolicyConfig.fromPartial(object.airflowMetadataRetentionConfig)
        : undefined;
    return message;
  },
};

function createBaseTaskLogsRetentionConfig(): TaskLogsRetentionConfig {
  return { storageMode: 0 };
}

export const TaskLogsRetentionConfig: MessageFns<TaskLogsRetentionConfig> = {
  encode(message: TaskLogsRetentionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.storageMode !== 0) {
      writer.uint32(16).int32(message.storageMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskLogsRetentionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskLogsRetentionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.storageMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskLogsRetentionConfig {
    return {
      storageMode: isSet(object.storageMode)
        ? taskLogsRetentionConfig_TaskLogsStorageModeFromJSON(object.storageMode)
        : 0,
    };
  },

  toJSON(message: TaskLogsRetentionConfig): unknown {
    const obj: any = {};
    if (message.storageMode !== 0) {
      obj.storageMode = taskLogsRetentionConfig_TaskLogsStorageModeToJSON(message.storageMode);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskLogsRetentionConfig>): TaskLogsRetentionConfig {
    return TaskLogsRetentionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskLogsRetentionConfig>): TaskLogsRetentionConfig {
    const message = createBaseTaskLogsRetentionConfig();
    message.storageMode = object.storageMode ?? 0;
    return message;
  },
};

function createBaseAirflowMetadataRetentionPolicyConfig(): AirflowMetadataRetentionPolicyConfig {
  return { retentionMode: 0, retentionDays: 0 };
}

export const AirflowMetadataRetentionPolicyConfig: MessageFns<AirflowMetadataRetentionPolicyConfig> = {
  encode(message: AirflowMetadataRetentionPolicyConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retentionMode !== 0) {
      writer.uint32(8).int32(message.retentionMode);
    }
    if (message.retentionDays !== 0) {
      writer.uint32(16).int32(message.retentionDays);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AirflowMetadataRetentionPolicyConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAirflowMetadataRetentionPolicyConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.retentionMode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.retentionDays = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AirflowMetadataRetentionPolicyConfig {
    return {
      retentionMode: isSet(object.retentionMode)
        ? airflowMetadataRetentionPolicyConfig_RetentionModeFromJSON(object.retentionMode)
        : 0,
      retentionDays: isSet(object.retentionDays) ? globalThis.Number(object.retentionDays) : 0,
    };
  },

  toJSON(message: AirflowMetadataRetentionPolicyConfig): unknown {
    const obj: any = {};
    if (message.retentionMode !== 0) {
      obj.retentionMode = airflowMetadataRetentionPolicyConfig_RetentionModeToJSON(message.retentionMode);
    }
    if (message.retentionDays !== 0) {
      obj.retentionDays = Math.round(message.retentionDays);
    }
    return obj;
  },

  create(base?: DeepPartial<AirflowMetadataRetentionPolicyConfig>): AirflowMetadataRetentionPolicyConfig {
    return AirflowMetadataRetentionPolicyConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AirflowMetadataRetentionPolicyConfig>): AirflowMetadataRetentionPolicyConfig {
    const message = createBaseAirflowMetadataRetentionPolicyConfig();
    message.retentionMode = object.retentionMode ?? 0;
    message.retentionDays = object.retentionDays ?? 0;
    return message;
  },
};

function createBaseStorageConfig(): StorageConfig {
  return { bucket: "" };
}

export const StorageConfig: MessageFns<StorageConfig> = {
  encode(message: StorageConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageConfig {
    return { bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "" };
  },

  toJSON(message: StorageConfig): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    return obj;
  },

  create(base?: DeepPartial<StorageConfig>): StorageConfig {
    return StorageConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StorageConfig>): StorageConfig {
    const message = createBaseStorageConfig();
    message.bucket = object.bucket ?? "";
    return message;
  },
};

function createBaseRecoveryConfig(): RecoveryConfig {
  return { scheduledSnapshotsConfig: undefined };
}

export const RecoveryConfig: MessageFns<RecoveryConfig> = {
  encode(message: RecoveryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheduledSnapshotsConfig !== undefined) {
      ScheduledSnapshotsConfig.encode(message.scheduledSnapshotsConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecoveryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecoveryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.scheduledSnapshotsConfig = ScheduledSnapshotsConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecoveryConfig {
    return {
      scheduledSnapshotsConfig: isSet(object.scheduledSnapshotsConfig)
        ? ScheduledSnapshotsConfig.fromJSON(object.scheduledSnapshotsConfig)
        : undefined,
    };
  },

  toJSON(message: RecoveryConfig): unknown {
    const obj: any = {};
    if (message.scheduledSnapshotsConfig !== undefined) {
      obj.scheduledSnapshotsConfig = ScheduledSnapshotsConfig.toJSON(message.scheduledSnapshotsConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<RecoveryConfig>): RecoveryConfig {
    return RecoveryConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RecoveryConfig>): RecoveryConfig {
    const message = createBaseRecoveryConfig();
    message.scheduledSnapshotsConfig =
      (object.scheduledSnapshotsConfig !== undefined && object.scheduledSnapshotsConfig !== null)
        ? ScheduledSnapshotsConfig.fromPartial(object.scheduledSnapshotsConfig)
        : undefined;
    return message;
  },
};

function createBaseScheduledSnapshotsConfig(): ScheduledSnapshotsConfig {
  return { enabled: false, snapshotLocation: "", snapshotCreationSchedule: "", timeZone: "" };
}

export const ScheduledSnapshotsConfig: MessageFns<ScheduledSnapshotsConfig> = {
  encode(message: ScheduledSnapshotsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.snapshotLocation !== "") {
      writer.uint32(50).string(message.snapshotLocation);
    }
    if (message.snapshotCreationSchedule !== "") {
      writer.uint32(26).string(message.snapshotCreationSchedule);
    }
    if (message.timeZone !== "") {
      writer.uint32(42).string(message.timeZone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScheduledSnapshotsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduledSnapshotsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.snapshotLocation = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.snapshotCreationSchedule = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.timeZone = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScheduledSnapshotsConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      snapshotLocation: isSet(object.snapshotLocation) ? globalThis.String(object.snapshotLocation) : "",
      snapshotCreationSchedule: isSet(object.snapshotCreationSchedule)
        ? globalThis.String(object.snapshotCreationSchedule)
        : "",
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
    };
  },

  toJSON(message: ScheduledSnapshotsConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.snapshotLocation !== "") {
      obj.snapshotLocation = message.snapshotLocation;
    }
    if (message.snapshotCreationSchedule !== "") {
      obj.snapshotCreationSchedule = message.snapshotCreationSchedule;
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    return obj;
  },

  create(base?: DeepPartial<ScheduledSnapshotsConfig>): ScheduledSnapshotsConfig {
    return ScheduledSnapshotsConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScheduledSnapshotsConfig>): ScheduledSnapshotsConfig {
    const message = createBaseScheduledSnapshotsConfig();
    message.enabled = object.enabled ?? false;
    message.snapshotLocation = object.snapshotLocation ?? "";
    message.snapshotCreationSchedule = object.snapshotCreationSchedule ?? "";
    message.timeZone = object.timeZone ?? "";
    return message;
  },
};

function createBaseMasterAuthorizedNetworksConfig(): MasterAuthorizedNetworksConfig {
  return { enabled: false, cidrBlocks: [] };
}

export const MasterAuthorizedNetworksConfig: MessageFns<MasterAuthorizedNetworksConfig> = {
  encode(message: MasterAuthorizedNetworksConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    for (const v of message.cidrBlocks) {
      MasterAuthorizedNetworksConfig_CidrBlock.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MasterAuthorizedNetworksConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMasterAuthorizedNetworksConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cidrBlocks.push(MasterAuthorizedNetworksConfig_CidrBlock.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MasterAuthorizedNetworksConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      cidrBlocks: globalThis.Array.isArray(object?.cidrBlocks)
        ? object.cidrBlocks.map((e: any) => MasterAuthorizedNetworksConfig_CidrBlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MasterAuthorizedNetworksConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.cidrBlocks?.length) {
      obj.cidrBlocks = message.cidrBlocks.map((e) => MasterAuthorizedNetworksConfig_CidrBlock.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MasterAuthorizedNetworksConfig>): MasterAuthorizedNetworksConfig {
    return MasterAuthorizedNetworksConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MasterAuthorizedNetworksConfig>): MasterAuthorizedNetworksConfig {
    const message = createBaseMasterAuthorizedNetworksConfig();
    message.enabled = object.enabled ?? false;
    message.cidrBlocks = object.cidrBlocks?.map((e) => MasterAuthorizedNetworksConfig_CidrBlock.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMasterAuthorizedNetworksConfig_CidrBlock(): MasterAuthorizedNetworksConfig_CidrBlock {
  return { displayName: "", cidrBlock: "" };
}

export const MasterAuthorizedNetworksConfig_CidrBlock: MessageFns<MasterAuthorizedNetworksConfig_CidrBlock> = {
  encode(message: MasterAuthorizedNetworksConfig_CidrBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.cidrBlock !== "") {
      writer.uint32(18).string(message.cidrBlock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MasterAuthorizedNetworksConfig_CidrBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMasterAuthorizedNetworksConfig_CidrBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cidrBlock = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MasterAuthorizedNetworksConfig_CidrBlock {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      cidrBlock: isSet(object.cidrBlock) ? globalThis.String(object.cidrBlock) : "",
    };
  },

  toJSON(message: MasterAuthorizedNetworksConfig_CidrBlock): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.cidrBlock !== "") {
      obj.cidrBlock = message.cidrBlock;
    }
    return obj;
  },

  create(base?: DeepPartial<MasterAuthorizedNetworksConfig_CidrBlock>): MasterAuthorizedNetworksConfig_CidrBlock {
    return MasterAuthorizedNetworksConfig_CidrBlock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MasterAuthorizedNetworksConfig_CidrBlock>): MasterAuthorizedNetworksConfig_CidrBlock {
    const message = createBaseMasterAuthorizedNetworksConfig_CidrBlock();
    message.displayName = object.displayName ?? "";
    message.cidrBlock = object.cidrBlock ?? "";
    return message;
  },
};

function createBaseCloudDataLineageIntegration(): CloudDataLineageIntegration {
  return { enabled: false };
}

export const CloudDataLineageIntegration: MessageFns<CloudDataLineageIntegration> = {
  encode(message: CloudDataLineageIntegration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudDataLineageIntegration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudDataLineageIntegration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudDataLineageIntegration {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: CloudDataLineageIntegration): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudDataLineageIntegration>): CloudDataLineageIntegration {
    return CloudDataLineageIntegration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudDataLineageIntegration>): CloudDataLineageIntegration {
    const message = createBaseCloudDataLineageIntegration();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseEnvironment(): Environment {
  return {
    name: "",
    config: undefined,
    uuid: "",
    state: 0,
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    satisfiesPzs: false,
    satisfiesPzi: false,
    storageConfig: undefined,
  };
}

export const Environment: MessageFns<Environment> = {
  encode(message: Environment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.config !== undefined) {
      EnvironmentConfig.encode(message.config, writer.uint32(18).fork()).join();
    }
    if (message.uuid !== "") {
      writer.uint32(26).string(message.uuid);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Environment_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.satisfiesPzs !== false) {
      writer.uint32(64).bool(message.satisfiesPzs);
    }
    if (message.satisfiesPzi !== false) {
      writer.uint32(80).bool(message.satisfiesPzi);
    }
    if (message.storageConfig !== undefined) {
      StorageConfig.encode(message.storageConfig, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = EnvironmentConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Environment_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.satisfiesPzs = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.storageConfig = StorageConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      config: isSet(object.config) ? EnvironmentConfig.fromJSON(object.config) : undefined,
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      state: isSet(object.state) ? environment_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      satisfiesPzs: isSet(object.satisfiesPzs) ? globalThis.Boolean(object.satisfiesPzs) : false,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : false,
      storageConfig: isSet(object.storageConfig) ? StorageConfig.fromJSON(object.storageConfig) : undefined,
    };
  },

  toJSON(message: Environment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.config !== undefined) {
      obj.config = EnvironmentConfig.toJSON(message.config);
    }
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.state !== 0) {
      obj.state = environment_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.satisfiesPzs !== false) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== false) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    if (message.storageConfig !== undefined) {
      obj.storageConfig = StorageConfig.toJSON(message.storageConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Environment>): Environment {
    return Environment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment>): Environment {
    const message = createBaseEnvironment();
    message.name = object.name ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? EnvironmentConfig.fromPartial(object.config)
      : undefined;
    message.uuid = object.uuid ?? "";
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.satisfiesPzs = object.satisfiesPzs ?? false;
    message.satisfiesPzi = object.satisfiesPzi ?? false;
    message.storageConfig = (object.storageConfig !== undefined && object.storageConfig !== null)
      ? StorageConfig.fromPartial(object.storageConfig)
      : undefined;
    return message;
  },
};

function createBaseEnvironment_LabelsEntry(): Environment_LabelsEntry {
  return { key: "", value: "" };
}

export const Environment_LabelsEntry: MessageFns<Environment_LabelsEntry> = {
  encode(message: Environment_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Environment_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Environment_LabelsEntry>): Environment_LabelsEntry {
    return Environment_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment_LabelsEntry>): Environment_LabelsEntry {
    const message = createBaseEnvironment_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCheckUpgradeRequest(): CheckUpgradeRequest {
  return { environment: "", imageVersion: "" };
}

export const CheckUpgradeRequest: MessageFns<CheckUpgradeRequest> = {
  encode(message: CheckUpgradeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== "") {
      writer.uint32(10).string(message.environment);
    }
    if (message.imageVersion !== "") {
      writer.uint32(18).string(message.imageVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckUpgradeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckUpgradeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.environment = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imageVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckUpgradeRequest {
    return {
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      imageVersion: isSet(object.imageVersion) ? globalThis.String(object.imageVersion) : "",
    };
  },

  toJSON(message: CheckUpgradeRequest): unknown {
    const obj: any = {};
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.imageVersion !== "") {
      obj.imageVersion = message.imageVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckUpgradeRequest>): CheckUpgradeRequest {
    return CheckUpgradeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckUpgradeRequest>): CheckUpgradeRequest {
    const message = createBaseCheckUpgradeRequest();
    message.environment = object.environment ?? "";
    message.imageVersion = object.imageVersion ?? "";
    return message;
  },
};

function createBaseCheckUpgradeResponse(): CheckUpgradeResponse {
  return {
    buildLogUri: "",
    containsPypiModulesConflict: 0,
    pypiConflictBuildLogExtract: "",
    imageVersion: "",
    pypiDependencies: {},
  };
}

export const CheckUpgradeResponse: MessageFns<CheckUpgradeResponse> = {
  encode(message: CheckUpgradeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buildLogUri !== "") {
      writer.uint32(10).string(message.buildLogUri);
    }
    if (message.containsPypiModulesConflict !== 0) {
      writer.uint32(32).int32(message.containsPypiModulesConflict);
    }
    if (message.pypiConflictBuildLogExtract !== "") {
      writer.uint32(26).string(message.pypiConflictBuildLogExtract);
    }
    if (message.imageVersion !== "") {
      writer.uint32(42).string(message.imageVersion);
    }
    Object.entries(message.pypiDependencies).forEach(([key, value]) => {
      CheckUpgradeResponse_PypiDependenciesEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckUpgradeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckUpgradeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buildLogUri = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.containsPypiModulesConflict = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pypiConflictBuildLogExtract = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.imageVersion = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = CheckUpgradeResponse_PypiDependenciesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.pypiDependencies[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckUpgradeResponse {
    return {
      buildLogUri: isSet(object.buildLogUri) ? globalThis.String(object.buildLogUri) : "",
      containsPypiModulesConflict: isSet(object.containsPypiModulesConflict)
        ? checkUpgradeResponse_ConflictResultFromJSON(object.containsPypiModulesConflict)
        : 0,
      pypiConflictBuildLogExtract: isSet(object.pypiConflictBuildLogExtract)
        ? globalThis.String(object.pypiConflictBuildLogExtract)
        : "",
      imageVersion: isSet(object.imageVersion) ? globalThis.String(object.imageVersion) : "",
      pypiDependencies: isObject(object.pypiDependencies)
        ? Object.entries(object.pypiDependencies).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CheckUpgradeResponse): unknown {
    const obj: any = {};
    if (message.buildLogUri !== "") {
      obj.buildLogUri = message.buildLogUri;
    }
    if (message.containsPypiModulesConflict !== 0) {
      obj.containsPypiModulesConflict = checkUpgradeResponse_ConflictResultToJSON(message.containsPypiModulesConflict);
    }
    if (message.pypiConflictBuildLogExtract !== "") {
      obj.pypiConflictBuildLogExtract = message.pypiConflictBuildLogExtract;
    }
    if (message.imageVersion !== "") {
      obj.imageVersion = message.imageVersion;
    }
    if (message.pypiDependencies) {
      const entries = Object.entries(message.pypiDependencies);
      if (entries.length > 0) {
        obj.pypiDependencies = {};
        entries.forEach(([k, v]) => {
          obj.pypiDependencies[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CheckUpgradeResponse>): CheckUpgradeResponse {
    return CheckUpgradeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckUpgradeResponse>): CheckUpgradeResponse {
    const message = createBaseCheckUpgradeResponse();
    message.buildLogUri = object.buildLogUri ?? "";
    message.containsPypiModulesConflict = object.containsPypiModulesConflict ?? 0;
    message.pypiConflictBuildLogExtract = object.pypiConflictBuildLogExtract ?? "";
    message.imageVersion = object.imageVersion ?? "";
    message.pypiDependencies = Object.entries(object.pypiDependencies ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCheckUpgradeResponse_PypiDependenciesEntry(): CheckUpgradeResponse_PypiDependenciesEntry {
  return { key: "", value: "" };
}

export const CheckUpgradeResponse_PypiDependenciesEntry: MessageFns<CheckUpgradeResponse_PypiDependenciesEntry> = {
  encode(message: CheckUpgradeResponse_PypiDependenciesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckUpgradeResponse_PypiDependenciesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckUpgradeResponse_PypiDependenciesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckUpgradeResponse_PypiDependenciesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CheckUpgradeResponse_PypiDependenciesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckUpgradeResponse_PypiDependenciesEntry>): CheckUpgradeResponse_PypiDependenciesEntry {
    return CheckUpgradeResponse_PypiDependenciesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CheckUpgradeResponse_PypiDependenciesEntry>,
  ): CheckUpgradeResponse_PypiDependenciesEntry {
    const message = createBaseCheckUpgradeResponse_PypiDependenciesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

/** Managed Apache Airflow Environments. */
export type EnvironmentsDefinition = typeof EnvironmentsDefinition;
export const EnvironmentsDefinition = {
  name: "Environments",
  fullName: "google.cloud.orchestration.airflow.service.v1beta1.Environments",
  methods: {
    /** Create a new environment. */
    createEnvironment: {
      name: "CreateEnvironment",
      requestType: CreateEnvironmentRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              83,
              10,
              11,
              69,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              18,
              68,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              97,
              105,
              114,
              102,
              108,
              111,
              119,
              46,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              46,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([18, 112, 97, 114, 101, 110, 116, 44, 101, 110, 118, 105, 114, 111, 110, 109, 101, 110, 116]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              11,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              34,
              53,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Get an existing environment. */
    getEnvironment: {
      name: "GetEnvironment",
      requestType: GetEnvironmentRequest,
      requestStream: false,
      responseType: Environment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** List environments. */
    listEnvironments: {
      name: "ListEnvironments",
      requestType: ListEnvironmentsRequest,
      requestStream: false,
      responseType: ListEnvironmentsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Update an environment. */
    updateEnvironment: {
      name: "UpdateEnvironment",
      requestType: UpdateEnvironmentRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              83,
              10,
              11,
              69,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              18,
              68,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              97,
              105,
              114,
              102,
              108,
              111,
              119,
              46,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              46,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              28,
              110,
              97,
              109,
              101,
              44,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              11,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              50,
              53,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Delete an environment. */
    deleteEnvironment: {
      name: "DeleteEnvironment",
      requestType: DeleteEnvironmentRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              93,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              68,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              97,
              105,
              114,
              102,
              108,
              111,
              119,
              46,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              46,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              42,
              53,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Restart Airflow web server. */
    restartWebServer: {
      name: "RestartWebServer",
      requestType: RestartWebServerRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              83,
              10,
              11,
              69,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              18,
              68,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              97,
              105,
              114,
              102,
              108,
              111,
              119,
              46,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              46,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              75,
              58,
              1,
              42,
              34,
              70,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              115,
              116,
              97,
              114,
              116,
              87,
              101,
              98,
              83,
              101,
              114,
              118,
              101,
              114,
            ]),
          ],
        },
      },
    },
    /**
     * Check if an upgrade operation on the environment will succeed.
     *
     * In case of problems detailed info can be found in the returned Operation.
     */
    checkUpgrade: {
      name: "CheckUpgrade",
      requestType: CheckUpgradeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              143,
              1,
              10,
              71,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              97,
              105,
              114,
              102,
              108,
              111,
              119,
              46,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              46,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              46,
              67,
              104,
              101,
              99,
              107,
              85,
              112,
              103,
              114,
              97,
              100,
              101,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              68,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              97,
              105,
              114,
              102,
              108,
              111,
              119,
              46,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              46,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              78,
              58,
              1,
              42,
              34,
              73,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              99,
              104,
              101,
              99,
              107,
              85,
              112,
              103,
              114,
              97,
              100,
              101,
            ]),
          ],
        },
      },
    },
    /** Executes Airflow CLI command. */
    executeAirflowCommand: {
      name: "ExecuteAirflowCommand",
      requestType: ExecuteAirflowCommandRequest,
      requestStream: false,
      responseType: ExecuteAirflowCommandResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              87,
              58,
              1,
              42,
              34,
              82,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              101,
              120,
              101,
              99,
              117,
              116,
              101,
              65,
              105,
              114,
              102,
              108,
              111,
              119,
              67,
              111,
              109,
              109,
              97,
              110,
              100,
            ]),
          ],
        },
      },
    },
    /** Stops Airflow CLI command execution. */
    stopAirflowCommand: {
      name: "StopAirflowCommand",
      requestType: StopAirflowCommandRequest,
      requestStream: false,
      responseType: StopAirflowCommandResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              84,
              58,
              1,
              42,
              34,
              79,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              111,
              112,
              65,
              105,
              114,
              102,
              108,
              111,
              119,
              67,
              111,
              109,
              109,
              97,
              110,
              100,
            ]),
          ],
        },
      },
    },
    /** Polls Airflow CLI command execution and fetches logs. */
    pollAirflowCommand: {
      name: "PollAirflowCommand",
      requestType: PollAirflowCommandRequest,
      requestStream: false,
      responseType: PollAirflowCommandResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              84,
              58,
              1,
              42,
              34,
              79,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              112,
              111,
              108,
              108,
              65,
              105,
              114,
              102,
              108,
              111,
              119,
              67,
              111,
              109,
              109,
              97,
              110,
              100,
            ]),
          ],
        },
      },
    },
    /**
     * Lists workloads in a Cloud Composer environment. Workload is a unit that
     * runs a single Composer component.
     *
     * This method is supported for Cloud Composer environments in versions
     * composer-3.*.*-airflow-*.*.* and newer.
     */
    listWorkloads: {
      name: "ListWorkloads",
      requestType: ListWorkloadsRequest,
      requestStream: false,
      responseType: ListWorkloadsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              67,
              18,
              65,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a user workloads Secret.
     *
     * This method is supported for Cloud Composer environments in versions
     * composer-3.*.*-airflow-*.*.* and newer.
     */
    createUserWorkloadsSecret: {
      name: "CreateUserWorkloadsSecret",
      requestType: CreateUserWorkloadsSecretRequest,
      requestStream: false,
      responseType: UserWorkloadsSecret,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              28,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              117,
              115,
              101,
              114,
              95,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              95,
              115,
              101,
              99,
              114,
              101,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              101,
              58,
              21,
              117,
              115,
              101,
              114,
              95,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              95,
              115,
              101,
              99,
              114,
              101,
              116,
              34,
              76,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              117,
              115,
              101,
              114,
              87,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              83,
              101,
              99,
              114,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets an existing user workloads Secret.
     * Values of the "data" field in the response are cleared.
     *
     * This method is supported for Cloud Composer environments in versions
     * composer-3.*.*-airflow-*.*.* and newer.
     */
    getUserWorkloadsSecret: {
      name: "GetUserWorkloadsSecret",
      requestType: GetUserWorkloadsSecretRequest,
      requestStream: false,
      responseType: UserWorkloadsSecret,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              78,
              18,
              76,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              117,
              115,
              101,
              114,
              87,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              83,
              101,
              99,
              114,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists user workloads Secrets.
     *
     * This method is supported for Cloud Composer environments in versions
     * composer-3.*.*-airflow-*.*.* and newer.
     */
    listUserWorkloadsSecrets: {
      name: "ListUserWorkloadsSecrets",
      requestType: ListUserWorkloadsSecretsRequest,
      requestStream: false,
      responseType: ListUserWorkloadsSecretsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              78,
              18,
              76,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              117,
              115,
              101,
              114,
              87,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              83,
              101,
              99,
              114,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a user workloads Secret.
     *
     * This method is supported for Cloud Composer environments in versions
     * composer-3.*.*-airflow-*.*.* and newer.
     */
    updateUserWorkloadsSecret: {
      name: "UpdateUserWorkloadsSecret",
      requestType: UpdateUserWorkloadsSecretRequest,
      requestStream: false,
      responseType: UserWorkloadsSecret,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              117,
              115,
              101,
              114,
              95,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              95,
              115,
              101,
              99,
              114,
              101,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              123,
              58,
              21,
              117,
              115,
              101,
              114,
              95,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              95,
              115,
              101,
              99,
              114,
              101,
              116,
              26,
              98,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              117,
              115,
              101,
              114,
              95,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              95,
              115,
              101,
              99,
              114,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              117,
              115,
              101,
              114,
              87,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              83,
              101,
              99,
              114,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a user workloads Secret.
     *
     * This method is supported for Cloud Composer environments in versions
     * composer-3.*.*-airflow-*.*.* and newer.
     */
    deleteUserWorkloadsSecret: {
      name: "DeleteUserWorkloadsSecret",
      requestType: DeleteUserWorkloadsSecretRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              78,
              42,
              76,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              117,
              115,
              101,
              114,
              87,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              83,
              101,
              99,
              114,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a user workloads ConfigMap.
     *
     * This method is supported for Cloud Composer environments in versions
     * composer-3.*.*-airflow-*.*.* and newer.
     */
    createUserWorkloadsConfigMap: {
      name: "CreateUserWorkloadsConfigMap",
      requestType: CreateUserWorkloadsConfigMapRequest,
      requestStream: false,
      responseType: UserWorkloadsConfigMap,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              32,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              117,
              115,
              101,
              114,
              95,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              109,
              97,
              112,
            ]),
          ],
          578365826: [
            Buffer.from([
              108,
              58,
              25,
              117,
              115,
              101,
              114,
              95,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              109,
              97,
              112,
              34,
              79,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              117,
              115,
              101,
              114,
              87,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              67,
              111,
              110,
              102,
              105,
              103,
              77,
              97,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets an existing user workloads ConfigMap.
     *
     * This method is supported for Cloud Composer environments in versions
     * composer-3.*.*-airflow-*.*.* and newer.
     */
    getUserWorkloadsConfigMap: {
      name: "GetUserWorkloadsConfigMap",
      requestType: GetUserWorkloadsConfigMapRequest,
      requestStream: false,
      responseType: UserWorkloadsConfigMap,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              81,
              18,
              79,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              117,
              115,
              101,
              114,
              87,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              67,
              111,
              110,
              102,
              105,
              103,
              77,
              97,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists user workloads ConfigMaps.
     *
     * This method is supported for Cloud Composer environments in versions
     * composer-3.*.*-airflow-*.*.* and newer.
     */
    listUserWorkloadsConfigMaps: {
      name: "ListUserWorkloadsConfigMaps",
      requestType: ListUserWorkloadsConfigMapsRequest,
      requestStream: false,
      responseType: ListUserWorkloadsConfigMapsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              81,
              18,
              79,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              117,
              115,
              101,
              114,
              87,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              67,
              111,
              110,
              102,
              105,
              103,
              77,
              97,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a user workloads ConfigMap.
     *
     * This method is supported for Cloud Composer environments in versions
     * composer-3.*.*-airflow-*.*.* and newer.
     */
    updateUserWorkloadsConfigMap: {
      name: "UpdateUserWorkloadsConfigMap",
      requestType: UpdateUserWorkloadsConfigMapRequest,
      requestStream: false,
      responseType: UserWorkloadsConfigMap,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              25,
              117,
              115,
              101,
              114,
              95,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              109,
              97,
              112,
            ]),
          ],
          578365826: [
            Buffer.from([
              134,
              1,
              58,
              25,
              117,
              115,
              101,
              114,
              95,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              109,
              97,
              112,
              26,
              105,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              117,
              115,
              101,
              114,
              95,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              109,
              97,
              112,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              117,
              115,
              101,
              114,
              87,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              67,
              111,
              110,
              102,
              105,
              103,
              77,
              97,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a user workloads ConfigMap.
     *
     * This method is supported for Cloud Composer environments in versions
     * composer-3.*.*-airflow-*.*.* and newer.
     */
    deleteUserWorkloadsConfigMap: {
      name: "DeleteUserWorkloadsConfigMap",
      requestType: DeleteUserWorkloadsConfigMapRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              81,
              42,
              79,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              117,
              115,
              101,
              114,
              87,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              67,
              111,
              110,
              102,
              105,
              103,
              77,
              97,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a snapshots of a Cloud Composer environment.
     *
     * As a result of this operation, snapshot of environment's state is stored
     * in a location specified in the SaveSnapshotRequest.
     */
    saveSnapshot: {
      name: "SaveSnapshot",
      requestType: SaveSnapshotRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              143,
              1,
              10,
              71,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              97,
              105,
              114,
              102,
              108,
              111,
              119,
              46,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              46,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              46,
              83,
              97,
              118,
              101,
              83,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              68,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              97,
              105,
              114,
              102,
              108,
              111,
              119,
              46,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              46,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              78,
              58,
              1,
              42,
              34,
              73,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              97,
              118,
              101,
              83,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Loads a snapshot of a Cloud Composer environment.
     *
     * As a result of this operation, a snapshot of environment's specified in
     * LoadSnapshotRequest is loaded into the environment.
     */
    loadSnapshot: {
      name: "LoadSnapshot",
      requestType: LoadSnapshotRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              143,
              1,
              10,
              71,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              97,
              105,
              114,
              102,
              108,
              111,
              119,
              46,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              46,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              46,
              76,
              111,
              97,
              100,
              83,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              68,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              97,
              105,
              114,
              102,
              108,
              111,
              119,
              46,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              46,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              78,
              58,
              1,
              42,
              34,
              73,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              108,
              111,
              97,
              100,
              83,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
            ]),
          ],
        },
      },
    },
    /** Triggers database failover (only for highly resilient environments). */
    databaseFailover: {
      name: "DatabaseFailover",
      requestType: DatabaseFailoverRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              147,
              1,
              10,
              75,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              97,
              105,
              114,
              102,
              108,
              111,
              119,
              46,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              46,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              46,
              68,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              70,
              97,
              105,
              108,
              111,
              118,
              101,
              114,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              68,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              97,
              105,
              114,
              102,
              108,
              111,
              119,
              46,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              46,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              82,
              58,
              1,
              42,
              34,
              77,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              70,
              97,
              105,
              108,
              111,
              118,
              101,
              114,
            ]),
          ],
        },
      },
    },
    /** Fetches database properties. */
    fetchDatabaseProperties: {
      name: "FetchDatabaseProperties",
      requestType: FetchDatabasePropertiesRequest,
      requestStream: false,
      responseType: FetchDatabasePropertiesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              86,
              18,
              84,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              102,
              101,
              116,
              99,
              104,
              68,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              80,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface EnvironmentsServiceImplementation<CallContextExt = {}> {
  /** Create a new environment. */
  createEnvironment(
    request: CreateEnvironmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Get an existing environment. */
  getEnvironment(
    request: GetEnvironmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Environment>>;
  /** List environments. */
  listEnvironments(
    request: ListEnvironmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListEnvironmentsResponse>>;
  /** Update an environment. */
  updateEnvironment(
    request: UpdateEnvironmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Delete an environment. */
  deleteEnvironment(
    request: DeleteEnvironmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Restart Airflow web server. */
  restartWebServer(
    request: RestartWebServerRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Check if an upgrade operation on the environment will succeed.
   *
   * In case of problems detailed info can be found in the returned Operation.
   */
  checkUpgrade(request: CheckUpgradeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Executes Airflow CLI command. */
  executeAirflowCommand(
    request: ExecuteAirflowCommandRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExecuteAirflowCommandResponse>>;
  /** Stops Airflow CLI command execution. */
  stopAirflowCommand(
    request: StopAirflowCommandRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StopAirflowCommandResponse>>;
  /** Polls Airflow CLI command execution and fetches logs. */
  pollAirflowCommand(
    request: PollAirflowCommandRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PollAirflowCommandResponse>>;
  /**
   * Lists workloads in a Cloud Composer environment. Workload is a unit that
   * runs a single Composer component.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  listWorkloads(
    request: ListWorkloadsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListWorkloadsResponse>>;
  /**
   * Creates a user workloads Secret.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  createUserWorkloadsSecret(
    request: CreateUserWorkloadsSecretRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UserWorkloadsSecret>>;
  /**
   * Gets an existing user workloads Secret.
   * Values of the "data" field in the response are cleared.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  getUserWorkloadsSecret(
    request: GetUserWorkloadsSecretRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UserWorkloadsSecret>>;
  /**
   * Lists user workloads Secrets.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  listUserWorkloadsSecrets(
    request: ListUserWorkloadsSecretsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListUserWorkloadsSecretsResponse>>;
  /**
   * Updates a user workloads Secret.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  updateUserWorkloadsSecret(
    request: UpdateUserWorkloadsSecretRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UserWorkloadsSecret>>;
  /**
   * Deletes a user workloads Secret.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  deleteUserWorkloadsSecret(
    request: DeleteUserWorkloadsSecretRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Creates a user workloads ConfigMap.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  createUserWorkloadsConfigMap(
    request: CreateUserWorkloadsConfigMapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UserWorkloadsConfigMap>>;
  /**
   * Gets an existing user workloads ConfigMap.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  getUserWorkloadsConfigMap(
    request: GetUserWorkloadsConfigMapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UserWorkloadsConfigMap>>;
  /**
   * Lists user workloads ConfigMaps.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  listUserWorkloadsConfigMaps(
    request: ListUserWorkloadsConfigMapsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListUserWorkloadsConfigMapsResponse>>;
  /**
   * Updates a user workloads ConfigMap.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  updateUserWorkloadsConfigMap(
    request: UpdateUserWorkloadsConfigMapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UserWorkloadsConfigMap>>;
  /**
   * Deletes a user workloads ConfigMap.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  deleteUserWorkloadsConfigMap(
    request: DeleteUserWorkloadsConfigMapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Creates a snapshots of a Cloud Composer environment.
   *
   * As a result of this operation, snapshot of environment's state is stored
   * in a location specified in the SaveSnapshotRequest.
   */
  saveSnapshot(request: SaveSnapshotRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Loads a snapshot of a Cloud Composer environment.
   *
   * As a result of this operation, a snapshot of environment's specified in
   * LoadSnapshotRequest is loaded into the environment.
   */
  loadSnapshot(request: LoadSnapshotRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Triggers database failover (only for highly resilient environments). */
  databaseFailover(
    request: DatabaseFailoverRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Fetches database properties. */
  fetchDatabaseProperties(
    request: FetchDatabasePropertiesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FetchDatabasePropertiesResponse>>;
}

export interface EnvironmentsClient<CallOptionsExt = {}> {
  /** Create a new environment. */
  createEnvironment(
    request: DeepPartial<CreateEnvironmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Get an existing environment. */
  getEnvironment(
    request: DeepPartial<GetEnvironmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Environment>;
  /** List environments. */
  listEnvironments(
    request: DeepPartial<ListEnvironmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListEnvironmentsResponse>;
  /** Update an environment. */
  updateEnvironment(
    request: DeepPartial<UpdateEnvironmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Delete an environment. */
  deleteEnvironment(
    request: DeepPartial<DeleteEnvironmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Restart Airflow web server. */
  restartWebServer(
    request: DeepPartial<RestartWebServerRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Check if an upgrade operation on the environment will succeed.
   *
   * In case of problems detailed info can be found in the returned Operation.
   */
  checkUpgrade(request: DeepPartial<CheckUpgradeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Executes Airflow CLI command. */
  executeAirflowCommand(
    request: DeepPartial<ExecuteAirflowCommandRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExecuteAirflowCommandResponse>;
  /** Stops Airflow CLI command execution. */
  stopAirflowCommand(
    request: DeepPartial<StopAirflowCommandRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StopAirflowCommandResponse>;
  /** Polls Airflow CLI command execution and fetches logs. */
  pollAirflowCommand(
    request: DeepPartial<PollAirflowCommandRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PollAirflowCommandResponse>;
  /**
   * Lists workloads in a Cloud Composer environment. Workload is a unit that
   * runs a single Composer component.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  listWorkloads(
    request: DeepPartial<ListWorkloadsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListWorkloadsResponse>;
  /**
   * Creates a user workloads Secret.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  createUserWorkloadsSecret(
    request: DeepPartial<CreateUserWorkloadsSecretRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UserWorkloadsSecret>;
  /**
   * Gets an existing user workloads Secret.
   * Values of the "data" field in the response are cleared.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  getUserWorkloadsSecret(
    request: DeepPartial<GetUserWorkloadsSecretRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UserWorkloadsSecret>;
  /**
   * Lists user workloads Secrets.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  listUserWorkloadsSecrets(
    request: DeepPartial<ListUserWorkloadsSecretsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListUserWorkloadsSecretsResponse>;
  /**
   * Updates a user workloads Secret.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  updateUserWorkloadsSecret(
    request: DeepPartial<UpdateUserWorkloadsSecretRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UserWorkloadsSecret>;
  /**
   * Deletes a user workloads Secret.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  deleteUserWorkloadsSecret(
    request: DeepPartial<DeleteUserWorkloadsSecretRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Creates a user workloads ConfigMap.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  createUserWorkloadsConfigMap(
    request: DeepPartial<CreateUserWorkloadsConfigMapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UserWorkloadsConfigMap>;
  /**
   * Gets an existing user workloads ConfigMap.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  getUserWorkloadsConfigMap(
    request: DeepPartial<GetUserWorkloadsConfigMapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UserWorkloadsConfigMap>;
  /**
   * Lists user workloads ConfigMaps.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  listUserWorkloadsConfigMaps(
    request: DeepPartial<ListUserWorkloadsConfigMapsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListUserWorkloadsConfigMapsResponse>;
  /**
   * Updates a user workloads ConfigMap.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  updateUserWorkloadsConfigMap(
    request: DeepPartial<UpdateUserWorkloadsConfigMapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UserWorkloadsConfigMap>;
  /**
   * Deletes a user workloads ConfigMap.
   *
   * This method is supported for Cloud Composer environments in versions
   * composer-3.*.*-airflow-*.*.* and newer.
   */
  deleteUserWorkloadsConfigMap(
    request: DeepPartial<DeleteUserWorkloadsConfigMapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Creates a snapshots of a Cloud Composer environment.
   *
   * As a result of this operation, snapshot of environment's state is stored
   * in a location specified in the SaveSnapshotRequest.
   */
  saveSnapshot(request: DeepPartial<SaveSnapshotRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Loads a snapshot of a Cloud Composer environment.
   *
   * As a result of this operation, a snapshot of environment's specified in
   * LoadSnapshotRequest is loaded into the environment.
   */
  loadSnapshot(request: DeepPartial<LoadSnapshotRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Triggers database failover (only for highly resilient environments). */
  databaseFailover(
    request: DeepPartial<DatabaseFailoverRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Fetches database properties. */
  fetchDatabaseProperties(
    request: DeepPartial<FetchDatabasePropertiesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FetchDatabasePropertiesResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
