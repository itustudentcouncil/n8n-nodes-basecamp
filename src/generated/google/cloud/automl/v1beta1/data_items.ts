// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/automl/v1beta1/data_items.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Value } from "../../../protobuf/struct.js";
import { BoundingPoly } from "./geometry.js";
import { DocumentInputConfig, InputConfig } from "./io.js";
import { TextSegment } from "./text_segment.js";

export const protobufPackage = "google.cloud.automl.v1beta1";

/**
 * A representation of an image.
 * Only images up to 30MB in size are supported.
 */
export interface Image {
  /**
   * Image content represented as a stream of bytes.
   * Note: As with all `bytes` fields, protobuffers use a pure binary
   * representation, whereas JSON representations use base64.
   */
  imageBytes?:
    | Buffer
    | undefined;
  /** An input config specifying the content of the image. */
  inputConfig?:
    | InputConfig
    | undefined;
  /** Output only. HTTP URI to the thumbnail image. */
  thumbnailUri: string;
}

/** A representation of a text snippet. */
export interface TextSnippet {
  /**
   * Required. The content of the text snippet as a string. Up to 250000
   * characters long.
   */
  content: string;
  /**
   * Optional. The format of [content][google.cloud.automl.v1beta1.TextSnippet.content]. Currently the only two allowed
   * values are "text/html" and "text/plain". If left blank, the format is
   * automatically determined from the type of the uploaded [content][google.cloud.automl.v1beta1.TextSnippet.content].
   */
  mimeType: string;
  /** Output only. HTTP URI where you can download the content. */
  contentUri: string;
}

/** Message that describes dimension of a document. */
export interface DocumentDimensions {
  /** Unit of the dimension. */
  unit: DocumentDimensions_DocumentDimensionUnit;
  /** Width value of the document, works together with the unit. */
  width: number;
  /** Height value of the document, works together with the unit. */
  height: number;
}

/** Unit of the document dimension. */
export enum DocumentDimensions_DocumentDimensionUnit {
  /** DOCUMENT_DIMENSION_UNIT_UNSPECIFIED - Should not be used. */
  DOCUMENT_DIMENSION_UNIT_UNSPECIFIED = 0,
  /** INCH - Document dimension is measured in inches. */
  INCH = 1,
  /** CENTIMETER - Document dimension is measured in centimeters. */
  CENTIMETER = 2,
  /** POINT - Document dimension is measured in points. 72 points = 1 inch. */
  POINT = 3,
  UNRECOGNIZED = -1,
}

export function documentDimensions_DocumentDimensionUnitFromJSON(
  object: any,
): DocumentDimensions_DocumentDimensionUnit {
  switch (object) {
    case 0:
    case "DOCUMENT_DIMENSION_UNIT_UNSPECIFIED":
      return DocumentDimensions_DocumentDimensionUnit.DOCUMENT_DIMENSION_UNIT_UNSPECIFIED;
    case 1:
    case "INCH":
      return DocumentDimensions_DocumentDimensionUnit.INCH;
    case 2:
    case "CENTIMETER":
      return DocumentDimensions_DocumentDimensionUnit.CENTIMETER;
    case 3:
    case "POINT":
      return DocumentDimensions_DocumentDimensionUnit.POINT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DocumentDimensions_DocumentDimensionUnit.UNRECOGNIZED;
  }
}

export function documentDimensions_DocumentDimensionUnitToJSON(
  object: DocumentDimensions_DocumentDimensionUnit,
): string {
  switch (object) {
    case DocumentDimensions_DocumentDimensionUnit.DOCUMENT_DIMENSION_UNIT_UNSPECIFIED:
      return "DOCUMENT_DIMENSION_UNIT_UNSPECIFIED";
    case DocumentDimensions_DocumentDimensionUnit.INCH:
      return "INCH";
    case DocumentDimensions_DocumentDimensionUnit.CENTIMETER:
      return "CENTIMETER";
    case DocumentDimensions_DocumentDimensionUnit.POINT:
      return "POINT";
    case DocumentDimensions_DocumentDimensionUnit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A structured text document e.g. a PDF. */
export interface Document {
  /** An input config specifying the content of the document. */
  inputConfig:
    | DocumentInputConfig
    | undefined;
  /** The plain text version of this document. */
  documentText:
    | TextSnippet
    | undefined;
  /**
   * Describes the layout of the document.
   * Sorted by [page_number][].
   */
  layout: Document_Layout[];
  /** The dimensions of the page in the document. */
  documentDimensions:
    | DocumentDimensions
    | undefined;
  /** Number of pages in the document. */
  pageCount: number;
}

/** Describes the layout information of a [text_segment][google.cloud.automl.v1beta1.Document.Layout.text_segment] in the document. */
export interface Document_Layout {
  /**
   * Text Segment that represents a segment in
   * [document_text][google.cloud.automl.v1beta1.Document.document_text].
   */
  textSegment:
    | TextSegment
    | undefined;
  /**
   * Page number of the [text_segment][google.cloud.automl.v1beta1.Document.Layout.text_segment] in the original document, starts
   * from 1.
   */
  pageNumber: number;
  /**
   * The position of the [text_segment][google.cloud.automl.v1beta1.Document.Layout.text_segment] in the page.
   * Contains exactly 4
   *
   * [normalized_vertices][google.cloud.automl.v1beta1.BoundingPoly.normalized_vertices]
   * and they are connected by edges in the order provided, which will
   * represent a rectangle parallel to the frame. The
   * [NormalizedVertex-s][google.cloud.automl.v1beta1.NormalizedVertex] are
   * relative to the page.
   * Coordinates are based on top-left as point (0,0).
   */
  boundingPoly:
    | BoundingPoly
    | undefined;
  /** The type of the [text_segment][google.cloud.automl.v1beta1.Document.Layout.text_segment] in document. */
  textSegmentType: Document_Layout_TextSegmentType;
}

/** The type of TextSegment in the context of the original document. */
export enum Document_Layout_TextSegmentType {
  /** TEXT_SEGMENT_TYPE_UNSPECIFIED - Should not be used. */
  TEXT_SEGMENT_TYPE_UNSPECIFIED = 0,
  /** TOKEN - The text segment is a token. e.g. word. */
  TOKEN = 1,
  /** PARAGRAPH - The text segment is a paragraph. */
  PARAGRAPH = 2,
  /** FORM_FIELD - The text segment is a form field. */
  FORM_FIELD = 3,
  /**
   * FORM_FIELD_NAME - The text segment is the name part of a form field. It will be treated
   * as child of another FORM_FIELD TextSegment if its span is subspan of
   * another TextSegment with type FORM_FIELD.
   */
  FORM_FIELD_NAME = 4,
  /**
   * FORM_FIELD_CONTENTS - The text segment is the text content part of a form field. It will be
   * treated as child of another FORM_FIELD TextSegment if its span is
   * subspan of another TextSegment with type FORM_FIELD.
   */
  FORM_FIELD_CONTENTS = 5,
  /** TABLE - The text segment is a whole table, including headers, and all rows. */
  TABLE = 6,
  /**
   * TABLE_HEADER - The text segment is a table's headers. It will be treated as child of
   * another TABLE TextSegment if its span is subspan of another TextSegment
   * with type TABLE.
   */
  TABLE_HEADER = 7,
  /**
   * TABLE_ROW - The text segment is a row in table. It will be treated as child of
   * another TABLE TextSegment if its span is subspan of another TextSegment
   * with type TABLE.
   */
  TABLE_ROW = 8,
  /**
   * TABLE_CELL - The text segment is a cell in table. It will be treated as child of
   * another TABLE_ROW TextSegment if its span is subspan of another
   * TextSegment with type TABLE_ROW.
   */
  TABLE_CELL = 9,
  UNRECOGNIZED = -1,
}

export function document_Layout_TextSegmentTypeFromJSON(object: any): Document_Layout_TextSegmentType {
  switch (object) {
    case 0:
    case "TEXT_SEGMENT_TYPE_UNSPECIFIED":
      return Document_Layout_TextSegmentType.TEXT_SEGMENT_TYPE_UNSPECIFIED;
    case 1:
    case "TOKEN":
      return Document_Layout_TextSegmentType.TOKEN;
    case 2:
    case "PARAGRAPH":
      return Document_Layout_TextSegmentType.PARAGRAPH;
    case 3:
    case "FORM_FIELD":
      return Document_Layout_TextSegmentType.FORM_FIELD;
    case 4:
    case "FORM_FIELD_NAME":
      return Document_Layout_TextSegmentType.FORM_FIELD_NAME;
    case 5:
    case "FORM_FIELD_CONTENTS":
      return Document_Layout_TextSegmentType.FORM_FIELD_CONTENTS;
    case 6:
    case "TABLE":
      return Document_Layout_TextSegmentType.TABLE;
    case 7:
    case "TABLE_HEADER":
      return Document_Layout_TextSegmentType.TABLE_HEADER;
    case 8:
    case "TABLE_ROW":
      return Document_Layout_TextSegmentType.TABLE_ROW;
    case 9:
    case "TABLE_CELL":
      return Document_Layout_TextSegmentType.TABLE_CELL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Document_Layout_TextSegmentType.UNRECOGNIZED;
  }
}

export function document_Layout_TextSegmentTypeToJSON(object: Document_Layout_TextSegmentType): string {
  switch (object) {
    case Document_Layout_TextSegmentType.TEXT_SEGMENT_TYPE_UNSPECIFIED:
      return "TEXT_SEGMENT_TYPE_UNSPECIFIED";
    case Document_Layout_TextSegmentType.TOKEN:
      return "TOKEN";
    case Document_Layout_TextSegmentType.PARAGRAPH:
      return "PARAGRAPH";
    case Document_Layout_TextSegmentType.FORM_FIELD:
      return "FORM_FIELD";
    case Document_Layout_TextSegmentType.FORM_FIELD_NAME:
      return "FORM_FIELD_NAME";
    case Document_Layout_TextSegmentType.FORM_FIELD_CONTENTS:
      return "FORM_FIELD_CONTENTS";
    case Document_Layout_TextSegmentType.TABLE:
      return "TABLE";
    case Document_Layout_TextSegmentType.TABLE_HEADER:
      return "TABLE_HEADER";
    case Document_Layout_TextSegmentType.TABLE_ROW:
      return "TABLE_ROW";
    case Document_Layout_TextSegmentType.TABLE_CELL:
      return "TABLE_CELL";
    case Document_Layout_TextSegmentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A representation of a row in a relational table. */
export interface Row {
  /**
   * The resource IDs of the column specs describing the columns of the row.
   * If set must contain, but possibly in a different order, all input
   * feature
   *
   * [column_spec_ids][google.cloud.automl.v1beta1.TablesModelMetadata.input_feature_column_specs]
   * of the Model this row is being passed to.
   * Note: The below `values` field must match order of this field, if this
   * field is set.
   */
  columnSpecIds: string[];
  /**
   * Required. The values of the row cells, given in the same order as the
   * column_spec_ids, or, if not set, then in the same order as input
   * feature
   *
   * [column_specs][google.cloud.automl.v1beta1.TablesModelMetadata.input_feature_column_specs]
   * of the Model this row is being passed to.
   */
  values: any[];
}

/** Example data used for training or prediction. */
export interface ExamplePayload {
  /** Example image. */
  image?:
    | Image
    | undefined;
  /** Example text. */
  textSnippet?:
    | TextSnippet
    | undefined;
  /** Example document. */
  document?:
    | Document
    | undefined;
  /** Example relational table row. */
  row?: Row | undefined;
}

function createBaseImage(): Image {
  return { imageBytes: undefined, inputConfig: undefined, thumbnailUri: "" };
}

export const Image: MessageFns<Image> = {
  encode(message: Image, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageBytes !== undefined) {
      writer.uint32(10).bytes(message.imageBytes);
    }
    if (message.inputConfig !== undefined) {
      InputConfig.encode(message.inputConfig, writer.uint32(50).fork()).join();
    }
    if (message.thumbnailUri !== "") {
      writer.uint32(34).string(message.thumbnailUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imageBytes = Buffer.from(reader.bytes());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inputConfig = InputConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.thumbnailUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Image {
    return {
      imageBytes: isSet(object.imageBytes) ? Buffer.from(bytesFromBase64(object.imageBytes)) : undefined,
      inputConfig: isSet(object.inputConfig) ? InputConfig.fromJSON(object.inputConfig) : undefined,
      thumbnailUri: isSet(object.thumbnailUri) ? globalThis.String(object.thumbnailUri) : "",
    };
  },

  toJSON(message: Image): unknown {
    const obj: any = {};
    if (message.imageBytes !== undefined) {
      obj.imageBytes = base64FromBytes(message.imageBytes);
    }
    if (message.inputConfig !== undefined) {
      obj.inputConfig = InputConfig.toJSON(message.inputConfig);
    }
    if (message.thumbnailUri !== "") {
      obj.thumbnailUri = message.thumbnailUri;
    }
    return obj;
  },

  create(base?: DeepPartial<Image>): Image {
    return Image.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Image>): Image {
    const message = createBaseImage();
    message.imageBytes = object.imageBytes ?? undefined;
    message.inputConfig = (object.inputConfig !== undefined && object.inputConfig !== null)
      ? InputConfig.fromPartial(object.inputConfig)
      : undefined;
    message.thumbnailUri = object.thumbnailUri ?? "";
    return message;
  },
};

function createBaseTextSnippet(): TextSnippet {
  return { content: "", mimeType: "", contentUri: "" };
}

export const TextSnippet: MessageFns<TextSnippet> = {
  encode(message: TextSnippet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    if (message.contentUri !== "") {
      writer.uint32(34).string(message.contentUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextSnippet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextSnippet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextSnippet {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      contentUri: isSet(object.contentUri) ? globalThis.String(object.contentUri) : "",
    };
  },

  toJSON(message: TextSnippet): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.contentUri !== "") {
      obj.contentUri = message.contentUri;
    }
    return obj;
  },

  create(base?: DeepPartial<TextSnippet>): TextSnippet {
    return TextSnippet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextSnippet>): TextSnippet {
    const message = createBaseTextSnippet();
    message.content = object.content ?? "";
    message.mimeType = object.mimeType ?? "";
    message.contentUri = object.contentUri ?? "";
    return message;
  },
};

function createBaseDocumentDimensions(): DocumentDimensions {
  return { unit: 0, width: 0, height: 0 };
}

export const DocumentDimensions: MessageFns<DocumentDimensions> = {
  encode(message: DocumentDimensions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unit !== 0) {
      writer.uint32(8).int32(message.unit);
    }
    if (message.width !== 0) {
      writer.uint32(21).float(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(29).float(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentDimensions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentDimensions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.unit = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.width = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.height = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentDimensions {
    return {
      unit: isSet(object.unit) ? documentDimensions_DocumentDimensionUnitFromJSON(object.unit) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: DocumentDimensions): unknown {
    const obj: any = {};
    if (message.unit !== 0) {
      obj.unit = documentDimensions_DocumentDimensionUnitToJSON(message.unit);
    }
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentDimensions>): DocumentDimensions {
    return DocumentDimensions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentDimensions>): DocumentDimensions {
    const message = createBaseDocumentDimensions();
    message.unit = object.unit ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseDocument(): Document {
  return { inputConfig: undefined, documentText: undefined, layout: [], documentDimensions: undefined, pageCount: 0 };
}

export const Document: MessageFns<Document> = {
  encode(message: Document, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputConfig !== undefined) {
      DocumentInputConfig.encode(message.inputConfig, writer.uint32(10).fork()).join();
    }
    if (message.documentText !== undefined) {
      TextSnippet.encode(message.documentText, writer.uint32(18).fork()).join();
    }
    for (const v of message.layout) {
      Document_Layout.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.documentDimensions !== undefined) {
      DocumentDimensions.encode(message.documentDimensions, writer.uint32(34).fork()).join();
    }
    if (message.pageCount !== 0) {
      writer.uint32(40).int32(message.pageCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputConfig = DocumentInputConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.documentText = TextSnippet.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.layout.push(Document_Layout.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.documentDimensions = DocumentDimensions.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.pageCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document {
    return {
      inputConfig: isSet(object.inputConfig) ? DocumentInputConfig.fromJSON(object.inputConfig) : undefined,
      documentText: isSet(object.documentText) ? TextSnippet.fromJSON(object.documentText) : undefined,
      layout: globalThis.Array.isArray(object?.layout)
        ? object.layout.map((e: any) => Document_Layout.fromJSON(e))
        : [],
      documentDimensions: isSet(object.documentDimensions)
        ? DocumentDimensions.fromJSON(object.documentDimensions)
        : undefined,
      pageCount: isSet(object.pageCount) ? globalThis.Number(object.pageCount) : 0,
    };
  },

  toJSON(message: Document): unknown {
    const obj: any = {};
    if (message.inputConfig !== undefined) {
      obj.inputConfig = DocumentInputConfig.toJSON(message.inputConfig);
    }
    if (message.documentText !== undefined) {
      obj.documentText = TextSnippet.toJSON(message.documentText);
    }
    if (message.layout?.length) {
      obj.layout = message.layout.map((e) => Document_Layout.toJSON(e));
    }
    if (message.documentDimensions !== undefined) {
      obj.documentDimensions = DocumentDimensions.toJSON(message.documentDimensions);
    }
    if (message.pageCount !== 0) {
      obj.pageCount = Math.round(message.pageCount);
    }
    return obj;
  },

  create(base?: DeepPartial<Document>): Document {
    return Document.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document>): Document {
    const message = createBaseDocument();
    message.inputConfig = (object.inputConfig !== undefined && object.inputConfig !== null)
      ? DocumentInputConfig.fromPartial(object.inputConfig)
      : undefined;
    message.documentText = (object.documentText !== undefined && object.documentText !== null)
      ? TextSnippet.fromPartial(object.documentText)
      : undefined;
    message.layout = object.layout?.map((e) => Document_Layout.fromPartial(e)) || [];
    message.documentDimensions = (object.documentDimensions !== undefined && object.documentDimensions !== null)
      ? DocumentDimensions.fromPartial(object.documentDimensions)
      : undefined;
    message.pageCount = object.pageCount ?? 0;
    return message;
  },
};

function createBaseDocument_Layout(): Document_Layout {
  return { textSegment: undefined, pageNumber: 0, boundingPoly: undefined, textSegmentType: 0 };
}

export const Document_Layout: MessageFns<Document_Layout> = {
  encode(message: Document_Layout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textSegment !== undefined) {
      TextSegment.encode(message.textSegment, writer.uint32(10).fork()).join();
    }
    if (message.pageNumber !== 0) {
      writer.uint32(16).int32(message.pageNumber);
    }
    if (message.boundingPoly !== undefined) {
      BoundingPoly.encode(message.boundingPoly, writer.uint32(26).fork()).join();
    }
    if (message.textSegmentType !== 0) {
      writer.uint32(32).int32(message.textSegmentType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Layout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Layout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textSegment = TextSegment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageNumber = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.boundingPoly = BoundingPoly.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.textSegmentType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Layout {
    return {
      textSegment: isSet(object.textSegment) ? TextSegment.fromJSON(object.textSegment) : undefined,
      pageNumber: isSet(object.pageNumber) ? globalThis.Number(object.pageNumber) : 0,
      boundingPoly: isSet(object.boundingPoly) ? BoundingPoly.fromJSON(object.boundingPoly) : undefined,
      textSegmentType: isSet(object.textSegmentType)
        ? document_Layout_TextSegmentTypeFromJSON(object.textSegmentType)
        : 0,
    };
  },

  toJSON(message: Document_Layout): unknown {
    const obj: any = {};
    if (message.textSegment !== undefined) {
      obj.textSegment = TextSegment.toJSON(message.textSegment);
    }
    if (message.pageNumber !== 0) {
      obj.pageNumber = Math.round(message.pageNumber);
    }
    if (message.boundingPoly !== undefined) {
      obj.boundingPoly = BoundingPoly.toJSON(message.boundingPoly);
    }
    if (message.textSegmentType !== 0) {
      obj.textSegmentType = document_Layout_TextSegmentTypeToJSON(message.textSegmentType);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Layout>): Document_Layout {
    return Document_Layout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Layout>): Document_Layout {
    const message = createBaseDocument_Layout();
    message.textSegment = (object.textSegment !== undefined && object.textSegment !== null)
      ? TextSegment.fromPartial(object.textSegment)
      : undefined;
    message.pageNumber = object.pageNumber ?? 0;
    message.boundingPoly = (object.boundingPoly !== undefined && object.boundingPoly !== null)
      ? BoundingPoly.fromPartial(object.boundingPoly)
      : undefined;
    message.textSegmentType = object.textSegmentType ?? 0;
    return message;
  },
};

function createBaseRow(): Row {
  return { columnSpecIds: [], values: [] };
}

export const Row: MessageFns<Row> = {
  encode(message: Row, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.columnSpecIds) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.values) {
      Value.encode(Value.wrap(v!), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Row {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.columnSpecIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.values.push(Value.unwrap(Value.decode(reader, reader.uint32())));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Row {
    return {
      columnSpecIds: globalThis.Array.isArray(object?.columnSpecIds)
        ? object.columnSpecIds.map((e: any) => globalThis.String(e))
        : [],
      values: globalThis.Array.isArray(object?.values) ? [...object.values] : [],
    };
  },

  toJSON(message: Row): unknown {
    const obj: any = {};
    if (message.columnSpecIds?.length) {
      obj.columnSpecIds = message.columnSpecIds;
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<Row>): Row {
    return Row.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Row>): Row {
    const message = createBaseRow();
    message.columnSpecIds = object.columnSpecIds?.map((e) => e) || [];
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseExamplePayload(): ExamplePayload {
  return { image: undefined, textSnippet: undefined, document: undefined, row: undefined };
}

export const ExamplePayload: MessageFns<ExamplePayload> = {
  encode(message: ExamplePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(10).fork()).join();
    }
    if (message.textSnippet !== undefined) {
      TextSnippet.encode(message.textSnippet, writer.uint32(18).fork()).join();
    }
    if (message.document !== undefined) {
      Document.encode(message.document, writer.uint32(34).fork()).join();
    }
    if (message.row !== undefined) {
      Row.encode(message.row, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExamplePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExamplePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textSnippet = TextSnippet.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.document = Document.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.row = Row.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExamplePayload {
    return {
      image: isSet(object.image) ? Image.fromJSON(object.image) : undefined,
      textSnippet: isSet(object.textSnippet) ? TextSnippet.fromJSON(object.textSnippet) : undefined,
      document: isSet(object.document) ? Document.fromJSON(object.document) : undefined,
      row: isSet(object.row) ? Row.fromJSON(object.row) : undefined,
    };
  },

  toJSON(message: ExamplePayload): unknown {
    const obj: any = {};
    if (message.image !== undefined) {
      obj.image = Image.toJSON(message.image);
    }
    if (message.textSnippet !== undefined) {
      obj.textSnippet = TextSnippet.toJSON(message.textSnippet);
    }
    if (message.document !== undefined) {
      obj.document = Document.toJSON(message.document);
    }
    if (message.row !== undefined) {
      obj.row = Row.toJSON(message.row);
    }
    return obj;
  },

  create(base?: DeepPartial<ExamplePayload>): ExamplePayload {
    return ExamplePayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExamplePayload>): ExamplePayload {
    const message = createBaseExamplePayload();
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    message.textSnippet = (object.textSnippet !== undefined && object.textSnippet !== null)
      ? TextSnippet.fromPartial(object.textSnippet)
      : undefined;
    message.document = (object.document !== undefined && object.document !== null)
      ? Document.fromPartial(object.document)
      : undefined;
    message.row = (object.row !== undefined && object.row !== null) ? Row.fromPartial(object.row) : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
