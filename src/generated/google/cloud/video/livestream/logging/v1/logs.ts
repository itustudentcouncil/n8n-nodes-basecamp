// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/video/livestream/logging/v1/logs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Status } from "../../../../../rpc/status.js";
import {
  Channel_StreamingState,
  channel_StreamingStateFromJSON,
  channel_StreamingStateToJSON,
  Event_State,
  event_StateFromJSON,
  event_StateToJSON,
} from "../../v1/resources.js";

export const protobufPackage = "google.cloud.video.livestream.logging.v1";

/** Logs of activities related to the Channels. */
export interface ChannelActivity {
  /** Message is for more details of the log and instructions to users. */
  message: string;
  /** The channel streaming state changes. */
  streamingStateChange?:
    | StreamingStateChange
    | undefined;
  /** An error happens with the video pipeline. */
  streamingError?:
    | StreamingError
    | undefined;
  /** The channel has accepted an input stream. */
  inputAccept?:
    | InputAccept
    | undefined;
  /** An error happens with the input stream. */
  inputError?:
    | InputError
    | undefined;
  /** An input stream disconnects. */
  inputDisconnect?:
    | InputDisconnect
    | undefined;
  /** An event state changes. */
  eventStateChange?:
    | EventStateChange
    | undefined;
  /** A SCTE35 command is received. */
  scte35CommandReceived?: Scte35Command | undefined;
}

/** StreamingStateChange records when the channel streaming state changes. */
export interface StreamingStateChange {
  /** New streaming state of the channel. */
  newState: Channel_StreamingState;
  /** Previous streaming state of the channel. */
  previousState: Channel_StreamingState;
}

/** StreamingError records when an error happens with the video pipeline. */
export interface StreamingError {
  /** A description of the reason for the streaming error. */
  error: Status | undefined;
}

/** InputAccept records when the channel has accepted an input stream. */
export interface InputAccept {
  /** ID of the input stream. */
  streamId: string;
  /** The user-defined key for the input attachment. */
  inputAttachment: string;
  /** Properties of the input stream. */
  inputStreamProperty: InputStreamProperty | undefined;
}

/** InputError records when an error happens with the input stream. */
export interface InputError {
  /** ID of the input stream. */
  streamId: string;
  /**
   * The user-defined key for the input attachment. If the stream doesnâ€™t belong
   * to any input attachment, this field is empty.
   */
  inputAttachment: string;
  /** Properties of the input stream. */
  inputStreamProperty:
    | InputStreamProperty
    | undefined;
  /** A description of the reason for the error with the input stream. */
  error: Status | undefined;
}

/** Properties of the input stream. */
export interface InputStreamProperty {
  /** Properties of the video streams. */
  videoStreams: VideoStream[];
  /** Properties of the audio streams. */
  audioStreams: AudioStream[];
}

/** Properties of the video stream. */
export interface VideoStream {
  /** Index of this video stream. */
  index: number;
  /** Properties of the video format. */
  videoFormat: VideoFormat | undefined;
}

/** Properties of the video format. */
export interface VideoFormat {
  /** Video codec used in this video stream. */
  codec: string;
  /** The width of the video stream in pixels. */
  widthPixels: number;
  /** The height of the video stream in pixels. */
  heightPixels: number;
  /** The frame rate of the input video stream. */
  frameRate: number;
}

/** Properties of the audio stream. */
export interface AudioStream {
  /** Index of this audio stream. */
  index: number;
  /** Properties of the audio format. */
  audioFormat: AudioFormat | undefined;
}

/** Properties of the audio format. */
export interface AudioFormat {
  /** Audio codec used in this audio stream. */
  codec: string;
  /** The number of audio channels. */
  channelCount: number;
  /** A list of channel names specifying the layout of the audio channels. */
  channelLayout: string[];
}

/** InputDisconnect records when an input stream disconnects. */
export interface InputDisconnect {
  /** ID of the input stream. */
  streamId: string;
  /** The user-defined key for the input attachment. */
  inputAttachment: string;
}

/** EventStateChange records when an Event state changes. */
export interface EventStateChange {
  /** Resource name of the event. */
  eventId: string;
  /** New state of the event. */
  newState: Event_State;
  /** Previous state of the event. */
  previousState: Event_State;
}

/** Scte35Command includes details of a received SCTE35 command. */
export interface Scte35Command {
  /** Information about the splice insert. */
  spliceInfoSection: Scte35Command_SpliceInfoSection | undefined;
}

/**
 * SpliceTime contains information about the execution time of the splice
 * insert.
 */
export interface Scte35Command_SpliceTime {
  /** If true, the execution time of the splice insert is specified. */
  timeSpecifiedFlag: boolean;
  /** The time of the splice insert. */
  ptsTime: Long;
}

/**
 * BreakDuration contains information about the duration of the splice
 * insert.
 */
export interface Scte35Command_BreakDuration {
  /** If true, the splice insert will automatically return upon finishing. */
  autoReturn: boolean;
  /** Duration of the splice insert. */
  duration: Long;
}

/**
 * Fine grained control on the scte command insertion for a specific
 * elementary stream. This is ignored if program_splice_flag is true.
 */
export interface Scte35Command_Component {
  /** Elementary stream PID that the scte command should be inserted into. */
  componentTag: number;
  /** The time of the insert. */
  spliceTime: Scte35Command_SpliceTime | undefined;
}

/** SpliceInsert contains information about the splice insert. */
export interface Scte35Command_SpliceInsert {
  /** Event ID of the scte command. */
  spliceEventId: number;
  /** Whether this scte command is to cancel another scheduled scte command. */
  spliceEventCancelIndicator: boolean;
  /** Whether this scte command is cueing out the current program. */
  outOfNetworkIndicator: boolean;
  /** If true, send splice insert to all streams. */
  programSpliceFlag: boolean;
  /** If true, the duration of the event is specified. */
  durationFlag: boolean;
  /** If true, the event should be executed immediately. */
  spliceImmediateFlag: boolean;
  /** Information about the execution time of the splice insert. */
  spliceTime:
    | Scte35Command_SpliceTime
    | undefined;
  /** Information about the duration of the splice insert. */
  breakDuration:
    | Scte35Command_BreakDuration
    | undefined;
  /** Unique ID for a viewing event. */
  uniqueProgramId: number;
  /** ID for an avail within one unique_program_id. */
  availNum: number;
  /** The number of avails within the current viewing event. */
  availsExpected: number;
  /** Number of components. */
  componentCount: number;
  /** Components of the program. */
  components: Scte35Command_Component[];
}

/** SpliceInfoSection contains information about the splice insert. */
export interface Scte35Command_SpliceInfoSection {
  /**
   * Overflow of pts_time, when pts_time doesn't have enough bits
   * to represent the time.
   */
  ptsAdjustment: Long;
  /** Information about the splice insert. */
  spliceInsert: Scte35Command_SpliceInsert | undefined;
}

function createBaseChannelActivity(): ChannelActivity {
  return {
    message: "",
    streamingStateChange: undefined,
    streamingError: undefined,
    inputAccept: undefined,
    inputError: undefined,
    inputDisconnect: undefined,
    eventStateChange: undefined,
    scte35CommandReceived: undefined,
  };
}

export const ChannelActivity: MessageFns<ChannelActivity> = {
  encode(message: ChannelActivity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.streamingStateChange !== undefined) {
      StreamingStateChange.encode(message.streamingStateChange, writer.uint32(18).fork()).join();
    }
    if (message.streamingError !== undefined) {
      StreamingError.encode(message.streamingError, writer.uint32(26).fork()).join();
    }
    if (message.inputAccept !== undefined) {
      InputAccept.encode(message.inputAccept, writer.uint32(34).fork()).join();
    }
    if (message.inputError !== undefined) {
      InputError.encode(message.inputError, writer.uint32(42).fork()).join();
    }
    if (message.inputDisconnect !== undefined) {
      InputDisconnect.encode(message.inputDisconnect, writer.uint32(50).fork()).join();
    }
    if (message.eventStateChange !== undefined) {
      EventStateChange.encode(message.eventStateChange, writer.uint32(58).fork()).join();
    }
    if (message.scte35CommandReceived !== undefined) {
      Scte35Command.encode(message.scte35CommandReceived, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelActivity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelActivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.streamingStateChange = StreamingStateChange.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.streamingError = StreamingError.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.inputAccept = InputAccept.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inputError = InputError.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inputDisconnect = InputDisconnect.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.eventStateChange = EventStateChange.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.scte35CommandReceived = Scte35Command.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelActivity {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      streamingStateChange: isSet(object.streamingStateChange)
        ? StreamingStateChange.fromJSON(object.streamingStateChange)
        : undefined,
      streamingError: isSet(object.streamingError) ? StreamingError.fromJSON(object.streamingError) : undefined,
      inputAccept: isSet(object.inputAccept) ? InputAccept.fromJSON(object.inputAccept) : undefined,
      inputError: isSet(object.inputError) ? InputError.fromJSON(object.inputError) : undefined,
      inputDisconnect: isSet(object.inputDisconnect) ? InputDisconnect.fromJSON(object.inputDisconnect) : undefined,
      eventStateChange: isSet(object.eventStateChange) ? EventStateChange.fromJSON(object.eventStateChange) : undefined,
      scte35CommandReceived: isSet(object.scte35CommandReceived)
        ? Scte35Command.fromJSON(object.scte35CommandReceived)
        : undefined,
    };
  },

  toJSON(message: ChannelActivity): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.streamingStateChange !== undefined) {
      obj.streamingStateChange = StreamingStateChange.toJSON(message.streamingStateChange);
    }
    if (message.streamingError !== undefined) {
      obj.streamingError = StreamingError.toJSON(message.streamingError);
    }
    if (message.inputAccept !== undefined) {
      obj.inputAccept = InputAccept.toJSON(message.inputAccept);
    }
    if (message.inputError !== undefined) {
      obj.inputError = InputError.toJSON(message.inputError);
    }
    if (message.inputDisconnect !== undefined) {
      obj.inputDisconnect = InputDisconnect.toJSON(message.inputDisconnect);
    }
    if (message.eventStateChange !== undefined) {
      obj.eventStateChange = EventStateChange.toJSON(message.eventStateChange);
    }
    if (message.scte35CommandReceived !== undefined) {
      obj.scte35CommandReceived = Scte35Command.toJSON(message.scte35CommandReceived);
    }
    return obj;
  },

  create(base?: DeepPartial<ChannelActivity>): ChannelActivity {
    return ChannelActivity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChannelActivity>): ChannelActivity {
    const message = createBaseChannelActivity();
    message.message = object.message ?? "";
    message.streamingStateChange = (object.streamingStateChange !== undefined && object.streamingStateChange !== null)
      ? StreamingStateChange.fromPartial(object.streamingStateChange)
      : undefined;
    message.streamingError = (object.streamingError !== undefined && object.streamingError !== null)
      ? StreamingError.fromPartial(object.streamingError)
      : undefined;
    message.inputAccept = (object.inputAccept !== undefined && object.inputAccept !== null)
      ? InputAccept.fromPartial(object.inputAccept)
      : undefined;
    message.inputError = (object.inputError !== undefined && object.inputError !== null)
      ? InputError.fromPartial(object.inputError)
      : undefined;
    message.inputDisconnect = (object.inputDisconnect !== undefined && object.inputDisconnect !== null)
      ? InputDisconnect.fromPartial(object.inputDisconnect)
      : undefined;
    message.eventStateChange = (object.eventStateChange !== undefined && object.eventStateChange !== null)
      ? EventStateChange.fromPartial(object.eventStateChange)
      : undefined;
    message.scte35CommandReceived =
      (object.scte35CommandReceived !== undefined && object.scte35CommandReceived !== null)
        ? Scte35Command.fromPartial(object.scte35CommandReceived)
        : undefined;
    return message;
  },
};

function createBaseStreamingStateChange(): StreamingStateChange {
  return { newState: 0, previousState: 0 };
}

export const StreamingStateChange: MessageFns<StreamingStateChange> = {
  encode(message: StreamingStateChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newState !== 0) {
      writer.uint32(8).int32(message.newState);
    }
    if (message.previousState !== 0) {
      writer.uint32(16).int32(message.previousState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingStateChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingStateChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.newState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.previousState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingStateChange {
    return {
      newState: isSet(object.newState) ? channel_StreamingStateFromJSON(object.newState) : 0,
      previousState: isSet(object.previousState) ? channel_StreamingStateFromJSON(object.previousState) : 0,
    };
  },

  toJSON(message: StreamingStateChange): unknown {
    const obj: any = {};
    if (message.newState !== 0) {
      obj.newState = channel_StreamingStateToJSON(message.newState);
    }
    if (message.previousState !== 0) {
      obj.previousState = channel_StreamingStateToJSON(message.previousState);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingStateChange>): StreamingStateChange {
    return StreamingStateChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingStateChange>): StreamingStateChange {
    const message = createBaseStreamingStateChange();
    message.newState = object.newState ?? 0;
    message.previousState = object.previousState ?? 0;
    return message;
  },
};

function createBaseStreamingError(): StreamingError {
  return { error: undefined };
}

export const StreamingError: MessageFns<StreamingError> = {
  encode(message: StreamingError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingError {
    return { error: isSet(object.error) ? Status.fromJSON(object.error) : undefined };
  },

  toJSON(message: StreamingError): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingError>): StreamingError {
    return StreamingError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingError>): StreamingError {
    const message = createBaseStreamingError();
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseInputAccept(): InputAccept {
  return { streamId: "", inputAttachment: "", inputStreamProperty: undefined };
}

export const InputAccept: MessageFns<InputAccept> = {
  encode(message: InputAccept, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streamId !== "") {
      writer.uint32(10).string(message.streamId);
    }
    if (message.inputAttachment !== "") {
      writer.uint32(18).string(message.inputAttachment);
    }
    if (message.inputStreamProperty !== undefined) {
      InputStreamProperty.encode(message.inputStreamProperty, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputAccept {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputAccept();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streamId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputAttachment = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inputStreamProperty = InputStreamProperty.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputAccept {
    return {
      streamId: isSet(object.streamId) ? globalThis.String(object.streamId) : "",
      inputAttachment: isSet(object.inputAttachment) ? globalThis.String(object.inputAttachment) : "",
      inputStreamProperty: isSet(object.inputStreamProperty)
        ? InputStreamProperty.fromJSON(object.inputStreamProperty)
        : undefined,
    };
  },

  toJSON(message: InputAccept): unknown {
    const obj: any = {};
    if (message.streamId !== "") {
      obj.streamId = message.streamId;
    }
    if (message.inputAttachment !== "") {
      obj.inputAttachment = message.inputAttachment;
    }
    if (message.inputStreamProperty !== undefined) {
      obj.inputStreamProperty = InputStreamProperty.toJSON(message.inputStreamProperty);
    }
    return obj;
  },

  create(base?: DeepPartial<InputAccept>): InputAccept {
    return InputAccept.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputAccept>): InputAccept {
    const message = createBaseInputAccept();
    message.streamId = object.streamId ?? "";
    message.inputAttachment = object.inputAttachment ?? "";
    message.inputStreamProperty = (object.inputStreamProperty !== undefined && object.inputStreamProperty !== null)
      ? InputStreamProperty.fromPartial(object.inputStreamProperty)
      : undefined;
    return message;
  },
};

function createBaseInputError(): InputError {
  return { streamId: "", inputAttachment: "", inputStreamProperty: undefined, error: undefined };
}

export const InputError: MessageFns<InputError> = {
  encode(message: InputError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streamId !== "") {
      writer.uint32(10).string(message.streamId);
    }
    if (message.inputAttachment !== "") {
      writer.uint32(18).string(message.inputAttachment);
    }
    if (message.inputStreamProperty !== undefined) {
      InputStreamProperty.encode(message.inputStreamProperty, writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streamId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputAttachment = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inputStreamProperty = InputStreamProperty.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputError {
    return {
      streamId: isSet(object.streamId) ? globalThis.String(object.streamId) : "",
      inputAttachment: isSet(object.inputAttachment) ? globalThis.String(object.inputAttachment) : "",
      inputStreamProperty: isSet(object.inputStreamProperty)
        ? InputStreamProperty.fromJSON(object.inputStreamProperty)
        : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: InputError): unknown {
    const obj: any = {};
    if (message.streamId !== "") {
      obj.streamId = message.streamId;
    }
    if (message.inputAttachment !== "") {
      obj.inputAttachment = message.inputAttachment;
    }
    if (message.inputStreamProperty !== undefined) {
      obj.inputStreamProperty = InputStreamProperty.toJSON(message.inputStreamProperty);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<InputError>): InputError {
    return InputError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputError>): InputError {
    const message = createBaseInputError();
    message.streamId = object.streamId ?? "";
    message.inputAttachment = object.inputAttachment ?? "";
    message.inputStreamProperty = (object.inputStreamProperty !== undefined && object.inputStreamProperty !== null)
      ? InputStreamProperty.fromPartial(object.inputStreamProperty)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseInputStreamProperty(): InputStreamProperty {
  return { videoStreams: [], audioStreams: [] };
}

export const InputStreamProperty: MessageFns<InputStreamProperty> = {
  encode(message: InputStreamProperty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.videoStreams) {
      VideoStream.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.audioStreams) {
      AudioStream.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputStreamProperty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputStreamProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.videoStreams.push(VideoStream.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audioStreams.push(AudioStream.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputStreamProperty {
    return {
      videoStreams: globalThis.Array.isArray(object?.videoStreams)
        ? object.videoStreams.map((e: any) => VideoStream.fromJSON(e))
        : [],
      audioStreams: globalThis.Array.isArray(object?.audioStreams)
        ? object.audioStreams.map((e: any) => AudioStream.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InputStreamProperty): unknown {
    const obj: any = {};
    if (message.videoStreams?.length) {
      obj.videoStreams = message.videoStreams.map((e) => VideoStream.toJSON(e));
    }
    if (message.audioStreams?.length) {
      obj.audioStreams = message.audioStreams.map((e) => AudioStream.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<InputStreamProperty>): InputStreamProperty {
    return InputStreamProperty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputStreamProperty>): InputStreamProperty {
    const message = createBaseInputStreamProperty();
    message.videoStreams = object.videoStreams?.map((e) => VideoStream.fromPartial(e)) || [];
    message.audioStreams = object.audioStreams?.map((e) => AudioStream.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVideoStream(): VideoStream {
  return { index: 0, videoFormat: undefined };
}

export const VideoStream: MessageFns<VideoStream> = {
  encode(message: VideoStream, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.videoFormat !== undefined) {
      VideoFormat.encode(message.videoFormat, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoStream {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.videoFormat = VideoFormat.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoStream {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      videoFormat: isSet(object.videoFormat) ? VideoFormat.fromJSON(object.videoFormat) : undefined,
    };
  },

  toJSON(message: VideoStream): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.videoFormat !== undefined) {
      obj.videoFormat = VideoFormat.toJSON(message.videoFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<VideoStream>): VideoStream {
    return VideoStream.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoStream>): VideoStream {
    const message = createBaseVideoStream();
    message.index = object.index ?? 0;
    message.videoFormat = (object.videoFormat !== undefined && object.videoFormat !== null)
      ? VideoFormat.fromPartial(object.videoFormat)
      : undefined;
    return message;
  },
};

function createBaseVideoFormat(): VideoFormat {
  return { codec: "", widthPixels: 0, heightPixels: 0, frameRate: 0 };
}

export const VideoFormat: MessageFns<VideoFormat> = {
  encode(message: VideoFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codec !== "") {
      writer.uint32(10).string(message.codec);
    }
    if (message.widthPixels !== 0) {
      writer.uint32(16).int32(message.widthPixels);
    }
    if (message.heightPixels !== 0) {
      writer.uint32(24).int32(message.heightPixels);
    }
    if (message.frameRate !== 0) {
      writer.uint32(33).double(message.frameRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.codec = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.widthPixels = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heightPixels = reader.int32();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.frameRate = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoFormat {
    return {
      codec: isSet(object.codec) ? globalThis.String(object.codec) : "",
      widthPixels: isSet(object.widthPixels) ? globalThis.Number(object.widthPixels) : 0,
      heightPixels: isSet(object.heightPixels) ? globalThis.Number(object.heightPixels) : 0,
      frameRate: isSet(object.frameRate) ? globalThis.Number(object.frameRate) : 0,
    };
  },

  toJSON(message: VideoFormat): unknown {
    const obj: any = {};
    if (message.codec !== "") {
      obj.codec = message.codec;
    }
    if (message.widthPixels !== 0) {
      obj.widthPixels = Math.round(message.widthPixels);
    }
    if (message.heightPixels !== 0) {
      obj.heightPixels = Math.round(message.heightPixels);
    }
    if (message.frameRate !== 0) {
      obj.frameRate = message.frameRate;
    }
    return obj;
  },

  create(base?: DeepPartial<VideoFormat>): VideoFormat {
    return VideoFormat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoFormat>): VideoFormat {
    const message = createBaseVideoFormat();
    message.codec = object.codec ?? "";
    message.widthPixels = object.widthPixels ?? 0;
    message.heightPixels = object.heightPixels ?? 0;
    message.frameRate = object.frameRate ?? 0;
    return message;
  },
};

function createBaseAudioStream(): AudioStream {
  return { index: 0, audioFormat: undefined };
}

export const AudioStream: MessageFns<AudioStream> = {
  encode(message: AudioStream, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.audioFormat !== undefined) {
      AudioFormat.encode(message.audioFormat, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioStream {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audioFormat = AudioFormat.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioStream {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      audioFormat: isSet(object.audioFormat) ? AudioFormat.fromJSON(object.audioFormat) : undefined,
    };
  },

  toJSON(message: AudioStream): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.audioFormat !== undefined) {
      obj.audioFormat = AudioFormat.toJSON(message.audioFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<AudioStream>): AudioStream {
    return AudioStream.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudioStream>): AudioStream {
    const message = createBaseAudioStream();
    message.index = object.index ?? 0;
    message.audioFormat = (object.audioFormat !== undefined && object.audioFormat !== null)
      ? AudioFormat.fromPartial(object.audioFormat)
      : undefined;
    return message;
  },
};

function createBaseAudioFormat(): AudioFormat {
  return { codec: "", channelCount: 0, channelLayout: [] };
}

export const AudioFormat: MessageFns<AudioFormat> = {
  encode(message: AudioFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codec !== "") {
      writer.uint32(10).string(message.codec);
    }
    if (message.channelCount !== 0) {
      writer.uint32(16).int32(message.channelCount);
    }
    for (const v of message.channelLayout) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.codec = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channelCount = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channelLayout.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioFormat {
    return {
      codec: isSet(object.codec) ? globalThis.String(object.codec) : "",
      channelCount: isSet(object.channelCount) ? globalThis.Number(object.channelCount) : 0,
      channelLayout: globalThis.Array.isArray(object?.channelLayout)
        ? object.channelLayout.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AudioFormat): unknown {
    const obj: any = {};
    if (message.codec !== "") {
      obj.codec = message.codec;
    }
    if (message.channelCount !== 0) {
      obj.channelCount = Math.round(message.channelCount);
    }
    if (message.channelLayout?.length) {
      obj.channelLayout = message.channelLayout;
    }
    return obj;
  },

  create(base?: DeepPartial<AudioFormat>): AudioFormat {
    return AudioFormat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudioFormat>): AudioFormat {
    const message = createBaseAudioFormat();
    message.codec = object.codec ?? "";
    message.channelCount = object.channelCount ?? 0;
    message.channelLayout = object.channelLayout?.map((e) => e) || [];
    return message;
  },
};

function createBaseInputDisconnect(): InputDisconnect {
  return { streamId: "", inputAttachment: "" };
}

export const InputDisconnect: MessageFns<InputDisconnect> = {
  encode(message: InputDisconnect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streamId !== "") {
      writer.uint32(10).string(message.streamId);
    }
    if (message.inputAttachment !== "") {
      writer.uint32(18).string(message.inputAttachment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputDisconnect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputDisconnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streamId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputAttachment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputDisconnect {
    return {
      streamId: isSet(object.streamId) ? globalThis.String(object.streamId) : "",
      inputAttachment: isSet(object.inputAttachment) ? globalThis.String(object.inputAttachment) : "",
    };
  },

  toJSON(message: InputDisconnect): unknown {
    const obj: any = {};
    if (message.streamId !== "") {
      obj.streamId = message.streamId;
    }
    if (message.inputAttachment !== "") {
      obj.inputAttachment = message.inputAttachment;
    }
    return obj;
  },

  create(base?: DeepPartial<InputDisconnect>): InputDisconnect {
    return InputDisconnect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputDisconnect>): InputDisconnect {
    const message = createBaseInputDisconnect();
    message.streamId = object.streamId ?? "";
    message.inputAttachment = object.inputAttachment ?? "";
    return message;
  },
};

function createBaseEventStateChange(): EventStateChange {
  return { eventId: "", newState: 0, previousState: 0 };
}

export const EventStateChange: MessageFns<EventStateChange> = {
  encode(message: EventStateChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.newState !== 0) {
      writer.uint32(16).int32(message.newState);
    }
    if (message.previousState !== 0) {
      writer.uint32(24).int32(message.previousState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventStateChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventStateChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.newState = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.previousState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventStateChange {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      newState: isSet(object.newState) ? event_StateFromJSON(object.newState) : 0,
      previousState: isSet(object.previousState) ? event_StateFromJSON(object.previousState) : 0,
    };
  },

  toJSON(message: EventStateChange): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.newState !== 0) {
      obj.newState = event_StateToJSON(message.newState);
    }
    if (message.previousState !== 0) {
      obj.previousState = event_StateToJSON(message.previousState);
    }
    return obj;
  },

  create(base?: DeepPartial<EventStateChange>): EventStateChange {
    return EventStateChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventStateChange>): EventStateChange {
    const message = createBaseEventStateChange();
    message.eventId = object.eventId ?? "";
    message.newState = object.newState ?? 0;
    message.previousState = object.previousState ?? 0;
    return message;
  },
};

function createBaseScte35Command(): Scte35Command {
  return { spliceInfoSection: undefined };
}

export const Scte35Command: MessageFns<Scte35Command> = {
  encode(message: Scte35Command, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.spliceInfoSection !== undefined) {
      Scte35Command_SpliceInfoSection.encode(message.spliceInfoSection, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scte35Command {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScte35Command();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.spliceInfoSection = Scte35Command_SpliceInfoSection.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scte35Command {
    return {
      spliceInfoSection: isSet(object.spliceInfoSection)
        ? Scte35Command_SpliceInfoSection.fromJSON(object.spliceInfoSection)
        : undefined,
    };
  },

  toJSON(message: Scte35Command): unknown {
    const obj: any = {};
    if (message.spliceInfoSection !== undefined) {
      obj.spliceInfoSection = Scte35Command_SpliceInfoSection.toJSON(message.spliceInfoSection);
    }
    return obj;
  },

  create(base?: DeepPartial<Scte35Command>): Scte35Command {
    return Scte35Command.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Scte35Command>): Scte35Command {
    const message = createBaseScte35Command();
    message.spliceInfoSection = (object.spliceInfoSection !== undefined && object.spliceInfoSection !== null)
      ? Scte35Command_SpliceInfoSection.fromPartial(object.spliceInfoSection)
      : undefined;
    return message;
  },
};

function createBaseScte35Command_SpliceTime(): Scte35Command_SpliceTime {
  return { timeSpecifiedFlag: false, ptsTime: Long.ZERO };
}

export const Scte35Command_SpliceTime: MessageFns<Scte35Command_SpliceTime> = {
  encode(message: Scte35Command_SpliceTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeSpecifiedFlag !== false) {
      writer.uint32(8).bool(message.timeSpecifiedFlag);
    }
    if (!message.ptsTime.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.ptsTime.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scte35Command_SpliceTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScte35Command_SpliceTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.timeSpecifiedFlag = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ptsTime = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scte35Command_SpliceTime {
    return {
      timeSpecifiedFlag: isSet(object.timeSpecifiedFlag) ? globalThis.Boolean(object.timeSpecifiedFlag) : false,
      ptsTime: isSet(object.ptsTime) ? Long.fromValue(object.ptsTime) : Long.ZERO,
    };
  },

  toJSON(message: Scte35Command_SpliceTime): unknown {
    const obj: any = {};
    if (message.timeSpecifiedFlag !== false) {
      obj.timeSpecifiedFlag = message.timeSpecifiedFlag;
    }
    if (!message.ptsTime.equals(Long.ZERO)) {
      obj.ptsTime = (message.ptsTime || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Scte35Command_SpliceTime>): Scte35Command_SpliceTime {
    return Scte35Command_SpliceTime.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Scte35Command_SpliceTime>): Scte35Command_SpliceTime {
    const message = createBaseScte35Command_SpliceTime();
    message.timeSpecifiedFlag = object.timeSpecifiedFlag ?? false;
    message.ptsTime = (object.ptsTime !== undefined && object.ptsTime !== null)
      ? Long.fromValue(object.ptsTime)
      : Long.ZERO;
    return message;
  },
};

function createBaseScte35Command_BreakDuration(): Scte35Command_BreakDuration {
  return { autoReturn: false, duration: Long.ZERO };
}

export const Scte35Command_BreakDuration: MessageFns<Scte35Command_BreakDuration> = {
  encode(message: Scte35Command_BreakDuration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.autoReturn !== false) {
      writer.uint32(8).bool(message.autoReturn);
    }
    if (!message.duration.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.duration.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scte35Command_BreakDuration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScte35Command_BreakDuration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.autoReturn = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.duration = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scte35Command_BreakDuration {
    return {
      autoReturn: isSet(object.autoReturn) ? globalThis.Boolean(object.autoReturn) : false,
      duration: isSet(object.duration) ? Long.fromValue(object.duration) : Long.ZERO,
    };
  },

  toJSON(message: Scte35Command_BreakDuration): unknown {
    const obj: any = {};
    if (message.autoReturn !== false) {
      obj.autoReturn = message.autoReturn;
    }
    if (!message.duration.equals(Long.ZERO)) {
      obj.duration = (message.duration || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Scte35Command_BreakDuration>): Scte35Command_BreakDuration {
    return Scte35Command_BreakDuration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Scte35Command_BreakDuration>): Scte35Command_BreakDuration {
    const message = createBaseScte35Command_BreakDuration();
    message.autoReturn = object.autoReturn ?? false;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Long.fromValue(object.duration)
      : Long.ZERO;
    return message;
  },
};

function createBaseScte35Command_Component(): Scte35Command_Component {
  return { componentTag: 0, spliceTime: undefined };
}

export const Scte35Command_Component: MessageFns<Scte35Command_Component> = {
  encode(message: Scte35Command_Component, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.componentTag !== 0) {
      writer.uint32(8).int32(message.componentTag);
    }
    if (message.spliceTime !== undefined) {
      Scte35Command_SpliceTime.encode(message.spliceTime, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scte35Command_Component {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScte35Command_Component();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.componentTag = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spliceTime = Scte35Command_SpliceTime.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scte35Command_Component {
    return {
      componentTag: isSet(object.componentTag) ? globalThis.Number(object.componentTag) : 0,
      spliceTime: isSet(object.spliceTime) ? Scte35Command_SpliceTime.fromJSON(object.spliceTime) : undefined,
    };
  },

  toJSON(message: Scte35Command_Component): unknown {
    const obj: any = {};
    if (message.componentTag !== 0) {
      obj.componentTag = Math.round(message.componentTag);
    }
    if (message.spliceTime !== undefined) {
      obj.spliceTime = Scte35Command_SpliceTime.toJSON(message.spliceTime);
    }
    return obj;
  },

  create(base?: DeepPartial<Scte35Command_Component>): Scte35Command_Component {
    return Scte35Command_Component.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Scte35Command_Component>): Scte35Command_Component {
    const message = createBaseScte35Command_Component();
    message.componentTag = object.componentTag ?? 0;
    message.spliceTime = (object.spliceTime !== undefined && object.spliceTime !== null)
      ? Scte35Command_SpliceTime.fromPartial(object.spliceTime)
      : undefined;
    return message;
  },
};

function createBaseScte35Command_SpliceInsert(): Scte35Command_SpliceInsert {
  return {
    spliceEventId: 0,
    spliceEventCancelIndicator: false,
    outOfNetworkIndicator: false,
    programSpliceFlag: false,
    durationFlag: false,
    spliceImmediateFlag: false,
    spliceTime: undefined,
    breakDuration: undefined,
    uniqueProgramId: 0,
    availNum: 0,
    availsExpected: 0,
    componentCount: 0,
    components: [],
  };
}

export const Scte35Command_SpliceInsert: MessageFns<Scte35Command_SpliceInsert> = {
  encode(message: Scte35Command_SpliceInsert, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.spliceEventId !== 0) {
      writer.uint32(8).int32(message.spliceEventId);
    }
    if (message.spliceEventCancelIndicator !== false) {
      writer.uint32(16).bool(message.spliceEventCancelIndicator);
    }
    if (message.outOfNetworkIndicator !== false) {
      writer.uint32(24).bool(message.outOfNetworkIndicator);
    }
    if (message.programSpliceFlag !== false) {
      writer.uint32(32).bool(message.programSpliceFlag);
    }
    if (message.durationFlag !== false) {
      writer.uint32(40).bool(message.durationFlag);
    }
    if (message.spliceImmediateFlag !== false) {
      writer.uint32(48).bool(message.spliceImmediateFlag);
    }
    if (message.spliceTime !== undefined) {
      Scte35Command_SpliceTime.encode(message.spliceTime, writer.uint32(58).fork()).join();
    }
    if (message.breakDuration !== undefined) {
      Scte35Command_BreakDuration.encode(message.breakDuration, writer.uint32(66).fork()).join();
    }
    if (message.uniqueProgramId !== 0) {
      writer.uint32(72).int32(message.uniqueProgramId);
    }
    if (message.availNum !== 0) {
      writer.uint32(80).int32(message.availNum);
    }
    if (message.availsExpected !== 0) {
      writer.uint32(88).int32(message.availsExpected);
    }
    if (message.componentCount !== 0) {
      writer.uint32(96).int32(message.componentCount);
    }
    for (const v of message.components) {
      Scte35Command_Component.encode(v!, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scte35Command_SpliceInsert {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScte35Command_SpliceInsert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.spliceEventId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.spliceEventCancelIndicator = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.outOfNetworkIndicator = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.programSpliceFlag = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.durationFlag = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.spliceImmediateFlag = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.spliceTime = Scte35Command_SpliceTime.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.breakDuration = Scte35Command_BreakDuration.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.uniqueProgramId = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.availNum = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.availsExpected = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.componentCount = reader.int32();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.components.push(Scte35Command_Component.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scte35Command_SpliceInsert {
    return {
      spliceEventId: isSet(object.spliceEventId) ? globalThis.Number(object.spliceEventId) : 0,
      spliceEventCancelIndicator: isSet(object.spliceEventCancelIndicator)
        ? globalThis.Boolean(object.spliceEventCancelIndicator)
        : false,
      outOfNetworkIndicator: isSet(object.outOfNetworkIndicator)
        ? globalThis.Boolean(object.outOfNetworkIndicator)
        : false,
      programSpliceFlag: isSet(object.programSpliceFlag) ? globalThis.Boolean(object.programSpliceFlag) : false,
      durationFlag: isSet(object.durationFlag) ? globalThis.Boolean(object.durationFlag) : false,
      spliceImmediateFlag: isSet(object.spliceImmediateFlag) ? globalThis.Boolean(object.spliceImmediateFlag) : false,
      spliceTime: isSet(object.spliceTime) ? Scte35Command_SpliceTime.fromJSON(object.spliceTime) : undefined,
      breakDuration: isSet(object.breakDuration)
        ? Scte35Command_BreakDuration.fromJSON(object.breakDuration)
        : undefined,
      uniqueProgramId: isSet(object.uniqueProgramId) ? globalThis.Number(object.uniqueProgramId) : 0,
      availNum: isSet(object.availNum) ? globalThis.Number(object.availNum) : 0,
      availsExpected: isSet(object.availsExpected) ? globalThis.Number(object.availsExpected) : 0,
      componentCount: isSet(object.componentCount) ? globalThis.Number(object.componentCount) : 0,
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => Scte35Command_Component.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Scte35Command_SpliceInsert): unknown {
    const obj: any = {};
    if (message.spliceEventId !== 0) {
      obj.spliceEventId = Math.round(message.spliceEventId);
    }
    if (message.spliceEventCancelIndicator !== false) {
      obj.spliceEventCancelIndicator = message.spliceEventCancelIndicator;
    }
    if (message.outOfNetworkIndicator !== false) {
      obj.outOfNetworkIndicator = message.outOfNetworkIndicator;
    }
    if (message.programSpliceFlag !== false) {
      obj.programSpliceFlag = message.programSpliceFlag;
    }
    if (message.durationFlag !== false) {
      obj.durationFlag = message.durationFlag;
    }
    if (message.spliceImmediateFlag !== false) {
      obj.spliceImmediateFlag = message.spliceImmediateFlag;
    }
    if (message.spliceTime !== undefined) {
      obj.spliceTime = Scte35Command_SpliceTime.toJSON(message.spliceTime);
    }
    if (message.breakDuration !== undefined) {
      obj.breakDuration = Scte35Command_BreakDuration.toJSON(message.breakDuration);
    }
    if (message.uniqueProgramId !== 0) {
      obj.uniqueProgramId = Math.round(message.uniqueProgramId);
    }
    if (message.availNum !== 0) {
      obj.availNum = Math.round(message.availNum);
    }
    if (message.availsExpected !== 0) {
      obj.availsExpected = Math.round(message.availsExpected);
    }
    if (message.componentCount !== 0) {
      obj.componentCount = Math.round(message.componentCount);
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => Scte35Command_Component.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Scte35Command_SpliceInsert>): Scte35Command_SpliceInsert {
    return Scte35Command_SpliceInsert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Scte35Command_SpliceInsert>): Scte35Command_SpliceInsert {
    const message = createBaseScte35Command_SpliceInsert();
    message.spliceEventId = object.spliceEventId ?? 0;
    message.spliceEventCancelIndicator = object.spliceEventCancelIndicator ?? false;
    message.outOfNetworkIndicator = object.outOfNetworkIndicator ?? false;
    message.programSpliceFlag = object.programSpliceFlag ?? false;
    message.durationFlag = object.durationFlag ?? false;
    message.spliceImmediateFlag = object.spliceImmediateFlag ?? false;
    message.spliceTime = (object.spliceTime !== undefined && object.spliceTime !== null)
      ? Scte35Command_SpliceTime.fromPartial(object.spliceTime)
      : undefined;
    message.breakDuration = (object.breakDuration !== undefined && object.breakDuration !== null)
      ? Scte35Command_BreakDuration.fromPartial(object.breakDuration)
      : undefined;
    message.uniqueProgramId = object.uniqueProgramId ?? 0;
    message.availNum = object.availNum ?? 0;
    message.availsExpected = object.availsExpected ?? 0;
    message.componentCount = object.componentCount ?? 0;
    message.components = object.components?.map((e) => Scte35Command_Component.fromPartial(e)) || [];
    return message;
  },
};

function createBaseScte35Command_SpliceInfoSection(): Scte35Command_SpliceInfoSection {
  return { ptsAdjustment: Long.ZERO, spliceInsert: undefined };
}

export const Scte35Command_SpliceInfoSection: MessageFns<Scte35Command_SpliceInfoSection> = {
  encode(message: Scte35Command_SpliceInfoSection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.ptsAdjustment.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.ptsAdjustment.toString());
    }
    if (message.spliceInsert !== undefined) {
      Scte35Command_SpliceInsert.encode(message.spliceInsert, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scte35Command_SpliceInfoSection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScte35Command_SpliceInfoSection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ptsAdjustment = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spliceInsert = Scte35Command_SpliceInsert.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scte35Command_SpliceInfoSection {
    return {
      ptsAdjustment: isSet(object.ptsAdjustment) ? Long.fromValue(object.ptsAdjustment) : Long.ZERO,
      spliceInsert: isSet(object.spliceInsert) ? Scte35Command_SpliceInsert.fromJSON(object.spliceInsert) : undefined,
    };
  },

  toJSON(message: Scte35Command_SpliceInfoSection): unknown {
    const obj: any = {};
    if (!message.ptsAdjustment.equals(Long.ZERO)) {
      obj.ptsAdjustment = (message.ptsAdjustment || Long.ZERO).toString();
    }
    if (message.spliceInsert !== undefined) {
      obj.spliceInsert = Scte35Command_SpliceInsert.toJSON(message.spliceInsert);
    }
    return obj;
  },

  create(base?: DeepPartial<Scte35Command_SpliceInfoSection>): Scte35Command_SpliceInfoSection {
    return Scte35Command_SpliceInfoSection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Scte35Command_SpliceInfoSection>): Scte35Command_SpliceInfoSection {
    const message = createBaseScte35Command_SpliceInfoSection();
    message.ptsAdjustment = (object.ptsAdjustment !== undefined && object.ptsAdjustment !== null)
      ? Long.fromValue(object.ptsAdjustment)
      : Long.ZERO;
    message.spliceInsert = (object.spliceInsert !== undefined && object.spliceInsert !== null)
      ? Scte35Command_SpliceInsert.fromPartial(object.spliceInsert)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
