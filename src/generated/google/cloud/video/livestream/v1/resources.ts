// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/video/livestream/v1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { Status } from "../../../../rpc/status.js";
import { ElementaryStream, Manifest, MuxStream, PreprocessingConfig, SpriteSheet, TimecodeConfig } from "./outputs.js";

export const protobufPackage = "google.cloud.video.livestream.v1";

/**
 * Input resource represents the endpoint from which the channel ingests
 * the input stream.
 */
export interface Input {
  /**
   * The resource name of the input, in the form of:
   * `projects/{project}/locations/{location}/inputs/{inputId}`.
   */
  name: string;
  /** Output only. The creation time. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update time. */
  updateTime:
    | Date
    | undefined;
  /** User-defined key/value metadata. */
  labels: { [key: string]: string };
  /** Source type. */
  type: Input_Type;
  /**
   * Tier defines the maximum input specification that is accepted by the
   * video pipeline. The billing is charged based on the tier specified here.
   * See [Pricing](https://cloud.google.com/livestream/pricing) for more detail.
   * The default is `HD`.
   */
  tier: Input_Tier;
  /**
   * Output only. URI to push the input stream to.
   * Its format depends on the input
   * [type][google.cloud.video.livestream.v1.Input.type], for example:
   *
   * *  `RTMP_PUSH`: `rtmp://1.2.3.4/live/{STREAM-ID}`
   * *  `SRT_PUSH`: `srt://1.2.3.4:4201?streamid={STREAM-ID}`
   */
  uri: string;
  /** Preprocessing configurations. */
  preprocessingConfig:
    | PreprocessingConfig
    | undefined;
  /** Security rule for access control. */
  securityRules:
    | Input_SecurityRule
    | undefined;
  /**
   * Output only. The information for the input stream. This field will be
   * present only when this input receives the input stream.
   */
  inputStreamProperty: InputStreamProperty | undefined;
}

/** The type of the input. */
export enum Input_Type {
  /** TYPE_UNSPECIFIED - Input type is not specified. */
  TYPE_UNSPECIFIED = 0,
  /** RTMP_PUSH - Input will take an rtmp input stream. */
  RTMP_PUSH = 1,
  /** SRT_PUSH - Input will take an srt (Secure Reliable Transport) input stream. */
  SRT_PUSH = 2,
  UNRECOGNIZED = -1,
}

export function input_TypeFromJSON(object: any): Input_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Input_Type.TYPE_UNSPECIFIED;
    case 1:
    case "RTMP_PUSH":
      return Input_Type.RTMP_PUSH;
    case 2:
    case "SRT_PUSH":
      return Input_Type.SRT_PUSH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Input_Type.UNRECOGNIZED;
  }
}

export function input_TypeToJSON(object: Input_Type): string {
  switch (object) {
    case Input_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Input_Type.RTMP_PUSH:
      return "RTMP_PUSH";
    case Input_Type.SRT_PUSH:
      return "SRT_PUSH";
    case Input_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Tier of the input specification. */
export enum Input_Tier {
  /** TIER_UNSPECIFIED - Tier is not specified. */
  TIER_UNSPECIFIED = 0,
  /** SD - Resolution < 1280x720. Bitrate <= 6 Mbps. FPS <= 60. */
  SD = 1,
  /** HD - Resolution <= 1920x1080. Bitrate <= 25 Mbps. FPS <= 60. */
  HD = 2,
  /** UHD - Resolution <= 4096x2160. Not supported yet. */
  UHD = 3,
  UNRECOGNIZED = -1,
}

export function input_TierFromJSON(object: any): Input_Tier {
  switch (object) {
    case 0:
    case "TIER_UNSPECIFIED":
      return Input_Tier.TIER_UNSPECIFIED;
    case 1:
    case "SD":
      return Input_Tier.SD;
    case 2:
    case "HD":
      return Input_Tier.HD;
    case 3:
    case "UHD":
      return Input_Tier.UHD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Input_Tier.UNRECOGNIZED;
  }
}

export function input_TierToJSON(object: Input_Tier): string {
  switch (object) {
    case Input_Tier.TIER_UNSPECIFIED:
      return "TIER_UNSPECIFIED";
    case Input_Tier.SD:
      return "SD";
    case Input_Tier.HD:
      return "HD";
    case Input_Tier.UHD:
      return "UHD";
    case Input_Tier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Security rules for access control. Each field represents one security rule.
 * Only when the source of the input stream satisfies all the fields, this
 * input stream can be accepted.
 */
export interface Input_SecurityRule {
  /**
   * At least one ip range must match unless none specified. The IP range is
   * defined by CIDR block: for example, `192.0.1.0/24` for a range and
   * `192.0.1.0/32` for a single IP address.
   */
  ipRanges: string[];
}

export interface Input_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Channel resource represents the processor that does a user-defined
 * "streaming" operation, which includes getting an input stream through an
 * input, transcoding it to multiple renditions, and publishing output live
 * streams in certain formats (for example, HLS or DASH) to the specified
 * location.
 */
export interface Channel {
  /**
   * The resource name of the channel, in the form of:
   * `projects/{project}/locations/{location}/channels/{channelId}`.
   */
  name: string;
  /** Output only. The creation time. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update time. */
  updateTime:
    | Date
    | undefined;
  /** User-defined key/value metadata. */
  labels: { [key: string]: string };
  /**
   * A list of input attachments that this channel uses.
   * One channel can have multiple inputs as the input sources. Only one
   * input can be selected as the input source at one time.
   */
  inputAttachments: InputAttachment[];
  /**
   * Output only. The
   * [InputAttachment.key][google.cloud.video.livestream.v1.InputAttachment.key]
   * that serves as the current input source. The first input in the
   * [input_attachments][google.cloud.video.livestream.v1.Channel.input_attachments]
   * is the initial input source.
   */
  activeInput: string;
  /**
   * Required. Information about the output (that is, the Cloud Storage bucket
   * to store the generated live stream).
   */
  output:
    | Channel_Output
    | undefined;
  /** List of elementary streams. */
  elementaryStreams: ElementaryStream[];
  /** List of multiplexing settings for output streams. */
  muxStreams: MuxStream[];
  /** List of output manifests. */
  manifests: Manifest[];
  /** List of output sprite sheets. */
  spriteSheets: SpriteSheet[];
  /** Output only. State of the streaming operation. */
  streamingState: Channel_StreamingState;
  /**
   * Output only. A description of the reason for the streaming error. This
   * property is always present when
   * [streaming_state][google.cloud.video.livestream.v1.Channel.streaming_state]
   * is
   * [STREAMING_ERROR][google.cloud.video.livestream.v1.Channel.StreamingState.STREAMING_ERROR].
   */
  streamingError:
    | Status
    | undefined;
  /** Configuration of platform logs for this channel. */
  logConfig:
    | LogConfig
    | undefined;
  /** Configuration of timecode for this channel. */
  timecodeConfig:
    | TimecodeConfig
    | undefined;
  /**
   * Encryption configurations for this channel. Each configuration has an ID
   * which is referred to by each MuxStream to indicate which configuration is
   * used for that output.
   */
  encryptions: Encryption[];
  /**
   * The configuration for input sources defined in
   * [input_attachments][google.cloud.video.livestream.v1.Channel.input_attachments].
   */
  inputConfig:
    | InputConfig
    | undefined;
  /** Optional. Configuration for retention of output files for this channel. */
  retentionConfig:
    | RetentionConfig
    | undefined;
  /**
   * Optional. List of static overlay images. Those images display over the
   * output content for the whole duration of the live stream.
   */
  staticOverlays: StaticOverlay[];
}

/** State of streaming operation that the channel is running. */
export enum Channel_StreamingState {
  /** STREAMING_STATE_UNSPECIFIED - Streaming state is not specified. */
  STREAMING_STATE_UNSPECIFIED = 0,
  /**
   * STREAMING - Channel is getting the input stream, generating the live streams to the
   * specified output location.
   */
  STREAMING = 1,
  /** AWAITING_INPUT - Channel is waiting for the input stream through the input. */
  AWAITING_INPUT = 2,
  /**
   * STREAMING_ERROR - Channel is running, but has trouble publishing the live streams onto the
   * specified output location (for example, the specified Cloud Storage
   * bucket is not writable).
   */
  STREAMING_ERROR = 4,
  /**
   * STREAMING_NO_INPUT - Channel is generating live streams with no input stream. Live streams are
   * filled out with black screen, while input stream is missing.
   * Not supported yet.
   */
  STREAMING_NO_INPUT = 5,
  /** STOPPED - Channel is stopped, finishing live streams. */
  STOPPED = 6,
  /** STARTING - Channel is starting. */
  STARTING = 7,
  /** STOPPING - Channel is stopping. */
  STOPPING = 8,
  UNRECOGNIZED = -1,
}

export function channel_StreamingStateFromJSON(object: any): Channel_StreamingState {
  switch (object) {
    case 0:
    case "STREAMING_STATE_UNSPECIFIED":
      return Channel_StreamingState.STREAMING_STATE_UNSPECIFIED;
    case 1:
    case "STREAMING":
      return Channel_StreamingState.STREAMING;
    case 2:
    case "AWAITING_INPUT":
      return Channel_StreamingState.AWAITING_INPUT;
    case 4:
    case "STREAMING_ERROR":
      return Channel_StreamingState.STREAMING_ERROR;
    case 5:
    case "STREAMING_NO_INPUT":
      return Channel_StreamingState.STREAMING_NO_INPUT;
    case 6:
    case "STOPPED":
      return Channel_StreamingState.STOPPED;
    case 7:
    case "STARTING":
      return Channel_StreamingState.STARTING;
    case 8:
    case "STOPPING":
      return Channel_StreamingState.STOPPING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Channel_StreamingState.UNRECOGNIZED;
  }
}

export function channel_StreamingStateToJSON(object: Channel_StreamingState): string {
  switch (object) {
    case Channel_StreamingState.STREAMING_STATE_UNSPECIFIED:
      return "STREAMING_STATE_UNSPECIFIED";
    case Channel_StreamingState.STREAMING:
      return "STREAMING";
    case Channel_StreamingState.AWAITING_INPUT:
      return "AWAITING_INPUT";
    case Channel_StreamingState.STREAMING_ERROR:
      return "STREAMING_ERROR";
    case Channel_StreamingState.STREAMING_NO_INPUT:
      return "STREAMING_NO_INPUT";
    case Channel_StreamingState.STOPPED:
      return "STOPPED";
    case Channel_StreamingState.STARTING:
      return "STARTING";
    case Channel_StreamingState.STOPPING:
      return "STOPPING";
    case Channel_StreamingState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Location of output file(s) in a Google Cloud Storage bucket. */
export interface Channel_Output {
  /** URI for the output file(s). For example, `gs://my-bucket/outputs/`. */
  uri: string;
}

export interface Channel_LabelsEntry {
  key: string;
  value: string;
}

/** 2D normalized coordinates. */
export interface NormalizedCoordinate {
  /** Optional. Normalized x coordinate. Valid range is [0.0, 1.0]. Default is 0. */
  x: number;
  /** Optional. Normalized y coordinate. Valid range is [0.0, 1.0]. Default is 0. */
  y: number;
}

/** Normalized resolution. */
export interface NormalizedResolution {
  /** Optional. Normalized width. Valid range is [0.0, 1.0]. Default is 0. */
  w: number;
  /** Optional. Normalized height. Valid range is [0.0, 1.0]. Default is 0. */
  h: number;
}

/** Configuration for the static overlay. */
export interface StaticOverlay {
  /**
   * Required. Asset to use for the overlaid image.
   * The asset must be represented in the form of:
   * `projects/{project}/locations/{location}/assets/{assetId}`.
   * The asset's resource type must be image.
   */
  asset: string;
  /**
   * Optional. Normalized image resolution, based on output video resolution.
   * Valid values are [0.0, 1.0]. To respect the original image aspect ratio,
   * set either `w` or `h` to 0. To use the original image resolution, set both
   * `w` and `h` to 0. The default is {0, 0}.
   */
  resolution:
    | NormalizedResolution
    | undefined;
  /**
   * Optional. Position of the image in terms of normalized coordinates of the
   * upper-left corner of the image, based on output video resolution. For
   * example, use the x and y coordinates {0, 0} to position the top-left corner
   * of the overlay animation in the top-left corner of the output video.
   */
  position:
    | NormalizedCoordinate
    | undefined;
  /**
   * Optional. Target image opacity. Valid values are from `1.0` (solid,
   * default) to `0.0` (transparent), exclusive. Set this to a value greater
   * than `0.0`.
   */
  opacity: number;
}

/** Configuration for the input sources of a channel. */
export interface InputConfig {
  /** Input switch mode. Default mode is `FAILOVER_PREFER_PRIMARY`. */
  inputSwitchMode: InputConfig_InputSwitchMode;
}

/** Input switch mode. */
export enum InputConfig_InputSwitchMode {
  /** INPUT_SWITCH_MODE_UNSPECIFIED - The input switch mode is not specified. */
  INPUT_SWITCH_MODE_UNSPECIFIED = 0,
  /**
   * FAILOVER_PREFER_PRIMARY - Automatic failover is enabled. The primary input stream is always
   * preferred over its backup input streams configured using the
   * [AutomaticFailover][google.cloud.video.livestream.v1.InputAttachment.AutomaticFailover]
   * field.
   */
  FAILOVER_PREFER_PRIMARY = 1,
  /**
   * MANUAL - Automatic failover is disabled. You must use the
   * [inputSwitch][google.cloud.video.livestream.v1.Event.input_switch] event
   * to switch the active input source for the channel to stream from. When
   * this mode is chosen, the
   * [AutomaticFailover][google.cloud.video.livestream.v1.InputAttachment.AutomaticFailover]
   * field is ignored.
   */
  MANUAL = 3,
  UNRECOGNIZED = -1,
}

export function inputConfig_InputSwitchModeFromJSON(object: any): InputConfig_InputSwitchMode {
  switch (object) {
    case 0:
    case "INPUT_SWITCH_MODE_UNSPECIFIED":
      return InputConfig_InputSwitchMode.INPUT_SWITCH_MODE_UNSPECIFIED;
    case 1:
    case "FAILOVER_PREFER_PRIMARY":
      return InputConfig_InputSwitchMode.FAILOVER_PREFER_PRIMARY;
    case 3:
    case "MANUAL":
      return InputConfig_InputSwitchMode.MANUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InputConfig_InputSwitchMode.UNRECOGNIZED;
  }
}

export function inputConfig_InputSwitchModeToJSON(object: InputConfig_InputSwitchMode): string {
  switch (object) {
    case InputConfig_InputSwitchMode.INPUT_SWITCH_MODE_UNSPECIFIED:
      return "INPUT_SWITCH_MODE_UNSPECIFIED";
    case InputConfig_InputSwitchMode.FAILOVER_PREFER_PRIMARY:
      return "FAILOVER_PREFER_PRIMARY";
    case InputConfig_InputSwitchMode.MANUAL:
      return "MANUAL";
    case InputConfig_InputSwitchMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Configuration of platform logs.
 * See [Using and managing platform
 * logs](https://cloud.google.com/logging/docs/api/platform-logs#managing-logs)
 * for more information about how to view platform logs through Cloud Logging.
 */
export interface LogConfig {
  /** The severity level of platform logging for this resource. */
  logSeverity: LogConfig_LogSeverity;
}

/**
 * The severity level of platform logging for this channel. Logs with a
 * severity level higher than or equal to the chosen severity level will be
 * logged and can be viewed through Cloud Logging.
 * The severity level of a log is ranked as followed from low to high: DEBUG <
 * INFO < NOTICE < WARNING < ERROR < CRITICAL < ALERT < EMERGENCY.
 * See
 * [LogSeverity](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity)
 * for more information.
 */
export enum LogConfig_LogSeverity {
  /** LOG_SEVERITY_UNSPECIFIED - Log severity is not specified. This is the same as log severity is OFF. */
  LOG_SEVERITY_UNSPECIFIED = 0,
  /** OFF - Log is turned off. */
  OFF = 1,
  /** DEBUG - Log with severity higher than or equal to DEBUG are logged. */
  DEBUG = 100,
  /** INFO - Logs with severity higher than or equal to INFO are logged. */
  INFO = 200,
  /** WARNING - Logs with severity higher than or equal to WARNING are logged. */
  WARNING = 400,
  /** ERROR - Logs with severity higher than or equal to ERROR are logged. */
  ERROR = 500,
  UNRECOGNIZED = -1,
}

export function logConfig_LogSeverityFromJSON(object: any): LogConfig_LogSeverity {
  switch (object) {
    case 0:
    case "LOG_SEVERITY_UNSPECIFIED":
      return LogConfig_LogSeverity.LOG_SEVERITY_UNSPECIFIED;
    case 1:
    case "OFF":
      return LogConfig_LogSeverity.OFF;
    case 100:
    case "DEBUG":
      return LogConfig_LogSeverity.DEBUG;
    case 200:
    case "INFO":
      return LogConfig_LogSeverity.INFO;
    case 400:
    case "WARNING":
      return LogConfig_LogSeverity.WARNING;
    case 500:
    case "ERROR":
      return LogConfig_LogSeverity.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LogConfig_LogSeverity.UNRECOGNIZED;
  }
}

export function logConfig_LogSeverityToJSON(object: LogConfig_LogSeverity): string {
  switch (object) {
    case LogConfig_LogSeverity.LOG_SEVERITY_UNSPECIFIED:
      return "LOG_SEVERITY_UNSPECIFIED";
    case LogConfig_LogSeverity.OFF:
      return "OFF";
    case LogConfig_LogSeverity.DEBUG:
      return "DEBUG";
    case LogConfig_LogSeverity.INFO:
      return "INFO";
    case LogConfig_LogSeverity.WARNING:
      return "WARNING";
    case LogConfig_LogSeverity.ERROR:
      return "ERROR";
    case LogConfig_LogSeverity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration for retention of output files. */
export interface RetentionConfig {
  /**
   * The minimum duration for which the output files from the channel will
   * remain in the output bucket. After this duration, output files are
   * deleted asynchronously.
   *
   * When the channel is deleted, all output files are deleted from the output
   * bucket asynchronously.
   *
   * If omitted or set to zero, output files will remain in the output bucket
   * based on
   * [Manifest.segment_keep_duration][google.cloud.video.livestream.v1.Manifest.segment_keep_duration],
   * which defaults to 60s.
   *
   * If both retention_window_duration and
   * [Manifest.segment_keep_duration][google.cloud.video.livestream.v1.Manifest.segment_keep_duration]
   * are set, retention_window_duration is used and
   * [Manifest.segment_keep_duration][google.cloud.video.livestream.v1.Manifest.segment_keep_duration]
   * is ignored.
   */
  retentionWindowDuration: Duration | undefined;
}

/** Properties of the input stream. */
export interface InputStreamProperty {
  /**
   * The time that the current input stream is accepted and the connection is
   * established.
   */
  lastEstablishTime:
    | Date
    | undefined;
  /** Properties of the video streams. */
  videoStreams: VideoStreamProperty[];
  /** Properties of the audio streams. */
  audioStreams: AudioStreamProperty[];
}

/** Properties of the video stream. */
export interface VideoStreamProperty {
  /** Index of this video stream. */
  index: number;
  /** Properties of the video format. */
  videoFormat: VideoFormat | undefined;
}

/** Properties of the video format. */
export interface VideoFormat {
  /** Video codec used in this video stream. */
  codec: string;
  /** The width of the video stream in pixels. */
  widthPixels: number;
  /** The height of the video stream in pixels. */
  heightPixels: number;
  /** The frame rate of the input video stream. */
  frameRate: number;
}

/** Properties of the audio stream. */
export interface AudioStreamProperty {
  /** Index of this audio stream. */
  index: number;
  /** Properties of the audio format. */
  audioFormat: AudioFormat | undefined;
}

/** Properties of the audio format. */
export interface AudioFormat {
  /** Audio codec used in this audio stream. */
  codec: string;
  /** The number of audio channels. */
  channelCount: number;
  /** A list of channel names specifying the layout of the audio channels. */
  channelLayout: string[];
}

/** A group of information for attaching an input resource to this channel. */
export interface InputAttachment {
  /**
   * A unique key for this input attachment. The key must be 1-63
   * characters in length. The key must begin and end with a letter (regardless
   * of case) or a number, but can contain dashes or underscores in between.
   */
  key: string;
  /**
   * The resource name of an existing input, in the form of:
   * `projects/{project}/locations/{location}/inputs/{inputId}`.
   */
  input: string;
  /** Automatic failover configurations. */
  automaticFailover: InputAttachment_AutomaticFailover | undefined;
}

/** Configurations to follow when automatic failover happens. */
export interface InputAttachment_AutomaticFailover {
  /**
   * The
   * [InputAttachment.key][google.cloud.video.livestream.v1.InputAttachment.key]s
   * of inputs to failover to when this input is disconnected. Currently, only
   * up to one backup input is supported.
   */
  inputKeys: string[];
}

/**
 * Event is a sub-resource of a channel, which can be scheduled by the user to
 * execute operations on a channel resource without having to stop the channel.
 */
export interface Event {
  /**
   * The resource name of the event, in the form of:
   * `projects/{project}/locations/{location}/channels/{channelId}/events/{eventId}`.
   */
  name: string;
  /** Output only. The creation time. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update time. */
  updateTime:
    | Date
    | undefined;
  /** User-defined key/value metadata. */
  labels: { [key: string]: string };
  /** Switches to another input stream. */
  inputSwitch?:
    | Event_InputSwitchTask
    | undefined;
  /** Inserts a new ad opportunity. */
  adBreak?:
    | Event_AdBreakTask
    | undefined;
  /** Stops any running ad break. */
  returnToProgram?:
    | Event_ReturnToProgramTask
    | undefined;
  /** Inserts a slate. */
  slate?:
    | Event_SlateTask
    | undefined;
  /** Mutes the stream. */
  mute?:
    | Event_MuteTask
    | undefined;
  /** Unmutes the stream. */
  unmute?:
    | Event_UnmuteTask
    | undefined;
  /**
   * When this field is set to true, the event will be executed at the earliest
   * time that the server can schedule the event and
   * [execution_time][google.cloud.video.livestream.v1.Event.execution_time]
   * will be populated with the time that the server actually schedules the
   * event.
   */
  executeNow: boolean;
  /**
   * The time to execute the event. If you set
   * [execute_now][google.cloud.video.livestream.v1.Event.execute_now] to
   * `true`, then do not set this field in the `CreateEvent` request. In
   * this case, the server schedules the event and populates this field. If you
   * set [execute_now][google.cloud.video.livestream.v1.Event.execute_now] to
   * `false`, then you must set this field to at least 10 seconds in the future
   * or else the event can't be created.
   */
  executionTime:
    | Date
    | undefined;
  /** Output only. The state of the event. */
  state: Event_State;
  /**
   * Output only. An error object that describes the reason for the failure.
   * This property is always present when `state` is `FAILED`.
   */
  error: Status | undefined;
}

/** State of the event */
export enum Event_State {
  /** STATE_UNSPECIFIED - Event state is not specified. */
  STATE_UNSPECIFIED = 0,
  /** SCHEDULED - Event is scheduled but not executed yet. */
  SCHEDULED = 1,
  /** RUNNING - Event is being executed. */
  RUNNING = 2,
  /** SUCCEEDED - Event has been successfully executed. */
  SUCCEEDED = 3,
  /** FAILED - Event fails to be executed. */
  FAILED = 4,
  /** PENDING - Event has been created but not scheduled yet. */
  PENDING = 5,
  /** STOPPED - Event was stopped before running for its full duration. */
  STOPPED = 6,
  UNRECOGNIZED = -1,
}

export function event_StateFromJSON(object: any): Event_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Event_State.STATE_UNSPECIFIED;
    case 1:
    case "SCHEDULED":
      return Event_State.SCHEDULED;
    case 2:
    case "RUNNING":
      return Event_State.RUNNING;
    case 3:
    case "SUCCEEDED":
      return Event_State.SUCCEEDED;
    case 4:
    case "FAILED":
      return Event_State.FAILED;
    case 5:
    case "PENDING":
      return Event_State.PENDING;
    case 6:
    case "STOPPED":
      return Event_State.STOPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Event_State.UNRECOGNIZED;
  }
}

export function event_StateToJSON(object: Event_State): string {
  switch (object) {
    case Event_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Event_State.SCHEDULED:
      return "SCHEDULED";
    case Event_State.RUNNING:
      return "RUNNING";
    case Event_State.SUCCEEDED:
      return "SUCCEEDED";
    case Event_State.FAILED:
      return "FAILED";
    case Event_State.PENDING:
      return "PENDING";
    case Event_State.STOPPED:
      return "STOPPED";
    case Event_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Switches to another input stream. Automatic failover is then disabled. */
export interface Event_InputSwitchTask {
  /**
   * The
   * [InputAttachment.key][google.cloud.video.livestream.v1.InputAttachment.key]
   * of the input to switch to.
   */
  inputKey: string;
}

/** Inserts a new ad opportunity. */
export interface Event_AdBreakTask {
  /** Duration of an ad opportunity. Must be greater than 0. */
  duration: Duration | undefined;
}

/** Inserts a slate. */
export interface Event_SlateTask {
  /**
   * Optional. Duration of the slate. Must be greater than 0 if specified.
   * Omit this field for a long running slate.
   */
  duration:
    | Duration
    | undefined;
  /**
   * Slate asset to use for the duration. If its duration is less than the
   * duration of the SlateTask, then the slate loops. The slate must be
   * represented in the form of:
   * `projects/{project}/locations/{location}/assets/{assetId}`.
   */
  asset: string;
}

/**
 * Stops any events which are currently running. This only applies to events
 * with a duration.
 */
export interface Event_ReturnToProgramTask {
}

/** Mutes the stream. */
export interface Event_MuteTask {
  /**
   * Duration for which the stream should be muted. If omitted, the stream
   * will be muted until an UnmuteTask event is sent.
   */
  duration: Duration | undefined;
}

/** Unmutes the stream. The task fails if the stream is not currently muted. */
export interface Event_UnmuteTask {
}

export interface Event_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Clip is a sub-resource under channel. Each clip represents a clipping
 * operation that generates a VOD playlist from its channel given a set of
 * timestamp ranges.
 */
export interface Clip {
  /**
   * The resource name of the clip, in the following format:
   * `projects/{project}/locations/{location}/channels/{c}/clips/{clipId}`.
   * `{clipId}` is a user-specified resource id that conforms to the following
   * criteria:
   *
   * 1. 1 character minimum, 63 characters maximum
   * 2. Only contains letters, digits, underscores, and hyphens
   */
  name: string;
  /** Output only. The creation timestamp of the clip resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the clip request starts to be processed. */
  startTime:
    | Date
    | undefined;
  /** Output only. The update timestamp of the clip resource. */
  updateTime:
    | Date
    | undefined;
  /** The labels associated with this resource. Each label is a key-value pair. */
  labels: { [key: string]: string };
  /** Output only. The state of the clip. */
  state: Clip_State;
  /**
   * Specify the `output_uri` to determine where to place the clip segments and
   * clip manifest files in Cloud Storage. The manifests specified in
   * `clip_manifests` fields will be placed under this URI. The exact URI of the
   * generated manifests will be provided in `clip_manifests.output_uri` for
   * each manifest.
   * Example:
   * "output_uri": "gs://my-bucket/clip-outputs"
   * "clip_manifests.output_uri": "gs://my-bucket/clip-outputs/main.m3u8"
   */
  outputUri: string;
  /**
   * Output only. An error object that describes the reason for the failure.
   * This property only presents when `state` is `FAILED`.
   */
  error:
    | Status
    | undefined;
  /** The specified ranges of segments to generate a clip. */
  slices: Clip_Slice[];
  /**
   * Required. A list of clip manifests. Currently only one clip manifest is
   * allowed.
   */
  clipManifests: Clip_ClipManifest[];
}

/** State of clipping operation. */
export enum Clip_State {
  /** STATE_UNSPECIFIED - State is not specified. */
  STATE_UNSPECIFIED = 0,
  /** PENDING - The operation is pending to be picked up by the server. */
  PENDING = 1,
  /**
   * CREATING - The server admitted this create clip request, and
   * outputs are under processing.
   */
  CREATING = 2,
  /**
   * SUCCEEDED - Outputs are available in the specified Cloud Storage bucket. For
   * additional information, see the `outputs` field.
   */
  SUCCEEDED = 3,
  /**
   * FAILED - The operation has failed. For additional information, see the `error`
   * field.
   */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function clip_StateFromJSON(object: any): Clip_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Clip_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Clip_State.PENDING;
    case 2:
    case "CREATING":
      return Clip_State.CREATING;
    case 3:
    case "SUCCEEDED":
      return Clip_State.SUCCEEDED;
    case 4:
    case "FAILED":
      return Clip_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Clip_State.UNRECOGNIZED;
  }
}

export function clip_StateToJSON(object: Clip_State): string {
  switch (object) {
    case Clip_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Clip_State.PENDING:
      return "PENDING";
    case Clip_State.CREATING:
      return "CREATING";
    case Clip_State.SUCCEEDED:
      return "SUCCEEDED";
    case Clip_State.FAILED:
      return "FAILED";
    case Clip_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * TimeSlice represents a tuple of Unix epoch timestamps that specifies a time
 * range.
 */
export interface Clip_TimeSlice {
  /** The mark-in Unix epoch time in the original live stream manifest. */
  markinTime:
    | Date
    | undefined;
  /** The mark-out Unix epoch time in the original live stream manifest. */
  markoutTime: Date | undefined;
}

/** Slice represents a slice of the requested clip. */
export interface Clip_Slice {
  /** A slice in form of a tuple of Unix epoch time. */
  timeSlice?: Clip_TimeSlice | undefined;
}

/** ClipManifest identifies a source manifest for the generated clip manifest. */
export interface Clip_ClipManifest {
  /**
   * Required. A unique key that identifies a manifest config in the parent
   * channel. This key is the same as `channel.manifests.key` for the selected
   * manifest.
   */
  manifestKey: string;
  /**
   * Output only. The output URI of the generated clip manifest. This field
   * will be populated when the CreateClip request is accepted. Current output
   * format is provided below but may change in the future. Please read this
   * field to get the uri to the generated clip manifest. Format:
   * {clip.output_uri}/{channel.manifest.fileName} Example:
   * gs://my-bucket/clip-outputs/main.m3u8
   */
  outputUri: string;
}

export interface Clip_LabelsEntry {
  key: string;
  value: string;
}

/** An asset represents a video or an image. */
export interface Asset {
  /**
   * The resource name of the asset, in the form of:
   * `projects/{project}/locations/{location}/assets/{assetId}`.
   */
  name: string;
  /** Output only. The creation time. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update time. */
  updateTime:
    | Date
    | undefined;
  /** User-defined key/value metadata. */
  labels: { [key: string]: string };
  /** VideoAsset represents a video. */
  video?:
    | Asset_VideoAsset
    | undefined;
  /** ImageAsset represents an image. */
  image?:
    | Asset_ImageAsset
    | undefined;
  /**
   * Based64-encoded CRC32c checksum of the asset file. For more information,
   * see the crc32c checksum of the [Cloud Storage Objects
   * resource](https://cloud.google.com/storage/docs/json_api/v1/objects).
   * If crc32c is omitted or left empty when the asset is created, this field is
   * filled by the crc32c checksum of the Cloud Storage object indicated by
   * [VideoAsset.uri][google.cloud.video.livestream.v1.Asset.VideoAsset.uri] or
   * [ImageAsset.uri][google.cloud.video.livestream.v1.Asset.ImageAsset.uri]. If
   * crc32c is set, the asset can't be created if the crc32c value does not
   * match with the crc32c checksum of the Cloud Storage object indicated by
   * [VideoAsset.uri][google.cloud.video.livestream.v1.Asset.VideoAsset.uri] or
   * [ImageAsset.uri][google.cloud.video.livestream.v1.Asset.ImageAsset.uri].
   */
  crc32c: string;
  /** Output only. The state of the asset resource. */
  state: Asset_State;
  /**
   * Output only. Only present when `state` is `ERROR`. The reason for the error
   * state of the asset.
   */
  error: Status | undefined;
}

/** State of the asset resource. */
export enum Asset_State {
  /** STATE_UNSPECIFIED - State is not specified. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The asset is being created. */
  CREATING = 1,
  /** ACTIVE - The asset is ready for use. */
  ACTIVE = 2,
  /** DELETING - The asset is being deleted. */
  DELETING = 3,
  /** ERROR - The asset has an error. */
  ERROR = 4,
  UNRECOGNIZED = -1,
}

export function asset_StateFromJSON(object: any): Asset_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Asset_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Asset_State.CREATING;
    case 2:
    case "ACTIVE":
      return Asset_State.ACTIVE;
    case 3:
    case "DELETING":
      return Asset_State.DELETING;
    case 4:
    case "ERROR":
      return Asset_State.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Asset_State.UNRECOGNIZED;
  }
}

export function asset_StateToJSON(object: Asset_State): string {
  switch (object) {
    case Asset_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Asset_State.CREATING:
      return "CREATING";
    case Asset_State.ACTIVE:
      return "ACTIVE";
    case Asset_State.DELETING:
      return "DELETING";
    case Asset_State.ERROR:
      return "ERROR";
    case Asset_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * VideoAsset represents a video. The supported formats are MP4, MPEG-TS, and
 * FLV. The supported video codec is H264. The supported audio codecs are
 * AAC, AC3, MP2, and MP3.
 */
export interface Asset_VideoAsset {
  /** Cloud Storage URI of the video. The format is `gs://my-bucket/my-object`. */
  uri: string;
}

/** Image represents an image. The supported formats are JPEG, PNG. */
export interface Asset_ImageAsset {
  /** Cloud Storage URI of the image. The format is `gs://my-bucket/my-object`. */
  uri: string;
}

export interface Asset_LabelsEntry {
  key: string;
  value: string;
}

/** Encryption settings. */
export interface Encryption {
  /**
   * Required. Identifier for this set of encryption options. The ID must be
   * 1-63 characters in length. The ID must begin and end with a letter
   * (regardless of case) or a number, but can contain dashes or underscores in
   * between.
   */
  id: string;
  /** For keys stored in Google Secret Manager. */
  secretManagerKeySource?:
    | Encryption_SecretManagerSource
    | undefined;
  /** Required. Configuration for DRM systems. */
  drmSystems:
    | Encryption_DrmSystems
    | undefined;
  /** Configuration for HLS AES-128 encryption. */
  aes128?:
    | Encryption_Aes128Encryption
    | undefined;
  /** Configuration for HLS SAMPLE-AES encryption. */
  sampleAes?:
    | Encryption_SampleAesEncryption
    | undefined;
  /** Configuration for MPEG-Dash Common Encryption (MPEG-CENC). */
  mpegCenc?: Encryption_MpegCommonEncryption | undefined;
}

/** Configuration for secrets stored in Google Secret Manager. */
export interface Encryption_SecretManagerSource {
  /**
   * Required. The name of the Secret Version containing the encryption key.
   * `projects/{project}/secrets/{secret_id}/versions/{version_number}`
   */
  secretVersion: string;
}

/** Widevine configuration. */
export interface Encryption_Widevine {
}

/** Fairplay configuration. */
export interface Encryption_Fairplay {
}

/** Playready configuration. */
export interface Encryption_Playready {
}

/** Clearkey configuration. */
export interface Encryption_Clearkey {
}

/**
 * Defines configuration for DRM systems in use. If a field is omitted,
 * that DRM system will be considered to be disabled.
 */
export interface Encryption_DrmSystems {
  /** Widevine configuration. */
  widevine:
    | Encryption_Widevine
    | undefined;
  /** Fairplay configuration. */
  fairplay:
    | Encryption_Fairplay
    | undefined;
  /** Playready configuration. */
  playready:
    | Encryption_Playready
    | undefined;
  /** Clearkey configuration. */
  clearkey: Encryption_Clearkey | undefined;
}

/** Configuration for HLS AES-128 encryption. */
export interface Encryption_Aes128Encryption {
}

/** Configuration for HLS SAMPLE-AES encryption. */
export interface Encryption_SampleAesEncryption {
}

/** Configuration for MPEG-Dash Common Encryption (MPEG-CENC). */
export interface Encryption_MpegCommonEncryption {
  /**
   * Required. Specify the encryption scheme, supported schemes:
   * - `cenc` - AES-CTR subsample
   * - `cbcs`- AES-CBC subsample pattern
   */
  scheme: string;
}

/**
 * Pool resource defines the configuration of Live Stream pools for a specific
 * location. Currently we support only one pool resource per project per
 * location. After the creation of the first input, a default pool is created
 * automatically at "projects/{project}/locations/{location}/pools/default".
 */
export interface Pool {
  /**
   * The resource name of the pool, in the form of:
   * `projects/{project}/locations/{location}/pools/{poolId}`.
   */
  name: string;
  /** Output only. The creation time. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update time. */
  updateTime:
    | Date
    | undefined;
  /** User-defined key/value metadata. */
  labels: { [key: string]: string };
  /** Network configuration for the pool. */
  networkConfig: Pool_NetworkConfig | undefined;
}

/** Defines the network configuration for the pool. */
export interface Pool_NetworkConfig {
  /**
   * peered_network is the network resource URL of the network that is peered
   * to the service provider network. Must be of the format
   * projects/NETWORK_PROJECT_NUMBER/global/networks/NETWORK_NAME, where
   * NETWORK_PROJECT_NUMBER is the project number of the Cloud project that
   * holds your VPC network and NETWORK_NAME is the name of your VPC network.
   * If peered_network is omitted or empty, the pool will use endpoints that
   * are publicly available.
   */
  peeredNetwork: string;
}

export interface Pool_LabelsEntry {
  key: string;
  value: string;
}

function createBaseInput(): Input {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    type: 0,
    tier: 0,
    uri: "",
    preprocessingConfig: undefined,
    securityRules: undefined,
    inputStreamProperty: undefined,
  };
}

export const Input: MessageFns<Input> = {
  encode(message: Input, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Input_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.tier !== 0) {
      writer.uint32(112).int32(message.tier);
    }
    if (message.uri !== "") {
      writer.uint32(50).string(message.uri);
    }
    if (message.preprocessingConfig !== undefined) {
      PreprocessingConfig.encode(message.preprocessingConfig, writer.uint32(74).fork()).join();
    }
    if (message.securityRules !== undefined) {
      Input_SecurityRule.encode(message.securityRules, writer.uint32(98).fork()).join();
    }
    if (message.inputStreamProperty !== undefined) {
      InputStreamProperty.encode(message.inputStreamProperty, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Input {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Input_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.preprocessingConfig = PreprocessingConfig.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.securityRules = Input_SecurityRule.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.inputStreamProperty = InputStreamProperty.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Input {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      type: isSet(object.type) ? input_TypeFromJSON(object.type) : 0,
      tier: isSet(object.tier) ? input_TierFromJSON(object.tier) : 0,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      preprocessingConfig: isSet(object.preprocessingConfig)
        ? PreprocessingConfig.fromJSON(object.preprocessingConfig)
        : undefined,
      securityRules: isSet(object.securityRules) ? Input_SecurityRule.fromJSON(object.securityRules) : undefined,
      inputStreamProperty: isSet(object.inputStreamProperty)
        ? InputStreamProperty.fromJSON(object.inputStreamProperty)
        : undefined,
    };
  },

  toJSON(message: Input): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.type !== 0) {
      obj.type = input_TypeToJSON(message.type);
    }
    if (message.tier !== 0) {
      obj.tier = input_TierToJSON(message.tier);
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.preprocessingConfig !== undefined) {
      obj.preprocessingConfig = PreprocessingConfig.toJSON(message.preprocessingConfig);
    }
    if (message.securityRules !== undefined) {
      obj.securityRules = Input_SecurityRule.toJSON(message.securityRules);
    }
    if (message.inputStreamProperty !== undefined) {
      obj.inputStreamProperty = InputStreamProperty.toJSON(message.inputStreamProperty);
    }
    return obj;
  },

  create(base?: DeepPartial<Input>): Input {
    return Input.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Input>): Input {
    const message = createBaseInput();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.type = object.type ?? 0;
    message.tier = object.tier ?? 0;
    message.uri = object.uri ?? "";
    message.preprocessingConfig = (object.preprocessingConfig !== undefined && object.preprocessingConfig !== null)
      ? PreprocessingConfig.fromPartial(object.preprocessingConfig)
      : undefined;
    message.securityRules = (object.securityRules !== undefined && object.securityRules !== null)
      ? Input_SecurityRule.fromPartial(object.securityRules)
      : undefined;
    message.inputStreamProperty = (object.inputStreamProperty !== undefined && object.inputStreamProperty !== null)
      ? InputStreamProperty.fromPartial(object.inputStreamProperty)
      : undefined;
    return message;
  },
};

function createBaseInput_SecurityRule(): Input_SecurityRule {
  return { ipRanges: [] };
}

export const Input_SecurityRule: MessageFns<Input_SecurityRule> = {
  encode(message: Input_SecurityRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ipRanges) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Input_SecurityRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInput_SecurityRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ipRanges.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Input_SecurityRule {
    return {
      ipRanges: globalThis.Array.isArray(object?.ipRanges) ? object.ipRanges.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Input_SecurityRule): unknown {
    const obj: any = {};
    if (message.ipRanges?.length) {
      obj.ipRanges = message.ipRanges;
    }
    return obj;
  },

  create(base?: DeepPartial<Input_SecurityRule>): Input_SecurityRule {
    return Input_SecurityRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Input_SecurityRule>): Input_SecurityRule {
    const message = createBaseInput_SecurityRule();
    message.ipRanges = object.ipRanges?.map((e) => e) || [];
    return message;
  },
};

function createBaseInput_LabelsEntry(): Input_LabelsEntry {
  return { key: "", value: "" };
}

export const Input_LabelsEntry: MessageFns<Input_LabelsEntry> = {
  encode(message: Input_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Input_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInput_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Input_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Input_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Input_LabelsEntry>): Input_LabelsEntry {
    return Input_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Input_LabelsEntry>): Input_LabelsEntry {
    const message = createBaseInput_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseChannel(): Channel {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    inputAttachments: [],
    activeInput: "",
    output: undefined,
    elementaryStreams: [],
    muxStreams: [],
    manifests: [],
    spriteSheets: [],
    streamingState: 0,
    streamingError: undefined,
    logConfig: undefined,
    timecodeConfig: undefined,
    encryptions: [],
    inputConfig: undefined,
    retentionConfig: undefined,
    staticOverlays: [],
  };
}

export const Channel: MessageFns<Channel> = {
  encode(message: Channel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Channel_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    for (const v of message.inputAttachments) {
      InputAttachment.encode(v!, writer.uint32(130).fork()).join();
    }
    if (message.activeInput !== "") {
      writer.uint32(50).string(message.activeInput);
    }
    if (message.output !== undefined) {
      Channel_Output.encode(message.output, writer.uint32(74).fork()).join();
    }
    for (const v of message.elementaryStreams) {
      ElementaryStream.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.muxStreams) {
      MuxStream.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.manifests) {
      Manifest.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.spriteSheets) {
      SpriteSheet.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.streamingState !== 0) {
      writer.uint32(112).int32(message.streamingState);
    }
    if (message.streamingError !== undefined) {
      Status.encode(message.streamingError, writer.uint32(146).fork()).join();
    }
    if (message.logConfig !== undefined) {
      LogConfig.encode(message.logConfig, writer.uint32(154).fork()).join();
    }
    if (message.timecodeConfig !== undefined) {
      TimecodeConfig.encode(message.timecodeConfig, writer.uint32(170).fork()).join();
    }
    for (const v of message.encryptions) {
      Encryption.encode(v!, writer.uint32(194).fork()).join();
    }
    if (message.inputConfig !== undefined) {
      InputConfig.encode(message.inputConfig, writer.uint32(202).fork()).join();
    }
    if (message.retentionConfig !== undefined) {
      RetentionConfig.encode(message.retentionConfig, writer.uint32(210).fork()).join();
    }
    for (const v of message.staticOverlays) {
      StaticOverlay.encode(v!, writer.uint32(218).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Channel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Channel_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.inputAttachments.push(InputAttachment.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.activeInput = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.output = Channel_Output.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.elementaryStreams.push(ElementaryStream.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.muxStreams.push(MuxStream.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.manifests.push(Manifest.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.spriteSheets.push(SpriteSheet.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.streamingState = reader.int32() as any;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.streamingError = Status.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.logConfig = LogConfig.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.timecodeConfig = TimecodeConfig.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.encryptions.push(Encryption.decode(reader, reader.uint32()));
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.inputConfig = InputConfig.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.retentionConfig = RetentionConfig.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.staticOverlays.push(StaticOverlay.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Channel {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      inputAttachments: globalThis.Array.isArray(object?.inputAttachments)
        ? object.inputAttachments.map((e: any) => InputAttachment.fromJSON(e))
        : [],
      activeInput: isSet(object.activeInput) ? globalThis.String(object.activeInput) : "",
      output: isSet(object.output) ? Channel_Output.fromJSON(object.output) : undefined,
      elementaryStreams: globalThis.Array.isArray(object?.elementaryStreams)
        ? object.elementaryStreams.map((e: any) => ElementaryStream.fromJSON(e))
        : [],
      muxStreams: globalThis.Array.isArray(object?.muxStreams)
        ? object.muxStreams.map((e: any) => MuxStream.fromJSON(e))
        : [],
      manifests: globalThis.Array.isArray(object?.manifests)
        ? object.manifests.map((e: any) => Manifest.fromJSON(e))
        : [],
      spriteSheets: globalThis.Array.isArray(object?.spriteSheets)
        ? object.spriteSheets.map((e: any) => SpriteSheet.fromJSON(e))
        : [],
      streamingState: isSet(object.streamingState) ? channel_StreamingStateFromJSON(object.streamingState) : 0,
      streamingError: isSet(object.streamingError) ? Status.fromJSON(object.streamingError) : undefined,
      logConfig: isSet(object.logConfig) ? LogConfig.fromJSON(object.logConfig) : undefined,
      timecodeConfig: isSet(object.timecodeConfig) ? TimecodeConfig.fromJSON(object.timecodeConfig) : undefined,
      encryptions: globalThis.Array.isArray(object?.encryptions)
        ? object.encryptions.map((e: any) => Encryption.fromJSON(e))
        : [],
      inputConfig: isSet(object.inputConfig) ? InputConfig.fromJSON(object.inputConfig) : undefined,
      retentionConfig: isSet(object.retentionConfig) ? RetentionConfig.fromJSON(object.retentionConfig) : undefined,
      staticOverlays: globalThis.Array.isArray(object?.staticOverlays)
        ? object.staticOverlays.map((e: any) => StaticOverlay.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Channel): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.inputAttachments?.length) {
      obj.inputAttachments = message.inputAttachments.map((e) => InputAttachment.toJSON(e));
    }
    if (message.activeInput !== "") {
      obj.activeInput = message.activeInput;
    }
    if (message.output !== undefined) {
      obj.output = Channel_Output.toJSON(message.output);
    }
    if (message.elementaryStreams?.length) {
      obj.elementaryStreams = message.elementaryStreams.map((e) => ElementaryStream.toJSON(e));
    }
    if (message.muxStreams?.length) {
      obj.muxStreams = message.muxStreams.map((e) => MuxStream.toJSON(e));
    }
    if (message.manifests?.length) {
      obj.manifests = message.manifests.map((e) => Manifest.toJSON(e));
    }
    if (message.spriteSheets?.length) {
      obj.spriteSheets = message.spriteSheets.map((e) => SpriteSheet.toJSON(e));
    }
    if (message.streamingState !== 0) {
      obj.streamingState = channel_StreamingStateToJSON(message.streamingState);
    }
    if (message.streamingError !== undefined) {
      obj.streamingError = Status.toJSON(message.streamingError);
    }
    if (message.logConfig !== undefined) {
      obj.logConfig = LogConfig.toJSON(message.logConfig);
    }
    if (message.timecodeConfig !== undefined) {
      obj.timecodeConfig = TimecodeConfig.toJSON(message.timecodeConfig);
    }
    if (message.encryptions?.length) {
      obj.encryptions = message.encryptions.map((e) => Encryption.toJSON(e));
    }
    if (message.inputConfig !== undefined) {
      obj.inputConfig = InputConfig.toJSON(message.inputConfig);
    }
    if (message.retentionConfig !== undefined) {
      obj.retentionConfig = RetentionConfig.toJSON(message.retentionConfig);
    }
    if (message.staticOverlays?.length) {
      obj.staticOverlays = message.staticOverlays.map((e) => StaticOverlay.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Channel>): Channel {
    return Channel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Channel>): Channel {
    const message = createBaseChannel();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.inputAttachments = object.inputAttachments?.map((e) => InputAttachment.fromPartial(e)) || [];
    message.activeInput = object.activeInput ?? "";
    message.output = (object.output !== undefined && object.output !== null)
      ? Channel_Output.fromPartial(object.output)
      : undefined;
    message.elementaryStreams = object.elementaryStreams?.map((e) => ElementaryStream.fromPartial(e)) || [];
    message.muxStreams = object.muxStreams?.map((e) => MuxStream.fromPartial(e)) || [];
    message.manifests = object.manifests?.map((e) => Manifest.fromPartial(e)) || [];
    message.spriteSheets = object.spriteSheets?.map((e) => SpriteSheet.fromPartial(e)) || [];
    message.streamingState = object.streamingState ?? 0;
    message.streamingError = (object.streamingError !== undefined && object.streamingError !== null)
      ? Status.fromPartial(object.streamingError)
      : undefined;
    message.logConfig = (object.logConfig !== undefined && object.logConfig !== null)
      ? LogConfig.fromPartial(object.logConfig)
      : undefined;
    message.timecodeConfig = (object.timecodeConfig !== undefined && object.timecodeConfig !== null)
      ? TimecodeConfig.fromPartial(object.timecodeConfig)
      : undefined;
    message.encryptions = object.encryptions?.map((e) => Encryption.fromPartial(e)) || [];
    message.inputConfig = (object.inputConfig !== undefined && object.inputConfig !== null)
      ? InputConfig.fromPartial(object.inputConfig)
      : undefined;
    message.retentionConfig = (object.retentionConfig !== undefined && object.retentionConfig !== null)
      ? RetentionConfig.fromPartial(object.retentionConfig)
      : undefined;
    message.staticOverlays = object.staticOverlays?.map((e) => StaticOverlay.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChannel_Output(): Channel_Output {
  return { uri: "" };
}

export const Channel_Output: MessageFns<Channel_Output> = {
  encode(message: Channel_Output, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Channel_Output {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannel_Output();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Channel_Output {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: Channel_Output): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<Channel_Output>): Channel_Output {
    return Channel_Output.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Channel_Output>): Channel_Output {
    const message = createBaseChannel_Output();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseChannel_LabelsEntry(): Channel_LabelsEntry {
  return { key: "", value: "" };
}

export const Channel_LabelsEntry: MessageFns<Channel_LabelsEntry> = {
  encode(message: Channel_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Channel_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannel_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Channel_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Channel_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Channel_LabelsEntry>): Channel_LabelsEntry {
    return Channel_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Channel_LabelsEntry>): Channel_LabelsEntry {
    const message = createBaseChannel_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNormalizedCoordinate(): NormalizedCoordinate {
  return { x: 0, y: 0 };
}

export const NormalizedCoordinate: MessageFns<NormalizedCoordinate> = {
  encode(message: NormalizedCoordinate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NormalizedCoordinate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNormalizedCoordinate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NormalizedCoordinate {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: NormalizedCoordinate): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create(base?: DeepPartial<NormalizedCoordinate>): NormalizedCoordinate {
    return NormalizedCoordinate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NormalizedCoordinate>): NormalizedCoordinate {
    const message = createBaseNormalizedCoordinate();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseNormalizedResolution(): NormalizedResolution {
  return { w: 0, h: 0 };
}

export const NormalizedResolution: MessageFns<NormalizedResolution> = {
  encode(message: NormalizedResolution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.w !== 0) {
      writer.uint32(9).double(message.w);
    }
    if (message.h !== 0) {
      writer.uint32(17).double(message.h);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NormalizedResolution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNormalizedResolution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.w = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.h = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NormalizedResolution {
    return {
      w: isSet(object.w) ? globalThis.Number(object.w) : 0,
      h: isSet(object.h) ? globalThis.Number(object.h) : 0,
    };
  },

  toJSON(message: NormalizedResolution): unknown {
    const obj: any = {};
    if (message.w !== 0) {
      obj.w = message.w;
    }
    if (message.h !== 0) {
      obj.h = message.h;
    }
    return obj;
  },

  create(base?: DeepPartial<NormalizedResolution>): NormalizedResolution {
    return NormalizedResolution.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NormalizedResolution>): NormalizedResolution {
    const message = createBaseNormalizedResolution();
    message.w = object.w ?? 0;
    message.h = object.h ?? 0;
    return message;
  },
};

function createBaseStaticOverlay(): StaticOverlay {
  return { asset: "", resolution: undefined, position: undefined, opacity: 0 };
}

export const StaticOverlay: MessageFns<StaticOverlay> = {
  encode(message: StaticOverlay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asset !== "") {
      writer.uint32(10).string(message.asset);
    }
    if (message.resolution !== undefined) {
      NormalizedResolution.encode(message.resolution, writer.uint32(18).fork()).join();
    }
    if (message.position !== undefined) {
      NormalizedCoordinate.encode(message.position, writer.uint32(26).fork()).join();
    }
    if (message.opacity !== 0) {
      writer.uint32(33).double(message.opacity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StaticOverlay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStaticOverlay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resolution = NormalizedResolution.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.position = NormalizedCoordinate.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.opacity = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StaticOverlay {
    return {
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
      resolution: isSet(object.resolution) ? NormalizedResolution.fromJSON(object.resolution) : undefined,
      position: isSet(object.position) ? NormalizedCoordinate.fromJSON(object.position) : undefined,
      opacity: isSet(object.opacity) ? globalThis.Number(object.opacity) : 0,
    };
  },

  toJSON(message: StaticOverlay): unknown {
    const obj: any = {};
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.resolution !== undefined) {
      obj.resolution = NormalizedResolution.toJSON(message.resolution);
    }
    if (message.position !== undefined) {
      obj.position = NormalizedCoordinate.toJSON(message.position);
    }
    if (message.opacity !== 0) {
      obj.opacity = message.opacity;
    }
    return obj;
  },

  create(base?: DeepPartial<StaticOverlay>): StaticOverlay {
    return StaticOverlay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StaticOverlay>): StaticOverlay {
    const message = createBaseStaticOverlay();
    message.asset = object.asset ?? "";
    message.resolution = (object.resolution !== undefined && object.resolution !== null)
      ? NormalizedResolution.fromPartial(object.resolution)
      : undefined;
    message.position = (object.position !== undefined && object.position !== null)
      ? NormalizedCoordinate.fromPartial(object.position)
      : undefined;
    message.opacity = object.opacity ?? 0;
    return message;
  },
};

function createBaseInputConfig(): InputConfig {
  return { inputSwitchMode: 0 };
}

export const InputConfig: MessageFns<InputConfig> = {
  encode(message: InputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputSwitchMode !== 0) {
      writer.uint32(8).int32(message.inputSwitchMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.inputSwitchMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputConfig {
    return {
      inputSwitchMode: isSet(object.inputSwitchMode) ? inputConfig_InputSwitchModeFromJSON(object.inputSwitchMode) : 0,
    };
  },

  toJSON(message: InputConfig): unknown {
    const obj: any = {};
    if (message.inputSwitchMode !== 0) {
      obj.inputSwitchMode = inputConfig_InputSwitchModeToJSON(message.inputSwitchMode);
    }
    return obj;
  },

  create(base?: DeepPartial<InputConfig>): InputConfig {
    return InputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputConfig>): InputConfig {
    const message = createBaseInputConfig();
    message.inputSwitchMode = object.inputSwitchMode ?? 0;
    return message;
  },
};

function createBaseLogConfig(): LogConfig {
  return { logSeverity: 0 };
}

export const LogConfig: MessageFns<LogConfig> = {
  encode(message: LogConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.logSeverity !== 0) {
      writer.uint32(8).int32(message.logSeverity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.logSeverity = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogConfig {
    return { logSeverity: isSet(object.logSeverity) ? logConfig_LogSeverityFromJSON(object.logSeverity) : 0 };
  },

  toJSON(message: LogConfig): unknown {
    const obj: any = {};
    if (message.logSeverity !== 0) {
      obj.logSeverity = logConfig_LogSeverityToJSON(message.logSeverity);
    }
    return obj;
  },

  create(base?: DeepPartial<LogConfig>): LogConfig {
    return LogConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogConfig>): LogConfig {
    const message = createBaseLogConfig();
    message.logSeverity = object.logSeverity ?? 0;
    return message;
  },
};

function createBaseRetentionConfig(): RetentionConfig {
  return { retentionWindowDuration: undefined };
}

export const RetentionConfig: MessageFns<RetentionConfig> = {
  encode(message: RetentionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retentionWindowDuration !== undefined) {
      Duration.encode(message.retentionWindowDuration, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetentionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetentionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.retentionWindowDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetentionConfig {
    return {
      retentionWindowDuration: isSet(object.retentionWindowDuration)
        ? Duration.fromJSON(object.retentionWindowDuration)
        : undefined,
    };
  },

  toJSON(message: RetentionConfig): unknown {
    const obj: any = {};
    if (message.retentionWindowDuration !== undefined) {
      obj.retentionWindowDuration = Duration.toJSON(message.retentionWindowDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<RetentionConfig>): RetentionConfig {
    return RetentionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetentionConfig>): RetentionConfig {
    const message = createBaseRetentionConfig();
    message.retentionWindowDuration =
      (object.retentionWindowDuration !== undefined && object.retentionWindowDuration !== null)
        ? Duration.fromPartial(object.retentionWindowDuration)
        : undefined;
    return message;
  },
};

function createBaseInputStreamProperty(): InputStreamProperty {
  return { lastEstablishTime: undefined, videoStreams: [], audioStreams: [] };
}

export const InputStreamProperty: MessageFns<InputStreamProperty> = {
  encode(message: InputStreamProperty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lastEstablishTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastEstablishTime), writer.uint32(10).fork()).join();
    }
    for (const v of message.videoStreams) {
      VideoStreamProperty.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.audioStreams) {
      AudioStreamProperty.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputStreamProperty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputStreamProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lastEstablishTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.videoStreams.push(VideoStreamProperty.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.audioStreams.push(AudioStreamProperty.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputStreamProperty {
    return {
      lastEstablishTime: isSet(object.lastEstablishTime) ? fromJsonTimestamp(object.lastEstablishTime) : undefined,
      videoStreams: globalThis.Array.isArray(object?.videoStreams)
        ? object.videoStreams.map((e: any) => VideoStreamProperty.fromJSON(e))
        : [],
      audioStreams: globalThis.Array.isArray(object?.audioStreams)
        ? object.audioStreams.map((e: any) => AudioStreamProperty.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InputStreamProperty): unknown {
    const obj: any = {};
    if (message.lastEstablishTime !== undefined) {
      obj.lastEstablishTime = message.lastEstablishTime.toISOString();
    }
    if (message.videoStreams?.length) {
      obj.videoStreams = message.videoStreams.map((e) => VideoStreamProperty.toJSON(e));
    }
    if (message.audioStreams?.length) {
      obj.audioStreams = message.audioStreams.map((e) => AudioStreamProperty.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<InputStreamProperty>): InputStreamProperty {
    return InputStreamProperty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputStreamProperty>): InputStreamProperty {
    const message = createBaseInputStreamProperty();
    message.lastEstablishTime = object.lastEstablishTime ?? undefined;
    message.videoStreams = object.videoStreams?.map((e) => VideoStreamProperty.fromPartial(e)) || [];
    message.audioStreams = object.audioStreams?.map((e) => AudioStreamProperty.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVideoStreamProperty(): VideoStreamProperty {
  return { index: 0, videoFormat: undefined };
}

export const VideoStreamProperty: MessageFns<VideoStreamProperty> = {
  encode(message: VideoStreamProperty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.videoFormat !== undefined) {
      VideoFormat.encode(message.videoFormat, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoStreamProperty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoStreamProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.videoFormat = VideoFormat.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoStreamProperty {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      videoFormat: isSet(object.videoFormat) ? VideoFormat.fromJSON(object.videoFormat) : undefined,
    };
  },

  toJSON(message: VideoStreamProperty): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.videoFormat !== undefined) {
      obj.videoFormat = VideoFormat.toJSON(message.videoFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<VideoStreamProperty>): VideoStreamProperty {
    return VideoStreamProperty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoStreamProperty>): VideoStreamProperty {
    const message = createBaseVideoStreamProperty();
    message.index = object.index ?? 0;
    message.videoFormat = (object.videoFormat !== undefined && object.videoFormat !== null)
      ? VideoFormat.fromPartial(object.videoFormat)
      : undefined;
    return message;
  },
};

function createBaseVideoFormat(): VideoFormat {
  return { codec: "", widthPixels: 0, heightPixels: 0, frameRate: 0 };
}

export const VideoFormat: MessageFns<VideoFormat> = {
  encode(message: VideoFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codec !== "") {
      writer.uint32(10).string(message.codec);
    }
    if (message.widthPixels !== 0) {
      writer.uint32(16).int32(message.widthPixels);
    }
    if (message.heightPixels !== 0) {
      writer.uint32(24).int32(message.heightPixels);
    }
    if (message.frameRate !== 0) {
      writer.uint32(33).double(message.frameRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.codec = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.widthPixels = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.heightPixels = reader.int32();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.frameRate = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoFormat {
    return {
      codec: isSet(object.codec) ? globalThis.String(object.codec) : "",
      widthPixels: isSet(object.widthPixels) ? globalThis.Number(object.widthPixels) : 0,
      heightPixels: isSet(object.heightPixels) ? globalThis.Number(object.heightPixels) : 0,
      frameRate: isSet(object.frameRate) ? globalThis.Number(object.frameRate) : 0,
    };
  },

  toJSON(message: VideoFormat): unknown {
    const obj: any = {};
    if (message.codec !== "") {
      obj.codec = message.codec;
    }
    if (message.widthPixels !== 0) {
      obj.widthPixels = Math.round(message.widthPixels);
    }
    if (message.heightPixels !== 0) {
      obj.heightPixels = Math.round(message.heightPixels);
    }
    if (message.frameRate !== 0) {
      obj.frameRate = message.frameRate;
    }
    return obj;
  },

  create(base?: DeepPartial<VideoFormat>): VideoFormat {
    return VideoFormat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoFormat>): VideoFormat {
    const message = createBaseVideoFormat();
    message.codec = object.codec ?? "";
    message.widthPixels = object.widthPixels ?? 0;
    message.heightPixels = object.heightPixels ?? 0;
    message.frameRate = object.frameRate ?? 0;
    return message;
  },
};

function createBaseAudioStreamProperty(): AudioStreamProperty {
  return { index: 0, audioFormat: undefined };
}

export const AudioStreamProperty: MessageFns<AudioStreamProperty> = {
  encode(message: AudioStreamProperty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.audioFormat !== undefined) {
      AudioFormat.encode(message.audioFormat, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioStreamProperty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioStreamProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audioFormat = AudioFormat.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioStreamProperty {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      audioFormat: isSet(object.audioFormat) ? AudioFormat.fromJSON(object.audioFormat) : undefined,
    };
  },

  toJSON(message: AudioStreamProperty): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.audioFormat !== undefined) {
      obj.audioFormat = AudioFormat.toJSON(message.audioFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<AudioStreamProperty>): AudioStreamProperty {
    return AudioStreamProperty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudioStreamProperty>): AudioStreamProperty {
    const message = createBaseAudioStreamProperty();
    message.index = object.index ?? 0;
    message.audioFormat = (object.audioFormat !== undefined && object.audioFormat !== null)
      ? AudioFormat.fromPartial(object.audioFormat)
      : undefined;
    return message;
  },
};

function createBaseAudioFormat(): AudioFormat {
  return { codec: "", channelCount: 0, channelLayout: [] };
}

export const AudioFormat: MessageFns<AudioFormat> = {
  encode(message: AudioFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codec !== "") {
      writer.uint32(10).string(message.codec);
    }
    if (message.channelCount !== 0) {
      writer.uint32(16).int32(message.channelCount);
    }
    for (const v of message.channelLayout) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.codec = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channelCount = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channelLayout.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioFormat {
    return {
      codec: isSet(object.codec) ? globalThis.String(object.codec) : "",
      channelCount: isSet(object.channelCount) ? globalThis.Number(object.channelCount) : 0,
      channelLayout: globalThis.Array.isArray(object?.channelLayout)
        ? object.channelLayout.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AudioFormat): unknown {
    const obj: any = {};
    if (message.codec !== "") {
      obj.codec = message.codec;
    }
    if (message.channelCount !== 0) {
      obj.channelCount = Math.round(message.channelCount);
    }
    if (message.channelLayout?.length) {
      obj.channelLayout = message.channelLayout;
    }
    return obj;
  },

  create(base?: DeepPartial<AudioFormat>): AudioFormat {
    return AudioFormat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudioFormat>): AudioFormat {
    const message = createBaseAudioFormat();
    message.codec = object.codec ?? "";
    message.channelCount = object.channelCount ?? 0;
    message.channelLayout = object.channelLayout?.map((e) => e) || [];
    return message;
  },
};

function createBaseInputAttachment(): InputAttachment {
  return { key: "", input: "", automaticFailover: undefined };
}

export const InputAttachment: MessageFns<InputAttachment> = {
  encode(message: InputAttachment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    if (message.automaticFailover !== undefined) {
      InputAttachment_AutomaticFailover.encode(message.automaticFailover, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputAttachment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.input = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.automaticFailover = InputAttachment_AutomaticFailover.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputAttachment {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      automaticFailover: isSet(object.automaticFailover)
        ? InputAttachment_AutomaticFailover.fromJSON(object.automaticFailover)
        : undefined,
    };
  },

  toJSON(message: InputAttachment): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.input !== "") {
      obj.input = message.input;
    }
    if (message.automaticFailover !== undefined) {
      obj.automaticFailover = InputAttachment_AutomaticFailover.toJSON(message.automaticFailover);
    }
    return obj;
  },

  create(base?: DeepPartial<InputAttachment>): InputAttachment {
    return InputAttachment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputAttachment>): InputAttachment {
    const message = createBaseInputAttachment();
    message.key = object.key ?? "";
    message.input = object.input ?? "";
    message.automaticFailover = (object.automaticFailover !== undefined && object.automaticFailover !== null)
      ? InputAttachment_AutomaticFailover.fromPartial(object.automaticFailover)
      : undefined;
    return message;
  },
};

function createBaseInputAttachment_AutomaticFailover(): InputAttachment_AutomaticFailover {
  return { inputKeys: [] };
}

export const InputAttachment_AutomaticFailover: MessageFns<InputAttachment_AutomaticFailover> = {
  encode(message: InputAttachment_AutomaticFailover, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inputKeys) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputAttachment_AutomaticFailover {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputAttachment_AutomaticFailover();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputKeys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputAttachment_AutomaticFailover {
    return {
      inputKeys: globalThis.Array.isArray(object?.inputKeys)
        ? object.inputKeys.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: InputAttachment_AutomaticFailover): unknown {
    const obj: any = {};
    if (message.inputKeys?.length) {
      obj.inputKeys = message.inputKeys;
    }
    return obj;
  },

  create(base?: DeepPartial<InputAttachment_AutomaticFailover>): InputAttachment_AutomaticFailover {
    return InputAttachment_AutomaticFailover.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputAttachment_AutomaticFailover>): InputAttachment_AutomaticFailover {
    const message = createBaseInputAttachment_AutomaticFailover();
    message.inputKeys = object.inputKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseEvent(): Event {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    inputSwitch: undefined,
    adBreak: undefined,
    returnToProgram: undefined,
    slate: undefined,
    mute: undefined,
    unmute: undefined,
    executeNow: false,
    executionTime: undefined,
    state: 0,
    error: undefined,
  };
}

export const Event: MessageFns<Event> = {
  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Event_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.inputSwitch !== undefined) {
      Event_InputSwitchTask.encode(message.inputSwitch, writer.uint32(42).fork()).join();
    }
    if (message.adBreak !== undefined) {
      Event_AdBreakTask.encode(message.adBreak, writer.uint32(50).fork()).join();
    }
    if (message.returnToProgram !== undefined) {
      Event_ReturnToProgramTask.encode(message.returnToProgram, writer.uint32(106).fork()).join();
    }
    if (message.slate !== undefined) {
      Event_SlateTask.encode(message.slate, writer.uint32(114).fork()).join();
    }
    if (message.mute !== undefined) {
      Event_MuteTask.encode(message.mute, writer.uint32(122).fork()).join();
    }
    if (message.unmute !== undefined) {
      Event_UnmuteTask.encode(message.unmute, writer.uint32(130).fork()).join();
    }
    if (message.executeNow !== false) {
      writer.uint32(72).bool(message.executeNow);
    }
    if (message.executionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.executionTime), writer.uint32(82).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(88).int32(message.state);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Event_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inputSwitch = Event_InputSwitchTask.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.adBreak = Event_AdBreakTask.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.returnToProgram = Event_ReturnToProgramTask.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.slate = Event_SlateTask.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.mute = Event_MuteTask.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.unmute = Event_UnmuteTask.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.executeNow = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.executionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      inputSwitch: isSet(object.inputSwitch) ? Event_InputSwitchTask.fromJSON(object.inputSwitch) : undefined,
      adBreak: isSet(object.adBreak) ? Event_AdBreakTask.fromJSON(object.adBreak) : undefined,
      returnToProgram: isSet(object.returnToProgram)
        ? Event_ReturnToProgramTask.fromJSON(object.returnToProgram)
        : undefined,
      slate: isSet(object.slate) ? Event_SlateTask.fromJSON(object.slate) : undefined,
      mute: isSet(object.mute) ? Event_MuteTask.fromJSON(object.mute) : undefined,
      unmute: isSet(object.unmute) ? Event_UnmuteTask.fromJSON(object.unmute) : undefined,
      executeNow: isSet(object.executeNow) ? globalThis.Boolean(object.executeNow) : false,
      executionTime: isSet(object.executionTime) ? fromJsonTimestamp(object.executionTime) : undefined,
      state: isSet(object.state) ? event_StateFromJSON(object.state) : 0,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.inputSwitch !== undefined) {
      obj.inputSwitch = Event_InputSwitchTask.toJSON(message.inputSwitch);
    }
    if (message.adBreak !== undefined) {
      obj.adBreak = Event_AdBreakTask.toJSON(message.adBreak);
    }
    if (message.returnToProgram !== undefined) {
      obj.returnToProgram = Event_ReturnToProgramTask.toJSON(message.returnToProgram);
    }
    if (message.slate !== undefined) {
      obj.slate = Event_SlateTask.toJSON(message.slate);
    }
    if (message.mute !== undefined) {
      obj.mute = Event_MuteTask.toJSON(message.mute);
    }
    if (message.unmute !== undefined) {
      obj.unmute = Event_UnmuteTask.toJSON(message.unmute);
    }
    if (message.executeNow !== false) {
      obj.executeNow = message.executeNow;
    }
    if (message.executionTime !== undefined) {
      obj.executionTime = message.executionTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = event_StateToJSON(message.state);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<Event>): Event {
    return Event.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Event>): Event {
    const message = createBaseEvent();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.inputSwitch = (object.inputSwitch !== undefined && object.inputSwitch !== null)
      ? Event_InputSwitchTask.fromPartial(object.inputSwitch)
      : undefined;
    message.adBreak = (object.adBreak !== undefined && object.adBreak !== null)
      ? Event_AdBreakTask.fromPartial(object.adBreak)
      : undefined;
    message.returnToProgram = (object.returnToProgram !== undefined && object.returnToProgram !== null)
      ? Event_ReturnToProgramTask.fromPartial(object.returnToProgram)
      : undefined;
    message.slate = (object.slate !== undefined && object.slate !== null)
      ? Event_SlateTask.fromPartial(object.slate)
      : undefined;
    message.mute = (object.mute !== undefined && object.mute !== null)
      ? Event_MuteTask.fromPartial(object.mute)
      : undefined;
    message.unmute = (object.unmute !== undefined && object.unmute !== null)
      ? Event_UnmuteTask.fromPartial(object.unmute)
      : undefined;
    message.executeNow = object.executeNow ?? false;
    message.executionTime = object.executionTime ?? undefined;
    message.state = object.state ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseEvent_InputSwitchTask(): Event_InputSwitchTask {
  return { inputKey: "" };
}

export const Event_InputSwitchTask: MessageFns<Event_InputSwitchTask> = {
  encode(message: Event_InputSwitchTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputKey !== "") {
      writer.uint32(10).string(message.inputKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event_InputSwitchTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent_InputSwitchTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event_InputSwitchTask {
    return { inputKey: isSet(object.inputKey) ? globalThis.String(object.inputKey) : "" };
  },

  toJSON(message: Event_InputSwitchTask): unknown {
    const obj: any = {};
    if (message.inputKey !== "") {
      obj.inputKey = message.inputKey;
    }
    return obj;
  },

  create(base?: DeepPartial<Event_InputSwitchTask>): Event_InputSwitchTask {
    return Event_InputSwitchTask.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Event_InputSwitchTask>): Event_InputSwitchTask {
    const message = createBaseEvent_InputSwitchTask();
    message.inputKey = object.inputKey ?? "";
    return message;
  },
};

function createBaseEvent_AdBreakTask(): Event_AdBreakTask {
  return { duration: undefined };
}

export const Event_AdBreakTask: MessageFns<Event_AdBreakTask> = {
  encode(message: Event_AdBreakTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event_AdBreakTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent_AdBreakTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event_AdBreakTask {
    return { duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined };
  },

  toJSON(message: Event_AdBreakTask): unknown {
    const obj: any = {};
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    return obj;
  },

  create(base?: DeepPartial<Event_AdBreakTask>): Event_AdBreakTask {
    return Event_AdBreakTask.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Event_AdBreakTask>): Event_AdBreakTask {
    const message = createBaseEvent_AdBreakTask();
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    return message;
  },
};

function createBaseEvent_SlateTask(): Event_SlateTask {
  return { duration: undefined, asset: "" };
}

export const Event_SlateTask: MessageFns<Event_SlateTask> = {
  encode(message: Event_SlateTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(10).fork()).join();
    }
    if (message.asset !== "") {
      writer.uint32(18).string(message.asset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event_SlateTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent_SlateTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.asset = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event_SlateTask {
    return {
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
    };
  },

  toJSON(message: Event_SlateTask): unknown {
    const obj: any = {};
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    return obj;
  },

  create(base?: DeepPartial<Event_SlateTask>): Event_SlateTask {
    return Event_SlateTask.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Event_SlateTask>): Event_SlateTask {
    const message = createBaseEvent_SlateTask();
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.asset = object.asset ?? "";
    return message;
  },
};

function createBaseEvent_ReturnToProgramTask(): Event_ReturnToProgramTask {
  return {};
}

export const Event_ReturnToProgramTask: MessageFns<Event_ReturnToProgramTask> = {
  encode(_: Event_ReturnToProgramTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event_ReturnToProgramTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent_ReturnToProgramTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Event_ReturnToProgramTask {
    return {};
  },

  toJSON(_: Event_ReturnToProgramTask): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Event_ReturnToProgramTask>): Event_ReturnToProgramTask {
    return Event_ReturnToProgramTask.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Event_ReturnToProgramTask>): Event_ReturnToProgramTask {
    const message = createBaseEvent_ReturnToProgramTask();
    return message;
  },
};

function createBaseEvent_MuteTask(): Event_MuteTask {
  return { duration: undefined };
}

export const Event_MuteTask: MessageFns<Event_MuteTask> = {
  encode(message: Event_MuteTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event_MuteTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent_MuteTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event_MuteTask {
    return { duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined };
  },

  toJSON(message: Event_MuteTask): unknown {
    const obj: any = {};
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    return obj;
  },

  create(base?: DeepPartial<Event_MuteTask>): Event_MuteTask {
    return Event_MuteTask.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Event_MuteTask>): Event_MuteTask {
    const message = createBaseEvent_MuteTask();
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    return message;
  },
};

function createBaseEvent_UnmuteTask(): Event_UnmuteTask {
  return {};
}

export const Event_UnmuteTask: MessageFns<Event_UnmuteTask> = {
  encode(_: Event_UnmuteTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event_UnmuteTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent_UnmuteTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Event_UnmuteTask {
    return {};
  },

  toJSON(_: Event_UnmuteTask): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Event_UnmuteTask>): Event_UnmuteTask {
    return Event_UnmuteTask.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Event_UnmuteTask>): Event_UnmuteTask {
    const message = createBaseEvent_UnmuteTask();
    return message;
  },
};

function createBaseEvent_LabelsEntry(): Event_LabelsEntry {
  return { key: "", value: "" };
}

export const Event_LabelsEntry: MessageFns<Event_LabelsEntry> = {
  encode(message: Event_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Event_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Event_LabelsEntry>): Event_LabelsEntry {
    return Event_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Event_LabelsEntry>): Event_LabelsEntry {
    const message = createBaseEvent_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseClip(): Clip {
  return {
    name: "",
    createTime: undefined,
    startTime: undefined,
    updateTime: undefined,
    labels: {},
    state: 0,
    outputUri: "",
    error: undefined,
    slices: [],
    clipManifests: [],
  };
}

export const Clip: MessageFns<Clip> = {
  encode(message: Clip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Clip_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.outputUri !== "") {
      writer.uint32(58).string(message.outputUri);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(74).fork()).join();
    }
    for (const v of message.slices) {
      Clip_Slice.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.clipManifests) {
      Clip_ClipManifest.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Clip {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Clip_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.outputUri = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.slices.push(Clip_Slice.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.clipManifests.push(Clip_ClipManifest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Clip {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      state: isSet(object.state) ? clip_StateFromJSON(object.state) : 0,
      outputUri: isSet(object.outputUri) ? globalThis.String(object.outputUri) : "",
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      slices: globalThis.Array.isArray(object?.slices) ? object.slices.map((e: any) => Clip_Slice.fromJSON(e)) : [],
      clipManifests: globalThis.Array.isArray(object?.clipManifests)
        ? object.clipManifests.map((e: any) => Clip_ClipManifest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Clip): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.state !== 0) {
      obj.state = clip_StateToJSON(message.state);
    }
    if (message.outputUri !== "") {
      obj.outputUri = message.outputUri;
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.slices?.length) {
      obj.slices = message.slices.map((e) => Clip_Slice.toJSON(e));
    }
    if (message.clipManifests?.length) {
      obj.clipManifests = message.clipManifests.map((e) => Clip_ClipManifest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Clip>): Clip {
    return Clip.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Clip>): Clip {
    const message = createBaseClip();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.state = object.state ?? 0;
    message.outputUri = object.outputUri ?? "";
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.slices = object.slices?.map((e) => Clip_Slice.fromPartial(e)) || [];
    message.clipManifests = object.clipManifests?.map((e) => Clip_ClipManifest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClip_TimeSlice(): Clip_TimeSlice {
  return { markinTime: undefined, markoutTime: undefined };
}

export const Clip_TimeSlice: MessageFns<Clip_TimeSlice> = {
  encode(message: Clip_TimeSlice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.markinTime !== undefined) {
      Timestamp.encode(toTimestamp(message.markinTime), writer.uint32(10).fork()).join();
    }
    if (message.markoutTime !== undefined) {
      Timestamp.encode(toTimestamp(message.markoutTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Clip_TimeSlice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClip_TimeSlice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.markinTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.markoutTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Clip_TimeSlice {
    return {
      markinTime: isSet(object.markinTime) ? fromJsonTimestamp(object.markinTime) : undefined,
      markoutTime: isSet(object.markoutTime) ? fromJsonTimestamp(object.markoutTime) : undefined,
    };
  },

  toJSON(message: Clip_TimeSlice): unknown {
    const obj: any = {};
    if (message.markinTime !== undefined) {
      obj.markinTime = message.markinTime.toISOString();
    }
    if (message.markoutTime !== undefined) {
      obj.markoutTime = message.markoutTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Clip_TimeSlice>): Clip_TimeSlice {
    return Clip_TimeSlice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Clip_TimeSlice>): Clip_TimeSlice {
    const message = createBaseClip_TimeSlice();
    message.markinTime = object.markinTime ?? undefined;
    message.markoutTime = object.markoutTime ?? undefined;
    return message;
  },
};

function createBaseClip_Slice(): Clip_Slice {
  return { timeSlice: undefined };
}

export const Clip_Slice: MessageFns<Clip_Slice> = {
  encode(message: Clip_Slice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeSlice !== undefined) {
      Clip_TimeSlice.encode(message.timeSlice, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Clip_Slice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClip_Slice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeSlice = Clip_TimeSlice.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Clip_Slice {
    return { timeSlice: isSet(object.timeSlice) ? Clip_TimeSlice.fromJSON(object.timeSlice) : undefined };
  },

  toJSON(message: Clip_Slice): unknown {
    const obj: any = {};
    if (message.timeSlice !== undefined) {
      obj.timeSlice = Clip_TimeSlice.toJSON(message.timeSlice);
    }
    return obj;
  },

  create(base?: DeepPartial<Clip_Slice>): Clip_Slice {
    return Clip_Slice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Clip_Slice>): Clip_Slice {
    const message = createBaseClip_Slice();
    message.timeSlice = (object.timeSlice !== undefined && object.timeSlice !== null)
      ? Clip_TimeSlice.fromPartial(object.timeSlice)
      : undefined;
    return message;
  },
};

function createBaseClip_ClipManifest(): Clip_ClipManifest {
  return { manifestKey: "", outputUri: "" };
}

export const Clip_ClipManifest: MessageFns<Clip_ClipManifest> = {
  encode(message: Clip_ClipManifest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.manifestKey !== "") {
      writer.uint32(10).string(message.manifestKey);
    }
    if (message.outputUri !== "") {
      writer.uint32(18).string(message.outputUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Clip_ClipManifest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClip_ClipManifest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.manifestKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outputUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Clip_ClipManifest {
    return {
      manifestKey: isSet(object.manifestKey) ? globalThis.String(object.manifestKey) : "",
      outputUri: isSet(object.outputUri) ? globalThis.String(object.outputUri) : "",
    };
  },

  toJSON(message: Clip_ClipManifest): unknown {
    const obj: any = {};
    if (message.manifestKey !== "") {
      obj.manifestKey = message.manifestKey;
    }
    if (message.outputUri !== "") {
      obj.outputUri = message.outputUri;
    }
    return obj;
  },

  create(base?: DeepPartial<Clip_ClipManifest>): Clip_ClipManifest {
    return Clip_ClipManifest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Clip_ClipManifest>): Clip_ClipManifest {
    const message = createBaseClip_ClipManifest();
    message.manifestKey = object.manifestKey ?? "";
    message.outputUri = object.outputUri ?? "";
    return message;
  },
};

function createBaseClip_LabelsEntry(): Clip_LabelsEntry {
  return { key: "", value: "" };
}

export const Clip_LabelsEntry: MessageFns<Clip_LabelsEntry> = {
  encode(message: Clip_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Clip_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClip_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Clip_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Clip_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Clip_LabelsEntry>): Clip_LabelsEntry {
    return Clip_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Clip_LabelsEntry>): Clip_LabelsEntry {
    const message = createBaseClip_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAsset(): Asset {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    video: undefined,
    image: undefined,
    crc32c: "",
    state: 0,
    error: undefined,
  };
}

export const Asset: MessageFns<Asset> = {
  encode(message: Asset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Asset_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.video !== undefined) {
      Asset_VideoAsset.encode(message.video, writer.uint32(42).fork()).join();
    }
    if (message.image !== undefined) {
      Asset_ImageAsset.encode(message.image, writer.uint32(50).fork()).join();
    }
    if (message.crc32c !== "") {
      writer.uint32(58).string(message.crc32c);
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Asset_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.video = Asset_VideoAsset.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.image = Asset_ImageAsset.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.crc32c = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      video: isSet(object.video) ? Asset_VideoAsset.fromJSON(object.video) : undefined,
      image: isSet(object.image) ? Asset_ImageAsset.fromJSON(object.image) : undefined,
      crc32c: isSet(object.crc32c) ? globalThis.String(object.crc32c) : "",
      state: isSet(object.state) ? asset_StateFromJSON(object.state) : 0,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.video !== undefined) {
      obj.video = Asset_VideoAsset.toJSON(message.video);
    }
    if (message.image !== undefined) {
      obj.image = Asset_ImageAsset.toJSON(message.image);
    }
    if (message.crc32c !== "") {
      obj.crc32c = message.crc32c;
    }
    if (message.state !== 0) {
      obj.state = asset_StateToJSON(message.state);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<Asset>): Asset {
    return Asset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset>): Asset {
    const message = createBaseAsset();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.video = (object.video !== undefined && object.video !== null)
      ? Asset_VideoAsset.fromPartial(object.video)
      : undefined;
    message.image = (object.image !== undefined && object.image !== null)
      ? Asset_ImageAsset.fromPartial(object.image)
      : undefined;
    message.crc32c = object.crc32c ?? "";
    message.state = object.state ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseAsset_VideoAsset(): Asset_VideoAsset {
  return { uri: "" };
}

export const Asset_VideoAsset: MessageFns<Asset_VideoAsset> = {
  encode(message: Asset_VideoAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset_VideoAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset_VideoAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset_VideoAsset {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: Asset_VideoAsset): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<Asset_VideoAsset>): Asset_VideoAsset {
    return Asset_VideoAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset_VideoAsset>): Asset_VideoAsset {
    const message = createBaseAsset_VideoAsset();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseAsset_ImageAsset(): Asset_ImageAsset {
  return { uri: "" };
}

export const Asset_ImageAsset: MessageFns<Asset_ImageAsset> = {
  encode(message: Asset_ImageAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset_ImageAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset_ImageAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset_ImageAsset {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: Asset_ImageAsset): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<Asset_ImageAsset>): Asset_ImageAsset {
    return Asset_ImageAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset_ImageAsset>): Asset_ImageAsset {
    const message = createBaseAsset_ImageAsset();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseAsset_LabelsEntry(): Asset_LabelsEntry {
  return { key: "", value: "" };
}

export const Asset_LabelsEntry: MessageFns<Asset_LabelsEntry> = {
  encode(message: Asset_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Asset_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Asset_LabelsEntry>): Asset_LabelsEntry {
    return Asset_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset_LabelsEntry>): Asset_LabelsEntry {
    const message = createBaseAsset_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEncryption(): Encryption {
  return {
    id: "",
    secretManagerKeySource: undefined,
    drmSystems: undefined,
    aes128: undefined,
    sampleAes: undefined,
    mpegCenc: undefined,
  };
}

export const Encryption: MessageFns<Encryption> = {
  encode(message: Encryption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.secretManagerKeySource !== undefined) {
      Encryption_SecretManagerSource.encode(message.secretManagerKeySource, writer.uint32(58).fork()).join();
    }
    if (message.drmSystems !== undefined) {
      Encryption_DrmSystems.encode(message.drmSystems, writer.uint32(26).fork()).join();
    }
    if (message.aes128 !== undefined) {
      Encryption_Aes128Encryption.encode(message.aes128, writer.uint32(34).fork()).join();
    }
    if (message.sampleAes !== undefined) {
      Encryption_SampleAesEncryption.encode(message.sampleAes, writer.uint32(42).fork()).join();
    }
    if (message.mpegCenc !== undefined) {
      Encryption_MpegCommonEncryption.encode(message.mpegCenc, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.secretManagerKeySource = Encryption_SecretManagerSource.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.drmSystems = Encryption_DrmSystems.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.aes128 = Encryption_Aes128Encryption.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sampleAes = Encryption_SampleAesEncryption.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.mpegCenc = Encryption_MpegCommonEncryption.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Encryption {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      secretManagerKeySource: isSet(object.secretManagerKeySource)
        ? Encryption_SecretManagerSource.fromJSON(object.secretManagerKeySource)
        : undefined,
      drmSystems: isSet(object.drmSystems) ? Encryption_DrmSystems.fromJSON(object.drmSystems) : undefined,
      aes128: isSet(object.aes128) ? Encryption_Aes128Encryption.fromJSON(object.aes128) : undefined,
      sampleAes: isSet(object.sampleAes) ? Encryption_SampleAesEncryption.fromJSON(object.sampleAes) : undefined,
      mpegCenc: isSet(object.mpegCenc) ? Encryption_MpegCommonEncryption.fromJSON(object.mpegCenc) : undefined,
    };
  },

  toJSON(message: Encryption): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.secretManagerKeySource !== undefined) {
      obj.secretManagerKeySource = Encryption_SecretManagerSource.toJSON(message.secretManagerKeySource);
    }
    if (message.drmSystems !== undefined) {
      obj.drmSystems = Encryption_DrmSystems.toJSON(message.drmSystems);
    }
    if (message.aes128 !== undefined) {
      obj.aes128 = Encryption_Aes128Encryption.toJSON(message.aes128);
    }
    if (message.sampleAes !== undefined) {
      obj.sampleAes = Encryption_SampleAesEncryption.toJSON(message.sampleAes);
    }
    if (message.mpegCenc !== undefined) {
      obj.mpegCenc = Encryption_MpegCommonEncryption.toJSON(message.mpegCenc);
    }
    return obj;
  },

  create(base?: DeepPartial<Encryption>): Encryption {
    return Encryption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Encryption>): Encryption {
    const message = createBaseEncryption();
    message.id = object.id ?? "";
    message.secretManagerKeySource =
      (object.secretManagerKeySource !== undefined && object.secretManagerKeySource !== null)
        ? Encryption_SecretManagerSource.fromPartial(object.secretManagerKeySource)
        : undefined;
    message.drmSystems = (object.drmSystems !== undefined && object.drmSystems !== null)
      ? Encryption_DrmSystems.fromPartial(object.drmSystems)
      : undefined;
    message.aes128 = (object.aes128 !== undefined && object.aes128 !== null)
      ? Encryption_Aes128Encryption.fromPartial(object.aes128)
      : undefined;
    message.sampleAes = (object.sampleAes !== undefined && object.sampleAes !== null)
      ? Encryption_SampleAesEncryption.fromPartial(object.sampleAes)
      : undefined;
    message.mpegCenc = (object.mpegCenc !== undefined && object.mpegCenc !== null)
      ? Encryption_MpegCommonEncryption.fromPartial(object.mpegCenc)
      : undefined;
    return message;
  },
};

function createBaseEncryption_SecretManagerSource(): Encryption_SecretManagerSource {
  return { secretVersion: "" };
}

export const Encryption_SecretManagerSource: MessageFns<Encryption_SecretManagerSource> = {
  encode(message: Encryption_SecretManagerSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secretVersion !== "") {
      writer.uint32(10).string(message.secretVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_SecretManagerSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_SecretManagerSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.secretVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Encryption_SecretManagerSource {
    return { secretVersion: isSet(object.secretVersion) ? globalThis.String(object.secretVersion) : "" };
  },

  toJSON(message: Encryption_SecretManagerSource): unknown {
    const obj: any = {};
    if (message.secretVersion !== "") {
      obj.secretVersion = message.secretVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<Encryption_SecretManagerSource>): Encryption_SecretManagerSource {
    return Encryption_SecretManagerSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Encryption_SecretManagerSource>): Encryption_SecretManagerSource {
    const message = createBaseEncryption_SecretManagerSource();
    message.secretVersion = object.secretVersion ?? "";
    return message;
  },
};

function createBaseEncryption_Widevine(): Encryption_Widevine {
  return {};
}

export const Encryption_Widevine: MessageFns<Encryption_Widevine> = {
  encode(_: Encryption_Widevine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_Widevine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_Widevine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Encryption_Widevine {
    return {};
  },

  toJSON(_: Encryption_Widevine): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Encryption_Widevine>): Encryption_Widevine {
    return Encryption_Widevine.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Encryption_Widevine>): Encryption_Widevine {
    const message = createBaseEncryption_Widevine();
    return message;
  },
};

function createBaseEncryption_Fairplay(): Encryption_Fairplay {
  return {};
}

export const Encryption_Fairplay: MessageFns<Encryption_Fairplay> = {
  encode(_: Encryption_Fairplay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_Fairplay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_Fairplay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Encryption_Fairplay {
    return {};
  },

  toJSON(_: Encryption_Fairplay): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Encryption_Fairplay>): Encryption_Fairplay {
    return Encryption_Fairplay.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Encryption_Fairplay>): Encryption_Fairplay {
    const message = createBaseEncryption_Fairplay();
    return message;
  },
};

function createBaseEncryption_Playready(): Encryption_Playready {
  return {};
}

export const Encryption_Playready: MessageFns<Encryption_Playready> = {
  encode(_: Encryption_Playready, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_Playready {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_Playready();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Encryption_Playready {
    return {};
  },

  toJSON(_: Encryption_Playready): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Encryption_Playready>): Encryption_Playready {
    return Encryption_Playready.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Encryption_Playready>): Encryption_Playready {
    const message = createBaseEncryption_Playready();
    return message;
  },
};

function createBaseEncryption_Clearkey(): Encryption_Clearkey {
  return {};
}

export const Encryption_Clearkey: MessageFns<Encryption_Clearkey> = {
  encode(_: Encryption_Clearkey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_Clearkey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_Clearkey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Encryption_Clearkey {
    return {};
  },

  toJSON(_: Encryption_Clearkey): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Encryption_Clearkey>): Encryption_Clearkey {
    return Encryption_Clearkey.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Encryption_Clearkey>): Encryption_Clearkey {
    const message = createBaseEncryption_Clearkey();
    return message;
  },
};

function createBaseEncryption_DrmSystems(): Encryption_DrmSystems {
  return { widevine: undefined, fairplay: undefined, playready: undefined, clearkey: undefined };
}

export const Encryption_DrmSystems: MessageFns<Encryption_DrmSystems> = {
  encode(message: Encryption_DrmSystems, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.widevine !== undefined) {
      Encryption_Widevine.encode(message.widevine, writer.uint32(10).fork()).join();
    }
    if (message.fairplay !== undefined) {
      Encryption_Fairplay.encode(message.fairplay, writer.uint32(18).fork()).join();
    }
    if (message.playready !== undefined) {
      Encryption_Playready.encode(message.playready, writer.uint32(26).fork()).join();
    }
    if (message.clearkey !== undefined) {
      Encryption_Clearkey.encode(message.clearkey, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_DrmSystems {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_DrmSystems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.widevine = Encryption_Widevine.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fairplay = Encryption_Fairplay.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.playready = Encryption_Playready.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clearkey = Encryption_Clearkey.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Encryption_DrmSystems {
    return {
      widevine: isSet(object.widevine) ? Encryption_Widevine.fromJSON(object.widevine) : undefined,
      fairplay: isSet(object.fairplay) ? Encryption_Fairplay.fromJSON(object.fairplay) : undefined,
      playready: isSet(object.playready) ? Encryption_Playready.fromJSON(object.playready) : undefined,
      clearkey: isSet(object.clearkey) ? Encryption_Clearkey.fromJSON(object.clearkey) : undefined,
    };
  },

  toJSON(message: Encryption_DrmSystems): unknown {
    const obj: any = {};
    if (message.widevine !== undefined) {
      obj.widevine = Encryption_Widevine.toJSON(message.widevine);
    }
    if (message.fairplay !== undefined) {
      obj.fairplay = Encryption_Fairplay.toJSON(message.fairplay);
    }
    if (message.playready !== undefined) {
      obj.playready = Encryption_Playready.toJSON(message.playready);
    }
    if (message.clearkey !== undefined) {
      obj.clearkey = Encryption_Clearkey.toJSON(message.clearkey);
    }
    return obj;
  },

  create(base?: DeepPartial<Encryption_DrmSystems>): Encryption_DrmSystems {
    return Encryption_DrmSystems.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Encryption_DrmSystems>): Encryption_DrmSystems {
    const message = createBaseEncryption_DrmSystems();
    message.widevine = (object.widevine !== undefined && object.widevine !== null)
      ? Encryption_Widevine.fromPartial(object.widevine)
      : undefined;
    message.fairplay = (object.fairplay !== undefined && object.fairplay !== null)
      ? Encryption_Fairplay.fromPartial(object.fairplay)
      : undefined;
    message.playready = (object.playready !== undefined && object.playready !== null)
      ? Encryption_Playready.fromPartial(object.playready)
      : undefined;
    message.clearkey = (object.clearkey !== undefined && object.clearkey !== null)
      ? Encryption_Clearkey.fromPartial(object.clearkey)
      : undefined;
    return message;
  },
};

function createBaseEncryption_Aes128Encryption(): Encryption_Aes128Encryption {
  return {};
}

export const Encryption_Aes128Encryption: MessageFns<Encryption_Aes128Encryption> = {
  encode(_: Encryption_Aes128Encryption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_Aes128Encryption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_Aes128Encryption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Encryption_Aes128Encryption {
    return {};
  },

  toJSON(_: Encryption_Aes128Encryption): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Encryption_Aes128Encryption>): Encryption_Aes128Encryption {
    return Encryption_Aes128Encryption.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Encryption_Aes128Encryption>): Encryption_Aes128Encryption {
    const message = createBaseEncryption_Aes128Encryption();
    return message;
  },
};

function createBaseEncryption_SampleAesEncryption(): Encryption_SampleAesEncryption {
  return {};
}

export const Encryption_SampleAesEncryption: MessageFns<Encryption_SampleAesEncryption> = {
  encode(_: Encryption_SampleAesEncryption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_SampleAesEncryption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_SampleAesEncryption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Encryption_SampleAesEncryption {
    return {};
  },

  toJSON(_: Encryption_SampleAesEncryption): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Encryption_SampleAesEncryption>): Encryption_SampleAesEncryption {
    return Encryption_SampleAesEncryption.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Encryption_SampleAesEncryption>): Encryption_SampleAesEncryption {
    const message = createBaseEncryption_SampleAesEncryption();
    return message;
  },
};

function createBaseEncryption_MpegCommonEncryption(): Encryption_MpegCommonEncryption {
  return { scheme: "" };
}

export const Encryption_MpegCommonEncryption: MessageFns<Encryption_MpegCommonEncryption> = {
  encode(message: Encryption_MpegCommonEncryption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheme !== "") {
      writer.uint32(10).string(message.scheme);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_MpegCommonEncryption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_MpegCommonEncryption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.scheme = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Encryption_MpegCommonEncryption {
    return { scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : "" };
  },

  toJSON(message: Encryption_MpegCommonEncryption): unknown {
    const obj: any = {};
    if (message.scheme !== "") {
      obj.scheme = message.scheme;
    }
    return obj;
  },

  create(base?: DeepPartial<Encryption_MpegCommonEncryption>): Encryption_MpegCommonEncryption {
    return Encryption_MpegCommonEncryption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Encryption_MpegCommonEncryption>): Encryption_MpegCommonEncryption {
    const message = createBaseEncryption_MpegCommonEncryption();
    message.scheme = object.scheme ?? "";
    return message;
  },
};

function createBasePool(): Pool {
  return { name: "", createTime: undefined, updateTime: undefined, labels: {}, networkConfig: undefined };
}

export const Pool: MessageFns<Pool> = {
  encode(message: Pool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Pool_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.networkConfig !== undefined) {
      Pool_NetworkConfig.encode(message.networkConfig, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Pool_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.networkConfig = Pool_NetworkConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      networkConfig: isSet(object.networkConfig) ? Pool_NetworkConfig.fromJSON(object.networkConfig) : undefined,
    };
  },

  toJSON(message: Pool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.networkConfig !== undefined) {
      obj.networkConfig = Pool_NetworkConfig.toJSON(message.networkConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Pool>): Pool {
    return Pool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pool>): Pool {
    const message = createBasePool();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.networkConfig = (object.networkConfig !== undefined && object.networkConfig !== null)
      ? Pool_NetworkConfig.fromPartial(object.networkConfig)
      : undefined;
    return message;
  },
};

function createBasePool_NetworkConfig(): Pool_NetworkConfig {
  return { peeredNetwork: "" };
}

export const Pool_NetworkConfig: MessageFns<Pool_NetworkConfig> = {
  encode(message: Pool_NetworkConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peeredNetwork !== "") {
      writer.uint32(10).string(message.peeredNetwork);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pool_NetworkConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePool_NetworkConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.peeredNetwork = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pool_NetworkConfig {
    return { peeredNetwork: isSet(object.peeredNetwork) ? globalThis.String(object.peeredNetwork) : "" };
  },

  toJSON(message: Pool_NetworkConfig): unknown {
    const obj: any = {};
    if (message.peeredNetwork !== "") {
      obj.peeredNetwork = message.peeredNetwork;
    }
    return obj;
  },

  create(base?: DeepPartial<Pool_NetworkConfig>): Pool_NetworkConfig {
    return Pool_NetworkConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pool_NetworkConfig>): Pool_NetworkConfig {
    const message = createBasePool_NetworkConfig();
    message.peeredNetwork = object.peeredNetwork ?? "";
    return message;
  },
};

function createBasePool_LabelsEntry(): Pool_LabelsEntry {
  return { key: "", value: "" };
}

export const Pool_LabelsEntry: MessageFns<Pool_LabelsEntry> = {
  encode(message: Pool_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pool_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePool_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pool_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Pool_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Pool_LabelsEntry>): Pool_LabelsEntry {
    return Pool_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pool_LabelsEntry>): Pool_LabelsEntry {
    const message = createBasePool_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
