// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/video/stitcher/v1/sessions.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration.js";
import { CompanionAds } from "./companions.js";
import { Event, ProgressEvent } from "./events.js";
import { AdTracking, adTrackingFromJSON, adTrackingToJSON } from "./live_configs.js";

export const protobufPackage = "google.cloud.video.stitcher.v1";

/** Metadata for a VOD session. The session expires 4 hours after its creation. */
export interface VodSession {
  /**
   * Output only. The name of the VOD session, in the form of
   * `projects/{project_number}/locations/{location}/vodSessions/{id}`.
   */
  name: string;
  /** Output only. Metadata of what was stitched into the content. */
  interstitials:
    | Interstitials
    | undefined;
  /** Output only. The playback URI of the stitched content. */
  playUri: string;
  /**
   * URI of the media to stitch. For most use cases, you should create a
   * [VodConfig][google.cloud.video.stitcher.v1.VodConfig] with this information
   * rather than setting this field directly.
   */
  sourceUri: string;
  /**
   * Ad tag URI. For most use cases, you should create a
   * [VodConfig][google.cloud.video.stitcher.v1.VodConfig] with this information
   * rather than setting this field directly.
   */
  adTagUri: string;
  /**
   * Key value pairs for ad tag macro replacement, only available for VOD
   * sessions that do not implement Google Ad manager ad insertion. If the
   * specified ad tag URI has macros, this field provides the mapping to the
   * value that will replace the macro in the ad tag URI.
   *
   * Macros are designated by square brackets, for example:
   *
   *   Ad tag URI: `"https://doubleclick.google.com/ad/1?geo_id=[geoId]"`
   *
   *   Ad tag macro map: `{"geoId": "123"}`
   *
   *   Fully qualified ad tag:
   *   `"https://doubleclick.google.com/ad/1?geo_id=123"`
   */
  adTagMacroMap: { [key: string]: string };
  /** Additional options that affect the output of the manifest. */
  manifestOptions:
    | ManifestOptions
    | undefined;
  /** Output only. The generated ID of the VodSession's source media. */
  assetId: string;
  /** Required. Determines how the ad should be tracked. */
  adTracking: AdTracking;
  /**
   * This field should be set with appropriate values if GAM is being used for
   * ads.
   */
  gamSettings:
    | VodSession_GamSettings
    | undefined;
  /**
   * The resource name of the VOD config for this session, in the form of
   * `projects/{project}/locations/{location}/vodConfigs/{id}`.
   */
  vodConfig: string;
}

/**
 * Defines fields related to Google Ad Manager (GAM). This should be set if
 * GAM is being used for ads.
 */
export interface VodSession_GamSettings {
  /** Required. Ad Manager network code. */
  networkCode: string;
  /** Required. The stream ID generated by Ad Manager. */
  streamId: string;
}

export interface VodSession_AdTagMacroMapEntry {
  key: string;
  value: string;
}

/** Describes what was stitched into a VOD session's manifest. */
export interface Interstitials {
  /** List of ad breaks ordered by time. */
  adBreaks: VodSessionAdBreak[];
  /** Information related to the content of the VOD session. */
  sessionContent: VodSessionContent | undefined;
}

/** Metadata for an inserted ad in a VOD session. */
export interface VodSessionAd {
  /** Duration in seconds of the ad. */
  duration:
    | Duration
    | undefined;
  /** Metadata of companion ads associated with the ad. */
  companionAds:
    | CompanionAds
    | undefined;
  /**
   * The list of progress tracking events for the ad break. These can be of
   * the following IAB types: `MUTE`, `UNMUTE`, `PAUSE`, `CLICK`,
   * `CLICK_THROUGH`, `REWIND`, `RESUME`, `ERROR`, `FULLSCREEN`,
   * `EXIT_FULLSCREEN`, `EXPAND`, `COLLAPSE`, `ACCEPT_INVITATION_LINEAR`,
   * `CLOSE_LINEAR`, `SKIP`.
   */
  activityEvents: Event[];
}

/** Metadata for the entire stitched content in a VOD session. */
export interface VodSessionContent {
  /**
   * The total duration in seconds of the content including the ads stitched
   * in.
   */
  duration: Duration | undefined;
}

/** Metadata for an inserted ad break. */
export interface VodSessionAdBreak {
  /** List of events that are expected to be triggered, ordered by time. */
  progressEvents: ProgressEvent[];
  /** Ordered list of ads stitched into the ad break. */
  ads: VodSessionAd[];
  /** Ad break end time in seconds relative to the start of the VOD asset. */
  endTimeOffset:
    | Duration
    | undefined;
  /** Ad break start time in seconds relative to the start of the VOD asset. */
  startTimeOffset: Duration | undefined;
}

/**
 * Metadata for a live session. The session expires 5 minutes after the client
 * stops fetching the session's playlists.
 */
export interface LiveSession {
  /**
   * Output only. The name of the live session, in the form of
   * `projects/{project}/locations/{location}/liveSessions/{id}`.
   */
  name: string;
  /** Output only. The URI to play the live session's ad-stitched stream. */
  playUri: string;
  /**
   * Key value pairs for ad tag macro replacement, only available for live
   * sessions that do not implement Google Ad manager ad insertion. If the
   * specified ad tag URI has macros, this field provides the mapping to the
   * value that will replace the macro in the ad tag URI.
   *
   * Macros are designated by square brackets, for example:
   *
   *   Ad tag URI: "https://doubleclick.google.com/ad/1?geo_id=[geoId]"
   *
   *   Ad tag macros: `{"geoId": "123"}`
   *
   *   Fully qualified ad tag:
   *   `"https://doubleclick.google.com/ad/1?geo_id=123"`
   */
  adTagMacros: { [key: string]: string };
  /** Additional options that affect the output of the manifest. */
  manifestOptions:
    | ManifestOptions
    | undefined;
  /**
   * This field should be set with appropriate values if GAM is being used for
   * ads.
   */
  gamSettings:
    | LiveSession_GamSettings
    | undefined;
  /**
   * Required. The resource name of the live config for this session, in the
   * form of `projects/{project}/locations/{location}/liveConfigs/{id}`.
   */
  liveConfig: string;
  /**
   * Determines how the ad should be tracked. This overrides the value set in
   * the live config for this session.
   */
  adTracking: AdTracking;
}

/** Defines fields related to Google Ad Manager (GAM). */
export interface LiveSession_GamSettings {
  /**
   * Required. The stream ID generated by Ad Manager. This must be set if GAM
   * is being used for ads and the session uses client-side ad tracking.
   */
  streamId: string;
  /**
   * [Targeting
   * parameters](https://support.google.com/admanager/answer/7320899) to send
   * to Ad Manager to generate a stream ID. This should only be set if the
   * session uses server-side ad tracking.
   */
  targetingParameters: { [key: string]: string };
}

export interface LiveSession_GamSettings_TargetingParametersEntry {
  key: string;
  value: string;
}

export interface LiveSession_AdTagMacrosEntry {
  key: string;
  value: string;
}

/** Options for manifest generation. */
export interface ManifestOptions {
  /**
   * If specified, the output manifest will only return renditions matching the
   * specified filters.
   */
  includeRenditions: RenditionFilter[];
  /**
   * If specified, the output manifest will orders the video and muxed
   * renditions by bitrate according to the ordering policy.
   */
  bitrateOrder: ManifestOptions_OrderPolicy;
}

/** Defines the ordering policy during manifest generation. */
export enum ManifestOptions_OrderPolicy {
  /** ORDER_POLICY_UNSPECIFIED - Ordering policy is not specified. */
  ORDER_POLICY_UNSPECIFIED = 0,
  /** ASCENDING - Order by ascending. */
  ASCENDING = 1,
  /** DESCENDING - Order by descending. */
  DESCENDING = 2,
  UNRECOGNIZED = -1,
}

export function manifestOptions_OrderPolicyFromJSON(object: any): ManifestOptions_OrderPolicy {
  switch (object) {
    case 0:
    case "ORDER_POLICY_UNSPECIFIED":
      return ManifestOptions_OrderPolicy.ORDER_POLICY_UNSPECIFIED;
    case 1:
    case "ASCENDING":
      return ManifestOptions_OrderPolicy.ASCENDING;
    case 2:
    case "DESCENDING":
      return ManifestOptions_OrderPolicy.DESCENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ManifestOptions_OrderPolicy.UNRECOGNIZED;
  }
}

export function manifestOptions_OrderPolicyToJSON(object: ManifestOptions_OrderPolicy): string {
  switch (object) {
    case ManifestOptions_OrderPolicy.ORDER_POLICY_UNSPECIFIED:
      return "ORDER_POLICY_UNSPECIFIED";
    case ManifestOptions_OrderPolicy.ASCENDING:
      return "ASCENDING";
    case ManifestOptions_OrderPolicy.DESCENDING:
      return "DESCENDING";
    case ManifestOptions_OrderPolicy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Filters for a video or muxed redition. */
export interface RenditionFilter {
  /**
   * Bitrate in bits per second for the rendition. If set, only renditions with
   * the exact bitrate will match.
   */
  bitrateBps: number;
  /**
   * Codecs for the rendition. If set, only renditions with the exact value
   * will match.
   */
  codecs: string;
}

function createBaseVodSession(): VodSession {
  return {
    name: "",
    interstitials: undefined,
    playUri: "",
    sourceUri: "",
    adTagUri: "",
    adTagMacroMap: {},
    manifestOptions: undefined,
    assetId: "",
    adTracking: 0,
    gamSettings: undefined,
    vodConfig: "",
  };
}

export const VodSession: MessageFns<VodSession> = {
  encode(message: VodSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.interstitials !== undefined) {
      Interstitials.encode(message.interstitials, writer.uint32(18).fork()).join();
    }
    if (message.playUri !== "") {
      writer.uint32(34).string(message.playUri);
    }
    if (message.sourceUri !== "") {
      writer.uint32(42).string(message.sourceUri);
    }
    if (message.adTagUri !== "") {
      writer.uint32(50).string(message.adTagUri);
    }
    Object.entries(message.adTagMacroMap).forEach(([key, value]) => {
      VodSession_AdTagMacroMapEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.manifestOptions !== undefined) {
      ManifestOptions.encode(message.manifestOptions, writer.uint32(74).fork()).join();
    }
    if (message.assetId !== "") {
      writer.uint32(82).string(message.assetId);
    }
    if (message.adTracking !== 0) {
      writer.uint32(88).int32(message.adTracking);
    }
    if (message.gamSettings !== undefined) {
      VodSession_GamSettings.encode(message.gamSettings, writer.uint32(106).fork()).join();
    }
    if (message.vodConfig !== "") {
      writer.uint32(114).string(message.vodConfig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VodSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVodSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.interstitials = Interstitials.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.playUri = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sourceUri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.adTagUri = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = VodSession_AdTagMacroMapEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.adTagMacroMap[entry7.key] = entry7.value;
          }
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.manifestOptions = ManifestOptions.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.assetId = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.adTracking = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.gamSettings = VodSession_GamSettings.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.vodConfig = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VodSession {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      interstitials: isSet(object.interstitials) ? Interstitials.fromJSON(object.interstitials) : undefined,
      playUri: isSet(object.playUri) ? globalThis.String(object.playUri) : "",
      sourceUri: isSet(object.sourceUri) ? globalThis.String(object.sourceUri) : "",
      adTagUri: isSet(object.adTagUri) ? globalThis.String(object.adTagUri) : "",
      adTagMacroMap: isObject(object.adTagMacroMap)
        ? Object.entries(object.adTagMacroMap).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      manifestOptions: isSet(object.manifestOptions) ? ManifestOptions.fromJSON(object.manifestOptions) : undefined,
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      adTracking: isSet(object.adTracking) ? adTrackingFromJSON(object.adTracking) : 0,
      gamSettings: isSet(object.gamSettings) ? VodSession_GamSettings.fromJSON(object.gamSettings) : undefined,
      vodConfig: isSet(object.vodConfig) ? globalThis.String(object.vodConfig) : "",
    };
  },

  toJSON(message: VodSession): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.interstitials !== undefined) {
      obj.interstitials = Interstitials.toJSON(message.interstitials);
    }
    if (message.playUri !== "") {
      obj.playUri = message.playUri;
    }
    if (message.sourceUri !== "") {
      obj.sourceUri = message.sourceUri;
    }
    if (message.adTagUri !== "") {
      obj.adTagUri = message.adTagUri;
    }
    if (message.adTagMacroMap) {
      const entries = Object.entries(message.adTagMacroMap);
      if (entries.length > 0) {
        obj.adTagMacroMap = {};
        entries.forEach(([k, v]) => {
          obj.adTagMacroMap[k] = v;
        });
      }
    }
    if (message.manifestOptions !== undefined) {
      obj.manifestOptions = ManifestOptions.toJSON(message.manifestOptions);
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.adTracking !== 0) {
      obj.adTracking = adTrackingToJSON(message.adTracking);
    }
    if (message.gamSettings !== undefined) {
      obj.gamSettings = VodSession_GamSettings.toJSON(message.gamSettings);
    }
    if (message.vodConfig !== "") {
      obj.vodConfig = message.vodConfig;
    }
    return obj;
  },

  create(base?: DeepPartial<VodSession>): VodSession {
    return VodSession.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VodSession>): VodSession {
    const message = createBaseVodSession();
    message.name = object.name ?? "";
    message.interstitials = (object.interstitials !== undefined && object.interstitials !== null)
      ? Interstitials.fromPartial(object.interstitials)
      : undefined;
    message.playUri = object.playUri ?? "";
    message.sourceUri = object.sourceUri ?? "";
    message.adTagUri = object.adTagUri ?? "";
    message.adTagMacroMap = Object.entries(object.adTagMacroMap ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.manifestOptions = (object.manifestOptions !== undefined && object.manifestOptions !== null)
      ? ManifestOptions.fromPartial(object.manifestOptions)
      : undefined;
    message.assetId = object.assetId ?? "";
    message.adTracking = object.adTracking ?? 0;
    message.gamSettings = (object.gamSettings !== undefined && object.gamSettings !== null)
      ? VodSession_GamSettings.fromPartial(object.gamSettings)
      : undefined;
    message.vodConfig = object.vodConfig ?? "";
    return message;
  },
};

function createBaseVodSession_GamSettings(): VodSession_GamSettings {
  return { networkCode: "", streamId: "" };
}

export const VodSession_GamSettings: MessageFns<VodSession_GamSettings> = {
  encode(message: VodSession_GamSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkCode !== "") {
      writer.uint32(10).string(message.networkCode);
    }
    if (message.streamId !== "") {
      writer.uint32(18).string(message.streamId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VodSession_GamSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVodSession_GamSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networkCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.streamId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VodSession_GamSettings {
    return {
      networkCode: isSet(object.networkCode) ? globalThis.String(object.networkCode) : "",
      streamId: isSet(object.streamId) ? globalThis.String(object.streamId) : "",
    };
  },

  toJSON(message: VodSession_GamSettings): unknown {
    const obj: any = {};
    if (message.networkCode !== "") {
      obj.networkCode = message.networkCode;
    }
    if (message.streamId !== "") {
      obj.streamId = message.streamId;
    }
    return obj;
  },

  create(base?: DeepPartial<VodSession_GamSettings>): VodSession_GamSettings {
    return VodSession_GamSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VodSession_GamSettings>): VodSession_GamSettings {
    const message = createBaseVodSession_GamSettings();
    message.networkCode = object.networkCode ?? "";
    message.streamId = object.streamId ?? "";
    return message;
  },
};

function createBaseVodSession_AdTagMacroMapEntry(): VodSession_AdTagMacroMapEntry {
  return { key: "", value: "" };
}

export const VodSession_AdTagMacroMapEntry: MessageFns<VodSession_AdTagMacroMapEntry> = {
  encode(message: VodSession_AdTagMacroMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VodSession_AdTagMacroMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVodSession_AdTagMacroMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VodSession_AdTagMacroMapEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: VodSession_AdTagMacroMapEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<VodSession_AdTagMacroMapEntry>): VodSession_AdTagMacroMapEntry {
    return VodSession_AdTagMacroMapEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VodSession_AdTagMacroMapEntry>): VodSession_AdTagMacroMapEntry {
    const message = createBaseVodSession_AdTagMacroMapEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInterstitials(): Interstitials {
  return { adBreaks: [], sessionContent: undefined };
}

export const Interstitials: MessageFns<Interstitials> = {
  encode(message: Interstitials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.adBreaks) {
      VodSessionAdBreak.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.sessionContent !== undefined) {
      VodSessionContent.encode(message.sessionContent, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Interstitials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterstitials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adBreaks.push(VodSessionAdBreak.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sessionContent = VodSessionContent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Interstitials {
    return {
      adBreaks: globalThis.Array.isArray(object?.adBreaks)
        ? object.adBreaks.map((e: any) => VodSessionAdBreak.fromJSON(e))
        : [],
      sessionContent: isSet(object.sessionContent) ? VodSessionContent.fromJSON(object.sessionContent) : undefined,
    };
  },

  toJSON(message: Interstitials): unknown {
    const obj: any = {};
    if (message.adBreaks?.length) {
      obj.adBreaks = message.adBreaks.map((e) => VodSessionAdBreak.toJSON(e));
    }
    if (message.sessionContent !== undefined) {
      obj.sessionContent = VodSessionContent.toJSON(message.sessionContent);
    }
    return obj;
  },

  create(base?: DeepPartial<Interstitials>): Interstitials {
    return Interstitials.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Interstitials>): Interstitials {
    const message = createBaseInterstitials();
    message.adBreaks = object.adBreaks?.map((e) => VodSessionAdBreak.fromPartial(e)) || [];
    message.sessionContent = (object.sessionContent !== undefined && object.sessionContent !== null)
      ? VodSessionContent.fromPartial(object.sessionContent)
      : undefined;
    return message;
  },
};

function createBaseVodSessionAd(): VodSessionAd {
  return { duration: undefined, companionAds: undefined, activityEvents: [] };
}

export const VodSessionAd: MessageFns<VodSessionAd> = {
  encode(message: VodSessionAd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(10).fork()).join();
    }
    if (message.companionAds !== undefined) {
      CompanionAds.encode(message.companionAds, writer.uint32(18).fork()).join();
    }
    for (const v of message.activityEvents) {
      Event.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VodSessionAd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVodSessionAd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.companionAds = CompanionAds.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.activityEvents.push(Event.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VodSessionAd {
    return {
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      companionAds: isSet(object.companionAds) ? CompanionAds.fromJSON(object.companionAds) : undefined,
      activityEvents: globalThis.Array.isArray(object?.activityEvents)
        ? object.activityEvents.map((e: any) => Event.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VodSessionAd): unknown {
    const obj: any = {};
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.companionAds !== undefined) {
      obj.companionAds = CompanionAds.toJSON(message.companionAds);
    }
    if (message.activityEvents?.length) {
      obj.activityEvents = message.activityEvents.map((e) => Event.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VodSessionAd>): VodSessionAd {
    return VodSessionAd.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VodSessionAd>): VodSessionAd {
    const message = createBaseVodSessionAd();
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.companionAds = (object.companionAds !== undefined && object.companionAds !== null)
      ? CompanionAds.fromPartial(object.companionAds)
      : undefined;
    message.activityEvents = object.activityEvents?.map((e) => Event.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVodSessionContent(): VodSessionContent {
  return { duration: undefined };
}

export const VodSessionContent: MessageFns<VodSessionContent> = {
  encode(message: VodSessionContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VodSessionContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVodSessionContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VodSessionContent {
    return { duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined };
  },

  toJSON(message: VodSessionContent): unknown {
    const obj: any = {};
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    return obj;
  },

  create(base?: DeepPartial<VodSessionContent>): VodSessionContent {
    return VodSessionContent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VodSessionContent>): VodSessionContent {
    const message = createBaseVodSessionContent();
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    return message;
  },
};

function createBaseVodSessionAdBreak(): VodSessionAdBreak {
  return { progressEvents: [], ads: [], endTimeOffset: undefined, startTimeOffset: undefined };
}

export const VodSessionAdBreak: MessageFns<VodSessionAdBreak> = {
  encode(message: VodSessionAdBreak, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.progressEvents) {
      ProgressEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.ads) {
      VodSessionAd.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.endTimeOffset !== undefined) {
      Duration.encode(message.endTimeOffset, writer.uint32(26).fork()).join();
    }
    if (message.startTimeOffset !== undefined) {
      Duration.encode(message.startTimeOffset, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VodSessionAdBreak {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVodSessionAdBreak();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.progressEvents.push(ProgressEvent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ads.push(VodSessionAd.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTimeOffset = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTimeOffset = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VodSessionAdBreak {
    return {
      progressEvents: globalThis.Array.isArray(object?.progressEvents)
        ? object.progressEvents.map((e: any) => ProgressEvent.fromJSON(e))
        : [],
      ads: globalThis.Array.isArray(object?.ads) ? object.ads.map((e: any) => VodSessionAd.fromJSON(e)) : [],
      endTimeOffset: isSet(object.endTimeOffset) ? Duration.fromJSON(object.endTimeOffset) : undefined,
      startTimeOffset: isSet(object.startTimeOffset) ? Duration.fromJSON(object.startTimeOffset) : undefined,
    };
  },

  toJSON(message: VodSessionAdBreak): unknown {
    const obj: any = {};
    if (message.progressEvents?.length) {
      obj.progressEvents = message.progressEvents.map((e) => ProgressEvent.toJSON(e));
    }
    if (message.ads?.length) {
      obj.ads = message.ads.map((e) => VodSessionAd.toJSON(e));
    }
    if (message.endTimeOffset !== undefined) {
      obj.endTimeOffset = Duration.toJSON(message.endTimeOffset);
    }
    if (message.startTimeOffset !== undefined) {
      obj.startTimeOffset = Duration.toJSON(message.startTimeOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<VodSessionAdBreak>): VodSessionAdBreak {
    return VodSessionAdBreak.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VodSessionAdBreak>): VodSessionAdBreak {
    const message = createBaseVodSessionAdBreak();
    message.progressEvents = object.progressEvents?.map((e) => ProgressEvent.fromPartial(e)) || [];
    message.ads = object.ads?.map((e) => VodSessionAd.fromPartial(e)) || [];
    message.endTimeOffset = (object.endTimeOffset !== undefined && object.endTimeOffset !== null)
      ? Duration.fromPartial(object.endTimeOffset)
      : undefined;
    message.startTimeOffset = (object.startTimeOffset !== undefined && object.startTimeOffset !== null)
      ? Duration.fromPartial(object.startTimeOffset)
      : undefined;
    return message;
  },
};

function createBaseLiveSession(): LiveSession {
  return {
    name: "",
    playUri: "",
    adTagMacros: {},
    manifestOptions: undefined,
    gamSettings: undefined,
    liveConfig: "",
    adTracking: 0,
  };
}

export const LiveSession: MessageFns<LiveSession> = {
  encode(message: LiveSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.playUri !== "") {
      writer.uint32(18).string(message.playUri);
    }
    Object.entries(message.adTagMacros).forEach(([key, value]) => {
      LiveSession_AdTagMacrosEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.manifestOptions !== undefined) {
      ManifestOptions.encode(message.manifestOptions, writer.uint32(82).fork()).join();
    }
    if (message.gamSettings !== undefined) {
      LiveSession_GamSettings.encode(message.gamSettings, writer.uint32(122).fork()).join();
    }
    if (message.liveConfig !== "") {
      writer.uint32(130).string(message.liveConfig);
    }
    if (message.adTracking !== 0) {
      writer.uint32(136).int32(message.adTracking);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.playUri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = LiveSession_AdTagMacrosEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.adTagMacros[entry6.key] = entry6.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.manifestOptions = ManifestOptions.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.gamSettings = LiveSession_GamSettings.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.liveConfig = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.adTracking = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LiveSession {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      playUri: isSet(object.playUri) ? globalThis.String(object.playUri) : "",
      adTagMacros: isObject(object.adTagMacros)
        ? Object.entries(object.adTagMacros).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      manifestOptions: isSet(object.manifestOptions) ? ManifestOptions.fromJSON(object.manifestOptions) : undefined,
      gamSettings: isSet(object.gamSettings) ? LiveSession_GamSettings.fromJSON(object.gamSettings) : undefined,
      liveConfig: isSet(object.liveConfig) ? globalThis.String(object.liveConfig) : "",
      adTracking: isSet(object.adTracking) ? adTrackingFromJSON(object.adTracking) : 0,
    };
  },

  toJSON(message: LiveSession): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.playUri !== "") {
      obj.playUri = message.playUri;
    }
    if (message.adTagMacros) {
      const entries = Object.entries(message.adTagMacros);
      if (entries.length > 0) {
        obj.adTagMacros = {};
        entries.forEach(([k, v]) => {
          obj.adTagMacros[k] = v;
        });
      }
    }
    if (message.manifestOptions !== undefined) {
      obj.manifestOptions = ManifestOptions.toJSON(message.manifestOptions);
    }
    if (message.gamSettings !== undefined) {
      obj.gamSettings = LiveSession_GamSettings.toJSON(message.gamSettings);
    }
    if (message.liveConfig !== "") {
      obj.liveConfig = message.liveConfig;
    }
    if (message.adTracking !== 0) {
      obj.adTracking = adTrackingToJSON(message.adTracking);
    }
    return obj;
  },

  create(base?: DeepPartial<LiveSession>): LiveSession {
    return LiveSession.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LiveSession>): LiveSession {
    const message = createBaseLiveSession();
    message.name = object.name ?? "";
    message.playUri = object.playUri ?? "";
    message.adTagMacros = Object.entries(object.adTagMacros ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.manifestOptions = (object.manifestOptions !== undefined && object.manifestOptions !== null)
      ? ManifestOptions.fromPartial(object.manifestOptions)
      : undefined;
    message.gamSettings = (object.gamSettings !== undefined && object.gamSettings !== null)
      ? LiveSession_GamSettings.fromPartial(object.gamSettings)
      : undefined;
    message.liveConfig = object.liveConfig ?? "";
    message.adTracking = object.adTracking ?? 0;
    return message;
  },
};

function createBaseLiveSession_GamSettings(): LiveSession_GamSettings {
  return { streamId: "", targetingParameters: {} };
}

export const LiveSession_GamSettings: MessageFns<LiveSession_GamSettings> = {
  encode(message: LiveSession_GamSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streamId !== "") {
      writer.uint32(10).string(message.streamId);
    }
    Object.entries(message.targetingParameters).forEach(([key, value]) => {
      LiveSession_GamSettings_TargetingParametersEntry.encode({ key: key as any, value }, writer.uint32(34).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveSession_GamSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveSession_GamSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streamId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = LiveSession_GamSettings_TargetingParametersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.targetingParameters[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LiveSession_GamSettings {
    return {
      streamId: isSet(object.streamId) ? globalThis.String(object.streamId) : "",
      targetingParameters: isObject(object.targetingParameters)
        ? Object.entries(object.targetingParameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: LiveSession_GamSettings): unknown {
    const obj: any = {};
    if (message.streamId !== "") {
      obj.streamId = message.streamId;
    }
    if (message.targetingParameters) {
      const entries = Object.entries(message.targetingParameters);
      if (entries.length > 0) {
        obj.targetingParameters = {};
        entries.forEach(([k, v]) => {
          obj.targetingParameters[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<LiveSession_GamSettings>): LiveSession_GamSettings {
    return LiveSession_GamSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LiveSession_GamSettings>): LiveSession_GamSettings {
    const message = createBaseLiveSession_GamSettings();
    message.streamId = object.streamId ?? "";
    message.targetingParameters = Object.entries(object.targetingParameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseLiveSession_GamSettings_TargetingParametersEntry(): LiveSession_GamSettings_TargetingParametersEntry {
  return { key: "", value: "" };
}

export const LiveSession_GamSettings_TargetingParametersEntry: MessageFns<
  LiveSession_GamSettings_TargetingParametersEntry
> = {
  encode(
    message: LiveSession_GamSettings_TargetingParametersEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveSession_GamSettings_TargetingParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveSession_GamSettings_TargetingParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LiveSession_GamSettings_TargetingParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LiveSession_GamSettings_TargetingParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<LiveSession_GamSettings_TargetingParametersEntry>,
  ): LiveSession_GamSettings_TargetingParametersEntry {
    return LiveSession_GamSettings_TargetingParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<LiveSession_GamSettings_TargetingParametersEntry>,
  ): LiveSession_GamSettings_TargetingParametersEntry {
    const message = createBaseLiveSession_GamSettings_TargetingParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLiveSession_AdTagMacrosEntry(): LiveSession_AdTagMacrosEntry {
  return { key: "", value: "" };
}

export const LiveSession_AdTagMacrosEntry: MessageFns<LiveSession_AdTagMacrosEntry> = {
  encode(message: LiveSession_AdTagMacrosEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveSession_AdTagMacrosEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveSession_AdTagMacrosEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LiveSession_AdTagMacrosEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LiveSession_AdTagMacrosEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<LiveSession_AdTagMacrosEntry>): LiveSession_AdTagMacrosEntry {
    return LiveSession_AdTagMacrosEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LiveSession_AdTagMacrosEntry>): LiveSession_AdTagMacrosEntry {
    const message = createBaseLiveSession_AdTagMacrosEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseManifestOptions(): ManifestOptions {
  return { includeRenditions: [], bitrateOrder: 0 };
}

export const ManifestOptions: MessageFns<ManifestOptions> = {
  encode(message: ManifestOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.includeRenditions) {
      RenditionFilter.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.bitrateOrder !== 0) {
      writer.uint32(16).int32(message.bitrateOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManifestOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManifestOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.includeRenditions.push(RenditionFilter.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.bitrateOrder = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ManifestOptions {
    return {
      includeRenditions: globalThis.Array.isArray(object?.includeRenditions)
        ? object.includeRenditions.map((e: any) => RenditionFilter.fromJSON(e))
        : [],
      bitrateOrder: isSet(object.bitrateOrder) ? manifestOptions_OrderPolicyFromJSON(object.bitrateOrder) : 0,
    };
  },

  toJSON(message: ManifestOptions): unknown {
    const obj: any = {};
    if (message.includeRenditions?.length) {
      obj.includeRenditions = message.includeRenditions.map((e) => RenditionFilter.toJSON(e));
    }
    if (message.bitrateOrder !== 0) {
      obj.bitrateOrder = manifestOptions_OrderPolicyToJSON(message.bitrateOrder);
    }
    return obj;
  },

  create(base?: DeepPartial<ManifestOptions>): ManifestOptions {
    return ManifestOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ManifestOptions>): ManifestOptions {
    const message = createBaseManifestOptions();
    message.includeRenditions = object.includeRenditions?.map((e) => RenditionFilter.fromPartial(e)) || [];
    message.bitrateOrder = object.bitrateOrder ?? 0;
    return message;
  },
};

function createBaseRenditionFilter(): RenditionFilter {
  return { bitrateBps: 0, codecs: "" };
}

export const RenditionFilter: MessageFns<RenditionFilter> = {
  encode(message: RenditionFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bitrateBps !== 0) {
      writer.uint32(8).int32(message.bitrateBps);
    }
    if (message.codecs !== "") {
      writer.uint32(18).string(message.codecs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenditionFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenditionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.bitrateBps = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.codecs = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenditionFilter {
    return {
      bitrateBps: isSet(object.bitrateBps) ? globalThis.Number(object.bitrateBps) : 0,
      codecs: isSet(object.codecs) ? globalThis.String(object.codecs) : "",
    };
  },

  toJSON(message: RenditionFilter): unknown {
    const obj: any = {};
    if (message.bitrateBps !== 0) {
      obj.bitrateBps = Math.round(message.bitrateBps);
    }
    if (message.codecs !== "") {
      obj.codecs = message.codecs;
    }
    return obj;
  },

  create(base?: DeepPartial<RenditionFilter>): RenditionFilter {
    return RenditionFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenditionFilter>): RenditionFilter {
    const message = createBaseRenditionFilter();
    message.bitrateBps = object.bitrateBps ?? 0;
    message.codecs = object.codecs ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
