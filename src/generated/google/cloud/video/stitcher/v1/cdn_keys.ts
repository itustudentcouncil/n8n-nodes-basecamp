// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/video/stitcher/v1/cdn_keys.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.video.stitcher.v1";

/**
 * Configuration for a CDN key. Used by the Video Stitcher
 * to sign URIs for fetching video manifests and signing
 * media segments for playback.
 */
export interface CdnKey {
  /** The configuration for a Google Cloud CDN key. */
  googleCdnKey?:
    | GoogleCdnKey
    | undefined;
  /** The configuration for an Akamai CDN key. */
  akamaiCdnKey?:
    | AkamaiCdnKey
    | undefined;
  /** The configuration for a Media CDN key. */
  mediaCdnKey?:
    | MediaCdnKey
    | undefined;
  /**
   * The resource name of the CDN key, in the form of
   * `projects/{project}/locations/{location}/cdnKeys/{id}`.
   * The name is ignored when creating a CDN key.
   */
  name: string;
  /** The hostname this key applies to. */
  hostname: string;
}

/** Configuration for a Google Cloud CDN key. */
export interface GoogleCdnKey {
  /** Input only. Secret for this Google Cloud CDN key. */
  privateKey: Buffer;
  /** The public name of the Google Cloud CDN key. */
  keyName: string;
}

/** Configuration for an Akamai CDN key. */
export interface AkamaiCdnKey {
  /** Input only. Token key for the Akamai CDN edge configuration. */
  tokenKey: Buffer;
}

/** Configuration for a Media CDN key. */
export interface MediaCdnKey {
  /** Input only. 64-byte ed25519 private key for this Media CDN key. */
  privateKey: Buffer;
  /** The keyset name of the Media CDN key. */
  keyName: string;
  /**
   * Optional. If set, the URL will be signed using the Media CDN token.
   * Otherwise, the URL would be signed using the standard Media CDN signature.
   */
  tokenConfig: MediaCdnKey_TokenConfig | undefined;
}

/** Configuration for a Media CDN token. */
export interface MediaCdnKey_TokenConfig {
  /**
   * Optional. The query parameter in which to find the token.
   *
   * The name must be 1-64 characters long and match
   * the regular expression `[a-zA-Z]([a-zA-Z0-9_-])*` which means the
   * first character must be a letter, and all following characters
   * must be a dash, underscore, letter or digit.
   *
   * Defaults to `edge-cache-token`.
   */
  queryParameter: string;
}

function createBaseCdnKey(): CdnKey {
  return { googleCdnKey: undefined, akamaiCdnKey: undefined, mediaCdnKey: undefined, name: "", hostname: "" };
}

export const CdnKey: MessageFns<CdnKey> = {
  encode(message: CdnKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.googleCdnKey !== undefined) {
      GoogleCdnKey.encode(message.googleCdnKey, writer.uint32(42).fork()).join();
    }
    if (message.akamaiCdnKey !== undefined) {
      AkamaiCdnKey.encode(message.akamaiCdnKey, writer.uint32(50).fork()).join();
    }
    if (message.mediaCdnKey !== undefined) {
      MediaCdnKey.encode(message.mediaCdnKey, writer.uint32(66).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.hostname !== "") {
      writer.uint32(34).string(message.hostname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CdnKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCdnKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.googleCdnKey = GoogleCdnKey.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.akamaiCdnKey = AkamaiCdnKey.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.mediaCdnKey = MediaCdnKey.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.hostname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CdnKey {
    return {
      googleCdnKey: isSet(object.googleCdnKey) ? GoogleCdnKey.fromJSON(object.googleCdnKey) : undefined,
      akamaiCdnKey: isSet(object.akamaiCdnKey) ? AkamaiCdnKey.fromJSON(object.akamaiCdnKey) : undefined,
      mediaCdnKey: isSet(object.mediaCdnKey) ? MediaCdnKey.fromJSON(object.mediaCdnKey) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
    };
  },

  toJSON(message: CdnKey): unknown {
    const obj: any = {};
    if (message.googleCdnKey !== undefined) {
      obj.googleCdnKey = GoogleCdnKey.toJSON(message.googleCdnKey);
    }
    if (message.akamaiCdnKey !== undefined) {
      obj.akamaiCdnKey = AkamaiCdnKey.toJSON(message.akamaiCdnKey);
    }
    if (message.mediaCdnKey !== undefined) {
      obj.mediaCdnKey = MediaCdnKey.toJSON(message.mediaCdnKey);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    return obj;
  },

  create(base?: DeepPartial<CdnKey>): CdnKey {
    return CdnKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CdnKey>): CdnKey {
    const message = createBaseCdnKey();
    message.googleCdnKey = (object.googleCdnKey !== undefined && object.googleCdnKey !== null)
      ? GoogleCdnKey.fromPartial(object.googleCdnKey)
      : undefined;
    message.akamaiCdnKey = (object.akamaiCdnKey !== undefined && object.akamaiCdnKey !== null)
      ? AkamaiCdnKey.fromPartial(object.akamaiCdnKey)
      : undefined;
    message.mediaCdnKey = (object.mediaCdnKey !== undefined && object.mediaCdnKey !== null)
      ? MediaCdnKey.fromPartial(object.mediaCdnKey)
      : undefined;
    message.name = object.name ?? "";
    message.hostname = object.hostname ?? "";
    return message;
  },
};

function createBaseGoogleCdnKey(): GoogleCdnKey {
  return { privateKey: Buffer.alloc(0), keyName: "" };
}

export const GoogleCdnKey: MessageFns<GoogleCdnKey> = {
  encode(message: GoogleCdnKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privateKey.length !== 0) {
      writer.uint32(10).bytes(message.privateKey);
    }
    if (message.keyName !== "") {
      writer.uint32(18).string(message.keyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleCdnKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleCdnKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateKey = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoogleCdnKey {
    return {
      privateKey: isSet(object.privateKey) ? Buffer.from(bytesFromBase64(object.privateKey)) : Buffer.alloc(0),
      keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "",
    };
  },

  toJSON(message: GoogleCdnKey): unknown {
    const obj: any = {};
    if (message.privateKey.length !== 0) {
      obj.privateKey = base64FromBytes(message.privateKey);
    }
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    return obj;
  },

  create(base?: DeepPartial<GoogleCdnKey>): GoogleCdnKey {
    return GoogleCdnKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GoogleCdnKey>): GoogleCdnKey {
    const message = createBaseGoogleCdnKey();
    message.privateKey = object.privateKey ?? Buffer.alloc(0);
    message.keyName = object.keyName ?? "";
    return message;
  },
};

function createBaseAkamaiCdnKey(): AkamaiCdnKey {
  return { tokenKey: Buffer.alloc(0) };
}

export const AkamaiCdnKey: MessageFns<AkamaiCdnKey> = {
  encode(message: AkamaiCdnKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenKey.length !== 0) {
      writer.uint32(10).bytes(message.tokenKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AkamaiCdnKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAkamaiCdnKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokenKey = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AkamaiCdnKey {
    return { tokenKey: isSet(object.tokenKey) ? Buffer.from(bytesFromBase64(object.tokenKey)) : Buffer.alloc(0) };
  },

  toJSON(message: AkamaiCdnKey): unknown {
    const obj: any = {};
    if (message.tokenKey.length !== 0) {
      obj.tokenKey = base64FromBytes(message.tokenKey);
    }
    return obj;
  },

  create(base?: DeepPartial<AkamaiCdnKey>): AkamaiCdnKey {
    return AkamaiCdnKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AkamaiCdnKey>): AkamaiCdnKey {
    const message = createBaseAkamaiCdnKey();
    message.tokenKey = object.tokenKey ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseMediaCdnKey(): MediaCdnKey {
  return { privateKey: Buffer.alloc(0), keyName: "", tokenConfig: undefined };
}

export const MediaCdnKey: MessageFns<MediaCdnKey> = {
  encode(message: MediaCdnKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privateKey.length !== 0) {
      writer.uint32(10).bytes(message.privateKey);
    }
    if (message.keyName !== "") {
      writer.uint32(18).string(message.keyName);
    }
    if (message.tokenConfig !== undefined) {
      MediaCdnKey_TokenConfig.encode(message.tokenConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaCdnKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaCdnKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateKey = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tokenConfig = MediaCdnKey_TokenConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediaCdnKey {
    return {
      privateKey: isSet(object.privateKey) ? Buffer.from(bytesFromBase64(object.privateKey)) : Buffer.alloc(0),
      keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "",
      tokenConfig: isSet(object.tokenConfig) ? MediaCdnKey_TokenConfig.fromJSON(object.tokenConfig) : undefined,
    };
  },

  toJSON(message: MediaCdnKey): unknown {
    const obj: any = {};
    if (message.privateKey.length !== 0) {
      obj.privateKey = base64FromBytes(message.privateKey);
    }
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    if (message.tokenConfig !== undefined) {
      obj.tokenConfig = MediaCdnKey_TokenConfig.toJSON(message.tokenConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<MediaCdnKey>): MediaCdnKey {
    return MediaCdnKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MediaCdnKey>): MediaCdnKey {
    const message = createBaseMediaCdnKey();
    message.privateKey = object.privateKey ?? Buffer.alloc(0);
    message.keyName = object.keyName ?? "";
    message.tokenConfig = (object.tokenConfig !== undefined && object.tokenConfig !== null)
      ? MediaCdnKey_TokenConfig.fromPartial(object.tokenConfig)
      : undefined;
    return message;
  },
};

function createBaseMediaCdnKey_TokenConfig(): MediaCdnKey_TokenConfig {
  return { queryParameter: "" };
}

export const MediaCdnKey_TokenConfig: MessageFns<MediaCdnKey_TokenConfig> = {
  encode(message: MediaCdnKey_TokenConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryParameter !== "") {
      writer.uint32(10).string(message.queryParameter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaCdnKey_TokenConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaCdnKey_TokenConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryParameter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediaCdnKey_TokenConfig {
    return { queryParameter: isSet(object.queryParameter) ? globalThis.String(object.queryParameter) : "" };
  },

  toJSON(message: MediaCdnKey_TokenConfig): unknown {
    const obj: any = {};
    if (message.queryParameter !== "") {
      obj.queryParameter = message.queryParameter;
    }
    return obj;
  },

  create(base?: DeepPartial<MediaCdnKey_TokenConfig>): MediaCdnKey_TokenConfig {
    return MediaCdnKey_TokenConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MediaCdnKey_TokenConfig>): MediaCdnKey_TokenConfig {
    const message = createBaseMediaCdnKey_TokenConfig();
    message.queryParameter = object.queryParameter ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
