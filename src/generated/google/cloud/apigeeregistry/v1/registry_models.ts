// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/apigeeregistry/v1/registry_models.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.apigeeregistry.v1";

/**
 * A top-level description of an API.
 * Produced by producers and are commitments to provide services.
 */
export interface Api {
  /** Resource name. */
  name: string;
  /** Human-meaningful name. */
  displayName: string;
  /** A detailed description. */
  description: string;
  /** Output only. Creation timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update timestamp. */
  updateTime:
    | Date
    | undefined;
  /**
   * A user-definable description of the availability of this service.
   * Format: free-form, but we expect single words that describe availability,
   * e.g., "NONE", "TESTING", "PREVIEW", "GENERAL", "DEPRECATED", "SHUTDOWN".
   */
  availability: string;
  /**
   * The recommended version of the API.
   * Format: `apis/{api}/versions/{version}`
   */
  recommendedVersion: string;
  /**
   * The recommended deployment of the API.
   * Format: `apis/{api}/deployments/{deployment}`
   */
  recommendedDeployment: string;
  /**
   * Labels attach identifying metadata to resources. Identifying metadata can
   * be used to filter list operations.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores, and dashes. International characters are allowed.
   * No more than 64 user labels can be associated with one resource (System
   * labels are excluded).
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   * System reserved label keys are prefixed with
   * `apigeeregistry.googleapis.com/` and cannot be changed.
   */
  labels: { [key: string]: string };
  /**
   * Annotations attach non-identifying metadata to resources.
   *
   * Annotation keys and values are less restricted than those of labels, but
   * should be generally used for small values of broad interest. Larger, topic-
   * specific metadata should be stored in Artifacts.
   */
  annotations: { [key: string]: string };
}

export interface Api_LabelsEntry {
  key: string;
  value: string;
}

export interface Api_AnnotationsEntry {
  key: string;
  value: string;
}

/**
 * Describes a particular version of an API.
 * ApiVersions are what consumers actually use.
 */
export interface ApiVersion {
  /** Resource name. */
  name: string;
  /** Human-meaningful name. */
  displayName: string;
  /** A detailed description. */
  description: string;
  /** Output only. Creation timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update timestamp. */
  updateTime:
    | Date
    | undefined;
  /**
   * A user-definable description of the lifecycle phase of this API version.
   * Format: free-form, but we expect single words that describe API maturity,
   * e.g., "CONCEPT", "DESIGN", "DEVELOPMENT", "STAGING", "PRODUCTION",
   * "DEPRECATED", "RETIRED".
   */
  state: string;
  /**
   * Labels attach identifying metadata to resources. Identifying metadata can
   * be used to filter list operations.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   * No more than 64 user labels can be associated with one resource (System
   * labels are excluded).
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   * System reserved label keys are prefixed with
   * `apigeeregistry.googleapis.com/` and cannot be changed.
   */
  labels: { [key: string]: string };
  /**
   * Annotations attach non-identifying metadata to resources.
   *
   * Annotation keys and values are less restricted than those of labels, but
   * should be generally used for small values of broad interest. Larger, topic-
   * specific metadata should be stored in Artifacts.
   */
  annotations: { [key: string]: string };
}

export interface ApiVersion_LabelsEntry {
  key: string;
  value: string;
}

export interface ApiVersion_AnnotationsEntry {
  key: string;
  value: string;
}

/**
 * Describes a version of an API in a structured way.
 * ApiSpecs provide formal descriptions that consumers can use to use a version.
 * ApiSpec resources are intended to be fully-resolved descriptions of an
 * ApiVersion. When specs consist of multiple files, these should be bundled
 * together (e.g., in a zip archive) and stored as a unit. Multiple specs can
 * exist to provide representations in different API description formats.
 * Synchronization of these representations would be provided by tooling and
 * background services.
 */
export interface ApiSpec {
  /** Resource name. */
  name: string;
  /** A possibly-hierarchical name used to refer to the spec from other specs. */
  filename: string;
  /** A detailed description. */
  description: string;
  /**
   * Output only. Immutable. The revision ID of the spec.
   * A new revision is committed whenever the spec contents are changed.
   * The format is an 8-character hexadecimal string.
   */
  revisionId: string;
  /** Output only. Creation timestamp; when the spec resource was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Revision creation timestamp; when the represented revision was created. */
  revisionCreateTime:
    | Date
    | undefined;
  /** Output only. Last update timestamp: when the represented revision was last modified. */
  revisionUpdateTime:
    | Date
    | undefined;
  /**
   * A style (format) descriptor for this spec that is specified as a Media Type
   * (https://en.wikipedia.org/wiki/Media_type). Possible values include
   * `application/vnd.apigee.proto`, `application/vnd.apigee.openapi`, and
   * `application/vnd.apigee.graphql`, with possible suffixes representing
   * compression types. These hypothetical names are defined in the vendor tree
   * defined in RFC6838 (https://tools.ietf.org/html/rfc6838) and are not final.
   * Content types can specify compression. Currently only GZip compression is
   * supported (indicated with "+gzip").
   */
  mimeType: string;
  /**
   * Output only. The size of the spec file in bytes. If the spec is gzipped, this is the
   * size of the uncompressed spec.
   */
  sizeBytes: number;
  /**
   * Output only. A SHA-256 hash of the spec's contents. If the spec is gzipped, this is
   * the hash of the uncompressed spec.
   */
  hash: string;
  /**
   * The original source URI of the spec (if one exists).
   * This is an external location that can be used for reference purposes
   * but which may not be authoritative since this external resource may
   * change after the spec is retrieved.
   */
  sourceUri: string;
  /**
   * Input only. The contents of the spec.
   * Provided by API callers when specs are created or updated.
   * To access the contents of a spec, use GetApiSpecContents.
   */
  contents: Buffer;
  /**
   * Labels attach identifying metadata to resources. Identifying metadata can
   * be used to filter list operations.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   * No more than 64 user labels can be associated with one resource (System
   * labels are excluded).
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   * System reserved label keys are prefixed with
   * `apigeeregistry.googleapis.com/` and cannot be changed.
   */
  labels: { [key: string]: string };
  /**
   * Annotations attach non-identifying metadata to resources.
   *
   * Annotation keys and values are less restricted than those of labels, but
   * should be generally used for small values of broad interest. Larger, topic-
   * specific metadata should be stored in Artifacts.
   */
  annotations: { [key: string]: string };
}

export interface ApiSpec_LabelsEntry {
  key: string;
  value: string;
}

export interface ApiSpec_AnnotationsEntry {
  key: string;
  value: string;
}

/**
 * Describes a service running at particular address that
 * provides a particular version of an API. ApiDeployments have revisions which
 * correspond to different configurations of a single deployment in time.
 * Revision identifiers should be updated whenever the served API spec or
 * endpoint address changes.
 */
export interface ApiDeployment {
  /** Resource name. */
  name: string;
  /** Human-meaningful name. */
  displayName: string;
  /** A detailed description. */
  description: string;
  /**
   * Output only. Immutable. The revision ID of the deployment.
   * A new revision is committed whenever the deployment contents are changed.
   * The format is an 8-character hexadecimal string.
   */
  revisionId: string;
  /** Output only. Creation timestamp; when the deployment resource was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Revision creation timestamp; when the represented revision was created. */
  revisionCreateTime:
    | Date
    | undefined;
  /** Output only. Last update timestamp: when the represented revision was last modified. */
  revisionUpdateTime:
    | Date
    | undefined;
  /**
   * The full resource name (including revision ID) of the spec of the API being
   * served by the deployment. Changes to this value will update the revision.
   * Format: `apis/{api}/deployments/{deployment}`
   */
  apiSpecRevision: string;
  /**
   * The address where the deployment is serving. Changes to this value will
   * update the revision.
   */
  endpointUri: string;
  /**
   * The address of the external channel of the API (e.g., the Developer
   * Portal). Changes to this value will not affect the revision.
   */
  externalChannelUri: string;
  /**
   * Text briefly identifying the intended audience of the API. Changes to this
   * value will not affect the revision.
   */
  intendedAudience: string;
  /**
   * Text briefly describing how to access the endpoint. Changes to this value
   * will not affect the revision.
   */
  accessGuidance: string;
  /**
   * Labels attach identifying metadata to resources. Identifying metadata can
   * be used to filter list operations.
   *
   * Label keys and values can be no longer than 64 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   * No more than 64 user labels can be associated with one resource (System
   * labels are excluded).
   *
   * See https://goo.gl/xmQnxf for more information and examples of labels.
   * System reserved label keys are prefixed with
   * `apigeeregistry.googleapis.com/` and cannot be changed.
   */
  labels: { [key: string]: string };
  /**
   * Annotations attach non-identifying metadata to resources.
   *
   * Annotation keys and values are less restricted than those of labels, but
   * should be generally used for small values of broad interest. Larger, topic-
   * specific metadata should be stored in Artifacts.
   */
  annotations: { [key: string]: string };
}

export interface ApiDeployment_LabelsEntry {
  key: string;
  value: string;
}

export interface ApiDeployment_AnnotationsEntry {
  key: string;
  value: string;
}

/**
 * Artifacts of resources. Artifacts are unique (single-value) per resource
 * and are used to store metadata that is too large or numerous to be stored
 * directly on the resource. Since artifacts are stored separately from parent
 * resources, they should generally be used for metadata that is needed
 * infrequently, i.e., not for display in primary views of the resource but
 * perhaps displayed or downloaded upon request. The `ListArtifacts` method
 * allows artifacts to be quickly enumerated and checked for presence without
 * downloading their (potentially-large) contents.
 */
export interface Artifact {
  /** Resource name. */
  name: string;
  /** Output only. Creation timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update timestamp. */
  updateTime:
    | Date
    | undefined;
  /**
   * A content type specifier for the artifact.
   * Content type specifiers are Media Types
   * (https://en.wikipedia.org/wiki/Media_type) with a possible "schema"
   * parameter that specifies a schema for the stored information.
   * Content types can specify compression. Currently only GZip compression is
   * supported (indicated with "+gzip").
   */
  mimeType: string;
  /**
   * Output only. The size of the artifact in bytes. If the artifact is gzipped, this is
   * the size of the uncompressed artifact.
   */
  sizeBytes: number;
  /**
   * Output only. A SHA-256 hash of the artifact's contents. If the artifact is gzipped,
   * this is the hash of the uncompressed artifact.
   */
  hash: string;
  /**
   * Input only. The contents of the artifact.
   * Provided by API callers when artifacts are created or replaced.
   * To access the contents of an artifact, use GetArtifactContents.
   */
  contents: Buffer;
}

function createBaseApi(): Api {
  return {
    name: "",
    displayName: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    availability: "",
    recommendedVersion: "",
    recommendedDeployment: "",
    labels: {},
    annotations: {},
  };
}

export const Api: MessageFns<Api> = {
  encode(message: Api, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    if (message.availability !== "") {
      writer.uint32(50).string(message.availability);
    }
    if (message.recommendedVersion !== "") {
      writer.uint32(58).string(message.recommendedVersion);
    }
    if (message.recommendedDeployment !== "") {
      writer.uint32(66).string(message.recommendedDeployment);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Api_LabelsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      Api_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Api {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApi();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.availability = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.recommendedVersion = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.recommendedDeployment = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = Api_LabelsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.labels[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = Api_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.annotations[entry10.key] = entry10.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Api {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      availability: isSet(object.availability) ? globalThis.String(object.availability) : "",
      recommendedVersion: isSet(object.recommendedVersion) ? globalThis.String(object.recommendedVersion) : "",
      recommendedDeployment: isSet(object.recommendedDeployment) ? globalThis.String(object.recommendedDeployment) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Api): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.availability !== "") {
      obj.availability = message.availability;
    }
    if (message.recommendedVersion !== "") {
      obj.recommendedVersion = message.recommendedVersion;
    }
    if (message.recommendedDeployment !== "") {
      obj.recommendedDeployment = message.recommendedDeployment;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Api>): Api {
    return Api.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Api>): Api {
    const message = createBaseApi();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.availability = object.availability ?? "";
    message.recommendedVersion = object.recommendedVersion ?? "";
    message.recommendedDeployment = object.recommendedDeployment ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseApi_LabelsEntry(): Api_LabelsEntry {
  return { key: "", value: "" };
}

export const Api_LabelsEntry: MessageFns<Api_LabelsEntry> = {
  encode(message: Api_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Api_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApi_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Api_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Api_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Api_LabelsEntry>): Api_LabelsEntry {
    return Api_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Api_LabelsEntry>): Api_LabelsEntry {
    const message = createBaseApi_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApi_AnnotationsEntry(): Api_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Api_AnnotationsEntry: MessageFns<Api_AnnotationsEntry> = {
  encode(message: Api_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Api_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApi_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Api_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Api_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Api_AnnotationsEntry>): Api_AnnotationsEntry {
    return Api_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Api_AnnotationsEntry>): Api_AnnotationsEntry {
    const message = createBaseApi_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApiVersion(): ApiVersion {
  return {
    name: "",
    displayName: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    state: "",
    labels: {},
    annotations: {},
  };
}

export const ApiVersion: MessageFns<ApiVersion> = {
  encode(message: ApiVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    if (message.state !== "") {
      writer.uint32(50).string(message.state);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ApiVersion_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      ApiVersion_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.state = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = ApiVersion_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = ApiVersion_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.annotations[entry8.key] = entry8.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiVersion {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ApiVersion): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ApiVersion>): ApiVersion {
    return ApiVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiVersion>): ApiVersion {
    const message = createBaseApiVersion();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseApiVersion_LabelsEntry(): ApiVersion_LabelsEntry {
  return { key: "", value: "" };
}

export const ApiVersion_LabelsEntry: MessageFns<ApiVersion_LabelsEntry> = {
  encode(message: ApiVersion_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiVersion_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiVersion_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiVersion_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiVersion_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ApiVersion_LabelsEntry>): ApiVersion_LabelsEntry {
    return ApiVersion_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiVersion_LabelsEntry>): ApiVersion_LabelsEntry {
    const message = createBaseApiVersion_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApiVersion_AnnotationsEntry(): ApiVersion_AnnotationsEntry {
  return { key: "", value: "" };
}

export const ApiVersion_AnnotationsEntry: MessageFns<ApiVersion_AnnotationsEntry> = {
  encode(message: ApiVersion_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiVersion_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiVersion_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiVersion_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiVersion_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ApiVersion_AnnotationsEntry>): ApiVersion_AnnotationsEntry {
    return ApiVersion_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiVersion_AnnotationsEntry>): ApiVersion_AnnotationsEntry {
    const message = createBaseApiVersion_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApiSpec(): ApiSpec {
  return {
    name: "",
    filename: "",
    description: "",
    revisionId: "",
    createTime: undefined,
    revisionCreateTime: undefined,
    revisionUpdateTime: undefined,
    mimeType: "",
    sizeBytes: 0,
    hash: "",
    sourceUri: "",
    contents: Buffer.alloc(0),
    labels: {},
    annotations: {},
  };
}

export const ApiSpec: MessageFns<ApiSpec> = {
  encode(message: ApiSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.filename !== "") {
      writer.uint32(18).string(message.filename);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.revisionId !== "") {
      writer.uint32(34).string(message.revisionId);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.revisionCreateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionCreateTime), writer.uint32(50).fork()).join();
    }
    if (message.revisionUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionUpdateTime), writer.uint32(58).fork()).join();
    }
    if (message.mimeType !== "") {
      writer.uint32(66).string(message.mimeType);
    }
    if (message.sizeBytes !== 0) {
      writer.uint32(72).int32(message.sizeBytes);
    }
    if (message.hash !== "") {
      writer.uint32(82).string(message.hash);
    }
    if (message.sourceUri !== "") {
      writer.uint32(90).string(message.sourceUri);
    }
    if (message.contents.length !== 0) {
      writer.uint32(98).bytes(message.contents);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ApiSpec_LabelsEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      ApiSpec_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filename = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.revisionCreateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.revisionUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.sizeBytes = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.sourceUri = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.contents = Buffer.from(reader.bytes());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          const entry14 = ApiSpec_LabelsEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.labels[entry14.key] = entry14.value;
          }
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = ApiSpec_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.annotations[entry15.key] = entry15.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiSpec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      revisionCreateTime: isSet(object.revisionCreateTime) ? fromJsonTimestamp(object.revisionCreateTime) : undefined,
      revisionUpdateTime: isSet(object.revisionUpdateTime) ? fromJsonTimestamp(object.revisionUpdateTime) : undefined,
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      sizeBytes: isSet(object.sizeBytes) ? globalThis.Number(object.sizeBytes) : 0,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      sourceUri: isSet(object.sourceUri) ? globalThis.String(object.sourceUri) : "",
      contents: isSet(object.contents) ? Buffer.from(bytesFromBase64(object.contents)) : Buffer.alloc(0),
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ApiSpec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.revisionCreateTime !== undefined) {
      obj.revisionCreateTime = message.revisionCreateTime.toISOString();
    }
    if (message.revisionUpdateTime !== undefined) {
      obj.revisionUpdateTime = message.revisionUpdateTime.toISOString();
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.sizeBytes !== 0) {
      obj.sizeBytes = Math.round(message.sizeBytes);
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.sourceUri !== "") {
      obj.sourceUri = message.sourceUri;
    }
    if (message.contents.length !== 0) {
      obj.contents = base64FromBytes(message.contents);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ApiSpec>): ApiSpec {
    return ApiSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiSpec>): ApiSpec {
    const message = createBaseApiSpec();
    message.name = object.name ?? "";
    message.filename = object.filename ?? "";
    message.description = object.description ?? "";
    message.revisionId = object.revisionId ?? "";
    message.createTime = object.createTime ?? undefined;
    message.revisionCreateTime = object.revisionCreateTime ?? undefined;
    message.revisionUpdateTime = object.revisionUpdateTime ?? undefined;
    message.mimeType = object.mimeType ?? "";
    message.sizeBytes = object.sizeBytes ?? 0;
    message.hash = object.hash ?? "";
    message.sourceUri = object.sourceUri ?? "";
    message.contents = object.contents ?? Buffer.alloc(0);
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseApiSpec_LabelsEntry(): ApiSpec_LabelsEntry {
  return { key: "", value: "" };
}

export const ApiSpec_LabelsEntry: MessageFns<ApiSpec_LabelsEntry> = {
  encode(message: ApiSpec_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiSpec_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiSpec_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiSpec_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiSpec_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ApiSpec_LabelsEntry>): ApiSpec_LabelsEntry {
    return ApiSpec_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiSpec_LabelsEntry>): ApiSpec_LabelsEntry {
    const message = createBaseApiSpec_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApiSpec_AnnotationsEntry(): ApiSpec_AnnotationsEntry {
  return { key: "", value: "" };
}

export const ApiSpec_AnnotationsEntry: MessageFns<ApiSpec_AnnotationsEntry> = {
  encode(message: ApiSpec_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiSpec_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiSpec_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiSpec_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiSpec_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ApiSpec_AnnotationsEntry>): ApiSpec_AnnotationsEntry {
    return ApiSpec_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiSpec_AnnotationsEntry>): ApiSpec_AnnotationsEntry {
    const message = createBaseApiSpec_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApiDeployment(): ApiDeployment {
  return {
    name: "",
    displayName: "",
    description: "",
    revisionId: "",
    createTime: undefined,
    revisionCreateTime: undefined,
    revisionUpdateTime: undefined,
    apiSpecRevision: "",
    endpointUri: "",
    externalChannelUri: "",
    intendedAudience: "",
    accessGuidance: "",
    labels: {},
    annotations: {},
  };
}

export const ApiDeployment: MessageFns<ApiDeployment> = {
  encode(message: ApiDeployment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.revisionId !== "") {
      writer.uint32(34).string(message.revisionId);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.revisionCreateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionCreateTime), writer.uint32(50).fork()).join();
    }
    if (message.revisionUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionUpdateTime), writer.uint32(58).fork()).join();
    }
    if (message.apiSpecRevision !== "") {
      writer.uint32(66).string(message.apiSpecRevision);
    }
    if (message.endpointUri !== "") {
      writer.uint32(74).string(message.endpointUri);
    }
    if (message.externalChannelUri !== "") {
      writer.uint32(82).string(message.externalChannelUri);
    }
    if (message.intendedAudience !== "") {
      writer.uint32(90).string(message.intendedAudience);
    }
    if (message.accessGuidance !== "") {
      writer.uint32(98).string(message.accessGuidance);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ApiDeployment_LabelsEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    Object.entries(message.annotations).forEach(([key, value]) => {
      ApiDeployment_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiDeployment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiDeployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.revisionCreateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.revisionUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.apiSpecRevision = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.endpointUri = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.externalChannelUri = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.intendedAudience = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.accessGuidance = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          const entry14 = ApiDeployment_LabelsEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.labels[entry14.key] = entry14.value;
          }
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = ApiDeployment_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.annotations[entry15.key] = entry15.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiDeployment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      revisionCreateTime: isSet(object.revisionCreateTime) ? fromJsonTimestamp(object.revisionCreateTime) : undefined,
      revisionUpdateTime: isSet(object.revisionUpdateTime) ? fromJsonTimestamp(object.revisionUpdateTime) : undefined,
      apiSpecRevision: isSet(object.apiSpecRevision) ? globalThis.String(object.apiSpecRevision) : "",
      endpointUri: isSet(object.endpointUri) ? globalThis.String(object.endpointUri) : "",
      externalChannelUri: isSet(object.externalChannelUri) ? globalThis.String(object.externalChannelUri) : "",
      intendedAudience: isSet(object.intendedAudience) ? globalThis.String(object.intendedAudience) : "",
      accessGuidance: isSet(object.accessGuidance) ? globalThis.String(object.accessGuidance) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ApiDeployment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.revisionCreateTime !== undefined) {
      obj.revisionCreateTime = message.revisionCreateTime.toISOString();
    }
    if (message.revisionUpdateTime !== undefined) {
      obj.revisionUpdateTime = message.revisionUpdateTime.toISOString();
    }
    if (message.apiSpecRevision !== "") {
      obj.apiSpecRevision = message.apiSpecRevision;
    }
    if (message.endpointUri !== "") {
      obj.endpointUri = message.endpointUri;
    }
    if (message.externalChannelUri !== "") {
      obj.externalChannelUri = message.externalChannelUri;
    }
    if (message.intendedAudience !== "") {
      obj.intendedAudience = message.intendedAudience;
    }
    if (message.accessGuidance !== "") {
      obj.accessGuidance = message.accessGuidance;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ApiDeployment>): ApiDeployment {
    return ApiDeployment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiDeployment>): ApiDeployment {
    const message = createBaseApiDeployment();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.revisionId = object.revisionId ?? "";
    message.createTime = object.createTime ?? undefined;
    message.revisionCreateTime = object.revisionCreateTime ?? undefined;
    message.revisionUpdateTime = object.revisionUpdateTime ?? undefined;
    message.apiSpecRevision = object.apiSpecRevision ?? "";
    message.endpointUri = object.endpointUri ?? "";
    message.externalChannelUri = object.externalChannelUri ?? "";
    message.intendedAudience = object.intendedAudience ?? "";
    message.accessGuidance = object.accessGuidance ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseApiDeployment_LabelsEntry(): ApiDeployment_LabelsEntry {
  return { key: "", value: "" };
}

export const ApiDeployment_LabelsEntry: MessageFns<ApiDeployment_LabelsEntry> = {
  encode(message: ApiDeployment_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiDeployment_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiDeployment_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiDeployment_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiDeployment_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ApiDeployment_LabelsEntry>): ApiDeployment_LabelsEntry {
    return ApiDeployment_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiDeployment_LabelsEntry>): ApiDeployment_LabelsEntry {
    const message = createBaseApiDeployment_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApiDeployment_AnnotationsEntry(): ApiDeployment_AnnotationsEntry {
  return { key: "", value: "" };
}

export const ApiDeployment_AnnotationsEntry: MessageFns<ApiDeployment_AnnotationsEntry> = {
  encode(message: ApiDeployment_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiDeployment_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiDeployment_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiDeployment_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiDeployment_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ApiDeployment_AnnotationsEntry>): ApiDeployment_AnnotationsEntry {
    return ApiDeployment_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiDeployment_AnnotationsEntry>): ApiDeployment_AnnotationsEntry {
    const message = createBaseApiDeployment_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseArtifact(): Artifact {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    mimeType: "",
    sizeBytes: 0,
    hash: "",
    contents: Buffer.alloc(0),
  };
}

export const Artifact: MessageFns<Artifact> = {
  encode(message: Artifact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.mimeType !== "") {
      writer.uint32(34).string(message.mimeType);
    }
    if (message.sizeBytes !== 0) {
      writer.uint32(40).int32(message.sizeBytes);
    }
    if (message.hash !== "") {
      writer.uint32(50).string(message.hash);
    }
    if (message.contents.length !== 0) {
      writer.uint32(58).bytes(message.contents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Artifact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArtifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.sizeBytes = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.contents = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Artifact {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      sizeBytes: isSet(object.sizeBytes) ? globalThis.Number(object.sizeBytes) : 0,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      contents: isSet(object.contents) ? Buffer.from(bytesFromBase64(object.contents)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Artifact): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.sizeBytes !== 0) {
      obj.sizeBytes = Math.round(message.sizeBytes);
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.contents.length !== 0) {
      obj.contents = base64FromBytes(message.contents);
    }
    return obj;
  },

  create(base?: DeepPartial<Artifact>): Artifact {
    return Artifact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Artifact>): Artifact {
    const message = createBaseArtifact();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.mimeType = object.mimeType ?? "";
    message.sizeBytes = object.sizeBytes ?? 0;
    message.hash = object.hash ?? "";
    message.contents = object.contents ?? Buffer.alloc(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
