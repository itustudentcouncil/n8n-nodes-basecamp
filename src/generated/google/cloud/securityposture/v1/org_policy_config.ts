// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/securityposture/v1/org_policy_config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Expr } from "../../../type/expr.js";

export const protobufPackage = "google.cloud.securityposture.v1";

/** A rule used to express this policy. */
export interface PolicyRule {
  /**
   * List of values to be used for this policy rule. This field can be set
   * only in policies for list constraints.
   */
  values?:
    | PolicyRule_StringValues
    | undefined;
  /**
   * Setting this to true means that all values are allowed. This field can
   * be set only in policies for list constraints.
   */
  allowAll?:
    | boolean
    | undefined;
  /**
   * Setting this to true means that all values are denied. This field can
   * be set only in policies for list constraints.
   */
  denyAll?:
    | boolean
    | undefined;
  /**
   * If `true`, then the policy is enforced. If `false`, then any
   * configuration is acceptable.
   * This field can be set only in policies for boolean constraints.
   */
  enforce?:
    | boolean
    | undefined;
  /**
   * A condition which determines whether this rule is used
   * in the evaluation of the policy. When set, the `expression` field in
   * the `Expr' must include from 1 to 10 subexpressions, joined by the "||"
   * or "&&" operators. Each subexpression must be of the form
   * "resource.matchTag('<ORG_ID>/tag_key_short_name,
   * 'tag_value_short_name')" or "resource.matchTagId('tagKeys/key_id',
   * 'tagValues/value_id')" where key_name and value_name are the resource
   * names for Label Keys and Values. These names are available from the Tag
   * Manager Service. An example expression is:
   * "resource.matchTag('123456789/environment,
   * 'prod')" or "resource.matchTagId('tagKeys/123',
   * 'tagValues/456')".
   */
  condition: Expr | undefined;
}

/**
 * A message that holds specific allowed and denied values.
 * This message can define specific values and subtrees of the Resource
 * Manager resource hierarchy (`Organizations`, `Folders`, `Projects`) that
 * are allowed or denied. This is achieved by using the `under:` and
 * optional `is:` prefixes.
 * The `under:` prefix is used to denote resource subtree values.
 * The `is:` prefix is used to denote specific values, and is required only
 * if the value contains a ":". Values prefixed with "is:" are treated the
 * same as values with no prefix.
 * Ancestry subtrees must be in one of the following formats:
 *
 * - `projects/<project-id>` (for example, `projects/tokyo-rain-123`)
 * - `folders/<folder-id>` (for example, `folders/1234`)
 * - `organizations/<organization-id>` (for example, `organizations/1234`)
 *
 * The `supports_under` field of the associated `Constraint`  defines
 * whether ancestry prefixes can be used.
 */
export interface PolicyRule_StringValues {
  /** List of values allowed at this resource. */
  allowedValues: string[];
  /** List of values denied at this resource. */
  deniedValues: string[];
}

/**
 * A custom constraint defined by customers which can *only* be applied to the
 * given resource types and organization.
 *
 * By creating a custom constraint, customers can apply policies of this
 * custom constraint. *Creating a custom constraint itself does NOT apply any
 * policy enforcement*.
 */
export interface CustomConstraint {
  /**
   * Immutable. Name of the constraint. This is unique within the organization.
   * Format of the name should be
   *
   * -
   * `organizations/{organization_id}/customConstraints/{custom_constraint_id}`
   *
   * Example: `organizations/123/customConstraints/custom.createOnlyE2TypeVms`
   *
   * The max length is 70 characters and the minimum length is 1. Note that the
   * prefix `organizations/{organization_id}/customConstraints/` is not counted.
   */
  name: string;
  /**
   * Immutable. The resource instance type on which this policy applies. Format
   * will be of the form : `<canonical service name>/<type>` Example:
   *
   *  - `compute.googleapis.com/Instance`.
   */
  resourceTypes: string[];
  /** All the operations being applied for this constraint. */
  methodTypes: CustomConstraint_MethodType[];
  /**
   * Org policy condition/expression. For example:
   * `resource.instanceName.matches("[production|test]_.*_(\d)+")` or,
   * `resource.management.auto_upgrade == true`
   *
   * The max length of the condition is 1000 characters.
   */
  condition: string;
  /** Allow or deny type. */
  actionType: CustomConstraint_ActionType;
  /**
   * One line display name for the UI.
   * The max length of the display_name is 200 characters.
   */
  displayName: string;
  /**
   * Detailed information about this custom policy constraint.
   * The max length of the description is 2000 characters.
   */
  description: string;
  /**
   * Output only. The last time this custom constraint was updated. This
   * represents the last time that the `CreateCustomConstraint` or
   * `UpdateCustomConstraint` RPC was called
   */
  updateTime: Date | undefined;
}

/**
 * The operation for which this constraint will be applied. To apply this
 * constraint only when creating new VMs, the `method_types` should be
 * `CREATE` only. To apply this constraint when creating or deleting
 * VMs, the `method_types` should be `CREATE` and `DELETE`.
 *
 * `UPDATE` only custom constraints are not supported. Use `CREATE` or
 * `CREATE, UPDATE`.
 */
export enum CustomConstraint_MethodType {
  /** METHOD_TYPE_UNSPECIFIED - Unspecified. Results in an error. */
  METHOD_TYPE_UNSPECIFIED = 0,
  /** CREATE - Constraint applied when creating the resource. */
  CREATE = 1,
  /** UPDATE - Constraint applied when updating the resource. */
  UPDATE = 2,
  /**
   * DELETE - Constraint applied when deleting the resource.
   * Not supported yet.
   */
  DELETE = 3,
  UNRECOGNIZED = -1,
}

export function customConstraint_MethodTypeFromJSON(object: any): CustomConstraint_MethodType {
  switch (object) {
    case 0:
    case "METHOD_TYPE_UNSPECIFIED":
      return CustomConstraint_MethodType.METHOD_TYPE_UNSPECIFIED;
    case 1:
    case "CREATE":
      return CustomConstraint_MethodType.CREATE;
    case 2:
    case "UPDATE":
      return CustomConstraint_MethodType.UPDATE;
    case 3:
    case "DELETE":
      return CustomConstraint_MethodType.DELETE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CustomConstraint_MethodType.UNRECOGNIZED;
  }
}

export function customConstraint_MethodTypeToJSON(object: CustomConstraint_MethodType): string {
  switch (object) {
    case CustomConstraint_MethodType.METHOD_TYPE_UNSPECIFIED:
      return "METHOD_TYPE_UNSPECIFIED";
    case CustomConstraint_MethodType.CREATE:
      return "CREATE";
    case CustomConstraint_MethodType.UPDATE:
      return "UPDATE";
    case CustomConstraint_MethodType.DELETE:
      return "DELETE";
    case CustomConstraint_MethodType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Allow or deny type. */
export enum CustomConstraint_ActionType {
  /** ACTION_TYPE_UNSPECIFIED - Unspecified. Results in an error. */
  ACTION_TYPE_UNSPECIFIED = 0,
  /** ALLOW - Allowed action type. */
  ALLOW = 1,
  /** DENY - Deny action type. */
  DENY = 2,
  UNRECOGNIZED = -1,
}

export function customConstraint_ActionTypeFromJSON(object: any): CustomConstraint_ActionType {
  switch (object) {
    case 0:
    case "ACTION_TYPE_UNSPECIFIED":
      return CustomConstraint_ActionType.ACTION_TYPE_UNSPECIFIED;
    case 1:
    case "ALLOW":
      return CustomConstraint_ActionType.ALLOW;
    case 2:
    case "DENY":
      return CustomConstraint_ActionType.DENY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CustomConstraint_ActionType.UNRECOGNIZED;
  }
}

export function customConstraint_ActionTypeToJSON(object: CustomConstraint_ActionType): string {
  switch (object) {
    case CustomConstraint_ActionType.ACTION_TYPE_UNSPECIFIED:
      return "ACTION_TYPE_UNSPECIFIED";
    case CustomConstraint_ActionType.ALLOW:
      return "ALLOW";
    case CustomConstraint_ActionType.DENY:
      return "DENY";
    case CustomConstraint_ActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBasePolicyRule(): PolicyRule {
  return { values: undefined, allowAll: undefined, denyAll: undefined, enforce: undefined, condition: undefined };
}

export const PolicyRule: MessageFns<PolicyRule> = {
  encode(message: PolicyRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.values !== undefined) {
      PolicyRule_StringValues.encode(message.values, writer.uint32(10).fork()).join();
    }
    if (message.allowAll !== undefined) {
      writer.uint32(16).bool(message.allowAll);
    }
    if (message.denyAll !== undefined) {
      writer.uint32(24).bool(message.denyAll);
    }
    if (message.enforce !== undefined) {
      writer.uint32(32).bool(message.enforce);
    }
    if (message.condition !== undefined) {
      Expr.encode(message.condition, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values = PolicyRule_StringValues.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allowAll = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.denyAll = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enforce = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.condition = Expr.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyRule {
    return {
      values: isSet(object.values) ? PolicyRule_StringValues.fromJSON(object.values) : undefined,
      allowAll: isSet(object.allowAll) ? globalThis.Boolean(object.allowAll) : undefined,
      denyAll: isSet(object.denyAll) ? globalThis.Boolean(object.denyAll) : undefined,
      enforce: isSet(object.enforce) ? globalThis.Boolean(object.enforce) : undefined,
      condition: isSet(object.condition) ? Expr.fromJSON(object.condition) : undefined,
    };
  },

  toJSON(message: PolicyRule): unknown {
    const obj: any = {};
    if (message.values !== undefined) {
      obj.values = PolicyRule_StringValues.toJSON(message.values);
    }
    if (message.allowAll !== undefined) {
      obj.allowAll = message.allowAll;
    }
    if (message.denyAll !== undefined) {
      obj.denyAll = message.denyAll;
    }
    if (message.enforce !== undefined) {
      obj.enforce = message.enforce;
    }
    if (message.condition !== undefined) {
      obj.condition = Expr.toJSON(message.condition);
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyRule>): PolicyRule {
    return PolicyRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyRule>): PolicyRule {
    const message = createBasePolicyRule();
    message.values = (object.values !== undefined && object.values !== null)
      ? PolicyRule_StringValues.fromPartial(object.values)
      : undefined;
    message.allowAll = object.allowAll ?? undefined;
    message.denyAll = object.denyAll ?? undefined;
    message.enforce = object.enforce ?? undefined;
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? Expr.fromPartial(object.condition)
      : undefined;
    return message;
  },
};

function createBasePolicyRule_StringValues(): PolicyRule_StringValues {
  return { allowedValues: [], deniedValues: [] };
}

export const PolicyRule_StringValues: MessageFns<PolicyRule_StringValues> = {
  encode(message: PolicyRule_StringValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allowedValues) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.deniedValues) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyRule_StringValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyRule_StringValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedValues.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deniedValues.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyRule_StringValues {
    return {
      allowedValues: globalThis.Array.isArray(object?.allowedValues)
        ? object.allowedValues.map((e: any) => globalThis.String(e))
        : [],
      deniedValues: globalThis.Array.isArray(object?.deniedValues)
        ? object.deniedValues.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PolicyRule_StringValues): unknown {
    const obj: any = {};
    if (message.allowedValues?.length) {
      obj.allowedValues = message.allowedValues;
    }
    if (message.deniedValues?.length) {
      obj.deniedValues = message.deniedValues;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyRule_StringValues>): PolicyRule_StringValues {
    return PolicyRule_StringValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyRule_StringValues>): PolicyRule_StringValues {
    const message = createBasePolicyRule_StringValues();
    message.allowedValues = object.allowedValues?.map((e) => e) || [];
    message.deniedValues = object.deniedValues?.map((e) => e) || [];
    return message;
  },
};

function createBaseCustomConstraint(): CustomConstraint {
  return {
    name: "",
    resourceTypes: [],
    methodTypes: [],
    condition: "",
    actionType: 0,
    displayName: "",
    description: "",
    updateTime: undefined,
  };
}

export const CustomConstraint: MessageFns<CustomConstraint> = {
  encode(message: CustomConstraint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.resourceTypes) {
      writer.uint32(18).string(v!);
    }
    writer.uint32(26).fork();
    for (const v of message.methodTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.condition !== "") {
      writer.uint32(34).string(message.condition);
    }
    if (message.actionType !== 0) {
      writer.uint32(40).int32(message.actionType);
    }
    if (message.displayName !== "") {
      writer.uint32(50).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomConstraint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceTypes.push(reader.string());
          continue;
        case 3:
          if (tag === 24) {
            message.methodTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.methodTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomConstraint {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      resourceTypes: globalThis.Array.isArray(object?.resourceTypes)
        ? object.resourceTypes.map((e: any) => globalThis.String(e))
        : [],
      methodTypes: globalThis.Array.isArray(object?.methodTypes)
        ? object.methodTypes.map((e: any) => customConstraint_MethodTypeFromJSON(e))
        : [],
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      actionType: isSet(object.actionType) ? customConstraint_ActionTypeFromJSON(object.actionType) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: CustomConstraint): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.resourceTypes?.length) {
      obj.resourceTypes = message.resourceTypes;
    }
    if (message.methodTypes?.length) {
      obj.methodTypes = message.methodTypes.map((e) => customConstraint_MethodTypeToJSON(e));
    }
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.actionType !== 0) {
      obj.actionType = customConstraint_ActionTypeToJSON(message.actionType);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CustomConstraint>): CustomConstraint {
    return CustomConstraint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomConstraint>): CustomConstraint {
    const message = createBaseCustomConstraint();
    message.name = object.name ?? "";
    message.resourceTypes = object.resourceTypes?.map((e) => e) || [];
    message.methodTypes = object.methodTypes?.map((e) => e) || [];
    message.condition = object.condition ?? "";
    message.actionType = object.actionType ?? 0;
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
