// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dataqna/v1alpha/question.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "../../../protobuf/any.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { AnnotatedString } from "./annotated_string.js";

export const protobufPackage = "google.cloud.dataqna.v1alpha";

/** Query entities of an interpretation. */
export enum InterpretEntity {
  /** INTERPRET_ENTITY_UNSPECIFIED - No interpret entity was specified. */
  INTERPRET_ENTITY_UNSPECIFIED = 0,
  /** DIMENSION - A dimenstion entity. */
  DIMENSION = 1,
  /** METRIC - A metric entity. */
  METRIC = 2,
  UNRECOGNIZED = -1,
}

export function interpretEntityFromJSON(object: any): InterpretEntity {
  switch (object) {
    case 0:
    case "INTERPRET_ENTITY_UNSPECIFIED":
      return InterpretEntity.INTERPRET_ENTITY_UNSPECIFIED;
    case 1:
    case "DIMENSION":
      return InterpretEntity.DIMENSION;
    case 2:
    case "METRIC":
      return InterpretEntity.METRIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InterpretEntity.UNRECOGNIZED;
  }
}

export function interpretEntityToJSON(object: InterpretEntity): string {
  switch (object) {
    case InterpretEntity.INTERPRET_ENTITY_UNSPECIFIED:
      return "INTERPRET_ENTITY_UNSPECIFIED";
    case InterpretEntity.DIMENSION:
      return "DIMENSION";
    case InterpretEntity.METRIC:
      return "METRIC";
    case InterpretEntity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The question resource represents a natural language query, its settings,
 * understanding generated by the system, and answer retrieval status.
 * A question cannot be modified.
 */
export interface Question {
  /**
   * Output only. Immutable. The unique identifier for the Question. The ID is server-generated.
   * Example: `projects/foo/locations/bar/questions/123`
   */
  name: string;
  /**
   * Required. Immutable. Scopes to be used for the question. A scope defines the relevant data set
   * scope. It can be a reference to a specific data source or a collection of
   * data sources. Currently, support is limited to a single BigQuery table.
   * There must be exactly one `scopes` element.
   *
   * Example:
   * `//bigquery.googleapis.com/projects/test-project/datasets/foo/tables/bar`
   */
  scopes: string[];
  /** Required. Immutable. The query in natural language. */
  query: string;
  /**
   * A list of annotations to use instead of the default annotation of a data
   * source (set in the data source reference resource). There must not be
   * more than one annotation with the same data source reference.
   */
  dataSourceAnnotations: string[];
  /**
   * An error field explaining why interpretation failed. This is only populated
   * if the interpretation failed.
   *
   * Note: This is different from getting a status error on the request itself.
   * This is not a client or server error and the Question resource is still
   * persisted, but the service could not interpret the question. Clients should
   * present the error to the user so the user can rephrase the question.
   */
  interpretError:
    | InterpretError
    | undefined;
  /** A list of interpretations for this question. */
  interpretations: Interpretation[];
  /** Time when the question was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The e-mail address of the user that created this question. */
  userEmail: string;
  /** Input only. Immutable. Flags to request additional information for debugging purposes. */
  debugFlags:
    | DebugFlags
    | undefined;
  /**
   * Top level debug information.
   * This will be stored as the type DebugInformation.
   * Using Any so clients don't need to pull in anything
   * inside the debug message.
   */
  debugInfo: Any | undefined;
}

/** Details on the failure to interpret the question. */
export interface InterpretError {
  /** Error message explaining why this question could not be interpreted. */
  message: string;
  /** The code for the error category why the interpretation failed. */
  code: InterpretError_InterpretErrorCode;
  /** Details on interpretation failure. */
  details: InterpretError_InterpretErrorDetails | undefined;
}

/**
 * The interpret error code provides an error category why the interpretation
 * failed.
 */
export enum InterpretError_InterpretErrorCode {
  /** INTERPRET_ERROR_CODE_UNSPECIFIED - No interpret error code was specified. */
  INTERPRET_ERROR_CODE_UNSPECIFIED = 0,
  /** INVALID_QUERY - The query is not valid. */
  INVALID_QUERY = 1,
  /**
   * FAILED_TO_UNDERSTAND - The interpreter failed to understand the question. For example, because
   * it was too ambiguous.
   */
  FAILED_TO_UNDERSTAND = 2,
  /**
   * FAILED_TO_ANSWER - The interpreter could understand the question, but was not able to arrive
   * at an answer. For example, because a requested operation is not
   * supported.
   */
  FAILED_TO_ANSWER = 3,
  UNRECOGNIZED = -1,
}

export function interpretError_InterpretErrorCodeFromJSON(object: any): InterpretError_InterpretErrorCode {
  switch (object) {
    case 0:
    case "INTERPRET_ERROR_CODE_UNSPECIFIED":
      return InterpretError_InterpretErrorCode.INTERPRET_ERROR_CODE_UNSPECIFIED;
    case 1:
    case "INVALID_QUERY":
      return InterpretError_InterpretErrorCode.INVALID_QUERY;
    case 2:
    case "FAILED_TO_UNDERSTAND":
      return InterpretError_InterpretErrorCode.FAILED_TO_UNDERSTAND;
    case 3:
    case "FAILED_TO_ANSWER":
      return InterpretError_InterpretErrorCode.FAILED_TO_ANSWER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InterpretError_InterpretErrorCode.UNRECOGNIZED;
  }
}

export function interpretError_InterpretErrorCodeToJSON(object: InterpretError_InterpretErrorCode): string {
  switch (object) {
    case InterpretError_InterpretErrorCode.INTERPRET_ERROR_CODE_UNSPECIFIED:
      return "INTERPRET_ERROR_CODE_UNSPECIFIED";
    case InterpretError_InterpretErrorCode.INVALID_QUERY:
      return "INVALID_QUERY";
    case InterpretError_InterpretErrorCode.FAILED_TO_UNDERSTAND:
      return "FAILED_TO_UNDERSTAND";
    case InterpretError_InterpretErrorCode.FAILED_TO_ANSWER:
      return "FAILED_TO_ANSWER";
    case InterpretError_InterpretErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details on interpretation failure. */
export interface InterpretError_InterpretErrorDetails {
  /** Populated if parts of the query are unsupported. */
  unsupportedDetails:
    | InterpretError_InterpretUnsupportedDetails
    | undefined;
  /** Populated if the query is incomplete. */
  incompleteQueryDetails:
    | InterpretError_InterpretIncompleteQueryDetails
    | undefined;
  /** Populated if the query was too ambiguous. */
  ambiguityDetails: InterpretError_InterpretAmbiguityDetails | undefined;
}

/** Details about unsupported parts in a query. */
export interface InterpretError_InterpretUnsupportedDetails {
  /** Unsupported operators. For example: median. */
  operators: string[];
  /** Unsupported intents. */
  intent: string[];
}

/** Details about an incomplete query. */
export interface InterpretError_InterpretIncompleteQueryDetails {
  /** List of missing interpret entities. */
  entities: InterpretEntity[];
}

/**
 * Details about a query that was too ambiguous. Currently, the message
 * has no fields and its presence signals that there was ambiguity.
 */
export interface InterpretError_InterpretAmbiguityDetails {
}

/** Information about the backend status (such as BigQuery) of the execution. */
export interface ExecutionInfo {
  /** Status returned by the backend when the job was created. */
  jobCreationStatus:
    | Status
    | undefined;
  /** Status of the job execution. */
  jobExecutionState: ExecutionInfo_JobExecutionState;
  /** Time when the execution was triggered. */
  createTime:
    | Date
    | undefined;
  /**
   * BigQuery job information.
   * Future versions will have different backends. Hence, clients must make sure
   * they can handle it when this field is not populated.
   */
  bigqueryJob: BigQueryJob | undefined;
}

/** Enum of possible job execution statuses. */
export enum ExecutionInfo_JobExecutionState {
  /** JOB_EXECUTION_STATE_UNSPECIFIED - No job execution was specified. */
  JOB_EXECUTION_STATE_UNSPECIFIED = 0,
  /** NOT_EXECUTED - No job execution was requested, yet. */
  NOT_EXECUTED = 1,
  /** RUNNING - The job is running. */
  RUNNING = 2,
  /** SUCCEEDED - The job completed successfully. */
  SUCCEEDED = 3,
  /** FAILED - The job completed unsuccessfully. */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function executionInfo_JobExecutionStateFromJSON(object: any): ExecutionInfo_JobExecutionState {
  switch (object) {
    case 0:
    case "JOB_EXECUTION_STATE_UNSPECIFIED":
      return ExecutionInfo_JobExecutionState.JOB_EXECUTION_STATE_UNSPECIFIED;
    case 1:
    case "NOT_EXECUTED":
      return ExecutionInfo_JobExecutionState.NOT_EXECUTED;
    case 2:
    case "RUNNING":
      return ExecutionInfo_JobExecutionState.RUNNING;
    case 3:
    case "SUCCEEDED":
      return ExecutionInfo_JobExecutionState.SUCCEEDED;
    case 4:
    case "FAILED":
      return ExecutionInfo_JobExecutionState.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionInfo_JobExecutionState.UNRECOGNIZED;
  }
}

export function executionInfo_JobExecutionStateToJSON(object: ExecutionInfo_JobExecutionState): string {
  switch (object) {
    case ExecutionInfo_JobExecutionState.JOB_EXECUTION_STATE_UNSPECIFIED:
      return "JOB_EXECUTION_STATE_UNSPECIFIED";
    case ExecutionInfo_JobExecutionState.NOT_EXECUTED:
      return "NOT_EXECUTED";
    case ExecutionInfo_JobExecutionState.RUNNING:
      return "RUNNING";
    case ExecutionInfo_JobExecutionState.SUCCEEDED:
      return "SUCCEEDED";
    case ExecutionInfo_JobExecutionState.FAILED:
      return "FAILED";
    case ExecutionInfo_JobExecutionState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * BigQuery job information. This can be used to query the BigQuery API and
 * retrieve the current job's status (using
 * [jobs.get](https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/get)).
 */
export interface BigQueryJob {
  /** The job ID. */
  jobId: string;
  /** The project ID of the job. */
  projectId: string;
  /** The location where the job is running. */
  location: string;
}

/** An interpretation of a natural language query. */
export interface Interpretation {
  /** List of data sources used in the current understanding. */
  dataSources: string[];
  /**
   * The level of confidence that one of the interpretations is correct. This is
   * a value in the range [0, 1] where a value of 0.5 or below is to be
   * considered a low confidence.
   */
  confidence: number;
  /**
   * A list of unused phrases. Clients should display a Did You Mean (DYM)
   *  dialog if this is non-empty, even if this is the only interpretation.
   */
  unusedPhrases: string[];
  /** Human readable representation of the query. */
  humanReadable:
    | HumanReadable
    | undefined;
  /**
   * Information about the interpretation structure that helps to understand and
   * visualize the response.
   */
  interpretationStructure:
    | InterpretationStructure
    | undefined;
  /** Representation of the data query to be sent to the backend. */
  dataQuery:
    | DataQuery
    | undefined;
  /**
   * Information about the backend response. This is populated only if execution
   * of an interpretation was requested.
   */
  executionInfo: ExecutionInfo | undefined;
}

/**
 * Representation of the data query for the backend.
 * This is provided for informational purposes only. Clients should not use
 * it to send it to the backend directly, but rather use the `execute` RPC
 * to trigger the execution. Using the `execute` RPC is needed in order to
 * track the state of a question and report on it correctly to the data
 * administrators.
 */
export interface DataQuery {
  /** The generated SQL query to be sent to the backend. */
  sql: string;
}

/** Human readable interpretation. */
export interface HumanReadable {
  /** Generated query explaining the interpretation. */
  generatedInterpretation:
    | AnnotatedString
    | undefined;
  /** Annotations on the original query. */
  originalQuestion: AnnotatedString | undefined;
}

/**
 * Information about the interpretation structure that helps to understand and
 * visualize the response.
 */
export interface InterpretationStructure {
  /**
   * List of possible visualization types to apply for this interpretation. The
   * order has no relevance.
   */
  visualizationTypes: InterpretationStructure_VisualizationType[];
  /**
   * Information about the output columns, that is, the columns that will be
   * returned by the backend.
   */
  columnInfo: InterpretationStructure_ColumnInfo[];
}

/** Enumeration of visualzation types to use for query response data. */
export enum InterpretationStructure_VisualizationType {
  /** VISUALIZATION_TYPE_UNSPECIFIED - No visualization type was specified. */
  VISUALIZATION_TYPE_UNSPECIFIED = 0,
  /** TABLE - Show a table. */
  TABLE = 1,
  /**
   * BAR_CHART - Show a [bar
   * chart](https://developers.google.com/chart/interactive/docs/gallery/barchart).
   */
  BAR_CHART = 2,
  /**
   * COLUMN_CHART - Show a [column
   * chart](https://developers.google.com/chart/interactive/docs/gallery/columnchart).
   */
  COLUMN_CHART = 3,
  /**
   * TIMELINE - Show a
   * [timeline](https://developers.google.com/chart/interactive/docs/gallery/timeline).
   */
  TIMELINE = 4,
  /**
   * SCATTER_PLOT - Show a [scatter
   * plot](https://developers.google.com/chart/interactive/docs/gallery/scatterchart).
   */
  SCATTER_PLOT = 5,
  /**
   * PIE_CHART - Show a [pie
   * chart](https://developers.google.com/chart/interactive/docs/gallery/piechart).
   */
  PIE_CHART = 6,
  /**
   * LINE_CHART - Show a [line
   * chart](https://developers.google.com/chart/interactive/docs/gallery/linechart).
   */
  LINE_CHART = 7,
  /**
   * AREA_CHART - Show an [area
   * chart](https://developers.google.com/chart/interactive/docs/gallery/areachart).
   */
  AREA_CHART = 8,
  /**
   * COMBO_CHART - Show a [combo
   * chart](https://developers.google.com/chart/interactive/docs/gallery/combochart).
   */
  COMBO_CHART = 9,
  /**
   * HISTOGRAM - Show a
   * [histogram](https://developers.google.com/chart/interactive/docs/gallery/histogram).
   */
  HISTOGRAM = 10,
  /**
   * GENERIC_CHART - This denotes queries when the user has not specified the particular type
   * of chart and has mentioned only a generic chart name such as "Chart",
   * "Plot", "Graph", etc. This will differentiate it from specific charting
   * terms such as "Bar chart", "Pie chart", etc.
   */
  GENERIC_CHART = 11,
  /**
   * CHART_NOT_UNDERSTOOD - The user tried to specify a chart type, but the interpreter could not
   * understand the type. The client should display a generic chart and may
   * give a hint to the user that the requested type was not understood.
   */
  CHART_NOT_UNDERSTOOD = 12,
  UNRECOGNIZED = -1,
}

export function interpretationStructure_VisualizationTypeFromJSON(
  object: any,
): InterpretationStructure_VisualizationType {
  switch (object) {
    case 0:
    case "VISUALIZATION_TYPE_UNSPECIFIED":
      return InterpretationStructure_VisualizationType.VISUALIZATION_TYPE_UNSPECIFIED;
    case 1:
    case "TABLE":
      return InterpretationStructure_VisualizationType.TABLE;
    case 2:
    case "BAR_CHART":
      return InterpretationStructure_VisualizationType.BAR_CHART;
    case 3:
    case "COLUMN_CHART":
      return InterpretationStructure_VisualizationType.COLUMN_CHART;
    case 4:
    case "TIMELINE":
      return InterpretationStructure_VisualizationType.TIMELINE;
    case 5:
    case "SCATTER_PLOT":
      return InterpretationStructure_VisualizationType.SCATTER_PLOT;
    case 6:
    case "PIE_CHART":
      return InterpretationStructure_VisualizationType.PIE_CHART;
    case 7:
    case "LINE_CHART":
      return InterpretationStructure_VisualizationType.LINE_CHART;
    case 8:
    case "AREA_CHART":
      return InterpretationStructure_VisualizationType.AREA_CHART;
    case 9:
    case "COMBO_CHART":
      return InterpretationStructure_VisualizationType.COMBO_CHART;
    case 10:
    case "HISTOGRAM":
      return InterpretationStructure_VisualizationType.HISTOGRAM;
    case 11:
    case "GENERIC_CHART":
      return InterpretationStructure_VisualizationType.GENERIC_CHART;
    case 12:
    case "CHART_NOT_UNDERSTOOD":
      return InterpretationStructure_VisualizationType.CHART_NOT_UNDERSTOOD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InterpretationStructure_VisualizationType.UNRECOGNIZED;
  }
}

export function interpretationStructure_VisualizationTypeToJSON(
  object: InterpretationStructure_VisualizationType,
): string {
  switch (object) {
    case InterpretationStructure_VisualizationType.VISUALIZATION_TYPE_UNSPECIFIED:
      return "VISUALIZATION_TYPE_UNSPECIFIED";
    case InterpretationStructure_VisualizationType.TABLE:
      return "TABLE";
    case InterpretationStructure_VisualizationType.BAR_CHART:
      return "BAR_CHART";
    case InterpretationStructure_VisualizationType.COLUMN_CHART:
      return "COLUMN_CHART";
    case InterpretationStructure_VisualizationType.TIMELINE:
      return "TIMELINE";
    case InterpretationStructure_VisualizationType.SCATTER_PLOT:
      return "SCATTER_PLOT";
    case InterpretationStructure_VisualizationType.PIE_CHART:
      return "PIE_CHART";
    case InterpretationStructure_VisualizationType.LINE_CHART:
      return "LINE_CHART";
    case InterpretationStructure_VisualizationType.AREA_CHART:
      return "AREA_CHART";
    case InterpretationStructure_VisualizationType.COMBO_CHART:
      return "COMBO_CHART";
    case InterpretationStructure_VisualizationType.HISTOGRAM:
      return "HISTOGRAM";
    case InterpretationStructure_VisualizationType.GENERIC_CHART:
      return "GENERIC_CHART";
    case InterpretationStructure_VisualizationType.CHART_NOT_UNDERSTOOD:
      return "CHART_NOT_UNDERSTOOD";
    case InterpretationStructure_VisualizationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about a column. */
export interface InterpretationStructure_ColumnInfo {
  /**
   * The alias of the output column as used by the backend. For example, the
   * field name in the schema provided in the query response in BigQuery.
   */
  outputAlias: string;
  /** Human readable name of the output column. */
  displayName: string;
}

/** Configuriation of debug flags. */
export interface DebugFlags {
  /** Whether to include the original VAQuery. */
  includeVaQuery: boolean;
  /** Whether to include the original nested VAQuery. */
  includeNestedVaQuery: boolean;
  /**
   * Whether to include the original human interpretation strings generated
   * by Analyza.
   */
  includeHumanInterpretation: boolean;
  /** Whether to include the Aqua debug response. */
  includeAquaDebugResponse: boolean;
  /**
   * The time in milliseconds from Unix epoch to be used
   * to process the query. This is useful for testing
   * the queries at different time period.
   * If not set or time_override <= 0, then the current
   * time is used.
   */
  timeOverride: Long;
  /** Set to true if request is initiated by an internal Google user. */
  isInternalGoogleUser: boolean;
  /**
   * Determines whether cache needs to be ignored. If set to
   * true, cache won't be queried and updated.
   */
  ignoreCache: boolean;
  /**
   * Whether to include the request/response pair from the call to the
   * EntityIndex for SearchEntities.
   */
  includeSearchEntitiesRpc: boolean;
  /**
   * Whether to include the request/response pair from the call to the
   * Annotations service for ListColumnAnnotations.
   */
  includeListColumnAnnotationsRpc: boolean;
  /** Whether to include the entity list passed to Analyza. */
  includeVirtualAnalystEntities: boolean;
  /** Whether to include the table list. */
  includeTableList: boolean;
  /** Whether to include the domain list. */
  includeDomainList: boolean;
}

function createBaseQuestion(): Question {
  return {
    name: "",
    scopes: [],
    query: "",
    dataSourceAnnotations: [],
    interpretError: undefined,
    interpretations: [],
    createTime: undefined,
    userEmail: "",
    debugFlags: undefined,
    debugInfo: undefined,
  };
}

export const Question: MessageFns<Question> = {
  encode(message: Question, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.scopes) {
      writer.uint32(18).string(v!);
    }
    if (message.query !== "") {
      writer.uint32(26).string(message.query);
    }
    for (const v of message.dataSourceAnnotations) {
      writer.uint32(34).string(v!);
    }
    if (message.interpretError !== undefined) {
      InterpretError.encode(message.interpretError, writer.uint32(42).fork()).join();
    }
    for (const v of message.interpretations) {
      Interpretation.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.userEmail !== "") {
      writer.uint32(66).string(message.userEmail);
    }
    if (message.debugFlags !== undefined) {
      DebugFlags.encode(message.debugFlags, writer.uint32(74).fork()).join();
    }
    if (message.debugInfo !== undefined) {
      Any.encode(message.debugInfo, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Question {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dataSourceAnnotations.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.interpretError = InterpretError.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.interpretations.push(Interpretation.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.userEmail = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.debugFlags = DebugFlags.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.debugInfo = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Question {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      dataSourceAnnotations: globalThis.Array.isArray(object?.dataSourceAnnotations)
        ? object.dataSourceAnnotations.map((e: any) => globalThis.String(e))
        : [],
      interpretError: isSet(object.interpretError) ? InterpretError.fromJSON(object.interpretError) : undefined,
      interpretations: globalThis.Array.isArray(object?.interpretations)
        ? object.interpretations.map((e: any) => Interpretation.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      userEmail: isSet(object.userEmail) ? globalThis.String(object.userEmail) : "",
      debugFlags: isSet(object.debugFlags) ? DebugFlags.fromJSON(object.debugFlags) : undefined,
      debugInfo: isSet(object.debugInfo) ? Any.fromJSON(object.debugInfo) : undefined,
    };
  },

  toJSON(message: Question): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.dataSourceAnnotations?.length) {
      obj.dataSourceAnnotations = message.dataSourceAnnotations;
    }
    if (message.interpretError !== undefined) {
      obj.interpretError = InterpretError.toJSON(message.interpretError);
    }
    if (message.interpretations?.length) {
      obj.interpretations = message.interpretations.map((e) => Interpretation.toJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.userEmail !== "") {
      obj.userEmail = message.userEmail;
    }
    if (message.debugFlags !== undefined) {
      obj.debugFlags = DebugFlags.toJSON(message.debugFlags);
    }
    if (message.debugInfo !== undefined) {
      obj.debugInfo = Any.toJSON(message.debugInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<Question>): Question {
    return Question.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Question>): Question {
    const message = createBaseQuestion();
    message.name = object.name ?? "";
    message.scopes = object.scopes?.map((e) => e) || [];
    message.query = object.query ?? "";
    message.dataSourceAnnotations = object.dataSourceAnnotations?.map((e) => e) || [];
    message.interpretError = (object.interpretError !== undefined && object.interpretError !== null)
      ? InterpretError.fromPartial(object.interpretError)
      : undefined;
    message.interpretations = object.interpretations?.map((e) => Interpretation.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    message.userEmail = object.userEmail ?? "";
    message.debugFlags = (object.debugFlags !== undefined && object.debugFlags !== null)
      ? DebugFlags.fromPartial(object.debugFlags)
      : undefined;
    message.debugInfo = (object.debugInfo !== undefined && object.debugInfo !== null)
      ? Any.fromPartial(object.debugInfo)
      : undefined;
    return message;
  },
};

function createBaseInterpretError(): InterpretError {
  return { message: "", code: 0, details: undefined };
}

export const InterpretError: MessageFns<InterpretError> = {
  encode(message: InterpretError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.code !== 0) {
      writer.uint32(16).int32(message.code);
    }
    if (message.details !== undefined) {
      InterpretError_InterpretErrorDetails.encode(message.details, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterpretError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterpretError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.details = InterpretError_InterpretErrorDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterpretError {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      code: isSet(object.code) ? interpretError_InterpretErrorCodeFromJSON(object.code) : 0,
      details: isSet(object.details) ? InterpretError_InterpretErrorDetails.fromJSON(object.details) : undefined,
    };
  },

  toJSON(message: InterpretError): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.code !== 0) {
      obj.code = interpretError_InterpretErrorCodeToJSON(message.code);
    }
    if (message.details !== undefined) {
      obj.details = InterpretError_InterpretErrorDetails.toJSON(message.details);
    }
    return obj;
  },

  create(base?: DeepPartial<InterpretError>): InterpretError {
    return InterpretError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InterpretError>): InterpretError {
    const message = createBaseInterpretError();
    message.message = object.message ?? "";
    message.code = object.code ?? 0;
    message.details = (object.details !== undefined && object.details !== null)
      ? InterpretError_InterpretErrorDetails.fromPartial(object.details)
      : undefined;
    return message;
  },
};

function createBaseInterpretError_InterpretErrorDetails(): InterpretError_InterpretErrorDetails {
  return { unsupportedDetails: undefined, incompleteQueryDetails: undefined, ambiguityDetails: undefined };
}

export const InterpretError_InterpretErrorDetails: MessageFns<InterpretError_InterpretErrorDetails> = {
  encode(message: InterpretError_InterpretErrorDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unsupportedDetails !== undefined) {
      InterpretError_InterpretUnsupportedDetails.encode(message.unsupportedDetails, writer.uint32(10).fork()).join();
    }
    if (message.incompleteQueryDetails !== undefined) {
      InterpretError_InterpretIncompleteQueryDetails.encode(message.incompleteQueryDetails, writer.uint32(18).fork())
        .join();
    }
    if (message.ambiguityDetails !== undefined) {
      InterpretError_InterpretAmbiguityDetails.encode(message.ambiguityDetails, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterpretError_InterpretErrorDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterpretError_InterpretErrorDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unsupportedDetails = InterpretError_InterpretUnsupportedDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.incompleteQueryDetails = InterpretError_InterpretIncompleteQueryDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ambiguityDetails = InterpretError_InterpretAmbiguityDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterpretError_InterpretErrorDetails {
    return {
      unsupportedDetails: isSet(object.unsupportedDetails)
        ? InterpretError_InterpretUnsupportedDetails.fromJSON(object.unsupportedDetails)
        : undefined,
      incompleteQueryDetails: isSet(object.incompleteQueryDetails)
        ? InterpretError_InterpretIncompleteQueryDetails.fromJSON(object.incompleteQueryDetails)
        : undefined,
      ambiguityDetails: isSet(object.ambiguityDetails)
        ? InterpretError_InterpretAmbiguityDetails.fromJSON(object.ambiguityDetails)
        : undefined,
    };
  },

  toJSON(message: InterpretError_InterpretErrorDetails): unknown {
    const obj: any = {};
    if (message.unsupportedDetails !== undefined) {
      obj.unsupportedDetails = InterpretError_InterpretUnsupportedDetails.toJSON(message.unsupportedDetails);
    }
    if (message.incompleteQueryDetails !== undefined) {
      obj.incompleteQueryDetails = InterpretError_InterpretIncompleteQueryDetails.toJSON(
        message.incompleteQueryDetails,
      );
    }
    if (message.ambiguityDetails !== undefined) {
      obj.ambiguityDetails = InterpretError_InterpretAmbiguityDetails.toJSON(message.ambiguityDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<InterpretError_InterpretErrorDetails>): InterpretError_InterpretErrorDetails {
    return InterpretError_InterpretErrorDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InterpretError_InterpretErrorDetails>): InterpretError_InterpretErrorDetails {
    const message = createBaseInterpretError_InterpretErrorDetails();
    message.unsupportedDetails = (object.unsupportedDetails !== undefined && object.unsupportedDetails !== null)
      ? InterpretError_InterpretUnsupportedDetails.fromPartial(object.unsupportedDetails)
      : undefined;
    message.incompleteQueryDetails =
      (object.incompleteQueryDetails !== undefined && object.incompleteQueryDetails !== null)
        ? InterpretError_InterpretIncompleteQueryDetails.fromPartial(object.incompleteQueryDetails)
        : undefined;
    message.ambiguityDetails = (object.ambiguityDetails !== undefined && object.ambiguityDetails !== null)
      ? InterpretError_InterpretAmbiguityDetails.fromPartial(object.ambiguityDetails)
      : undefined;
    return message;
  },
};

function createBaseInterpretError_InterpretUnsupportedDetails(): InterpretError_InterpretUnsupportedDetails {
  return { operators: [], intent: [] };
}

export const InterpretError_InterpretUnsupportedDetails: MessageFns<InterpretError_InterpretUnsupportedDetails> = {
  encode(message: InterpretError_InterpretUnsupportedDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.operators) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.intent) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterpretError_InterpretUnsupportedDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterpretError_InterpretUnsupportedDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operators.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.intent.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterpretError_InterpretUnsupportedDetails {
    return {
      operators: globalThis.Array.isArray(object?.operators)
        ? object.operators.map((e: any) => globalThis.String(e))
        : [],
      intent: globalThis.Array.isArray(object?.intent) ? object.intent.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: InterpretError_InterpretUnsupportedDetails): unknown {
    const obj: any = {};
    if (message.operators?.length) {
      obj.operators = message.operators;
    }
    if (message.intent?.length) {
      obj.intent = message.intent;
    }
    return obj;
  },

  create(base?: DeepPartial<InterpretError_InterpretUnsupportedDetails>): InterpretError_InterpretUnsupportedDetails {
    return InterpretError_InterpretUnsupportedDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<InterpretError_InterpretUnsupportedDetails>,
  ): InterpretError_InterpretUnsupportedDetails {
    const message = createBaseInterpretError_InterpretUnsupportedDetails();
    message.operators = object.operators?.map((e) => e) || [];
    message.intent = object.intent?.map((e) => e) || [];
    return message;
  },
};

function createBaseInterpretError_InterpretIncompleteQueryDetails(): InterpretError_InterpretIncompleteQueryDetails {
  return { entities: [] };
}

export const InterpretError_InterpretIncompleteQueryDetails: MessageFns<
  InterpretError_InterpretIncompleteQueryDetails
> = {
  encode(
    message: InterpretError_InterpretIncompleteQueryDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.entities) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterpretError_InterpretIncompleteQueryDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterpretError_InterpretIncompleteQueryDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.entities.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.entities.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterpretError_InterpretIncompleteQueryDetails {
    return {
      entities: globalThis.Array.isArray(object?.entities)
        ? object.entities.map((e: any) => interpretEntityFromJSON(e))
        : [],
    };
  },

  toJSON(message: InterpretError_InterpretIncompleteQueryDetails): unknown {
    const obj: any = {};
    if (message.entities?.length) {
      obj.entities = message.entities.map((e) => interpretEntityToJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<InterpretError_InterpretIncompleteQueryDetails>,
  ): InterpretError_InterpretIncompleteQueryDetails {
    return InterpretError_InterpretIncompleteQueryDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<InterpretError_InterpretIncompleteQueryDetails>,
  ): InterpretError_InterpretIncompleteQueryDetails {
    const message = createBaseInterpretError_InterpretIncompleteQueryDetails();
    message.entities = object.entities?.map((e) => e) || [];
    return message;
  },
};

function createBaseInterpretError_InterpretAmbiguityDetails(): InterpretError_InterpretAmbiguityDetails {
  return {};
}

export const InterpretError_InterpretAmbiguityDetails: MessageFns<InterpretError_InterpretAmbiguityDetails> = {
  encode(_: InterpretError_InterpretAmbiguityDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterpretError_InterpretAmbiguityDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterpretError_InterpretAmbiguityDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InterpretError_InterpretAmbiguityDetails {
    return {};
  },

  toJSON(_: InterpretError_InterpretAmbiguityDetails): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<InterpretError_InterpretAmbiguityDetails>): InterpretError_InterpretAmbiguityDetails {
    return InterpretError_InterpretAmbiguityDetails.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<InterpretError_InterpretAmbiguityDetails>): InterpretError_InterpretAmbiguityDetails {
    const message = createBaseInterpretError_InterpretAmbiguityDetails();
    return message;
  },
};

function createBaseExecutionInfo(): ExecutionInfo {
  return { jobCreationStatus: undefined, jobExecutionState: 0, createTime: undefined, bigqueryJob: undefined };
}

export const ExecutionInfo: MessageFns<ExecutionInfo> = {
  encode(message: ExecutionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobCreationStatus !== undefined) {
      Status.encode(message.jobCreationStatus, writer.uint32(10).fork()).join();
    }
    if (message.jobExecutionState !== 0) {
      writer.uint32(16).int32(message.jobExecutionState);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.bigqueryJob !== undefined) {
      BigQueryJob.encode(message.bigqueryJob, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jobCreationStatus = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.jobExecutionState = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bigqueryJob = BigQueryJob.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionInfo {
    return {
      jobCreationStatus: isSet(object.jobCreationStatus) ? Status.fromJSON(object.jobCreationStatus) : undefined,
      jobExecutionState: isSet(object.jobExecutionState)
        ? executionInfo_JobExecutionStateFromJSON(object.jobExecutionState)
        : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      bigqueryJob: isSet(object.bigqueryJob) ? BigQueryJob.fromJSON(object.bigqueryJob) : undefined,
    };
  },

  toJSON(message: ExecutionInfo): unknown {
    const obj: any = {};
    if (message.jobCreationStatus !== undefined) {
      obj.jobCreationStatus = Status.toJSON(message.jobCreationStatus);
    }
    if (message.jobExecutionState !== 0) {
      obj.jobExecutionState = executionInfo_JobExecutionStateToJSON(message.jobExecutionState);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.bigqueryJob !== undefined) {
      obj.bigqueryJob = BigQueryJob.toJSON(message.bigqueryJob);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutionInfo>): ExecutionInfo {
    return ExecutionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutionInfo>): ExecutionInfo {
    const message = createBaseExecutionInfo();
    message.jobCreationStatus = (object.jobCreationStatus !== undefined && object.jobCreationStatus !== null)
      ? Status.fromPartial(object.jobCreationStatus)
      : undefined;
    message.jobExecutionState = object.jobExecutionState ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.bigqueryJob = (object.bigqueryJob !== undefined && object.bigqueryJob !== null)
      ? BigQueryJob.fromPartial(object.bigqueryJob)
      : undefined;
    return message;
  },
};

function createBaseBigQueryJob(): BigQueryJob {
  return { jobId: "", projectId: "", location: "" };
}

export const BigQueryJob: MessageFns<BigQueryJob> = {
  encode(message: BigQueryJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.location !== "") {
      writer.uint32(26).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BigQueryJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigQueryJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BigQueryJob {
    return {
      jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: BigQueryJob): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<BigQueryJob>): BigQueryJob {
    return BigQueryJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BigQueryJob>): BigQueryJob {
    const message = createBaseBigQueryJob();
    message.jobId = object.jobId ?? "";
    message.projectId = object.projectId ?? "";
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseInterpretation(): Interpretation {
  return {
    dataSources: [],
    confidence: 0,
    unusedPhrases: [],
    humanReadable: undefined,
    interpretationStructure: undefined,
    dataQuery: undefined,
    executionInfo: undefined,
  };
}

export const Interpretation: MessageFns<Interpretation> = {
  encode(message: Interpretation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dataSources) {
      writer.uint32(10).string(v!);
    }
    if (message.confidence !== 0) {
      writer.uint32(17).double(message.confidence);
    }
    for (const v of message.unusedPhrases) {
      writer.uint32(26).string(v!);
    }
    if (message.humanReadable !== undefined) {
      HumanReadable.encode(message.humanReadable, writer.uint32(34).fork()).join();
    }
    if (message.interpretationStructure !== undefined) {
      InterpretationStructure.encode(message.interpretationStructure, writer.uint32(42).fork()).join();
    }
    if (message.dataQuery !== undefined) {
      DataQuery.encode(message.dataQuery, writer.uint32(50).fork()).join();
    }
    if (message.executionInfo !== undefined) {
      ExecutionInfo.encode(message.executionInfo, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Interpretation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterpretation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSources.push(reader.string());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.confidence = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unusedPhrases.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.humanReadable = HumanReadable.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.interpretationStructure = InterpretationStructure.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dataQuery = DataQuery.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.executionInfo = ExecutionInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Interpretation {
    return {
      dataSources: globalThis.Array.isArray(object?.dataSources)
        ? object.dataSources.map((e: any) => globalThis.String(e))
        : [],
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      unusedPhrases: globalThis.Array.isArray(object?.unusedPhrases)
        ? object.unusedPhrases.map((e: any) => globalThis.String(e))
        : [],
      humanReadable: isSet(object.humanReadable) ? HumanReadable.fromJSON(object.humanReadable) : undefined,
      interpretationStructure: isSet(object.interpretationStructure)
        ? InterpretationStructure.fromJSON(object.interpretationStructure)
        : undefined,
      dataQuery: isSet(object.dataQuery) ? DataQuery.fromJSON(object.dataQuery) : undefined,
      executionInfo: isSet(object.executionInfo) ? ExecutionInfo.fromJSON(object.executionInfo) : undefined,
    };
  },

  toJSON(message: Interpretation): unknown {
    const obj: any = {};
    if (message.dataSources?.length) {
      obj.dataSources = message.dataSources;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.unusedPhrases?.length) {
      obj.unusedPhrases = message.unusedPhrases;
    }
    if (message.humanReadable !== undefined) {
      obj.humanReadable = HumanReadable.toJSON(message.humanReadable);
    }
    if (message.interpretationStructure !== undefined) {
      obj.interpretationStructure = InterpretationStructure.toJSON(message.interpretationStructure);
    }
    if (message.dataQuery !== undefined) {
      obj.dataQuery = DataQuery.toJSON(message.dataQuery);
    }
    if (message.executionInfo !== undefined) {
      obj.executionInfo = ExecutionInfo.toJSON(message.executionInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<Interpretation>): Interpretation {
    return Interpretation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Interpretation>): Interpretation {
    const message = createBaseInterpretation();
    message.dataSources = object.dataSources?.map((e) => e) || [];
    message.confidence = object.confidence ?? 0;
    message.unusedPhrases = object.unusedPhrases?.map((e) => e) || [];
    message.humanReadable = (object.humanReadable !== undefined && object.humanReadable !== null)
      ? HumanReadable.fromPartial(object.humanReadable)
      : undefined;
    message.interpretationStructure =
      (object.interpretationStructure !== undefined && object.interpretationStructure !== null)
        ? InterpretationStructure.fromPartial(object.interpretationStructure)
        : undefined;
    message.dataQuery = (object.dataQuery !== undefined && object.dataQuery !== null)
      ? DataQuery.fromPartial(object.dataQuery)
      : undefined;
    message.executionInfo = (object.executionInfo !== undefined && object.executionInfo !== null)
      ? ExecutionInfo.fromPartial(object.executionInfo)
      : undefined;
    return message;
  },
};

function createBaseDataQuery(): DataQuery {
  return { sql: "" };
}

export const DataQuery: MessageFns<DataQuery> = {
  encode(message: DataQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sql !== "") {
      writer.uint32(10).string(message.sql);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sql = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataQuery {
    return { sql: isSet(object.sql) ? globalThis.String(object.sql) : "" };
  },

  toJSON(message: DataQuery): unknown {
    const obj: any = {};
    if (message.sql !== "") {
      obj.sql = message.sql;
    }
    return obj;
  },

  create(base?: DeepPartial<DataQuery>): DataQuery {
    return DataQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataQuery>): DataQuery {
    const message = createBaseDataQuery();
    message.sql = object.sql ?? "";
    return message;
  },
};

function createBaseHumanReadable(): HumanReadable {
  return { generatedInterpretation: undefined, originalQuestion: undefined };
}

export const HumanReadable: MessageFns<HumanReadable> = {
  encode(message: HumanReadable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.generatedInterpretation !== undefined) {
      AnnotatedString.encode(message.generatedInterpretation, writer.uint32(10).fork()).join();
    }
    if (message.originalQuestion !== undefined) {
      AnnotatedString.encode(message.originalQuestion, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HumanReadable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHumanReadable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.generatedInterpretation = AnnotatedString.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.originalQuestion = AnnotatedString.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HumanReadable {
    return {
      generatedInterpretation: isSet(object.generatedInterpretation)
        ? AnnotatedString.fromJSON(object.generatedInterpretation)
        : undefined,
      originalQuestion: isSet(object.originalQuestion) ? AnnotatedString.fromJSON(object.originalQuestion) : undefined,
    };
  },

  toJSON(message: HumanReadable): unknown {
    const obj: any = {};
    if (message.generatedInterpretation !== undefined) {
      obj.generatedInterpretation = AnnotatedString.toJSON(message.generatedInterpretation);
    }
    if (message.originalQuestion !== undefined) {
      obj.originalQuestion = AnnotatedString.toJSON(message.originalQuestion);
    }
    return obj;
  },

  create(base?: DeepPartial<HumanReadable>): HumanReadable {
    return HumanReadable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HumanReadable>): HumanReadable {
    const message = createBaseHumanReadable();
    message.generatedInterpretation =
      (object.generatedInterpretation !== undefined && object.generatedInterpretation !== null)
        ? AnnotatedString.fromPartial(object.generatedInterpretation)
        : undefined;
    message.originalQuestion = (object.originalQuestion !== undefined && object.originalQuestion !== null)
      ? AnnotatedString.fromPartial(object.originalQuestion)
      : undefined;
    return message;
  },
};

function createBaseInterpretationStructure(): InterpretationStructure {
  return { visualizationTypes: [], columnInfo: [] };
}

export const InterpretationStructure: MessageFns<InterpretationStructure> = {
  encode(message: InterpretationStructure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.visualizationTypes) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.columnInfo) {
      InterpretationStructure_ColumnInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterpretationStructure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterpretationStructure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.visualizationTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.visualizationTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.columnInfo.push(InterpretationStructure_ColumnInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterpretationStructure {
    return {
      visualizationTypes: globalThis.Array.isArray(object?.visualizationTypes)
        ? object.visualizationTypes.map((e: any) => interpretationStructure_VisualizationTypeFromJSON(e))
        : [],
      columnInfo: globalThis.Array.isArray(object?.columnInfo)
        ? object.columnInfo.map((e: any) => InterpretationStructure_ColumnInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InterpretationStructure): unknown {
    const obj: any = {};
    if (message.visualizationTypes?.length) {
      obj.visualizationTypes = message.visualizationTypes.map((e) =>
        interpretationStructure_VisualizationTypeToJSON(e)
      );
    }
    if (message.columnInfo?.length) {
      obj.columnInfo = message.columnInfo.map((e) => InterpretationStructure_ColumnInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<InterpretationStructure>): InterpretationStructure {
    return InterpretationStructure.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InterpretationStructure>): InterpretationStructure {
    const message = createBaseInterpretationStructure();
    message.visualizationTypes = object.visualizationTypes?.map((e) => e) || [];
    message.columnInfo = object.columnInfo?.map((e) => InterpretationStructure_ColumnInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInterpretationStructure_ColumnInfo(): InterpretationStructure_ColumnInfo {
  return { outputAlias: "", displayName: "" };
}

export const InterpretationStructure_ColumnInfo: MessageFns<InterpretationStructure_ColumnInfo> = {
  encode(message: InterpretationStructure_ColumnInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputAlias !== "") {
      writer.uint32(10).string(message.outputAlias);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterpretationStructure_ColumnInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterpretationStructure_ColumnInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outputAlias = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterpretationStructure_ColumnInfo {
    return {
      outputAlias: isSet(object.outputAlias) ? globalThis.String(object.outputAlias) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: InterpretationStructure_ColumnInfo): unknown {
    const obj: any = {};
    if (message.outputAlias !== "") {
      obj.outputAlias = message.outputAlias;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<InterpretationStructure_ColumnInfo>): InterpretationStructure_ColumnInfo {
    return InterpretationStructure_ColumnInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InterpretationStructure_ColumnInfo>): InterpretationStructure_ColumnInfo {
    const message = createBaseInterpretationStructure_ColumnInfo();
    message.outputAlias = object.outputAlias ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseDebugFlags(): DebugFlags {
  return {
    includeVaQuery: false,
    includeNestedVaQuery: false,
    includeHumanInterpretation: false,
    includeAquaDebugResponse: false,
    timeOverride: Long.ZERO,
    isInternalGoogleUser: false,
    ignoreCache: false,
    includeSearchEntitiesRpc: false,
    includeListColumnAnnotationsRpc: false,
    includeVirtualAnalystEntities: false,
    includeTableList: false,
    includeDomainList: false,
  };
}

export const DebugFlags: MessageFns<DebugFlags> = {
  encode(message: DebugFlags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeVaQuery !== false) {
      writer.uint32(8).bool(message.includeVaQuery);
    }
    if (message.includeNestedVaQuery !== false) {
      writer.uint32(16).bool(message.includeNestedVaQuery);
    }
    if (message.includeHumanInterpretation !== false) {
      writer.uint32(24).bool(message.includeHumanInterpretation);
    }
    if (message.includeAquaDebugResponse !== false) {
      writer.uint32(32).bool(message.includeAquaDebugResponse);
    }
    if (!message.timeOverride.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.timeOverride.toString());
    }
    if (message.isInternalGoogleUser !== false) {
      writer.uint32(48).bool(message.isInternalGoogleUser);
    }
    if (message.ignoreCache !== false) {
      writer.uint32(56).bool(message.ignoreCache);
    }
    if (message.includeSearchEntitiesRpc !== false) {
      writer.uint32(64).bool(message.includeSearchEntitiesRpc);
    }
    if (message.includeListColumnAnnotationsRpc !== false) {
      writer.uint32(72).bool(message.includeListColumnAnnotationsRpc);
    }
    if (message.includeVirtualAnalystEntities !== false) {
      writer.uint32(80).bool(message.includeVirtualAnalystEntities);
    }
    if (message.includeTableList !== false) {
      writer.uint32(88).bool(message.includeTableList);
    }
    if (message.includeDomainList !== false) {
      writer.uint32(96).bool(message.includeDomainList);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DebugFlags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebugFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.includeVaQuery = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeNestedVaQuery = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.includeHumanInterpretation = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.includeAquaDebugResponse = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.timeOverride = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isInternalGoogleUser = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.ignoreCache = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.includeSearchEntitiesRpc = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.includeListColumnAnnotationsRpc = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.includeVirtualAnalystEntities = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.includeTableList = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.includeDomainList = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DebugFlags {
    return {
      includeVaQuery: isSet(object.includeVaQuery) ? globalThis.Boolean(object.includeVaQuery) : false,
      includeNestedVaQuery: isSet(object.includeNestedVaQuery)
        ? globalThis.Boolean(object.includeNestedVaQuery)
        : false,
      includeHumanInterpretation: isSet(object.includeHumanInterpretation)
        ? globalThis.Boolean(object.includeHumanInterpretation)
        : false,
      includeAquaDebugResponse: isSet(object.includeAquaDebugResponse)
        ? globalThis.Boolean(object.includeAquaDebugResponse)
        : false,
      timeOverride: isSet(object.timeOverride) ? Long.fromValue(object.timeOverride) : Long.ZERO,
      isInternalGoogleUser: isSet(object.isInternalGoogleUser)
        ? globalThis.Boolean(object.isInternalGoogleUser)
        : false,
      ignoreCache: isSet(object.ignoreCache) ? globalThis.Boolean(object.ignoreCache) : false,
      includeSearchEntitiesRpc: isSet(object.includeSearchEntitiesRpc)
        ? globalThis.Boolean(object.includeSearchEntitiesRpc)
        : false,
      includeListColumnAnnotationsRpc: isSet(object.includeListColumnAnnotationsRpc)
        ? globalThis.Boolean(object.includeListColumnAnnotationsRpc)
        : false,
      includeVirtualAnalystEntities: isSet(object.includeVirtualAnalystEntities)
        ? globalThis.Boolean(object.includeVirtualAnalystEntities)
        : false,
      includeTableList: isSet(object.includeTableList) ? globalThis.Boolean(object.includeTableList) : false,
      includeDomainList: isSet(object.includeDomainList) ? globalThis.Boolean(object.includeDomainList) : false,
    };
  },

  toJSON(message: DebugFlags): unknown {
    const obj: any = {};
    if (message.includeVaQuery !== false) {
      obj.includeVaQuery = message.includeVaQuery;
    }
    if (message.includeNestedVaQuery !== false) {
      obj.includeNestedVaQuery = message.includeNestedVaQuery;
    }
    if (message.includeHumanInterpretation !== false) {
      obj.includeHumanInterpretation = message.includeHumanInterpretation;
    }
    if (message.includeAquaDebugResponse !== false) {
      obj.includeAquaDebugResponse = message.includeAquaDebugResponse;
    }
    if (!message.timeOverride.equals(Long.ZERO)) {
      obj.timeOverride = (message.timeOverride || Long.ZERO).toString();
    }
    if (message.isInternalGoogleUser !== false) {
      obj.isInternalGoogleUser = message.isInternalGoogleUser;
    }
    if (message.ignoreCache !== false) {
      obj.ignoreCache = message.ignoreCache;
    }
    if (message.includeSearchEntitiesRpc !== false) {
      obj.includeSearchEntitiesRpc = message.includeSearchEntitiesRpc;
    }
    if (message.includeListColumnAnnotationsRpc !== false) {
      obj.includeListColumnAnnotationsRpc = message.includeListColumnAnnotationsRpc;
    }
    if (message.includeVirtualAnalystEntities !== false) {
      obj.includeVirtualAnalystEntities = message.includeVirtualAnalystEntities;
    }
    if (message.includeTableList !== false) {
      obj.includeTableList = message.includeTableList;
    }
    if (message.includeDomainList !== false) {
      obj.includeDomainList = message.includeDomainList;
    }
    return obj;
  },

  create(base?: DeepPartial<DebugFlags>): DebugFlags {
    return DebugFlags.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DebugFlags>): DebugFlags {
    const message = createBaseDebugFlags();
    message.includeVaQuery = object.includeVaQuery ?? false;
    message.includeNestedVaQuery = object.includeNestedVaQuery ?? false;
    message.includeHumanInterpretation = object.includeHumanInterpretation ?? false;
    message.includeAquaDebugResponse = object.includeAquaDebugResponse ?? false;
    message.timeOverride = (object.timeOverride !== undefined && object.timeOverride !== null)
      ? Long.fromValue(object.timeOverride)
      : Long.ZERO;
    message.isInternalGoogleUser = object.isInternalGoogleUser ?? false;
    message.ignoreCache = object.ignoreCache ?? false;
    message.includeSearchEntitiesRpc = object.includeSearchEntitiesRpc ?? false;
    message.includeListColumnAnnotationsRpc = object.includeListColumnAnnotationsRpc ?? false;
    message.includeVirtualAnalystEntities = object.includeVirtualAnalystEntities ?? false;
    message.includeTableList = object.includeTableList ?? false;
    message.includeDomainList = object.includeDomainList ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
