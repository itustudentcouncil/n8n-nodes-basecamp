// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/servicehealth/logging/v1/event_log.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.servicehealth.logging.v1";

/** Message describing the payload of service health logs. */
export interface EventLog {
  /** Brief description for the event. */
  title: string;
  /** Free-form, human-readable description. */
  description: string;
  /** Identifies the category of the event. */
  category: EventLog_EventCategory;
  /** The current state of the event. */
  state: EventLog_State;
  /** The current detailed state of the event. */
  detailedState: EventLog_DetailedState;
  /**
   * Google Cloud products known to be affected by the event, in JSON serialized
   * format. List of all supported [Google Cloud
   * products](../resources/products-locations.md).
   *
   * Example: "`['Google Cloud SQL', 'Cloud Compute Engine']`".
   */
  impactedProducts: string;
  /**
   * Locations known to be impacted by the event, in JSON serialized format. See
   * possible [values](products-locations.md), which are subject to where the
   * service is running.
   *
   * Example: "`['us-central1', 'us-west1']`".
   */
  impactedLocations: string;
  /**
   * Communicates why a given event is deemed relevant in the context of a given
   * project.
   */
  relevance: EventLog_Relevance;
  /**
   * When `detailed_state`=`MERGED`, `parent_event` contains the name of the
   * parent event. All further updates will be published to the parent event.
   */
  parentEvent: string;
  /** The time when the event was last modified. */
  updateTime:
    | Date
    | undefined;
  /** The start time of the event, if applicable. */
  startTime:
    | Date
    | undefined;
  /** The end time of the event, if applicable. */
  endTime:
    | Date
    | undefined;
  /** Incident-only field. The time when the next update can be expected. */
  nextUpdateTime: Date | undefined;
}

/**
 * The category of the event. This enum lists all possible categories of
 * event.
 */
export enum EventLog_EventCategory {
  /** EVENT_CATEGORY_UNSPECIFIED - Unspecified category. */
  EVENT_CATEGORY_UNSPECIFIED = 0,
  /** INCIDENT - Event category for service outage or degradation. */
  INCIDENT = 2,
  UNRECOGNIZED = -1,
}

export function eventLog_EventCategoryFromJSON(object: any): EventLog_EventCategory {
  switch (object) {
    case 0:
    case "EVENT_CATEGORY_UNSPECIFIED":
      return EventLog_EventCategory.EVENT_CATEGORY_UNSPECIFIED;
    case 2:
    case "INCIDENT":
      return EventLog_EventCategory.INCIDENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventLog_EventCategory.UNRECOGNIZED;
  }
}

export function eventLog_EventCategoryToJSON(object: EventLog_EventCategory): string {
  switch (object) {
    case EventLog_EventCategory.EVENT_CATEGORY_UNSPECIFIED:
      return "EVENT_CATEGORY_UNSPECIFIED";
    case EventLog_EventCategory.INCIDENT:
      return "INCIDENT";
    case EventLog_EventCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The state of the event. This enum lists all possible states of event. */
export enum EventLog_State {
  /** STATE_UNSPECIFIED - Unspecified state */
  STATE_UNSPECIFIED = 0,
  /**
   * ACTIVE - Event is actively affecting a Google Cloud service and will continue to
   * receive updates.
   */
  ACTIVE = 1,
  /**
   * CLOSED - Event is no longer affecting the Google Cloud service or has been merged
   * with another event.
   */
  CLOSED = 2,
  UNRECOGNIZED = -1,
}

export function eventLog_StateFromJSON(object: any): EventLog_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return EventLog_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return EventLog_State.ACTIVE;
    case 2:
    case "CLOSED":
      return EventLog_State.CLOSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventLog_State.UNRECOGNIZED;
  }
}

export function eventLog_StateToJSON(object: EventLog_State): string {
  switch (object) {
    case EventLog_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case EventLog_State.ACTIVE:
      return "ACTIVE";
    case EventLog_State.CLOSED:
      return "CLOSED";
    case EventLog_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The detailed state of the event. This enum lists all possible detail states
 * of event.
 */
export enum EventLog_DetailedState {
  /** DETAILED_STATE_UNSPECIFIED - Unspecified detail state. */
  DETAILED_STATE_UNSPECIFIED = 0,
  /**
   * EMERGING - Google engineers are actively investigating the event to determine the
   * impact.
   */
  EMERGING = 1,
  /**
   * CONFIRMED - The event is confirmed and impacting at least one Google Cloud service.
   * Ongoing status updates will be provided until it is resolved.
   */
  CONFIRMED = 2,
  /**
   * RESOLVED - The event is no longer affecting any Google Cloud service, and there will
   * be no further updates.
   */
  RESOLVED = 3,
  /**
   * MERGED - Event was merged into a parent event. All further updates will be
   * published to the parent only. The `parent_event` field contains the name
   * of the parent.
   */
  MERGED = 4,
  UNRECOGNIZED = -1,
}

export function eventLog_DetailedStateFromJSON(object: any): EventLog_DetailedState {
  switch (object) {
    case 0:
    case "DETAILED_STATE_UNSPECIFIED":
      return EventLog_DetailedState.DETAILED_STATE_UNSPECIFIED;
    case 1:
    case "EMERGING":
      return EventLog_DetailedState.EMERGING;
    case 2:
    case "CONFIRMED":
      return EventLog_DetailedState.CONFIRMED;
    case 3:
    case "RESOLVED":
      return EventLog_DetailedState.RESOLVED;
    case 4:
    case "MERGED":
      return EventLog_DetailedState.MERGED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventLog_DetailedState.UNRECOGNIZED;
  }
}

export function eventLog_DetailedStateToJSON(object: EventLog_DetailedState): string {
  switch (object) {
    case EventLog_DetailedState.DETAILED_STATE_UNSPECIFIED:
      return "DETAILED_STATE_UNSPECIFIED";
    case EventLog_DetailedState.EMERGING:
      return "EMERGING";
    case EventLog_DetailedState.CONFIRMED:
      return "CONFIRMED";
    case EventLog_DetailedState.RESOLVED:
      return "RESOLVED";
    case EventLog_DetailedState.MERGED:
      return "MERGED";
    case EventLog_DetailedState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Communicates why a given event is deemed relevant in the context of a given
 * project. This enum lists all possible detailed states of relevance.
 */
export enum EventLog_Relevance {
  /** RELEVANCE_UNSPECIFIED - Unspecified relevance. */
  RELEVANCE_UNSPECIFIED = 0,
  /** UNKNOWN - The relevance of the event to the project is unknown. */
  UNKNOWN = 2,
  /** NOT_IMPACTED - The event does not impact the project. */
  NOT_IMPACTED = 6,
  /**
   * PARTIALLY_RELATED - We determined that the event is linked to a product that is used by
   * the project, but we have no information (either positive
   * or negative) whether the project is affected.
   */
  PARTIALLY_RELATED = 7,
  /** RELATED - The event has a connection to your project and it may be impacted */
  RELATED = 8,
  /** IMPACTED - The event is impacting your project */
  IMPACTED = 9,
  UNRECOGNIZED = -1,
}

export function eventLog_RelevanceFromJSON(object: any): EventLog_Relevance {
  switch (object) {
    case 0:
    case "RELEVANCE_UNSPECIFIED":
      return EventLog_Relevance.RELEVANCE_UNSPECIFIED;
    case 2:
    case "UNKNOWN":
      return EventLog_Relevance.UNKNOWN;
    case 6:
    case "NOT_IMPACTED":
      return EventLog_Relevance.NOT_IMPACTED;
    case 7:
    case "PARTIALLY_RELATED":
      return EventLog_Relevance.PARTIALLY_RELATED;
    case 8:
    case "RELATED":
      return EventLog_Relevance.RELATED;
    case 9:
    case "IMPACTED":
      return EventLog_Relevance.IMPACTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventLog_Relevance.UNRECOGNIZED;
  }
}

export function eventLog_RelevanceToJSON(object: EventLog_Relevance): string {
  switch (object) {
    case EventLog_Relevance.RELEVANCE_UNSPECIFIED:
      return "RELEVANCE_UNSPECIFIED";
    case EventLog_Relevance.UNKNOWN:
      return "UNKNOWN";
    case EventLog_Relevance.NOT_IMPACTED:
      return "NOT_IMPACTED";
    case EventLog_Relevance.PARTIALLY_RELATED:
      return "PARTIALLY_RELATED";
    case EventLog_Relevance.RELATED:
      return "RELATED";
    case EventLog_Relevance.IMPACTED:
      return "IMPACTED";
    case EventLog_Relevance.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseEventLog(): EventLog {
  return {
    title: "",
    description: "",
    category: 0,
    state: 0,
    detailedState: 0,
    impactedProducts: "",
    impactedLocations: "",
    relevance: 0,
    parentEvent: "",
    updateTime: undefined,
    startTime: undefined,
    endTime: undefined,
    nextUpdateTime: undefined,
  };
}

export const EventLog: MessageFns<EventLog> = {
  encode(message: EventLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.category !== 0) {
      writer.uint32(24).int32(message.category);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.detailedState !== 0) {
      writer.uint32(112).int32(message.detailedState);
    }
    if (message.impactedProducts !== "") {
      writer.uint32(122).string(message.impactedProducts);
    }
    if (message.impactedLocations !== "") {
      writer.uint32(50).string(message.impactedLocations);
    }
    if (message.relevance !== 0) {
      writer.uint32(56).int32(message.relevance);
    }
    if (message.parentEvent !== "") {
      writer.uint32(66).string(message.parentEvent);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(90).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(98).fork()).join();
    }
    if (message.nextUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.nextUpdateTime), writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.detailedState = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.impactedProducts = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.impactedLocations = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.relevance = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.parentEvent = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.nextUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventLog {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      category: isSet(object.category) ? eventLog_EventCategoryFromJSON(object.category) : 0,
      state: isSet(object.state) ? eventLog_StateFromJSON(object.state) : 0,
      detailedState: isSet(object.detailedState) ? eventLog_DetailedStateFromJSON(object.detailedState) : 0,
      impactedProducts: isSet(object.impactedProducts) ? globalThis.String(object.impactedProducts) : "",
      impactedLocations: isSet(object.impactedLocations) ? globalThis.String(object.impactedLocations) : "",
      relevance: isSet(object.relevance) ? eventLog_RelevanceFromJSON(object.relevance) : 0,
      parentEvent: isSet(object.parentEvent) ? globalThis.String(object.parentEvent) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      nextUpdateTime: isSet(object.nextUpdateTime) ? fromJsonTimestamp(object.nextUpdateTime) : undefined,
    };
  },

  toJSON(message: EventLog): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.category !== 0) {
      obj.category = eventLog_EventCategoryToJSON(message.category);
    }
    if (message.state !== 0) {
      obj.state = eventLog_StateToJSON(message.state);
    }
    if (message.detailedState !== 0) {
      obj.detailedState = eventLog_DetailedStateToJSON(message.detailedState);
    }
    if (message.impactedProducts !== "") {
      obj.impactedProducts = message.impactedProducts;
    }
    if (message.impactedLocations !== "") {
      obj.impactedLocations = message.impactedLocations;
    }
    if (message.relevance !== 0) {
      obj.relevance = eventLog_RelevanceToJSON(message.relevance);
    }
    if (message.parentEvent !== "") {
      obj.parentEvent = message.parentEvent;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.nextUpdateTime !== undefined) {
      obj.nextUpdateTime = message.nextUpdateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<EventLog>): EventLog {
    return EventLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventLog>): EventLog {
    const message = createBaseEventLog();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.category = object.category ?? 0;
    message.state = object.state ?? 0;
    message.detailedState = object.detailedState ?? 0;
    message.impactedProducts = object.impactedProducts ?? "";
    message.impactedLocations = object.impactedLocations ?? "";
    message.relevance = object.relevance ?? 0;
    message.parentEvent = object.parentEvent ?? "";
    message.updateTime = object.updateTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.nextUpdateTime = object.nextUpdateTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
