// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/shell/v1/cloudshell.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.shell.v1";

/**
 * A Cloud Shell environment, which is defined as the combination of a Docker
 * image specifying what is installed on the environment and a home directory
 * containing the user's data that will remain across sessions. Each user has
 * at least an environment with the ID "default".
 */
export interface Environment {
  /**
   * Immutable. Full name of this resource, in the format
   * `users/{owner_email}/environments/{environment_id}`. `{owner_email}` is the
   * email address of the user to whom this environment belongs, and
   * `{environment_id}` is the identifier of this environment. For example,
   * `users/someone@example.com/environments/default`.
   */
  name: string;
  /**
   * Output only. The environment's identifier, unique among the user's
   * environments.
   */
  id: string;
  /**
   * Required. Immutable. Full path to the Docker image used to run this environment, e.g.
   * "gcr.io/dev-con/cloud-devshell:latest".
   */
  dockerImage: string;
  /** Output only. Current execution state of this environment. */
  state: Environment_State;
  /**
   * Output only. Host to which clients can connect to initiate HTTPS or WSS
   * connections with the environment.
   */
  webHost: string;
  /**
   * Output only. Username that clients should use when initiating SSH sessions
   * with the environment.
   */
  sshUsername: string;
  /**
   * Output only. Host to which clients can connect to initiate SSH sessions
   * with the environment.
   */
  sshHost: string;
  /**
   * Output only. Port to which clients can connect to initiate SSH sessions
   * with the environment.
   */
  sshPort: number;
  /**
   * Output only. Public keys associated with the environment. Clients can
   * connect to this environment via SSH only if they possess a private key
   * corresponding to at least one of these public keys. Keys can be added to or
   * removed from the environment using the AddPublicKey and RemovePublicKey
   * methods.
   */
  publicKeys: string[];
}

/** Possible execution states for an environment. */
export enum Environment_State {
  /** STATE_UNSPECIFIED - The environment's states is unknown. */
  STATE_UNSPECIFIED = 0,
  /**
   * SUSPENDED - The environment is not running and can't be connected to. Starting the
   * environment will transition it to the PENDING state.
   */
  SUSPENDED = 1,
  /**
   * PENDING - The environment is being started but is not yet ready to accept
   * connections.
   */
  PENDING = 2,
  /**
   * RUNNING - The environment is running and ready to accept connections. It will
   * automatically transition back to DISABLED after a period of inactivity or
   * if another environment is started.
   */
  RUNNING = 3,
  /** DELETING - The environment is being deleted and can't be connected to. */
  DELETING = 4,
  UNRECOGNIZED = -1,
}

export function environment_StateFromJSON(object: any): Environment_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Environment_State.STATE_UNSPECIFIED;
    case 1:
    case "SUSPENDED":
      return Environment_State.SUSPENDED;
    case 2:
    case "PENDING":
      return Environment_State.PENDING;
    case 3:
    case "RUNNING":
      return Environment_State.RUNNING;
    case 4:
    case "DELETING":
      return Environment_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Environment_State.UNRECOGNIZED;
  }
}

export function environment_StateToJSON(object: Environment_State): string {
  switch (object) {
    case Environment_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Environment_State.SUSPENDED:
      return "SUSPENDED";
    case Environment_State.PENDING:
      return "PENDING";
    case Environment_State.RUNNING:
      return "RUNNING";
    case Environment_State.DELETING:
      return "DELETING";
    case Environment_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Request message for
 * [GetEnvironment][google.cloud.shell.v1.CloudShellService.GetEnvironment].
 */
export interface GetEnvironmentRequest {
  /**
   * Required. Name of the requested resource, for example `users/me/environments/default`
   * or `users/someone@example.com/environments/default`.
   */
  name: string;
}

/**
 * Message included in the metadata field of operations returned from
 * [CreateEnvironment][google.cloud.shell.v1.CloudShellService.CreateEnvironment].
 */
export interface CreateEnvironmentMetadata {
}

/**
 * Message included in the metadata field of operations returned from
 * [DeleteEnvironment][google.cloud.shell.v1.CloudShellService.DeleteEnvironment].
 */
export interface DeleteEnvironmentMetadata {
}

/**
 * Request message for
 * [StartEnvironment][google.cloud.shell.v1.CloudShellService.StartEnvironment].
 */
export interface StartEnvironmentRequest {
  /**
   * Name of the resource that should be started, for example
   * `users/me/environments/default` or
   * `users/someone@example.com/environments/default`.
   */
  name: string;
  /**
   * The initial access token passed to the environment. If this is present and
   * valid, the environment will be pre-authenticated with gcloud so that the
   * user can run gcloud commands in Cloud Shell without having to log in. This
   * code can be updated later by calling AuthorizeEnvironment.
   */
  accessToken: string;
  /** Public keys that should be added to the environment before it is started. */
  publicKeys: string[];
}

/**
 * Request message for
 * [AuthorizeEnvironment][google.cloud.shell.v1.CloudShellService.AuthorizeEnvironment].
 */
export interface AuthorizeEnvironmentRequest {
  /**
   * Name of the resource that should receive the credentials, for example
   * `users/me/environments/default` or
   * `users/someone@example.com/environments/default`.
   */
  name: string;
  /** The OAuth access token that should be sent to the environment. */
  accessToken: string;
  /** The OAuth ID token that should be sent to the environment. */
  idToken: string;
  /**
   * The time when the credentials expire. If not set, defaults to one hour from
   * when the server received the request.
   */
  expireTime: Date | undefined;
}

/**
 * Response message for
 * [AuthorizeEnvironment][google.cloud.shell.v1.CloudShellService.AuthorizeEnvironment].
 */
export interface AuthorizeEnvironmentResponse {
}

/**
 * Message included in the metadata field of operations returned from
 * [AuthorizeEnvironment][google.cloud.shell.v1.CloudShellService.AuthorizeEnvironment].
 */
export interface AuthorizeEnvironmentMetadata {
}

/**
 * Message included in the metadata field of operations returned from
 * [StartEnvironment][google.cloud.shell.v1.CloudShellService.StartEnvironment].
 */
export interface StartEnvironmentMetadata {
  /** Current state of the environment being started. */
  state: StartEnvironmentMetadata_State;
}

/**
 * Possible states an environment might transition between during startup.
 * These states are not normally actionable by clients, but may be used to
 * show a progress message to the user. An environment won't necessarily go
 * through all of these states when starting. More states are likely to be
 * added in the future.
 */
export enum StartEnvironmentMetadata_State {
  /** STATE_UNSPECIFIED - The environment's start state is unknown. */
  STATE_UNSPECIFIED = 0,
  /**
   * STARTING - The environment is in the process of being started, but no additional
   * details are available.
   */
  STARTING = 1,
  /**
   * UNARCHIVING_DISK - Startup is waiting for the user's disk to be unarchived. This can happen
   * when the user returns to Cloud Shell after not having used it for a
   * while, and suggests that startup will take longer than normal.
   */
  UNARCHIVING_DISK = 2,
  /**
   * AWAITING_COMPUTE_RESOURCES - Startup is waiting for compute resources to be assigned to the
   * environment. This should normally happen very quickly, but an environment
   * might stay in this state for an extended period of time if the system is
   * experiencing heavy load.
   */
  AWAITING_COMPUTE_RESOURCES = 4,
  /**
   * FINISHED - Startup has completed. If the start operation was successful, the user
   * should be able to establish an SSH connection to their environment.
   * Otherwise, the operation will contain details of the failure.
   */
  FINISHED = 3,
  UNRECOGNIZED = -1,
}

export function startEnvironmentMetadata_StateFromJSON(object: any): StartEnvironmentMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return StartEnvironmentMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "STARTING":
      return StartEnvironmentMetadata_State.STARTING;
    case 2:
    case "UNARCHIVING_DISK":
      return StartEnvironmentMetadata_State.UNARCHIVING_DISK;
    case 4:
    case "AWAITING_COMPUTE_RESOURCES":
      return StartEnvironmentMetadata_State.AWAITING_COMPUTE_RESOURCES;
    case 3:
    case "FINISHED":
      return StartEnvironmentMetadata_State.FINISHED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StartEnvironmentMetadata_State.UNRECOGNIZED;
  }
}

export function startEnvironmentMetadata_StateToJSON(object: StartEnvironmentMetadata_State): string {
  switch (object) {
    case StartEnvironmentMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case StartEnvironmentMetadata_State.STARTING:
      return "STARTING";
    case StartEnvironmentMetadata_State.UNARCHIVING_DISK:
      return "UNARCHIVING_DISK";
    case StartEnvironmentMetadata_State.AWAITING_COMPUTE_RESOURCES:
      return "AWAITING_COMPUTE_RESOURCES";
    case StartEnvironmentMetadata_State.FINISHED:
      return "FINISHED";
    case StartEnvironmentMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Message included in the response field of operations returned from
 * [StartEnvironment][google.cloud.shell.v1.CloudShellService.StartEnvironment]
 * once the operation is complete.
 */
export interface StartEnvironmentResponse {
  /** Environment that was started. */
  environment: Environment | undefined;
}

/**
 * Request message for
 * [AddPublicKey][google.cloud.shell.v1.CloudShellService.AddPublicKey].
 */
export interface AddPublicKeyRequest {
  /**
   * Environment this key should be added to, e.g.
   * `users/me/environments/default`.
   */
  environment: string;
  /**
   * Key that should be added to the environment. Supported formats are
   * `ssh-dss` (see RFC4253), `ssh-rsa` (see RFC4253), `ecdsa-sha2-nistp256`
   * (see RFC5656), `ecdsa-sha2-nistp384` (see RFC5656) and
   * `ecdsa-sha2-nistp521` (see RFC5656). It should be structured as
   * &lt;format&gt; &lt;content&gt;, where &lt;content&gt; part is encoded with
   * Base64.
   */
  key: string;
}

/**
 * Response message for
 * [AddPublicKey][google.cloud.shell.v1.CloudShellService.AddPublicKey].
 */
export interface AddPublicKeyResponse {
  /** Key that was added to the environment. */
  key: string;
}

/**
 * Message included in the metadata field of operations returned from
 * [AddPublicKey][google.cloud.shell.v1.CloudShellService.AddPublicKey].
 */
export interface AddPublicKeyMetadata {
}

/**
 * Request message for
 * [RemovePublicKey][google.cloud.shell.v1.CloudShellService.RemovePublicKey].
 */
export interface RemovePublicKeyRequest {
  /**
   * Environment this key should be removed from, e.g.
   * `users/me/environments/default`.
   */
  environment: string;
  /** Key that should be removed from the environment. */
  key: string;
}

/**
 * Response message for
 * [RemovePublicKey][google.cloud.shell.v1.CloudShellService.RemovePublicKey].
 */
export interface RemovePublicKeyResponse {
}

/**
 * Message included in the metadata field of operations returned from
 * [RemovePublicKey][google.cloud.shell.v1.CloudShellService.RemovePublicKey].
 */
export interface RemovePublicKeyMetadata {
}

/**
 * Cloud-shell specific information that will be included as details in failure
 * responses.
 */
export interface CloudShellErrorDetails {
  /** Code indicating the specific error the occurred. */
  code: CloudShellErrorDetails_CloudShellErrorCode;
}

/** Set of possible errors returned from API calls. */
export enum CloudShellErrorDetails_CloudShellErrorCode {
  /** CLOUD_SHELL_ERROR_CODE_UNSPECIFIED - An unknown error occurred. */
  CLOUD_SHELL_ERROR_CODE_UNSPECIFIED = 0,
  /**
   * IMAGE_UNAVAILABLE - The image used by the Cloud Shell environment either does not exist or
   * the user does not have access to it.
   */
  IMAGE_UNAVAILABLE = 1,
  /**
   * CLOUD_SHELL_DISABLED - Cloud Shell has been disabled by an administrator for the user making the
   * request.
   */
  CLOUD_SHELL_DISABLED = 2,
  /**
   * TOS_VIOLATION - Cloud Shell has been permanently disabled due to a Terms of Service
   * violation by the user.
   */
  TOS_VIOLATION = 4,
  /**
   * QUOTA_EXCEEDED - The user has exhausted their weekly Cloud Shell quota, and Cloud Shell
   * will be disabled until the quota resets.
   */
  QUOTA_EXCEEDED = 5,
  /**
   * ENVIRONMENT_UNAVAILABLE - The Cloud Shell environment is unavailable and cannot be connected to at
   * the moment.
   */
  ENVIRONMENT_UNAVAILABLE = 6,
  UNRECOGNIZED = -1,
}

export function cloudShellErrorDetails_CloudShellErrorCodeFromJSON(
  object: any,
): CloudShellErrorDetails_CloudShellErrorCode {
  switch (object) {
    case 0:
    case "CLOUD_SHELL_ERROR_CODE_UNSPECIFIED":
      return CloudShellErrorDetails_CloudShellErrorCode.CLOUD_SHELL_ERROR_CODE_UNSPECIFIED;
    case 1:
    case "IMAGE_UNAVAILABLE":
      return CloudShellErrorDetails_CloudShellErrorCode.IMAGE_UNAVAILABLE;
    case 2:
    case "CLOUD_SHELL_DISABLED":
      return CloudShellErrorDetails_CloudShellErrorCode.CLOUD_SHELL_DISABLED;
    case 4:
    case "TOS_VIOLATION":
      return CloudShellErrorDetails_CloudShellErrorCode.TOS_VIOLATION;
    case 5:
    case "QUOTA_EXCEEDED":
      return CloudShellErrorDetails_CloudShellErrorCode.QUOTA_EXCEEDED;
    case 6:
    case "ENVIRONMENT_UNAVAILABLE":
      return CloudShellErrorDetails_CloudShellErrorCode.ENVIRONMENT_UNAVAILABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CloudShellErrorDetails_CloudShellErrorCode.UNRECOGNIZED;
  }
}

export function cloudShellErrorDetails_CloudShellErrorCodeToJSON(
  object: CloudShellErrorDetails_CloudShellErrorCode,
): string {
  switch (object) {
    case CloudShellErrorDetails_CloudShellErrorCode.CLOUD_SHELL_ERROR_CODE_UNSPECIFIED:
      return "CLOUD_SHELL_ERROR_CODE_UNSPECIFIED";
    case CloudShellErrorDetails_CloudShellErrorCode.IMAGE_UNAVAILABLE:
      return "IMAGE_UNAVAILABLE";
    case CloudShellErrorDetails_CloudShellErrorCode.CLOUD_SHELL_DISABLED:
      return "CLOUD_SHELL_DISABLED";
    case CloudShellErrorDetails_CloudShellErrorCode.TOS_VIOLATION:
      return "TOS_VIOLATION";
    case CloudShellErrorDetails_CloudShellErrorCode.QUOTA_EXCEEDED:
      return "QUOTA_EXCEEDED";
    case CloudShellErrorDetails_CloudShellErrorCode.ENVIRONMENT_UNAVAILABLE:
      return "ENVIRONMENT_UNAVAILABLE";
    case CloudShellErrorDetails_CloudShellErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseEnvironment(): Environment {
  return {
    name: "",
    id: "",
    dockerImage: "",
    state: 0,
    webHost: "",
    sshUsername: "",
    sshHost: "",
    sshPort: 0,
    publicKeys: [],
  };
}

export const Environment: MessageFns<Environment> = {
  encode(message: Environment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.dockerImage !== "") {
      writer.uint32(26).string(message.dockerImage);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.webHost !== "") {
      writer.uint32(98).string(message.webHost);
    }
    if (message.sshUsername !== "") {
      writer.uint32(42).string(message.sshUsername);
    }
    if (message.sshHost !== "") {
      writer.uint32(50).string(message.sshHost);
    }
    if (message.sshPort !== 0) {
      writer.uint32(56).int32(message.sshPort);
    }
    for (const v of message.publicKeys) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dockerImage = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.webHost = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sshUsername = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sshHost = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.sshPort = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.publicKeys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      dockerImage: isSet(object.dockerImage) ? globalThis.String(object.dockerImage) : "",
      state: isSet(object.state) ? environment_StateFromJSON(object.state) : 0,
      webHost: isSet(object.webHost) ? globalThis.String(object.webHost) : "",
      sshUsername: isSet(object.sshUsername) ? globalThis.String(object.sshUsername) : "",
      sshHost: isSet(object.sshHost) ? globalThis.String(object.sshHost) : "",
      sshPort: isSet(object.sshPort) ? globalThis.Number(object.sshPort) : 0,
      publicKeys: globalThis.Array.isArray(object?.publicKeys)
        ? object.publicKeys.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Environment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.dockerImage !== "") {
      obj.dockerImage = message.dockerImage;
    }
    if (message.state !== 0) {
      obj.state = environment_StateToJSON(message.state);
    }
    if (message.webHost !== "") {
      obj.webHost = message.webHost;
    }
    if (message.sshUsername !== "") {
      obj.sshUsername = message.sshUsername;
    }
    if (message.sshHost !== "") {
      obj.sshHost = message.sshHost;
    }
    if (message.sshPort !== 0) {
      obj.sshPort = Math.round(message.sshPort);
    }
    if (message.publicKeys?.length) {
      obj.publicKeys = message.publicKeys;
    }
    return obj;
  },

  create(base?: DeepPartial<Environment>): Environment {
    return Environment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment>): Environment {
    const message = createBaseEnvironment();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.dockerImage = object.dockerImage ?? "";
    message.state = object.state ?? 0;
    message.webHost = object.webHost ?? "";
    message.sshUsername = object.sshUsername ?? "";
    message.sshHost = object.sshHost ?? "";
    message.sshPort = object.sshPort ?? 0;
    message.publicKeys = object.publicKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetEnvironmentRequest(): GetEnvironmentRequest {
  return { name: "" };
}

export const GetEnvironmentRequest: MessageFns<GetEnvironmentRequest> = {
  encode(message: GetEnvironmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEnvironmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEnvironmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEnvironmentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetEnvironmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetEnvironmentRequest>): GetEnvironmentRequest {
    return GetEnvironmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEnvironmentRequest>): GetEnvironmentRequest {
    const message = createBaseGetEnvironmentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateEnvironmentMetadata(): CreateEnvironmentMetadata {
  return {};
}

export const CreateEnvironmentMetadata: MessageFns<CreateEnvironmentMetadata> = {
  encode(_: CreateEnvironmentMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEnvironmentMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEnvironmentMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreateEnvironmentMetadata {
    return {};
  },

  toJSON(_: CreateEnvironmentMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CreateEnvironmentMetadata>): CreateEnvironmentMetadata {
    return CreateEnvironmentMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CreateEnvironmentMetadata>): CreateEnvironmentMetadata {
    const message = createBaseCreateEnvironmentMetadata();
    return message;
  },
};

function createBaseDeleteEnvironmentMetadata(): DeleteEnvironmentMetadata {
  return {};
}

export const DeleteEnvironmentMetadata: MessageFns<DeleteEnvironmentMetadata> = {
  encode(_: DeleteEnvironmentMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEnvironmentMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEnvironmentMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteEnvironmentMetadata {
    return {};
  },

  toJSON(_: DeleteEnvironmentMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DeleteEnvironmentMetadata>): DeleteEnvironmentMetadata {
    return DeleteEnvironmentMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeleteEnvironmentMetadata>): DeleteEnvironmentMetadata {
    const message = createBaseDeleteEnvironmentMetadata();
    return message;
  },
};

function createBaseStartEnvironmentRequest(): StartEnvironmentRequest {
  return { name: "", accessToken: "", publicKeys: [] };
}

export const StartEnvironmentRequest: MessageFns<StartEnvironmentRequest> = {
  encode(message: StartEnvironmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    for (const v of message.publicKeys) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartEnvironmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartEnvironmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKeys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartEnvironmentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      publicKeys: globalThis.Array.isArray(object?.publicKeys)
        ? object.publicKeys.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StartEnvironmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.publicKeys?.length) {
      obj.publicKeys = message.publicKeys;
    }
    return obj;
  },

  create(base?: DeepPartial<StartEnvironmentRequest>): StartEnvironmentRequest {
    return StartEnvironmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartEnvironmentRequest>): StartEnvironmentRequest {
    const message = createBaseStartEnvironmentRequest();
    message.name = object.name ?? "";
    message.accessToken = object.accessToken ?? "";
    message.publicKeys = object.publicKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseAuthorizeEnvironmentRequest(): AuthorizeEnvironmentRequest {
  return { name: "", accessToken: "", idToken: "", expireTime: undefined };
}

export const AuthorizeEnvironmentRequest: MessageFns<AuthorizeEnvironmentRequest> = {
  encode(message: AuthorizeEnvironmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.idToken !== "") {
      writer.uint32(34).string(message.idToken);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizeEnvironmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizeEnvironmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.idToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthorizeEnvironmentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      idToken: isSet(object.idToken) ? globalThis.String(object.idToken) : "",
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
    };
  },

  toJSON(message: AuthorizeEnvironmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.idToken !== "") {
      obj.idToken = message.idToken;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AuthorizeEnvironmentRequest>): AuthorizeEnvironmentRequest {
    return AuthorizeEnvironmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthorizeEnvironmentRequest>): AuthorizeEnvironmentRequest {
    const message = createBaseAuthorizeEnvironmentRequest();
    message.name = object.name ?? "";
    message.accessToken = object.accessToken ?? "";
    message.idToken = object.idToken ?? "";
    message.expireTime = object.expireTime ?? undefined;
    return message;
  },
};

function createBaseAuthorizeEnvironmentResponse(): AuthorizeEnvironmentResponse {
  return {};
}

export const AuthorizeEnvironmentResponse: MessageFns<AuthorizeEnvironmentResponse> = {
  encode(_: AuthorizeEnvironmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizeEnvironmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizeEnvironmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AuthorizeEnvironmentResponse {
    return {};
  },

  toJSON(_: AuthorizeEnvironmentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AuthorizeEnvironmentResponse>): AuthorizeEnvironmentResponse {
    return AuthorizeEnvironmentResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AuthorizeEnvironmentResponse>): AuthorizeEnvironmentResponse {
    const message = createBaseAuthorizeEnvironmentResponse();
    return message;
  },
};

function createBaseAuthorizeEnvironmentMetadata(): AuthorizeEnvironmentMetadata {
  return {};
}

export const AuthorizeEnvironmentMetadata: MessageFns<AuthorizeEnvironmentMetadata> = {
  encode(_: AuthorizeEnvironmentMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizeEnvironmentMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizeEnvironmentMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AuthorizeEnvironmentMetadata {
    return {};
  },

  toJSON(_: AuthorizeEnvironmentMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AuthorizeEnvironmentMetadata>): AuthorizeEnvironmentMetadata {
    return AuthorizeEnvironmentMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AuthorizeEnvironmentMetadata>): AuthorizeEnvironmentMetadata {
    const message = createBaseAuthorizeEnvironmentMetadata();
    return message;
  },
};

function createBaseStartEnvironmentMetadata(): StartEnvironmentMetadata {
  return { state: 0 };
}

export const StartEnvironmentMetadata: MessageFns<StartEnvironmentMetadata> = {
  encode(message: StartEnvironmentMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartEnvironmentMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartEnvironmentMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartEnvironmentMetadata {
    return { state: isSet(object.state) ? startEnvironmentMetadata_StateFromJSON(object.state) : 0 };
  },

  toJSON(message: StartEnvironmentMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = startEnvironmentMetadata_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<StartEnvironmentMetadata>): StartEnvironmentMetadata {
    return StartEnvironmentMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartEnvironmentMetadata>): StartEnvironmentMetadata {
    const message = createBaseStartEnvironmentMetadata();
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseStartEnvironmentResponse(): StartEnvironmentResponse {
  return { environment: undefined };
}

export const StartEnvironmentResponse: MessageFns<StartEnvironmentResponse> = {
  encode(message: StartEnvironmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== undefined) {
      Environment.encode(message.environment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartEnvironmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartEnvironmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.environment = Environment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartEnvironmentResponse {
    return { environment: isSet(object.environment) ? Environment.fromJSON(object.environment) : undefined };
  },

  toJSON(message: StartEnvironmentResponse): unknown {
    const obj: any = {};
    if (message.environment !== undefined) {
      obj.environment = Environment.toJSON(message.environment);
    }
    return obj;
  },

  create(base?: DeepPartial<StartEnvironmentResponse>): StartEnvironmentResponse {
    return StartEnvironmentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartEnvironmentResponse>): StartEnvironmentResponse {
    const message = createBaseStartEnvironmentResponse();
    message.environment = (object.environment !== undefined && object.environment !== null)
      ? Environment.fromPartial(object.environment)
      : undefined;
    return message;
  },
};

function createBaseAddPublicKeyRequest(): AddPublicKeyRequest {
  return { environment: "", key: "" };
}

export const AddPublicKeyRequest: MessageFns<AddPublicKeyRequest> = {
  encode(message: AddPublicKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== "") {
      writer.uint32(10).string(message.environment);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddPublicKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddPublicKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.environment = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddPublicKeyRequest {
    return {
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: AddPublicKeyRequest): unknown {
    const obj: any = {};
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create(base?: DeepPartial<AddPublicKeyRequest>): AddPublicKeyRequest {
    return AddPublicKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddPublicKeyRequest>): AddPublicKeyRequest {
    const message = createBaseAddPublicKeyRequest();
    message.environment = object.environment ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseAddPublicKeyResponse(): AddPublicKeyResponse {
  return { key: "" };
}

export const AddPublicKeyResponse: MessageFns<AddPublicKeyResponse> = {
  encode(message: AddPublicKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddPublicKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddPublicKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddPublicKeyResponse {
    return { key: isSet(object.key) ? globalThis.String(object.key) : "" };
  },

  toJSON(message: AddPublicKeyResponse): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create(base?: DeepPartial<AddPublicKeyResponse>): AddPublicKeyResponse {
    return AddPublicKeyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddPublicKeyResponse>): AddPublicKeyResponse {
    const message = createBaseAddPublicKeyResponse();
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseAddPublicKeyMetadata(): AddPublicKeyMetadata {
  return {};
}

export const AddPublicKeyMetadata: MessageFns<AddPublicKeyMetadata> = {
  encode(_: AddPublicKeyMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddPublicKeyMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddPublicKeyMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AddPublicKeyMetadata {
    return {};
  },

  toJSON(_: AddPublicKeyMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AddPublicKeyMetadata>): AddPublicKeyMetadata {
    return AddPublicKeyMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AddPublicKeyMetadata>): AddPublicKeyMetadata {
    const message = createBaseAddPublicKeyMetadata();
    return message;
  },
};

function createBaseRemovePublicKeyRequest(): RemovePublicKeyRequest {
  return { environment: "", key: "" };
}

export const RemovePublicKeyRequest: MessageFns<RemovePublicKeyRequest> = {
  encode(message: RemovePublicKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.environment !== "") {
      writer.uint32(10).string(message.environment);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemovePublicKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemovePublicKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.environment = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemovePublicKeyRequest {
    return {
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: RemovePublicKeyRequest): unknown {
    const obj: any = {};
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create(base?: DeepPartial<RemovePublicKeyRequest>): RemovePublicKeyRequest {
    return RemovePublicKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemovePublicKeyRequest>): RemovePublicKeyRequest {
    const message = createBaseRemovePublicKeyRequest();
    message.environment = object.environment ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseRemovePublicKeyResponse(): RemovePublicKeyResponse {
  return {};
}

export const RemovePublicKeyResponse: MessageFns<RemovePublicKeyResponse> = {
  encode(_: RemovePublicKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemovePublicKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemovePublicKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemovePublicKeyResponse {
    return {};
  },

  toJSON(_: RemovePublicKeyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RemovePublicKeyResponse>): RemovePublicKeyResponse {
    return RemovePublicKeyResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RemovePublicKeyResponse>): RemovePublicKeyResponse {
    const message = createBaseRemovePublicKeyResponse();
    return message;
  },
};

function createBaseRemovePublicKeyMetadata(): RemovePublicKeyMetadata {
  return {};
}

export const RemovePublicKeyMetadata: MessageFns<RemovePublicKeyMetadata> = {
  encode(_: RemovePublicKeyMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemovePublicKeyMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemovePublicKeyMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemovePublicKeyMetadata {
    return {};
  },

  toJSON(_: RemovePublicKeyMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RemovePublicKeyMetadata>): RemovePublicKeyMetadata {
    return RemovePublicKeyMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RemovePublicKeyMetadata>): RemovePublicKeyMetadata {
    const message = createBaseRemovePublicKeyMetadata();
    return message;
  },
};

function createBaseCloudShellErrorDetails(): CloudShellErrorDetails {
  return { code: 0 };
}

export const CloudShellErrorDetails: MessageFns<CloudShellErrorDetails> = {
  encode(message: CloudShellErrorDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudShellErrorDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudShellErrorDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudShellErrorDetails {
    return { code: isSet(object.code) ? cloudShellErrorDetails_CloudShellErrorCodeFromJSON(object.code) : 0 };
  },

  toJSON(message: CloudShellErrorDetails): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = cloudShellErrorDetails_CloudShellErrorCodeToJSON(message.code);
    }
    return obj;
  },

  create(base?: DeepPartial<CloudShellErrorDetails>): CloudShellErrorDetails {
    return CloudShellErrorDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudShellErrorDetails>): CloudShellErrorDetails {
    const message = createBaseCloudShellErrorDetails();
    message.code = object.code ?? 0;
    return message;
  },
};

/**
 * API for interacting with Google Cloud Shell. Each user of Cloud Shell has at
 * least one environment, which has the ID "default". Environment consists of a
 * Docker image defining what is installed on the environment and a home
 * directory containing the user's data that will remain across sessions.
 * Clients use this API to start and fetch information about their environment,
 * which can then be used to connect to that environment via a separate SSH
 * client.
 */
export type CloudShellServiceDefinition = typeof CloudShellServiceDefinition;
export const CloudShellServiceDefinition = {
  name: "CloudShellService",
  fullName: "google.cloud.shell.v1.CloudShellService",
  methods: {
    /** Gets an environment. Returns NOT_FOUND if the environment does not exist. */
    getEnvironment: {
      name: "GetEnvironment",
      requestType: GetEnvironmentRequest,
      requestStream: false,
      responseType: Environment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              35,
              18,
              33,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              117,
              115,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Starts an existing environment, allowing clients to connect to it. The
     * returned operation will contain an instance of StartEnvironmentMetadata in
     * its metadata field. Users can wait for the environment to start by polling
     * this operation via GetOperation. Once the environment has finished starting
     * and is ready to accept connections, the operation will contain a
     * StartEnvironmentResponse in its response field.
     */
    startEnvironment: {
      name: "StartEnvironment",
      requestType: StartEnvironmentRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              52,
              10,
              24,
              83,
              116,
              97,
              114,
              116,
              69,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              24,
              83,
              116,
              97,
              114,
              116,
              69,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              44,
              58,
              1,
              42,
              34,
              39,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              117,
              115,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              97,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Sends OAuth credentials to a running environment on behalf of a user. When
     * this completes, the environment will be authorized to run various Google
     * Cloud command line tools without requiring the user to manually
     * authenticate.
     */
    authorizeEnvironment: {
      name: "AuthorizeEnvironment",
      requestType: AuthorizeEnvironmentRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              60,
              10,
              28,
              65,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              101,
              69,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              28,
              65,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              101,
              69,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              48,
              58,
              1,
              42,
              34,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              117,
              115,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Adds a public SSH key to an environment, allowing clients with the
     * corresponding private key to connect to that environment via SSH. If a key
     * with the same content already exists, this will error with ALREADY_EXISTS.
     */
    addPublicKey: {
      name: "AddPublicKey",
      requestType: AddPublicKeyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              44,
              10,
              20,
              65,
              100,
              100,
              80,
              117,
              98,
              108,
              105,
              99,
              75,
              101,
              121,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              20,
              65,
              100,
              100,
              80,
              117,
              98,
              108,
              105,
              99,
              75,
              101,
              121,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              58,
              58,
              1,
              42,
              34,
              53,
              47,
              118,
              49,
              47,
              123,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              61,
              117,
              115,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              100,
              100,
              80,
              117,
              98,
              108,
              105,
              99,
              75,
              101,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Removes a public SSH key from an environment. Clients will no longer be
     * able to connect to the environment using the corresponding private key.
     * If a key with the same content is not present, this will error with
     * NOT_FOUND.
     */
    removePublicKey: {
      name: "RemovePublicKey",
      requestType: RemovePublicKeyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              50,
              10,
              23,
              82,
              101,
              109,
              111,
              118,
              101,
              80,
              117,
              98,
              108,
              105,
              99,
              75,
              101,
              121,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              23,
              82,
              101,
              109,
              111,
              118,
              101,
              80,
              117,
              98,
              108,
              105,
              99,
              75,
              101,
              121,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              61,
              58,
              1,
              42,
              34,
              56,
              47,
              118,
              49,
              47,
              123,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              61,
              117,
              115,
              101,
              114,
              115,
              47,
              42,
              47,
              101,
              110,
              118,
              105,
              114,
              111,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              109,
              111,
              118,
              101,
              80,
              117,
              98,
              108,
              105,
              99,
              75,
              101,
              121,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface CloudShellServiceImplementation<CallContextExt = {}> {
  /** Gets an environment. Returns NOT_FOUND if the environment does not exist. */
  getEnvironment(
    request: GetEnvironmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Environment>>;
  /**
   * Starts an existing environment, allowing clients to connect to it. The
   * returned operation will contain an instance of StartEnvironmentMetadata in
   * its metadata field. Users can wait for the environment to start by polling
   * this operation via GetOperation. Once the environment has finished starting
   * and is ready to accept connections, the operation will contain a
   * StartEnvironmentResponse in its response field.
   */
  startEnvironment(
    request: StartEnvironmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Sends OAuth credentials to a running environment on behalf of a user. When
   * this completes, the environment will be authorized to run various Google
   * Cloud command line tools without requiring the user to manually
   * authenticate.
   */
  authorizeEnvironment(
    request: AuthorizeEnvironmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Adds a public SSH key to an environment, allowing clients with the
   * corresponding private key to connect to that environment via SSH. If a key
   * with the same content already exists, this will error with ALREADY_EXISTS.
   */
  addPublicKey(request: AddPublicKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Removes a public SSH key from an environment. Clients will no longer be
   * able to connect to the environment using the corresponding private key.
   * If a key with the same content is not present, this will error with
   * NOT_FOUND.
   */
  removePublicKey(
    request: RemovePublicKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface CloudShellServiceClient<CallOptionsExt = {}> {
  /** Gets an environment. Returns NOT_FOUND if the environment does not exist. */
  getEnvironment(
    request: DeepPartial<GetEnvironmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Environment>;
  /**
   * Starts an existing environment, allowing clients to connect to it. The
   * returned operation will contain an instance of StartEnvironmentMetadata in
   * its metadata field. Users can wait for the environment to start by polling
   * this operation via GetOperation. Once the environment has finished starting
   * and is ready to accept connections, the operation will contain a
   * StartEnvironmentResponse in its response field.
   */
  startEnvironment(
    request: DeepPartial<StartEnvironmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Sends OAuth credentials to a running environment on behalf of a user. When
   * this completes, the environment will be authorized to run various Google
   * Cloud command line tools without requiring the user to manually
   * authenticate.
   */
  authorizeEnvironment(
    request: DeepPartial<AuthorizeEnvironmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Adds a public SSH key to an environment, allowing clients with the
   * corresponding private key to connect to that environment via SSH. If a key
   * with the same content already exists, this will error with ALREADY_EXISTS.
   */
  addPublicKey(request: DeepPartial<AddPublicKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Removes a public SSH key from an environment. Clients will no longer be
   * able to connect to the environment using the corresponding private key.
   * If a key with the same content is not present, this will error with
   * NOT_FOUND.
   */
  removePublicKey(
    request: DeepPartial<RemovePublicKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
