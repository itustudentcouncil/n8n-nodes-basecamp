// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dialogflow/cx/v3beta1/conversation_history.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Duration } from "../../../../protobuf/duration.js";
import { Empty } from "../../../../protobuf/empty.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { Environment } from "./environment.js";
import { Flow } from "./flow.js";
import { Intent } from "./intent.js";
import { Page } from "./page.js";
import { DetectIntentRequest, DetectIntentResponse } from "./session.js";

export const protobufPackage = "google.cloud.dialogflow.cx.v3beta1";

/** The request message for [Conversations.GetConversation][]. */
export interface GetConversationRequest {
  /**
   * Required. The name of the conversation.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/conversations/<Conversation ID>`.
   */
  name: string;
}

/** The request message for [Conversations.DeleteConversation][]. */
export interface DeleteConversationRequest {
  /**
   * Required. The name of the conversation.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/conversations/<Conversation ID>`.
   */
  name: string;
}

/** The request message for [Conversations.ListConversations][]. */
export interface ListConversationsRequest {
  /**
   * Required. The agent to list all conversations for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /**
   * Optional. The filter string. Supports filter by create_time,
   * metrics.has_end_interaction, metrics.has_live_agent_handoff,
   * intents.display_name, pages.display_name and flows.display_name. Timestamps
   * expect an [RFC-3339][https://datatracker.ietf.org/doc/html/rfc3339]
   * formatted string (e.g. 2012-04-21T11:30:00-04:00). UTC offsets are
   * supported. Some examples:
   *   1. By create time:
   *        create_time > "2022-04-21T11:30:00-04:00"
   *   2. By intent display name:
   *        intents.display_name : "billing"
   *   3. By end interaction signal:
   *        metrics.has_end_interaction = true
   */
  filter: string;
  /**
   * Optional. The maximum number of items to return in a single page. By
   * default 100 and at most 1000.
   */
  pageSize: number;
  /** Optional. The next_page_token value returned from a previous list request. */
  pageToken: string;
}

/** The response message for [Conversations.ListConversations][]. */
export interface ListConversationsResponse {
  /**
   * The list of conversations. There will be a maximum number of items returned
   * based on the
   * [page_size][google.cloud.dialogflow.cx.v3beta1.ListConversationsRequest.page_size]
   * field. The returned conversations will be sorted by start_time in
   * descending order (newest conversation first).
   */
  conversations: Conversation[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
}

/** Represents a conversation. */
export interface Conversation {
  /**
   * Identifier. The identifier of the conversation.
   * If conversation ID is reused, interactions happened later than 48 hours of
   * the conversation's create time will be ignored. Format:
   * `projects/<ProjectID>/locations/<Location ID>/agents/<Agent
   * ID>/conversations/<Conversation ID>`
   */
  name: string;
  /** The type of the conversation. */
  type: Conversation_Type;
  /**
   * The language of the conversation, which is the language of the first
   * request in the conversation.
   */
  languageCode: string;
  /**
   * Start time of the conversation, which is the time of the first request of
   * the conversation.
   */
  startTime:
    | Date
    | undefined;
  /** Duration of the conversation. */
  duration:
    | Duration
    | undefined;
  /** Conversation metrics. */
  metrics:
    | Conversation_Metrics
    | undefined;
  /**
   * All the matched [Intent][google.cloud.dialogflow.cx.v3beta1.Intent] in the
   * conversation. Only `name` and `display_name` are filled in this message.
   */
  intents: Intent[];
  /**
   * All the [Flow][google.cloud.dialogflow.cx.v3beta1.Flow] the conversation
   * has went through. Only `name` and `display_name` are filled in this
   * message.
   */
  flows: Flow[];
  /**
   * All the [Page][google.cloud.dialogflow.cx.v3beta1.Page] the conversation
   * has went through. Only `name` and `display_name` are filled in this
   * message.
   */
  pages: Page[];
  /**
   * Interactions of the conversation.
   * Only populated for `GetConversation` and empty for `ListConversations`.
   */
  interactions: Conversation_Interaction[];
  /**
   * Environment of the conversation.
   * Only `name` and `display_name` are filled in this message.
   */
  environment:
    | Environment
    | undefined;
  /** Flow versions used in the conversation. */
  flowVersions: { [key: string]: Long };
}

/** Represents the type of a conversation. */
export enum Conversation_Type {
  /** TYPE_UNSPECIFIED - Not specified. This value should never be used. */
  TYPE_UNSPECIFIED = 0,
  /**
   * AUDIO - Audio conversation. A conversation is classified as an audio conversation
   * if any request has STT input audio or any response has TTS output audio.
   */
  AUDIO = 1,
  /**
   * TEXT - Text conversation. A conversation is classified as a text conversation
   * if any request has text input and no request has STT input audio and no
   * response has TTS output audio.
   */
  TEXT = 2,
  /**
   * UNDETERMINED - Default conversation type for a conversation. A conversation is
   * classified as undetermined if none of the requests contain text or audio
   * input (eg. event or intent input).
   */
  UNDETERMINED = 3,
  UNRECOGNIZED = -1,
}

export function conversation_TypeFromJSON(object: any): Conversation_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Conversation_Type.TYPE_UNSPECIFIED;
    case 1:
    case "AUDIO":
      return Conversation_Type.AUDIO;
    case 2:
    case "TEXT":
      return Conversation_Type.TEXT;
    case 3:
    case "UNDETERMINED":
      return Conversation_Type.UNDETERMINED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Conversation_Type.UNRECOGNIZED;
  }
}

export function conversation_TypeToJSON(object: Conversation_Type): string {
  switch (object) {
    case Conversation_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Conversation_Type.AUDIO:
      return "AUDIO";
    case Conversation_Type.TEXT:
      return "TEXT";
    case Conversation_Type.UNDETERMINED:
      return "UNDETERMINED";
    case Conversation_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents metrics for the conversation. */
export interface Conversation_Metrics {
  /** The number of interactions in the conversation. */
  interactionCount: number;
  /** Duration of all the input's audio in the conversation. */
  inputAudioDuration:
    | Duration
    | undefined;
  /** Duration of all the output's audio in the conversation. */
  outputAudioDuration:
    | Duration
    | undefined;
  /**
   * Maximum latency of the
   * [Webhook][google.cloud.dialogflow.cx.v3beta1.Webhook] calls in the
   * conversation.
   */
  maxWebhookLatency:
    | Duration
    | undefined;
  /**
   * A signal that indicates the interaction with the Dialogflow agent has
   * ended.
   * If any response has the
   * [ResponseMessage.end_interaction][google.cloud.dialogflow.cx.v3beta1.ResponseMessage.end_interaction]
   * signal, this is set to true.
   */
  hasEndInteraction: boolean;
  /**
   * Hands off conversation to a human agent.
   * If any response has the
   * [ResponseMessage.live_agent_handoff][google.cloud.dialogflow.cx.v3beta1.ResponseMessage.live_agent_handoff]signal,
   * this is set to true.
   */
  hasLiveAgentHandoff: boolean;
  /**
   * The average confidence all of the
   * [Match][google.cloud.dialogflow.cx.v3beta1.Match] in the conversation.
   * Values range from 0.0 (completely uncertain) to 1.0 (completely certain).
   */
  averageMatchConfidence: number;
  /** Query input counts. */
  queryInputCount:
    | Conversation_Metrics_QueryInputCount
    | undefined;
  /** Match type counts. */
  matchTypeCount: Conversation_Metrics_MatchTypeCount | undefined;
}

/**
 * Count by types of
 * [QueryInput][google.cloud.dialogflow.cx.v3beta1.QueryInput] of the
 * requests in the conversation.
 */
export interface Conversation_Metrics_QueryInputCount {
  /**
   * The number of [TextInput][google.cloud.dialogflow.cx.v3beta1.TextInput]
   * in the conversation.
   */
  textCount: number;
  /**
   * The number of
   * [IntentInput][google.cloud.dialogflow.cx.v3beta1.IntentInput] in the
   * conversation.
   */
  intentCount: number;
  /**
   * The number of
   * [AudioInput][google.cloud.dialogflow.cx.v3beta1.AudioInput] in the
   * conversation.
   */
  audioCount: number;
  /**
   * The number of
   * [EventInput][google.cloud.dialogflow.cx.v3beta1.EventInput] in the
   * conversation.
   */
  eventCount: number;
  /**
   * The number of [DtmfInput][google.cloud.dialogflow.cx.v3beta1.DtmfInput]
   * in the conversation.
   */
  dtmfCount: number;
}

/**
 * Count by
 * [Match.MatchType][google.cloud.dialogflow.cx.v3beta1.Match.MatchType] of
 * the matches in the conversation.
 */
export interface Conversation_Metrics_MatchTypeCount {
  /**
   * The number of matches with type
   * [Match.MatchType.MATCH_TYPE_UNSPECIFIED][google.cloud.dialogflow.cx.v3beta1.Match.MatchType.MATCH_TYPE_UNSPECIFIED].
   */
  unspecifiedCount: number;
  /**
   * The number of matches with type
   * [Match.MatchType.INTENT][google.cloud.dialogflow.cx.v3beta1.Match.MatchType.INTENT].
   */
  intentCount: number;
  /**
   * The number of matches with type
   * [Match.MatchType.DIRECT_INTENT][google.cloud.dialogflow.cx.v3beta1.Match.MatchType.DIRECT_INTENT].
   */
  directIntentCount: number;
  /**
   * The number of matches with type
   * [Match.MatchType.PARAMETER_FILLING][google.cloud.dialogflow.cx.v3beta1.Match.MatchType.PARAMETER_FILLING].
   */
  parameterFillingCount: number;
  /**
   * The number of matches with type
   * [Match.MatchType.NO_MATCH][google.cloud.dialogflow.cx.v3beta1.Match.MatchType.NO_MATCH].
   */
  noMatchCount: number;
  /**
   * The number of matches with type
   * [Match.MatchType.NO_INPUT][google.cloud.dialogflow.cx.v3beta1.Match.MatchType.NO_INPUT].
   */
  noInputCount: number;
  /**
   * The number of matches with type
   * [Match.MatchType.EVENT][google.cloud.dialogflow.cx.v3beta1.Match.MatchType.EVENT].
   */
  eventCount: number;
}

/**
 * Represents an interaction between an end user and a Dialogflow CX agent
 * using V3 (Streaming)DetectIntent API, or an interaction between an end user
 * and a Dialogflow CX agent using V2 (Streaming)AnalyzeContent API.
 */
export interface Conversation_Interaction {
  /** The request of the interaction. */
  request:
    | DetectIntentRequest
    | undefined;
  /** The final response of the interaction. */
  response:
    | DetectIntentResponse
    | undefined;
  /**
   * The partial responses of the interaction. Empty if there is no partial
   * response in the interaction.
   * See the
   * [partial response
   * documentation][https://cloud.google.com/dialogflow/cx/docs/concept/fulfillment#queue].
   */
  partialResponses: DetectIntentResponse[];
  /** The input text or the transcript of the input audio in the request. */
  requestUtterances: string;
  /**
   * The output text or the transcript of the output audio in the responses.
   * If multiple output messages are returned, they will be concatenated into
   * one.
   */
  responseUtterances: string;
  /** The time that the interaction was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Missing transition predicted for the interaction. This field is set only
   * if the interaction match type was no-match.
   */
  missingTransition: Conversation_Interaction_MissingTransition | undefined;
}

/**
 * Information collected for DF CX agents in case NLU predicted an intent
 * that was filtered out as being inactive which may indicate a missing
 * transition and/or absent functionality.
 */
export interface Conversation_Interaction_MissingTransition {
  /** Name of the intent that could have triggered. */
  intentDisplayName: string;
  /**
   * Score of the above intent. The higher it is the more likely a
   * transition was missed on a given page.
   */
  score: number;
}

export interface Conversation_FlowVersionsEntry {
  key: string;
  value: Long;
}

function createBaseGetConversationRequest(): GetConversationRequest {
  return { name: "" };
}

export const GetConversationRequest: MessageFns<GetConversationRequest> = {
  encode(message: GetConversationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConversationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConversationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetConversationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetConversationRequest>): GetConversationRequest {
    return GetConversationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConversationRequest>): GetConversationRequest {
    const message = createBaseGetConversationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteConversationRequest(): DeleteConversationRequest {
  return { name: "" };
}

export const DeleteConversationRequest: MessageFns<DeleteConversationRequest> = {
  encode(message: DeleteConversationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConversationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConversationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteConversationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteConversationRequest>): DeleteConversationRequest {
    return DeleteConversationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteConversationRequest>): DeleteConversationRequest {
    const message = createBaseDeleteConversationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListConversationsRequest(): ListConversationsRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListConversationsRequest: MessageFns<ListConversationsRequest> = {
  encode(message: ListConversationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConversationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConversationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConversationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListConversationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConversationsRequest>): ListConversationsRequest {
    return ListConversationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConversationsRequest>): ListConversationsRequest {
    const message = createBaseListConversationsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListConversationsResponse(): ListConversationsResponse {
  return { conversations: [], nextPageToken: "" };
}

export const ListConversationsResponse: MessageFns<ListConversationsResponse> = {
  encode(message: ListConversationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conversations) {
      Conversation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConversationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConversationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversations.push(Conversation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConversationsResponse {
    return {
      conversations: globalThis.Array.isArray(object?.conversations)
        ? object.conversations.map((e: any) => Conversation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListConversationsResponse): unknown {
    const obj: any = {};
    if (message.conversations?.length) {
      obj.conversations = message.conversations.map((e) => Conversation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConversationsResponse>): ListConversationsResponse {
    return ListConversationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConversationsResponse>): ListConversationsResponse {
    const message = createBaseListConversationsResponse();
    message.conversations = object.conversations?.map((e) => Conversation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseConversation(): Conversation {
  return {
    name: "",
    type: 0,
    languageCode: "",
    startTime: undefined,
    duration: undefined,
    metrics: undefined,
    intents: [],
    flows: [],
    pages: [],
    interactions: [],
    environment: undefined,
    flowVersions: {},
  };
}

export const Conversation: MessageFns<Conversation> = {
  encode(message: Conversation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.languageCode !== "") {
      writer.uint32(26).string(message.languageCode);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(42).fork()).join();
    }
    if (message.metrics !== undefined) {
      Conversation_Metrics.encode(message.metrics, writer.uint32(50).fork()).join();
    }
    for (const v of message.intents) {
      Intent.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.flows) {
      Flow.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.pages) {
      Page.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.interactions) {
      Conversation_Interaction.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.environment !== undefined) {
      Environment.encode(message.environment, writer.uint32(90).fork()).join();
    }
    Object.entries(message.flowVersions).forEach(([key, value]) => {
      Conversation_FlowVersionsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metrics = Conversation_Metrics.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.intents.push(Intent.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.flows.push(Flow.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.pages.push(Page.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.interactions.push(Conversation_Interaction.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.environment = Environment.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = Conversation_FlowVersionsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.flowVersions[entry12.key] = entry12.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? conversation_TypeFromJSON(object.type) : 0,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      metrics: isSet(object.metrics) ? Conversation_Metrics.fromJSON(object.metrics) : undefined,
      intents: globalThis.Array.isArray(object?.intents) ? object.intents.map((e: any) => Intent.fromJSON(e)) : [],
      flows: globalThis.Array.isArray(object?.flows) ? object.flows.map((e: any) => Flow.fromJSON(e)) : [],
      pages: globalThis.Array.isArray(object?.pages) ? object.pages.map((e: any) => Page.fromJSON(e)) : [],
      interactions: globalThis.Array.isArray(object?.interactions)
        ? object.interactions.map((e: any) => Conversation_Interaction.fromJSON(e))
        : [],
      environment: isSet(object.environment) ? Environment.fromJSON(object.environment) : undefined,
      flowVersions: isObject(object.flowVersions)
        ? Object.entries(object.flowVersions).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Conversation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = conversation_TypeToJSON(message.type);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.metrics !== undefined) {
      obj.metrics = Conversation_Metrics.toJSON(message.metrics);
    }
    if (message.intents?.length) {
      obj.intents = message.intents.map((e) => Intent.toJSON(e));
    }
    if (message.flows?.length) {
      obj.flows = message.flows.map((e) => Flow.toJSON(e));
    }
    if (message.pages?.length) {
      obj.pages = message.pages.map((e) => Page.toJSON(e));
    }
    if (message.interactions?.length) {
      obj.interactions = message.interactions.map((e) => Conversation_Interaction.toJSON(e));
    }
    if (message.environment !== undefined) {
      obj.environment = Environment.toJSON(message.environment);
    }
    if (message.flowVersions) {
      const entries = Object.entries(message.flowVersions);
      if (entries.length > 0) {
        obj.flowVersions = {};
        entries.forEach(([k, v]) => {
          obj.flowVersions[k] = v.toString();
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation>): Conversation {
    return Conversation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation>): Conversation {
    const message = createBaseConversation();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.languageCode = object.languageCode ?? "";
    message.startTime = object.startTime ?? undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? Conversation_Metrics.fromPartial(object.metrics)
      : undefined;
    message.intents = object.intents?.map((e) => Intent.fromPartial(e)) || [];
    message.flows = object.flows?.map((e) => Flow.fromPartial(e)) || [];
    message.pages = object.pages?.map((e) => Page.fromPartial(e)) || [];
    message.interactions = object.interactions?.map((e) => Conversation_Interaction.fromPartial(e)) || [];
    message.environment = (object.environment !== undefined && object.environment !== null)
      ? Environment.fromPartial(object.environment)
      : undefined;
    message.flowVersions = Object.entries(object.flowVersions ?? {}).reduce<{ [key: string]: Long }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Long.fromValue(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseConversation_Metrics(): Conversation_Metrics {
  return {
    interactionCount: 0,
    inputAudioDuration: undefined,
    outputAudioDuration: undefined,
    maxWebhookLatency: undefined,
    hasEndInteraction: false,
    hasLiveAgentHandoff: false,
    averageMatchConfidence: 0,
    queryInputCount: undefined,
    matchTypeCount: undefined,
  };
}

export const Conversation_Metrics: MessageFns<Conversation_Metrics> = {
  encode(message: Conversation_Metrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.interactionCount !== 0) {
      writer.uint32(8).int32(message.interactionCount);
    }
    if (message.inputAudioDuration !== undefined) {
      Duration.encode(message.inputAudioDuration, writer.uint32(18).fork()).join();
    }
    if (message.outputAudioDuration !== undefined) {
      Duration.encode(message.outputAudioDuration, writer.uint32(26).fork()).join();
    }
    if (message.maxWebhookLatency !== undefined) {
      Duration.encode(message.maxWebhookLatency, writer.uint32(34).fork()).join();
    }
    if (message.hasEndInteraction !== false) {
      writer.uint32(40).bool(message.hasEndInteraction);
    }
    if (message.hasLiveAgentHandoff !== false) {
      writer.uint32(48).bool(message.hasLiveAgentHandoff);
    }
    if (message.averageMatchConfidence !== 0) {
      writer.uint32(61).float(message.averageMatchConfidence);
    }
    if (message.queryInputCount !== undefined) {
      Conversation_Metrics_QueryInputCount.encode(message.queryInputCount, writer.uint32(66).fork()).join();
    }
    if (message.matchTypeCount !== undefined) {
      Conversation_Metrics_MatchTypeCount.encode(message.matchTypeCount, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_Metrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_Metrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.interactionCount = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputAudioDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outputAudioDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maxWebhookLatency = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.hasEndInteraction = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.hasLiveAgentHandoff = reader.bool();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.averageMatchConfidence = reader.float();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.queryInputCount = Conversation_Metrics_QueryInputCount.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.matchTypeCount = Conversation_Metrics_MatchTypeCount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_Metrics {
    return {
      interactionCount: isSet(object.interactionCount) ? globalThis.Number(object.interactionCount) : 0,
      inputAudioDuration: isSet(object.inputAudioDuration) ? Duration.fromJSON(object.inputAudioDuration) : undefined,
      outputAudioDuration: isSet(object.outputAudioDuration)
        ? Duration.fromJSON(object.outputAudioDuration)
        : undefined,
      maxWebhookLatency: isSet(object.maxWebhookLatency) ? Duration.fromJSON(object.maxWebhookLatency) : undefined,
      hasEndInteraction: isSet(object.hasEndInteraction) ? globalThis.Boolean(object.hasEndInteraction) : false,
      hasLiveAgentHandoff: isSet(object.hasLiveAgentHandoff) ? globalThis.Boolean(object.hasLiveAgentHandoff) : false,
      averageMatchConfidence: isSet(object.averageMatchConfidence)
        ? globalThis.Number(object.averageMatchConfidence)
        : 0,
      queryInputCount: isSet(object.queryInputCount)
        ? Conversation_Metrics_QueryInputCount.fromJSON(object.queryInputCount)
        : undefined,
      matchTypeCount: isSet(object.matchTypeCount)
        ? Conversation_Metrics_MatchTypeCount.fromJSON(object.matchTypeCount)
        : undefined,
    };
  },

  toJSON(message: Conversation_Metrics): unknown {
    const obj: any = {};
    if (message.interactionCount !== 0) {
      obj.interactionCount = Math.round(message.interactionCount);
    }
    if (message.inputAudioDuration !== undefined) {
      obj.inputAudioDuration = Duration.toJSON(message.inputAudioDuration);
    }
    if (message.outputAudioDuration !== undefined) {
      obj.outputAudioDuration = Duration.toJSON(message.outputAudioDuration);
    }
    if (message.maxWebhookLatency !== undefined) {
      obj.maxWebhookLatency = Duration.toJSON(message.maxWebhookLatency);
    }
    if (message.hasEndInteraction !== false) {
      obj.hasEndInteraction = message.hasEndInteraction;
    }
    if (message.hasLiveAgentHandoff !== false) {
      obj.hasLiveAgentHandoff = message.hasLiveAgentHandoff;
    }
    if (message.averageMatchConfidence !== 0) {
      obj.averageMatchConfidence = message.averageMatchConfidence;
    }
    if (message.queryInputCount !== undefined) {
      obj.queryInputCount = Conversation_Metrics_QueryInputCount.toJSON(message.queryInputCount);
    }
    if (message.matchTypeCount !== undefined) {
      obj.matchTypeCount = Conversation_Metrics_MatchTypeCount.toJSON(message.matchTypeCount);
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation_Metrics>): Conversation_Metrics {
    return Conversation_Metrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation_Metrics>): Conversation_Metrics {
    const message = createBaseConversation_Metrics();
    message.interactionCount = object.interactionCount ?? 0;
    message.inputAudioDuration = (object.inputAudioDuration !== undefined && object.inputAudioDuration !== null)
      ? Duration.fromPartial(object.inputAudioDuration)
      : undefined;
    message.outputAudioDuration = (object.outputAudioDuration !== undefined && object.outputAudioDuration !== null)
      ? Duration.fromPartial(object.outputAudioDuration)
      : undefined;
    message.maxWebhookLatency = (object.maxWebhookLatency !== undefined && object.maxWebhookLatency !== null)
      ? Duration.fromPartial(object.maxWebhookLatency)
      : undefined;
    message.hasEndInteraction = object.hasEndInteraction ?? false;
    message.hasLiveAgentHandoff = object.hasLiveAgentHandoff ?? false;
    message.averageMatchConfidence = object.averageMatchConfidence ?? 0;
    message.queryInputCount = (object.queryInputCount !== undefined && object.queryInputCount !== null)
      ? Conversation_Metrics_QueryInputCount.fromPartial(object.queryInputCount)
      : undefined;
    message.matchTypeCount = (object.matchTypeCount !== undefined && object.matchTypeCount !== null)
      ? Conversation_Metrics_MatchTypeCount.fromPartial(object.matchTypeCount)
      : undefined;
    return message;
  },
};

function createBaseConversation_Metrics_QueryInputCount(): Conversation_Metrics_QueryInputCount {
  return { textCount: 0, intentCount: 0, audioCount: 0, eventCount: 0, dtmfCount: 0 };
}

export const Conversation_Metrics_QueryInputCount: MessageFns<Conversation_Metrics_QueryInputCount> = {
  encode(message: Conversation_Metrics_QueryInputCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textCount !== 0) {
      writer.uint32(8).int32(message.textCount);
    }
    if (message.intentCount !== 0) {
      writer.uint32(16).int32(message.intentCount);
    }
    if (message.audioCount !== 0) {
      writer.uint32(24).int32(message.audioCount);
    }
    if (message.eventCount !== 0) {
      writer.uint32(32).int32(message.eventCount);
    }
    if (message.dtmfCount !== 0) {
      writer.uint32(40).int32(message.dtmfCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_Metrics_QueryInputCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_Metrics_QueryInputCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.textCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intentCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.audioCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.eventCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.dtmfCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_Metrics_QueryInputCount {
    return {
      textCount: isSet(object.textCount) ? globalThis.Number(object.textCount) : 0,
      intentCount: isSet(object.intentCount) ? globalThis.Number(object.intentCount) : 0,
      audioCount: isSet(object.audioCount) ? globalThis.Number(object.audioCount) : 0,
      eventCount: isSet(object.eventCount) ? globalThis.Number(object.eventCount) : 0,
      dtmfCount: isSet(object.dtmfCount) ? globalThis.Number(object.dtmfCount) : 0,
    };
  },

  toJSON(message: Conversation_Metrics_QueryInputCount): unknown {
    const obj: any = {};
    if (message.textCount !== 0) {
      obj.textCount = Math.round(message.textCount);
    }
    if (message.intentCount !== 0) {
      obj.intentCount = Math.round(message.intentCount);
    }
    if (message.audioCount !== 0) {
      obj.audioCount = Math.round(message.audioCount);
    }
    if (message.eventCount !== 0) {
      obj.eventCount = Math.round(message.eventCount);
    }
    if (message.dtmfCount !== 0) {
      obj.dtmfCount = Math.round(message.dtmfCount);
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation_Metrics_QueryInputCount>): Conversation_Metrics_QueryInputCount {
    return Conversation_Metrics_QueryInputCount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation_Metrics_QueryInputCount>): Conversation_Metrics_QueryInputCount {
    const message = createBaseConversation_Metrics_QueryInputCount();
    message.textCount = object.textCount ?? 0;
    message.intentCount = object.intentCount ?? 0;
    message.audioCount = object.audioCount ?? 0;
    message.eventCount = object.eventCount ?? 0;
    message.dtmfCount = object.dtmfCount ?? 0;
    return message;
  },
};

function createBaseConversation_Metrics_MatchTypeCount(): Conversation_Metrics_MatchTypeCount {
  return {
    unspecifiedCount: 0,
    intentCount: 0,
    directIntentCount: 0,
    parameterFillingCount: 0,
    noMatchCount: 0,
    noInputCount: 0,
    eventCount: 0,
  };
}

export const Conversation_Metrics_MatchTypeCount: MessageFns<Conversation_Metrics_MatchTypeCount> = {
  encode(message: Conversation_Metrics_MatchTypeCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unspecifiedCount !== 0) {
      writer.uint32(8).int32(message.unspecifiedCount);
    }
    if (message.intentCount !== 0) {
      writer.uint32(16).int32(message.intentCount);
    }
    if (message.directIntentCount !== 0) {
      writer.uint32(24).int32(message.directIntentCount);
    }
    if (message.parameterFillingCount !== 0) {
      writer.uint32(32).int32(message.parameterFillingCount);
    }
    if (message.noMatchCount !== 0) {
      writer.uint32(40).int32(message.noMatchCount);
    }
    if (message.noInputCount !== 0) {
      writer.uint32(48).int32(message.noInputCount);
    }
    if (message.eventCount !== 0) {
      writer.uint32(56).int32(message.eventCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_Metrics_MatchTypeCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_Metrics_MatchTypeCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.unspecifiedCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intentCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.directIntentCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.parameterFillingCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.noMatchCount = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.noInputCount = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.eventCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_Metrics_MatchTypeCount {
    return {
      unspecifiedCount: isSet(object.unspecifiedCount) ? globalThis.Number(object.unspecifiedCount) : 0,
      intentCount: isSet(object.intentCount) ? globalThis.Number(object.intentCount) : 0,
      directIntentCount: isSet(object.directIntentCount) ? globalThis.Number(object.directIntentCount) : 0,
      parameterFillingCount: isSet(object.parameterFillingCount) ? globalThis.Number(object.parameterFillingCount) : 0,
      noMatchCount: isSet(object.noMatchCount) ? globalThis.Number(object.noMatchCount) : 0,
      noInputCount: isSet(object.noInputCount) ? globalThis.Number(object.noInputCount) : 0,
      eventCount: isSet(object.eventCount) ? globalThis.Number(object.eventCount) : 0,
    };
  },

  toJSON(message: Conversation_Metrics_MatchTypeCount): unknown {
    const obj: any = {};
    if (message.unspecifiedCount !== 0) {
      obj.unspecifiedCount = Math.round(message.unspecifiedCount);
    }
    if (message.intentCount !== 0) {
      obj.intentCount = Math.round(message.intentCount);
    }
    if (message.directIntentCount !== 0) {
      obj.directIntentCount = Math.round(message.directIntentCount);
    }
    if (message.parameterFillingCount !== 0) {
      obj.parameterFillingCount = Math.round(message.parameterFillingCount);
    }
    if (message.noMatchCount !== 0) {
      obj.noMatchCount = Math.round(message.noMatchCount);
    }
    if (message.noInputCount !== 0) {
      obj.noInputCount = Math.round(message.noInputCount);
    }
    if (message.eventCount !== 0) {
      obj.eventCount = Math.round(message.eventCount);
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation_Metrics_MatchTypeCount>): Conversation_Metrics_MatchTypeCount {
    return Conversation_Metrics_MatchTypeCount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation_Metrics_MatchTypeCount>): Conversation_Metrics_MatchTypeCount {
    const message = createBaseConversation_Metrics_MatchTypeCount();
    message.unspecifiedCount = object.unspecifiedCount ?? 0;
    message.intentCount = object.intentCount ?? 0;
    message.directIntentCount = object.directIntentCount ?? 0;
    message.parameterFillingCount = object.parameterFillingCount ?? 0;
    message.noMatchCount = object.noMatchCount ?? 0;
    message.noInputCount = object.noInputCount ?? 0;
    message.eventCount = object.eventCount ?? 0;
    return message;
  },
};

function createBaseConversation_Interaction(): Conversation_Interaction {
  return {
    request: undefined,
    response: undefined,
    partialResponses: [],
    requestUtterances: "",
    responseUtterances: "",
    createTime: undefined,
    missingTransition: undefined,
  };
}

export const Conversation_Interaction: MessageFns<Conversation_Interaction> = {
  encode(message: Conversation_Interaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      DetectIntentRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    if (message.response !== undefined) {
      DetectIntentResponse.encode(message.response, writer.uint32(18).fork()).join();
    }
    for (const v of message.partialResponses) {
      DetectIntentResponse.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.requestUtterances !== "") {
      writer.uint32(34).string(message.requestUtterances);
    }
    if (message.responseUtterances !== "") {
      writer.uint32(42).string(message.responseUtterances);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.missingTransition !== undefined) {
      Conversation_Interaction_MissingTransition.encode(message.missingTransition, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_Interaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_Interaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.request = DetectIntentRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = DetectIntentResponse.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.partialResponses.push(DetectIntentResponse.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestUtterances = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.responseUtterances = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.missingTransition = Conversation_Interaction_MissingTransition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_Interaction {
    return {
      request: isSet(object.request) ? DetectIntentRequest.fromJSON(object.request) : undefined,
      response: isSet(object.response) ? DetectIntentResponse.fromJSON(object.response) : undefined,
      partialResponses: globalThis.Array.isArray(object?.partialResponses)
        ? object.partialResponses.map((e: any) => DetectIntentResponse.fromJSON(e))
        : [],
      requestUtterances: isSet(object.requestUtterances) ? globalThis.String(object.requestUtterances) : "",
      responseUtterances: isSet(object.responseUtterances) ? globalThis.String(object.responseUtterances) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      missingTransition: isSet(object.missingTransition)
        ? Conversation_Interaction_MissingTransition.fromJSON(object.missingTransition)
        : undefined,
    };
  },

  toJSON(message: Conversation_Interaction): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = DetectIntentRequest.toJSON(message.request);
    }
    if (message.response !== undefined) {
      obj.response = DetectIntentResponse.toJSON(message.response);
    }
    if (message.partialResponses?.length) {
      obj.partialResponses = message.partialResponses.map((e) => DetectIntentResponse.toJSON(e));
    }
    if (message.requestUtterances !== "") {
      obj.requestUtterances = message.requestUtterances;
    }
    if (message.responseUtterances !== "") {
      obj.responseUtterances = message.responseUtterances;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.missingTransition !== undefined) {
      obj.missingTransition = Conversation_Interaction_MissingTransition.toJSON(message.missingTransition);
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation_Interaction>): Conversation_Interaction {
    return Conversation_Interaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation_Interaction>): Conversation_Interaction {
    const message = createBaseConversation_Interaction();
    message.request = (object.request !== undefined && object.request !== null)
      ? DetectIntentRequest.fromPartial(object.request)
      : undefined;
    message.response = (object.response !== undefined && object.response !== null)
      ? DetectIntentResponse.fromPartial(object.response)
      : undefined;
    message.partialResponses = object.partialResponses?.map((e) => DetectIntentResponse.fromPartial(e)) || [];
    message.requestUtterances = object.requestUtterances ?? "";
    message.responseUtterances = object.responseUtterances ?? "";
    message.createTime = object.createTime ?? undefined;
    message.missingTransition = (object.missingTransition !== undefined && object.missingTransition !== null)
      ? Conversation_Interaction_MissingTransition.fromPartial(object.missingTransition)
      : undefined;
    return message;
  },
};

function createBaseConversation_Interaction_MissingTransition(): Conversation_Interaction_MissingTransition {
  return { intentDisplayName: "", score: 0 };
}

export const Conversation_Interaction_MissingTransition: MessageFns<Conversation_Interaction_MissingTransition> = {
  encode(message: Conversation_Interaction_MissingTransition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intentDisplayName !== "") {
      writer.uint32(10).string(message.intentDisplayName);
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_Interaction_MissingTransition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_Interaction_MissingTransition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intentDisplayName = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_Interaction_MissingTransition {
    return {
      intentDisplayName: isSet(object.intentDisplayName) ? globalThis.String(object.intentDisplayName) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
    };
  },

  toJSON(message: Conversation_Interaction_MissingTransition): unknown {
    const obj: any = {};
    if (message.intentDisplayName !== "") {
      obj.intentDisplayName = message.intentDisplayName;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation_Interaction_MissingTransition>): Conversation_Interaction_MissingTransition {
    return Conversation_Interaction_MissingTransition.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Conversation_Interaction_MissingTransition>,
  ): Conversation_Interaction_MissingTransition {
    const message = createBaseConversation_Interaction_MissingTransition();
    message.intentDisplayName = object.intentDisplayName ?? "";
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseConversation_FlowVersionsEntry(): Conversation_FlowVersionsEntry {
  return { key: "", value: Long.ZERO };
}

export const Conversation_FlowVersionsEntry: MessageFns<Conversation_FlowVersionsEntry> = {
  encode(message: Conversation_FlowVersionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_FlowVersionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_FlowVersionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_FlowVersionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: Conversation_FlowVersionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation_FlowVersionsEntry>): Conversation_FlowVersionsEntry {
    return Conversation_FlowVersionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation_FlowVersionsEntry>): Conversation_FlowVersionsEntry {
    const message = createBaseConversation_FlowVersionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

/** Service for managing conversation history. */
export type ConversationHistoryDefinition = typeof ConversationHistoryDefinition;
export const ConversationHistoryDefinition = {
  name: "ConversationHistory",
  fullName: "google.cloud.dialogflow.cx.v3beta1.ConversationHistory",
  methods: {
    /** Returns the list of all conversations. */
    listConversations: {
      name: "ListConversations",
      requestType: ListConversationsRequest,
      requestStream: false,
      responseType: ListConversationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              65,
              18,
              63,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves the specified conversation. */
    getConversation: {
      name: "GetConversation",
      requestType: GetConversationRequest,
      requestStream: false,
      responseType: Conversation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              65,
              18,
              63,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified conversation. */
    deleteConversation: {
      name: "DeleteConversation",
      requestType: DeleteConversationRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              65,
              42,
              63,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ConversationHistoryServiceImplementation<CallContextExt = {}> {
  /** Returns the list of all conversations. */
  listConversations(
    request: ListConversationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListConversationsResponse>>;
  /** Retrieves the specified conversation. */
  getConversation(
    request: GetConversationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Conversation>>;
  /** Deletes the specified conversation. */
  deleteConversation(
    request: DeleteConversationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface ConversationHistoryClient<CallOptionsExt = {}> {
  /** Returns the list of all conversations. */
  listConversations(
    request: DeepPartial<ListConversationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListConversationsResponse>;
  /** Retrieves the specified conversation. */
  getConversation(
    request: DeepPartial<GetConversationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Conversation>;
  /** Deletes the specified conversation. */
  deleteConversation(
    request: DeepPartial<DeleteConversationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
