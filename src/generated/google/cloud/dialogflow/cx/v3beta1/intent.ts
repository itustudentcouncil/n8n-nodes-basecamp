// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dialogflow/cx/v3beta1/intent.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../../longrunning/operations.js";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { InlineDestination, InlineSource } from "./inline.js";

export const protobufPackage = "google.cloud.dialogflow.cx.v3beta1";

/**
 * Represents the options for views of an intent.
 * An intent can be a sizable object. Therefore, we provide a resource view that
 * does not return training phrases in the response.
 */
export enum IntentView {
  /** INTENT_VIEW_UNSPECIFIED - Not specified. Treated as INTENT_VIEW_FULL. */
  INTENT_VIEW_UNSPECIFIED = 0,
  /** INTENT_VIEW_PARTIAL - Training phrases field is not populated in the response. */
  INTENT_VIEW_PARTIAL = 1,
  /** INTENT_VIEW_FULL - All fields are populated. */
  INTENT_VIEW_FULL = 2,
  UNRECOGNIZED = -1,
}

export function intentViewFromJSON(object: any): IntentView {
  switch (object) {
    case 0:
    case "INTENT_VIEW_UNSPECIFIED":
      return IntentView.INTENT_VIEW_UNSPECIFIED;
    case 1:
    case "INTENT_VIEW_PARTIAL":
      return IntentView.INTENT_VIEW_PARTIAL;
    case 2:
    case "INTENT_VIEW_FULL":
      return IntentView.INTENT_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IntentView.UNRECOGNIZED;
  }
}

export function intentViewToJSON(object: IntentView): string {
  switch (object) {
    case IntentView.INTENT_VIEW_UNSPECIFIED:
      return "INTENT_VIEW_UNSPECIFIED";
    case IntentView.INTENT_VIEW_PARTIAL:
      return "INTENT_VIEW_PARTIAL";
    case IntentView.INTENT_VIEW_FULL:
      return "INTENT_VIEW_FULL";
    case IntentView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An intent represents a user's intent to interact with a conversational agent.
 *
 * You can provide information for the Dialogflow API to use to match user input
 * to an intent by adding training phrases (i.e., examples of user input) to
 * your intent.
 */
export interface Intent {
  /**
   * The unique identifier of the intent.
   * Required for the
   * [Intents.UpdateIntent][google.cloud.dialogflow.cx.v3beta1.Intents.UpdateIntent]
   * method.
   * [Intents.CreateIntent][google.cloud.dialogflow.cx.v3beta1.Intents.CreateIntent]
   * populates the name automatically.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/intents/<Intent ID>`.
   */
  name: string;
  /** Required. The human-readable name of the intent, unique within the agent. */
  displayName: string;
  /**
   * The collection of training phrases the agent is trained on to identify the
   * intent.
   */
  trainingPhrases: Intent_TrainingPhrase[];
  /** The collection of parameters associated with the intent. */
  parameters: Intent_Parameter[];
  /**
   * The priority of this intent. Higher numbers represent higher
   * priorities.
   *
   * - If the supplied value is unspecified or 0, the service
   *   translates the value to 500,000, which corresponds to the
   *   `Normal` priority in the console.
   * - If the supplied value is negative, the intent is ignored
   *   in runtime detect intent requests.
   */
  priority: number;
  /**
   * Indicates whether this is a fallback intent. Currently only default
   * fallback intent is allowed in the agent, which is added upon agent
   * creation.
   * Adding training phrases to fallback intent is useful in the case of
   * requests that are mistakenly matched, since training phrases assigned to
   * fallback intents act as negative examples that triggers no-match event.
   */
  isFallback: boolean;
  /**
   * The key/value metadata to label an intent. Labels can contain
   * lowercase letters, digits and the symbols '-' and '_'. International
   * characters are allowed, including letters from unicase alphabets. Keys must
   * start with a letter. Keys and values can be no longer than 63 characters
   * and no more than 128 bytes.
   *
   * Prefix "sys-" is reserved for Dialogflow defined labels. Currently allowed
   * Dialogflow defined labels include:
   * * sys-head
   * * sys-contextual
   * The above labels do not require value. "sys-head" means the intent is a
   * head intent. "sys-contextual" means the intent is a contextual intent.
   */
  labels: { [key: string]: string };
  /**
   * Human readable description for better understanding an intent like its
   * scope, content, result etc. Maximum character limit: 140 characters.
   */
  description: string;
}

/** Represents an example that the agent is trained on to identify the intent. */
export interface Intent_TrainingPhrase {
  /** Output only. The unique identifier of the training phrase. */
  id: string;
  /**
   * Required. The ordered list of training phrase parts.
   * The parts are concatenated in order to form the training phrase.
   *
   * Note: The API does not automatically annotate training phrases like the
   * Dialogflow Console does.
   *
   * Note: Do not forget to include whitespace at part boundaries, so the
   * training phrase is well formatted when the parts are concatenated.
   *
   * If the training phrase does not need to be annotated with parameters,
   * you just need a single part with only the
   * [Part.text][google.cloud.dialogflow.cx.v3beta1.Intent.TrainingPhrase.Part.text]
   * field set.
   *
   * If you want to annotate the training phrase, you must create multiple
   * parts, where the fields of each part are populated in one of two ways:
   *
   * -   `Part.text` is set to a part of the phrase that has no parameters.
   * -   `Part.text` is set to a part of the phrase that you want to annotate,
   *     and the `parameter_id` field is set.
   */
  parts: Intent_TrainingPhrase_Part[];
  /** Indicates how many times this example was added to the intent. */
  repeatCount: number;
}

/** Represents a part of a training phrase. */
export interface Intent_TrainingPhrase_Part {
  /** Required. The text for this part. */
  text: string;
  /**
   * The [parameter][google.cloud.dialogflow.cx.v3beta1.Intent.Parameter]
   * used to annotate this part of the training phrase. This field is
   * required for annotated parts of the training phrase.
   */
  parameterId: string;
}

/** Represents an intent parameter. */
export interface Intent_Parameter {
  /**
   * Required. The unique identifier of the parameter. This field
   * is used by [training
   * phrases][google.cloud.dialogflow.cx.v3beta1.Intent.TrainingPhrase] to
   * annotate their
   * [parts][google.cloud.dialogflow.cx.v3beta1.Intent.TrainingPhrase.Part].
   */
  id: string;
  /**
   * Required. The entity type of the parameter.
   * Format: `projects/-/locations/-/agents/-/entityTypes/<System Entity Type
   * ID>` for system entity types (for example,
   * `projects/-/locations/-/agents/-/entityTypes/sys.date`), or
   * `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/entityTypes/<Entity Type ID>` for developer entity types.
   */
  entityType: string;
  /** Indicates whether the parameter represents a list of values. */
  isList: boolean;
  /**
   * Indicates whether the parameter content should be redacted in log. If
   * redaction is enabled, the parameter content will be replaced by parameter
   * name during logging.
   * Note: the parameter content is subject to redaction if either parameter
   * level redaction or [entity type level
   * redaction][google.cloud.dialogflow.cx.v3beta1.EntityType.redact] is
   * enabled.
   */
  redact: boolean;
}

export interface Intent_LabelsEntry {
  key: string;
  value: string;
}

/**
 * The request message for
 * [Intents.ListIntents][google.cloud.dialogflow.cx.v3beta1.Intents.ListIntents].
 */
export interface ListIntentsRequest {
  /**
   * Required. The agent to list all intents for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /**
   * The language to list intents for. The following fields are language
   * dependent:
   *
   * *   `Intent.training_phrases.parts.text`
   *
   * If not specified, the agent's default language is used.
   * [Many
   * languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
   * are supported.
   * Note: languages must be enabled in the agent before they can be used.
   */
  languageCode: string;
  /** The resource view to apply to the returned intent. */
  intentView: IntentView;
  /**
   * The maximum number of items to return in a single page. By default 100 and
   * at most 1000.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous list request. */
  pageToken: string;
}

/**
 * The response message for
 * [Intents.ListIntents][google.cloud.dialogflow.cx.v3beta1.Intents.ListIntents].
 */
export interface ListIntentsResponse {
  /**
   * The list of intents. There will be a maximum number of items returned based
   * on the page_size field in the request.
   */
  intents: Intent[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
}

/**
 * The request message for
 * [Intents.GetIntent][google.cloud.dialogflow.cx.v3beta1.Intents.GetIntent].
 */
export interface GetIntentRequest {
  /**
   * Required. The name of the intent.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/intents/<Intent ID>`.
   */
  name: string;
  /**
   * The language to retrieve the intent for. The following fields are language
   * dependent:
   *
   * *   `Intent.training_phrases.parts.text`
   *
   * If not specified, the agent's default language is used.
   * [Many
   * languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
   * are supported.
   * Note: languages must be enabled in the agent before they can be used.
   */
  languageCode: string;
}

/**
 * The request message for
 * [Intents.CreateIntent][google.cloud.dialogflow.cx.v3beta1.Intents.CreateIntent].
 */
export interface CreateIntentRequest {
  /**
   * Required. The agent to create an intent for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /** Required. The intent to create. */
  intent:
    | Intent
    | undefined;
  /**
   * The language of the following fields in `intent`:
   *
   * *   `Intent.training_phrases.parts.text`
   *
   * If not specified, the agent's default language is used.
   * [Many
   * languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
   * are supported.
   * Note: languages must be enabled in the agent before they can be used.
   */
  languageCode: string;
}

/**
 * The request message for
 * [Intents.UpdateIntent][google.cloud.dialogflow.cx.v3beta1.Intents.UpdateIntent].
 */
export interface UpdateIntentRequest {
  /** Required. The intent to update. */
  intent:
    | Intent
    | undefined;
  /**
   * The language of the following fields in `intent`:
   *
   * *   `Intent.training_phrases.parts.text`
   *
   * If not specified, the agent's default language is used.
   * [Many
   * languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
   * are supported.
   * Note: languages must be enabled in the agent before they can be used.
   */
  languageCode: string;
  /**
   * The mask to control which fields get updated. If the mask is not present,
   * all fields will be updated.
   */
  updateMask: string[] | undefined;
}

/**
 * The request message for
 * [Intents.DeleteIntent][google.cloud.dialogflow.cx.v3beta1.Intents.DeleteIntent].
 */
export interface DeleteIntentRequest {
  /**
   * Required. The name of the intent to delete.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/intents/<Intent ID>`.
   */
  name: string;
}

/**
 * The request message for
 * [Intents.ImportIntents][google.cloud.dialogflow.cx.v3beta1.Intents.ImportIntents].
 */
export interface ImportIntentsRequest {
  /**
   * Required. The agent to import the intents into.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /**
   * The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI
   * to import intents from. The format of this URI must be
   * `gs://<bucket-name>/<object-name>`.
   *
   * Dialogflow performs a read operation for the Cloud Storage object
   * on the caller's behalf, so your request authentication must
   * have read permissions for the object. For more information, see
   * [Dialogflow access
   * control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
   */
  intentsUri?:
    | string
    | undefined;
  /** Uncompressed byte content of intents. */
  intentsContent?:
    | InlineSource
    | undefined;
  /** Merge option for importing intents. If not specified, `REJECT` is assumed. */
  mergeOption: ImportIntentsRequest_MergeOption;
}

/** Merge option when display name conflicts exist during import. */
export enum ImportIntentsRequest_MergeOption {
  /** MERGE_OPTION_UNSPECIFIED - Unspecified. Should not be used. */
  MERGE_OPTION_UNSPECIFIED = 0,
  /**
   * REJECT - DEPRECATED: Please use
   * [REPORT_CONFLICT][ImportIntentsRequest.REPORT_CONFLICT] instead.
   * Fail the request if there are intents whose display names conflict with
   * the display names of intents in the agent.
   *
   * @deprecated
   */
  REJECT = 1,
  /**
   * REPLACE - Replace the original intent in the agent with the new intent when display
   * name conflicts exist.
   */
  REPLACE = 2,
  /**
   * MERGE - Merge the original intent with the new intent when display name conflicts
   * exist.
   */
  MERGE = 3,
  /**
   * RENAME - Create new intents with new display names to differentiate them from the
   * existing intents when display name conflicts exist.
   */
  RENAME = 4,
  /**
   * REPORT_CONFLICT - Report conflict information if display names conflict is detected.
   * Otherwise, import intents.
   */
  REPORT_CONFLICT = 5,
  /**
   * KEEP - Keep the original intent and discard the conflicting new intent when
   * display name conflicts exist.
   */
  KEEP = 6,
  UNRECOGNIZED = -1,
}

export function importIntentsRequest_MergeOptionFromJSON(object: any): ImportIntentsRequest_MergeOption {
  switch (object) {
    case 0:
    case "MERGE_OPTION_UNSPECIFIED":
      return ImportIntentsRequest_MergeOption.MERGE_OPTION_UNSPECIFIED;
    case 1:
    case "REJECT":
      return ImportIntentsRequest_MergeOption.REJECT;
    case 2:
    case "REPLACE":
      return ImportIntentsRequest_MergeOption.REPLACE;
    case 3:
    case "MERGE":
      return ImportIntentsRequest_MergeOption.MERGE;
    case 4:
    case "RENAME":
      return ImportIntentsRequest_MergeOption.RENAME;
    case 5:
    case "REPORT_CONFLICT":
      return ImportIntentsRequest_MergeOption.REPORT_CONFLICT;
    case 6:
    case "KEEP":
      return ImportIntentsRequest_MergeOption.KEEP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImportIntentsRequest_MergeOption.UNRECOGNIZED;
  }
}

export function importIntentsRequest_MergeOptionToJSON(object: ImportIntentsRequest_MergeOption): string {
  switch (object) {
    case ImportIntentsRequest_MergeOption.MERGE_OPTION_UNSPECIFIED:
      return "MERGE_OPTION_UNSPECIFIED";
    case ImportIntentsRequest_MergeOption.REJECT:
      return "REJECT";
    case ImportIntentsRequest_MergeOption.REPLACE:
      return "REPLACE";
    case ImportIntentsRequest_MergeOption.MERGE:
      return "MERGE";
    case ImportIntentsRequest_MergeOption.RENAME:
      return "RENAME";
    case ImportIntentsRequest_MergeOption.REPORT_CONFLICT:
      return "REPORT_CONFLICT";
    case ImportIntentsRequest_MergeOption.KEEP:
      return "KEEP";
    case ImportIntentsRequest_MergeOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The response message for
 * [Intents.ImportIntents][google.cloud.dialogflow.cx.v3beta1.Intents.ImportIntents].
 */
export interface ImportIntentsResponse {
  /**
   * The unique identifier of the imported intents.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/intents/<Intent ID>`.
   */
  intents: string[];
  /**
   * Info which resources have conflicts when
   * [REPORT_CONFLICT][ImportIntentsResponse.REPORT_CONFLICT] merge_option is
   * set in ImportIntentsRequest.
   */
  conflictingResources: ImportIntentsResponse_ConflictingResources | undefined;
}

/**
 * Conflicting resources detected during the import process. Only filled when
 * [REPORT_CONFLICT][ImportIntentsResponse.REPORT_CONFLICT] is set in the
 * request and there are conflicts in the display names.
 */
export interface ImportIntentsResponse_ConflictingResources {
  /** Display names of conflicting intents. */
  intentDisplayNames: string[];
  /** Display names of conflicting entities. */
  entityDisplayNames: string[];
}

/**
 * Metadata returned for the
 * [Intents.ImportIntents][google.cloud.dialogflow.cx.v3beta1.Intents.ImportIntents]
 * long running operation.
 */
export interface ImportIntentsMetadata {
}

/**
 * The request message for
 * [Intents.ExportIntents][google.cloud.dialogflow.cx.v3beta1.Intents.ExportIntents].
 */
export interface ExportIntentsRequest {
  /**
   * Required. The name of the parent agent to export intents.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>`.
   */
  parent: string;
  /**
   * Required. The name of the intents to export.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/intents/<Intent ID>`.
   */
  intents: string[];
  /**
   * Optional. The [Google Cloud
   * Storage](https://cloud.google.com/storage/docs/) URI to export the
   * intents to. The format of this URI must be
   * `gs://<bucket-name>/<object-name>`.
   *
   * Dialogflow performs a write operation for the Cloud Storage object
   * on the caller's behalf, so your request authentication must
   * have write permissions for the object. For more information, see
   * [Dialogflow access
   * control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
   */
  intentsUri?:
    | string
    | undefined;
  /** Optional. The option to return the serialized intents inline. */
  intentsContentInline?:
    | boolean
    | undefined;
  /**
   * Optional. The data format of the exported intents. If not specified, `BLOB`
   * is assumed.
   */
  dataFormat: ExportIntentsRequest_DataFormat;
}

/** Data format of the exported intents. */
export enum ExportIntentsRequest_DataFormat {
  /** DATA_FORMAT_UNSPECIFIED - Unspecified format. Treated as `BLOB`. */
  DATA_FORMAT_UNSPECIFIED = 0,
  /** BLOB - Intents will be exported as raw bytes. */
  BLOB = 1,
  /** JSON - Intents will be exported in JSON format. */
  JSON = 2,
  /** CSV - Intents will be exported in CSV format. */
  CSV = 3,
  UNRECOGNIZED = -1,
}

export function exportIntentsRequest_DataFormatFromJSON(object: any): ExportIntentsRequest_DataFormat {
  switch (object) {
    case 0:
    case "DATA_FORMAT_UNSPECIFIED":
      return ExportIntentsRequest_DataFormat.DATA_FORMAT_UNSPECIFIED;
    case 1:
    case "BLOB":
      return ExportIntentsRequest_DataFormat.BLOB;
    case 2:
    case "JSON":
      return ExportIntentsRequest_DataFormat.JSON;
    case 3:
    case "CSV":
      return ExportIntentsRequest_DataFormat.CSV;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExportIntentsRequest_DataFormat.UNRECOGNIZED;
  }
}

export function exportIntentsRequest_DataFormatToJSON(object: ExportIntentsRequest_DataFormat): string {
  switch (object) {
    case ExportIntentsRequest_DataFormat.DATA_FORMAT_UNSPECIFIED:
      return "DATA_FORMAT_UNSPECIFIED";
    case ExportIntentsRequest_DataFormat.BLOB:
      return "BLOB";
    case ExportIntentsRequest_DataFormat.JSON:
      return "JSON";
    case ExportIntentsRequest_DataFormat.CSV:
      return "CSV";
    case ExportIntentsRequest_DataFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The response message for
 * [Intents.ExportIntents][google.cloud.dialogflow.cx.v3beta1.Intents.ExportIntents].
 */
export interface ExportIntentsResponse {
  /**
   * The URI to a file containing the exported intents. This field is
   * populated only if `intents_uri` is specified in
   * [ExportIntentsRequest][google.cloud.dialogflow.cx.v3beta1.ExportIntentsRequest].
   */
  intentsUri?:
    | string
    | undefined;
  /**
   * Uncompressed byte content for intents. This field is populated only if
   * `intents_content_inline` is set to true in
   * [ExportIntentsRequest][google.cloud.dialogflow.cx.v3beta1.ExportIntentsRequest].
   */
  intentsContent?: InlineDestination | undefined;
}

/**
 * Metadata returned for the
 * [Intents.ExportIntents][google.cloud.dialogflow.cx.v3beta1.Intents.ExportIntents]
 * long running operation.
 */
export interface ExportIntentsMetadata {
}

function createBaseIntent(): Intent {
  return {
    name: "",
    displayName: "",
    trainingPhrases: [],
    parameters: [],
    priority: 0,
    isFallback: false,
    labels: {},
    description: "",
  };
}

export const Intent: MessageFns<Intent> = {
  encode(message: Intent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.trainingPhrases) {
      Intent_TrainingPhrase.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.parameters) {
      Intent_Parameter.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.priority !== 0) {
      writer.uint32(40).int32(message.priority);
    }
    if (message.isFallback !== false) {
      writer.uint32(48).bool(message.isFallback);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Intent_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Intent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.trainingPhrases.push(Intent_TrainingPhrase.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parameters.push(Intent_Parameter.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.priority = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isFallback = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Intent_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intent {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      trainingPhrases: globalThis.Array.isArray(object?.trainingPhrases)
        ? object.trainingPhrases.map((e: any) => Intent_TrainingPhrase.fromJSON(e))
        : [],
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => Intent_Parameter.fromJSON(e))
        : [],
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      isFallback: isSet(object.isFallback) ? globalThis.Boolean(object.isFallback) : false,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Intent): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.trainingPhrases?.length) {
      obj.trainingPhrases = message.trainingPhrases.map((e) => Intent_TrainingPhrase.toJSON(e));
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => Intent_Parameter.toJSON(e));
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.isFallback !== false) {
      obj.isFallback = message.isFallback;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<Intent>): Intent {
    return Intent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Intent>): Intent {
    const message = createBaseIntent();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.trainingPhrases = object.trainingPhrases?.map((e) => Intent_TrainingPhrase.fromPartial(e)) || [];
    message.parameters = object.parameters?.map((e) => Intent_Parameter.fromPartial(e)) || [];
    message.priority = object.priority ?? 0;
    message.isFallback = object.isFallback ?? false;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseIntent_TrainingPhrase(): Intent_TrainingPhrase {
  return { id: "", parts: [], repeatCount: 0 };
}

export const Intent_TrainingPhrase: MessageFns<Intent_TrainingPhrase> = {
  encode(message: Intent_TrainingPhrase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.parts) {
      Intent_TrainingPhrase_Part.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.repeatCount !== 0) {
      writer.uint32(24).int32(message.repeatCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Intent_TrainingPhrase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntent_TrainingPhrase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parts.push(Intent_TrainingPhrase_Part.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.repeatCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intent_TrainingPhrase {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      parts: globalThis.Array.isArray(object?.parts)
        ? object.parts.map((e: any) => Intent_TrainingPhrase_Part.fromJSON(e))
        : [],
      repeatCount: isSet(object.repeatCount) ? globalThis.Number(object.repeatCount) : 0,
    };
  },

  toJSON(message: Intent_TrainingPhrase): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.parts?.length) {
      obj.parts = message.parts.map((e) => Intent_TrainingPhrase_Part.toJSON(e));
    }
    if (message.repeatCount !== 0) {
      obj.repeatCount = Math.round(message.repeatCount);
    }
    return obj;
  },

  create(base?: DeepPartial<Intent_TrainingPhrase>): Intent_TrainingPhrase {
    return Intent_TrainingPhrase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Intent_TrainingPhrase>): Intent_TrainingPhrase {
    const message = createBaseIntent_TrainingPhrase();
    message.id = object.id ?? "";
    message.parts = object.parts?.map((e) => Intent_TrainingPhrase_Part.fromPartial(e)) || [];
    message.repeatCount = object.repeatCount ?? 0;
    return message;
  },
};

function createBaseIntent_TrainingPhrase_Part(): Intent_TrainingPhrase_Part {
  return { text: "", parameterId: "" };
}

export const Intent_TrainingPhrase_Part: MessageFns<Intent_TrainingPhrase_Part> = {
  encode(message: Intent_TrainingPhrase_Part, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.parameterId !== "") {
      writer.uint32(18).string(message.parameterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Intent_TrainingPhrase_Part {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntent_TrainingPhrase_Part();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameterId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intent_TrainingPhrase_Part {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      parameterId: isSet(object.parameterId) ? globalThis.String(object.parameterId) : "",
    };
  },

  toJSON(message: Intent_TrainingPhrase_Part): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.parameterId !== "") {
      obj.parameterId = message.parameterId;
    }
    return obj;
  },

  create(base?: DeepPartial<Intent_TrainingPhrase_Part>): Intent_TrainingPhrase_Part {
    return Intent_TrainingPhrase_Part.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Intent_TrainingPhrase_Part>): Intent_TrainingPhrase_Part {
    const message = createBaseIntent_TrainingPhrase_Part();
    message.text = object.text ?? "";
    message.parameterId = object.parameterId ?? "";
    return message;
  },
};

function createBaseIntent_Parameter(): Intent_Parameter {
  return { id: "", entityType: "", isList: false, redact: false };
}

export const Intent_Parameter: MessageFns<Intent_Parameter> = {
  encode(message: Intent_Parameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.entityType !== "") {
      writer.uint32(18).string(message.entityType);
    }
    if (message.isList !== false) {
      writer.uint32(24).bool(message.isList);
    }
    if (message.redact !== false) {
      writer.uint32(32).bool(message.redact);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Intent_Parameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntent_Parameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isList = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.redact = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intent_Parameter {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      isList: isSet(object.isList) ? globalThis.Boolean(object.isList) : false,
      redact: isSet(object.redact) ? globalThis.Boolean(object.redact) : false,
    };
  },

  toJSON(message: Intent_Parameter): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.isList !== false) {
      obj.isList = message.isList;
    }
    if (message.redact !== false) {
      obj.redact = message.redact;
    }
    return obj;
  },

  create(base?: DeepPartial<Intent_Parameter>): Intent_Parameter {
    return Intent_Parameter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Intent_Parameter>): Intent_Parameter {
    const message = createBaseIntent_Parameter();
    message.id = object.id ?? "";
    message.entityType = object.entityType ?? "";
    message.isList = object.isList ?? false;
    message.redact = object.redact ?? false;
    return message;
  },
};

function createBaseIntent_LabelsEntry(): Intent_LabelsEntry {
  return { key: "", value: "" };
}

export const Intent_LabelsEntry: MessageFns<Intent_LabelsEntry> = {
  encode(message: Intent_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Intent_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntent_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intent_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Intent_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Intent_LabelsEntry>): Intent_LabelsEntry {
    return Intent_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Intent_LabelsEntry>): Intent_LabelsEntry {
    const message = createBaseIntent_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListIntentsRequest(): ListIntentsRequest {
  return { parent: "", languageCode: "", intentView: 0, pageSize: 0, pageToken: "" };
}

export const ListIntentsRequest: MessageFns<ListIntentsRequest> = {
  encode(message: ListIntentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    if (message.intentView !== 0) {
      writer.uint32(40).int32(message.intentView);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIntentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIntentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.intentView = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIntentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      intentView: isSet(object.intentView) ? intentViewFromJSON(object.intentView) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListIntentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.intentView !== 0) {
      obj.intentView = intentViewToJSON(message.intentView);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIntentsRequest>): ListIntentsRequest {
    return ListIntentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIntentsRequest>): ListIntentsRequest {
    const message = createBaseListIntentsRequest();
    message.parent = object.parent ?? "";
    message.languageCode = object.languageCode ?? "";
    message.intentView = object.intentView ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListIntentsResponse(): ListIntentsResponse {
  return { intents: [], nextPageToken: "" };
}

export const ListIntentsResponse: MessageFns<ListIntentsResponse> = {
  encode(message: ListIntentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.intents) {
      Intent.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIntentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIntentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intents.push(Intent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIntentsResponse {
    return {
      intents: globalThis.Array.isArray(object?.intents) ? object.intents.map((e: any) => Intent.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListIntentsResponse): unknown {
    const obj: any = {};
    if (message.intents?.length) {
      obj.intents = message.intents.map((e) => Intent.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIntentsResponse>): ListIntentsResponse {
    return ListIntentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIntentsResponse>): ListIntentsResponse {
    const message = createBaseListIntentsResponse();
    message.intents = object.intents?.map((e) => Intent.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetIntentRequest(): GetIntentRequest {
  return { name: "", languageCode: "" };
}

export const GetIntentRequest: MessageFns<GetIntentRequest> = {
  encode(message: GetIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIntentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: GetIntentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<GetIntentRequest>): GetIntentRequest {
    return GetIntentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetIntentRequest>): GetIntentRequest {
    const message = createBaseGetIntentRequest();
    message.name = object.name ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseCreateIntentRequest(): CreateIntentRequest {
  return { parent: "", intent: undefined, languageCode: "" };
}

export const CreateIntentRequest: MessageFns<CreateIntentRequest> = {
  encode(message: CreateIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.intent !== undefined) {
      Intent.encode(message.intent, writer.uint32(18).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(26).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.intent = Intent.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIntentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      intent: isSet(object.intent) ? Intent.fromJSON(object.intent) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: CreateIntentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.intent !== undefined) {
      obj.intent = Intent.toJSON(message.intent);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateIntentRequest>): CreateIntentRequest {
    return CreateIntentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateIntentRequest>): CreateIntentRequest {
    const message = createBaseCreateIntentRequest();
    message.parent = object.parent ?? "";
    message.intent = (object.intent !== undefined && object.intent !== null)
      ? Intent.fromPartial(object.intent)
      : undefined;
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseUpdateIntentRequest(): UpdateIntentRequest {
  return { intent: undefined, languageCode: "", updateMask: undefined };
}

export const UpdateIntentRequest: MessageFns<UpdateIntentRequest> = {
  encode(message: UpdateIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intent !== undefined) {
      Intent.encode(message.intent, writer.uint32(10).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intent = Intent.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateIntentRequest {
    return {
      intent: isSet(object.intent) ? Intent.fromJSON(object.intent) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateIntentRequest): unknown {
    const obj: any = {};
    if (message.intent !== undefined) {
      obj.intent = Intent.toJSON(message.intent);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateIntentRequest>): UpdateIntentRequest {
    return UpdateIntentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateIntentRequest>): UpdateIntentRequest {
    const message = createBaseUpdateIntentRequest();
    message.intent = (object.intent !== undefined && object.intent !== null)
      ? Intent.fromPartial(object.intent)
      : undefined;
    message.languageCode = object.languageCode ?? "";
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteIntentRequest(): DeleteIntentRequest {
  return { name: "" };
}

export const DeleteIntentRequest: MessageFns<DeleteIntentRequest> = {
  encode(message: DeleteIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteIntentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteIntentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteIntentRequest>): DeleteIntentRequest {
    return DeleteIntentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteIntentRequest>): DeleteIntentRequest {
    const message = createBaseDeleteIntentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseImportIntentsRequest(): ImportIntentsRequest {
  return { parent: "", intentsUri: undefined, intentsContent: undefined, mergeOption: 0 };
}

export const ImportIntentsRequest: MessageFns<ImportIntentsRequest> = {
  encode(message: ImportIntentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.intentsUri !== undefined) {
      writer.uint32(18).string(message.intentsUri);
    }
    if (message.intentsContent !== undefined) {
      InlineSource.encode(message.intentsContent, writer.uint32(26).fork()).join();
    }
    if (message.mergeOption !== 0) {
      writer.uint32(32).int32(message.mergeOption);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportIntentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportIntentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.intentsUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.intentsContent = InlineSource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.mergeOption = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportIntentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      intentsUri: isSet(object.intentsUri) ? globalThis.String(object.intentsUri) : undefined,
      intentsContent: isSet(object.intentsContent) ? InlineSource.fromJSON(object.intentsContent) : undefined,
      mergeOption: isSet(object.mergeOption) ? importIntentsRequest_MergeOptionFromJSON(object.mergeOption) : 0,
    };
  },

  toJSON(message: ImportIntentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.intentsUri !== undefined) {
      obj.intentsUri = message.intentsUri;
    }
    if (message.intentsContent !== undefined) {
      obj.intentsContent = InlineSource.toJSON(message.intentsContent);
    }
    if (message.mergeOption !== 0) {
      obj.mergeOption = importIntentsRequest_MergeOptionToJSON(message.mergeOption);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportIntentsRequest>): ImportIntentsRequest {
    return ImportIntentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportIntentsRequest>): ImportIntentsRequest {
    const message = createBaseImportIntentsRequest();
    message.parent = object.parent ?? "";
    message.intentsUri = object.intentsUri ?? undefined;
    message.intentsContent = (object.intentsContent !== undefined && object.intentsContent !== null)
      ? InlineSource.fromPartial(object.intentsContent)
      : undefined;
    message.mergeOption = object.mergeOption ?? 0;
    return message;
  },
};

function createBaseImportIntentsResponse(): ImportIntentsResponse {
  return { intents: [], conflictingResources: undefined };
}

export const ImportIntentsResponse: MessageFns<ImportIntentsResponse> = {
  encode(message: ImportIntentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.intents) {
      writer.uint32(10).string(v!);
    }
    if (message.conflictingResources !== undefined) {
      ImportIntentsResponse_ConflictingResources.encode(message.conflictingResources, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportIntentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportIntentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intents.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conflictingResources = ImportIntentsResponse_ConflictingResources.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportIntentsResponse {
    return {
      intents: globalThis.Array.isArray(object?.intents) ? object.intents.map((e: any) => globalThis.String(e)) : [],
      conflictingResources: isSet(object.conflictingResources)
        ? ImportIntentsResponse_ConflictingResources.fromJSON(object.conflictingResources)
        : undefined,
    };
  },

  toJSON(message: ImportIntentsResponse): unknown {
    const obj: any = {};
    if (message.intents?.length) {
      obj.intents = message.intents;
    }
    if (message.conflictingResources !== undefined) {
      obj.conflictingResources = ImportIntentsResponse_ConflictingResources.toJSON(message.conflictingResources);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportIntentsResponse>): ImportIntentsResponse {
    return ImportIntentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportIntentsResponse>): ImportIntentsResponse {
    const message = createBaseImportIntentsResponse();
    message.intents = object.intents?.map((e) => e) || [];
    message.conflictingResources = (object.conflictingResources !== undefined && object.conflictingResources !== null)
      ? ImportIntentsResponse_ConflictingResources.fromPartial(object.conflictingResources)
      : undefined;
    return message;
  },
};

function createBaseImportIntentsResponse_ConflictingResources(): ImportIntentsResponse_ConflictingResources {
  return { intentDisplayNames: [], entityDisplayNames: [] };
}

export const ImportIntentsResponse_ConflictingResources: MessageFns<ImportIntentsResponse_ConflictingResources> = {
  encode(message: ImportIntentsResponse_ConflictingResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.intentDisplayNames) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.entityDisplayNames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportIntentsResponse_ConflictingResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportIntentsResponse_ConflictingResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intentDisplayNames.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityDisplayNames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportIntentsResponse_ConflictingResources {
    return {
      intentDisplayNames: globalThis.Array.isArray(object?.intentDisplayNames)
        ? object.intentDisplayNames.map((e: any) => globalThis.String(e))
        : [],
      entityDisplayNames: globalThis.Array.isArray(object?.entityDisplayNames)
        ? object.entityDisplayNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ImportIntentsResponse_ConflictingResources): unknown {
    const obj: any = {};
    if (message.intentDisplayNames?.length) {
      obj.intentDisplayNames = message.intentDisplayNames;
    }
    if (message.entityDisplayNames?.length) {
      obj.entityDisplayNames = message.entityDisplayNames;
    }
    return obj;
  },

  create(base?: DeepPartial<ImportIntentsResponse_ConflictingResources>): ImportIntentsResponse_ConflictingResources {
    return ImportIntentsResponse_ConflictingResources.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ImportIntentsResponse_ConflictingResources>,
  ): ImportIntentsResponse_ConflictingResources {
    const message = createBaseImportIntentsResponse_ConflictingResources();
    message.intentDisplayNames = object.intentDisplayNames?.map((e) => e) || [];
    message.entityDisplayNames = object.entityDisplayNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseImportIntentsMetadata(): ImportIntentsMetadata {
  return {};
}

export const ImportIntentsMetadata: MessageFns<ImportIntentsMetadata> = {
  encode(_: ImportIntentsMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportIntentsMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportIntentsMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ImportIntentsMetadata {
    return {};
  },

  toJSON(_: ImportIntentsMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ImportIntentsMetadata>): ImportIntentsMetadata {
    return ImportIntentsMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ImportIntentsMetadata>): ImportIntentsMetadata {
    const message = createBaseImportIntentsMetadata();
    return message;
  },
};

function createBaseExportIntentsRequest(): ExportIntentsRequest {
  return { parent: "", intents: [], intentsUri: undefined, intentsContentInline: undefined, dataFormat: 0 };
}

export const ExportIntentsRequest: MessageFns<ExportIntentsRequest> = {
  encode(message: ExportIntentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.intents) {
      writer.uint32(18).string(v!);
    }
    if (message.intentsUri !== undefined) {
      writer.uint32(26).string(message.intentsUri);
    }
    if (message.intentsContentInline !== undefined) {
      writer.uint32(32).bool(message.intentsContentInline);
    }
    if (message.dataFormat !== 0) {
      writer.uint32(40).int32(message.dataFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportIntentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportIntentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.intents.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.intentsUri = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.intentsContentInline = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.dataFormat = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportIntentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      intents: globalThis.Array.isArray(object?.intents) ? object.intents.map((e: any) => globalThis.String(e)) : [],
      intentsUri: isSet(object.intentsUri) ? globalThis.String(object.intentsUri) : undefined,
      intentsContentInline: isSet(object.intentsContentInline)
        ? globalThis.Boolean(object.intentsContentInline)
        : undefined,
      dataFormat: isSet(object.dataFormat) ? exportIntentsRequest_DataFormatFromJSON(object.dataFormat) : 0,
    };
  },

  toJSON(message: ExportIntentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.intents?.length) {
      obj.intents = message.intents;
    }
    if (message.intentsUri !== undefined) {
      obj.intentsUri = message.intentsUri;
    }
    if (message.intentsContentInline !== undefined) {
      obj.intentsContentInline = message.intentsContentInline;
    }
    if (message.dataFormat !== 0) {
      obj.dataFormat = exportIntentsRequest_DataFormatToJSON(message.dataFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportIntentsRequest>): ExportIntentsRequest {
    return ExportIntentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportIntentsRequest>): ExportIntentsRequest {
    const message = createBaseExportIntentsRequest();
    message.parent = object.parent ?? "";
    message.intents = object.intents?.map((e) => e) || [];
    message.intentsUri = object.intentsUri ?? undefined;
    message.intentsContentInline = object.intentsContentInline ?? undefined;
    message.dataFormat = object.dataFormat ?? 0;
    return message;
  },
};

function createBaseExportIntentsResponse(): ExportIntentsResponse {
  return { intentsUri: undefined, intentsContent: undefined };
}

export const ExportIntentsResponse: MessageFns<ExportIntentsResponse> = {
  encode(message: ExportIntentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intentsUri !== undefined) {
      writer.uint32(10).string(message.intentsUri);
    }
    if (message.intentsContent !== undefined) {
      InlineDestination.encode(message.intentsContent, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportIntentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportIntentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intentsUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.intentsContent = InlineDestination.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportIntentsResponse {
    return {
      intentsUri: isSet(object.intentsUri) ? globalThis.String(object.intentsUri) : undefined,
      intentsContent: isSet(object.intentsContent) ? InlineDestination.fromJSON(object.intentsContent) : undefined,
    };
  },

  toJSON(message: ExportIntentsResponse): unknown {
    const obj: any = {};
    if (message.intentsUri !== undefined) {
      obj.intentsUri = message.intentsUri;
    }
    if (message.intentsContent !== undefined) {
      obj.intentsContent = InlineDestination.toJSON(message.intentsContent);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportIntentsResponse>): ExportIntentsResponse {
    return ExportIntentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportIntentsResponse>): ExportIntentsResponse {
    const message = createBaseExportIntentsResponse();
    message.intentsUri = object.intentsUri ?? undefined;
    message.intentsContent = (object.intentsContent !== undefined && object.intentsContent !== null)
      ? InlineDestination.fromPartial(object.intentsContent)
      : undefined;
    return message;
  },
};

function createBaseExportIntentsMetadata(): ExportIntentsMetadata {
  return {};
}

export const ExportIntentsMetadata: MessageFns<ExportIntentsMetadata> = {
  encode(_: ExportIntentsMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportIntentsMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportIntentsMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ExportIntentsMetadata {
    return {};
  },

  toJSON(_: ExportIntentsMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ExportIntentsMetadata>): ExportIntentsMetadata {
    return ExportIntentsMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ExportIntentsMetadata>): ExportIntentsMetadata {
    const message = createBaseExportIntentsMetadata();
    return message;
  },
};

/** Service for managing [Intents][google.cloud.dialogflow.cx.v3beta1.Intent]. */
export type IntentsDefinition = typeof IntentsDefinition;
export const IntentsDefinition = {
  name: "Intents",
  fullName: "google.cloud.dialogflow.cx.v3beta1.Intents",
  methods: {
    /** Returns the list of all intents in the specified agent. */
    listIntents: {
      name: "ListIntents",
      requestType: ListIntentsRequest,
      requestStream: false,
      responseType: ListIntentsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              116,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves the specified intent. */
    getIntent: {
      name: "GetIntent",
      requestType: GetIntentRequest,
      requestStream: false,
      responseType: Intent,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              116,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates an intent in the specified agent.
     *
     * Note: You should always train a flow prior to sending it queries. See the
     * [training
     * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
     */
    createIntent: {
      name: "CreateIntent",
      requestType: CreateIntentRequest,
      requestStream: false,
      responseType: Intent,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([13, 112, 97, 114, 101, 110, 116, 44, 105, 110, 116, 101, 110, 116])],
          578365826: [
            Buffer.from([
              67,
              58,
              6,
              105,
              110,
              116,
              101,
              110,
              116,
              34,
              57,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              116,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the specified intent.
     *
     * Note: You should always train a flow prior to sending it queries. See the
     * [training
     * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
     */
    updateIntent: {
      name: "UpdateIntent",
      requestType: UpdateIntentRequest,
      requestStream: false,
      responseType: Intent,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 105, 110, 116, 101, 110, 116, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              74,
              58,
              6,
              105,
              110,
              116,
              101,
              110,
              116,
              50,
              64,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              105,
              110,
              116,
              101,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              116,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the specified intent.
     *
     * Note: You should always train a flow prior to sending it queries. See the
     * [training
     * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
     */
    deleteIntent: {
      name: "DeleteIntent",
      requestType: DeleteIntentRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              42,
              57,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              105,
              110,
              116,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Imports the specified intents into the agent.
     *
     * This method is a [long-running
     * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
     * The returned `Operation` type has the following method-specific fields:
     *
     * - `metadata`:
     * [ImportIntentsMetadata][google.cloud.dialogflow.cx.v3beta1.ImportIntentsMetadata]
     * - `response`:
     * [ImportIntentsResponse][google.cloud.dialogflow.cx.v3beta1.ImportIntentsResponse]
     */
    importIntents: {
      name: "ImportIntents",
      requestType: ImportIntentsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              46,
              10,
              21,
              73,
              109,
              112,
              111,
              114,
              116,
              73,
              110,
              116,
              101,
              110,
              116,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              21,
              73,
              109,
              112,
              111,
              114,
              116,
              73,
              110,
              116,
              101,
              110,
              116,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              116,
              101,
              110,
              116,
              115,
              58,
              105,
              109,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Exports the selected intents.
     *
     * This method is a [long-running
     * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
     * The returned `Operation` type has the following method-specific fields:
     *
     * - `metadata`:
     * [ExportIntentsMetadata][google.cloud.dialogflow.cx.v3beta1.ExportIntentsMetadata]
     * - `response`:
     * [ExportIntentsResponse][google.cloud.dialogflow.cx.v3beta1.ExportIntentsResponse]
     */
    exportIntents: {
      name: "ExportIntents",
      requestType: ExportIntentsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              46,
              10,
              21,
              69,
              120,
              112,
              111,
              114,
              116,
              73,
              110,
              116,
              101,
              110,
              116,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              21,
              69,
              120,
              112,
              111,
              114,
              116,
              73,
              110,
              116,
              101,
              110,
              116,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              116,
              101,
              110,
              116,
              115,
              58,
              101,
              120,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface IntentsServiceImplementation<CallContextExt = {}> {
  /** Returns the list of all intents in the specified agent. */
  listIntents(
    request: ListIntentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListIntentsResponse>>;
  /** Retrieves the specified intent. */
  getIntent(request: GetIntentRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Intent>>;
  /**
   * Creates an intent in the specified agent.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  createIntent(request: CreateIntentRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Intent>>;
  /**
   * Updates the specified intent.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  updateIntent(request: UpdateIntentRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Intent>>;
  /**
   * Deletes the specified intent.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  deleteIntent(request: DeleteIntentRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Imports the specified intents into the agent.
   *
   * This method is a [long-running
   * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
   * The returned `Operation` type has the following method-specific fields:
   *
   * - `metadata`:
   * [ImportIntentsMetadata][google.cloud.dialogflow.cx.v3beta1.ImportIntentsMetadata]
   * - `response`:
   * [ImportIntentsResponse][google.cloud.dialogflow.cx.v3beta1.ImportIntentsResponse]
   */
  importIntents(request: ImportIntentsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Exports the selected intents.
   *
   * This method is a [long-running
   * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
   * The returned `Operation` type has the following method-specific fields:
   *
   * - `metadata`:
   * [ExportIntentsMetadata][google.cloud.dialogflow.cx.v3beta1.ExportIntentsMetadata]
   * - `response`:
   * [ExportIntentsResponse][google.cloud.dialogflow.cx.v3beta1.ExportIntentsResponse]
   */
  exportIntents(request: ExportIntentsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
}

export interface IntentsClient<CallOptionsExt = {}> {
  /** Returns the list of all intents in the specified agent. */
  listIntents(
    request: DeepPartial<ListIntentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListIntentsResponse>;
  /** Retrieves the specified intent. */
  getIntent(request: DeepPartial<GetIntentRequest>, options?: CallOptions & CallOptionsExt): Promise<Intent>;
  /**
   * Creates an intent in the specified agent.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  createIntent(request: DeepPartial<CreateIntentRequest>, options?: CallOptions & CallOptionsExt): Promise<Intent>;
  /**
   * Updates the specified intent.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  updateIntent(request: DeepPartial<UpdateIntentRequest>, options?: CallOptions & CallOptionsExt): Promise<Intent>;
  /**
   * Deletes the specified intent.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  deleteIntent(request: DeepPartial<DeleteIntentRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Imports the specified intents into the agent.
   *
   * This method is a [long-running
   * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
   * The returned `Operation` type has the following method-specific fields:
   *
   * - `metadata`:
   * [ImportIntentsMetadata][google.cloud.dialogflow.cx.v3beta1.ImportIntentsMetadata]
   * - `response`:
   * [ImportIntentsResponse][google.cloud.dialogflow.cx.v3beta1.ImportIntentsResponse]
   */
  importIntents(request: DeepPartial<ImportIntentsRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Exports the selected intents.
   *
   * This method is a [long-running
   * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
   * The returned `Operation` type has the following method-specific fields:
   *
   * - `metadata`:
   * [ExportIntentsMetadata][google.cloud.dialogflow.cx.v3beta1.ExportIntentsMetadata]
   * - `response`:
   * [ExportIntentsResponse][google.cloud.dialogflow.cx.v3beta1.ExportIntentsResponse]
   */
  exportIntents(request: DeepPartial<ExportIntentsRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
