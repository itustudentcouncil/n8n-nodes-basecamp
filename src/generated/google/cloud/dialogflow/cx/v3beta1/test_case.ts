// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dialogflow/cx/v3beta1/test_case.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../../longrunning/operations.js";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { Struct } from "../../../../protobuf/struct.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { Status } from "../../../../rpc/status.js";
import { Flow } from "./flow.js";
import { Intent } from "./intent.js";
import { EventHandler, Page, TransitionRoute } from "./page.js";
import { ResponseMessage_Text } from "./response_message.js";
import { QueryInput } from "./session.js";
import { TransitionRouteGroup } from "./transition_route_group.js";

export const protobufPackage = "google.cloud.dialogflow.cx.v3beta1";

/** The test result for a test case and an agent environment. */
export enum TestResult {
  /** TEST_RESULT_UNSPECIFIED - Not specified. Should never be used. */
  TEST_RESULT_UNSPECIFIED = 0,
  /** PASSED - The test passed. */
  PASSED = 1,
  /** FAILED - The test did not pass. */
  FAILED = 2,
  UNRECOGNIZED = -1,
}

export function testResultFromJSON(object: any): TestResult {
  switch (object) {
    case 0:
    case "TEST_RESULT_UNSPECIFIED":
      return TestResult.TEST_RESULT_UNSPECIFIED;
    case 1:
    case "PASSED":
      return TestResult.PASSED;
    case 2:
    case "FAILED":
      return TestResult.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestResult.UNRECOGNIZED;
  }
}

export function testResultToJSON(object: TestResult): string {
  switch (object) {
    case TestResult.TEST_RESULT_UNSPECIFIED:
      return "TEST_RESULT_UNSPECIFIED";
    case TestResult.PASSED:
      return "PASSED";
    case TestResult.FAILED:
      return "FAILED";
    case TestResult.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents a test case. */
export interface TestCase {
  /**
   * The unique identifier of the test case.
   * [TestCases.CreateTestCase][google.cloud.dialogflow.cx.v3beta1.TestCases.CreateTestCase]
   * will populate the name automatically. Otherwise use format:
   * `projects/<Project ID>/locations/<LocationID>/agents/
   * <AgentID>/testCases/<TestCase ID>`.
   */
  name: string;
  /**
   * Tags are short descriptions that users may apply to test cases for
   * organizational and filtering purposes. Each tag should start with "#" and
   * has a limit of 30 characters.
   */
  tags: string[];
  /**
   * Required. The human-readable name of the test case, unique within the
   * agent. Limit of 200 characters.
   */
  displayName: string;
  /** Additional freeform notes about the test case. Limit of 400 characters. */
  notes: string;
  /** Config for the test case. */
  testConfig:
    | TestConfig
    | undefined;
  /**
   * The conversation turns uttered when the test case was created, in
   * chronological order. These include the canonical set of agent utterances
   * that should occur when the agent is working properly.
   */
  testCaseConversationTurns: ConversationTurn[];
  /** Output only. When the test was created. */
  creationTime:
    | Date
    | undefined;
  /** The latest test result. */
  lastTestResult: TestCaseResult | undefined;
}

/** Represents a result from running a test case in an agent environment. */
export interface TestCaseResult {
  /**
   * The resource name for the test case result. Format:
   * `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/testCases/
   * <TestCase ID>/results/<TestCaseResult ID>`.
   */
  name: string;
  /**
   * Environment where the test was run. If not set, it indicates the draft
   * environment.
   */
  environment: string;
  /**
   * The conversation turns uttered during the test case replay in chronological
   * order.
   */
  conversationTurns: ConversationTurn[];
  /** Whether the test case passed in the agent environment. */
  testResult: TestResult;
  /** The time that the test was run. */
  testTime: Date | undefined;
}

/** Represents configurations for a test case. */
export interface TestConfig {
  /** Session parameters to be compared when calculating differences. */
  trackingParameters: string[];
  /**
   * Flow name to start the test case with.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>`.
   *
   * Only one of `flow` and `page` should be set to indicate the starting point
   * of the test case. If neither is set, the test case will start with start
   * page on the default start flow.
   */
  flow: string;
  /**
   * The [page][google.cloud.dialogflow.cx.v3beta1.Page] to start the test case
   * with. Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>/pages/<Page ID>`.
   *
   * Only one of `flow` and `page` should be set to indicate the starting point
   * of the test case. If neither is set, the test case will start with start
   * page on the default start flow.
   */
  page: string;
}

/**
 * One interaction between a human and virtual agent. The human provides some
 * input and the virtual agent provides a response.
 */
export interface ConversationTurn {
  /** The user input. */
  userInput:
    | ConversationTurn_UserInput
    | undefined;
  /** The virtual agent output. */
  virtualAgentOutput: ConversationTurn_VirtualAgentOutput | undefined;
}

/** The input from the human user. */
export interface ConversationTurn_UserInput {
  /**
   * Supports [text
   * input][google.cloud.dialogflow.cx.v3beta1.QueryInput.text], [event
   * input][google.cloud.dialogflow.cx.v3beta1.QueryInput.event], [dtmf
   * input][google.cloud.dialogflow.cx.v3beta1.QueryInput.dtmf] in the test
   * case.
   */
  input:
    | QueryInput
    | undefined;
  /**
   * Parameters that need to be injected into the conversation during intent
   * detection.
   */
  injectedParameters:
    | { [key: string]: any }
    | undefined;
  /**
   * If webhooks should be allowed to trigger in response to the user
   * utterance. Often if parameters are injected, webhooks should not be
   * enabled.
   */
  isWebhookEnabled: boolean;
  /** Whether sentiment analysis is enabled. */
  enableSentimentAnalysis: boolean;
}

/** The output from the virtual agent. */
export interface ConversationTurn_VirtualAgentOutput {
  /** The session parameters available to the bot at this point. */
  sessionParameters:
    | { [key: string]: any }
    | undefined;
  /**
   * Output only. If this is part of a [result conversation
   * turn][TestCaseResult.conversation_turns], the list of differences
   * between the original run and the replay for this output, if any.
   */
  differences: TestRunDifference[];
  /**
   * Required. Input only. The diagnostic
   * [info][Session.DetectIntentResponse.QueryResult.diagnostic_info]
   * output for the turn. Required to calculate the testing coverage.
   */
  diagnosticInfo:
    | { [key: string]: any }
    | undefined;
  /**
   * The [Intent][google.cloud.dialogflow.cx.v3beta1.Intent] that triggered
   * the response. Only name and displayName will be set.
   */
  triggeredIntent:
    | Intent
    | undefined;
  /**
   * The [Page][google.cloud.dialogflow.cx.v3beta1.Page] on which the
   * utterance was spoken. Only name and displayName will be set.
   */
  currentPage:
    | Page
    | undefined;
  /**
   * The [text][google.cloud.dialogflow.cx.v3beta1.ResponseMessage.Text]
   * responses from the agent for the turn.
   */
  textResponses: ResponseMessage_Text[];
  /**
   * Response error from the agent in the test result. If set, other output
   * is empty.
   */
  status: Status | undefined;
}

/** The description of differences between original and replayed agent output. */
export interface TestRunDifference {
  /** The type of diff. */
  type: TestRunDifference_DiffType;
  /**
   * A human readable description of the diff, showing the actual output vs
   * expected output.
   */
  description: string;
}

/** What part of the message replay differs from the test case. */
export enum TestRunDifference_DiffType {
  /** DIFF_TYPE_UNSPECIFIED - Should never be used. */
  DIFF_TYPE_UNSPECIFIED = 0,
  /** INTENT - The intent. */
  INTENT = 1,
  /** PAGE - The page. */
  PAGE = 2,
  /** PARAMETERS - The parameters. */
  PARAMETERS = 3,
  /** UTTERANCE - The message utterance. */
  UTTERANCE = 4,
  /** FLOW - The flow. */
  FLOW = 5,
  UNRECOGNIZED = -1,
}

export function testRunDifference_DiffTypeFromJSON(object: any): TestRunDifference_DiffType {
  switch (object) {
    case 0:
    case "DIFF_TYPE_UNSPECIFIED":
      return TestRunDifference_DiffType.DIFF_TYPE_UNSPECIFIED;
    case 1:
    case "INTENT":
      return TestRunDifference_DiffType.INTENT;
    case 2:
    case "PAGE":
      return TestRunDifference_DiffType.PAGE;
    case 3:
    case "PARAMETERS":
      return TestRunDifference_DiffType.PARAMETERS;
    case 4:
    case "UTTERANCE":
      return TestRunDifference_DiffType.UTTERANCE;
    case 5:
    case "FLOW":
      return TestRunDifference_DiffType.FLOW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestRunDifference_DiffType.UNRECOGNIZED;
  }
}

export function testRunDifference_DiffTypeToJSON(object: TestRunDifference_DiffType): string {
  switch (object) {
    case TestRunDifference_DiffType.DIFF_TYPE_UNSPECIFIED:
      return "DIFF_TYPE_UNSPECIFIED";
    case TestRunDifference_DiffType.INTENT:
      return "INTENT";
    case TestRunDifference_DiffType.PAGE:
      return "PAGE";
    case TestRunDifference_DiffType.PARAMETERS:
      return "PARAMETERS";
    case TestRunDifference_DiffType.UTTERANCE:
      return "UTTERANCE";
    case TestRunDifference_DiffType.FLOW:
      return "FLOW";
    case TestRunDifference_DiffType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Transition coverage represents the percentage of all possible page
 * transitions (page-level transition routes and event handlers, excluding
 * transition route groups) present within any of a parent's test cases.
 */
export interface TransitionCoverage {
  /** The list of Transitions present in the agent. */
  transitions: TransitionCoverage_Transition[];
  /** The percent of transitions in the agent that are covered. */
  coverageScore: number;
}

/** The source or target of a transition. */
export interface TransitionCoverage_TransitionNode {
  /**
   * Indicates a transition to a
   * [Page][google.cloud.dialogflow.cx.v3beta1.Page]. Only some fields such
   * as name and displayname will be set.
   */
  page?:
    | Page
    | undefined;
  /**
   * Indicates a transition to a
   * [Flow][google.cloud.dialogflow.cx.v3beta1.Flow]. Only some fields such
   * as name and displayname will be set.
   */
  flow?: Flow | undefined;
}

/** A transition in a page. */
export interface TransitionCoverage_Transition {
  /** The start node of a transition. */
  source:
    | TransitionCoverage_TransitionNode
    | undefined;
  /** The index of a transition in the transition list. Starting from 0. */
  index: number;
  /** The end node of a transition. */
  target:
    | TransitionCoverage_TransitionNode
    | undefined;
  /**
   * Whether the transition is covered by at least one of the
   * agent's test cases.
   */
  covered: boolean;
  /** Intent route or condition route. */
  transitionRoute?:
    | TransitionRoute
    | undefined;
  /** Event handler. */
  eventHandler?: EventHandler | undefined;
}

/**
 * Transition route group coverage represents the percentage of all possible
 * transition routes present within any of a parent's test cases. The results
 * are grouped by the transition route group.
 */
export interface TransitionRouteGroupCoverage {
  /** Transition route group coverages. */
  coverages: TransitionRouteGroupCoverage_Coverage[];
  /**
   * The percent of transition routes in all the transition route groups that
   * are covered.
   */
  coverageScore: number;
}

/** Coverage result message for one transition route group. */
export interface TransitionRouteGroupCoverage_Coverage {
  /** Transition route group metadata. Only name and displayName will be set. */
  routeGroup:
    | TransitionRouteGroup
    | undefined;
  /** The list of transition routes and coverage in the transition route group. */
  transitions: TransitionRouteGroupCoverage_Coverage_Transition[];
  /**
   * The percent of transition routes in the transition route group that are
   * covered.
   */
  coverageScore: number;
}

/** A transition coverage in a transition route group. */
export interface TransitionRouteGroupCoverage_Coverage_Transition {
  /** Intent route or condition route. */
  transitionRoute:
    | TransitionRoute
    | undefined;
  /**
   * Whether the transition route is covered by at least one of the
   * agent's test cases.
   */
  covered: boolean;
}

/**
 * Intent coverage represents the percentage of all possible intents in the
 * agent that are triggered in any of a parent's test cases.
 */
export interface IntentCoverage {
  /** The list of Intents present in the agent */
  intents: IntentCoverage_Intent[];
  /** The percent of intents in the agent that are covered. */
  coverageScore: number;
}

/** The agent's intent. */
export interface IntentCoverage_Intent {
  /** The intent full resource name */
  intent: string;
  /**
   * Whether the intent is covered by at least one of the agent's
   * test cases.
   */
  covered: boolean;
}

/**
 * The request message for
 * [TestCases.CalculateCoverage][google.cloud.dialogflow.cx.v3beta1.TestCases.CalculateCoverage].
 */
export interface CalculateCoverageRequest {
  /**
   * Required. The agent to calculate coverage for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  agent: string;
  /** Required. The type of coverage requested. */
  type: CalculateCoverageRequest_CoverageType;
}

/** The type of coverage score requested. */
export enum CalculateCoverageRequest_CoverageType {
  /** COVERAGE_TYPE_UNSPECIFIED - Should never be used. */
  COVERAGE_TYPE_UNSPECIFIED = 0,
  /** INTENT - Intent coverage. */
  INTENT = 1,
  /** PAGE_TRANSITION - Page transition coverage. */
  PAGE_TRANSITION = 2,
  /** TRANSITION_ROUTE_GROUP - Transition route group coverage. */
  TRANSITION_ROUTE_GROUP = 3,
  UNRECOGNIZED = -1,
}

export function calculateCoverageRequest_CoverageTypeFromJSON(object: any): CalculateCoverageRequest_CoverageType {
  switch (object) {
    case 0:
    case "COVERAGE_TYPE_UNSPECIFIED":
      return CalculateCoverageRequest_CoverageType.COVERAGE_TYPE_UNSPECIFIED;
    case 1:
    case "INTENT":
      return CalculateCoverageRequest_CoverageType.INTENT;
    case 2:
    case "PAGE_TRANSITION":
      return CalculateCoverageRequest_CoverageType.PAGE_TRANSITION;
    case 3:
    case "TRANSITION_ROUTE_GROUP":
      return CalculateCoverageRequest_CoverageType.TRANSITION_ROUTE_GROUP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CalculateCoverageRequest_CoverageType.UNRECOGNIZED;
  }
}

export function calculateCoverageRequest_CoverageTypeToJSON(object: CalculateCoverageRequest_CoverageType): string {
  switch (object) {
    case CalculateCoverageRequest_CoverageType.COVERAGE_TYPE_UNSPECIFIED:
      return "COVERAGE_TYPE_UNSPECIFIED";
    case CalculateCoverageRequest_CoverageType.INTENT:
      return "INTENT";
    case CalculateCoverageRequest_CoverageType.PAGE_TRANSITION:
      return "PAGE_TRANSITION";
    case CalculateCoverageRequest_CoverageType.TRANSITION_ROUTE_GROUP:
      return "TRANSITION_ROUTE_GROUP";
    case CalculateCoverageRequest_CoverageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The response message for
 * [TestCases.CalculateCoverage][google.cloud.dialogflow.cx.v3beta1.TestCases.CalculateCoverage].
 */
export interface CalculateCoverageResponse {
  /**
   * The agent to calculate coverage for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  agent: string;
  /** Intent coverage. */
  intentCoverage?:
    | IntentCoverage
    | undefined;
  /** Transition (excluding transition route groups) coverage. */
  transitionCoverage?:
    | TransitionCoverage
    | undefined;
  /** Transition route group coverage. */
  routeGroupCoverage?: TransitionRouteGroupCoverage | undefined;
}

/**
 * The request message for
 * [TestCases.ListTestCases][google.cloud.dialogflow.cx.v3beta1.TestCases.ListTestCases].
 */
export interface ListTestCasesRequest {
  /**
   * Required. The agent to list all pages for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /**
   * The maximum number of items to return in a single page. By default 20.
   * Note that when TestCaseView = FULL, the maximum page size allowed is 20.
   * When TestCaseView = BASIC, the maximum page size allowed is 500.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous list request. */
  pageToken: string;
  /** Specifies whether response should include all fields or just the metadata. */
  view: ListTestCasesRequest_TestCaseView;
}

/** Specifies how much test case information to include in the response. */
export enum ListTestCasesRequest_TestCaseView {
  /**
   * TEST_CASE_VIEW_UNSPECIFIED - The default / unset value.
   * The API will default to the BASIC view.
   */
  TEST_CASE_VIEW_UNSPECIFIED = 0,
  /**
   * BASIC - Include basic metadata about the test case, but not the conversation
   * turns. This is the default value.
   */
  BASIC = 1,
  /** FULL - Include everything. */
  FULL = 2,
  UNRECOGNIZED = -1,
}

export function listTestCasesRequest_TestCaseViewFromJSON(object: any): ListTestCasesRequest_TestCaseView {
  switch (object) {
    case 0:
    case "TEST_CASE_VIEW_UNSPECIFIED":
      return ListTestCasesRequest_TestCaseView.TEST_CASE_VIEW_UNSPECIFIED;
    case 1:
    case "BASIC":
      return ListTestCasesRequest_TestCaseView.BASIC;
    case 2:
    case "FULL":
      return ListTestCasesRequest_TestCaseView.FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ListTestCasesRequest_TestCaseView.UNRECOGNIZED;
  }
}

export function listTestCasesRequest_TestCaseViewToJSON(object: ListTestCasesRequest_TestCaseView): string {
  switch (object) {
    case ListTestCasesRequest_TestCaseView.TEST_CASE_VIEW_UNSPECIFIED:
      return "TEST_CASE_VIEW_UNSPECIFIED";
    case ListTestCasesRequest_TestCaseView.BASIC:
      return "BASIC";
    case ListTestCasesRequest_TestCaseView.FULL:
      return "FULL";
    case ListTestCasesRequest_TestCaseView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The response message for
 * [TestCases.ListTestCases][google.cloud.dialogflow.cx.v3beta1.TestCases.ListTestCases].
 */
export interface ListTestCasesResponse {
  /**
   * The list of test cases. There will be a maximum number of items returned
   * based on the page_size field in the request.
   */
  testCases: TestCase[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
}

/**
 * The request message for
 * [TestCases.BatchDeleteTestCases][google.cloud.dialogflow.cx.v3beta1.TestCases.BatchDeleteTestCases].
 */
export interface BatchDeleteTestCasesRequest {
  /**
   * Required. The agent to delete test cases from.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /**
   * Required. Format of test case names: `projects/<Project ID>/locations/
   * <Location ID>/agents/<AgentID>/testCases/<TestCase ID>`.
   */
  names: string[];
}

/**
 * The request message for
 * [TestCases.CreateTestCase][google.cloud.dialogflow.cx.v3beta1.TestCases.CreateTestCase].
 */
export interface CreateTestCaseRequest {
  /**
   * Required. The agent to create the test case for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /** Required. The test case to create. */
  testCase: TestCase | undefined;
}

/**
 * The request message for
 * [TestCases.UpdateTestCase][google.cloud.dialogflow.cx.v3beta1.TestCases.UpdateTestCase].
 */
export interface UpdateTestCaseRequest {
  /** Required. The test case to update. */
  testCase:
    | TestCase
    | undefined;
  /**
   * Required. The mask to specify which fields should be updated. The
   * [`creationTime`][google.cloud.dialogflow.cx.v3beta1.TestCase.creation_time]
   * and
   * [`lastTestResult`][google.cloud.dialogflow.cx.v3beta1.TestCase.last_test_result]
   * cannot be updated.
   */
  updateMask: string[] | undefined;
}

/**
 * The request message for
 * [TestCases.GetTestCase][google.cloud.dialogflow.cx.v3beta1.TestCases.GetTestCase].
 */
export interface GetTestCaseRequest {
  /**
   * Required. The name of the testcase.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/testCases/<TestCase ID>`.
   */
  name: string;
}

/**
 * The request message for
 * [TestCases.RunTestCase][google.cloud.dialogflow.cx.v3beta1.TestCases.RunTestCase].
 */
export interface RunTestCaseRequest {
  /**
   * Required. Format of test case name to run: `projects/<Project
   * ID>/locations/ <Location ID>/agents/<AgentID>/testCases/<TestCase ID>`.
   */
  name: string;
  /**
   * Optional. Environment name. If not set, draft environment is assumed.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/environments/<Environment ID>`.
   */
  environment: string;
}

/**
 * The response message for
 * [TestCases.RunTestCase][google.cloud.dialogflow.cx.v3beta1.TestCases.RunTestCase].
 */
export interface RunTestCaseResponse {
  /** The result. */
  result: TestCaseResult | undefined;
}

/**
 * Metadata returned for the
 * [TestCases.RunTestCase][google.cloud.dialogflow.cx.v3beta1.TestCases.RunTestCase]
 * long running operation. This message currently has no fields.
 */
export interface RunTestCaseMetadata {
}

/**
 * The request message for
 * [TestCases.BatchRunTestCases][google.cloud.dialogflow.cx.v3beta1.TestCases.BatchRunTestCases].
 */
export interface BatchRunTestCasesRequest {
  /**
   * Required. Agent name. Format: `projects/<Project ID>/locations/<Location
   * ID>/agents/ <AgentID>`.
   */
  parent: string;
  /**
   * Optional. If not set, draft environment is assumed. Format:
   * `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/environments/<Environment ID>`.
   */
  environment: string;
  /**
   * Required. Format: `projects/<Project ID>/locations/<Location
   * ID>/agents/<Agent ID>/testCases/<TestCase ID>`.
   */
  testCases: string[];
}

/**
 * The response message for
 * [TestCases.BatchRunTestCases][google.cloud.dialogflow.cx.v3beta1.TestCases.BatchRunTestCases].
 */
export interface BatchRunTestCasesResponse {
  /**
   * The test case results. The detailed
   * [conversation
   * turns][google.cloud.dialogflow.cx.v3beta1.TestCaseResult.conversation_turns]
   * are empty in this response.
   */
  results: TestCaseResult[];
}

/**
 * Metadata returned for the
 * [TestCases.BatchRunTestCases][google.cloud.dialogflow.cx.v3beta1.TestCases.BatchRunTestCases]
 * long running operation.
 */
export interface BatchRunTestCasesMetadata {
  /** The test errors. */
  errors: TestError[];
}

/** Error info for running a test. */
export interface TestError {
  /** The test case resource name. */
  testCase: string;
  /** The status associated with the test. */
  status:
    | Status
    | undefined;
  /** The timestamp when the test was completed. */
  testTime: Date | undefined;
}

/**
 * The request message for
 * [TestCases.ImportTestCases][google.cloud.dialogflow.cx.v3beta1.TestCases.ImportTestCases].
 */
export interface ImportTestCasesRequest {
  /**
   * Required. The agent to import test cases to.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /**
   * The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI
   * to import test cases from. The format of this URI must be
   * `gs://<bucket-name>/<object-name>`.
   *
   * Dialogflow performs a read operation for the Cloud Storage object
   * on the caller's behalf, so your request authentication must
   * have read permissions for the object. For more information, see
   * [Dialogflow access
   * control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
   */
  gcsUri?:
    | string
    | undefined;
  /** Uncompressed raw byte content for test cases. */
  content?: Buffer | undefined;
}

/**
 * The response message for
 * [TestCases.ImportTestCases][google.cloud.dialogflow.cx.v3beta1.TestCases.ImportTestCases].
 */
export interface ImportTestCasesResponse {
  /**
   * The unique identifiers of the new test cases.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/testCases/<TestCase ID>`.
   */
  names: string[];
}

/**
 * Metadata returned for the
 * [TestCases.ImportTestCases][google.cloud.dialogflow.cx.v3beta1.TestCases.ImportTestCases]
 * long running operation.
 */
export interface ImportTestCasesMetadata {
  /** Errors for failed test cases. */
  errors: TestCaseError[];
}

/** Error info for importing a test. */
export interface TestCaseError {
  /** The test case. */
  testCase:
    | TestCase
    | undefined;
  /** The status associated with the test case. */
  status: Status | undefined;
}

/**
 * The request message for
 * [TestCases.ExportTestCases][google.cloud.dialogflow.cx.v3beta1.TestCases.ExportTestCases].
 */
export interface ExportTestCasesRequest {
  /**
   * Required. The agent where to export test cases from.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /**
   * The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI to
   * export the test cases to. The format of this URI must be
   * `gs://<bucket-name>/<object-name>`. If unspecified, the serialized test
   * cases is returned inline.
   *
   * Dialogflow performs a write operation for the Cloud Storage object
   * on the caller's behalf, so your request authentication must
   * have write permissions for the object. For more information, see
   * [Dialogflow access
   * control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
   */
  gcsUri?:
    | string
    | undefined;
  /**
   * The data format of the exported test cases. If not specified, `BLOB` is
   * assumed.
   */
  dataFormat: ExportTestCasesRequest_DataFormat;
  /**
   * The filter expression used to filter exported test cases, see
   * [API Filtering](https://aip.dev/160). The expression is case insensitive
   * and supports the following syntax:
   *
   *   name = <value> [OR name = <value>] ...
   *
   * For example:
   *
   * *   "name = t1 OR name = t2" matches the test case with the exact resource
   *     name "t1" or "t2".
   */
  filter: string;
}

/** Data format of the exported test cases. */
export enum ExportTestCasesRequest_DataFormat {
  /** DATA_FORMAT_UNSPECIFIED - Unspecified format. */
  DATA_FORMAT_UNSPECIFIED = 0,
  /** BLOB - Raw bytes. */
  BLOB = 1,
  /** JSON - JSON format. */
  JSON = 2,
  UNRECOGNIZED = -1,
}

export function exportTestCasesRequest_DataFormatFromJSON(object: any): ExportTestCasesRequest_DataFormat {
  switch (object) {
    case 0:
    case "DATA_FORMAT_UNSPECIFIED":
      return ExportTestCasesRequest_DataFormat.DATA_FORMAT_UNSPECIFIED;
    case 1:
    case "BLOB":
      return ExportTestCasesRequest_DataFormat.BLOB;
    case 2:
    case "JSON":
      return ExportTestCasesRequest_DataFormat.JSON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExportTestCasesRequest_DataFormat.UNRECOGNIZED;
  }
}

export function exportTestCasesRequest_DataFormatToJSON(object: ExportTestCasesRequest_DataFormat): string {
  switch (object) {
    case ExportTestCasesRequest_DataFormat.DATA_FORMAT_UNSPECIFIED:
      return "DATA_FORMAT_UNSPECIFIED";
    case ExportTestCasesRequest_DataFormat.BLOB:
      return "BLOB";
    case ExportTestCasesRequest_DataFormat.JSON:
      return "JSON";
    case ExportTestCasesRequest_DataFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The response message for
 * [TestCases.ExportTestCases][google.cloud.dialogflow.cx.v3beta1.TestCases.ExportTestCases].
 */
export interface ExportTestCasesResponse {
  /**
   * The URI to a file containing the exported test cases. This field is
   * populated only if `gcs_uri` is specified in
   * [ExportTestCasesRequest][google.cloud.dialogflow.cx.v3beta1.ExportTestCasesRequest].
   */
  gcsUri?:
    | string
    | undefined;
  /** Uncompressed raw byte content for test cases. */
  content?: Buffer | undefined;
}

/**
 * Metadata returned for the
 * [TestCases.ExportTestCases][google.cloud.dialogflow.cx.v3beta1.TestCases.ExportTestCases]
 * long running operation. This message currently has no fields.
 */
export interface ExportTestCasesMetadata {
}

/**
 * The request message for
 * [TestCases.ListTestCaseResults][google.cloud.dialogflow.cx.v3beta1.TestCases.ListTestCaseResults].
 */
export interface ListTestCaseResultsRequest {
  /**
   * Required. The test case to list results for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/
   * testCases/<TestCase ID>`. Specify a `-` as a wildcard for TestCase ID to
   * list results across multiple test cases.
   */
  parent: string;
  /**
   * The maximum number of items to return in a single page. By default 100 and
   * at most 1000.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous list request. */
  pageToken: string;
  /**
   * The filter expression used to filter test case results. See
   * [API Filtering](https://aip.dev/160).
   *
   * The expression is case insensitive. Only 'AND' is supported for logical
   * operators. The supported syntax is listed below in detail:
   *
   *   <field> <operator> <value> [AND <field> <operator> <value>] ...
   *   [AND latest]
   *
   * The supported fields and operators are:
   * field                 operator
   * `environment`         `=`, `IN`  (Use value `draft` for draft environment)
   * `test_time`           `>`, `<`
   *
   * `latest` only returns the latest test result in all results for each test
   * case.
   *
   * Examples:
   * *   "environment=draft AND latest" matches the latest test result for each
   *     test case in the draft environment.
   * *   "environment IN (e1,e2)" matches any test case results with an
   *     environment resource name of either "e1" or "e2".
   * *   "test_time > 1602540713" matches any test case results with test time
   *     later than a unix timestamp in seconds 1602540713.
   */
  filter: string;
}

/**
 * The response message for
 * [TestCases.ListTestCaseResults][google.cloud.dialogflow.cx.v3beta1.TestCases.ListTestCaseResults].
 */
export interface ListTestCaseResultsResponse {
  /** The list of test case results. */
  testCaseResults: TestCaseResult[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
}

/**
 * The request message for
 * [TestCases.GetTestCaseResult][google.cloud.dialogflow.cx.v3beta1.TestCases.GetTestCaseResult].
 */
export interface GetTestCaseResultRequest {
  /**
   * Required. The name of the testcase.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/testCases/<TestCase ID>/results/<TestCaseResult ID>`.
   */
  name: string;
}

function createBaseTestCase(): TestCase {
  return {
    name: "",
    tags: [],
    displayName: "",
    notes: "",
    testConfig: undefined,
    testCaseConversationTurns: [],
    creationTime: undefined,
    lastTestResult: undefined,
  };
}

export const TestCase: MessageFns<TestCase> = {
  encode(message: TestCase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.tags) {
      writer.uint32(18).string(v!);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.notes !== "") {
      writer.uint32(34).string(message.notes);
    }
    if (message.testConfig !== undefined) {
      TestConfig.encode(message.testConfig, writer.uint32(106).fork()).join();
    }
    for (const v of message.testCaseConversationTurns) {
      ConversationTurn.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.creationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.creationTime), writer.uint32(82).fork()).join();
    }
    if (message.lastTestResult !== undefined) {
      TestCaseResult.encode(message.lastTestResult, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.testConfig = TestConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.testCaseConversationTurns.push(ConversationTurn.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.creationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.lastTestResult = TestCaseResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCase {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      testConfig: isSet(object.testConfig) ? TestConfig.fromJSON(object.testConfig) : undefined,
      testCaseConversationTurns: globalThis.Array.isArray(object?.testCaseConversationTurns)
        ? object.testCaseConversationTurns.map((e: any) => ConversationTurn.fromJSON(e))
        : [],
      creationTime: isSet(object.creationTime) ? fromJsonTimestamp(object.creationTime) : undefined,
      lastTestResult: isSet(object.lastTestResult) ? TestCaseResult.fromJSON(object.lastTestResult) : undefined,
    };
  },

  toJSON(message: TestCase): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.testConfig !== undefined) {
      obj.testConfig = TestConfig.toJSON(message.testConfig);
    }
    if (message.testCaseConversationTurns?.length) {
      obj.testCaseConversationTurns = message.testCaseConversationTurns.map((e) => ConversationTurn.toJSON(e));
    }
    if (message.creationTime !== undefined) {
      obj.creationTime = message.creationTime.toISOString();
    }
    if (message.lastTestResult !== undefined) {
      obj.lastTestResult = TestCaseResult.toJSON(message.lastTestResult);
    }
    return obj;
  },

  create(base?: DeepPartial<TestCase>): TestCase {
    return TestCase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestCase>): TestCase {
    const message = createBaseTestCase();
    message.name = object.name ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.displayName = object.displayName ?? "";
    message.notes = object.notes ?? "";
    message.testConfig = (object.testConfig !== undefined && object.testConfig !== null)
      ? TestConfig.fromPartial(object.testConfig)
      : undefined;
    message.testCaseConversationTurns = object.testCaseConversationTurns?.map((e) => ConversationTurn.fromPartial(e)) ||
      [];
    message.creationTime = object.creationTime ?? undefined;
    message.lastTestResult = (object.lastTestResult !== undefined && object.lastTestResult !== null)
      ? TestCaseResult.fromPartial(object.lastTestResult)
      : undefined;
    return message;
  },
};

function createBaseTestCaseResult(): TestCaseResult {
  return { name: "", environment: "", conversationTurns: [], testResult: 0, testTime: undefined };
}

export const TestCaseResult: MessageFns<TestCaseResult> = {
  encode(message: TestCaseResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.environment !== "") {
      writer.uint32(18).string(message.environment);
    }
    for (const v of message.conversationTurns) {
      ConversationTurn.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.testResult !== 0) {
      writer.uint32(32).int32(message.testResult);
    }
    if (message.testTime !== undefined) {
      Timestamp.encode(toTimestamp(message.testTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCaseResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCaseResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.environment = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.conversationTurns.push(ConversationTurn.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.testResult = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.testTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCaseResult {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      conversationTurns: globalThis.Array.isArray(object?.conversationTurns)
        ? object.conversationTurns.map((e: any) => ConversationTurn.fromJSON(e))
        : [],
      testResult: isSet(object.testResult) ? testResultFromJSON(object.testResult) : 0,
      testTime: isSet(object.testTime) ? fromJsonTimestamp(object.testTime) : undefined,
    };
  },

  toJSON(message: TestCaseResult): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.conversationTurns?.length) {
      obj.conversationTurns = message.conversationTurns.map((e) => ConversationTurn.toJSON(e));
    }
    if (message.testResult !== 0) {
      obj.testResult = testResultToJSON(message.testResult);
    }
    if (message.testTime !== undefined) {
      obj.testTime = message.testTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TestCaseResult>): TestCaseResult {
    return TestCaseResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestCaseResult>): TestCaseResult {
    const message = createBaseTestCaseResult();
    message.name = object.name ?? "";
    message.environment = object.environment ?? "";
    message.conversationTurns = object.conversationTurns?.map((e) => ConversationTurn.fromPartial(e)) || [];
    message.testResult = object.testResult ?? 0;
    message.testTime = object.testTime ?? undefined;
    return message;
  },
};

function createBaseTestConfig(): TestConfig {
  return { trackingParameters: [], flow: "", page: "" };
}

export const TestConfig: MessageFns<TestConfig> = {
  encode(message: TestConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.trackingParameters) {
      writer.uint32(10).string(v!);
    }
    if (message.flow !== "") {
      writer.uint32(18).string(message.flow);
    }
    if (message.page !== "") {
      writer.uint32(26).string(message.page);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.trackingParameters.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.flow = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.page = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestConfig {
    return {
      trackingParameters: globalThis.Array.isArray(object?.trackingParameters)
        ? object.trackingParameters.map((e: any) => globalThis.String(e))
        : [],
      flow: isSet(object.flow) ? globalThis.String(object.flow) : "",
      page: isSet(object.page) ? globalThis.String(object.page) : "",
    };
  },

  toJSON(message: TestConfig): unknown {
    const obj: any = {};
    if (message.trackingParameters?.length) {
      obj.trackingParameters = message.trackingParameters;
    }
    if (message.flow !== "") {
      obj.flow = message.flow;
    }
    if (message.page !== "") {
      obj.page = message.page;
    }
    return obj;
  },

  create(base?: DeepPartial<TestConfig>): TestConfig {
    return TestConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestConfig>): TestConfig {
    const message = createBaseTestConfig();
    message.trackingParameters = object.trackingParameters?.map((e) => e) || [];
    message.flow = object.flow ?? "";
    message.page = object.page ?? "";
    return message;
  },
};

function createBaseConversationTurn(): ConversationTurn {
  return { userInput: undefined, virtualAgentOutput: undefined };
}

export const ConversationTurn: MessageFns<ConversationTurn> = {
  encode(message: ConversationTurn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userInput !== undefined) {
      ConversationTurn_UserInput.encode(message.userInput, writer.uint32(10).fork()).join();
    }
    if (message.virtualAgentOutput !== undefined) {
      ConversationTurn_VirtualAgentOutput.encode(message.virtualAgentOutput, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationTurn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationTurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userInput = ConversationTurn_UserInput.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.virtualAgentOutput = ConversationTurn_VirtualAgentOutput.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationTurn {
    return {
      userInput: isSet(object.userInput) ? ConversationTurn_UserInput.fromJSON(object.userInput) : undefined,
      virtualAgentOutput: isSet(object.virtualAgentOutput)
        ? ConversationTurn_VirtualAgentOutput.fromJSON(object.virtualAgentOutput)
        : undefined,
    };
  },

  toJSON(message: ConversationTurn): unknown {
    const obj: any = {};
    if (message.userInput !== undefined) {
      obj.userInput = ConversationTurn_UserInput.toJSON(message.userInput);
    }
    if (message.virtualAgentOutput !== undefined) {
      obj.virtualAgentOutput = ConversationTurn_VirtualAgentOutput.toJSON(message.virtualAgentOutput);
    }
    return obj;
  },

  create(base?: DeepPartial<ConversationTurn>): ConversationTurn {
    return ConversationTurn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversationTurn>): ConversationTurn {
    const message = createBaseConversationTurn();
    message.userInput = (object.userInput !== undefined && object.userInput !== null)
      ? ConversationTurn_UserInput.fromPartial(object.userInput)
      : undefined;
    message.virtualAgentOutput = (object.virtualAgentOutput !== undefined && object.virtualAgentOutput !== null)
      ? ConversationTurn_VirtualAgentOutput.fromPartial(object.virtualAgentOutput)
      : undefined;
    return message;
  },
};

function createBaseConversationTurn_UserInput(): ConversationTurn_UserInput {
  return { input: undefined, injectedParameters: undefined, isWebhookEnabled: false, enableSentimentAnalysis: false };
}

export const ConversationTurn_UserInput: MessageFns<ConversationTurn_UserInput> = {
  encode(message: ConversationTurn_UserInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== undefined) {
      QueryInput.encode(message.input, writer.uint32(42).fork()).join();
    }
    if (message.injectedParameters !== undefined) {
      Struct.encode(Struct.wrap(message.injectedParameters), writer.uint32(18).fork()).join();
    }
    if (message.isWebhookEnabled !== false) {
      writer.uint32(24).bool(message.isWebhookEnabled);
    }
    if (message.enableSentimentAnalysis !== false) {
      writer.uint32(56).bool(message.enableSentimentAnalysis);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationTurn_UserInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationTurn_UserInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.input = QueryInput.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.injectedParameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isWebhookEnabled = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.enableSentimentAnalysis = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationTurn_UserInput {
    return {
      input: isSet(object.input) ? QueryInput.fromJSON(object.input) : undefined,
      injectedParameters: isObject(object.injectedParameters) ? object.injectedParameters : undefined,
      isWebhookEnabled: isSet(object.isWebhookEnabled) ? globalThis.Boolean(object.isWebhookEnabled) : false,
      enableSentimentAnalysis: isSet(object.enableSentimentAnalysis)
        ? globalThis.Boolean(object.enableSentimentAnalysis)
        : false,
    };
  },

  toJSON(message: ConversationTurn_UserInput): unknown {
    const obj: any = {};
    if (message.input !== undefined) {
      obj.input = QueryInput.toJSON(message.input);
    }
    if (message.injectedParameters !== undefined) {
      obj.injectedParameters = message.injectedParameters;
    }
    if (message.isWebhookEnabled !== false) {
      obj.isWebhookEnabled = message.isWebhookEnabled;
    }
    if (message.enableSentimentAnalysis !== false) {
      obj.enableSentimentAnalysis = message.enableSentimentAnalysis;
    }
    return obj;
  },

  create(base?: DeepPartial<ConversationTurn_UserInput>): ConversationTurn_UserInput {
    return ConversationTurn_UserInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversationTurn_UserInput>): ConversationTurn_UserInput {
    const message = createBaseConversationTurn_UserInput();
    message.input = (object.input !== undefined && object.input !== null)
      ? QueryInput.fromPartial(object.input)
      : undefined;
    message.injectedParameters = object.injectedParameters ?? undefined;
    message.isWebhookEnabled = object.isWebhookEnabled ?? false;
    message.enableSentimentAnalysis = object.enableSentimentAnalysis ?? false;
    return message;
  },
};

function createBaseConversationTurn_VirtualAgentOutput(): ConversationTurn_VirtualAgentOutput {
  return {
    sessionParameters: undefined,
    differences: [],
    diagnosticInfo: undefined,
    triggeredIntent: undefined,
    currentPage: undefined,
    textResponses: [],
    status: undefined,
  };
}

export const ConversationTurn_VirtualAgentOutput: MessageFns<ConversationTurn_VirtualAgentOutput> = {
  encode(message: ConversationTurn_VirtualAgentOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionParameters !== undefined) {
      Struct.encode(Struct.wrap(message.sessionParameters), writer.uint32(34).fork()).join();
    }
    for (const v of message.differences) {
      TestRunDifference.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.diagnosticInfo !== undefined) {
      Struct.encode(Struct.wrap(message.diagnosticInfo), writer.uint32(50).fork()).join();
    }
    if (message.triggeredIntent !== undefined) {
      Intent.encode(message.triggeredIntent, writer.uint32(58).fork()).join();
    }
    if (message.currentPage !== undefined) {
      Page.encode(message.currentPage, writer.uint32(66).fork()).join();
    }
    for (const v of message.textResponses) {
      ResponseMessage_Text.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationTurn_VirtualAgentOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationTurn_VirtualAgentOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sessionParameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.differences.push(TestRunDifference.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.diagnosticInfo = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.triggeredIntent = Intent.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.currentPage = Page.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.textResponses.push(ResponseMessage_Text.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationTurn_VirtualAgentOutput {
    return {
      sessionParameters: isObject(object.sessionParameters) ? object.sessionParameters : undefined,
      differences: globalThis.Array.isArray(object?.differences)
        ? object.differences.map((e: any) => TestRunDifference.fromJSON(e))
        : [],
      diagnosticInfo: isObject(object.diagnosticInfo) ? object.diagnosticInfo : undefined,
      triggeredIntent: isSet(object.triggeredIntent) ? Intent.fromJSON(object.triggeredIntent) : undefined,
      currentPage: isSet(object.currentPage) ? Page.fromJSON(object.currentPage) : undefined,
      textResponses: globalThis.Array.isArray(object?.textResponses)
        ? object.textResponses.map((e: any) => ResponseMessage_Text.fromJSON(e))
        : [],
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: ConversationTurn_VirtualAgentOutput): unknown {
    const obj: any = {};
    if (message.sessionParameters !== undefined) {
      obj.sessionParameters = message.sessionParameters;
    }
    if (message.differences?.length) {
      obj.differences = message.differences.map((e) => TestRunDifference.toJSON(e));
    }
    if (message.diagnosticInfo !== undefined) {
      obj.diagnosticInfo = message.diagnosticInfo;
    }
    if (message.triggeredIntent !== undefined) {
      obj.triggeredIntent = Intent.toJSON(message.triggeredIntent);
    }
    if (message.currentPage !== undefined) {
      obj.currentPage = Page.toJSON(message.currentPage);
    }
    if (message.textResponses?.length) {
      obj.textResponses = message.textResponses.map((e) => ResponseMessage_Text.toJSON(e));
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<ConversationTurn_VirtualAgentOutput>): ConversationTurn_VirtualAgentOutput {
    return ConversationTurn_VirtualAgentOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversationTurn_VirtualAgentOutput>): ConversationTurn_VirtualAgentOutput {
    const message = createBaseConversationTurn_VirtualAgentOutput();
    message.sessionParameters = object.sessionParameters ?? undefined;
    message.differences = object.differences?.map((e) => TestRunDifference.fromPartial(e)) || [];
    message.diagnosticInfo = object.diagnosticInfo ?? undefined;
    message.triggeredIntent = (object.triggeredIntent !== undefined && object.triggeredIntent !== null)
      ? Intent.fromPartial(object.triggeredIntent)
      : undefined;
    message.currentPage = (object.currentPage !== undefined && object.currentPage !== null)
      ? Page.fromPartial(object.currentPage)
      : undefined;
    message.textResponses = object.textResponses?.map((e) => ResponseMessage_Text.fromPartial(e)) || [];
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseTestRunDifference(): TestRunDifference {
  return { type: 0, description: "" };
}

export const TestRunDifference: MessageFns<TestRunDifference> = {
  encode(message: TestRunDifference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestRunDifference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestRunDifference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestRunDifference {
    return {
      type: isSet(object.type) ? testRunDifference_DiffTypeFromJSON(object.type) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: TestRunDifference): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = testRunDifference_DiffTypeToJSON(message.type);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<TestRunDifference>): TestRunDifference {
    return TestRunDifference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestRunDifference>): TestRunDifference {
    const message = createBaseTestRunDifference();
    message.type = object.type ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseTransitionCoverage(): TransitionCoverage {
  return { transitions: [], coverageScore: 0 };
}

export const TransitionCoverage: MessageFns<TransitionCoverage> = {
  encode(message: TransitionCoverage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transitions) {
      TransitionCoverage_Transition.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.coverageScore !== 0) {
      writer.uint32(21).float(message.coverageScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionCoverage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionCoverage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transitions.push(TransitionCoverage_Transition.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.coverageScore = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitionCoverage {
    return {
      transitions: globalThis.Array.isArray(object?.transitions)
        ? object.transitions.map((e: any) => TransitionCoverage_Transition.fromJSON(e))
        : [],
      coverageScore: isSet(object.coverageScore) ? globalThis.Number(object.coverageScore) : 0,
    };
  },

  toJSON(message: TransitionCoverage): unknown {
    const obj: any = {};
    if (message.transitions?.length) {
      obj.transitions = message.transitions.map((e) => TransitionCoverage_Transition.toJSON(e));
    }
    if (message.coverageScore !== 0) {
      obj.coverageScore = message.coverageScore;
    }
    return obj;
  },

  create(base?: DeepPartial<TransitionCoverage>): TransitionCoverage {
    return TransitionCoverage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransitionCoverage>): TransitionCoverage {
    const message = createBaseTransitionCoverage();
    message.transitions = object.transitions?.map((e) => TransitionCoverage_Transition.fromPartial(e)) || [];
    message.coverageScore = object.coverageScore ?? 0;
    return message;
  },
};

function createBaseTransitionCoverage_TransitionNode(): TransitionCoverage_TransitionNode {
  return { page: undefined, flow: undefined };
}

export const TransitionCoverage_TransitionNode: MessageFns<TransitionCoverage_TransitionNode> = {
  encode(message: TransitionCoverage_TransitionNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== undefined) {
      Page.encode(message.page, writer.uint32(10).fork()).join();
    }
    if (message.flow !== undefined) {
      Flow.encode(message.flow, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionCoverage_TransitionNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionCoverage_TransitionNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.page = Page.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.flow = Flow.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitionCoverage_TransitionNode {
    return {
      page: isSet(object.page) ? Page.fromJSON(object.page) : undefined,
      flow: isSet(object.flow) ? Flow.fromJSON(object.flow) : undefined,
    };
  },

  toJSON(message: TransitionCoverage_TransitionNode): unknown {
    const obj: any = {};
    if (message.page !== undefined) {
      obj.page = Page.toJSON(message.page);
    }
    if (message.flow !== undefined) {
      obj.flow = Flow.toJSON(message.flow);
    }
    return obj;
  },

  create(base?: DeepPartial<TransitionCoverage_TransitionNode>): TransitionCoverage_TransitionNode {
    return TransitionCoverage_TransitionNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransitionCoverage_TransitionNode>): TransitionCoverage_TransitionNode {
    const message = createBaseTransitionCoverage_TransitionNode();
    message.page = (object.page !== undefined && object.page !== null) ? Page.fromPartial(object.page) : undefined;
    message.flow = (object.flow !== undefined && object.flow !== null) ? Flow.fromPartial(object.flow) : undefined;
    return message;
  },
};

function createBaseTransitionCoverage_Transition(): TransitionCoverage_Transition {
  return {
    source: undefined,
    index: 0,
    target: undefined,
    covered: false,
    transitionRoute: undefined,
    eventHandler: undefined,
  };
}

export const TransitionCoverage_Transition: MessageFns<TransitionCoverage_Transition> = {
  encode(message: TransitionCoverage_Transition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      TransitionCoverage_TransitionNode.encode(message.source, writer.uint32(10).fork()).join();
    }
    if (message.index !== 0) {
      writer.uint32(32).int32(message.index);
    }
    if (message.target !== undefined) {
      TransitionCoverage_TransitionNode.encode(message.target, writer.uint32(18).fork()).join();
    }
    if (message.covered !== false) {
      writer.uint32(24).bool(message.covered);
    }
    if (message.transitionRoute !== undefined) {
      TransitionRoute.encode(message.transitionRoute, writer.uint32(42).fork()).join();
    }
    if (message.eventHandler !== undefined) {
      EventHandler.encode(message.eventHandler, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionCoverage_Transition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionCoverage_Transition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = TransitionCoverage_TransitionNode.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.target = TransitionCoverage_TransitionNode.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.covered = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transitionRoute = TransitionRoute.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.eventHandler = EventHandler.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitionCoverage_Transition {
    return {
      source: isSet(object.source) ? TransitionCoverage_TransitionNode.fromJSON(object.source) : undefined,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      target: isSet(object.target) ? TransitionCoverage_TransitionNode.fromJSON(object.target) : undefined,
      covered: isSet(object.covered) ? globalThis.Boolean(object.covered) : false,
      transitionRoute: isSet(object.transitionRoute) ? TransitionRoute.fromJSON(object.transitionRoute) : undefined,
      eventHandler: isSet(object.eventHandler) ? EventHandler.fromJSON(object.eventHandler) : undefined,
    };
  },

  toJSON(message: TransitionCoverage_Transition): unknown {
    const obj: any = {};
    if (message.source !== undefined) {
      obj.source = TransitionCoverage_TransitionNode.toJSON(message.source);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.target !== undefined) {
      obj.target = TransitionCoverage_TransitionNode.toJSON(message.target);
    }
    if (message.covered !== false) {
      obj.covered = message.covered;
    }
    if (message.transitionRoute !== undefined) {
      obj.transitionRoute = TransitionRoute.toJSON(message.transitionRoute);
    }
    if (message.eventHandler !== undefined) {
      obj.eventHandler = EventHandler.toJSON(message.eventHandler);
    }
    return obj;
  },

  create(base?: DeepPartial<TransitionCoverage_Transition>): TransitionCoverage_Transition {
    return TransitionCoverage_Transition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransitionCoverage_Transition>): TransitionCoverage_Transition {
    const message = createBaseTransitionCoverage_Transition();
    message.source = (object.source !== undefined && object.source !== null)
      ? TransitionCoverage_TransitionNode.fromPartial(object.source)
      : undefined;
    message.index = object.index ?? 0;
    message.target = (object.target !== undefined && object.target !== null)
      ? TransitionCoverage_TransitionNode.fromPartial(object.target)
      : undefined;
    message.covered = object.covered ?? false;
    message.transitionRoute = (object.transitionRoute !== undefined && object.transitionRoute !== null)
      ? TransitionRoute.fromPartial(object.transitionRoute)
      : undefined;
    message.eventHandler = (object.eventHandler !== undefined && object.eventHandler !== null)
      ? EventHandler.fromPartial(object.eventHandler)
      : undefined;
    return message;
  },
};

function createBaseTransitionRouteGroupCoverage(): TransitionRouteGroupCoverage {
  return { coverages: [], coverageScore: 0 };
}

export const TransitionRouteGroupCoverage: MessageFns<TransitionRouteGroupCoverage> = {
  encode(message: TransitionRouteGroupCoverage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.coverages) {
      TransitionRouteGroupCoverage_Coverage.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.coverageScore !== 0) {
      writer.uint32(21).float(message.coverageScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionRouteGroupCoverage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionRouteGroupCoverage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.coverages.push(TransitionRouteGroupCoverage_Coverage.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.coverageScore = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitionRouteGroupCoverage {
    return {
      coverages: globalThis.Array.isArray(object?.coverages)
        ? object.coverages.map((e: any) => TransitionRouteGroupCoverage_Coverage.fromJSON(e))
        : [],
      coverageScore: isSet(object.coverageScore) ? globalThis.Number(object.coverageScore) : 0,
    };
  },

  toJSON(message: TransitionRouteGroupCoverage): unknown {
    const obj: any = {};
    if (message.coverages?.length) {
      obj.coverages = message.coverages.map((e) => TransitionRouteGroupCoverage_Coverage.toJSON(e));
    }
    if (message.coverageScore !== 0) {
      obj.coverageScore = message.coverageScore;
    }
    return obj;
  },

  create(base?: DeepPartial<TransitionRouteGroupCoverage>): TransitionRouteGroupCoverage {
    return TransitionRouteGroupCoverage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransitionRouteGroupCoverage>): TransitionRouteGroupCoverage {
    const message = createBaseTransitionRouteGroupCoverage();
    message.coverages = object.coverages?.map((e) => TransitionRouteGroupCoverage_Coverage.fromPartial(e)) || [];
    message.coverageScore = object.coverageScore ?? 0;
    return message;
  },
};

function createBaseTransitionRouteGroupCoverage_Coverage(): TransitionRouteGroupCoverage_Coverage {
  return { routeGroup: undefined, transitions: [], coverageScore: 0 };
}

export const TransitionRouteGroupCoverage_Coverage: MessageFns<TransitionRouteGroupCoverage_Coverage> = {
  encode(message: TransitionRouteGroupCoverage_Coverage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routeGroup !== undefined) {
      TransitionRouteGroup.encode(message.routeGroup, writer.uint32(10).fork()).join();
    }
    for (const v of message.transitions) {
      TransitionRouteGroupCoverage_Coverage_Transition.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.coverageScore !== 0) {
      writer.uint32(29).float(message.coverageScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionRouteGroupCoverage_Coverage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionRouteGroupCoverage_Coverage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.routeGroup = TransitionRouteGroup.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transitions.push(TransitionRouteGroupCoverage_Coverage_Transition.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.coverageScore = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitionRouteGroupCoverage_Coverage {
    return {
      routeGroup: isSet(object.routeGroup) ? TransitionRouteGroup.fromJSON(object.routeGroup) : undefined,
      transitions: globalThis.Array.isArray(object?.transitions)
        ? object.transitions.map((e: any) => TransitionRouteGroupCoverage_Coverage_Transition.fromJSON(e))
        : [],
      coverageScore: isSet(object.coverageScore) ? globalThis.Number(object.coverageScore) : 0,
    };
  },

  toJSON(message: TransitionRouteGroupCoverage_Coverage): unknown {
    const obj: any = {};
    if (message.routeGroup !== undefined) {
      obj.routeGroup = TransitionRouteGroup.toJSON(message.routeGroup);
    }
    if (message.transitions?.length) {
      obj.transitions = message.transitions.map((e) => TransitionRouteGroupCoverage_Coverage_Transition.toJSON(e));
    }
    if (message.coverageScore !== 0) {
      obj.coverageScore = message.coverageScore;
    }
    return obj;
  },

  create(base?: DeepPartial<TransitionRouteGroupCoverage_Coverage>): TransitionRouteGroupCoverage_Coverage {
    return TransitionRouteGroupCoverage_Coverage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransitionRouteGroupCoverage_Coverage>): TransitionRouteGroupCoverage_Coverage {
    const message = createBaseTransitionRouteGroupCoverage_Coverage();
    message.routeGroup = (object.routeGroup !== undefined && object.routeGroup !== null)
      ? TransitionRouteGroup.fromPartial(object.routeGroup)
      : undefined;
    message.transitions =
      object.transitions?.map((e) => TransitionRouteGroupCoverage_Coverage_Transition.fromPartial(e)) || [];
    message.coverageScore = object.coverageScore ?? 0;
    return message;
  },
};

function createBaseTransitionRouteGroupCoverage_Coverage_Transition(): TransitionRouteGroupCoverage_Coverage_Transition {
  return { transitionRoute: undefined, covered: false };
}

export const TransitionRouteGroupCoverage_Coverage_Transition: MessageFns<
  TransitionRouteGroupCoverage_Coverage_Transition
> = {
  encode(
    message: TransitionRouteGroupCoverage_Coverage_Transition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transitionRoute !== undefined) {
      TransitionRoute.encode(message.transitionRoute, writer.uint32(10).fork()).join();
    }
    if (message.covered !== false) {
      writer.uint32(16).bool(message.covered);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionRouteGroupCoverage_Coverage_Transition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionRouteGroupCoverage_Coverage_Transition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transitionRoute = TransitionRoute.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.covered = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitionRouteGroupCoverage_Coverage_Transition {
    return {
      transitionRoute: isSet(object.transitionRoute) ? TransitionRoute.fromJSON(object.transitionRoute) : undefined,
      covered: isSet(object.covered) ? globalThis.Boolean(object.covered) : false,
    };
  },

  toJSON(message: TransitionRouteGroupCoverage_Coverage_Transition): unknown {
    const obj: any = {};
    if (message.transitionRoute !== undefined) {
      obj.transitionRoute = TransitionRoute.toJSON(message.transitionRoute);
    }
    if (message.covered !== false) {
      obj.covered = message.covered;
    }
    return obj;
  },

  create(
    base?: DeepPartial<TransitionRouteGroupCoverage_Coverage_Transition>,
  ): TransitionRouteGroupCoverage_Coverage_Transition {
    return TransitionRouteGroupCoverage_Coverage_Transition.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<TransitionRouteGroupCoverage_Coverage_Transition>,
  ): TransitionRouteGroupCoverage_Coverage_Transition {
    const message = createBaseTransitionRouteGroupCoverage_Coverage_Transition();
    message.transitionRoute = (object.transitionRoute !== undefined && object.transitionRoute !== null)
      ? TransitionRoute.fromPartial(object.transitionRoute)
      : undefined;
    message.covered = object.covered ?? false;
    return message;
  },
};

function createBaseIntentCoverage(): IntentCoverage {
  return { intents: [], coverageScore: 0 };
}

export const IntentCoverage: MessageFns<IntentCoverage> = {
  encode(message: IntentCoverage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.intents) {
      IntentCoverage_Intent.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.coverageScore !== 0) {
      writer.uint32(21).float(message.coverageScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntentCoverage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntentCoverage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intents.push(IntentCoverage_Intent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.coverageScore = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntentCoverage {
    return {
      intents: globalThis.Array.isArray(object?.intents)
        ? object.intents.map((e: any) => IntentCoverage_Intent.fromJSON(e))
        : [],
      coverageScore: isSet(object.coverageScore) ? globalThis.Number(object.coverageScore) : 0,
    };
  },

  toJSON(message: IntentCoverage): unknown {
    const obj: any = {};
    if (message.intents?.length) {
      obj.intents = message.intents.map((e) => IntentCoverage_Intent.toJSON(e));
    }
    if (message.coverageScore !== 0) {
      obj.coverageScore = message.coverageScore;
    }
    return obj;
  },

  create(base?: DeepPartial<IntentCoverage>): IntentCoverage {
    return IntentCoverage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntentCoverage>): IntentCoverage {
    const message = createBaseIntentCoverage();
    message.intents = object.intents?.map((e) => IntentCoverage_Intent.fromPartial(e)) || [];
    message.coverageScore = object.coverageScore ?? 0;
    return message;
  },
};

function createBaseIntentCoverage_Intent(): IntentCoverage_Intent {
  return { intent: "", covered: false };
}

export const IntentCoverage_Intent: MessageFns<IntentCoverage_Intent> = {
  encode(message: IntentCoverage_Intent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intent !== "") {
      writer.uint32(10).string(message.intent);
    }
    if (message.covered !== false) {
      writer.uint32(16).bool(message.covered);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntentCoverage_Intent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntentCoverage_Intent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.covered = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntentCoverage_Intent {
    return {
      intent: isSet(object.intent) ? globalThis.String(object.intent) : "",
      covered: isSet(object.covered) ? globalThis.Boolean(object.covered) : false,
    };
  },

  toJSON(message: IntentCoverage_Intent): unknown {
    const obj: any = {};
    if (message.intent !== "") {
      obj.intent = message.intent;
    }
    if (message.covered !== false) {
      obj.covered = message.covered;
    }
    return obj;
  },

  create(base?: DeepPartial<IntentCoverage_Intent>): IntentCoverage_Intent {
    return IntentCoverage_Intent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntentCoverage_Intent>): IntentCoverage_Intent {
    const message = createBaseIntentCoverage_Intent();
    message.intent = object.intent ?? "";
    message.covered = object.covered ?? false;
    return message;
  },
};

function createBaseCalculateCoverageRequest(): CalculateCoverageRequest {
  return { agent: "", type: 0 };
}

export const CalculateCoverageRequest: MessageFns<CalculateCoverageRequest> = {
  encode(message: CalculateCoverageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agent !== "") {
      writer.uint32(26).string(message.agent);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculateCoverageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculateCoverageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.agent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CalculateCoverageRequest {
    return {
      agent: isSet(object.agent) ? globalThis.String(object.agent) : "",
      type: isSet(object.type) ? calculateCoverageRequest_CoverageTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: CalculateCoverageRequest): unknown {
    const obj: any = {};
    if (message.agent !== "") {
      obj.agent = message.agent;
    }
    if (message.type !== 0) {
      obj.type = calculateCoverageRequest_CoverageTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<CalculateCoverageRequest>): CalculateCoverageRequest {
    return CalculateCoverageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CalculateCoverageRequest>): CalculateCoverageRequest {
    const message = createBaseCalculateCoverageRequest();
    message.agent = object.agent ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseCalculateCoverageResponse(): CalculateCoverageResponse {
  return { agent: "", intentCoverage: undefined, transitionCoverage: undefined, routeGroupCoverage: undefined };
}

export const CalculateCoverageResponse: MessageFns<CalculateCoverageResponse> = {
  encode(message: CalculateCoverageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agent !== "") {
      writer.uint32(42).string(message.agent);
    }
    if (message.intentCoverage !== undefined) {
      IntentCoverage.encode(message.intentCoverage, writer.uint32(18).fork()).join();
    }
    if (message.transitionCoverage !== undefined) {
      TransitionCoverage.encode(message.transitionCoverage, writer.uint32(34).fork()).join();
    }
    if (message.routeGroupCoverage !== undefined) {
      TransitionRouteGroupCoverage.encode(message.routeGroupCoverage, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculateCoverageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculateCoverageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.agent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.intentCoverage = IntentCoverage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transitionCoverage = TransitionCoverage.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.routeGroupCoverage = TransitionRouteGroupCoverage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CalculateCoverageResponse {
    return {
      agent: isSet(object.agent) ? globalThis.String(object.agent) : "",
      intentCoverage: isSet(object.intentCoverage) ? IntentCoverage.fromJSON(object.intentCoverage) : undefined,
      transitionCoverage: isSet(object.transitionCoverage)
        ? TransitionCoverage.fromJSON(object.transitionCoverage)
        : undefined,
      routeGroupCoverage: isSet(object.routeGroupCoverage)
        ? TransitionRouteGroupCoverage.fromJSON(object.routeGroupCoverage)
        : undefined,
    };
  },

  toJSON(message: CalculateCoverageResponse): unknown {
    const obj: any = {};
    if (message.agent !== "") {
      obj.agent = message.agent;
    }
    if (message.intentCoverage !== undefined) {
      obj.intentCoverage = IntentCoverage.toJSON(message.intentCoverage);
    }
    if (message.transitionCoverage !== undefined) {
      obj.transitionCoverage = TransitionCoverage.toJSON(message.transitionCoverage);
    }
    if (message.routeGroupCoverage !== undefined) {
      obj.routeGroupCoverage = TransitionRouteGroupCoverage.toJSON(message.routeGroupCoverage);
    }
    return obj;
  },

  create(base?: DeepPartial<CalculateCoverageResponse>): CalculateCoverageResponse {
    return CalculateCoverageResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CalculateCoverageResponse>): CalculateCoverageResponse {
    const message = createBaseCalculateCoverageResponse();
    message.agent = object.agent ?? "";
    message.intentCoverage = (object.intentCoverage !== undefined && object.intentCoverage !== null)
      ? IntentCoverage.fromPartial(object.intentCoverage)
      : undefined;
    message.transitionCoverage = (object.transitionCoverage !== undefined && object.transitionCoverage !== null)
      ? TransitionCoverage.fromPartial(object.transitionCoverage)
      : undefined;
    message.routeGroupCoverage = (object.routeGroupCoverage !== undefined && object.routeGroupCoverage !== null)
      ? TransitionRouteGroupCoverage.fromPartial(object.routeGroupCoverage)
      : undefined;
    return message;
  },
};

function createBaseListTestCasesRequest(): ListTestCasesRequest {
  return { parent: "", pageSize: 0, pageToken: "", view: 0 };
}

export const ListTestCasesRequest: MessageFns<ListTestCasesRequest> = {
  encode(message: ListTestCasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.view !== 0) {
      writer.uint32(32).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTestCasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTestCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTestCasesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      view: isSet(object.view) ? listTestCasesRequest_TestCaseViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: ListTestCasesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.view !== 0) {
      obj.view = listTestCasesRequest_TestCaseViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<ListTestCasesRequest>): ListTestCasesRequest {
    return ListTestCasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTestCasesRequest>): ListTestCasesRequest {
    const message = createBaseListTestCasesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListTestCasesResponse(): ListTestCasesResponse {
  return { testCases: [], nextPageToken: "" };
}

export const ListTestCasesResponse: MessageFns<ListTestCasesResponse> = {
  encode(message: ListTestCasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.testCases) {
      TestCase.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTestCasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTestCasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testCases.push(TestCase.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTestCasesResponse {
    return {
      testCases: globalThis.Array.isArray(object?.testCases)
        ? object.testCases.map((e: any) => TestCase.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTestCasesResponse): unknown {
    const obj: any = {};
    if (message.testCases?.length) {
      obj.testCases = message.testCases.map((e) => TestCase.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTestCasesResponse>): ListTestCasesResponse {
    return ListTestCasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTestCasesResponse>): ListTestCasesResponse {
    const message = createBaseListTestCasesResponse();
    message.testCases = object.testCases?.map((e) => TestCase.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseBatchDeleteTestCasesRequest(): BatchDeleteTestCasesRequest {
  return { parent: "", names: [] };
}

export const BatchDeleteTestCasesRequest: MessageFns<BatchDeleteTestCasesRequest> = {
  encode(message: BatchDeleteTestCasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.names) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDeleteTestCasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeleteTestCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.names.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeleteTestCasesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BatchDeleteTestCasesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.names?.length) {
      obj.names = message.names;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeleteTestCasesRequest>): BatchDeleteTestCasesRequest {
    return BatchDeleteTestCasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeleteTestCasesRequest>): BatchDeleteTestCasesRequest {
    const message = createBaseBatchDeleteTestCasesRequest();
    message.parent = object.parent ?? "";
    message.names = object.names?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateTestCaseRequest(): CreateTestCaseRequest {
  return { parent: "", testCase: undefined };
}

export const CreateTestCaseRequest: MessageFns<CreateTestCaseRequest> = {
  encode(message: CreateTestCaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.testCase !== undefined) {
      TestCase.encode(message.testCase, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTestCaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTestCaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.testCase = TestCase.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTestCaseRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      testCase: isSet(object.testCase) ? TestCase.fromJSON(object.testCase) : undefined,
    };
  },

  toJSON(message: CreateTestCaseRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.testCase !== undefined) {
      obj.testCase = TestCase.toJSON(message.testCase);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTestCaseRequest>): CreateTestCaseRequest {
    return CreateTestCaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTestCaseRequest>): CreateTestCaseRequest {
    const message = createBaseCreateTestCaseRequest();
    message.parent = object.parent ?? "";
    message.testCase = (object.testCase !== undefined && object.testCase !== null)
      ? TestCase.fromPartial(object.testCase)
      : undefined;
    return message;
  },
};

function createBaseUpdateTestCaseRequest(): UpdateTestCaseRequest {
  return { testCase: undefined, updateMask: undefined };
}

export const UpdateTestCaseRequest: MessageFns<UpdateTestCaseRequest> = {
  encode(message: UpdateTestCaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testCase !== undefined) {
      TestCase.encode(message.testCase, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTestCaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTestCaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testCase = TestCase.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTestCaseRequest {
    return {
      testCase: isSet(object.testCase) ? TestCase.fromJSON(object.testCase) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateTestCaseRequest): unknown {
    const obj: any = {};
    if (message.testCase !== undefined) {
      obj.testCase = TestCase.toJSON(message.testCase);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTestCaseRequest>): UpdateTestCaseRequest {
    return UpdateTestCaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTestCaseRequest>): UpdateTestCaseRequest {
    const message = createBaseUpdateTestCaseRequest();
    message.testCase = (object.testCase !== undefined && object.testCase !== null)
      ? TestCase.fromPartial(object.testCase)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetTestCaseRequest(): GetTestCaseRequest {
  return { name: "" };
}

export const GetTestCaseRequest: MessageFns<GetTestCaseRequest> = {
  encode(message: GetTestCaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTestCaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestCaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestCaseRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTestCaseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTestCaseRequest>): GetTestCaseRequest {
    return GetTestCaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTestCaseRequest>): GetTestCaseRequest {
    const message = createBaseGetTestCaseRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRunTestCaseRequest(): RunTestCaseRequest {
  return { name: "", environment: "" };
}

export const RunTestCaseRequest: MessageFns<RunTestCaseRequest> = {
  encode(message: RunTestCaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.environment !== "") {
      writer.uint32(18).string(message.environment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunTestCaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunTestCaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.environment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunTestCaseRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
    };
  },

  toJSON(message: RunTestCaseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    return obj;
  },

  create(base?: DeepPartial<RunTestCaseRequest>): RunTestCaseRequest {
    return RunTestCaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunTestCaseRequest>): RunTestCaseRequest {
    const message = createBaseRunTestCaseRequest();
    message.name = object.name ?? "";
    message.environment = object.environment ?? "";
    return message;
  },
};

function createBaseRunTestCaseResponse(): RunTestCaseResponse {
  return { result: undefined };
}

export const RunTestCaseResponse: MessageFns<RunTestCaseResponse> = {
  encode(message: RunTestCaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      TestCaseResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunTestCaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunTestCaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result = TestCaseResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunTestCaseResponse {
    return { result: isSet(object.result) ? TestCaseResult.fromJSON(object.result) : undefined };
  },

  toJSON(message: RunTestCaseResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = TestCaseResult.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<RunTestCaseResponse>): RunTestCaseResponse {
    return RunTestCaseResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunTestCaseResponse>): RunTestCaseResponse {
    const message = createBaseRunTestCaseResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? TestCaseResult.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseRunTestCaseMetadata(): RunTestCaseMetadata {
  return {};
}

export const RunTestCaseMetadata: MessageFns<RunTestCaseMetadata> = {
  encode(_: RunTestCaseMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunTestCaseMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunTestCaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RunTestCaseMetadata {
    return {};
  },

  toJSON(_: RunTestCaseMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RunTestCaseMetadata>): RunTestCaseMetadata {
    return RunTestCaseMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RunTestCaseMetadata>): RunTestCaseMetadata {
    const message = createBaseRunTestCaseMetadata();
    return message;
  },
};

function createBaseBatchRunTestCasesRequest(): BatchRunTestCasesRequest {
  return { parent: "", environment: "", testCases: [] };
}

export const BatchRunTestCasesRequest: MessageFns<BatchRunTestCasesRequest> = {
  encode(message: BatchRunTestCasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.environment !== "") {
      writer.uint32(18).string(message.environment);
    }
    for (const v of message.testCases) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchRunTestCasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchRunTestCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.environment = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.testCases.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchRunTestCasesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      testCases: globalThis.Array.isArray(object?.testCases)
        ? object.testCases.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: BatchRunTestCasesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.testCases?.length) {
      obj.testCases = message.testCases;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchRunTestCasesRequest>): BatchRunTestCasesRequest {
    return BatchRunTestCasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchRunTestCasesRequest>): BatchRunTestCasesRequest {
    const message = createBaseBatchRunTestCasesRequest();
    message.parent = object.parent ?? "";
    message.environment = object.environment ?? "";
    message.testCases = object.testCases?.map((e) => e) || [];
    return message;
  },
};

function createBaseBatchRunTestCasesResponse(): BatchRunTestCasesResponse {
  return { results: [] };
}

export const BatchRunTestCasesResponse: MessageFns<BatchRunTestCasesResponse> = {
  encode(message: BatchRunTestCasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      TestCaseResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchRunTestCasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchRunTestCasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(TestCaseResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchRunTestCasesResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => TestCaseResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchRunTestCasesResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => TestCaseResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchRunTestCasesResponse>): BatchRunTestCasesResponse {
    return BatchRunTestCasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchRunTestCasesResponse>): BatchRunTestCasesResponse {
    const message = createBaseBatchRunTestCasesResponse();
    message.results = object.results?.map((e) => TestCaseResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchRunTestCasesMetadata(): BatchRunTestCasesMetadata {
  return { errors: [] };
}

export const BatchRunTestCasesMetadata: MessageFns<BatchRunTestCasesMetadata> = {
  encode(message: BatchRunTestCasesMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errors) {
      TestError.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchRunTestCasesMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchRunTestCasesMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errors.push(TestError.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchRunTestCasesMetadata {
    return {
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => TestError.fromJSON(e)) : [],
    };
  },

  toJSON(message: BatchRunTestCasesMetadata): unknown {
    const obj: any = {};
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => TestError.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchRunTestCasesMetadata>): BatchRunTestCasesMetadata {
    return BatchRunTestCasesMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchRunTestCasesMetadata>): BatchRunTestCasesMetadata {
    const message = createBaseBatchRunTestCasesMetadata();
    message.errors = object.errors?.map((e) => TestError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTestError(): TestError {
  return { testCase: "", status: undefined, testTime: undefined };
}

export const TestError: MessageFns<TestError> = {
  encode(message: TestError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testCase !== "") {
      writer.uint32(10).string(message.testCase);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).join();
    }
    if (message.testTime !== undefined) {
      Timestamp.encode(toTimestamp(message.testTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testCase = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.testTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestError {
    return {
      testCase: isSet(object.testCase) ? globalThis.String(object.testCase) : "",
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      testTime: isSet(object.testTime) ? fromJsonTimestamp(object.testTime) : undefined,
    };
  },

  toJSON(message: TestError): unknown {
    const obj: any = {};
    if (message.testCase !== "") {
      obj.testCase = message.testCase;
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.testTime !== undefined) {
      obj.testTime = message.testTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TestError>): TestError {
    return TestError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestError>): TestError {
    const message = createBaseTestError();
    message.testCase = object.testCase ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.testTime = object.testTime ?? undefined;
    return message;
  },
};

function createBaseImportTestCasesRequest(): ImportTestCasesRequest {
  return { parent: "", gcsUri: undefined, content: undefined };
}

export const ImportTestCasesRequest: MessageFns<ImportTestCasesRequest> = {
  encode(message: ImportTestCasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.gcsUri !== undefined) {
      writer.uint32(18).string(message.gcsUri);
    }
    if (message.content !== undefined) {
      writer.uint32(26).bytes(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportTestCasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportTestCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcsUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportTestCasesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      gcsUri: isSet(object.gcsUri) ? globalThis.String(object.gcsUri) : undefined,
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : undefined,
    };
  },

  toJSON(message: ImportTestCasesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.gcsUri !== undefined) {
      obj.gcsUri = message.gcsUri;
    }
    if (message.content !== undefined) {
      obj.content = base64FromBytes(message.content);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportTestCasesRequest>): ImportTestCasesRequest {
    return ImportTestCasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportTestCasesRequest>): ImportTestCasesRequest {
    const message = createBaseImportTestCasesRequest();
    message.parent = object.parent ?? "";
    message.gcsUri = object.gcsUri ?? undefined;
    message.content = object.content ?? undefined;
    return message;
  },
};

function createBaseImportTestCasesResponse(): ImportTestCasesResponse {
  return { names: [] };
}

export const ImportTestCasesResponse: MessageFns<ImportTestCasesResponse> = {
  encode(message: ImportTestCasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.names) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportTestCasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportTestCasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.names.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportTestCasesResponse {
    return { names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: ImportTestCasesResponse): unknown {
    const obj: any = {};
    if (message.names?.length) {
      obj.names = message.names;
    }
    return obj;
  },

  create(base?: DeepPartial<ImportTestCasesResponse>): ImportTestCasesResponse {
    return ImportTestCasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportTestCasesResponse>): ImportTestCasesResponse {
    const message = createBaseImportTestCasesResponse();
    message.names = object.names?.map((e) => e) || [];
    return message;
  },
};

function createBaseImportTestCasesMetadata(): ImportTestCasesMetadata {
  return { errors: [] };
}

export const ImportTestCasesMetadata: MessageFns<ImportTestCasesMetadata> = {
  encode(message: ImportTestCasesMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errors) {
      TestCaseError.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportTestCasesMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportTestCasesMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errors.push(TestCaseError.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportTestCasesMetadata {
    return {
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => TestCaseError.fromJSON(e)) : [],
    };
  },

  toJSON(message: ImportTestCasesMetadata): unknown {
    const obj: any = {};
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => TestCaseError.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ImportTestCasesMetadata>): ImportTestCasesMetadata {
    return ImportTestCasesMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportTestCasesMetadata>): ImportTestCasesMetadata {
    const message = createBaseImportTestCasesMetadata();
    message.errors = object.errors?.map((e) => TestCaseError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTestCaseError(): TestCaseError {
  return { testCase: undefined, status: undefined };
}

export const TestCaseError: MessageFns<TestCaseError> = {
  encode(message: TestCaseError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testCase !== undefined) {
      TestCase.encode(message.testCase, writer.uint32(10).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCaseError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testCase = TestCase.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCaseError {
    return {
      testCase: isSet(object.testCase) ? TestCase.fromJSON(object.testCase) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: TestCaseError): unknown {
    const obj: any = {};
    if (message.testCase !== undefined) {
      obj.testCase = TestCase.toJSON(message.testCase);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<TestCaseError>): TestCaseError {
    return TestCaseError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TestCaseError>): TestCaseError {
    const message = createBaseTestCaseError();
    message.testCase = (object.testCase !== undefined && object.testCase !== null)
      ? TestCase.fromPartial(object.testCase)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseExportTestCasesRequest(): ExportTestCasesRequest {
  return { parent: "", gcsUri: undefined, dataFormat: 0, filter: "" };
}

export const ExportTestCasesRequest: MessageFns<ExportTestCasesRequest> = {
  encode(message: ExportTestCasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.gcsUri !== undefined) {
      writer.uint32(18).string(message.gcsUri);
    }
    if (message.dataFormat !== 0) {
      writer.uint32(24).int32(message.dataFormat);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportTestCasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportTestCasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcsUri = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dataFormat = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportTestCasesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      gcsUri: isSet(object.gcsUri) ? globalThis.String(object.gcsUri) : undefined,
      dataFormat: isSet(object.dataFormat) ? exportTestCasesRequest_DataFormatFromJSON(object.dataFormat) : 0,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ExportTestCasesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.gcsUri !== undefined) {
      obj.gcsUri = message.gcsUri;
    }
    if (message.dataFormat !== 0) {
      obj.dataFormat = exportTestCasesRequest_DataFormatToJSON(message.dataFormat);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportTestCasesRequest>): ExportTestCasesRequest {
    return ExportTestCasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportTestCasesRequest>): ExportTestCasesRequest {
    const message = createBaseExportTestCasesRequest();
    message.parent = object.parent ?? "";
    message.gcsUri = object.gcsUri ?? undefined;
    message.dataFormat = object.dataFormat ?? 0;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseExportTestCasesResponse(): ExportTestCasesResponse {
  return { gcsUri: undefined, content: undefined };
}

export const ExportTestCasesResponse: MessageFns<ExportTestCasesResponse> = {
  encode(message: ExportTestCasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsUri !== undefined) {
      writer.uint32(10).string(message.gcsUri);
    }
    if (message.content !== undefined) {
      writer.uint32(18).bytes(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportTestCasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportTestCasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportTestCasesResponse {
    return {
      gcsUri: isSet(object.gcsUri) ? globalThis.String(object.gcsUri) : undefined,
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : undefined,
    };
  },

  toJSON(message: ExportTestCasesResponse): unknown {
    const obj: any = {};
    if (message.gcsUri !== undefined) {
      obj.gcsUri = message.gcsUri;
    }
    if (message.content !== undefined) {
      obj.content = base64FromBytes(message.content);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportTestCasesResponse>): ExportTestCasesResponse {
    return ExportTestCasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportTestCasesResponse>): ExportTestCasesResponse {
    const message = createBaseExportTestCasesResponse();
    message.gcsUri = object.gcsUri ?? undefined;
    message.content = object.content ?? undefined;
    return message;
  },
};

function createBaseExportTestCasesMetadata(): ExportTestCasesMetadata {
  return {};
}

export const ExportTestCasesMetadata: MessageFns<ExportTestCasesMetadata> = {
  encode(_: ExportTestCasesMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportTestCasesMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportTestCasesMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ExportTestCasesMetadata {
    return {};
  },

  toJSON(_: ExportTestCasesMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ExportTestCasesMetadata>): ExportTestCasesMetadata {
    return ExportTestCasesMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ExportTestCasesMetadata>): ExportTestCasesMetadata {
    const message = createBaseExportTestCasesMetadata();
    return message;
  },
};

function createBaseListTestCaseResultsRequest(): ListTestCaseResultsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListTestCaseResultsRequest: MessageFns<ListTestCaseResultsRequest> = {
  encode(message: ListTestCaseResultsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTestCaseResultsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTestCaseResultsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTestCaseResultsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListTestCaseResultsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTestCaseResultsRequest>): ListTestCaseResultsRequest {
    return ListTestCaseResultsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTestCaseResultsRequest>): ListTestCaseResultsRequest {
    const message = createBaseListTestCaseResultsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListTestCaseResultsResponse(): ListTestCaseResultsResponse {
  return { testCaseResults: [], nextPageToken: "" };
}

export const ListTestCaseResultsResponse: MessageFns<ListTestCaseResultsResponse> = {
  encode(message: ListTestCaseResultsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.testCaseResults) {
      TestCaseResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTestCaseResultsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTestCaseResultsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.testCaseResults.push(TestCaseResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTestCaseResultsResponse {
    return {
      testCaseResults: globalThis.Array.isArray(object?.testCaseResults)
        ? object.testCaseResults.map((e: any) => TestCaseResult.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTestCaseResultsResponse): unknown {
    const obj: any = {};
    if (message.testCaseResults?.length) {
      obj.testCaseResults = message.testCaseResults.map((e) => TestCaseResult.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTestCaseResultsResponse>): ListTestCaseResultsResponse {
    return ListTestCaseResultsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTestCaseResultsResponse>): ListTestCaseResultsResponse {
    const message = createBaseListTestCaseResultsResponse();
    message.testCaseResults = object.testCaseResults?.map((e) => TestCaseResult.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetTestCaseResultRequest(): GetTestCaseResultRequest {
  return { name: "" };
}

export const GetTestCaseResultRequest: MessageFns<GetTestCaseResultRequest> = {
  encode(message: GetTestCaseResultRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTestCaseResultRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTestCaseResultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTestCaseResultRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTestCaseResultRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTestCaseResultRequest>): GetTestCaseResultRequest {
    return GetTestCaseResultRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTestCaseResultRequest>): GetTestCaseResultRequest {
    const message = createBaseGetTestCaseResultRequest();
    message.name = object.name ?? "";
    return message;
  },
};

/**
 * Service for managing [Test
 * Cases][google.cloud.dialogflow.cx.v3beta1.TestCase] and [Test Case
 * Results][google.cloud.dialogflow.cx.v3beta1.TestCaseResult].
 */
export type TestCasesDefinition = typeof TestCasesDefinition;
export const TestCasesDefinition = {
  name: "TestCases",
  fullName: "google.cloud.dialogflow.cx.v3beta1.TestCases",
  methods: {
    /** Fetches a list of test cases for a given agent. */
    listTestCases: {
      name: "ListTestCases",
      requestType: ListTestCasesRequest,
      requestStream: false,
      responseType: ListTestCasesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              116,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Batch deletes test cases. */
    batchDeleteTestCases: {
      name: "BatchDeleteTestCases",
      requestType: BatchDeleteTestCasesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              76,
              58,
              1,
              42,
              34,
              71,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              116,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              68,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Gets a test case. */
    getTestCase: {
      name: "GetTestCase",
      requestType: GetTestCaseRequest,
      requestStream: false,
      responseType: TestCase,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a test case for the given agent. */
    createTestCase: {
      name: "CreateTestCase",
      requestType: CreateTestCaseRequest,
      requestStream: false,
      responseType: TestCase,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([16, 112, 97, 114, 101, 110, 116, 44, 116, 101, 115, 116, 95, 99, 97, 115, 101])],
          578365826: [
            Buffer.from([
              72,
              58,
              9,
              116,
              101,
              115,
              116,
              95,
              99,
              97,
              115,
              101,
              34,
              59,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              116,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the specified test case. */
    updateTestCase: {
      name: "UpdateTestCase",
      requestType: UpdateTestCaseRequest,
      requestStream: false,
      responseType: TestCase,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              116,
              101,
              115,
              116,
              95,
              99,
              97,
              115,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              82,
              58,
              9,
              116,
              101,
              115,
              116,
              95,
              99,
              97,
              115,
              101,
              50,
              69,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              116,
              101,
              115,
              116,
              95,
              99,
              97,
              115,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Kicks off a test case run.
     *
     * This method is a [long-running
     * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
     * The returned `Operation` type has the following method-specific fields:
     *
     * - `metadata`:
     * [RunTestCaseMetadata][google.cloud.dialogflow.cx.v3beta1.RunTestCaseMetadata]
     * - `response`:
     * [RunTestCaseResponse][google.cloud.dialogflow.cx.v3beta1.RunTestCaseResponse]
     */
    runTestCase: {
      name: "RunTestCase",
      requestType: RunTestCaseRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              19,
              82,
              117,
              110,
              84,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              19,
              82,
              117,
              110,
              84,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              117,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * Kicks off a batch run of test cases.
     *
     * This method is a [long-running
     * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
     * The returned `Operation` type has the following method-specific fields:
     *
     * - `metadata`:
     * [BatchRunTestCasesMetadata][google.cloud.dialogflow.cx.v3beta1.BatchRunTestCasesMetadata]
     * - `response`:
     * [BatchRunTestCasesResponse][google.cloud.dialogflow.cx.v3beta1.BatchRunTestCasesResponse]
     */
    batchRunTestCases: {
      name: "BatchRunTestCases",
      requestType: BatchRunTestCasesRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              54,
              10,
              25,
              66,
              97,
              116,
              99,
              104,
              82,
              117,
              110,
              84,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              25,
              66,
              97,
              116,
              99,
              104,
              82,
              117,
              110,
              84,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              73,
              58,
              1,
              42,
              34,
              68,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              116,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              82,
              117,
              110,
            ]),
          ],
        },
      },
    },
    /** Calculates the test coverage for an agent. */
    calculateCoverage: {
      name: "CalculateCoverage",
      requestType: CalculateCoverageRequest,
      requestStream: false,
      responseType: CalculateCoverageResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              78,
              18,
              76,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              97,
              103,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              116,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              58,
              99,
              97,
              108,
              99,
              117,
              108,
              97,
              116,
              101,
              67,
              111,
              118,
              101,
              114,
              97,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Imports the test cases from a Cloud Storage bucket or a local file. It
     * always creates new test cases and won't overwrite any existing ones. The
     * provided ID in the imported test case is neglected.
     *
     * This method is a [long-running
     * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
     * The returned `Operation` type has the following method-specific fields:
     *
     * - `metadata`:
     * [ImportTestCasesMetadata][google.cloud.dialogflow.cx.v3beta1.ImportTestCasesMetadata]
     * - `response`:
     * [ImportTestCasesResponse][google.cloud.dialogflow.cx.v3beta1.ImportTestCasesResponse]
     */
    importTestCases: {
      name: "ImportTestCases",
      requestType: ImportTestCasesRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              50,
              10,
              23,
              73,
              109,
              112,
              111,
              114,
              116,
              84,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              23,
              73,
              109,
              112,
              111,
              114,
              116,
              84,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              1,
              42,
              34,
              66,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              116,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              58,
              105,
              109,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Exports the test cases under the agent to a Cloud Storage bucket or a local
     * file. Filter can be applied to export a subset of test cases.
     *
     * This method is a [long-running
     * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
     * The returned `Operation` type has the following method-specific fields:
     *
     * - `metadata`:
     * [ExportTestCasesMetadata][google.cloud.dialogflow.cx.v3beta1.ExportTestCasesMetadata]
     * - `response`:
     * [ExportTestCasesResponse][google.cloud.dialogflow.cx.v3beta1.ExportTestCasesResponse]
     */
    exportTestCases: {
      name: "ExportTestCases",
      requestType: ExportTestCasesRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              50,
              10,
              23,
              69,
              120,
              112,
              111,
              114,
              116,
              84,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              23,
              69,
              120,
              112,
              111,
              114,
              116,
              84,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              1,
              42,
              34,
              66,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              116,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              58,
              101,
              120,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Fetches the list of run results for the given test case. A maximum of 100
     * results are kept for each test case.
     */
    listTestCaseResults: {
      name: "ListTestCaseResults",
      requestType: ListTestCaseResultsRequest,
      requestStream: false,
      responseType: ListTestCaseResultsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              71,
              18,
              69,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              115,
              117,
              108,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a test case result. */
    getTestCaseResult: {
      name: "GetTestCaseResult",
      requestType: GetTestCaseResultRequest,
      requestStream: false,
      responseType: TestCaseResult,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              71,
              18,
              69,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              116,
              101,
              115,
              116,
              67,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              115,
              117,
              108,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface TestCasesServiceImplementation<CallContextExt = {}> {
  /** Fetches a list of test cases for a given agent. */
  listTestCases(
    request: ListTestCasesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTestCasesResponse>>;
  /** Batch deletes test cases. */
  batchDeleteTestCases(
    request: BatchDeleteTestCasesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Gets a test case. */
  getTestCase(request: GetTestCaseRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TestCase>>;
  /** Creates a test case for the given agent. */
  createTestCase(request: CreateTestCaseRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TestCase>>;
  /** Updates the specified test case. */
  updateTestCase(request: UpdateTestCaseRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TestCase>>;
  /**
   * Kicks off a test case run.
   *
   * This method is a [long-running
   * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
   * The returned `Operation` type has the following method-specific fields:
   *
   * - `metadata`:
   * [RunTestCaseMetadata][google.cloud.dialogflow.cx.v3beta1.RunTestCaseMetadata]
   * - `response`:
   * [RunTestCaseResponse][google.cloud.dialogflow.cx.v3beta1.RunTestCaseResponse]
   */
  runTestCase(request: RunTestCaseRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Kicks off a batch run of test cases.
   *
   * This method is a [long-running
   * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
   * The returned `Operation` type has the following method-specific fields:
   *
   * - `metadata`:
   * [BatchRunTestCasesMetadata][google.cloud.dialogflow.cx.v3beta1.BatchRunTestCasesMetadata]
   * - `response`:
   * [BatchRunTestCasesResponse][google.cloud.dialogflow.cx.v3beta1.BatchRunTestCasesResponse]
   */
  batchRunTestCases(
    request: BatchRunTestCasesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Calculates the test coverage for an agent. */
  calculateCoverage(
    request: CalculateCoverageRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CalculateCoverageResponse>>;
  /**
   * Imports the test cases from a Cloud Storage bucket or a local file. It
   * always creates new test cases and won't overwrite any existing ones. The
   * provided ID in the imported test case is neglected.
   *
   * This method is a [long-running
   * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
   * The returned `Operation` type has the following method-specific fields:
   *
   * - `metadata`:
   * [ImportTestCasesMetadata][google.cloud.dialogflow.cx.v3beta1.ImportTestCasesMetadata]
   * - `response`:
   * [ImportTestCasesResponse][google.cloud.dialogflow.cx.v3beta1.ImportTestCasesResponse]
   */
  importTestCases(
    request: ImportTestCasesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Exports the test cases under the agent to a Cloud Storage bucket or a local
   * file. Filter can be applied to export a subset of test cases.
   *
   * This method is a [long-running
   * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
   * The returned `Operation` type has the following method-specific fields:
   *
   * - `metadata`:
   * [ExportTestCasesMetadata][google.cloud.dialogflow.cx.v3beta1.ExportTestCasesMetadata]
   * - `response`:
   * [ExportTestCasesResponse][google.cloud.dialogflow.cx.v3beta1.ExportTestCasesResponse]
   */
  exportTestCases(
    request: ExportTestCasesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Fetches the list of run results for the given test case. A maximum of 100
   * results are kept for each test case.
   */
  listTestCaseResults(
    request: ListTestCaseResultsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTestCaseResultsResponse>>;
  /** Gets a test case result. */
  getTestCaseResult(
    request: GetTestCaseResultRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestCaseResult>>;
}

export interface TestCasesClient<CallOptionsExt = {}> {
  /** Fetches a list of test cases for a given agent. */
  listTestCases(
    request: DeepPartial<ListTestCasesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTestCasesResponse>;
  /** Batch deletes test cases. */
  batchDeleteTestCases(
    request: DeepPartial<BatchDeleteTestCasesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Gets a test case. */
  getTestCase(request: DeepPartial<GetTestCaseRequest>, options?: CallOptions & CallOptionsExt): Promise<TestCase>;
  /** Creates a test case for the given agent. */
  createTestCase(
    request: DeepPartial<CreateTestCaseRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestCase>;
  /** Updates the specified test case. */
  updateTestCase(
    request: DeepPartial<UpdateTestCaseRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestCase>;
  /**
   * Kicks off a test case run.
   *
   * This method is a [long-running
   * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
   * The returned `Operation` type has the following method-specific fields:
   *
   * - `metadata`:
   * [RunTestCaseMetadata][google.cloud.dialogflow.cx.v3beta1.RunTestCaseMetadata]
   * - `response`:
   * [RunTestCaseResponse][google.cloud.dialogflow.cx.v3beta1.RunTestCaseResponse]
   */
  runTestCase(request: DeepPartial<RunTestCaseRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Kicks off a batch run of test cases.
   *
   * This method is a [long-running
   * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
   * The returned `Operation` type has the following method-specific fields:
   *
   * - `metadata`:
   * [BatchRunTestCasesMetadata][google.cloud.dialogflow.cx.v3beta1.BatchRunTestCasesMetadata]
   * - `response`:
   * [BatchRunTestCasesResponse][google.cloud.dialogflow.cx.v3beta1.BatchRunTestCasesResponse]
   */
  batchRunTestCases(
    request: DeepPartial<BatchRunTestCasesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Calculates the test coverage for an agent. */
  calculateCoverage(
    request: DeepPartial<CalculateCoverageRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CalculateCoverageResponse>;
  /**
   * Imports the test cases from a Cloud Storage bucket or a local file. It
   * always creates new test cases and won't overwrite any existing ones. The
   * provided ID in the imported test case is neglected.
   *
   * This method is a [long-running
   * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
   * The returned `Operation` type has the following method-specific fields:
   *
   * - `metadata`:
   * [ImportTestCasesMetadata][google.cloud.dialogflow.cx.v3beta1.ImportTestCasesMetadata]
   * - `response`:
   * [ImportTestCasesResponse][google.cloud.dialogflow.cx.v3beta1.ImportTestCasesResponse]
   */
  importTestCases(
    request: DeepPartial<ImportTestCasesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Exports the test cases under the agent to a Cloud Storage bucket or a local
   * file. Filter can be applied to export a subset of test cases.
   *
   * This method is a [long-running
   * operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation).
   * The returned `Operation` type has the following method-specific fields:
   *
   * - `metadata`:
   * [ExportTestCasesMetadata][google.cloud.dialogflow.cx.v3beta1.ExportTestCasesMetadata]
   * - `response`:
   * [ExportTestCasesResponse][google.cloud.dialogflow.cx.v3beta1.ExportTestCasesResponse]
   */
  exportTestCases(
    request: DeepPartial<ExportTestCasesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Fetches the list of run results for the given test case. A maximum of 100
   * results are kept for each test case.
   */
  listTestCaseResults(
    request: DeepPartial<ListTestCaseResultsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTestCaseResultsResponse>;
  /** Gets a test case result. */
  getTestCaseResult(
    request: DeepPartial<GetTestCaseResultRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestCaseResult>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
