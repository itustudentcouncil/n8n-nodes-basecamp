// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dialogflow/cx/v3/data_store_connection.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.dialogflow.cx.v3";

/**
 * Type of a data store.
 * Determines how search is performed in the data store.
 */
export enum DataStoreType {
  /**
   * DATA_STORE_TYPE_UNSPECIFIED - Not specified. This value indicates that the data store type is not
   * specified, so it will not be used during search.
   */
  DATA_STORE_TYPE_UNSPECIFIED = 0,
  /** PUBLIC_WEB - A data store that contains public web content. */
  PUBLIC_WEB = 1,
  /** UNSTRUCTURED - A data store that contains unstructured private data. */
  UNSTRUCTURED = 2,
  /** STRUCTURED - A data store that contains structured data (for example FAQ). */
  STRUCTURED = 3,
  UNRECOGNIZED = -1,
}

export function dataStoreTypeFromJSON(object: any): DataStoreType {
  switch (object) {
    case 0:
    case "DATA_STORE_TYPE_UNSPECIFIED":
      return DataStoreType.DATA_STORE_TYPE_UNSPECIFIED;
    case 1:
    case "PUBLIC_WEB":
      return DataStoreType.PUBLIC_WEB;
    case 2:
    case "UNSTRUCTURED":
      return DataStoreType.UNSTRUCTURED;
    case 3:
    case "STRUCTURED":
      return DataStoreType.STRUCTURED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataStoreType.UNRECOGNIZED;
  }
}

export function dataStoreTypeToJSON(object: DataStoreType): string {
  switch (object) {
    case DataStoreType.DATA_STORE_TYPE_UNSPECIFIED:
      return "DATA_STORE_TYPE_UNSPECIFIED";
    case DataStoreType.PUBLIC_WEB:
      return "PUBLIC_WEB";
    case DataStoreType.UNSTRUCTURED:
      return "UNSTRUCTURED";
    case DataStoreType.STRUCTURED:
      return "STRUCTURED";
    case DataStoreType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A data store connection. It represents a data store in Discovery Engine and
 * the type of the contents it contains.
 */
export interface DataStoreConnection {
  /** The type of the connected data store. */
  dataStoreType: DataStoreType;
  /**
   * The full name of the referenced data store.
   * Formats:
   * `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`
   * `projects/{project}/locations/{location}/dataStores/{data_store}`
   */
  dataStore: string;
}

/**
 * Data store connection feature output signals.
 * Might be only partially field if processing stop before the final answer.
 * Reasons for this can be, but are not limited to: empty UCS search results,
 * positive RAI check outcome, grounding failure, ...
 */
export interface DataStoreConnectionSignals {
  /** Optional. Diagnostic info related to the rewriter model call. */
  rewriterModelCallSignals:
    | DataStoreConnectionSignals_RewriterModelCallSignals
    | undefined;
  /** Optional. Rewritten string query used for search. */
  rewrittenQuery: string;
  /** Optional. Search snippets included in the answer generation prompt. */
  searchSnippets: DataStoreConnectionSignals_SearchSnippet[];
  /** Optional. Diagnostic info related to the answer generation model call. */
  answerGenerationModelCallSignals:
    | DataStoreConnectionSignals_AnswerGenerationModelCallSignals
    | undefined;
  /** Optional. The final compiled answer. */
  answer: string;
  /**
   * Optional. Answer parts with relevant citations.
   * Concatenation of texts should add up the `answer` (not counting
   * whitespaces).
   */
  answerParts: DataStoreConnectionSignals_AnswerPart[];
  /**
   * Optional. Snippets cited by the answer generation model from the most to
   * least relevant.
   */
  citedSnippets: DataStoreConnectionSignals_CitedSnippet[];
  /** Optional. Grounding signals. */
  groundingSignals:
    | DataStoreConnectionSignals_GroundingSignals
    | undefined;
  /** Optional. Safety check result. */
  safetySignals: DataStoreConnectionSignals_SafetySignals | undefined;
}

/** Diagnostic info related to the rewriter model call. */
export interface DataStoreConnectionSignals_RewriterModelCallSignals {
  /** Prompt as sent to the model. */
  renderedPrompt: string;
  /** Output of the generative model. */
  modelOutput: string;
  /**
   * Name of the generative model. For example, "gemini-ultra", "gemini-pro",
   * "gemini-1.5-flash" etc. Defaults to "Other" if the model is unknown.
   */
  model: string;
}

/** Search snippet details. */
export interface DataStoreConnectionSignals_SearchSnippet {
  /** Title of the enclosing document. */
  documentTitle: string;
  /** Uri for the document. Present if specified for the document. */
  documentUri: string;
  /** Text included in the prompt. */
  text: string;
}

/** Diagnostic info related to the answer generation model call. */
export interface DataStoreConnectionSignals_AnswerGenerationModelCallSignals {
  /** Prompt as sent to the model. */
  renderedPrompt: string;
  /** Output of the generative model. */
  modelOutput: string;
  /**
   * Name of the generative model. For example, "gemini-ultra", "gemini-pro",
   * "gemini-1.5-flash" etc. Defaults to "Other" if the model is unknown.
   */
  model: string;
}

/** Answer part with citation. */
export interface DataStoreConnectionSignals_AnswerPart {
  /** Substring of the answer. */
  text: string;
  /** Citations for this answer part. Indices of `search_snippets`. */
  supportingIndices: number[];
}

/** Snippet cited by the answer generation model. */
export interface DataStoreConnectionSignals_CitedSnippet {
  /** Details of the snippet. */
  searchSnippet:
    | DataStoreConnectionSignals_SearchSnippet
    | undefined;
  /** Index of the snippet in `search_snippets` field. */
  snippetIndex: number;
}

/** Grounding signals. */
export interface DataStoreConnectionSignals_GroundingSignals {
  /** Represents the decision of the grounding check. */
  decision: DataStoreConnectionSignals_GroundingSignals_GroundingDecision;
  /** Grounding score bucket setting. */
  score: DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket;
}

/** Represents the decision of the grounding check. */
export enum DataStoreConnectionSignals_GroundingSignals_GroundingDecision {
  /** GROUNDING_DECISION_UNSPECIFIED - Decision not specified. */
  GROUNDING_DECISION_UNSPECIFIED = 0,
  /** ACCEPTED_BY_GROUNDING - Grounding have accepted the answer. */
  ACCEPTED_BY_GROUNDING = 1,
  /** REJECTED_BY_GROUNDING - Grounding have rejected the answer. */
  REJECTED_BY_GROUNDING = 2,
  UNRECOGNIZED = -1,
}

export function dataStoreConnectionSignals_GroundingSignals_GroundingDecisionFromJSON(
  object: any,
): DataStoreConnectionSignals_GroundingSignals_GroundingDecision {
  switch (object) {
    case 0:
    case "GROUNDING_DECISION_UNSPECIFIED":
      return DataStoreConnectionSignals_GroundingSignals_GroundingDecision.GROUNDING_DECISION_UNSPECIFIED;
    case 1:
    case "ACCEPTED_BY_GROUNDING":
      return DataStoreConnectionSignals_GroundingSignals_GroundingDecision.ACCEPTED_BY_GROUNDING;
    case 2:
    case "REJECTED_BY_GROUNDING":
      return DataStoreConnectionSignals_GroundingSignals_GroundingDecision.REJECTED_BY_GROUNDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataStoreConnectionSignals_GroundingSignals_GroundingDecision.UNRECOGNIZED;
  }
}

export function dataStoreConnectionSignals_GroundingSignals_GroundingDecisionToJSON(
  object: DataStoreConnectionSignals_GroundingSignals_GroundingDecision,
): string {
  switch (object) {
    case DataStoreConnectionSignals_GroundingSignals_GroundingDecision.GROUNDING_DECISION_UNSPECIFIED:
      return "GROUNDING_DECISION_UNSPECIFIED";
    case DataStoreConnectionSignals_GroundingSignals_GroundingDecision.ACCEPTED_BY_GROUNDING:
      return "ACCEPTED_BY_GROUNDING";
    case DataStoreConnectionSignals_GroundingSignals_GroundingDecision.REJECTED_BY_GROUNDING:
      return "REJECTED_BY_GROUNDING";
    case DataStoreConnectionSignals_GroundingSignals_GroundingDecision.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Grounding score buckets. */
export enum DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket {
  /** GROUNDING_SCORE_BUCKET_UNSPECIFIED - Score not specified. */
  GROUNDING_SCORE_BUCKET_UNSPECIFIED = 0,
  /** VERY_LOW - We have very low confidence that the answer is grounded. */
  VERY_LOW = 1,
  /** LOW - We have low confidence that the answer is grounded. */
  LOW = 3,
  /** MEDIUM - We have medium confidence that the answer is grounded. */
  MEDIUM = 4,
  /** HIGH - We have high confidence that the answer is grounded. */
  HIGH = 5,
  /** VERY_HIGH - We have very high confidence that the answer is grounded. */
  VERY_HIGH = 6,
  UNRECOGNIZED = -1,
}

export function dataStoreConnectionSignals_GroundingSignals_GroundingScoreBucketFromJSON(
  object: any,
): DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket {
  switch (object) {
    case 0:
    case "GROUNDING_SCORE_BUCKET_UNSPECIFIED":
      return DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.GROUNDING_SCORE_BUCKET_UNSPECIFIED;
    case 1:
    case "VERY_LOW":
      return DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.VERY_LOW;
    case 3:
    case "LOW":
      return DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.LOW;
    case 4:
    case "MEDIUM":
      return DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.MEDIUM;
    case 5:
    case "HIGH":
      return DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.HIGH;
    case 6:
    case "VERY_HIGH":
      return DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.VERY_HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.UNRECOGNIZED;
  }
}

export function dataStoreConnectionSignals_GroundingSignals_GroundingScoreBucketToJSON(
  object: DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket,
): string {
  switch (object) {
    case DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.GROUNDING_SCORE_BUCKET_UNSPECIFIED:
      return "GROUNDING_SCORE_BUCKET_UNSPECIFIED";
    case DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.VERY_LOW:
      return "VERY_LOW";
    case DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.LOW:
      return "LOW";
    case DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.MEDIUM:
      return "MEDIUM";
    case DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.HIGH:
      return "HIGH";
    case DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.VERY_HIGH:
      return "VERY_HIGH";
    case DataStoreConnectionSignals_GroundingSignals_GroundingScoreBucket.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Safety check results. */
export interface DataStoreConnectionSignals_SafetySignals {
  /** Safety decision. */
  decision: DataStoreConnectionSignals_SafetySignals_SafetyDecision;
  /** Specifies banned phrase match subject. */
  bannedPhraseMatch: DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch;
  /** The matched banned phrase if there was a match. */
  matchedBannedPhrase: string;
}

/**
 * Safety decision.
 * All kinds of check are incorporated into this final decision, including
 * banned phrases check.
 */
export enum DataStoreConnectionSignals_SafetySignals_SafetyDecision {
  /** SAFETY_DECISION_UNSPECIFIED - Decision not specified. */
  SAFETY_DECISION_UNSPECIFIED = 0,
  /** ACCEPTED_BY_SAFETY_CHECK - No manual or automatic safety check fired. */
  ACCEPTED_BY_SAFETY_CHECK = 1,
  /** REJECTED_BY_SAFETY_CHECK - One ore more safety checks fired. */
  REJECTED_BY_SAFETY_CHECK = 2,
  UNRECOGNIZED = -1,
}

export function dataStoreConnectionSignals_SafetySignals_SafetyDecisionFromJSON(
  object: any,
): DataStoreConnectionSignals_SafetySignals_SafetyDecision {
  switch (object) {
    case 0:
    case "SAFETY_DECISION_UNSPECIFIED":
      return DataStoreConnectionSignals_SafetySignals_SafetyDecision.SAFETY_DECISION_UNSPECIFIED;
    case 1:
    case "ACCEPTED_BY_SAFETY_CHECK":
      return DataStoreConnectionSignals_SafetySignals_SafetyDecision.ACCEPTED_BY_SAFETY_CHECK;
    case 2:
    case "REJECTED_BY_SAFETY_CHECK":
      return DataStoreConnectionSignals_SafetySignals_SafetyDecision.REJECTED_BY_SAFETY_CHECK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataStoreConnectionSignals_SafetySignals_SafetyDecision.UNRECOGNIZED;
  }
}

export function dataStoreConnectionSignals_SafetySignals_SafetyDecisionToJSON(
  object: DataStoreConnectionSignals_SafetySignals_SafetyDecision,
): string {
  switch (object) {
    case DataStoreConnectionSignals_SafetySignals_SafetyDecision.SAFETY_DECISION_UNSPECIFIED:
      return "SAFETY_DECISION_UNSPECIFIED";
    case DataStoreConnectionSignals_SafetySignals_SafetyDecision.ACCEPTED_BY_SAFETY_CHECK:
      return "ACCEPTED_BY_SAFETY_CHECK";
    case DataStoreConnectionSignals_SafetySignals_SafetyDecision.REJECTED_BY_SAFETY_CHECK:
      return "REJECTED_BY_SAFETY_CHECK";
    case DataStoreConnectionSignals_SafetySignals_SafetyDecision.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies banned phrase match subject. */
export enum DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch {
  /** BANNED_PHRASE_MATCH_UNSPECIFIED - No banned phrase check was executed. */
  BANNED_PHRASE_MATCH_UNSPECIFIED = 0,
  /** BANNED_PHRASE_MATCH_NONE - All banned phrase checks led to no match. */
  BANNED_PHRASE_MATCH_NONE = 1,
  /** BANNED_PHRASE_MATCH_QUERY - A banned phrase matched the query. */
  BANNED_PHRASE_MATCH_QUERY = 2,
  /** BANNED_PHRASE_MATCH_RESPONSE - A banned phrase matched the response. */
  BANNED_PHRASE_MATCH_RESPONSE = 3,
  UNRECOGNIZED = -1,
}

export function dataStoreConnectionSignals_SafetySignals_BannedPhraseMatchFromJSON(
  object: any,
): DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch {
  switch (object) {
    case 0:
    case "BANNED_PHRASE_MATCH_UNSPECIFIED":
      return DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch.BANNED_PHRASE_MATCH_UNSPECIFIED;
    case 1:
    case "BANNED_PHRASE_MATCH_NONE":
      return DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch.BANNED_PHRASE_MATCH_NONE;
    case 2:
    case "BANNED_PHRASE_MATCH_QUERY":
      return DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch.BANNED_PHRASE_MATCH_QUERY;
    case 3:
    case "BANNED_PHRASE_MATCH_RESPONSE":
      return DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch.BANNED_PHRASE_MATCH_RESPONSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch.UNRECOGNIZED;
  }
}

export function dataStoreConnectionSignals_SafetySignals_BannedPhraseMatchToJSON(
  object: DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch,
): string {
  switch (object) {
    case DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch.BANNED_PHRASE_MATCH_UNSPECIFIED:
      return "BANNED_PHRASE_MATCH_UNSPECIFIED";
    case DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch.BANNED_PHRASE_MATCH_NONE:
      return "BANNED_PHRASE_MATCH_NONE";
    case DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch.BANNED_PHRASE_MATCH_QUERY:
      return "BANNED_PHRASE_MATCH_QUERY";
    case DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch.BANNED_PHRASE_MATCH_RESPONSE:
      return "BANNED_PHRASE_MATCH_RESPONSE";
    case DataStoreConnectionSignals_SafetySignals_BannedPhraseMatch.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseDataStoreConnection(): DataStoreConnection {
  return { dataStoreType: 0, dataStore: "" };
}

export const DataStoreConnection: MessageFns<DataStoreConnection> = {
  encode(message: DataStoreConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataStoreType !== 0) {
      writer.uint32(8).int32(message.dataStoreType);
    }
    if (message.dataStore !== "") {
      writer.uint32(18).string(message.dataStore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStoreConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStoreConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dataStoreType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataStore = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStoreConnection {
    return {
      dataStoreType: isSet(object.dataStoreType) ? dataStoreTypeFromJSON(object.dataStoreType) : 0,
      dataStore: isSet(object.dataStore) ? globalThis.String(object.dataStore) : "",
    };
  },

  toJSON(message: DataStoreConnection): unknown {
    const obj: any = {};
    if (message.dataStoreType !== 0) {
      obj.dataStoreType = dataStoreTypeToJSON(message.dataStoreType);
    }
    if (message.dataStore !== "") {
      obj.dataStore = message.dataStore;
    }
    return obj;
  },

  create(base?: DeepPartial<DataStoreConnection>): DataStoreConnection {
    return DataStoreConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataStoreConnection>): DataStoreConnection {
    const message = createBaseDataStoreConnection();
    message.dataStoreType = object.dataStoreType ?? 0;
    message.dataStore = object.dataStore ?? "";
    return message;
  },
};

function createBaseDataStoreConnectionSignals(): DataStoreConnectionSignals {
  return {
    rewriterModelCallSignals: undefined,
    rewrittenQuery: "",
    searchSnippets: [],
    answerGenerationModelCallSignals: undefined,
    answer: "",
    answerParts: [],
    citedSnippets: [],
    groundingSignals: undefined,
    safetySignals: undefined,
  };
}

export const DataStoreConnectionSignals: MessageFns<DataStoreConnectionSignals> = {
  encode(message: DataStoreConnectionSignals, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rewriterModelCallSignals !== undefined) {
      DataStoreConnectionSignals_RewriterModelCallSignals.encode(
        message.rewriterModelCallSignals,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.rewrittenQuery !== "") {
      writer.uint32(18).string(message.rewrittenQuery);
    }
    for (const v of message.searchSnippets) {
      DataStoreConnectionSignals_SearchSnippet.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.answerGenerationModelCallSignals !== undefined) {
      DataStoreConnectionSignals_AnswerGenerationModelCallSignals.encode(
        message.answerGenerationModelCallSignals,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.answer !== "") {
      writer.uint32(42).string(message.answer);
    }
    for (const v of message.answerParts) {
      DataStoreConnectionSignals_AnswerPart.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.citedSnippets) {
      DataStoreConnectionSignals_CitedSnippet.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.groundingSignals !== undefined) {
      DataStoreConnectionSignals_GroundingSignals.encode(message.groundingSignals, writer.uint32(66).fork()).join();
    }
    if (message.safetySignals !== undefined) {
      DataStoreConnectionSignals_SafetySignals.encode(message.safetySignals, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStoreConnectionSignals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStoreConnectionSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rewriterModelCallSignals = DataStoreConnectionSignals_RewriterModelCallSignals.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rewrittenQuery = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.searchSnippets.push(DataStoreConnectionSignals_SearchSnippet.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.answerGenerationModelCallSignals = DataStoreConnectionSignals_AnswerGenerationModelCallSignals.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.answer = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.answerParts.push(DataStoreConnectionSignals_AnswerPart.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.citedSnippets.push(DataStoreConnectionSignals_CitedSnippet.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.groundingSignals = DataStoreConnectionSignals_GroundingSignals.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.safetySignals = DataStoreConnectionSignals_SafetySignals.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStoreConnectionSignals {
    return {
      rewriterModelCallSignals: isSet(object.rewriterModelCallSignals)
        ? DataStoreConnectionSignals_RewriterModelCallSignals.fromJSON(object.rewriterModelCallSignals)
        : undefined,
      rewrittenQuery: isSet(object.rewrittenQuery) ? globalThis.String(object.rewrittenQuery) : "",
      searchSnippets: globalThis.Array.isArray(object?.searchSnippets)
        ? object.searchSnippets.map((e: any) => DataStoreConnectionSignals_SearchSnippet.fromJSON(e))
        : [],
      answerGenerationModelCallSignals: isSet(object.answerGenerationModelCallSignals)
        ? DataStoreConnectionSignals_AnswerGenerationModelCallSignals.fromJSON(object.answerGenerationModelCallSignals)
        : undefined,
      answer: isSet(object.answer) ? globalThis.String(object.answer) : "",
      answerParts: globalThis.Array.isArray(object?.answerParts)
        ? object.answerParts.map((e: any) => DataStoreConnectionSignals_AnswerPart.fromJSON(e))
        : [],
      citedSnippets: globalThis.Array.isArray(object?.citedSnippets)
        ? object.citedSnippets.map((e: any) => DataStoreConnectionSignals_CitedSnippet.fromJSON(e))
        : [],
      groundingSignals: isSet(object.groundingSignals)
        ? DataStoreConnectionSignals_GroundingSignals.fromJSON(object.groundingSignals)
        : undefined,
      safetySignals: isSet(object.safetySignals)
        ? DataStoreConnectionSignals_SafetySignals.fromJSON(object.safetySignals)
        : undefined,
    };
  },

  toJSON(message: DataStoreConnectionSignals): unknown {
    const obj: any = {};
    if (message.rewriterModelCallSignals !== undefined) {
      obj.rewriterModelCallSignals = DataStoreConnectionSignals_RewriterModelCallSignals.toJSON(
        message.rewriterModelCallSignals,
      );
    }
    if (message.rewrittenQuery !== "") {
      obj.rewrittenQuery = message.rewrittenQuery;
    }
    if (message.searchSnippets?.length) {
      obj.searchSnippets = message.searchSnippets.map((e) => DataStoreConnectionSignals_SearchSnippet.toJSON(e));
    }
    if (message.answerGenerationModelCallSignals !== undefined) {
      obj.answerGenerationModelCallSignals = DataStoreConnectionSignals_AnswerGenerationModelCallSignals.toJSON(
        message.answerGenerationModelCallSignals,
      );
    }
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    if (message.answerParts?.length) {
      obj.answerParts = message.answerParts.map((e) => DataStoreConnectionSignals_AnswerPart.toJSON(e));
    }
    if (message.citedSnippets?.length) {
      obj.citedSnippets = message.citedSnippets.map((e) => DataStoreConnectionSignals_CitedSnippet.toJSON(e));
    }
    if (message.groundingSignals !== undefined) {
      obj.groundingSignals = DataStoreConnectionSignals_GroundingSignals.toJSON(message.groundingSignals);
    }
    if (message.safetySignals !== undefined) {
      obj.safetySignals = DataStoreConnectionSignals_SafetySignals.toJSON(message.safetySignals);
    }
    return obj;
  },

  create(base?: DeepPartial<DataStoreConnectionSignals>): DataStoreConnectionSignals {
    return DataStoreConnectionSignals.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataStoreConnectionSignals>): DataStoreConnectionSignals {
    const message = createBaseDataStoreConnectionSignals();
    message.rewriterModelCallSignals =
      (object.rewriterModelCallSignals !== undefined && object.rewriterModelCallSignals !== null)
        ? DataStoreConnectionSignals_RewriterModelCallSignals.fromPartial(object.rewriterModelCallSignals)
        : undefined;
    message.rewrittenQuery = object.rewrittenQuery ?? "";
    message.searchSnippets =
      object.searchSnippets?.map((e) => DataStoreConnectionSignals_SearchSnippet.fromPartial(e)) || [];
    message.answerGenerationModelCallSignals =
      (object.answerGenerationModelCallSignals !== undefined && object.answerGenerationModelCallSignals !== null)
        ? DataStoreConnectionSignals_AnswerGenerationModelCallSignals.fromPartial(
          object.answerGenerationModelCallSignals,
        )
        : undefined;
    message.answer = object.answer ?? "";
    message.answerParts = object.answerParts?.map((e) => DataStoreConnectionSignals_AnswerPart.fromPartial(e)) || [];
    message.citedSnippets = object.citedSnippets?.map((e) => DataStoreConnectionSignals_CitedSnippet.fromPartial(e)) ||
      [];
    message.groundingSignals = (object.groundingSignals !== undefined && object.groundingSignals !== null)
      ? DataStoreConnectionSignals_GroundingSignals.fromPartial(object.groundingSignals)
      : undefined;
    message.safetySignals = (object.safetySignals !== undefined && object.safetySignals !== null)
      ? DataStoreConnectionSignals_SafetySignals.fromPartial(object.safetySignals)
      : undefined;
    return message;
  },
};

function createBaseDataStoreConnectionSignals_RewriterModelCallSignals(): DataStoreConnectionSignals_RewriterModelCallSignals {
  return { renderedPrompt: "", modelOutput: "", model: "" };
}

export const DataStoreConnectionSignals_RewriterModelCallSignals: MessageFns<
  DataStoreConnectionSignals_RewriterModelCallSignals
> = {
  encode(
    message: DataStoreConnectionSignals_RewriterModelCallSignals,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.renderedPrompt !== "") {
      writer.uint32(10).string(message.renderedPrompt);
    }
    if (message.modelOutput !== "") {
      writer.uint32(18).string(message.modelOutput);
    }
    if (message.model !== "") {
      writer.uint32(26).string(message.model);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStoreConnectionSignals_RewriterModelCallSignals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStoreConnectionSignals_RewriterModelCallSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.renderedPrompt = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.modelOutput = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.model = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStoreConnectionSignals_RewriterModelCallSignals {
    return {
      renderedPrompt: isSet(object.renderedPrompt) ? globalThis.String(object.renderedPrompt) : "",
      modelOutput: isSet(object.modelOutput) ? globalThis.String(object.modelOutput) : "",
      model: isSet(object.model) ? globalThis.String(object.model) : "",
    };
  },

  toJSON(message: DataStoreConnectionSignals_RewriterModelCallSignals): unknown {
    const obj: any = {};
    if (message.renderedPrompt !== "") {
      obj.renderedPrompt = message.renderedPrompt;
    }
    if (message.modelOutput !== "") {
      obj.modelOutput = message.modelOutput;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    return obj;
  },

  create(
    base?: DeepPartial<DataStoreConnectionSignals_RewriterModelCallSignals>,
  ): DataStoreConnectionSignals_RewriterModelCallSignals {
    return DataStoreConnectionSignals_RewriterModelCallSignals.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DataStoreConnectionSignals_RewriterModelCallSignals>,
  ): DataStoreConnectionSignals_RewriterModelCallSignals {
    const message = createBaseDataStoreConnectionSignals_RewriterModelCallSignals();
    message.renderedPrompt = object.renderedPrompt ?? "";
    message.modelOutput = object.modelOutput ?? "";
    message.model = object.model ?? "";
    return message;
  },
};

function createBaseDataStoreConnectionSignals_SearchSnippet(): DataStoreConnectionSignals_SearchSnippet {
  return { documentTitle: "", documentUri: "", text: "" };
}

export const DataStoreConnectionSignals_SearchSnippet: MessageFns<DataStoreConnectionSignals_SearchSnippet> = {
  encode(message: DataStoreConnectionSignals_SearchSnippet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.documentTitle !== "") {
      writer.uint32(10).string(message.documentTitle);
    }
    if (message.documentUri !== "") {
      writer.uint32(18).string(message.documentUri);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStoreConnectionSignals_SearchSnippet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStoreConnectionSignals_SearchSnippet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentTitle = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.documentUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStoreConnectionSignals_SearchSnippet {
    return {
      documentTitle: isSet(object.documentTitle) ? globalThis.String(object.documentTitle) : "",
      documentUri: isSet(object.documentUri) ? globalThis.String(object.documentUri) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: DataStoreConnectionSignals_SearchSnippet): unknown {
    const obj: any = {};
    if (message.documentTitle !== "") {
      obj.documentTitle = message.documentTitle;
    }
    if (message.documentUri !== "") {
      obj.documentUri = message.documentUri;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<DataStoreConnectionSignals_SearchSnippet>): DataStoreConnectionSignals_SearchSnippet {
    return DataStoreConnectionSignals_SearchSnippet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataStoreConnectionSignals_SearchSnippet>): DataStoreConnectionSignals_SearchSnippet {
    const message = createBaseDataStoreConnectionSignals_SearchSnippet();
    message.documentTitle = object.documentTitle ?? "";
    message.documentUri = object.documentUri ?? "";
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseDataStoreConnectionSignals_AnswerGenerationModelCallSignals(): DataStoreConnectionSignals_AnswerGenerationModelCallSignals {
  return { renderedPrompt: "", modelOutput: "", model: "" };
}

export const DataStoreConnectionSignals_AnswerGenerationModelCallSignals: MessageFns<
  DataStoreConnectionSignals_AnswerGenerationModelCallSignals
> = {
  encode(
    message: DataStoreConnectionSignals_AnswerGenerationModelCallSignals,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.renderedPrompt !== "") {
      writer.uint32(10).string(message.renderedPrompt);
    }
    if (message.modelOutput !== "") {
      writer.uint32(18).string(message.modelOutput);
    }
    if (message.model !== "") {
      writer.uint32(26).string(message.model);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DataStoreConnectionSignals_AnswerGenerationModelCallSignals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStoreConnectionSignals_AnswerGenerationModelCallSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.renderedPrompt = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.modelOutput = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.model = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStoreConnectionSignals_AnswerGenerationModelCallSignals {
    return {
      renderedPrompt: isSet(object.renderedPrompt) ? globalThis.String(object.renderedPrompt) : "",
      modelOutput: isSet(object.modelOutput) ? globalThis.String(object.modelOutput) : "",
      model: isSet(object.model) ? globalThis.String(object.model) : "",
    };
  },

  toJSON(message: DataStoreConnectionSignals_AnswerGenerationModelCallSignals): unknown {
    const obj: any = {};
    if (message.renderedPrompt !== "") {
      obj.renderedPrompt = message.renderedPrompt;
    }
    if (message.modelOutput !== "") {
      obj.modelOutput = message.modelOutput;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    return obj;
  },

  create(
    base?: DeepPartial<DataStoreConnectionSignals_AnswerGenerationModelCallSignals>,
  ): DataStoreConnectionSignals_AnswerGenerationModelCallSignals {
    return DataStoreConnectionSignals_AnswerGenerationModelCallSignals.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DataStoreConnectionSignals_AnswerGenerationModelCallSignals>,
  ): DataStoreConnectionSignals_AnswerGenerationModelCallSignals {
    const message = createBaseDataStoreConnectionSignals_AnswerGenerationModelCallSignals();
    message.renderedPrompt = object.renderedPrompt ?? "";
    message.modelOutput = object.modelOutput ?? "";
    message.model = object.model ?? "";
    return message;
  },
};

function createBaseDataStoreConnectionSignals_AnswerPart(): DataStoreConnectionSignals_AnswerPart {
  return { text: "", supportingIndices: [] };
}

export const DataStoreConnectionSignals_AnswerPart: MessageFns<DataStoreConnectionSignals_AnswerPart> = {
  encode(message: DataStoreConnectionSignals_AnswerPart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    writer.uint32(18).fork();
    for (const v of message.supportingIndices) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStoreConnectionSignals_AnswerPart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStoreConnectionSignals_AnswerPart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.supportingIndices.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportingIndices.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStoreConnectionSignals_AnswerPart {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      supportingIndices: globalThis.Array.isArray(object?.supportingIndices)
        ? object.supportingIndices.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: DataStoreConnectionSignals_AnswerPart): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.supportingIndices?.length) {
      obj.supportingIndices = message.supportingIndices.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DataStoreConnectionSignals_AnswerPart>): DataStoreConnectionSignals_AnswerPart {
    return DataStoreConnectionSignals_AnswerPart.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataStoreConnectionSignals_AnswerPart>): DataStoreConnectionSignals_AnswerPart {
    const message = createBaseDataStoreConnectionSignals_AnswerPart();
    message.text = object.text ?? "";
    message.supportingIndices = object.supportingIndices?.map((e) => e) || [];
    return message;
  },
};

function createBaseDataStoreConnectionSignals_CitedSnippet(): DataStoreConnectionSignals_CitedSnippet {
  return { searchSnippet: undefined, snippetIndex: 0 };
}

export const DataStoreConnectionSignals_CitedSnippet: MessageFns<DataStoreConnectionSignals_CitedSnippet> = {
  encode(message: DataStoreConnectionSignals_CitedSnippet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchSnippet !== undefined) {
      DataStoreConnectionSignals_SearchSnippet.encode(message.searchSnippet, writer.uint32(10).fork()).join();
    }
    if (message.snippetIndex !== 0) {
      writer.uint32(16).int32(message.snippetIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStoreConnectionSignals_CitedSnippet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStoreConnectionSignals_CitedSnippet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchSnippet = DataStoreConnectionSignals_SearchSnippet.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.snippetIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStoreConnectionSignals_CitedSnippet {
    return {
      searchSnippet: isSet(object.searchSnippet)
        ? DataStoreConnectionSignals_SearchSnippet.fromJSON(object.searchSnippet)
        : undefined,
      snippetIndex: isSet(object.snippetIndex) ? globalThis.Number(object.snippetIndex) : 0,
    };
  },

  toJSON(message: DataStoreConnectionSignals_CitedSnippet): unknown {
    const obj: any = {};
    if (message.searchSnippet !== undefined) {
      obj.searchSnippet = DataStoreConnectionSignals_SearchSnippet.toJSON(message.searchSnippet);
    }
    if (message.snippetIndex !== 0) {
      obj.snippetIndex = Math.round(message.snippetIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<DataStoreConnectionSignals_CitedSnippet>): DataStoreConnectionSignals_CitedSnippet {
    return DataStoreConnectionSignals_CitedSnippet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataStoreConnectionSignals_CitedSnippet>): DataStoreConnectionSignals_CitedSnippet {
    const message = createBaseDataStoreConnectionSignals_CitedSnippet();
    message.searchSnippet = (object.searchSnippet !== undefined && object.searchSnippet !== null)
      ? DataStoreConnectionSignals_SearchSnippet.fromPartial(object.searchSnippet)
      : undefined;
    message.snippetIndex = object.snippetIndex ?? 0;
    return message;
  },
};

function createBaseDataStoreConnectionSignals_GroundingSignals(): DataStoreConnectionSignals_GroundingSignals {
  return { decision: 0, score: 0 };
}

export const DataStoreConnectionSignals_GroundingSignals: MessageFns<DataStoreConnectionSignals_GroundingSignals> = {
  encode(
    message: DataStoreConnectionSignals_GroundingSignals,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.decision !== 0) {
      writer.uint32(8).int32(message.decision);
    }
    if (message.score !== 0) {
      writer.uint32(16).int32(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStoreConnectionSignals_GroundingSignals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStoreConnectionSignals_GroundingSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.decision = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.score = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStoreConnectionSignals_GroundingSignals {
    return {
      decision: isSet(object.decision)
        ? dataStoreConnectionSignals_GroundingSignals_GroundingDecisionFromJSON(object.decision)
        : 0,
      score: isSet(object.score)
        ? dataStoreConnectionSignals_GroundingSignals_GroundingScoreBucketFromJSON(object.score)
        : 0,
    };
  },

  toJSON(message: DataStoreConnectionSignals_GroundingSignals): unknown {
    const obj: any = {};
    if (message.decision !== 0) {
      obj.decision = dataStoreConnectionSignals_GroundingSignals_GroundingDecisionToJSON(message.decision);
    }
    if (message.score !== 0) {
      obj.score = dataStoreConnectionSignals_GroundingSignals_GroundingScoreBucketToJSON(message.score);
    }
    return obj;
  },

  create(base?: DeepPartial<DataStoreConnectionSignals_GroundingSignals>): DataStoreConnectionSignals_GroundingSignals {
    return DataStoreConnectionSignals_GroundingSignals.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DataStoreConnectionSignals_GroundingSignals>,
  ): DataStoreConnectionSignals_GroundingSignals {
    const message = createBaseDataStoreConnectionSignals_GroundingSignals();
    message.decision = object.decision ?? 0;
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseDataStoreConnectionSignals_SafetySignals(): DataStoreConnectionSignals_SafetySignals {
  return { decision: 0, bannedPhraseMatch: 0, matchedBannedPhrase: "" };
}

export const DataStoreConnectionSignals_SafetySignals: MessageFns<DataStoreConnectionSignals_SafetySignals> = {
  encode(message: DataStoreConnectionSignals_SafetySignals, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.decision !== 0) {
      writer.uint32(8).int32(message.decision);
    }
    if (message.bannedPhraseMatch !== 0) {
      writer.uint32(16).int32(message.bannedPhraseMatch);
    }
    if (message.matchedBannedPhrase !== "") {
      writer.uint32(26).string(message.matchedBannedPhrase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStoreConnectionSignals_SafetySignals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStoreConnectionSignals_SafetySignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.decision = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.bannedPhraseMatch = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.matchedBannedPhrase = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStoreConnectionSignals_SafetySignals {
    return {
      decision: isSet(object.decision)
        ? dataStoreConnectionSignals_SafetySignals_SafetyDecisionFromJSON(object.decision)
        : 0,
      bannedPhraseMatch: isSet(object.bannedPhraseMatch)
        ? dataStoreConnectionSignals_SafetySignals_BannedPhraseMatchFromJSON(object.bannedPhraseMatch)
        : 0,
      matchedBannedPhrase: isSet(object.matchedBannedPhrase) ? globalThis.String(object.matchedBannedPhrase) : "",
    };
  },

  toJSON(message: DataStoreConnectionSignals_SafetySignals): unknown {
    const obj: any = {};
    if (message.decision !== 0) {
      obj.decision = dataStoreConnectionSignals_SafetySignals_SafetyDecisionToJSON(message.decision);
    }
    if (message.bannedPhraseMatch !== 0) {
      obj.bannedPhraseMatch = dataStoreConnectionSignals_SafetySignals_BannedPhraseMatchToJSON(
        message.bannedPhraseMatch,
      );
    }
    if (message.matchedBannedPhrase !== "") {
      obj.matchedBannedPhrase = message.matchedBannedPhrase;
    }
    return obj;
  },

  create(base?: DeepPartial<DataStoreConnectionSignals_SafetySignals>): DataStoreConnectionSignals_SafetySignals {
    return DataStoreConnectionSignals_SafetySignals.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataStoreConnectionSignals_SafetySignals>): DataStoreConnectionSignals_SafetySignals {
    const message = createBaseDataStoreConnectionSignals_SafetySignals();
    message.decision = object.decision ?? 0;
    message.bannedPhraseMatch = object.bannedPhraseMatch ?? 0;
    message.matchedBannedPhrase = object.matchedBannedPhrase ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
