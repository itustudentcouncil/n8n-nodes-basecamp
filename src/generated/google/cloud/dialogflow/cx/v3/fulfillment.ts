// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dialogflow/cx/v3/fulfillment.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Value } from "../../../../protobuf/struct.js";
import { AdvancedSettings } from "./advanced_settings.js";
import { ResponseMessage } from "./response_message.js";

export const protobufPackage = "google.cloud.dialogflow.cx.v3";

/**
 * A fulfillment can do one or more of the following actions at the same time:
 *
 *   * Generate rich message responses.
 *   * Set parameter values.
 *   * Call the webhook.
 *
 * Fulfillments can be called at various stages in the
 * [Page][google.cloud.dialogflow.cx.v3.Page] or
 * [Form][google.cloud.dialogflow.cx.v3.Form] lifecycle. For example, when a
 * [DetectIntentRequest][google.cloud.dialogflow.cx.v3.DetectIntentRequest]
 * drives a session to enter a new page, the page's entry fulfillment can add a
 * static response to the
 * [QueryResult][google.cloud.dialogflow.cx.v3.QueryResult] in the returning
 * [DetectIntentResponse][google.cloud.dialogflow.cx.v3.DetectIntentResponse],
 * call the webhook (for example, to load user data from a database), or both.
 */
export interface Fulfillment {
  /** The list of rich message responses to present to the user. */
  messages: ResponseMessage[];
  /**
   * The webhook to call.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/webhooks/<Webhook ID>`.
   */
  webhook: string;
  /**
   * Whether Dialogflow should return currently queued fulfillment response
   * messages in streaming APIs. If a webhook is specified, it happens before
   * Dialogflow invokes webhook.
   * Warning:
   * 1) This flag only affects streaming API. Responses are still queued
   * and returned once in non-streaming API.
   * 2) The flag can be enabled in any fulfillment but only the first 3 partial
   * responses will be returned. You may only want to apply it to fulfillments
   * that have slow webhooks.
   */
  returnPartialResponses: boolean;
  /**
   * The value of this field will be populated in the
   * [WebhookRequest][google.cloud.dialogflow.cx.v3.WebhookRequest]
   * `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is
   * called.
   * The tag is typically used by the webhook service to identify which
   * fulfillment is being called, but it could be used for other purposes.
   * This field is required if `webhook` is specified.
   */
  tag: string;
  /** Set parameter values before executing the webhook. */
  setParameterActions: Fulfillment_SetParameterAction[];
  /** Conditional cases for this fulfillment. */
  conditionalCases: Fulfillment_ConditionalCases[];
  /**
   * Hierarchical advanced settings for this fulfillment. The settings exposed
   * at the lower level overrides the settings exposed at the higher level.
   */
  advancedSettings:
    | AdvancedSettings
    | undefined;
  /**
   * If the flag is true, the agent will utilize LLM to generate a text
   * response. If LLM generation fails, the defined
   * [responses][google.cloud.dialogflow.cx.v3.Fulfillment.messages] in the
   * fulfillment will be respected. This flag is only useful for fulfillments
   * associated with no-match event handlers.
   */
  enableGenerativeFallback: boolean;
}

/** Setting a parameter value. */
export interface Fulfillment_SetParameterAction {
  /** Display name of the parameter. */
  parameter: string;
  /** The new value of the parameter. A null value clears the parameter. */
  value: any | undefined;
}

/**
 * A list of cascading if-else conditions. Cases are mutually exclusive.
 * The first one with a matching condition is selected, all the rest ignored.
 */
export interface Fulfillment_ConditionalCases {
  /** A list of cascading if-else conditions. */
  cases: Fulfillment_ConditionalCases_Case[];
}

/**
 * Each case has a Boolean condition. When it is evaluated to be True, the
 * corresponding messages will be selected and evaluated recursively.
 */
export interface Fulfillment_ConditionalCases_Case {
  /**
   * The condition to activate and select this case. Empty means the
   * condition is always true. The condition is evaluated against [form
   * parameters][Form.parameters] or [session
   * parameters][SessionInfo.parameters].
   *
   * See the [conditions
   * reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
   */
  condition: string;
  /** A list of case content. */
  caseContent: Fulfillment_ConditionalCases_Case_CaseContent[];
}

/** The list of messages or conditional cases to activate for this case. */
export interface Fulfillment_ConditionalCases_Case_CaseContent {
  /** Returned message. */
  message?:
    | ResponseMessage
    | undefined;
  /** Additional cases to be evaluated. */
  additionalCases?: Fulfillment_ConditionalCases | undefined;
}

function createBaseFulfillment(): Fulfillment {
  return {
    messages: [],
    webhook: "",
    returnPartialResponses: false,
    tag: "",
    setParameterActions: [],
    conditionalCases: [],
    advancedSettings: undefined,
    enableGenerativeFallback: false,
  };
}

export const Fulfillment: MessageFns<Fulfillment> = {
  encode(message: Fulfillment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      ResponseMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.webhook !== "") {
      writer.uint32(18).string(message.webhook);
    }
    if (message.returnPartialResponses !== false) {
      writer.uint32(64).bool(message.returnPartialResponses);
    }
    if (message.tag !== "") {
      writer.uint32(26).string(message.tag);
    }
    for (const v of message.setParameterActions) {
      Fulfillment_SetParameterAction.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.conditionalCases) {
      Fulfillment_ConditionalCases.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.advancedSettings !== undefined) {
      AdvancedSettings.encode(message.advancedSettings, writer.uint32(58).fork()).join();
    }
    if (message.enableGenerativeFallback !== false) {
      writer.uint32(96).bool(message.enableGenerativeFallback);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fulfillment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfillment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(ResponseMessage.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.webhook = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.returnPartialResponses = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tag = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.setParameterActions.push(Fulfillment_SetParameterAction.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.conditionalCases.push(Fulfillment_ConditionalCases.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.advancedSettings = AdvancedSettings.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.enableGenerativeFallback = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fulfillment {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ResponseMessage.fromJSON(e))
        : [],
      webhook: isSet(object.webhook) ? globalThis.String(object.webhook) : "",
      returnPartialResponses: isSet(object.returnPartialResponses)
        ? globalThis.Boolean(object.returnPartialResponses)
        : false,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      setParameterActions: globalThis.Array.isArray(object?.setParameterActions)
        ? object.setParameterActions.map((e: any) => Fulfillment_SetParameterAction.fromJSON(e))
        : [],
      conditionalCases: globalThis.Array.isArray(object?.conditionalCases)
        ? object.conditionalCases.map((e: any) => Fulfillment_ConditionalCases.fromJSON(e))
        : [],
      advancedSettings: isSet(object.advancedSettings) ? AdvancedSettings.fromJSON(object.advancedSettings) : undefined,
      enableGenerativeFallback: isSet(object.enableGenerativeFallback)
        ? globalThis.Boolean(object.enableGenerativeFallback)
        : false,
    };
  },

  toJSON(message: Fulfillment): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => ResponseMessage.toJSON(e));
    }
    if (message.webhook !== "") {
      obj.webhook = message.webhook;
    }
    if (message.returnPartialResponses !== false) {
      obj.returnPartialResponses = message.returnPartialResponses;
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.setParameterActions?.length) {
      obj.setParameterActions = message.setParameterActions.map((e) => Fulfillment_SetParameterAction.toJSON(e));
    }
    if (message.conditionalCases?.length) {
      obj.conditionalCases = message.conditionalCases.map((e) => Fulfillment_ConditionalCases.toJSON(e));
    }
    if (message.advancedSettings !== undefined) {
      obj.advancedSettings = AdvancedSettings.toJSON(message.advancedSettings);
    }
    if (message.enableGenerativeFallback !== false) {
      obj.enableGenerativeFallback = message.enableGenerativeFallback;
    }
    return obj;
  },

  create(base?: DeepPartial<Fulfillment>): Fulfillment {
    return Fulfillment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fulfillment>): Fulfillment {
    const message = createBaseFulfillment();
    message.messages = object.messages?.map((e) => ResponseMessage.fromPartial(e)) || [];
    message.webhook = object.webhook ?? "";
    message.returnPartialResponses = object.returnPartialResponses ?? false;
    message.tag = object.tag ?? "";
    message.setParameterActions =
      object.setParameterActions?.map((e) => Fulfillment_SetParameterAction.fromPartial(e)) || [];
    message.conditionalCases = object.conditionalCases?.map((e) => Fulfillment_ConditionalCases.fromPartial(e)) || [];
    message.advancedSettings = (object.advancedSettings !== undefined && object.advancedSettings !== null)
      ? AdvancedSettings.fromPartial(object.advancedSettings)
      : undefined;
    message.enableGenerativeFallback = object.enableGenerativeFallback ?? false;
    return message;
  },
};

function createBaseFulfillment_SetParameterAction(): Fulfillment_SetParameterAction {
  return { parameter: "", value: undefined };
}

export const Fulfillment_SetParameterAction: MessageFns<Fulfillment_SetParameterAction> = {
  encode(message: Fulfillment_SetParameterAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parameter !== "") {
      writer.uint32(10).string(message.parameter);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fulfillment_SetParameterAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfillment_SetParameterAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parameter = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fulfillment_SetParameterAction {
    return {
      parameter: isSet(object.parameter) ? globalThis.String(object.parameter) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: Fulfillment_SetParameterAction): unknown {
    const obj: any = {};
    if (message.parameter !== "") {
      obj.parameter = message.parameter;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Fulfillment_SetParameterAction>): Fulfillment_SetParameterAction {
    return Fulfillment_SetParameterAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fulfillment_SetParameterAction>): Fulfillment_SetParameterAction {
    const message = createBaseFulfillment_SetParameterAction();
    message.parameter = object.parameter ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseFulfillment_ConditionalCases(): Fulfillment_ConditionalCases {
  return { cases: [] };
}

export const Fulfillment_ConditionalCases: MessageFns<Fulfillment_ConditionalCases> = {
  encode(message: Fulfillment_ConditionalCases, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cases) {
      Fulfillment_ConditionalCases_Case.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fulfillment_ConditionalCases {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfillment_ConditionalCases();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cases.push(Fulfillment_ConditionalCases_Case.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fulfillment_ConditionalCases {
    return {
      cases: globalThis.Array.isArray(object?.cases)
        ? object.cases.map((e: any) => Fulfillment_ConditionalCases_Case.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Fulfillment_ConditionalCases): unknown {
    const obj: any = {};
    if (message.cases?.length) {
      obj.cases = message.cases.map((e) => Fulfillment_ConditionalCases_Case.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Fulfillment_ConditionalCases>): Fulfillment_ConditionalCases {
    return Fulfillment_ConditionalCases.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fulfillment_ConditionalCases>): Fulfillment_ConditionalCases {
    const message = createBaseFulfillment_ConditionalCases();
    message.cases = object.cases?.map((e) => Fulfillment_ConditionalCases_Case.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFulfillment_ConditionalCases_Case(): Fulfillment_ConditionalCases_Case {
  return { condition: "", caseContent: [] };
}

export const Fulfillment_ConditionalCases_Case: MessageFns<Fulfillment_ConditionalCases_Case> = {
  encode(message: Fulfillment_ConditionalCases_Case, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condition !== "") {
      writer.uint32(10).string(message.condition);
    }
    for (const v of message.caseContent) {
      Fulfillment_ConditionalCases_Case_CaseContent.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fulfillment_ConditionalCases_Case {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfillment_ConditionalCases_Case();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.caseContent.push(Fulfillment_ConditionalCases_Case_CaseContent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fulfillment_ConditionalCases_Case {
    return {
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      caseContent: globalThis.Array.isArray(object?.caseContent)
        ? object.caseContent.map((e: any) => Fulfillment_ConditionalCases_Case_CaseContent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Fulfillment_ConditionalCases_Case): unknown {
    const obj: any = {};
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.caseContent?.length) {
      obj.caseContent = message.caseContent.map((e) => Fulfillment_ConditionalCases_Case_CaseContent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Fulfillment_ConditionalCases_Case>): Fulfillment_ConditionalCases_Case {
    return Fulfillment_ConditionalCases_Case.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fulfillment_ConditionalCases_Case>): Fulfillment_ConditionalCases_Case {
    const message = createBaseFulfillment_ConditionalCases_Case();
    message.condition = object.condition ?? "";
    message.caseContent =
      object.caseContent?.map((e) => Fulfillment_ConditionalCases_Case_CaseContent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFulfillment_ConditionalCases_Case_CaseContent(): Fulfillment_ConditionalCases_Case_CaseContent {
  return { message: undefined, additionalCases: undefined };
}

export const Fulfillment_ConditionalCases_Case_CaseContent: MessageFns<Fulfillment_ConditionalCases_Case_CaseContent> =
  {
    encode(
      message: Fulfillment_ConditionalCases_Case_CaseContent,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.message !== undefined) {
        ResponseMessage.encode(message.message, writer.uint32(10).fork()).join();
      }
      if (message.additionalCases !== undefined) {
        Fulfillment_ConditionalCases.encode(message.additionalCases, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): Fulfillment_ConditionalCases_Case_CaseContent {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseFulfillment_ConditionalCases_Case_CaseContent();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.message = ResponseMessage.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.additionalCases = Fulfillment_ConditionalCases.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): Fulfillment_ConditionalCases_Case_CaseContent {
      return {
        message: isSet(object.message) ? ResponseMessage.fromJSON(object.message) : undefined,
        additionalCases: isSet(object.additionalCases)
          ? Fulfillment_ConditionalCases.fromJSON(object.additionalCases)
          : undefined,
      };
    },

    toJSON(message: Fulfillment_ConditionalCases_Case_CaseContent): unknown {
      const obj: any = {};
      if (message.message !== undefined) {
        obj.message = ResponseMessage.toJSON(message.message);
      }
      if (message.additionalCases !== undefined) {
        obj.additionalCases = Fulfillment_ConditionalCases.toJSON(message.additionalCases);
      }
      return obj;
    },

    create(
      base?: DeepPartial<Fulfillment_ConditionalCases_Case_CaseContent>,
    ): Fulfillment_ConditionalCases_Case_CaseContent {
      return Fulfillment_ConditionalCases_Case_CaseContent.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<Fulfillment_ConditionalCases_Case_CaseContent>,
    ): Fulfillment_ConditionalCases_Case_CaseContent {
      const message = createBaseFulfillment_ConditionalCases_Case_CaseContent();
      message.message = (object.message !== undefined && object.message !== null)
        ? ResponseMessage.fromPartial(object.message)
        : undefined;
      message.additionalCases = (object.additionalCases !== undefined && object.additionalCases !== null)
        ? Fulfillment_ConditionalCases.fromPartial(object.additionalCases)
        : undefined;
      return message;
    },
  };

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
