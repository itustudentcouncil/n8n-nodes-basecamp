// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dialogflow/cx/v3/advanced_settings.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration.js";
import { GcsDestination } from "./gcs.js";

export const protobufPackage = "google.cloud.dialogflow.cx.v3";

/**
 * Hierarchical advanced settings for agent/flow/page/fulfillment/parameter.
 * Settings exposed at lower level overrides the settings exposed at higher
 * level. Overriding occurs at the sub-setting level. For example, the
 * playback_interruption_settings at fulfillment level only overrides the
 * playback_interruption_settings at the agent level, leaving other settings
 * at the agent level unchanged.
 *
 * DTMF settings does not override each other. DTMF settings set at different
 * levels define DTMF detections running in parallel.
 *
 * Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
 */
export interface AdvancedSettings {
  /**
   * If present, incoming audio is exported by Dialogflow to the configured
   * Google Cloud Storage destination.
   * Exposed at the following levels:
   * - Agent level
   * - Flow level
   */
  audioExportGcsDestination:
    | GcsDestination
    | undefined;
  /**
   * Settings for speech to text detection.
   * Exposed at the following levels:
   * - Agent level
   * - Flow level
   * - Page level
   * - Parameter level
   */
  speechSettings:
    | AdvancedSettings_SpeechSettings
    | undefined;
  /**
   * Settings for DTMF.
   * Exposed at the following levels:
   * - Agent level
   * - Flow level
   * - Page level
   * - Parameter level.
   */
  dtmfSettings:
    | AdvancedSettings_DtmfSettings
    | undefined;
  /**
   * Settings for logging.
   * Settings for Dialogflow History, Contact Center messages, StackDriver logs,
   * and speech logging.
   * Exposed at the following levels:
   * - Agent level.
   */
  loggingSettings: AdvancedSettings_LoggingSettings | undefined;
}

/** Define behaviors of speech to text detection. */
export interface AdvancedSettings_SpeechSettings {
  /**
   * Sensitivity of the speech model that detects the end of speech.
   * Scale from 0 to 100.
   */
  endpointerSensitivity: number;
  /** Timeout before detecting no speech. */
  noSpeechTimeout:
    | Duration
    | undefined;
  /**
   * Use timeout based endpointing, interpreting endpointer sensitivy as
   * seconds of timeout value.
   */
  useTimeoutBasedEndpointing: boolean;
  /**
   * Mapping from language to Speech-to-Text model. The mapped Speech-to-Text
   * model will be selected for requests from its corresponding language.
   * For more information, see
   * [Speech
   * models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
   */
  models: { [key: string]: string };
}

export interface AdvancedSettings_SpeechSettings_ModelsEntry {
  key: string;
  value: string;
}

/** Define behaviors for DTMF (dual tone multi frequency). */
export interface AdvancedSettings_DtmfSettings {
  /**
   * If true, incoming audio is processed for DTMF (dual tone multi frequency)
   * events. For example, if the caller presses a button on their telephone
   * keypad and DTMF processing is enabled, Dialogflow will detect the
   * event (e.g. a "3" was pressed) in the incoming audio and pass the event
   * to the bot to drive business logic (e.g. when 3 is pressed, return the
   * account balance).
   */
  enabled: boolean;
  /** Max length of DTMF digits. */
  maxDigits: number;
  /** The digit that terminates a DTMF digit sequence. */
  finishDigit: string;
  /** Interdigit timeout setting for matching dtmf input to regex. */
  interdigitTimeoutDuration:
    | Duration
    | undefined;
  /** Endpoint timeout setting for matching dtmf input to regex. */
  endpointingTimeoutDuration: Duration | undefined;
}

/** Define behaviors on logging. */
export interface AdvancedSettings_LoggingSettings {
  /** Enables StackDriver logging. */
  enableStackdriverLogging: boolean;
  /** Enables DF Interaction logging. */
  enableInteractionLogging: boolean;
  /**
   * Enables consent-based end-user input redaction, if true, a pre-defined
   * session parameter `$session.params.conversation-redaction` will be
   * used to determine if the utterance should be redacted.
   */
  enableConsentBasedRedaction: boolean;
}

function createBaseAdvancedSettings(): AdvancedSettings {
  return {
    audioExportGcsDestination: undefined,
    speechSettings: undefined,
    dtmfSettings: undefined,
    loggingSettings: undefined,
  };
}

export const AdvancedSettings: MessageFns<AdvancedSettings> = {
  encode(message: AdvancedSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audioExportGcsDestination !== undefined) {
      GcsDestination.encode(message.audioExportGcsDestination, writer.uint32(18).fork()).join();
    }
    if (message.speechSettings !== undefined) {
      AdvancedSettings_SpeechSettings.encode(message.speechSettings, writer.uint32(26).fork()).join();
    }
    if (message.dtmfSettings !== undefined) {
      AdvancedSettings_DtmfSettings.encode(message.dtmfSettings, writer.uint32(42).fork()).join();
    }
    if (message.loggingSettings !== undefined) {
      AdvancedSettings_LoggingSettings.encode(message.loggingSettings, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvancedSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvancedSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audioExportGcsDestination = GcsDestination.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.speechSettings = AdvancedSettings_SpeechSettings.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dtmfSettings = AdvancedSettings_DtmfSettings.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.loggingSettings = AdvancedSettings_LoggingSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvancedSettings {
    return {
      audioExportGcsDestination: isSet(object.audioExportGcsDestination)
        ? GcsDestination.fromJSON(object.audioExportGcsDestination)
        : undefined,
      speechSettings: isSet(object.speechSettings)
        ? AdvancedSettings_SpeechSettings.fromJSON(object.speechSettings)
        : undefined,
      dtmfSettings: isSet(object.dtmfSettings)
        ? AdvancedSettings_DtmfSettings.fromJSON(object.dtmfSettings)
        : undefined,
      loggingSettings: isSet(object.loggingSettings)
        ? AdvancedSettings_LoggingSettings.fromJSON(object.loggingSettings)
        : undefined,
    };
  },

  toJSON(message: AdvancedSettings): unknown {
    const obj: any = {};
    if (message.audioExportGcsDestination !== undefined) {
      obj.audioExportGcsDestination = GcsDestination.toJSON(message.audioExportGcsDestination);
    }
    if (message.speechSettings !== undefined) {
      obj.speechSettings = AdvancedSettings_SpeechSettings.toJSON(message.speechSettings);
    }
    if (message.dtmfSettings !== undefined) {
      obj.dtmfSettings = AdvancedSettings_DtmfSettings.toJSON(message.dtmfSettings);
    }
    if (message.loggingSettings !== undefined) {
      obj.loggingSettings = AdvancedSettings_LoggingSettings.toJSON(message.loggingSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<AdvancedSettings>): AdvancedSettings {
    return AdvancedSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdvancedSettings>): AdvancedSettings {
    const message = createBaseAdvancedSettings();
    message.audioExportGcsDestination =
      (object.audioExportGcsDestination !== undefined && object.audioExportGcsDestination !== null)
        ? GcsDestination.fromPartial(object.audioExportGcsDestination)
        : undefined;
    message.speechSettings = (object.speechSettings !== undefined && object.speechSettings !== null)
      ? AdvancedSettings_SpeechSettings.fromPartial(object.speechSettings)
      : undefined;
    message.dtmfSettings = (object.dtmfSettings !== undefined && object.dtmfSettings !== null)
      ? AdvancedSettings_DtmfSettings.fromPartial(object.dtmfSettings)
      : undefined;
    message.loggingSettings = (object.loggingSettings !== undefined && object.loggingSettings !== null)
      ? AdvancedSettings_LoggingSettings.fromPartial(object.loggingSettings)
      : undefined;
    return message;
  },
};

function createBaseAdvancedSettings_SpeechSettings(): AdvancedSettings_SpeechSettings {
  return { endpointerSensitivity: 0, noSpeechTimeout: undefined, useTimeoutBasedEndpointing: false, models: {} };
}

export const AdvancedSettings_SpeechSettings: MessageFns<AdvancedSettings_SpeechSettings> = {
  encode(message: AdvancedSettings_SpeechSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpointerSensitivity !== 0) {
      writer.uint32(8).int32(message.endpointerSensitivity);
    }
    if (message.noSpeechTimeout !== undefined) {
      Duration.encode(message.noSpeechTimeout, writer.uint32(18).fork()).join();
    }
    if (message.useTimeoutBasedEndpointing !== false) {
      writer.uint32(24).bool(message.useTimeoutBasedEndpointing);
    }
    Object.entries(message.models).forEach(([key, value]) => {
      AdvancedSettings_SpeechSettings_ModelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvancedSettings_SpeechSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvancedSettings_SpeechSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.endpointerSensitivity = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.noSpeechTimeout = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.useTimeoutBasedEndpointing = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = AdvancedSettings_SpeechSettings_ModelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.models[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvancedSettings_SpeechSettings {
    return {
      endpointerSensitivity: isSet(object.endpointerSensitivity) ? globalThis.Number(object.endpointerSensitivity) : 0,
      noSpeechTimeout: isSet(object.noSpeechTimeout) ? Duration.fromJSON(object.noSpeechTimeout) : undefined,
      useTimeoutBasedEndpointing: isSet(object.useTimeoutBasedEndpointing)
        ? globalThis.Boolean(object.useTimeoutBasedEndpointing)
        : false,
      models: isObject(object.models)
        ? Object.entries(object.models).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AdvancedSettings_SpeechSettings): unknown {
    const obj: any = {};
    if (message.endpointerSensitivity !== 0) {
      obj.endpointerSensitivity = Math.round(message.endpointerSensitivity);
    }
    if (message.noSpeechTimeout !== undefined) {
      obj.noSpeechTimeout = Duration.toJSON(message.noSpeechTimeout);
    }
    if (message.useTimeoutBasedEndpointing !== false) {
      obj.useTimeoutBasedEndpointing = message.useTimeoutBasedEndpointing;
    }
    if (message.models) {
      const entries = Object.entries(message.models);
      if (entries.length > 0) {
        obj.models = {};
        entries.forEach(([k, v]) => {
          obj.models[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<AdvancedSettings_SpeechSettings>): AdvancedSettings_SpeechSettings {
    return AdvancedSettings_SpeechSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdvancedSettings_SpeechSettings>): AdvancedSettings_SpeechSettings {
    const message = createBaseAdvancedSettings_SpeechSettings();
    message.endpointerSensitivity = object.endpointerSensitivity ?? 0;
    message.noSpeechTimeout = (object.noSpeechTimeout !== undefined && object.noSpeechTimeout !== null)
      ? Duration.fromPartial(object.noSpeechTimeout)
      : undefined;
    message.useTimeoutBasedEndpointing = object.useTimeoutBasedEndpointing ?? false;
    message.models = Object.entries(object.models ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAdvancedSettings_SpeechSettings_ModelsEntry(): AdvancedSettings_SpeechSettings_ModelsEntry {
  return { key: "", value: "" };
}

export const AdvancedSettings_SpeechSettings_ModelsEntry: MessageFns<AdvancedSettings_SpeechSettings_ModelsEntry> = {
  encode(
    message: AdvancedSettings_SpeechSettings_ModelsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvancedSettings_SpeechSettings_ModelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvancedSettings_SpeechSettings_ModelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvancedSettings_SpeechSettings_ModelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AdvancedSettings_SpeechSettings_ModelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AdvancedSettings_SpeechSettings_ModelsEntry>): AdvancedSettings_SpeechSettings_ModelsEntry {
    return AdvancedSettings_SpeechSettings_ModelsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AdvancedSettings_SpeechSettings_ModelsEntry>,
  ): AdvancedSettings_SpeechSettings_ModelsEntry {
    const message = createBaseAdvancedSettings_SpeechSettings_ModelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAdvancedSettings_DtmfSettings(): AdvancedSettings_DtmfSettings {
  return {
    enabled: false,
    maxDigits: 0,
    finishDigit: "",
    interdigitTimeoutDuration: undefined,
    endpointingTimeoutDuration: undefined,
  };
}

export const AdvancedSettings_DtmfSettings: MessageFns<AdvancedSettings_DtmfSettings> = {
  encode(message: AdvancedSettings_DtmfSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.maxDigits !== 0) {
      writer.uint32(16).int32(message.maxDigits);
    }
    if (message.finishDigit !== "") {
      writer.uint32(26).string(message.finishDigit);
    }
    if (message.interdigitTimeoutDuration !== undefined) {
      Duration.encode(message.interdigitTimeoutDuration, writer.uint32(50).fork()).join();
    }
    if (message.endpointingTimeoutDuration !== undefined) {
      Duration.encode(message.endpointingTimeoutDuration, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvancedSettings_DtmfSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvancedSettings_DtmfSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxDigits = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.finishDigit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.interdigitTimeoutDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.endpointingTimeoutDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvancedSettings_DtmfSettings {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      maxDigits: isSet(object.maxDigits) ? globalThis.Number(object.maxDigits) : 0,
      finishDigit: isSet(object.finishDigit) ? globalThis.String(object.finishDigit) : "",
      interdigitTimeoutDuration: isSet(object.interdigitTimeoutDuration)
        ? Duration.fromJSON(object.interdigitTimeoutDuration)
        : undefined,
      endpointingTimeoutDuration: isSet(object.endpointingTimeoutDuration)
        ? Duration.fromJSON(object.endpointingTimeoutDuration)
        : undefined,
    };
  },

  toJSON(message: AdvancedSettings_DtmfSettings): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.maxDigits !== 0) {
      obj.maxDigits = Math.round(message.maxDigits);
    }
    if (message.finishDigit !== "") {
      obj.finishDigit = message.finishDigit;
    }
    if (message.interdigitTimeoutDuration !== undefined) {
      obj.interdigitTimeoutDuration = Duration.toJSON(message.interdigitTimeoutDuration);
    }
    if (message.endpointingTimeoutDuration !== undefined) {
      obj.endpointingTimeoutDuration = Duration.toJSON(message.endpointingTimeoutDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<AdvancedSettings_DtmfSettings>): AdvancedSettings_DtmfSettings {
    return AdvancedSettings_DtmfSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdvancedSettings_DtmfSettings>): AdvancedSettings_DtmfSettings {
    const message = createBaseAdvancedSettings_DtmfSettings();
    message.enabled = object.enabled ?? false;
    message.maxDigits = object.maxDigits ?? 0;
    message.finishDigit = object.finishDigit ?? "";
    message.interdigitTimeoutDuration =
      (object.interdigitTimeoutDuration !== undefined && object.interdigitTimeoutDuration !== null)
        ? Duration.fromPartial(object.interdigitTimeoutDuration)
        : undefined;
    message.endpointingTimeoutDuration =
      (object.endpointingTimeoutDuration !== undefined && object.endpointingTimeoutDuration !== null)
        ? Duration.fromPartial(object.endpointingTimeoutDuration)
        : undefined;
    return message;
  },
};

function createBaseAdvancedSettings_LoggingSettings(): AdvancedSettings_LoggingSettings {
  return { enableStackdriverLogging: false, enableInteractionLogging: false, enableConsentBasedRedaction: false };
}

export const AdvancedSettings_LoggingSettings: MessageFns<AdvancedSettings_LoggingSettings> = {
  encode(message: AdvancedSettings_LoggingSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableStackdriverLogging !== false) {
      writer.uint32(16).bool(message.enableStackdriverLogging);
    }
    if (message.enableInteractionLogging !== false) {
      writer.uint32(24).bool(message.enableInteractionLogging);
    }
    if (message.enableConsentBasedRedaction !== false) {
      writer.uint32(32).bool(message.enableConsentBasedRedaction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvancedSettings_LoggingSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvancedSettings_LoggingSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableStackdriverLogging = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enableInteractionLogging = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enableConsentBasedRedaction = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvancedSettings_LoggingSettings {
    return {
      enableStackdriverLogging: isSet(object.enableStackdriverLogging)
        ? globalThis.Boolean(object.enableStackdriverLogging)
        : false,
      enableInteractionLogging: isSet(object.enableInteractionLogging)
        ? globalThis.Boolean(object.enableInteractionLogging)
        : false,
      enableConsentBasedRedaction: isSet(object.enableConsentBasedRedaction)
        ? globalThis.Boolean(object.enableConsentBasedRedaction)
        : false,
    };
  },

  toJSON(message: AdvancedSettings_LoggingSettings): unknown {
    const obj: any = {};
    if (message.enableStackdriverLogging !== false) {
      obj.enableStackdriverLogging = message.enableStackdriverLogging;
    }
    if (message.enableInteractionLogging !== false) {
      obj.enableInteractionLogging = message.enableInteractionLogging;
    }
    if (message.enableConsentBasedRedaction !== false) {
      obj.enableConsentBasedRedaction = message.enableConsentBasedRedaction;
    }
    return obj;
  },

  create(base?: DeepPartial<AdvancedSettings_LoggingSettings>): AdvancedSettings_LoggingSettings {
    return AdvancedSettings_LoggingSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdvancedSettings_LoggingSettings>): AdvancedSettings_LoggingSettings {
    const message = createBaseAdvancedSettings_LoggingSettings();
    message.enableStackdriverLogging = object.enableStackdriverLogging ?? false;
    message.enableInteractionLogging = object.enableInteractionLogging ?? false;
    message.enableConsentBasedRedaction = object.enableConsentBasedRedaction ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
