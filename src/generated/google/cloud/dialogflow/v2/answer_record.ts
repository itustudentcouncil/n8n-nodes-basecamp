// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dialogflow/v2/answer_record.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { ArticleAnswer, DialogflowAssistAnswer, FaqAnswer } from "./participant.js";

export const protobufPackage = "google.cloud.dialogflow.v2";

/**
 * Answer records are records to manage answer history and feedbacks for
 * Dialogflow.
 *
 * Currently, answer record includes:
 *
 * - human agent assistant article suggestion
 * - human agent assistant faq article
 *
 * It doesn't include:
 *
 * - `DetectIntent` intent matching
 * - `DetectIntent` knowledge
 *
 * Answer records are not related to the conversation history in the
 * Dialogflow Console. A Record is generated even when the end-user disables
 * conversation history in the console. Records are created when there's a human
 * agent assistant suggestion generated.
 *
 * A typical workflow for customers provide feedback to an answer is:
 *
 * 1. For human agent assistant, customers get suggestion via ListSuggestions
 *    API. Together with the answers,
 *    [AnswerRecord.name][google.cloud.dialogflow.v2.AnswerRecord.name] are
 *    returned to the customers.
 * 2. The customer uses the
 * [AnswerRecord.name][google.cloud.dialogflow.v2.AnswerRecord.name] to call the
 *    [UpdateAnswerRecord][] method to send feedback about a specific answer
 *    that they believe is wrong.
 */
export interface AnswerRecord {
  /**
   * The unique identifier of this answer record.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/answerRecords/<Answer Record ID>`.
   */
  name: string;
  /**
   * Required. The AnswerFeedback for this record. You can set this with
   * [AnswerRecords.UpdateAnswerRecord][google.cloud.dialogflow.v2.AnswerRecords.UpdateAnswerRecord]
   * in order to give us feedback about this answer.
   */
  answerFeedback:
    | AnswerFeedback
    | undefined;
  /** Output only. The record for human agent assistant. */
  agentAssistantRecord?: AgentAssistantRecord | undefined;
}

/**
 * Request message for
 * [AnswerRecords.ListAnswerRecords][google.cloud.dialogflow.v2.AnswerRecords.ListAnswerRecords].
 */
export interface ListAnswerRecordsRequest {
  /**
   * Required. The project to list all answer records for in reverse
   * chronological order. Format: `projects/<Project ID>/locations/<Location
   * ID>`.
   */
  parent: string;
  /**
   * Optional. Filters to restrict results to specific answer records.
   *
   * Marked deprecated as it hasn't been, and isn't currently, supported.
   *
   * For more information about filtering, see
   * [API Filtering](https://aip.dev/160).
   *
   * @deprecated
   */
  filter: string;
  /**
   * Optional. The maximum number of records to return in a single page.
   * The server may return fewer records than this. If unspecified, we use 10.
   * The maximum is 100.
   */
  pageSize: number;
  /**
   * Optional. The
   * [ListAnswerRecordsResponse.next_page_token][google.cloud.dialogflow.v2.ListAnswerRecordsResponse.next_page_token]
   * value returned from a previous list request used to continue listing on
   * the next page.
   */
  pageToken: string;
}

/**
 * Response message for
 * [AnswerRecords.ListAnswerRecords][google.cloud.dialogflow.v2.AnswerRecords.ListAnswerRecords].
 */
export interface ListAnswerRecordsResponse {
  /** The list of answer records. */
  answerRecords: AnswerRecord[];
  /**
   * A token to retrieve next page of results. Or empty if there are no more
   * results.
   * Pass this value in the
   * [ListAnswerRecordsRequest.page_token][google.cloud.dialogflow.v2.ListAnswerRecordsRequest.page_token]
   * field in the subsequent call to `ListAnswerRecords` method to retrieve the
   * next page of results.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [AnswerRecords.UpdateAnswerRecord][google.cloud.dialogflow.v2.AnswerRecords.UpdateAnswerRecord].
 */
export interface UpdateAnswerRecordRequest {
  /** Required. Answer record to update. */
  answerRecord:
    | AnswerRecord
    | undefined;
  /** Required. The mask to control which fields get updated. */
  updateMask: string[] | undefined;
}

/**
 * Represents feedback the customer has about the quality & correctness of a
 * certain answer in a conversation.
 */
export interface AnswerFeedback {
  /** The correctness level of the specific answer. */
  correctnessLevel: AnswerFeedback_CorrectnessLevel;
  /** Detail feedback of agent assist suggestions. */
  agentAssistantDetailFeedback?:
    | AgentAssistantFeedback
    | undefined;
  /**
   * Indicates whether the answer/item was clicked by the human agent
   * or not. Default to false.
   * For knowledge search and knowledge assist, the answer record is considered
   * to be clicked if the answer was copied or any URI was clicked.
   */
  clicked: boolean;
  /** Time when the answer/item was clicked. */
  clickTime:
    | Date
    | undefined;
  /**
   * Indicates whether the answer/item was displayed to the human
   * agent in the agent desktop UI. Default to false.
   */
  displayed: boolean;
  /** Time when the answer/item was displayed. */
  displayTime: Date | undefined;
}

/** The correctness level of an answer. */
export enum AnswerFeedback_CorrectnessLevel {
  /** CORRECTNESS_LEVEL_UNSPECIFIED - Correctness level unspecified. */
  CORRECTNESS_LEVEL_UNSPECIFIED = 0,
  /** NOT_CORRECT - Answer is totally wrong. */
  NOT_CORRECT = 1,
  /** PARTIALLY_CORRECT - Answer is partially correct. */
  PARTIALLY_CORRECT = 2,
  /** FULLY_CORRECT - Answer is fully correct. */
  FULLY_CORRECT = 3,
  UNRECOGNIZED = -1,
}

export function answerFeedback_CorrectnessLevelFromJSON(object: any): AnswerFeedback_CorrectnessLevel {
  switch (object) {
    case 0:
    case "CORRECTNESS_LEVEL_UNSPECIFIED":
      return AnswerFeedback_CorrectnessLevel.CORRECTNESS_LEVEL_UNSPECIFIED;
    case 1:
    case "NOT_CORRECT":
      return AnswerFeedback_CorrectnessLevel.NOT_CORRECT;
    case 2:
    case "PARTIALLY_CORRECT":
      return AnswerFeedback_CorrectnessLevel.PARTIALLY_CORRECT;
    case 3:
    case "FULLY_CORRECT":
      return AnswerFeedback_CorrectnessLevel.FULLY_CORRECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnswerFeedback_CorrectnessLevel.UNRECOGNIZED;
  }
}

export function answerFeedback_CorrectnessLevelToJSON(object: AnswerFeedback_CorrectnessLevel): string {
  switch (object) {
    case AnswerFeedback_CorrectnessLevel.CORRECTNESS_LEVEL_UNSPECIFIED:
      return "CORRECTNESS_LEVEL_UNSPECIFIED";
    case AnswerFeedback_CorrectnessLevel.NOT_CORRECT:
      return "NOT_CORRECT";
    case AnswerFeedback_CorrectnessLevel.PARTIALLY_CORRECT:
      return "PARTIALLY_CORRECT";
    case AnswerFeedback_CorrectnessLevel.FULLY_CORRECT:
      return "FULLY_CORRECT";
    case AnswerFeedback_CorrectnessLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Detail feedback of Agent Assist result. */
export interface AgentAssistantFeedback {
  /**
   * Optional. Whether or not the suggested answer is relevant.
   *
   * For example:
   *
   * * Query: "Can I change my mailing address?"
   * * Suggested document says: "Items must be returned/exchanged within 60
   *   days of the purchase date."
   * * [answer_relevance][google.cloud.dialogflow.v2.AgentAssistantFeedback.answer_relevance]: [AnswerRelevance.IRRELEVANT][google.cloud.dialogflow.v2.AgentAssistantFeedback.AnswerRelevance.IRRELEVANT]
   */
  answerRelevance: AgentAssistantFeedback_AnswerRelevance;
  /**
   * Optional. Whether or not the information in the document is correct.
   *
   * For example:
   *
   * * Query: "Can I return the package in 2 days once received?"
   * * Suggested document says: "Items must be returned/exchanged within 60
   *   days of the purchase date."
   * * Ground truth: "No return or exchange is allowed."
   * * [document_correctness]: INCORRECT
   */
  documentCorrectness: AgentAssistantFeedback_DocumentCorrectness;
  /**
   * Optional. Whether or not the suggested document is efficient. For example,
   * if the document is poorly written, hard to understand, hard to use or
   * too long to find useful information,
   * [document_efficiency][google.cloud.dialogflow.v2.AgentAssistantFeedback.document_efficiency]
   * is
   * [DocumentEfficiency.INEFFICIENT][google.cloud.dialogflow.v2.AgentAssistantFeedback.DocumentEfficiency.INEFFICIENT].
   */
  documentEfficiency: AgentAssistantFeedback_DocumentEfficiency;
  /** Optional. Feedback for conversation summarization. */
  summarizationFeedback:
    | AgentAssistantFeedback_SummarizationFeedback
    | undefined;
  /** Optional. Feedback for knowledge search. */
  knowledgeSearchFeedback:
    | AgentAssistantFeedback_KnowledgeSearchFeedback
    | undefined;
  /** Optional. Feedback for knowledge assist. */
  knowledgeAssistFeedback: AgentAssistantFeedback_KnowledgeAssistFeedback | undefined;
}

/** Relevance of an answer. */
export enum AgentAssistantFeedback_AnswerRelevance {
  /** ANSWER_RELEVANCE_UNSPECIFIED - Answer relevance unspecified. */
  ANSWER_RELEVANCE_UNSPECIFIED = 0,
  /** IRRELEVANT - Answer is irrelevant to query. */
  IRRELEVANT = 1,
  /** RELEVANT - Answer is relevant to query. */
  RELEVANT = 2,
  UNRECOGNIZED = -1,
}

export function agentAssistantFeedback_AnswerRelevanceFromJSON(object: any): AgentAssistantFeedback_AnswerRelevance {
  switch (object) {
    case 0:
    case "ANSWER_RELEVANCE_UNSPECIFIED":
      return AgentAssistantFeedback_AnswerRelevance.ANSWER_RELEVANCE_UNSPECIFIED;
    case 1:
    case "IRRELEVANT":
      return AgentAssistantFeedback_AnswerRelevance.IRRELEVANT;
    case 2:
    case "RELEVANT":
      return AgentAssistantFeedback_AnswerRelevance.RELEVANT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AgentAssistantFeedback_AnswerRelevance.UNRECOGNIZED;
  }
}

export function agentAssistantFeedback_AnswerRelevanceToJSON(object: AgentAssistantFeedback_AnswerRelevance): string {
  switch (object) {
    case AgentAssistantFeedback_AnswerRelevance.ANSWER_RELEVANCE_UNSPECIFIED:
      return "ANSWER_RELEVANCE_UNSPECIFIED";
    case AgentAssistantFeedback_AnswerRelevance.IRRELEVANT:
      return "IRRELEVANT";
    case AgentAssistantFeedback_AnswerRelevance.RELEVANT:
      return "RELEVANT";
    case AgentAssistantFeedback_AnswerRelevance.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Correctness of document. */
export enum AgentAssistantFeedback_DocumentCorrectness {
  /** DOCUMENT_CORRECTNESS_UNSPECIFIED - Document correctness unspecified. */
  DOCUMENT_CORRECTNESS_UNSPECIFIED = 0,
  /** INCORRECT - Information in document is incorrect. */
  INCORRECT = 1,
  /** CORRECT - Information in document is correct. */
  CORRECT = 2,
  UNRECOGNIZED = -1,
}

export function agentAssistantFeedback_DocumentCorrectnessFromJSON(
  object: any,
): AgentAssistantFeedback_DocumentCorrectness {
  switch (object) {
    case 0:
    case "DOCUMENT_CORRECTNESS_UNSPECIFIED":
      return AgentAssistantFeedback_DocumentCorrectness.DOCUMENT_CORRECTNESS_UNSPECIFIED;
    case 1:
    case "INCORRECT":
      return AgentAssistantFeedback_DocumentCorrectness.INCORRECT;
    case 2:
    case "CORRECT":
      return AgentAssistantFeedback_DocumentCorrectness.CORRECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AgentAssistantFeedback_DocumentCorrectness.UNRECOGNIZED;
  }
}

export function agentAssistantFeedback_DocumentCorrectnessToJSON(
  object: AgentAssistantFeedback_DocumentCorrectness,
): string {
  switch (object) {
    case AgentAssistantFeedback_DocumentCorrectness.DOCUMENT_CORRECTNESS_UNSPECIFIED:
      return "DOCUMENT_CORRECTNESS_UNSPECIFIED";
    case AgentAssistantFeedback_DocumentCorrectness.INCORRECT:
      return "INCORRECT";
    case AgentAssistantFeedback_DocumentCorrectness.CORRECT:
      return "CORRECT";
    case AgentAssistantFeedback_DocumentCorrectness.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Efficiency of document. */
export enum AgentAssistantFeedback_DocumentEfficiency {
  /** DOCUMENT_EFFICIENCY_UNSPECIFIED - Document efficiency unspecified. */
  DOCUMENT_EFFICIENCY_UNSPECIFIED = 0,
  /** INEFFICIENT - Document is inefficient. */
  INEFFICIENT = 1,
  /** EFFICIENT - Document is efficient. */
  EFFICIENT = 2,
  UNRECOGNIZED = -1,
}

export function agentAssistantFeedback_DocumentEfficiencyFromJSON(
  object: any,
): AgentAssistantFeedback_DocumentEfficiency {
  switch (object) {
    case 0:
    case "DOCUMENT_EFFICIENCY_UNSPECIFIED":
      return AgentAssistantFeedback_DocumentEfficiency.DOCUMENT_EFFICIENCY_UNSPECIFIED;
    case 1:
    case "INEFFICIENT":
      return AgentAssistantFeedback_DocumentEfficiency.INEFFICIENT;
    case 2:
    case "EFFICIENT":
      return AgentAssistantFeedback_DocumentEfficiency.EFFICIENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AgentAssistantFeedback_DocumentEfficiency.UNRECOGNIZED;
  }
}

export function agentAssistantFeedback_DocumentEfficiencyToJSON(
  object: AgentAssistantFeedback_DocumentEfficiency,
): string {
  switch (object) {
    case AgentAssistantFeedback_DocumentEfficiency.DOCUMENT_EFFICIENCY_UNSPECIFIED:
      return "DOCUMENT_EFFICIENCY_UNSPECIFIED";
    case AgentAssistantFeedback_DocumentEfficiency.INEFFICIENT:
      return "INEFFICIENT";
    case AgentAssistantFeedback_DocumentEfficiency.EFFICIENT:
      return "EFFICIENT";
    case AgentAssistantFeedback_DocumentEfficiency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Feedback for conversation summarization. */
export interface AgentAssistantFeedback_SummarizationFeedback {
  /** Timestamp when composing of the summary starts. */
  startTime:
    | Date
    | undefined;
  /** Timestamp when the summary was submitted. */
  submitTime:
    | Date
    | undefined;
  /** Text of actual submitted summary. */
  summaryText: string;
  /** Optional. Actual text sections of submitted summary. */
  textSections: { [key: string]: string };
}

export interface AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry {
  key: string;
  value: string;
}

/** Feedback for knowledge search. */
export interface AgentAssistantFeedback_KnowledgeSearchFeedback {
  /**
   * Whether the answer was copied by the human agent or not.
   * If the value is set to be true,
   * [AnswerFeedback.clicked][google.cloud.dialogflow.v2.AnswerFeedback.clicked]
   * will be updated to be true.
   */
  answerCopied: boolean;
  /**
   * The URIs clicked by the human agent. The value is appended for each
   * [UpdateAnswerRecordRequest][google.cloud.dialogflow.v2.UpdateAnswerRecordRequest].
   * If the value is not empty,
   * [AnswerFeedback.clicked][google.cloud.dialogflow.v2.AnswerFeedback.clicked]
   * will be updated to be true.
   */
  clickedUris: string[];
}

/** Feedback for knowledge assist. */
export interface AgentAssistantFeedback_KnowledgeAssistFeedback {
  /**
   * Whether the suggested answer was copied by the human agent.
   * If the value is set to be true,
   * [AnswerFeedback.clicked][google.cloud.dialogflow.v2.AnswerFeedback.clicked]
   * will be updated to be true.
   */
  answerCopied: boolean;
  /**
   * The URIs clicked by the human agent. The value is appended for each
   * UpdateAnswerRecordRequest.
   * If the value is not empty,
   * [AnswerFeedback.clicked][google.cloud.dialogflow.v2.AnswerFeedback.clicked]
   * will be updated to be true.
   */
  clickedUris: string[];
}

/** Represents a record of a human agent assist answer. */
export interface AgentAssistantRecord {
  /** Output only. The article suggestion answer. */
  articleSuggestionAnswer?:
    | ArticleAnswer
    | undefined;
  /** Output only. The FAQ answer. */
  faqAnswer?:
    | FaqAnswer
    | undefined;
  /** Output only. Dialogflow assist answer. */
  dialogflowAssistAnswer?: DialogflowAssistAnswer | undefined;
}

function createBaseAnswerRecord(): AnswerRecord {
  return { name: "", answerFeedback: undefined, agentAssistantRecord: undefined };
}

export const AnswerRecord: MessageFns<AnswerRecord> = {
  encode(message: AnswerRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.answerFeedback !== undefined) {
      AnswerFeedback.encode(message.answerFeedback, writer.uint32(18).fork()).join();
    }
    if (message.agentAssistantRecord !== undefined) {
      AgentAssistantRecord.encode(message.agentAssistantRecord, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnswerRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswerRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.answerFeedback = AnswerFeedback.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.agentAssistantRecord = AgentAssistantRecord.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnswerRecord {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      answerFeedback: isSet(object.answerFeedback) ? AnswerFeedback.fromJSON(object.answerFeedback) : undefined,
      agentAssistantRecord: isSet(object.agentAssistantRecord)
        ? AgentAssistantRecord.fromJSON(object.agentAssistantRecord)
        : undefined,
    };
  },

  toJSON(message: AnswerRecord): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.answerFeedback !== undefined) {
      obj.answerFeedback = AnswerFeedback.toJSON(message.answerFeedback);
    }
    if (message.agentAssistantRecord !== undefined) {
      obj.agentAssistantRecord = AgentAssistantRecord.toJSON(message.agentAssistantRecord);
    }
    return obj;
  },

  create(base?: DeepPartial<AnswerRecord>): AnswerRecord {
    return AnswerRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnswerRecord>): AnswerRecord {
    const message = createBaseAnswerRecord();
    message.name = object.name ?? "";
    message.answerFeedback = (object.answerFeedback !== undefined && object.answerFeedback !== null)
      ? AnswerFeedback.fromPartial(object.answerFeedback)
      : undefined;
    message.agentAssistantRecord = (object.agentAssistantRecord !== undefined && object.agentAssistantRecord !== null)
      ? AgentAssistantRecord.fromPartial(object.agentAssistantRecord)
      : undefined;
    return message;
  },
};

function createBaseListAnswerRecordsRequest(): ListAnswerRecordsRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListAnswerRecordsRequest: MessageFns<ListAnswerRecordsRequest> = {
  encode(message: ListAnswerRecordsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAnswerRecordsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAnswerRecordsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAnswerRecordsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListAnswerRecordsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAnswerRecordsRequest>): ListAnswerRecordsRequest {
    return ListAnswerRecordsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAnswerRecordsRequest>): ListAnswerRecordsRequest {
    const message = createBaseListAnswerRecordsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListAnswerRecordsResponse(): ListAnswerRecordsResponse {
  return { answerRecords: [], nextPageToken: "" };
}

export const ListAnswerRecordsResponse: MessageFns<ListAnswerRecordsResponse> = {
  encode(message: ListAnswerRecordsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.answerRecords) {
      AnswerRecord.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAnswerRecordsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAnswerRecordsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.answerRecords.push(AnswerRecord.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAnswerRecordsResponse {
    return {
      answerRecords: globalThis.Array.isArray(object?.answerRecords)
        ? object.answerRecords.map((e: any) => AnswerRecord.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAnswerRecordsResponse): unknown {
    const obj: any = {};
    if (message.answerRecords?.length) {
      obj.answerRecords = message.answerRecords.map((e) => AnswerRecord.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAnswerRecordsResponse>): ListAnswerRecordsResponse {
    return ListAnswerRecordsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAnswerRecordsResponse>): ListAnswerRecordsResponse {
    const message = createBaseListAnswerRecordsResponse();
    message.answerRecords = object.answerRecords?.map((e) => AnswerRecord.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateAnswerRecordRequest(): UpdateAnswerRecordRequest {
  return { answerRecord: undefined, updateMask: undefined };
}

export const UpdateAnswerRecordRequest: MessageFns<UpdateAnswerRecordRequest> = {
  encode(message: UpdateAnswerRecordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answerRecord !== undefined) {
      AnswerRecord.encode(message.answerRecord, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAnswerRecordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAnswerRecordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.answerRecord = AnswerRecord.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAnswerRecordRequest {
    return {
      answerRecord: isSet(object.answerRecord) ? AnswerRecord.fromJSON(object.answerRecord) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateAnswerRecordRequest): unknown {
    const obj: any = {};
    if (message.answerRecord !== undefined) {
      obj.answerRecord = AnswerRecord.toJSON(message.answerRecord);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAnswerRecordRequest>): UpdateAnswerRecordRequest {
    return UpdateAnswerRecordRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAnswerRecordRequest>): UpdateAnswerRecordRequest {
    const message = createBaseUpdateAnswerRecordRequest();
    message.answerRecord = (object.answerRecord !== undefined && object.answerRecord !== null)
      ? AnswerRecord.fromPartial(object.answerRecord)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseAnswerFeedback(): AnswerFeedback {
  return {
    correctnessLevel: 0,
    agentAssistantDetailFeedback: undefined,
    clicked: false,
    clickTime: undefined,
    displayed: false,
    displayTime: undefined,
  };
}

export const AnswerFeedback: MessageFns<AnswerFeedback> = {
  encode(message: AnswerFeedback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.correctnessLevel !== 0) {
      writer.uint32(8).int32(message.correctnessLevel);
    }
    if (message.agentAssistantDetailFeedback !== undefined) {
      AgentAssistantFeedback.encode(message.agentAssistantDetailFeedback, writer.uint32(18).fork()).join();
    }
    if (message.clicked !== false) {
      writer.uint32(24).bool(message.clicked);
    }
    if (message.clickTime !== undefined) {
      Timestamp.encode(toTimestamp(message.clickTime), writer.uint32(42).fork()).join();
    }
    if (message.displayed !== false) {
      writer.uint32(32).bool(message.displayed);
    }
    if (message.displayTime !== undefined) {
      Timestamp.encode(toTimestamp(message.displayTime), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnswerFeedback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswerFeedback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.correctnessLevel = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.agentAssistantDetailFeedback = AgentAssistantFeedback.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.clicked = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.clickTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.displayed = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.displayTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnswerFeedback {
    return {
      correctnessLevel: isSet(object.correctnessLevel)
        ? answerFeedback_CorrectnessLevelFromJSON(object.correctnessLevel)
        : 0,
      agentAssistantDetailFeedback: isSet(object.agentAssistantDetailFeedback)
        ? AgentAssistantFeedback.fromJSON(object.agentAssistantDetailFeedback)
        : undefined,
      clicked: isSet(object.clicked) ? globalThis.Boolean(object.clicked) : false,
      clickTime: isSet(object.clickTime) ? fromJsonTimestamp(object.clickTime) : undefined,
      displayed: isSet(object.displayed) ? globalThis.Boolean(object.displayed) : false,
      displayTime: isSet(object.displayTime) ? fromJsonTimestamp(object.displayTime) : undefined,
    };
  },

  toJSON(message: AnswerFeedback): unknown {
    const obj: any = {};
    if (message.correctnessLevel !== 0) {
      obj.correctnessLevel = answerFeedback_CorrectnessLevelToJSON(message.correctnessLevel);
    }
    if (message.agentAssistantDetailFeedback !== undefined) {
      obj.agentAssistantDetailFeedback = AgentAssistantFeedback.toJSON(message.agentAssistantDetailFeedback);
    }
    if (message.clicked !== false) {
      obj.clicked = message.clicked;
    }
    if (message.clickTime !== undefined) {
      obj.clickTime = message.clickTime.toISOString();
    }
    if (message.displayed !== false) {
      obj.displayed = message.displayed;
    }
    if (message.displayTime !== undefined) {
      obj.displayTime = message.displayTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AnswerFeedback>): AnswerFeedback {
    return AnswerFeedback.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnswerFeedback>): AnswerFeedback {
    const message = createBaseAnswerFeedback();
    message.correctnessLevel = object.correctnessLevel ?? 0;
    message.agentAssistantDetailFeedback =
      (object.agentAssistantDetailFeedback !== undefined && object.agentAssistantDetailFeedback !== null)
        ? AgentAssistantFeedback.fromPartial(object.agentAssistantDetailFeedback)
        : undefined;
    message.clicked = object.clicked ?? false;
    message.clickTime = object.clickTime ?? undefined;
    message.displayed = object.displayed ?? false;
    message.displayTime = object.displayTime ?? undefined;
    return message;
  },
};

function createBaseAgentAssistantFeedback(): AgentAssistantFeedback {
  return {
    answerRelevance: 0,
    documentCorrectness: 0,
    documentEfficiency: 0,
    summarizationFeedback: undefined,
    knowledgeSearchFeedback: undefined,
    knowledgeAssistFeedback: undefined,
  };
}

export const AgentAssistantFeedback: MessageFns<AgentAssistantFeedback> = {
  encode(message: AgentAssistantFeedback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answerRelevance !== 0) {
      writer.uint32(8).int32(message.answerRelevance);
    }
    if (message.documentCorrectness !== 0) {
      writer.uint32(16).int32(message.documentCorrectness);
    }
    if (message.documentEfficiency !== 0) {
      writer.uint32(24).int32(message.documentEfficiency);
    }
    if (message.summarizationFeedback !== undefined) {
      AgentAssistantFeedback_SummarizationFeedback.encode(message.summarizationFeedback, writer.uint32(34).fork())
        .join();
    }
    if (message.knowledgeSearchFeedback !== undefined) {
      AgentAssistantFeedback_KnowledgeSearchFeedback.encode(message.knowledgeSearchFeedback, writer.uint32(42).fork())
        .join();
    }
    if (message.knowledgeAssistFeedback !== undefined) {
      AgentAssistantFeedback_KnowledgeAssistFeedback.encode(message.knowledgeAssistFeedback, writer.uint32(50).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentAssistantFeedback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentAssistantFeedback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.answerRelevance = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.documentCorrectness = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.documentEfficiency = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.summarizationFeedback = AgentAssistantFeedback_SummarizationFeedback.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.knowledgeSearchFeedback = AgentAssistantFeedback_KnowledgeSearchFeedback.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.knowledgeAssistFeedback = AgentAssistantFeedback_KnowledgeAssistFeedback.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentAssistantFeedback {
    return {
      answerRelevance: isSet(object.answerRelevance)
        ? agentAssistantFeedback_AnswerRelevanceFromJSON(object.answerRelevance)
        : 0,
      documentCorrectness: isSet(object.documentCorrectness)
        ? agentAssistantFeedback_DocumentCorrectnessFromJSON(object.documentCorrectness)
        : 0,
      documentEfficiency: isSet(object.documentEfficiency)
        ? agentAssistantFeedback_DocumentEfficiencyFromJSON(object.documentEfficiency)
        : 0,
      summarizationFeedback: isSet(object.summarizationFeedback)
        ? AgentAssistantFeedback_SummarizationFeedback.fromJSON(object.summarizationFeedback)
        : undefined,
      knowledgeSearchFeedback: isSet(object.knowledgeSearchFeedback)
        ? AgentAssistantFeedback_KnowledgeSearchFeedback.fromJSON(object.knowledgeSearchFeedback)
        : undefined,
      knowledgeAssistFeedback: isSet(object.knowledgeAssistFeedback)
        ? AgentAssistantFeedback_KnowledgeAssistFeedback.fromJSON(object.knowledgeAssistFeedback)
        : undefined,
    };
  },

  toJSON(message: AgentAssistantFeedback): unknown {
    const obj: any = {};
    if (message.answerRelevance !== 0) {
      obj.answerRelevance = agentAssistantFeedback_AnswerRelevanceToJSON(message.answerRelevance);
    }
    if (message.documentCorrectness !== 0) {
      obj.documentCorrectness = agentAssistantFeedback_DocumentCorrectnessToJSON(message.documentCorrectness);
    }
    if (message.documentEfficiency !== 0) {
      obj.documentEfficiency = agentAssistantFeedback_DocumentEfficiencyToJSON(message.documentEfficiency);
    }
    if (message.summarizationFeedback !== undefined) {
      obj.summarizationFeedback = AgentAssistantFeedback_SummarizationFeedback.toJSON(message.summarizationFeedback);
    }
    if (message.knowledgeSearchFeedback !== undefined) {
      obj.knowledgeSearchFeedback = AgentAssistantFeedback_KnowledgeSearchFeedback.toJSON(
        message.knowledgeSearchFeedback,
      );
    }
    if (message.knowledgeAssistFeedback !== undefined) {
      obj.knowledgeAssistFeedback = AgentAssistantFeedback_KnowledgeAssistFeedback.toJSON(
        message.knowledgeAssistFeedback,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AgentAssistantFeedback>): AgentAssistantFeedback {
    return AgentAssistantFeedback.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentAssistantFeedback>): AgentAssistantFeedback {
    const message = createBaseAgentAssistantFeedback();
    message.answerRelevance = object.answerRelevance ?? 0;
    message.documentCorrectness = object.documentCorrectness ?? 0;
    message.documentEfficiency = object.documentEfficiency ?? 0;
    message.summarizationFeedback =
      (object.summarizationFeedback !== undefined && object.summarizationFeedback !== null)
        ? AgentAssistantFeedback_SummarizationFeedback.fromPartial(object.summarizationFeedback)
        : undefined;
    message.knowledgeSearchFeedback =
      (object.knowledgeSearchFeedback !== undefined && object.knowledgeSearchFeedback !== null)
        ? AgentAssistantFeedback_KnowledgeSearchFeedback.fromPartial(object.knowledgeSearchFeedback)
        : undefined;
    message.knowledgeAssistFeedback =
      (object.knowledgeAssistFeedback !== undefined && object.knowledgeAssistFeedback !== null)
        ? AgentAssistantFeedback_KnowledgeAssistFeedback.fromPartial(object.knowledgeAssistFeedback)
        : undefined;
    return message;
  },
};

function createBaseAgentAssistantFeedback_SummarizationFeedback(): AgentAssistantFeedback_SummarizationFeedback {
  return { startTime: undefined, submitTime: undefined, summaryText: "", textSections: {} };
}

export const AgentAssistantFeedback_SummarizationFeedback: MessageFns<AgentAssistantFeedback_SummarizationFeedback> = {
  encode(
    message: AgentAssistantFeedback_SummarizationFeedback,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.submitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(18).fork()).join();
    }
    if (message.summaryText !== "") {
      writer.uint32(26).string(message.summaryText);
    }
    Object.entries(message.textSections).forEach(([key, value]) => {
      AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry.encode(
        { key: key as any, value },
        writer.uint32(34).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentAssistantFeedback_SummarizationFeedback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentAssistantFeedback_SummarizationFeedback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.submitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.summaryText = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.textSections[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentAssistantFeedback_SummarizationFeedback {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      submitTime: isSet(object.submitTime) ? fromJsonTimestamp(object.submitTime) : undefined,
      summaryText: isSet(object.summaryText) ? globalThis.String(object.summaryText) : "",
      textSections: isObject(object.textSections)
        ? Object.entries(object.textSections).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AgentAssistantFeedback_SummarizationFeedback): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.submitTime !== undefined) {
      obj.submitTime = message.submitTime.toISOString();
    }
    if (message.summaryText !== "") {
      obj.summaryText = message.summaryText;
    }
    if (message.textSections) {
      const entries = Object.entries(message.textSections);
      if (entries.length > 0) {
        obj.textSections = {};
        entries.forEach(([k, v]) => {
          obj.textSections[k] = v;
        });
      }
    }
    return obj;
  },

  create(
    base?: DeepPartial<AgentAssistantFeedback_SummarizationFeedback>,
  ): AgentAssistantFeedback_SummarizationFeedback {
    return AgentAssistantFeedback_SummarizationFeedback.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AgentAssistantFeedback_SummarizationFeedback>,
  ): AgentAssistantFeedback_SummarizationFeedback {
    const message = createBaseAgentAssistantFeedback_SummarizationFeedback();
    message.startTime = object.startTime ?? undefined;
    message.submitTime = object.submitTime ?? undefined;
    message.summaryText = object.summaryText ?? "";
    message.textSections = Object.entries(object.textSections ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry(): AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry {
  return { key: "", value: "" };
}

export const AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry: MessageFns<
  AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry
> = {
  encode(
    message: AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry>,
  ): AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry {
    return AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry>,
  ): AgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry {
    const message = createBaseAgentAssistantFeedback_SummarizationFeedback_TextSectionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAgentAssistantFeedback_KnowledgeSearchFeedback(): AgentAssistantFeedback_KnowledgeSearchFeedback {
  return { answerCopied: false, clickedUris: [] };
}

export const AgentAssistantFeedback_KnowledgeSearchFeedback: MessageFns<
  AgentAssistantFeedback_KnowledgeSearchFeedback
> = {
  encode(
    message: AgentAssistantFeedback_KnowledgeSearchFeedback,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.answerCopied !== false) {
      writer.uint32(8).bool(message.answerCopied);
    }
    for (const v of message.clickedUris) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentAssistantFeedback_KnowledgeSearchFeedback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentAssistantFeedback_KnowledgeSearchFeedback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.answerCopied = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clickedUris.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentAssistantFeedback_KnowledgeSearchFeedback {
    return {
      answerCopied: isSet(object.answerCopied) ? globalThis.Boolean(object.answerCopied) : false,
      clickedUris: globalThis.Array.isArray(object?.clickedUris)
        ? object.clickedUris.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AgentAssistantFeedback_KnowledgeSearchFeedback): unknown {
    const obj: any = {};
    if (message.answerCopied !== false) {
      obj.answerCopied = message.answerCopied;
    }
    if (message.clickedUris?.length) {
      obj.clickedUris = message.clickedUris;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AgentAssistantFeedback_KnowledgeSearchFeedback>,
  ): AgentAssistantFeedback_KnowledgeSearchFeedback {
    return AgentAssistantFeedback_KnowledgeSearchFeedback.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AgentAssistantFeedback_KnowledgeSearchFeedback>,
  ): AgentAssistantFeedback_KnowledgeSearchFeedback {
    const message = createBaseAgentAssistantFeedback_KnowledgeSearchFeedback();
    message.answerCopied = object.answerCopied ?? false;
    message.clickedUris = object.clickedUris?.map((e) => e) || [];
    return message;
  },
};

function createBaseAgentAssistantFeedback_KnowledgeAssistFeedback(): AgentAssistantFeedback_KnowledgeAssistFeedback {
  return { answerCopied: false, clickedUris: [] };
}

export const AgentAssistantFeedback_KnowledgeAssistFeedback: MessageFns<
  AgentAssistantFeedback_KnowledgeAssistFeedback
> = {
  encode(
    message: AgentAssistantFeedback_KnowledgeAssistFeedback,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.answerCopied !== false) {
      writer.uint32(8).bool(message.answerCopied);
    }
    for (const v of message.clickedUris) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentAssistantFeedback_KnowledgeAssistFeedback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentAssistantFeedback_KnowledgeAssistFeedback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.answerCopied = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clickedUris.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentAssistantFeedback_KnowledgeAssistFeedback {
    return {
      answerCopied: isSet(object.answerCopied) ? globalThis.Boolean(object.answerCopied) : false,
      clickedUris: globalThis.Array.isArray(object?.clickedUris)
        ? object.clickedUris.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AgentAssistantFeedback_KnowledgeAssistFeedback): unknown {
    const obj: any = {};
    if (message.answerCopied !== false) {
      obj.answerCopied = message.answerCopied;
    }
    if (message.clickedUris?.length) {
      obj.clickedUris = message.clickedUris;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AgentAssistantFeedback_KnowledgeAssistFeedback>,
  ): AgentAssistantFeedback_KnowledgeAssistFeedback {
    return AgentAssistantFeedback_KnowledgeAssistFeedback.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AgentAssistantFeedback_KnowledgeAssistFeedback>,
  ): AgentAssistantFeedback_KnowledgeAssistFeedback {
    const message = createBaseAgentAssistantFeedback_KnowledgeAssistFeedback();
    message.answerCopied = object.answerCopied ?? false;
    message.clickedUris = object.clickedUris?.map((e) => e) || [];
    return message;
  },
};

function createBaseAgentAssistantRecord(): AgentAssistantRecord {
  return { articleSuggestionAnswer: undefined, faqAnswer: undefined, dialogflowAssistAnswer: undefined };
}

export const AgentAssistantRecord: MessageFns<AgentAssistantRecord> = {
  encode(message: AgentAssistantRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.articleSuggestionAnswer !== undefined) {
      ArticleAnswer.encode(message.articleSuggestionAnswer, writer.uint32(42).fork()).join();
    }
    if (message.faqAnswer !== undefined) {
      FaqAnswer.encode(message.faqAnswer, writer.uint32(50).fork()).join();
    }
    if (message.dialogflowAssistAnswer !== undefined) {
      DialogflowAssistAnswer.encode(message.dialogflowAssistAnswer, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentAssistantRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentAssistantRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.articleSuggestionAnswer = ArticleAnswer.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.faqAnswer = FaqAnswer.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dialogflowAssistAnswer = DialogflowAssistAnswer.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentAssistantRecord {
    return {
      articleSuggestionAnswer: isSet(object.articleSuggestionAnswer)
        ? ArticleAnswer.fromJSON(object.articleSuggestionAnswer)
        : undefined,
      faqAnswer: isSet(object.faqAnswer) ? FaqAnswer.fromJSON(object.faqAnswer) : undefined,
      dialogflowAssistAnswer: isSet(object.dialogflowAssistAnswer)
        ? DialogflowAssistAnswer.fromJSON(object.dialogflowAssistAnswer)
        : undefined,
    };
  },

  toJSON(message: AgentAssistantRecord): unknown {
    const obj: any = {};
    if (message.articleSuggestionAnswer !== undefined) {
      obj.articleSuggestionAnswer = ArticleAnswer.toJSON(message.articleSuggestionAnswer);
    }
    if (message.faqAnswer !== undefined) {
      obj.faqAnswer = FaqAnswer.toJSON(message.faqAnswer);
    }
    if (message.dialogflowAssistAnswer !== undefined) {
      obj.dialogflowAssistAnswer = DialogflowAssistAnswer.toJSON(message.dialogflowAssistAnswer);
    }
    return obj;
  },

  create(base?: DeepPartial<AgentAssistantRecord>): AgentAssistantRecord {
    return AgentAssistantRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentAssistantRecord>): AgentAssistantRecord {
    const message = createBaseAgentAssistantRecord();
    message.articleSuggestionAnswer =
      (object.articleSuggestionAnswer !== undefined && object.articleSuggestionAnswer !== null)
        ? ArticleAnswer.fromPartial(object.articleSuggestionAnswer)
        : undefined;
    message.faqAnswer = (object.faqAnswer !== undefined && object.faqAnswer !== null)
      ? FaqAnswer.fromPartial(object.faqAnswer)
      : undefined;
    message.dialogflowAssistAnswer =
      (object.dialogflowAssistAnswer !== undefined && object.dialogflowAssistAnswer !== null)
        ? DialogflowAssistAnswer.fromPartial(object.dialogflowAssistAnswer)
        : undefined;
    return message;
  },
};

/**
 * Service for managing
 * [AnswerRecords][google.cloud.dialogflow.v2.AnswerRecord].
 */
export type AnswerRecordsDefinition = typeof AnswerRecordsDefinition;
export const AnswerRecordsDefinition = {
  name: "AnswerRecords",
  fullName: "google.cloud.dialogflow.v2.AnswerRecords",
  methods: {
    /**
     * Returns the list of all answer records in the specified project in reverse
     * chronological order.
     */
    listAnswerRecords: {
      name: "ListAnswerRecords",
      requestType: ListAnswerRecordsRequest,
      requestStream: false,
      responseType: ListAnswerRecordsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              92,
              90,
              51,
              18,
              49,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              110,
              115,
              119,
              101,
              114,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              18,
              37,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              97,
              110,
              115,
              119,
              101,
              114,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the specified answer record. */
    updateAnswerRecord: {
      name: "UpdateAnswerRecord",
      requestType: UpdateAnswerRecordRequest,
      requestStream: false,
      responseType: AnswerRecord,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              25,
              97,
              110,
              115,
              119,
              101,
              114,
              95,
              114,
              101,
              99,
              111,
              114,
              100,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              150,
              1,
              58,
              13,
              97,
              110,
              115,
              119,
              101,
              114,
              95,
              114,
              101,
              99,
              111,
              114,
              100,
              90,
              80,
              58,
              13,
              97,
              110,
              115,
              119,
              101,
              114,
              95,
              114,
              101,
              99,
              111,
              114,
              100,
              50,
              63,
              47,
              118,
              50,
              47,
              123,
              97,
              110,
              115,
              119,
              101,
              114,
              95,
              114,
              101,
              99,
              111,
              114,
              100,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              110,
              115,
              119,
              101,
              114,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              47,
              42,
              125,
              50,
              51,
              47,
              118,
              50,
              47,
              123,
              97,
              110,
              115,
              119,
              101,
              114,
              95,
              114,
              101,
              99,
              111,
              114,
              100,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              97,
              110,
              115,
              119,
              101,
              114,
              82,
              101,
              99,
              111,
              114,
              100,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AnswerRecordsServiceImplementation<CallContextExt = {}> {
  /**
   * Returns the list of all answer records in the specified project in reverse
   * chronological order.
   */
  listAnswerRecords(
    request: ListAnswerRecordsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAnswerRecordsResponse>>;
  /** Updates the specified answer record. */
  updateAnswerRecord(
    request: UpdateAnswerRecordRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AnswerRecord>>;
}

export interface AnswerRecordsClient<CallOptionsExt = {}> {
  /**
   * Returns the list of all answer records in the specified project in reverse
   * chronological order.
   */
  listAnswerRecords(
    request: DeepPartial<ListAnswerRecordsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAnswerRecordsResponse>;
  /** Updates the specified answer record. */
  updateAnswerRecord(
    request: DeepPartial<UpdateAnswerRecordRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AnswerRecord>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
