// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dialogflow/v2/conversation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { ConversationProfile } from "./conversation_profile.js";
import {
  ConversationContext,
  Generator,
  GeneratorSuggestion,
  TriggerEvent,
  triggerEventFromJSON,
  triggerEventToJSON,
} from "./generator.js";
import { AssistQueryParameters, Message } from "./participant.js";
import { TextInput } from "./session.js";

export const protobufPackage = "google.cloud.dialogflow.v2";

/**
 * Represents a conversation.
 * A conversation is an interaction between an agent, including live agents
 * and Dialogflow agents, and a support customer. Conversations can
 * include phone calls and text-based chat sessions.
 */
export interface Conversation {
  /**
   * Output only. Identifier. The unique identifier of this conversation.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>`.
   */
  name: string;
  /** Output only. The current state of the Conversation. */
  lifecycleState: Conversation_LifecycleState;
  /**
   * Required. The Conversation Profile to be used to configure this
   * Conversation. This field cannot be updated.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversationProfiles/<Conversation Profile ID>`.
   */
  conversationProfile: string;
  /**
   * Output only. It will not be empty if the conversation is to be connected
   * over telephony.
   */
  phoneNumber:
    | ConversationPhoneNumber
    | undefined;
  /** Output only. The time the conversation was started. */
  startTime:
    | Date
    | undefined;
  /** Output only. The time the conversation was finished. */
  endTime:
    | Date
    | undefined;
  /**
   * Optional. The stage of a conversation. It indicates whether the virtual
   * agent or a human agent is handling the conversation.
   *
   * If the conversation is created with the conversation profile that has
   * Dialogflow config set, defaults to
   * [ConversationStage.VIRTUAL_AGENT_STAGE][google.cloud.dialogflow.v2.Conversation.ConversationStage.VIRTUAL_AGENT_STAGE];
   * Otherwise, defaults to
   * [ConversationStage.HUMAN_ASSIST_STAGE][google.cloud.dialogflow.v2.Conversation.ConversationStage.HUMAN_ASSIST_STAGE].
   *
   * If the conversation is created with the conversation profile that has
   * Dialogflow config set but explicitly sets conversation_stage to
   * [ConversationStage.HUMAN_ASSIST_STAGE][google.cloud.dialogflow.v2.Conversation.ConversationStage.HUMAN_ASSIST_STAGE],
   * it skips
   * [ConversationStage.VIRTUAL_AGENT_STAGE][google.cloud.dialogflow.v2.Conversation.ConversationStage.VIRTUAL_AGENT_STAGE]
   * stage and directly goes to
   * [ConversationStage.HUMAN_ASSIST_STAGE][google.cloud.dialogflow.v2.Conversation.ConversationStage.HUMAN_ASSIST_STAGE].
   */
  conversationStage: Conversation_ConversationStage;
}

/** Enumeration of the completion status of the conversation. */
export enum Conversation_LifecycleState {
  /** LIFECYCLE_STATE_UNSPECIFIED - Unknown. */
  LIFECYCLE_STATE_UNSPECIFIED = 0,
  /** IN_PROGRESS - Conversation is currently open for media analysis. */
  IN_PROGRESS = 1,
  /** COMPLETED - Conversation has been completed. */
  COMPLETED = 2,
  UNRECOGNIZED = -1,
}

export function conversation_LifecycleStateFromJSON(object: any): Conversation_LifecycleState {
  switch (object) {
    case 0:
    case "LIFECYCLE_STATE_UNSPECIFIED":
      return Conversation_LifecycleState.LIFECYCLE_STATE_UNSPECIFIED;
    case 1:
    case "IN_PROGRESS":
      return Conversation_LifecycleState.IN_PROGRESS;
    case 2:
    case "COMPLETED":
      return Conversation_LifecycleState.COMPLETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Conversation_LifecycleState.UNRECOGNIZED;
  }
}

export function conversation_LifecycleStateToJSON(object: Conversation_LifecycleState): string {
  switch (object) {
    case Conversation_LifecycleState.LIFECYCLE_STATE_UNSPECIFIED:
      return "LIFECYCLE_STATE_UNSPECIFIED";
    case Conversation_LifecycleState.IN_PROGRESS:
      return "IN_PROGRESS";
    case Conversation_LifecycleState.COMPLETED:
      return "COMPLETED";
    case Conversation_LifecycleState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Enumeration of the different conversation stages a conversation can be in.
 * Reference:
 * https://cloud.google.com/dialogflow/priv/docs/contact-center/basics#stages
 */
export enum Conversation_ConversationStage {
  /**
   * CONVERSATION_STAGE_UNSPECIFIED - Unknown. Should never be used after a conversation is successfully
   * created.
   */
  CONVERSATION_STAGE_UNSPECIFIED = 0,
  /**
   * VIRTUAL_AGENT_STAGE - The conversation should return virtual agent responses into the
   * conversation.
   */
  VIRTUAL_AGENT_STAGE = 1,
  /**
   * HUMAN_ASSIST_STAGE - The conversation should not provide responses, just listen and provide
   * suggestions.
   */
  HUMAN_ASSIST_STAGE = 2,
  UNRECOGNIZED = -1,
}

export function conversation_ConversationStageFromJSON(object: any): Conversation_ConversationStage {
  switch (object) {
    case 0:
    case "CONVERSATION_STAGE_UNSPECIFIED":
      return Conversation_ConversationStage.CONVERSATION_STAGE_UNSPECIFIED;
    case 1:
    case "VIRTUAL_AGENT_STAGE":
      return Conversation_ConversationStage.VIRTUAL_AGENT_STAGE;
    case 2:
    case "HUMAN_ASSIST_STAGE":
      return Conversation_ConversationStage.HUMAN_ASSIST_STAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Conversation_ConversationStage.UNRECOGNIZED;
  }
}

export function conversation_ConversationStageToJSON(object: Conversation_ConversationStage): string {
  switch (object) {
    case Conversation_ConversationStage.CONVERSATION_STAGE_UNSPECIFIED:
      return "CONVERSATION_STAGE_UNSPECIFIED";
    case Conversation_ConversationStage.VIRTUAL_AGENT_STAGE:
      return "VIRTUAL_AGENT_STAGE";
    case Conversation_ConversationStage.HUMAN_ASSIST_STAGE:
      return "HUMAN_ASSIST_STAGE";
    case Conversation_ConversationStage.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The request message for
 * [Conversations.CreateConversation][google.cloud.dialogflow.v2.Conversations.CreateConversation].
 */
export interface CreateConversationRequest {
  /**
   * Required. Resource identifier of the project creating the conversation.
   * Format: `projects/<Project ID>/locations/<Location ID>`.
   */
  parent: string;
  /** Required. The conversation to create. */
  conversation:
    | Conversation
    | undefined;
  /**
   * Optional. Identifier of the conversation. Generally it's auto generated by
   * Google. Only set it if you cannot wait for the response to return a
   * auto-generated one to you.
   *
   * The conversation ID must be compliant with the regression fomula
   * `[a-zA-Z][a-zA-Z0-9_-]*` with the characters length in range of [3,64].
   * If the field is provided, the caller is resposible for
   * 1. the uniqueness of the ID, otherwise the request will be rejected.
   * 2. the consistency for whether to use custom ID or not under a project to
   * better ensure uniqueness.
   */
  conversationId: string;
}

/**
 * The request message for
 * [Conversations.ListConversations][google.cloud.dialogflow.v2.Conversations.ListConversations].
 */
export interface ListConversationsRequest {
  /**
   * Required. The project from which to list all conversation.
   * Format: `projects/<Project ID>/locations/<Location ID>`.
   */
  parent: string;
  /**
   * Optional. The maximum number of items to return in a single page. By
   * default 100 and at most 1000.
   */
  pageSize: number;
  /** Optional. The next_page_token value returned from a previous list request. */
  pageToken: string;
  /**
   * Optional. A filter expression that filters conversations listed in the
   * response. Only `lifecycle_state` can be filtered on in this way. For
   * example, the following expression only returns `COMPLETED` conversations:
   *
   * `lifecycle_state = "COMPLETED"`
   *
   * For more information about filtering, see
   * [API Filtering](https://aip.dev/160).
   */
  filter: string;
}

/**
 * The response message for
 * [Conversations.ListConversations][google.cloud.dialogflow.v2.Conversations.ListConversations].
 */
export interface ListConversationsResponse {
  /**
   * The list of conversations. There will be a maximum number of items
   * returned based on the page_size field in the request.
   */
  conversations: Conversation[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/**
 * The request message for
 * [Conversations.GetConversation][google.cloud.dialogflow.v2.Conversations.GetConversation].
 */
export interface GetConversationRequest {
  /**
   * Required. The name of the conversation. Format:
   * `projects/<Project ID>/locations/<Location ID>/conversations/<Conversation
   * ID>`.
   */
  name: string;
}

/**
 * The request message for
 * [Conversations.CompleteConversation][google.cloud.dialogflow.v2.Conversations.CompleteConversation].
 */
export interface CompleteConversationRequest {
  /**
   * Required. Resource identifier of the conversation to close.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>`.
   */
  name: string;
}

/**
 * The request message for
 * [Conversations.ListMessages][google.cloud.dialogflow.v2.Conversations.ListMessages].
 */
export interface ListMessagesRequest {
  /**
   * Required. The name of the conversation to list messages for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>`
   */
  parent: string;
  /**
   * Optional. Filter on message fields. Currently predicates on `create_time`
   * and `create_time_epoch_microseconds` are supported. `create_time` only
   * support milliseconds accuracy. E.g.,
   * `create_time_epoch_microseconds > 1551790877964485` or
   * `create_time > 2017-01-15T01:30:15.01Z`.
   *
   * For more information about filtering, see
   * [API Filtering](https://aip.dev/160).
   */
  filter: string;
  /**
   * Optional. The maximum number of items to return in a single page. By
   * default 100 and at most 1000.
   */
  pageSize: number;
  /** Optional. The next_page_token value returned from a previous list request. */
  pageToken: string;
}

/**
 * The response message for
 * [Conversations.ListMessages][google.cloud.dialogflow.v2.Conversations.ListMessages].
 */
export interface ListMessagesResponse {
  /**
   * The list of messages. There will be a maximum number of items
   * returned based on the page_size field in the request.
   * `messages` is sorted by `create_time` in descending order.
   */
  messages: Message[];
  /**
   * Token to retrieve the next page of results, or empty if there are
   * no more results in the list.
   */
  nextPageToken: string;
}

/**
 * Represents a phone number for telephony integration. It allows for connecting
 * a particular conversation over telephony.
 */
export interface ConversationPhoneNumber {
  /** Output only. The phone number to connect to this conversation. */
  phoneNumber: string;
}

/**
 * The request message for
 * [Conversations.SuggestConversationSummary][google.cloud.dialogflow.v2.Conversations.SuggestConversationSummary].
 */
export interface SuggestConversationSummaryRequest {
  /**
   * Required. The conversation to fetch suggestion for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>`.
   */
  conversation: string;
  /**
   * Optional. The name of the latest conversation message used as context for
   * compiling suggestion. If empty, the latest message of the conversation will
   * be used.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Optional. Max number of messages prior to and including
   * [latest_message] to use as context when compiling the
   * suggestion. By default 500 and at most 1000.
   */
  contextSize: number;
  /**
   * Optional. Parameters for a human assist query. Only used for POC/demo
   * purpose.
   */
  assistQueryParams: AssistQueryParameters | undefined;
}

/**
 * The response message for
 * [Conversations.SuggestConversationSummary][google.cloud.dialogflow.v2.Conversations.SuggestConversationSummary].
 */
export interface SuggestConversationSummaryResponse {
  /** Generated summary. */
  summary:
    | SuggestConversationSummaryResponse_Summary
    | undefined;
  /**
   * The name of the latest conversation message used as context for
   * compiling suggestion.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Number of messages prior to and including
   * [last_conversation_message][] used to compile the suggestion. It may be
   * smaller than the [SuggestSummaryRequest.context_size][] field in the
   * request if there weren't that many messages in the conversation.
   */
  contextSize: number;
}

/** Generated summary for a conversation. */
export interface SuggestConversationSummaryResponse_Summary {
  /** The summary content that is concatenated into one string. */
  text: string;
  /**
   * The summary content that is divided into sections. The key is the
   * section's name and the value is the section's content. There is no
   * specific format for the key or value.
   */
  textSections: { [key: string]: string };
  /**
   * The name of the answer record. Format:
   * "projects/<Project ID>/answerRecords/<Answer Record ID>"
   */
  answerRecord: string;
  /**
   * The baseline model version used to generate this summary. It is empty if
   * a baseline model was not used to generate this summary.
   */
  baselineModelVersion: string;
}

export interface SuggestConversationSummaryResponse_Summary_TextSectionsEntry {
  key: string;
  value: string;
}

/**
 * The request message for
 * [Conversations.GenerateStatelessSummary][google.cloud.dialogflow.v2.Conversations.GenerateStatelessSummary].
 */
export interface GenerateStatelessSummaryRequest {
  /** Required. The conversation to suggest a summary for. */
  statelessConversation:
    | GenerateStatelessSummaryRequest_MinimalConversation
    | undefined;
  /**
   * Required. A ConversationProfile containing information required for Summary
   * generation.
   * Required fields: {language_code, security_settings}
   * Optional fields: {agent_assistant_config}
   */
  conversationProfile:
    | ConversationProfile
    | undefined;
  /**
   * Optional. The name of the latest conversation message used as context for
   * generating a Summary. If empty, the latest message of the conversation will
   * be used. The format is specific to the user and the names of the messages
   * provided.
   */
  latestMessage: string;
  /**
   * Optional. Max number of messages prior to and including
   * [latest_message] to use as context when compiling the
   * suggestion. By default 500 and at most 1000.
   */
  maxContextSize: number;
}

/**
 * The minimum amount of information required to generate a Summary without
 * having a Conversation resource created.
 */
export interface GenerateStatelessSummaryRequest_MinimalConversation {
  /**
   * Required. The messages that the Summary will be generated from. It is
   * expected that this message content is already redacted and does not
   * contain any PII. Required fields: {content, language_code, participant,
   * participant_role} Optional fields: {send_time} If send_time is not
   * provided, then the messages must be provided in chronological order.
   */
  messages: Message[];
  /**
   * Required. The parent resource to charge for the Summary's generation.
   * Format: `projects/<Project ID>/locations/<Location ID>`.
   */
  parent: string;
}

/**
 * The response message for
 * [Conversations.GenerateStatelessSummary][google.cloud.dialogflow.v2.Conversations.GenerateStatelessSummary].
 */
export interface GenerateStatelessSummaryResponse {
  /** Generated summary. */
  summary:
    | GenerateStatelessSummaryResponse_Summary
    | undefined;
  /**
   * The name of the latest conversation message used as context for
   * compiling suggestion. The format is specific to the user and the names of
   * the messages provided.
   */
  latestMessage: string;
  /**
   * Number of messages prior to and including
   * [last_conversation_message][] used to compile the suggestion. It may be
   * smaller than the [GenerateStatelessSummaryRequest.context_size][] field in
   * the request if there weren't that many messages in the conversation.
   */
  contextSize: number;
}

/** Generated summary for a conversation. */
export interface GenerateStatelessSummaryResponse_Summary {
  /** The summary content that is concatenated into one string. */
  text: string;
  /**
   * The summary content that is divided into sections. The key is the
   * section's name and the value is the section's content. There is no
   * specific format for the key or value.
   */
  textSections: { [key: string]: string };
  /**
   * The baseline model version used to generate this summary. It is empty if
   * a baseline model was not used to generate this summary.
   */
  baselineModelVersion: string;
}

export interface GenerateStatelessSummaryResponse_Summary_TextSectionsEntry {
  key: string;
  value: string;
}

/**
 * The request message for
 * [Conversations.GenerateStatelessSuggestion][google.cloud.dialogflow.v2.Conversations.GenerateStatelessSuggestion].
 */
export interface GenerateStatelessSuggestionRequest {
  /**
   * Required. The parent resource to charge for the Suggestion's generation.
   * Format: `projects/<Project ID>/locations/<Location ID>`.
   */
  parent: string;
  /**
   * Uncreated generator. It should be a complete generator that includes all
   * information about the generator.
   */
  generator?:
    | Generator
    | undefined;
  /**
   * The resource name of the existing created generator. Format:
   * `projects/<Project ID>/locations/<Location ID>/generators/<Generator ID>`
   */
  generatorName?:
    | string
    | undefined;
  /** Optional. Context of the conversation, including transcripts. */
  conversationContext:
    | ConversationContext
    | undefined;
  /**
   * Optional. A list of trigger events. Generator will be triggered only if
   * it's trigger event is included here.
   */
  triggerEvents: TriggerEvent[];
}

/**
 * The response message for
 * [Conversations.GenerateStatelessSuggestion][google.cloud.dialogflow.v2.Conversations.GenerateStatelessSuggestion].
 */
export interface GenerateStatelessSuggestionResponse {
  /** Required. Generated suggestion for a conversation. */
  generatorSuggestion: GeneratorSuggestion | undefined;
}

/**
 * The request message for
 * [Conversations.SearchKnowledge][google.cloud.dialogflow.v2.Conversations.SearchKnowledge].
 */
export interface SearchKnowledgeRequest {
  /**
   * Required. The parent resource contains the conversation profile
   * Format: 'projects/<Project ID>' or `projects/<Project
   * ID>/locations/<Location ID>`.
   */
  parent: string;
  /** Required. The natural language text query for knowledge search. */
  query:
    | TextInput
    | undefined;
  /**
   * Required. The conversation profile used to configure the search.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversationProfiles/<Conversation Profile ID>`.
   */
  conversationProfile: string;
  /**
   * Required. The ID of the search session.
   * The session_id can be combined with Dialogflow V3 Agent ID retrieved from
   * conversation profile or on its own to identify a search session. The search
   * history of the same session will impact the search result. It's up to the
   * API caller to choose an appropriate `Session ID`. It can be a random number
   * or some type of session identifiers (preferably hashed). The length must
   * not exceed 36 characters.
   */
  sessionId: string;
  /**
   * Optional. The conversation (between human agent and end user) where the
   * search request is triggered. Format: `projects/<Project
   * ID>/locations/<Location ID>/conversations/<Conversation ID>`.
   */
  conversation: string;
  /**
   * Optional. The name of the latest conversation message when the request is
   * triggered.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
}

/**
 * The response message for
 * [Conversations.SearchKnowledge][google.cloud.dialogflow.v2.Conversations.SearchKnowledge].
 */
export interface SearchKnowledgeResponse {
  /**
   * Most relevant snippets extracted from articles in the given knowledge base,
   * ordered by confidence.
   */
  answers: SearchKnowledgeAnswer[];
  /** The rewritten query used to search knowledge. */
  rewrittenQuery: string;
}

/** Represents a SearchKnowledge answer. */
export interface SearchKnowledgeAnswer {
  /**
   * The piece of text from the knowledge base documents that answers
   * the search query
   */
  answer: string;
  /** The type of the answer. */
  answerType: SearchKnowledgeAnswer_AnswerType;
  /** All sources used to generate the answer. */
  answerSources: SearchKnowledgeAnswer_AnswerSource[];
  /**
   * The name of the answer record.
   * Format: `projects/<Project ID>/locations/<location ID>/answer
   * Records/<Answer Record ID>`
   */
  answerRecord: string;
}

/** The type of the answer. */
export enum SearchKnowledgeAnswer_AnswerType {
  /** ANSWER_TYPE_UNSPECIFIED - The answer has a unspecified type. */
  ANSWER_TYPE_UNSPECIFIED = 0,
  /** FAQ - The answer is from FAQ documents. */
  FAQ = 1,
  /** GENERATIVE - The answer is from generative model. */
  GENERATIVE = 2,
  /** INTENT - The answer is from intent matching. */
  INTENT = 3,
  UNRECOGNIZED = -1,
}

export function searchKnowledgeAnswer_AnswerTypeFromJSON(object: any): SearchKnowledgeAnswer_AnswerType {
  switch (object) {
    case 0:
    case "ANSWER_TYPE_UNSPECIFIED":
      return SearchKnowledgeAnswer_AnswerType.ANSWER_TYPE_UNSPECIFIED;
    case 1:
    case "FAQ":
      return SearchKnowledgeAnswer_AnswerType.FAQ;
    case 2:
    case "GENERATIVE":
      return SearchKnowledgeAnswer_AnswerType.GENERATIVE;
    case 3:
    case "INTENT":
      return SearchKnowledgeAnswer_AnswerType.INTENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchKnowledgeAnswer_AnswerType.UNRECOGNIZED;
  }
}

export function searchKnowledgeAnswer_AnswerTypeToJSON(object: SearchKnowledgeAnswer_AnswerType): string {
  switch (object) {
    case SearchKnowledgeAnswer_AnswerType.ANSWER_TYPE_UNSPECIFIED:
      return "ANSWER_TYPE_UNSPECIFIED";
    case SearchKnowledgeAnswer_AnswerType.FAQ:
      return "FAQ";
    case SearchKnowledgeAnswer_AnswerType.GENERATIVE:
      return "GENERATIVE";
    case SearchKnowledgeAnswer_AnswerType.INTENT:
      return "INTENT";
    case SearchKnowledgeAnswer_AnswerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The sources of the answers. */
export interface SearchKnowledgeAnswer_AnswerSource {
  /** The title of the article. */
  title: string;
  /** The URI of the article. */
  uri: string;
  /** The relevant snippet of the article. */
  snippet: string;
}

function createBaseConversation(): Conversation {
  return {
    name: "",
    lifecycleState: 0,
    conversationProfile: "",
    phoneNumber: undefined,
    startTime: undefined,
    endTime: undefined,
    conversationStage: 0,
  };
}

export const Conversation: MessageFns<Conversation> = {
  encode(message: Conversation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.lifecycleState !== 0) {
      writer.uint32(16).int32(message.lifecycleState);
    }
    if (message.conversationProfile !== "") {
      writer.uint32(26).string(message.conversationProfile);
    }
    if (message.phoneNumber !== undefined) {
      ConversationPhoneNumber.encode(message.phoneNumber, writer.uint32(34).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(42).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(50).fork()).join();
    }
    if (message.conversationStage !== 0) {
      writer.uint32(56).int32(message.conversationStage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lifecycleState = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.conversationProfile = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.phoneNumber = ConversationPhoneNumber.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.conversationStage = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      lifecycleState: isSet(object.lifecycleState) ? conversation_LifecycleStateFromJSON(object.lifecycleState) : 0,
      conversationProfile: isSet(object.conversationProfile) ? globalThis.String(object.conversationProfile) : "",
      phoneNumber: isSet(object.phoneNumber) ? ConversationPhoneNumber.fromJSON(object.phoneNumber) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      conversationStage: isSet(object.conversationStage)
        ? conversation_ConversationStageFromJSON(object.conversationStage)
        : 0,
    };
  },

  toJSON(message: Conversation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.lifecycleState !== 0) {
      obj.lifecycleState = conversation_LifecycleStateToJSON(message.lifecycleState);
    }
    if (message.conversationProfile !== "") {
      obj.conversationProfile = message.conversationProfile;
    }
    if (message.phoneNumber !== undefined) {
      obj.phoneNumber = ConversationPhoneNumber.toJSON(message.phoneNumber);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.conversationStage !== 0) {
      obj.conversationStage = conversation_ConversationStageToJSON(message.conversationStage);
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation>): Conversation {
    return Conversation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation>): Conversation {
    const message = createBaseConversation();
    message.name = object.name ?? "";
    message.lifecycleState = object.lifecycleState ?? 0;
    message.conversationProfile = object.conversationProfile ?? "";
    message.phoneNumber = (object.phoneNumber !== undefined && object.phoneNumber !== null)
      ? ConversationPhoneNumber.fromPartial(object.phoneNumber)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.conversationStage = object.conversationStage ?? 0;
    return message;
  },
};

function createBaseCreateConversationRequest(): CreateConversationRequest {
  return { parent: "", conversation: undefined, conversationId: "" };
}

export const CreateConversationRequest: MessageFns<CreateConversationRequest> = {
  encode(message: CreateConversationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.conversation !== undefined) {
      Conversation.encode(message.conversation, writer.uint32(18).fork()).join();
    }
    if (message.conversationId !== "") {
      writer.uint32(26).string(message.conversationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConversationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversation = Conversation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.conversationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConversationRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      conversation: isSet(object.conversation) ? Conversation.fromJSON(object.conversation) : undefined,
      conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
    };
  },

  toJSON(message: CreateConversationRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.conversation !== undefined) {
      obj.conversation = Conversation.toJSON(message.conversation);
    }
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateConversationRequest>): CreateConversationRequest {
    return CreateConversationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateConversationRequest>): CreateConversationRequest {
    const message = createBaseCreateConversationRequest();
    message.parent = object.parent ?? "";
    message.conversation = (object.conversation !== undefined && object.conversation !== null)
      ? Conversation.fromPartial(object.conversation)
      : undefined;
    message.conversationId = object.conversationId ?? "";
    return message;
  },
};

function createBaseListConversationsRequest(): ListConversationsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListConversationsRequest: MessageFns<ListConversationsRequest> = {
  encode(message: ListConversationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConversationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConversationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConversationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListConversationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConversationsRequest>): ListConversationsRequest {
    return ListConversationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConversationsRequest>): ListConversationsRequest {
    const message = createBaseListConversationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListConversationsResponse(): ListConversationsResponse {
  return { conversations: [], nextPageToken: "" };
}

export const ListConversationsResponse: MessageFns<ListConversationsResponse> = {
  encode(message: ListConversationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conversations) {
      Conversation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConversationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConversationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversations.push(Conversation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConversationsResponse {
    return {
      conversations: globalThis.Array.isArray(object?.conversations)
        ? object.conversations.map((e: any) => Conversation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListConversationsResponse): unknown {
    const obj: any = {};
    if (message.conversations?.length) {
      obj.conversations = message.conversations.map((e) => Conversation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConversationsResponse>): ListConversationsResponse {
    return ListConversationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConversationsResponse>): ListConversationsResponse {
    const message = createBaseListConversationsResponse();
    message.conversations = object.conversations?.map((e) => Conversation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetConversationRequest(): GetConversationRequest {
  return { name: "" };
}

export const GetConversationRequest: MessageFns<GetConversationRequest> = {
  encode(message: GetConversationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConversationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConversationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetConversationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetConversationRequest>): GetConversationRequest {
    return GetConversationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConversationRequest>): GetConversationRequest {
    const message = createBaseGetConversationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCompleteConversationRequest(): CompleteConversationRequest {
  return { name: "" };
}

export const CompleteConversationRequest: MessageFns<CompleteConversationRequest> = {
  encode(message: CompleteConversationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteConversationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteConversationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CompleteConversationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CompleteConversationRequest>): CompleteConversationRequest {
    return CompleteConversationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteConversationRequest>): CompleteConversationRequest {
    const message = createBaseCompleteConversationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListMessagesRequest(): ListMessagesRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListMessagesRequest: MessageFns<ListMessagesRequest> = {
  encode(message: ListMessagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMessagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMessagesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListMessagesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMessagesRequest>): ListMessagesRequest {
    return ListMessagesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMessagesRequest>): ListMessagesRequest {
    const message = createBaseListMessagesRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListMessagesResponse(): ListMessagesResponse {
  return { messages: [], nextPageToken: "" };
}

export const ListMessagesResponse: MessageFns<ListMessagesResponse> = {
  encode(message: ListMessagesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMessagesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMessagesResponse {
    return {
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => Message.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListMessagesResponse): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => Message.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMessagesResponse>): ListMessagesResponse {
    return ListMessagesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMessagesResponse>): ListMessagesResponse {
    const message = createBaseListMessagesResponse();
    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseConversationPhoneNumber(): ConversationPhoneNumber {
  return { phoneNumber: "" };
}

export const ConversationPhoneNumber: MessageFns<ConversationPhoneNumber> = {
  encode(message: ConversationPhoneNumber, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.phoneNumber !== "") {
      writer.uint32(26).string(message.phoneNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationPhoneNumber {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationPhoneNumber();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationPhoneNumber {
    return { phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : "" };
  },

  toJSON(message: ConversationPhoneNumber): unknown {
    const obj: any = {};
    if (message.phoneNumber !== "") {
      obj.phoneNumber = message.phoneNumber;
    }
    return obj;
  },

  create(base?: DeepPartial<ConversationPhoneNumber>): ConversationPhoneNumber {
    return ConversationPhoneNumber.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversationPhoneNumber>): ConversationPhoneNumber {
    const message = createBaseConversationPhoneNumber();
    message.phoneNumber = object.phoneNumber ?? "";
    return message;
  },
};

function createBaseSuggestConversationSummaryRequest(): SuggestConversationSummaryRequest {
  return { conversation: "", latestMessage: "", contextSize: 0, assistQueryParams: undefined };
}

export const SuggestConversationSummaryRequest: MessageFns<SuggestConversationSummaryRequest> = {
  encode(message: SuggestConversationSummaryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversation !== "") {
      writer.uint32(10).string(message.conversation);
    }
    if (message.latestMessage !== "") {
      writer.uint32(26).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(32).int32(message.contextSize);
    }
    if (message.assistQueryParams !== undefined) {
      AssistQueryParameters.encode(message.assistQueryParams, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestConversationSummaryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestConversationSummaryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversation = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.assistQueryParams = AssistQueryParameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestConversationSummaryRequest {
    return {
      conversation: isSet(object.conversation) ? globalThis.String(object.conversation) : "",
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
      assistQueryParams: isSet(object.assistQueryParams)
        ? AssistQueryParameters.fromJSON(object.assistQueryParams)
        : undefined,
    };
  },

  toJSON(message: SuggestConversationSummaryRequest): unknown {
    const obj: any = {};
    if (message.conversation !== "") {
      obj.conversation = message.conversation;
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    if (message.assistQueryParams !== undefined) {
      obj.assistQueryParams = AssistQueryParameters.toJSON(message.assistQueryParams);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestConversationSummaryRequest>): SuggestConversationSummaryRequest {
    return SuggestConversationSummaryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestConversationSummaryRequest>): SuggestConversationSummaryRequest {
    const message = createBaseSuggestConversationSummaryRequest();
    message.conversation = object.conversation ?? "";
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    message.assistQueryParams = (object.assistQueryParams !== undefined && object.assistQueryParams !== null)
      ? AssistQueryParameters.fromPartial(object.assistQueryParams)
      : undefined;
    return message;
  },
};

function createBaseSuggestConversationSummaryResponse(): SuggestConversationSummaryResponse {
  return { summary: undefined, latestMessage: "", contextSize: 0 };
}

export const SuggestConversationSummaryResponse: MessageFns<SuggestConversationSummaryResponse> = {
  encode(message: SuggestConversationSummaryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.summary !== undefined) {
      SuggestConversationSummaryResponse_Summary.encode(message.summary, writer.uint32(10).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestConversationSummaryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestConversationSummaryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.summary = SuggestConversationSummaryResponse_Summary.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestConversationSummaryResponse {
    return {
      summary: isSet(object.summary) ? SuggestConversationSummaryResponse_Summary.fromJSON(object.summary) : undefined,
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: SuggestConversationSummaryResponse): unknown {
    const obj: any = {};
    if (message.summary !== undefined) {
      obj.summary = SuggestConversationSummaryResponse_Summary.toJSON(message.summary);
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestConversationSummaryResponse>): SuggestConversationSummaryResponse {
    return SuggestConversationSummaryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestConversationSummaryResponse>): SuggestConversationSummaryResponse {
    const message = createBaseSuggestConversationSummaryResponse();
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? SuggestConversationSummaryResponse_Summary.fromPartial(object.summary)
      : undefined;
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseSuggestConversationSummaryResponse_Summary(): SuggestConversationSummaryResponse_Summary {
  return { text: "", textSections: {}, answerRecord: "", baselineModelVersion: "" };
}

export const SuggestConversationSummaryResponse_Summary: MessageFns<SuggestConversationSummaryResponse_Summary> = {
  encode(message: SuggestConversationSummaryResponse_Summary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    Object.entries(message.textSections).forEach(([key, value]) => {
      SuggestConversationSummaryResponse_Summary_TextSectionsEntry.encode(
        { key: key as any, value },
        writer.uint32(34).fork(),
      ).join();
    });
    if (message.answerRecord !== "") {
      writer.uint32(26).string(message.answerRecord);
    }
    if (message.baselineModelVersion !== "") {
      writer.uint32(42).string(message.baselineModelVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestConversationSummaryResponse_Summary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestConversationSummaryResponse_Summary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = SuggestConversationSummaryResponse_Summary_TextSectionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.textSections[entry4.key] = entry4.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.baselineModelVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestConversationSummaryResponse_Summary {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      textSections: isObject(object.textSections)
        ? Object.entries(object.textSections).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
      baselineModelVersion: isSet(object.baselineModelVersion) ? globalThis.String(object.baselineModelVersion) : "",
    };
  },

  toJSON(message: SuggestConversationSummaryResponse_Summary): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.textSections) {
      const entries = Object.entries(message.textSections);
      if (entries.length > 0) {
        obj.textSections = {};
        entries.forEach(([k, v]) => {
          obj.textSections[k] = v;
        });
      }
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    if (message.baselineModelVersion !== "") {
      obj.baselineModelVersion = message.baselineModelVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestConversationSummaryResponse_Summary>): SuggestConversationSummaryResponse_Summary {
    return SuggestConversationSummaryResponse_Summary.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SuggestConversationSummaryResponse_Summary>,
  ): SuggestConversationSummaryResponse_Summary {
    const message = createBaseSuggestConversationSummaryResponse_Summary();
    message.text = object.text ?? "";
    message.textSections = Object.entries(object.textSections ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.answerRecord = object.answerRecord ?? "";
    message.baselineModelVersion = object.baselineModelVersion ?? "";
    return message;
  },
};

function createBaseSuggestConversationSummaryResponse_Summary_TextSectionsEntry(): SuggestConversationSummaryResponse_Summary_TextSectionsEntry {
  return { key: "", value: "" };
}

export const SuggestConversationSummaryResponse_Summary_TextSectionsEntry: MessageFns<
  SuggestConversationSummaryResponse_Summary_TextSectionsEntry
> = {
  encode(
    message: SuggestConversationSummaryResponse_Summary_TextSectionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SuggestConversationSummaryResponse_Summary_TextSectionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestConversationSummaryResponse_Summary_TextSectionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestConversationSummaryResponse_Summary_TextSectionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SuggestConversationSummaryResponse_Summary_TextSectionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SuggestConversationSummaryResponse_Summary_TextSectionsEntry>,
  ): SuggestConversationSummaryResponse_Summary_TextSectionsEntry {
    return SuggestConversationSummaryResponse_Summary_TextSectionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SuggestConversationSummaryResponse_Summary_TextSectionsEntry>,
  ): SuggestConversationSummaryResponse_Summary_TextSectionsEntry {
    const message = createBaseSuggestConversationSummaryResponse_Summary_TextSectionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGenerateStatelessSummaryRequest(): GenerateStatelessSummaryRequest {
  return { statelessConversation: undefined, conversationProfile: undefined, latestMessage: "", maxContextSize: 0 };
}

export const GenerateStatelessSummaryRequest: MessageFns<GenerateStatelessSummaryRequest> = {
  encode(message: GenerateStatelessSummaryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statelessConversation !== undefined) {
      GenerateStatelessSummaryRequest_MinimalConversation.encode(
        message.statelessConversation,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.conversationProfile !== undefined) {
      ConversationProfile.encode(message.conversationProfile, writer.uint32(18).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(26).string(message.latestMessage);
    }
    if (message.maxContextSize !== 0) {
      writer.uint32(32).int32(message.maxContextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateStatelessSummaryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateStatelessSummaryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.statelessConversation = GenerateStatelessSummaryRequest_MinimalConversation.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversationProfile = ConversationProfile.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxContextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateStatelessSummaryRequest {
    return {
      statelessConversation: isSet(object.statelessConversation)
        ? GenerateStatelessSummaryRequest_MinimalConversation.fromJSON(object.statelessConversation)
        : undefined,
      conversationProfile: isSet(object.conversationProfile)
        ? ConversationProfile.fromJSON(object.conversationProfile)
        : undefined,
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      maxContextSize: isSet(object.maxContextSize) ? globalThis.Number(object.maxContextSize) : 0,
    };
  },

  toJSON(message: GenerateStatelessSummaryRequest): unknown {
    const obj: any = {};
    if (message.statelessConversation !== undefined) {
      obj.statelessConversation = GenerateStatelessSummaryRequest_MinimalConversation.toJSON(
        message.statelessConversation,
      );
    }
    if (message.conversationProfile !== undefined) {
      obj.conversationProfile = ConversationProfile.toJSON(message.conversationProfile);
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.maxContextSize !== 0) {
      obj.maxContextSize = Math.round(message.maxContextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateStatelessSummaryRequest>): GenerateStatelessSummaryRequest {
    return GenerateStatelessSummaryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateStatelessSummaryRequest>): GenerateStatelessSummaryRequest {
    const message = createBaseGenerateStatelessSummaryRequest();
    message.statelessConversation =
      (object.statelessConversation !== undefined && object.statelessConversation !== null)
        ? GenerateStatelessSummaryRequest_MinimalConversation.fromPartial(object.statelessConversation)
        : undefined;
    message.conversationProfile = (object.conversationProfile !== undefined && object.conversationProfile !== null)
      ? ConversationProfile.fromPartial(object.conversationProfile)
      : undefined;
    message.latestMessage = object.latestMessage ?? "";
    message.maxContextSize = object.maxContextSize ?? 0;
    return message;
  },
};

function createBaseGenerateStatelessSummaryRequest_MinimalConversation(): GenerateStatelessSummaryRequest_MinimalConversation {
  return { messages: [], parent: "" };
}

export const GenerateStatelessSummaryRequest_MinimalConversation: MessageFns<
  GenerateStatelessSummaryRequest_MinimalConversation
> = {
  encode(
    message: GenerateStatelessSummaryRequest_MinimalConversation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateStatelessSummaryRequest_MinimalConversation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateStatelessSummaryRequest_MinimalConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateStatelessSummaryRequest_MinimalConversation {
    return {
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => Message.fromJSON(e)) : [],
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: GenerateStatelessSummaryRequest_MinimalConversation): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => Message.toJSON(e));
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GenerateStatelessSummaryRequest_MinimalConversation>,
  ): GenerateStatelessSummaryRequest_MinimalConversation {
    return GenerateStatelessSummaryRequest_MinimalConversation.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenerateStatelessSummaryRequest_MinimalConversation>,
  ): GenerateStatelessSummaryRequest_MinimalConversation {
    const message = createBaseGenerateStatelessSummaryRequest_MinimalConversation();
    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseGenerateStatelessSummaryResponse(): GenerateStatelessSummaryResponse {
  return { summary: undefined, latestMessage: "", contextSize: 0 };
}

export const GenerateStatelessSummaryResponse: MessageFns<GenerateStatelessSummaryResponse> = {
  encode(message: GenerateStatelessSummaryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.summary !== undefined) {
      GenerateStatelessSummaryResponse_Summary.encode(message.summary, writer.uint32(10).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateStatelessSummaryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateStatelessSummaryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.summary = GenerateStatelessSummaryResponse_Summary.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateStatelessSummaryResponse {
    return {
      summary: isSet(object.summary) ? GenerateStatelessSummaryResponse_Summary.fromJSON(object.summary) : undefined,
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: GenerateStatelessSummaryResponse): unknown {
    const obj: any = {};
    if (message.summary !== undefined) {
      obj.summary = GenerateStatelessSummaryResponse_Summary.toJSON(message.summary);
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateStatelessSummaryResponse>): GenerateStatelessSummaryResponse {
    return GenerateStatelessSummaryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateStatelessSummaryResponse>): GenerateStatelessSummaryResponse {
    const message = createBaseGenerateStatelessSummaryResponse();
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? GenerateStatelessSummaryResponse_Summary.fromPartial(object.summary)
      : undefined;
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseGenerateStatelessSummaryResponse_Summary(): GenerateStatelessSummaryResponse_Summary {
  return { text: "", textSections: {}, baselineModelVersion: "" };
}

export const GenerateStatelessSummaryResponse_Summary: MessageFns<GenerateStatelessSummaryResponse_Summary> = {
  encode(message: GenerateStatelessSummaryResponse_Summary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    Object.entries(message.textSections).forEach(([key, value]) => {
      GenerateStatelessSummaryResponse_Summary_TextSectionsEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    if (message.baselineModelVersion !== "") {
      writer.uint32(34).string(message.baselineModelVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateStatelessSummaryResponse_Summary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateStatelessSummaryResponse_Summary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = GenerateStatelessSummaryResponse_Summary_TextSectionsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.textSections[entry2.key] = entry2.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.baselineModelVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateStatelessSummaryResponse_Summary {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      textSections: isObject(object.textSections)
        ? Object.entries(object.textSections).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      baselineModelVersion: isSet(object.baselineModelVersion) ? globalThis.String(object.baselineModelVersion) : "",
    };
  },

  toJSON(message: GenerateStatelessSummaryResponse_Summary): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.textSections) {
      const entries = Object.entries(message.textSections);
      if (entries.length > 0) {
        obj.textSections = {};
        entries.forEach(([k, v]) => {
          obj.textSections[k] = v;
        });
      }
    }
    if (message.baselineModelVersion !== "") {
      obj.baselineModelVersion = message.baselineModelVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateStatelessSummaryResponse_Summary>): GenerateStatelessSummaryResponse_Summary {
    return GenerateStatelessSummaryResponse_Summary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateStatelessSummaryResponse_Summary>): GenerateStatelessSummaryResponse_Summary {
    const message = createBaseGenerateStatelessSummaryResponse_Summary();
    message.text = object.text ?? "";
    message.textSections = Object.entries(object.textSections ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.baselineModelVersion = object.baselineModelVersion ?? "";
    return message;
  },
};

function createBaseGenerateStatelessSummaryResponse_Summary_TextSectionsEntry(): GenerateStatelessSummaryResponse_Summary_TextSectionsEntry {
  return { key: "", value: "" };
}

export const GenerateStatelessSummaryResponse_Summary_TextSectionsEntry: MessageFns<
  GenerateStatelessSummaryResponse_Summary_TextSectionsEntry
> = {
  encode(
    message: GenerateStatelessSummaryResponse_Summary_TextSectionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GenerateStatelessSummaryResponse_Summary_TextSectionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateStatelessSummaryResponse_Summary_TextSectionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateStatelessSummaryResponse_Summary_TextSectionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GenerateStatelessSummaryResponse_Summary_TextSectionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GenerateStatelessSummaryResponse_Summary_TextSectionsEntry>,
  ): GenerateStatelessSummaryResponse_Summary_TextSectionsEntry {
    return GenerateStatelessSummaryResponse_Summary_TextSectionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenerateStatelessSummaryResponse_Summary_TextSectionsEntry>,
  ): GenerateStatelessSummaryResponse_Summary_TextSectionsEntry {
    const message = createBaseGenerateStatelessSummaryResponse_Summary_TextSectionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGenerateStatelessSuggestionRequest(): GenerateStatelessSuggestionRequest {
  return {
    parent: "",
    generator: undefined,
    generatorName: undefined,
    conversationContext: undefined,
    triggerEvents: [],
  };
}

export const GenerateStatelessSuggestionRequest: MessageFns<GenerateStatelessSuggestionRequest> = {
  encode(message: GenerateStatelessSuggestionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.generator !== undefined) {
      Generator.encode(message.generator, writer.uint32(18).fork()).join();
    }
    if (message.generatorName !== undefined) {
      writer.uint32(26).string(message.generatorName);
    }
    if (message.conversationContext !== undefined) {
      ConversationContext.encode(message.conversationContext, writer.uint32(42).fork()).join();
    }
    writer.uint32(50).fork();
    for (const v of message.triggerEvents) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateStatelessSuggestionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateStatelessSuggestionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.generator = Generator.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.generatorName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.conversationContext = ConversationContext.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag === 48) {
            message.triggerEvents.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.triggerEvents.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateStatelessSuggestionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      generator: isSet(object.generator) ? Generator.fromJSON(object.generator) : undefined,
      generatorName: isSet(object.generatorName) ? globalThis.String(object.generatorName) : undefined,
      conversationContext: isSet(object.conversationContext)
        ? ConversationContext.fromJSON(object.conversationContext)
        : undefined,
      triggerEvents: globalThis.Array.isArray(object?.triggerEvents)
        ? object.triggerEvents.map((e: any) => triggerEventFromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateStatelessSuggestionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.generator !== undefined) {
      obj.generator = Generator.toJSON(message.generator);
    }
    if (message.generatorName !== undefined) {
      obj.generatorName = message.generatorName;
    }
    if (message.conversationContext !== undefined) {
      obj.conversationContext = ConversationContext.toJSON(message.conversationContext);
    }
    if (message.triggerEvents?.length) {
      obj.triggerEvents = message.triggerEvents.map((e) => triggerEventToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateStatelessSuggestionRequest>): GenerateStatelessSuggestionRequest {
    return GenerateStatelessSuggestionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateStatelessSuggestionRequest>): GenerateStatelessSuggestionRequest {
    const message = createBaseGenerateStatelessSuggestionRequest();
    message.parent = object.parent ?? "";
    message.generator = (object.generator !== undefined && object.generator !== null)
      ? Generator.fromPartial(object.generator)
      : undefined;
    message.generatorName = object.generatorName ?? undefined;
    message.conversationContext = (object.conversationContext !== undefined && object.conversationContext !== null)
      ? ConversationContext.fromPartial(object.conversationContext)
      : undefined;
    message.triggerEvents = object.triggerEvents?.map((e) => e) || [];
    return message;
  },
};

function createBaseGenerateStatelessSuggestionResponse(): GenerateStatelessSuggestionResponse {
  return { generatorSuggestion: undefined };
}

export const GenerateStatelessSuggestionResponse: MessageFns<GenerateStatelessSuggestionResponse> = {
  encode(message: GenerateStatelessSuggestionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.generatorSuggestion !== undefined) {
      GeneratorSuggestion.encode(message.generatorSuggestion, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateStatelessSuggestionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateStatelessSuggestionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.generatorSuggestion = GeneratorSuggestion.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateStatelessSuggestionResponse {
    return {
      generatorSuggestion: isSet(object.generatorSuggestion)
        ? GeneratorSuggestion.fromJSON(object.generatorSuggestion)
        : undefined,
    };
  },

  toJSON(message: GenerateStatelessSuggestionResponse): unknown {
    const obj: any = {};
    if (message.generatorSuggestion !== undefined) {
      obj.generatorSuggestion = GeneratorSuggestion.toJSON(message.generatorSuggestion);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateStatelessSuggestionResponse>): GenerateStatelessSuggestionResponse {
    return GenerateStatelessSuggestionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateStatelessSuggestionResponse>): GenerateStatelessSuggestionResponse {
    const message = createBaseGenerateStatelessSuggestionResponse();
    message.generatorSuggestion = (object.generatorSuggestion !== undefined && object.generatorSuggestion !== null)
      ? GeneratorSuggestion.fromPartial(object.generatorSuggestion)
      : undefined;
    return message;
  },
};

function createBaseSearchKnowledgeRequest(): SearchKnowledgeRequest {
  return { parent: "", query: undefined, conversationProfile: "", sessionId: "", conversation: "", latestMessage: "" };
}

export const SearchKnowledgeRequest: MessageFns<SearchKnowledgeRequest> = {
  encode(message: SearchKnowledgeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(50).string(message.parent);
    }
    if (message.query !== undefined) {
      TextInput.encode(message.query, writer.uint32(10).fork()).join();
    }
    if (message.conversationProfile !== "") {
      writer.uint32(18).string(message.conversationProfile);
    }
    if (message.sessionId !== "") {
      writer.uint32(26).string(message.sessionId);
    }
    if (message.conversation !== "") {
      writer.uint32(34).string(message.conversation);
    }
    if (message.latestMessage !== "") {
      writer.uint32(42).string(message.latestMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchKnowledgeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchKnowledgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = TextInput.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversationProfile = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.conversation = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchKnowledgeRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      query: isSet(object.query) ? TextInput.fromJSON(object.query) : undefined,
      conversationProfile: isSet(object.conversationProfile) ? globalThis.String(object.conversationProfile) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      conversation: isSet(object.conversation) ? globalThis.String(object.conversation) : "",
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
    };
  },

  toJSON(message: SearchKnowledgeRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.query !== undefined) {
      obj.query = TextInput.toJSON(message.query);
    }
    if (message.conversationProfile !== "") {
      obj.conversationProfile = message.conversationProfile;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.conversation !== "") {
      obj.conversation = message.conversation;
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchKnowledgeRequest>): SearchKnowledgeRequest {
    return SearchKnowledgeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchKnowledgeRequest>): SearchKnowledgeRequest {
    const message = createBaseSearchKnowledgeRequest();
    message.parent = object.parent ?? "";
    message.query = (object.query !== undefined && object.query !== null)
      ? TextInput.fromPartial(object.query)
      : undefined;
    message.conversationProfile = object.conversationProfile ?? "";
    message.sessionId = object.sessionId ?? "";
    message.conversation = object.conversation ?? "";
    message.latestMessage = object.latestMessage ?? "";
    return message;
  },
};

function createBaseSearchKnowledgeResponse(): SearchKnowledgeResponse {
  return { answers: [], rewrittenQuery: "" };
}

export const SearchKnowledgeResponse: MessageFns<SearchKnowledgeResponse> = {
  encode(message: SearchKnowledgeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.answers) {
      SearchKnowledgeAnswer.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.rewrittenQuery !== "") {
      writer.uint32(26).string(message.rewrittenQuery);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchKnowledgeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchKnowledgeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.answers.push(SearchKnowledgeAnswer.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rewrittenQuery = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchKnowledgeResponse {
    return {
      answers: globalThis.Array.isArray(object?.answers)
        ? object.answers.map((e: any) => SearchKnowledgeAnswer.fromJSON(e))
        : [],
      rewrittenQuery: isSet(object.rewrittenQuery) ? globalThis.String(object.rewrittenQuery) : "",
    };
  },

  toJSON(message: SearchKnowledgeResponse): unknown {
    const obj: any = {};
    if (message.answers?.length) {
      obj.answers = message.answers.map((e) => SearchKnowledgeAnswer.toJSON(e));
    }
    if (message.rewrittenQuery !== "") {
      obj.rewrittenQuery = message.rewrittenQuery;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchKnowledgeResponse>): SearchKnowledgeResponse {
    return SearchKnowledgeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchKnowledgeResponse>): SearchKnowledgeResponse {
    const message = createBaseSearchKnowledgeResponse();
    message.answers = object.answers?.map((e) => SearchKnowledgeAnswer.fromPartial(e)) || [];
    message.rewrittenQuery = object.rewrittenQuery ?? "";
    return message;
  },
};

function createBaseSearchKnowledgeAnswer(): SearchKnowledgeAnswer {
  return { answer: "", answerType: 0, answerSources: [], answerRecord: "" };
}

export const SearchKnowledgeAnswer: MessageFns<SearchKnowledgeAnswer> = {
  encode(message: SearchKnowledgeAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answer !== "") {
      writer.uint32(10).string(message.answer);
    }
    if (message.answerType !== 0) {
      writer.uint32(16).int32(message.answerType);
    }
    for (const v of message.answerSources) {
      SearchKnowledgeAnswer_AnswerSource.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.answerRecord !== "") {
      writer.uint32(42).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchKnowledgeAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchKnowledgeAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.answer = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.answerType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.answerSources.push(SearchKnowledgeAnswer_AnswerSource.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchKnowledgeAnswer {
    return {
      answer: isSet(object.answer) ? globalThis.String(object.answer) : "",
      answerType: isSet(object.answerType) ? searchKnowledgeAnswer_AnswerTypeFromJSON(object.answerType) : 0,
      answerSources: globalThis.Array.isArray(object?.answerSources)
        ? object.answerSources.map((e: any) => SearchKnowledgeAnswer_AnswerSource.fromJSON(e))
        : [],
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
    };
  },

  toJSON(message: SearchKnowledgeAnswer): unknown {
    const obj: any = {};
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    if (message.answerType !== 0) {
      obj.answerType = searchKnowledgeAnswer_AnswerTypeToJSON(message.answerType);
    }
    if (message.answerSources?.length) {
      obj.answerSources = message.answerSources.map((e) => SearchKnowledgeAnswer_AnswerSource.toJSON(e));
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchKnowledgeAnswer>): SearchKnowledgeAnswer {
    return SearchKnowledgeAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchKnowledgeAnswer>): SearchKnowledgeAnswer {
    const message = createBaseSearchKnowledgeAnswer();
    message.answer = object.answer ?? "";
    message.answerType = object.answerType ?? 0;
    message.answerSources = object.answerSources?.map((e) => SearchKnowledgeAnswer_AnswerSource.fromPartial(e)) || [];
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseSearchKnowledgeAnswer_AnswerSource(): SearchKnowledgeAnswer_AnswerSource {
  return { title: "", uri: "", snippet: "" };
}

export const SearchKnowledgeAnswer_AnswerSource: MessageFns<SearchKnowledgeAnswer_AnswerSource> = {
  encode(message: SearchKnowledgeAnswer_AnswerSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.snippet !== "") {
      writer.uint32(26).string(message.snippet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchKnowledgeAnswer_AnswerSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchKnowledgeAnswer_AnswerSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.snippet = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchKnowledgeAnswer_AnswerSource {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      snippet: isSet(object.snippet) ? globalThis.String(object.snippet) : "",
    };
  },

  toJSON(message: SearchKnowledgeAnswer_AnswerSource): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.snippet !== "") {
      obj.snippet = message.snippet;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchKnowledgeAnswer_AnswerSource>): SearchKnowledgeAnswer_AnswerSource {
    return SearchKnowledgeAnswer_AnswerSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchKnowledgeAnswer_AnswerSource>): SearchKnowledgeAnswer_AnswerSource {
    const message = createBaseSearchKnowledgeAnswer_AnswerSource();
    message.title = object.title ?? "";
    message.uri = object.uri ?? "";
    message.snippet = object.snippet ?? "";
    return message;
  },
};

/**
 * Service for managing
 * [Conversations][google.cloud.dialogflow.v2.Conversation].
 */
export type ConversationsDefinition = typeof ConversationsDefinition;
export const ConversationsDefinition = {
  name: "Conversations",
  fullName: "google.cloud.dialogflow.v2.Conversations",
  methods: {
    /**
     * Creates a new conversation. Conversations are auto-completed after 24
     * hours.
     *
     * Conversation Lifecycle:
     * There are two stages during a conversation: Automated Agent Stage and
     * Assist Stage.
     *
     * For Automated Agent Stage, there will be a dialogflow agent responding to
     * user queries.
     *
     * For Assist Stage, there's no dialogflow agent responding to user queries.
     * But we will provide suggestions which are generated from conversation.
     *
     * If
     * [Conversation.conversation_profile][google.cloud.dialogflow.v2.Conversation.conversation_profile]
     * is configured for a dialogflow agent, conversation will start from
     * `Automated Agent Stage`, otherwise, it will start from `Assist Stage`. And
     * during `Automated Agent Stage`, once an
     * [Intent][google.cloud.dialogflow.v2.Intent] with
     * [Intent.live_agent_handoff][google.cloud.dialogflow.v2.Intent.live_agent_handoff]
     * is triggered, conversation will transfer to Assist Stage.
     */
    createConversation: {
      name: "CreateConversation",
      requestType: CreateConversationRequest,
      requestStream: false,
      responseType: Conversation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              19,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              120,
              58,
              12,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              90,
              65,
              58,
              12,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              34,
              49,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              34,
              37,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the list of all conversations in the specified project. */
    listConversations: {
      name: "ListConversations",
      requestType: ListConversationsRequest,
      requestStream: false,
      responseType: ListConversationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              92,
              90,
              51,
              18,
              49,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              18,
              37,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves the specific conversation. */
    getConversation: {
      name: "GetConversation",
      requestType: GetConversationRequest,
      requestStream: false,
      responseType: Conversation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              92,
              90,
              51,
              18,
              49,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              18,
              37,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Completes the specified conversation. Finished conversations are purged
     * from the database after 30 days.
     */
    completeConversation: {
      name: "CompleteConversation",
      requestType: CompleteConversationRequest,
      requestStream: false,
      responseType: Conversation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              116,
              58,
              1,
              42,
              90,
              63,
              58,
              1,
              42,
              34,
              58,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              99,
              111,
              109,
              112,
              108,
              101,
              116,
              101,
              34,
              46,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              99,
              111,
              109,
              112,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Lists messages that belong to a given conversation.
     * `messages` are ordered by `create_time` in descending order. To fetch
     * updates without duplication, send request with filter
     * `create_time_epoch_microseconds >
     * [first item's create_time of previous request]` and empty page_token.
     */
    listMessages: {
      name: "ListMessages",
      requestType: ListMessagesRequest,
      requestStream: false,
      responseType: ListMessagesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              114,
              90,
              62,
              18,
              60,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              115,
              115,
              97,
              103,
              101,
              115,
              18,
              48,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              115,
              115,
              97,
              103,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Suggests summary for a conversation based on specific historical messages.
     * The range of the messages to be used for summary can be specified in the
     * request.
     */
    suggestConversationSummary: {
      name: "SuggestConversationSummary",
      requestType: SuggestConversationSummaryRequest,
      requestStream: false,
      responseType: SuggestConversationSummaryResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 99, 111, 110, 118, 101, 114, 115, 97, 116, 105, 111, 110])],
          578365826: [
            Buffer.from([
              192,
              1,
              58,
              1,
              42,
              90,
              101,
              58,
              1,
              42,
              34,
              96,
              47,
              118,
              50,
              47,
              123,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              67,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              83,
              117,
              109,
              109,
              97,
              114,
              121,
              34,
              84,
              47,
              118,
              50,
              47,
              123,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              67,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              83,
              117,
              109,
              109,
              97,
              114,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Generates and returns a summary for a conversation that does not have a
     * resource created for it.
     */
    generateStatelessSummary: {
      name: "GenerateStatelessSummary",
      requestType: GenerateStatelessSummaryRequest,
      requestStream: false,
      responseType: GenerateStatelessSummaryResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              190,
              1,
              58,
              1,
              42,
              90,
              100,
              58,
              1,
              42,
              34,
              95,
              47,
              118,
              50,
              47,
              123,
              115,
              116,
              97,
              116,
              101,
              108,
              101,
              115,
              115,
              95,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              46,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              83,
              116,
              97,
              116,
              101,
              108,
              101,
              115,
              115,
              83,
              117,
              109,
              109,
              97,
              114,
              121,
              34,
              83,
              47,
              118,
              50,
              47,
              123,
              115,
              116,
              97,
              116,
              101,
              108,
              101,
              115,
              115,
              95,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              46,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              83,
              116,
              97,
              116,
              101,
              108,
              101,
              115,
              115,
              83,
              117,
              109,
              109,
              97,
              114,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Generates and returns a suggestion for a conversation that does not have a
     * resource created for it.
     */
    generateStatelessSuggestion: {
      name: "GenerateStatelessSuggestion",
      requestType: GenerateStatelessSuggestionRequest,
      requestStream: false,
      responseType: GenerateStatelessSuggestionResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              116,
              97,
              116,
              101,
              108,
              101,
              115,
              115,
              83,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Get answers for the given query based on knowledge documents. */
    searchKnowledge: {
      name: "SearchKnowledge",
      requestType: SearchKnowledgeRequest,
      requestStream: false,
      responseType: SearchKnowledgeResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              170,
              2,
              58,
              1,
              42,
              90,
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              75,
              110,
              111,
              119,
              108,
              101,
              100,
              103,
              101,
              90,
              78,
              58,
              1,
              42,
              34,
              73,
              47,
              118,
              50,
              47,
              123,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              75,
              110,
              111,
              119,
              108,
              101,
              100,
              103,
              101,
              90,
              90,
              58,
              1,
              42,
              34,
              85,
              47,
              118,
              50,
              47,
              123,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              75,
              110,
              111,
              119,
              108,
              101,
              100,
              103,
              101,
              34,
              51,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              75,
              110,
              111,
              119,
              108,
              101,
              100,
              103,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ConversationsServiceImplementation<CallContextExt = {}> {
  /**
   * Creates a new conversation. Conversations are auto-completed after 24
   * hours.
   *
   * Conversation Lifecycle:
   * There are two stages during a conversation: Automated Agent Stage and
   * Assist Stage.
   *
   * For Automated Agent Stage, there will be a dialogflow agent responding to
   * user queries.
   *
   * For Assist Stage, there's no dialogflow agent responding to user queries.
   * But we will provide suggestions which are generated from conversation.
   *
   * If
   * [Conversation.conversation_profile][google.cloud.dialogflow.v2.Conversation.conversation_profile]
   * is configured for a dialogflow agent, conversation will start from
   * `Automated Agent Stage`, otherwise, it will start from `Assist Stage`. And
   * during `Automated Agent Stage`, once an
   * [Intent][google.cloud.dialogflow.v2.Intent] with
   * [Intent.live_agent_handoff][google.cloud.dialogflow.v2.Intent.live_agent_handoff]
   * is triggered, conversation will transfer to Assist Stage.
   */
  createConversation(
    request: CreateConversationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Conversation>>;
  /** Returns the list of all conversations in the specified project. */
  listConversations(
    request: ListConversationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListConversationsResponse>>;
  /** Retrieves the specific conversation. */
  getConversation(
    request: GetConversationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Conversation>>;
  /**
   * Completes the specified conversation. Finished conversations are purged
   * from the database after 30 days.
   */
  completeConversation(
    request: CompleteConversationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Conversation>>;
  /**
   * Lists messages that belong to a given conversation.
   * `messages` are ordered by `create_time` in descending order. To fetch
   * updates without duplication, send request with filter
   * `create_time_epoch_microseconds >
   * [first item's create_time of previous request]` and empty page_token.
   */
  listMessages(
    request: ListMessagesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListMessagesResponse>>;
  /**
   * Suggests summary for a conversation based on specific historical messages.
   * The range of the messages to be used for summary can be specified in the
   * request.
   */
  suggestConversationSummary(
    request: SuggestConversationSummaryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SuggestConversationSummaryResponse>>;
  /**
   * Generates and returns a summary for a conversation that does not have a
   * resource created for it.
   */
  generateStatelessSummary(
    request: GenerateStatelessSummaryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateStatelessSummaryResponse>>;
  /**
   * Generates and returns a suggestion for a conversation that does not have a
   * resource created for it.
   */
  generateStatelessSuggestion(
    request: GenerateStatelessSuggestionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateStatelessSuggestionResponse>>;
  /** Get answers for the given query based on knowledge documents. */
  searchKnowledge(
    request: SearchKnowledgeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchKnowledgeResponse>>;
}

export interface ConversationsClient<CallOptionsExt = {}> {
  /**
   * Creates a new conversation. Conversations are auto-completed after 24
   * hours.
   *
   * Conversation Lifecycle:
   * There are two stages during a conversation: Automated Agent Stage and
   * Assist Stage.
   *
   * For Automated Agent Stage, there will be a dialogflow agent responding to
   * user queries.
   *
   * For Assist Stage, there's no dialogflow agent responding to user queries.
   * But we will provide suggestions which are generated from conversation.
   *
   * If
   * [Conversation.conversation_profile][google.cloud.dialogflow.v2.Conversation.conversation_profile]
   * is configured for a dialogflow agent, conversation will start from
   * `Automated Agent Stage`, otherwise, it will start from `Assist Stage`. And
   * during `Automated Agent Stage`, once an
   * [Intent][google.cloud.dialogflow.v2.Intent] with
   * [Intent.live_agent_handoff][google.cloud.dialogflow.v2.Intent.live_agent_handoff]
   * is triggered, conversation will transfer to Assist Stage.
   */
  createConversation(
    request: DeepPartial<CreateConversationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Conversation>;
  /** Returns the list of all conversations in the specified project. */
  listConversations(
    request: DeepPartial<ListConversationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListConversationsResponse>;
  /** Retrieves the specific conversation. */
  getConversation(
    request: DeepPartial<GetConversationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Conversation>;
  /**
   * Completes the specified conversation. Finished conversations are purged
   * from the database after 30 days.
   */
  completeConversation(
    request: DeepPartial<CompleteConversationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Conversation>;
  /**
   * Lists messages that belong to a given conversation.
   * `messages` are ordered by `create_time` in descending order. To fetch
   * updates without duplication, send request with filter
   * `create_time_epoch_microseconds >
   * [first item's create_time of previous request]` and empty page_token.
   */
  listMessages(
    request: DeepPartial<ListMessagesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListMessagesResponse>;
  /**
   * Suggests summary for a conversation based on specific historical messages.
   * The range of the messages to be used for summary can be specified in the
   * request.
   */
  suggestConversationSummary(
    request: DeepPartial<SuggestConversationSummaryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SuggestConversationSummaryResponse>;
  /**
   * Generates and returns a summary for a conversation that does not have a
   * resource created for it.
   */
  generateStatelessSummary(
    request: DeepPartial<GenerateStatelessSummaryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateStatelessSummaryResponse>;
  /**
   * Generates and returns a suggestion for a conversation that does not have a
   * resource created for it.
   */
  generateStatelessSuggestion(
    request: DeepPartial<GenerateStatelessSuggestionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateStatelessSuggestionResponse>;
  /** Get answers for the given query based on knowledge documents. */
  searchKnowledge(
    request: DeepPartial<SearchKnowledgeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchKnowledgeResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
