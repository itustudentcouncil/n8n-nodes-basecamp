// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/clouddms/v1/conversionworkspace_resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Empty } from "../../../protobuf/empty.js";
import { Struct } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { DatabaseEngine, databaseEngineFromJSON, databaseEngineToJSON } from "./clouddms_resources.js";

export const protobufPackage = "google.cloud.clouddms.v1";

/**
 * Enum used by ValueListFilter to indicate whether the source value is in the
 * supplied list
 */
export enum ValuePresentInList {
  /** VALUE_PRESENT_IN_LIST_UNSPECIFIED - Value present in list unspecified */
  VALUE_PRESENT_IN_LIST_UNSPECIFIED = 0,
  /** VALUE_PRESENT_IN_LIST_IF_VALUE_LIST - If the source value is in the supplied list at value_list */
  VALUE_PRESENT_IN_LIST_IF_VALUE_LIST = 1,
  /** VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST - If the source value is not in the supplied list at value_list */
  VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST = 2,
  UNRECOGNIZED = -1,
}

export function valuePresentInListFromJSON(object: any): ValuePresentInList {
  switch (object) {
    case 0:
    case "VALUE_PRESENT_IN_LIST_UNSPECIFIED":
      return ValuePresentInList.VALUE_PRESENT_IN_LIST_UNSPECIFIED;
    case 1:
    case "VALUE_PRESENT_IN_LIST_IF_VALUE_LIST":
      return ValuePresentInList.VALUE_PRESENT_IN_LIST_IF_VALUE_LIST;
    case 2:
    case "VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST":
      return ValuePresentInList.VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ValuePresentInList.UNRECOGNIZED;
  }
}

export function valuePresentInListToJSON(object: ValuePresentInList): string {
  switch (object) {
    case ValuePresentInList.VALUE_PRESENT_IN_LIST_UNSPECIFIED:
      return "VALUE_PRESENT_IN_LIST_UNSPECIFIED";
    case ValuePresentInList.VALUE_PRESENT_IN_LIST_IF_VALUE_LIST:
      return "VALUE_PRESENT_IN_LIST_IF_VALUE_LIST";
    case ValuePresentInList.VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST:
      return "VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST";
    case ValuePresentInList.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The type of database entities supported, */
export enum DatabaseEntityType {
  /** DATABASE_ENTITY_TYPE_UNSPECIFIED - Unspecified database entity type. */
  DATABASE_ENTITY_TYPE_UNSPECIFIED = 0,
  /** DATABASE_ENTITY_TYPE_SCHEMA - Schema. */
  DATABASE_ENTITY_TYPE_SCHEMA = 1,
  /** DATABASE_ENTITY_TYPE_TABLE - Table. */
  DATABASE_ENTITY_TYPE_TABLE = 2,
  /** DATABASE_ENTITY_TYPE_COLUMN - Column. */
  DATABASE_ENTITY_TYPE_COLUMN = 3,
  /** DATABASE_ENTITY_TYPE_CONSTRAINT - Constraint. */
  DATABASE_ENTITY_TYPE_CONSTRAINT = 4,
  /** DATABASE_ENTITY_TYPE_INDEX - Index. */
  DATABASE_ENTITY_TYPE_INDEX = 5,
  /** DATABASE_ENTITY_TYPE_TRIGGER - Trigger. */
  DATABASE_ENTITY_TYPE_TRIGGER = 6,
  /** DATABASE_ENTITY_TYPE_VIEW - View. */
  DATABASE_ENTITY_TYPE_VIEW = 7,
  /** DATABASE_ENTITY_TYPE_SEQUENCE - Sequence. */
  DATABASE_ENTITY_TYPE_SEQUENCE = 8,
  /** DATABASE_ENTITY_TYPE_STORED_PROCEDURE - Stored Procedure. */
  DATABASE_ENTITY_TYPE_STORED_PROCEDURE = 9,
  /** DATABASE_ENTITY_TYPE_FUNCTION - Function. */
  DATABASE_ENTITY_TYPE_FUNCTION = 10,
  /** DATABASE_ENTITY_TYPE_SYNONYM - Synonym. */
  DATABASE_ENTITY_TYPE_SYNONYM = 11,
  /** DATABASE_ENTITY_TYPE_DATABASE_PACKAGE - Package. */
  DATABASE_ENTITY_TYPE_DATABASE_PACKAGE = 12,
  /** DATABASE_ENTITY_TYPE_UDT - UDT. */
  DATABASE_ENTITY_TYPE_UDT = 13,
  /** DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW - Materialized View. */
  DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW = 14,
  /** DATABASE_ENTITY_TYPE_DATABASE - Database. */
  DATABASE_ENTITY_TYPE_DATABASE = 15,
  UNRECOGNIZED = -1,
}

export function databaseEntityTypeFromJSON(object: any): DatabaseEntityType {
  switch (object) {
    case 0:
    case "DATABASE_ENTITY_TYPE_UNSPECIFIED":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_UNSPECIFIED;
    case 1:
    case "DATABASE_ENTITY_TYPE_SCHEMA":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_SCHEMA;
    case 2:
    case "DATABASE_ENTITY_TYPE_TABLE":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_TABLE;
    case 3:
    case "DATABASE_ENTITY_TYPE_COLUMN":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_COLUMN;
    case 4:
    case "DATABASE_ENTITY_TYPE_CONSTRAINT":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_CONSTRAINT;
    case 5:
    case "DATABASE_ENTITY_TYPE_INDEX":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_INDEX;
    case 6:
    case "DATABASE_ENTITY_TYPE_TRIGGER":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_TRIGGER;
    case 7:
    case "DATABASE_ENTITY_TYPE_VIEW":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_VIEW;
    case 8:
    case "DATABASE_ENTITY_TYPE_SEQUENCE":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_SEQUENCE;
    case 9:
    case "DATABASE_ENTITY_TYPE_STORED_PROCEDURE":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_STORED_PROCEDURE;
    case 10:
    case "DATABASE_ENTITY_TYPE_FUNCTION":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_FUNCTION;
    case 11:
    case "DATABASE_ENTITY_TYPE_SYNONYM":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_SYNONYM;
    case 12:
    case "DATABASE_ENTITY_TYPE_DATABASE_PACKAGE":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_DATABASE_PACKAGE;
    case 13:
    case "DATABASE_ENTITY_TYPE_UDT":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_UDT;
    case 14:
    case "DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW;
    case 15:
    case "DATABASE_ENTITY_TYPE_DATABASE":
      return DatabaseEntityType.DATABASE_ENTITY_TYPE_DATABASE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatabaseEntityType.UNRECOGNIZED;
  }
}

export function databaseEntityTypeToJSON(object: DatabaseEntityType): string {
  switch (object) {
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_UNSPECIFIED:
      return "DATABASE_ENTITY_TYPE_UNSPECIFIED";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_SCHEMA:
      return "DATABASE_ENTITY_TYPE_SCHEMA";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_TABLE:
      return "DATABASE_ENTITY_TYPE_TABLE";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_COLUMN:
      return "DATABASE_ENTITY_TYPE_COLUMN";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_CONSTRAINT:
      return "DATABASE_ENTITY_TYPE_CONSTRAINT";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_INDEX:
      return "DATABASE_ENTITY_TYPE_INDEX";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_TRIGGER:
      return "DATABASE_ENTITY_TYPE_TRIGGER";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_VIEW:
      return "DATABASE_ENTITY_TYPE_VIEW";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_SEQUENCE:
      return "DATABASE_ENTITY_TYPE_SEQUENCE";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_STORED_PROCEDURE:
      return "DATABASE_ENTITY_TYPE_STORED_PROCEDURE";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_FUNCTION:
      return "DATABASE_ENTITY_TYPE_FUNCTION";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_SYNONYM:
      return "DATABASE_ENTITY_TYPE_SYNONYM";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_DATABASE_PACKAGE:
      return "DATABASE_ENTITY_TYPE_DATABASE_PACKAGE";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_UDT:
      return "DATABASE_ENTITY_TYPE_UDT";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW:
      return "DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW";
    case DatabaseEntityType.DATABASE_ENTITY_TYPE_DATABASE:
      return "DATABASE_ENTITY_TYPE_DATABASE";
    case DatabaseEntityType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Entity Name Transformation Types */
export enum EntityNameTransformation {
  /** ENTITY_NAME_TRANSFORMATION_UNSPECIFIED - Entity name transformation unspecified. */
  ENTITY_NAME_TRANSFORMATION_UNSPECIFIED = 0,
  /** ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION - No transformation. */
  ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION = 1,
  /** ENTITY_NAME_TRANSFORMATION_LOWER_CASE - Transform to lower case. */
  ENTITY_NAME_TRANSFORMATION_LOWER_CASE = 2,
  /** ENTITY_NAME_TRANSFORMATION_UPPER_CASE - Transform to upper case. */
  ENTITY_NAME_TRANSFORMATION_UPPER_CASE = 3,
  /** ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE - Transform to capitalized case. */
  ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE = 4,
  UNRECOGNIZED = -1,
}

export function entityNameTransformationFromJSON(object: any): EntityNameTransformation {
  switch (object) {
    case 0:
    case "ENTITY_NAME_TRANSFORMATION_UNSPECIFIED":
      return EntityNameTransformation.ENTITY_NAME_TRANSFORMATION_UNSPECIFIED;
    case 1:
    case "ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION":
      return EntityNameTransformation.ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION;
    case 2:
    case "ENTITY_NAME_TRANSFORMATION_LOWER_CASE":
      return EntityNameTransformation.ENTITY_NAME_TRANSFORMATION_LOWER_CASE;
    case 3:
    case "ENTITY_NAME_TRANSFORMATION_UPPER_CASE":
      return EntityNameTransformation.ENTITY_NAME_TRANSFORMATION_UPPER_CASE;
    case 4:
    case "ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE":
      return EntityNameTransformation.ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EntityNameTransformation.UNRECOGNIZED;
  }
}

export function entityNameTransformationToJSON(object: EntityNameTransformation): string {
  switch (object) {
    case EntityNameTransformation.ENTITY_NAME_TRANSFORMATION_UNSPECIFIED:
      return "ENTITY_NAME_TRANSFORMATION_UNSPECIFIED";
    case EntityNameTransformation.ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION:
      return "ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION";
    case EntityNameTransformation.ENTITY_NAME_TRANSFORMATION_LOWER_CASE:
      return "ENTITY_NAME_TRANSFORMATION_LOWER_CASE";
    case EntityNameTransformation.ENTITY_NAME_TRANSFORMATION_UPPER_CASE:
      return "ENTITY_NAME_TRANSFORMATION_UPPER_CASE";
    case EntityNameTransformation.ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE:
      return "ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE";
    case EntityNameTransformation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The types of jobs that can be executed in the background. */
export enum BackgroundJobType {
  /** BACKGROUND_JOB_TYPE_UNSPECIFIED - Unspecified background job type. */
  BACKGROUND_JOB_TYPE_UNSPECIFIED = 0,
  /** BACKGROUND_JOB_TYPE_SOURCE_SEED - Job to seed from the source database. */
  BACKGROUND_JOB_TYPE_SOURCE_SEED = 1,
  /**
   * BACKGROUND_JOB_TYPE_CONVERT - Job to convert the source database into a draft of the destination
   * database.
   */
  BACKGROUND_JOB_TYPE_CONVERT = 2,
  /** BACKGROUND_JOB_TYPE_APPLY_DESTINATION - Job to apply the draft tree onto the destination. */
  BACKGROUND_JOB_TYPE_APPLY_DESTINATION = 3,
  /**
   * BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE - Job to import and convert mapping rules from an external source such as an
   * ora2pg config file.
   */
  BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE = 5,
  UNRECOGNIZED = -1,
}

export function backgroundJobTypeFromJSON(object: any): BackgroundJobType {
  switch (object) {
    case 0:
    case "BACKGROUND_JOB_TYPE_UNSPECIFIED":
      return BackgroundJobType.BACKGROUND_JOB_TYPE_UNSPECIFIED;
    case 1:
    case "BACKGROUND_JOB_TYPE_SOURCE_SEED":
      return BackgroundJobType.BACKGROUND_JOB_TYPE_SOURCE_SEED;
    case 2:
    case "BACKGROUND_JOB_TYPE_CONVERT":
      return BackgroundJobType.BACKGROUND_JOB_TYPE_CONVERT;
    case 3:
    case "BACKGROUND_JOB_TYPE_APPLY_DESTINATION":
      return BackgroundJobType.BACKGROUND_JOB_TYPE_APPLY_DESTINATION;
    case 5:
    case "BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE":
      return BackgroundJobType.BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackgroundJobType.UNRECOGNIZED;
  }
}

export function backgroundJobTypeToJSON(object: BackgroundJobType): string {
  switch (object) {
    case BackgroundJobType.BACKGROUND_JOB_TYPE_UNSPECIFIED:
      return "BACKGROUND_JOB_TYPE_UNSPECIFIED";
    case BackgroundJobType.BACKGROUND_JOB_TYPE_SOURCE_SEED:
      return "BACKGROUND_JOB_TYPE_SOURCE_SEED";
    case BackgroundJobType.BACKGROUND_JOB_TYPE_CONVERT:
      return "BACKGROUND_JOB_TYPE_CONVERT";
    case BackgroundJobType.BACKGROUND_JOB_TYPE_APPLY_DESTINATION:
      return "BACKGROUND_JOB_TYPE_APPLY_DESTINATION";
    case BackgroundJobType.BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE:
      return "BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE";
    case BackgroundJobType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The format for the import rules file. */
export enum ImportRulesFileFormat {
  /** IMPORT_RULES_FILE_FORMAT_UNSPECIFIED - Unspecified rules format. */
  IMPORT_RULES_FILE_FORMAT_UNSPECIFIED = 0,
  /** IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE - HarbourBridge session file. */
  IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE = 1,
  /** IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE - Ora2Pg configuration file. */
  IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE = 2,
  UNRECOGNIZED = -1,
}

export function importRulesFileFormatFromJSON(object: any): ImportRulesFileFormat {
  switch (object) {
    case 0:
    case "IMPORT_RULES_FILE_FORMAT_UNSPECIFIED":
      return ImportRulesFileFormat.IMPORT_RULES_FILE_FORMAT_UNSPECIFIED;
    case 1:
    case "IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE":
      return ImportRulesFileFormat.IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE;
    case 2:
    case "IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE":
      return ImportRulesFileFormat.IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImportRulesFileFormat.UNRECOGNIZED;
  }
}

export function importRulesFileFormatToJSON(object: ImportRulesFileFormat): string {
  switch (object) {
    case ImportRulesFileFormat.IMPORT_RULES_FILE_FORMAT_UNSPECIFIED:
      return "IMPORT_RULES_FILE_FORMAT_UNSPECIFIED";
    case ImportRulesFileFormat.IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE:
      return "IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE";
    case ImportRulesFileFormat.IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE:
      return "IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE";
    case ImportRulesFileFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Enum used by IntComparisonFilter and DoubleComparisonFilter to indicate the
 * relation between source value and compare value.
 */
export enum ValueComparison {
  /** VALUE_COMPARISON_UNSPECIFIED - Value comparison unspecified. */
  VALUE_COMPARISON_UNSPECIFIED = 0,
  /** VALUE_COMPARISON_IF_VALUE_SMALLER_THAN - Value is smaller than the Compare value. */
  VALUE_COMPARISON_IF_VALUE_SMALLER_THAN = 1,
  /** VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN - Value is smaller or equal than the Compare value. */
  VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN = 2,
  /** VALUE_COMPARISON_IF_VALUE_LARGER_THAN - Value is larger than the Compare value. */
  VALUE_COMPARISON_IF_VALUE_LARGER_THAN = 3,
  /** VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN - Value is larger or equal than the Compare value. */
  VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN = 4,
  UNRECOGNIZED = -1,
}

export function valueComparisonFromJSON(object: any): ValueComparison {
  switch (object) {
    case 0:
    case "VALUE_COMPARISON_UNSPECIFIED":
      return ValueComparison.VALUE_COMPARISON_UNSPECIFIED;
    case 1:
    case "VALUE_COMPARISON_IF_VALUE_SMALLER_THAN":
      return ValueComparison.VALUE_COMPARISON_IF_VALUE_SMALLER_THAN;
    case 2:
    case "VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN":
      return ValueComparison.VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN;
    case 3:
    case "VALUE_COMPARISON_IF_VALUE_LARGER_THAN":
      return ValueComparison.VALUE_COMPARISON_IF_VALUE_LARGER_THAN;
    case 4:
    case "VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN":
      return ValueComparison.VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ValueComparison.UNRECOGNIZED;
  }
}

export function valueComparisonToJSON(object: ValueComparison): string {
  switch (object) {
    case ValueComparison.VALUE_COMPARISON_UNSPECIFIED:
      return "VALUE_COMPARISON_UNSPECIFIED";
    case ValueComparison.VALUE_COMPARISON_IF_VALUE_SMALLER_THAN:
      return "VALUE_COMPARISON_IF_VALUE_SMALLER_THAN";
    case ValueComparison.VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN:
      return "VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN";
    case ValueComparison.VALUE_COMPARISON_IF_VALUE_LARGER_THAN:
      return "VALUE_COMPARISON_IF_VALUE_LARGER_THAN";
    case ValueComparison.VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN:
      return "VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN";
    case ValueComparison.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies the columns on which numeric filter needs to be applied. */
export enum NumericFilterOption {
  /** NUMERIC_FILTER_OPTION_UNSPECIFIED - Numeric filter option unspecified */
  NUMERIC_FILTER_OPTION_UNSPECIFIED = 0,
  /** NUMERIC_FILTER_OPTION_ALL - Numeric filter option that matches all numeric columns. */
  NUMERIC_FILTER_OPTION_ALL = 1,
  /**
   * NUMERIC_FILTER_OPTION_LIMIT - Numeric filter option that matches columns having numeric datatypes with
   * specified precision and scale within the limited range of filter.
   */
  NUMERIC_FILTER_OPTION_LIMIT = 2,
  /**
   * NUMERIC_FILTER_OPTION_LIMITLESS - Numeric filter option that matches only the numeric columns with no
   * precision and scale specified.
   */
  NUMERIC_FILTER_OPTION_LIMITLESS = 3,
  UNRECOGNIZED = -1,
}

export function numericFilterOptionFromJSON(object: any): NumericFilterOption {
  switch (object) {
    case 0:
    case "NUMERIC_FILTER_OPTION_UNSPECIFIED":
      return NumericFilterOption.NUMERIC_FILTER_OPTION_UNSPECIFIED;
    case 1:
    case "NUMERIC_FILTER_OPTION_ALL":
      return NumericFilterOption.NUMERIC_FILTER_OPTION_ALL;
    case 2:
    case "NUMERIC_FILTER_OPTION_LIMIT":
      return NumericFilterOption.NUMERIC_FILTER_OPTION_LIMIT;
    case 3:
    case "NUMERIC_FILTER_OPTION_LIMITLESS":
      return NumericFilterOption.NUMERIC_FILTER_OPTION_LIMITLESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NumericFilterOption.UNRECOGNIZED;
  }
}

export function numericFilterOptionToJSON(object: NumericFilterOption): string {
  switch (object) {
    case NumericFilterOption.NUMERIC_FILTER_OPTION_UNSPECIFIED:
      return "NUMERIC_FILTER_OPTION_UNSPECIFIED";
    case NumericFilterOption.NUMERIC_FILTER_OPTION_ALL:
      return "NUMERIC_FILTER_OPTION_ALL";
    case NumericFilterOption.NUMERIC_FILTER_OPTION_LIMIT:
      return "NUMERIC_FILTER_OPTION_LIMIT";
    case NumericFilterOption.NUMERIC_FILTER_OPTION_LIMITLESS:
      return "NUMERIC_FILTER_OPTION_LIMITLESS";
    case NumericFilterOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The type and version of a source or destination database. */
export interface DatabaseEngineInfo {
  /** Required. Engine type. */
  engine: DatabaseEngine;
  /** Required. Engine named version, for example 12.c.1. */
  version: string;
}

/** The main conversion workspace resource entity. */
export interface ConversionWorkspace {
  /**
   * Full name of the workspace resource, in the form of:
   * projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
   */
  name: string;
  /** Required. The source engine details. */
  source:
    | DatabaseEngineInfo
    | undefined;
  /** Required. The destination engine details. */
  destination:
    | DatabaseEngineInfo
    | undefined;
  /**
   * Optional. A generic list of settings for the workspace.
   * The settings are database pair dependant and can indicate default behavior
   * for the mapping rules engine or turn on or off specific features.
   * Such examples can be: convert_foreign_key_to_interleave=true,
   * skip_triggers=false, ignore_non_table_synonyms=true
   */
  globalSettings: { [key: string]: string };
  /**
   * Output only. Whether the workspace has uncommitted changes (changes which
   * were made after the workspace was committed).
   */
  hasUncommittedChanges: boolean;
  /** Output only. The latest commit ID. */
  latestCommitId: string;
  /** Output only. The timestamp when the workspace was committed. */
  latestCommitTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the workspace resource was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the workspace resource was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Optional. The display name for the workspace. */
  displayName: string;
}

export interface ConversionWorkspace_GlobalSettingsEntry {
  key: string;
  value: string;
}

/** Execution log of a background job. */
export interface BackgroundJobLogEntry {
  /** The background job log entry ID. */
  id: string;
  /** The type of job that was executed. */
  jobType: BackgroundJobType;
  /** The timestamp when the background job was started. */
  startTime:
    | Date
    | undefined;
  /** The timestamp when the background job was finished. */
  finishTime:
    | Date
    | undefined;
  /**
   * Output only. Job completion state, i.e. the final state after the job
   * completed.
   */
  completionState: BackgroundJobLogEntry_JobCompletionState;
  /**
   * Output only. Job completion comment, such as how many entities were seeded,
   * how many warnings were found during conversion, and similar information.
   */
  completionComment: string;
  /**
   * Output only. Whether the client requested the conversion workspace to be
   * committed after a successful completion of the job.
   */
  requestAutocommit: boolean;
  /** Output only. Seed job details. */
  seedJobDetails?:
    | BackgroundJobLogEntry_SeedJobDetails
    | undefined;
  /** Output only. Import rules job details. */
  importRulesJobDetails?:
    | BackgroundJobLogEntry_ImportRulesJobDetails
    | undefined;
  /** Output only. Convert job details. */
  convertJobDetails?:
    | BackgroundJobLogEntry_ConvertJobDetails
    | undefined;
  /** Output only. Apply job details. */
  applyJobDetails?: BackgroundJobLogEntry_ApplyJobDetails | undefined;
}

/** Final state after a job completes. */
export enum BackgroundJobLogEntry_JobCompletionState {
  /**
   * JOB_COMPLETION_STATE_UNSPECIFIED - The status is not specified. This state is used when job is not yet
   * finished.
   */
  JOB_COMPLETION_STATE_UNSPECIFIED = 0,
  /** SUCCEEDED - Success. */
  SUCCEEDED = 1,
  /** FAILED - Error. */
  FAILED = 2,
  UNRECOGNIZED = -1,
}

export function backgroundJobLogEntry_JobCompletionStateFromJSON(
  object: any,
): BackgroundJobLogEntry_JobCompletionState {
  switch (object) {
    case 0:
    case "JOB_COMPLETION_STATE_UNSPECIFIED":
      return BackgroundJobLogEntry_JobCompletionState.JOB_COMPLETION_STATE_UNSPECIFIED;
    case 1:
    case "SUCCEEDED":
      return BackgroundJobLogEntry_JobCompletionState.SUCCEEDED;
    case 2:
    case "FAILED":
      return BackgroundJobLogEntry_JobCompletionState.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackgroundJobLogEntry_JobCompletionState.UNRECOGNIZED;
  }
}

export function backgroundJobLogEntry_JobCompletionStateToJSON(
  object: BackgroundJobLogEntry_JobCompletionState,
): string {
  switch (object) {
    case BackgroundJobLogEntry_JobCompletionState.JOB_COMPLETION_STATE_UNSPECIFIED:
      return "JOB_COMPLETION_STATE_UNSPECIFIED";
    case BackgroundJobLogEntry_JobCompletionState.SUCCEEDED:
      return "SUCCEEDED";
    case BackgroundJobLogEntry_JobCompletionState.FAILED:
      return "FAILED";
    case BackgroundJobLogEntry_JobCompletionState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details regarding a Seed background job. */
export interface BackgroundJobLogEntry_SeedJobDetails {
  /** Output only. The connection profile which was used for the seed job. */
  connectionProfile: string;
}

/** Details regarding an Import Rules background job. */
export interface BackgroundJobLogEntry_ImportRulesJobDetails {
  /** Output only. File names used for the import rules job. */
  files: string[];
  /** Output only. The requested file format. */
  fileFormat: ImportRulesFileFormat;
}

/** Details regarding a Convert background job. */
export interface BackgroundJobLogEntry_ConvertJobDetails {
  /** Output only. AIP-160 based filter used to specify the entities to convert */
  filter: string;
}

/** Details regarding an Apply background job. */
export interface BackgroundJobLogEntry_ApplyJobDetails {
  /** Output only. The connection profile which was used for the apply job. */
  connectionProfile: string;
  /** Output only. AIP-160 based filter used to specify the entities to apply */
  filter: string;
}

/**
 * A filter defining the entities that a mapping rule should be applied to.
 * When more than one field is specified, the rule is applied only to
 * entities which match all the fields.
 */
export interface MappingRuleFilter {
  /**
   * Optional. The rule should be applied to entities whose parent entity
   * (fully qualified name) matches the given value.
   * For example, if the rule applies to a table entity, the expected value
   * should be a schema (schema). If the rule applies to a column or index
   * entity, the expected value can be either a schema (schema) or a table
   * (schema.table)
   */
  parentEntity: string;
  /**
   * Optional. The rule should be applied to entities whose non-qualified name
   * starts with the given prefix.
   */
  entityNamePrefix: string;
  /**
   * Optional. The rule should be applied to entities whose non-qualified name
   * ends with the given suffix.
   */
  entityNameSuffix: string;
  /**
   * Optional. The rule should be applied to entities whose non-qualified name
   * contains the given string.
   */
  entityNameContains: string;
  /**
   * Optional. The rule should be applied to specific entities defined by their
   * fully qualified names.
   */
  entities: string[];
}

/**
 * Definition of a transformation that is to be applied to a group of entities
 * in the source schema. Several such transformations can be applied to an
 * entity sequentially to define the corresponding entity in the target schema.
 */
export interface MappingRule {
  /**
   * Full name of the mapping rule resource, in the form of:
   * projects/{project}/locations/{location}/conversionWorkspaces/{set}/mappingRule/{rule}.
   */
  name: string;
  /** Optional. A human readable name */
  displayName: string;
  /** Optional. The mapping rule state */
  state: MappingRule_State;
  /** Required. The rule scope */
  ruleScope: DatabaseEntityType;
  /** Required. The rule filter */
  filter:
    | MappingRuleFilter
    | undefined;
  /**
   * Required. The order in which the rule is applied. Lower order rules are
   * applied before higher value rules so they may end up being overridden.
   */
  ruleOrder: Long;
  /**
   * Output only. The revision ID of the mapping rule.
   * A new revision is committed whenever the mapping rule is changed in any
   * way. The format is an 8-character hexadecimal string.
   */
  revisionId: string;
  /** Output only. The timestamp that the revision was created. */
  revisionCreateTime:
    | Date
    | undefined;
  /** Optional. Rule to specify how a single entity should be renamed. */
  singleEntityRename?:
    | SingleEntityRename
    | undefined;
  /** Optional. Rule to specify how multiple entities should be renamed. */
  multiEntityRename?:
    | MultiEntityRename
    | undefined;
  /**
   * Optional. Rule to specify how multiple entities should be relocated into
   * a different schema.
   */
  entityMove?:
    | EntityMove
    | undefined;
  /** Optional. Rule to specify how a single column is converted. */
  singleColumnChange?:
    | SingleColumnChange
    | undefined;
  /**
   * Optional. Rule to specify how multiple columns should be converted to a
   * different data type.
   */
  multiColumnDataTypeChange?:
    | MultiColumnDatatypeChange
    | undefined;
  /**
   * Optional. Rule to specify how the data contained in a column should be
   * transformed (such as trimmed, rounded, etc) provided that the data meets
   * certain criteria.
   */
  conditionalColumnSetValue?:
    | ConditionalColumnSetValue
    | undefined;
  /**
   * Optional. Rule to specify how multiple tables should be converted with an
   * additional rowid column.
   */
  convertRowidColumn?:
    | ConvertRowIdToColumn
    | undefined;
  /** Optional. Rule to specify the primary key for a table */
  setTablePrimaryKey?:
    | SetTablePrimaryKey
    | undefined;
  /** Optional. Rule to specify how a single package is converted. */
  singlePackageChange?:
    | SinglePackageChange
    | undefined;
  /**
   * Optional. Rule to change the sql code for an entity, for example,
   * function, procedure.
   */
  sourceSqlChange?:
    | SourceSqlChange
    | undefined;
  /**
   * Optional. Rule to specify the list of columns to include or exclude from
   * a table.
   */
  filterTableColumns?: FilterTableColumns | undefined;
}

/** The current mapping rule state such as enabled, disabled or deleted. */
export enum MappingRule_State {
  /** STATE_UNSPECIFIED - The state of the mapping rule is unknown. */
  STATE_UNSPECIFIED = 0,
  /** ENABLED - The rule is enabled. */
  ENABLED = 1,
  /** DISABLED - The rule is disabled. */
  DISABLED = 2,
  /** DELETED - The rule is logically deleted. */
  DELETED = 3,
  UNRECOGNIZED = -1,
}

export function mappingRule_StateFromJSON(object: any): MappingRule_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return MappingRule_State.STATE_UNSPECIFIED;
    case 1:
    case "ENABLED":
      return MappingRule_State.ENABLED;
    case 2:
    case "DISABLED":
      return MappingRule_State.DISABLED;
    case 3:
    case "DELETED":
      return MappingRule_State.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MappingRule_State.UNRECOGNIZED;
  }
}

export function mappingRule_StateToJSON(object: MappingRule_State): string {
  switch (object) {
    case MappingRule_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case MappingRule_State.ENABLED:
      return "ENABLED";
    case MappingRule_State.DISABLED:
      return "DISABLED";
    case MappingRule_State.DELETED:
      return "DELETED";
    case MappingRule_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Options to configure rule type SingleEntityRename.
 * The rule is used to rename an entity.
 *
 * The rule filter field can refer to only one entity.
 *
 * The rule scope can be one of: Database, Schema, Table, Column, Constraint,
 * Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT,
 * Synonym
 */
export interface SingleEntityRename {
  /** Required. The new name of the destination entity */
  newName: string;
}

/**
 * Options to configure rule type MultiEntityRename.
 * The rule is used to rename multiple entities.
 *
 * The rule filter field can refer to one or more entities.
 *
 * The rule scope can be one of: Database, Schema, Table, Column, Constraint,
 * Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT
 */
export interface MultiEntityRename {
  /**
   * Optional. The pattern used to generate the new entity's name. This pattern
   * must include the characters '{name}', which will be replaced with the name
   * of the original entity. For example, the pattern 't_{name}' for an entity
   * name jobs would be converted to 't_jobs'.
   *
   * If unspecified, the default value for this field is '{name}'
   */
  newNamePattern: string;
  /**
   * Optional. Additional transformation that can be done on the source entity
   * name before it is being used by the new_name_pattern, for example lower
   * case. If no transformation is desired, use NO_TRANSFORMATION
   */
  sourceNameTransformation: EntityNameTransformation;
}

/**
 * Options to configure rule type EntityMove.
 * The rule is used to move an entity to a new schema.
 *
 * The rule filter field can refer to one or more entities.
 *
 * The rule scope can be one of: Table, Column, Constraint, Index, View,
 * Function, Stored Procedure, Materialized View, Sequence, UDT
 */
export interface EntityMove {
  /** Required. The new schema */
  newSchema: string;
}

/**
 * Options to configure rule type SingleColumnChange.
 * The rule is used to change the properties of a column.
 *
 * The rule filter field can refer to one entity.
 *
 * The rule scope can be one of: Column.
 *
 * When using this rule, if a field is not specified than the destination
 * column's configuration will be the same as the one in the source column..
 */
export interface SingleColumnChange {
  /** Optional. Column data type name. */
  dataType: string;
  /** Optional. Charset override - instead of table level charset. */
  charset: string;
  /** Optional. Collation override - instead of table level collation. */
  collation: string;
  /** Optional. Column length - e.g. 50 as in varchar (50) - when relevant. */
  length: Long;
  /** Optional. Column precision - e.g. 8 as in double (8,2) - when relevant. */
  precision: number;
  /** Optional. Column scale - e.g. 2 as in double (8,2) - when relevant. */
  scale: number;
  /**
   * Optional. Column fractional seconds precision - e.g. 2 as in timestamp (2)
   * - when relevant.
   */
  fractionalSecondsPrecision: number;
  /** Optional. Is the column of array type. */
  array: boolean;
  /**
   * Optional. The length of the array, only relevant if the column type is an
   * array.
   */
  arrayLength: number;
  /** Optional. Is the column nullable. */
  nullable: boolean;
  /** Optional. Is the column auto-generated/identity. */
  autoGenerated: boolean;
  /** Optional. Is the column a UDT (User-defined Type). */
  udt: boolean;
  /** Optional. Custom engine specific features. */
  customFeatures:
    | { [key: string]: any }
    | undefined;
  /** Optional. Specifies the list of values allowed in the column. */
  setValues: string[];
  /** Optional. Comment associated with the column. */
  comment: string;
}

/**
 * Options to configure rule type MultiColumnDatatypeChange.
 * The rule is used to change the data type and associated properties of
 * multiple columns at once.
 *
 * The rule filter field can refer to one or more entities.
 *
 * The rule scope can be one of:Column.
 *
 * This rule requires additional filters to be specified beyond the basic rule
 * filter field, which is the source data type, but the rule supports additional
 * filtering capabilities such as the minimum and maximum field length. All
 * additional filters which are specified are required to be met in order for
 * the rule to be applied (logical AND between the fields).
 */
export interface MultiColumnDatatypeChange {
  /** Required. Filter on source data type. */
  sourceDataTypeFilter: string;
  /** Optional. Filter for text-based data types like varchar. */
  sourceTextFilter?:
    | SourceTextFilter
    | undefined;
  /**
   * Optional. Filter for fixed point number data types such as
   * NUMERIC/NUMBER.
   */
  sourceNumericFilter?:
    | SourceNumericFilter
    | undefined;
  /** Required. New data type. */
  newDataType: string;
  /**
   * Optional. Column length - e.g. varchar (50) - if not specified and relevant
   * uses the source column length.
   */
  overrideLength: Long;
  /**
   * Optional. Column scale - when relevant - if not specified and relevant
   * uses the source column scale.
   */
  overrideScale: number;
  /**
   * Optional. Column precision - when relevant - if not specified and relevant
   * uses the source column precision.
   */
  overridePrecision: number;
  /**
   * Optional. Column fractional seconds precision - used only for timestamp
   * based datatypes - if not specified and relevant uses the source column
   * fractional seconds precision.
   */
  overrideFractionalSecondsPrecision: number;
  /** Optional. Custom engine specific features. */
  customFeatures: { [key: string]: any } | undefined;
}

/** Filter for text-based data types like varchar. */
export interface SourceTextFilter {
  /**
   * Optional. The filter will match columns with length greater than or equal
   * to this number.
   */
  sourceMinLengthFilter: Long;
  /**
   * Optional. The filter will match columns with length smaller than or equal
   * to this number.
   */
  sourceMaxLengthFilter: Long;
}

/** Filter for fixed point number data types such as NUMERIC/NUMBER */
export interface SourceNumericFilter {
  /**
   * Optional. The filter will match columns with scale greater than or equal to
   * this number.
   */
  sourceMinScaleFilter: number;
  /**
   * Optional. The filter will match columns with scale smaller than or equal to
   * this number.
   */
  sourceMaxScaleFilter: number;
  /**
   * Optional. The filter will match columns with precision greater than or
   * equal to this number.
   */
  sourceMinPrecisionFilter: number;
  /**
   * Optional. The filter will match columns with precision smaller than or
   * equal to this number.
   */
  sourceMaxPrecisionFilter: number;
  /**
   * Required. Enum to set the option defining the datatypes numeric filter has
   * to be applied to
   */
  numericFilterOption: NumericFilterOption;
}

/**
 * Options to configure rule type ConditionalColumnSetValue.
 * The rule is used to transform the data which is being replicated/migrated.
 *
 * The rule filter field can refer to one or more entities.
 *
 * The rule scope can be one of: Column.
 */
export interface ConditionalColumnSetValue {
  /**
   * Optional. Optional filter on source column length. Used for text based
   * data types like varchar.
   */
  sourceTextFilter?:
    | SourceTextFilter
    | undefined;
  /**
   * Optional. Optional filter on source column precision and scale. Used for
   * fixed point numbers such as NUMERIC/NUMBER data types.
   */
  sourceNumericFilter?:
    | SourceNumericFilter
    | undefined;
  /** Required. Description of data transformation during migration. */
  valueTransformation:
    | ValueTransformation
    | undefined;
  /** Optional. Custom engine specific features. */
  customFeatures: { [key: string]: any } | undefined;
}

/**
 * Description of data transformation during migration as part of the
 * ConditionalColumnSetValue.
 */
export interface ValueTransformation {
  /** Optional. Value is null */
  isNull?:
    | Empty
    | undefined;
  /** Optional. Value is found in the specified list. */
  valueList?:
    | ValueListFilter
    | undefined;
  /**
   * Optional. Filter on relation between source value and compare value of
   * type integer.
   */
  intComparison?:
    | IntComparisonFilter
    | undefined;
  /**
   * Optional. Filter on relation between source value and compare value of
   * type double.
   */
  doubleComparison?:
    | DoubleComparisonFilter
    | undefined;
  /** Optional. Set to null */
  assignNull?:
    | Empty
    | undefined;
  /**
   * Optional. Set to a specific value (value is converted to fit the target
   * data type)
   */
  assignSpecificValue?:
    | AssignSpecificValue
    | undefined;
  /**
   * Optional. Set to min_value - if integer or numeric, will use
   * int.minvalue, etc
   */
  assignMinValue?:
    | Empty
    | undefined;
  /**
   * Optional. Set to max_value - if integer or numeric, will use
   * int.maxvalue, etc
   */
  assignMaxValue?:
    | Empty
    | undefined;
  /** Optional. Allows the data to change scale */
  roundScale?:
    | RoundToScale
    | undefined;
  /** Optional. Applies a hash function on the data */
  applyHash?: ApplyHash | undefined;
}

/**
 * Options to configure rule type ConvertROWIDToColumn.
 * The rule is used to add column rowid to destination tables based on an Oracle
 * rowid function/property.
 *
 * The rule filter field can refer to one or more entities.
 *
 * The rule scope can be one of: Table.
 *
 * This rule requires additional filter to be specified beyond the basic rule
 * filter field, which is whether or not to work on tables which already have a
 * primary key defined.
 */
export interface ConvertRowIdToColumn {
  /** Required. Only work on tables without primary key defined */
  onlyIfNoPrimaryKey: boolean;
}

/**
 * Options to configure rule type SetTablePrimaryKey.
 * The rule is used to specify the columns and name to configure/alter the
 * primary key of a table.
 *
 * The rule filter field can refer to one entity.
 *
 * The rule scope can be one of: Table.
 */
export interface SetTablePrimaryKey {
  /** Required. List of column names for the primary key */
  primaryKeyColumns: string[];
  /** Optional. Name for the primary key */
  primaryKey: string;
}

/**
 * Options to configure rule type SinglePackageChange.
 * The rule is used to alter the sql code for a package entities.
 *
 * The rule filter field can refer to one entity.
 *
 * The rule scope can be: Package
 */
export interface SinglePackageChange {
  /** Optional. Sql code for package description */
  packageDescription: string;
  /** Optional. Sql code for package body */
  packageBody: string;
}

/**
 * Options to configure rule type SourceSqlChange.
 * The rule is used to alter the sql code for database entities.
 *
 * The rule filter field can refer to one entity.
 *
 * The rule scope can be: StoredProcedure, Function, Trigger, View
 */
export interface SourceSqlChange {
  /** Required. Sql code for source (stored procedure, function, trigger or view) */
  sqlCode: string;
}

/**
 * Options to configure rule type FilterTableColumns.
 * The rule is used to filter the list of columns to include or exclude from a
 * table.
 *
 * The rule filter field can refer to one entity.
 *
 * The rule scope can be: Table
 *
 * Only one of the two lists can be specified for the rule.
 */
export interface FilterTableColumns {
  /** Optional. List of columns to be included for a particular table. */
  includeColumns: string[];
  /** Optional. List of columns to be excluded for a particular table. */
  excludeColumns: string[];
}

/** A list of values to filter by in ConditionalColumnSetValue */
export interface ValueListFilter {
  /**
   * Required. Indicates whether the filter matches rows with values that are
   * present in the list or those with values not present in it.
   */
  valuePresentList: ValuePresentInList;
  /** Required. The list to be used to filter by */
  values: string[];
  /**
   * Required. Whether to ignore case when filtering by values. Defaults to
   * false
   */
  ignoreCase: boolean;
}

/**
 * Filter based on relation between source value and compare value of type
 * integer in ConditionalColumnSetValue
 */
export interface IntComparisonFilter {
  /** Required. Relation between source value and compare value */
  valueComparison: ValueComparison;
  /** Required. Integer compare value to be used */
  value: Long;
}

/**
 * Filter based on relation between source
 * value and compare value of type double in ConditionalColumnSetValue
 */
export interface DoubleComparisonFilter {
  /** Required. Relation between source value and compare value */
  valueComparison: ValueComparison;
  /** Required. Double compare value to be used */
  value: number;
}

/** Set to a specific value (value is converted to fit the target data type) */
export interface AssignSpecificValue {
  /** Required. Specific value to be assigned */
  value: string;
}

/** Apply a hash function on the value. */
export interface ApplyHash {
  /** Optional. Generate UUID from the data's byte array */
  uuidFromBytes?: Empty | undefined;
}

/**
 * This allows the data to change scale, for example if the source is 2 digits
 * after the decimal point, specify round to scale value = 2. If for example the
 * value needs to be converted to an integer, use round to scale value = 0.
 */
export interface RoundToScale {
  /** Required. Scale value to be used */
  scale: number;
}

/**
 * The base entity type for all the database related entities.
 * The message contains the entity name, the name of its parent, the entity
 * type, and the specific details per entity type.
 */
export interface DatabaseEntity {
  /** The short name (e.g. table name) of the entity. */
  shortName: string;
  /** The full name of the parent entity (e.g. schema name). */
  parentEntity: string;
  /** The type of tree the entity belongs to. */
  tree: DatabaseEntity_TreeType;
  /** The type of the database entity (table, view, index, ...). */
  entityType: DatabaseEntityType;
  /**
   * Details about entity mappings.
   * For source tree entities, this holds the draft entities which were
   * generated by the mapping rules.
   * For draft tree entities, this holds the source entities which were
   * converted to form the draft entity.
   * Destination entities will have no mapping details.
   */
  mappings: EntityMapping[];
  /**
   * Details about the entity DDL script. Multiple DDL scripts are provided for
   * child entities such as a table entity will have one DDL for the table with
   * additional DDLs for each index, constraint and such.
   */
  entityDdl: EntityDdl[];
  /** Details about the various issues found for the entity. */
  issues: EntityIssue[];
  /** Database. */
  database?:
    | DatabaseInstanceEntity
    | undefined;
  /** Schema. */
  schema?:
    | SchemaEntity
    | undefined;
  /** Table. */
  table?:
    | TableEntity
    | undefined;
  /** View. */
  view?:
    | ViewEntity
    | undefined;
  /** Sequence. */
  sequence?:
    | SequenceEntity
    | undefined;
  /** Stored procedure. */
  storedProcedure?:
    | StoredProcedureEntity
    | undefined;
  /** Function. */
  databaseFunction?:
    | FunctionEntity
    | undefined;
  /** Synonym. */
  synonym?:
    | SynonymEntity
    | undefined;
  /** Package. */
  databasePackage?:
    | PackageEntity
    | undefined;
  /** UDT. */
  udt?:
    | UDTEntity
    | undefined;
  /** Materialized view. */
  materializedView?: MaterializedViewEntity | undefined;
}

/** The type of database entities tree. */
export enum DatabaseEntity_TreeType {
  /** TREE_TYPE_UNSPECIFIED - Tree type unspecified. */
  TREE_TYPE_UNSPECIFIED = 0,
  /** SOURCE - Tree of entities loaded from a source database. */
  SOURCE = 1,
  /** DRAFT - Tree of entities converted from the source tree using the mapping rules. */
  DRAFT = 2,
  /** DESTINATION - Tree of entities observed on the destination database. */
  DESTINATION = 3,
  UNRECOGNIZED = -1,
}

export function databaseEntity_TreeTypeFromJSON(object: any): DatabaseEntity_TreeType {
  switch (object) {
    case 0:
    case "TREE_TYPE_UNSPECIFIED":
      return DatabaseEntity_TreeType.TREE_TYPE_UNSPECIFIED;
    case 1:
    case "SOURCE":
      return DatabaseEntity_TreeType.SOURCE;
    case 2:
    case "DRAFT":
      return DatabaseEntity_TreeType.DRAFT;
    case 3:
    case "DESTINATION":
      return DatabaseEntity_TreeType.DESTINATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatabaseEntity_TreeType.UNRECOGNIZED;
  }
}

export function databaseEntity_TreeTypeToJSON(object: DatabaseEntity_TreeType): string {
  switch (object) {
    case DatabaseEntity_TreeType.TREE_TYPE_UNSPECIFIED:
      return "TREE_TYPE_UNSPECIFIED";
    case DatabaseEntity_TreeType.SOURCE:
      return "SOURCE";
    case DatabaseEntity_TreeType.DRAFT:
      return "DRAFT";
    case DatabaseEntity_TreeType.DESTINATION:
      return "DESTINATION";
    case DatabaseEntity_TreeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** DatabaseInstance acts as a parent entity to other database entities. */
export interface DatabaseInstanceEntity {
  /** Custom engine specific features. */
  customFeatures: { [key: string]: any } | undefined;
}

/**
 * Schema typically has no parent entity, but can have a parent entity
 * DatabaseInstance (for database engines which support it).  For some database
 * engines, the terms  schema and user can be used interchangeably when they
 * refer to a namespace or a collection of other database entities. Can store
 * additional information which is schema specific.
 */
export interface SchemaEntity {
  /** Custom engine specific features. */
  customFeatures: { [key: string]: any } | undefined;
}

/** Table's parent is a schema. */
export interface TableEntity {
  /** Table columns. */
  columns: ColumnEntity[];
  /** Table constraints. */
  constraints: ConstraintEntity[];
  /** Table indices. */
  indices: IndexEntity[];
  /** Table triggers. */
  triggers: TriggerEntity[];
  /** Custom engine specific features. */
  customFeatures:
    | { [key: string]: any }
    | undefined;
  /** Comment associated with the table. */
  comment: string;
}

/**
 * Column is not used as an independent entity, it is retrieved as part of a
 * Table entity.
 */
export interface ColumnEntity {
  /** Column name. */
  name: string;
  /** Column data type. */
  dataType: string;
  /** Charset override - instead of table level charset. */
  charset: string;
  /** Collation override - instead of table level collation. */
  collation: string;
  /** Column length - e.g. varchar (50). */
  length: Long;
  /** Column precision - when relevant. */
  precision: number;
  /** Column scale - when relevant. */
  scale: number;
  /** Column fractional second precision - used for timestamp based datatypes. */
  fractionalSecondsPrecision: number;
  /** Is the column of array type. */
  array: boolean;
  /** If the column is array, of which length. */
  arrayLength: number;
  /** Is the column nullable. */
  nullable: boolean;
  /** Is the column auto-generated/identity. */
  autoGenerated: boolean;
  /** Is the column a UDT. */
  udt: boolean;
  /** Custom engine specific features. */
  customFeatures:
    | { [key: string]: any }
    | undefined;
  /**
   * Specifies the list of values allowed in the column.
   * Only used for set data type.
   */
  setValues: string[];
  /** Comment associated with the column. */
  comment: string;
  /** Column order in the table. */
  ordinalPosition: number;
  /** Default value of the column. */
  defaultValue: string;
}

/**
 * Constraint is not used as an independent entity, it is retrieved
 * as part of another entity such as Table or View.
 */
export interface ConstraintEntity {
  /** The name of the table constraint. */
  name: string;
  /**
   * Type of constraint, for example unique, primary key, foreign key (currently
   * only primary key is supported).
   */
  type: string;
  /**
   * Table columns used as part of the Constraint, for example primary key
   * constraint should list the columns which constitutes the key.
   */
  tableColumns: string[];
  /** Custom engine specific features. */
  customFeatures:
    | { [key: string]: any }
    | undefined;
  /**
   * Reference columns which may be associated with the constraint. For example,
   * if the constraint is a FOREIGN_KEY, this represents the list of full names
   * of referenced columns by the foreign key.
   */
  referenceColumns: string[];
  /**
   * Reference table which may be associated with the constraint. For example,
   * if the constraint is a FOREIGN_KEY, this represents the list of full name
   * of the referenced table by the foreign key.
   */
  referenceTable: string;
  /**
   * Table which is associated with the constraint. In case the constraint
   * is defined on a table, this field is left empty as this information is
   * stored in parent_name. However, if constraint is defined on a view, this
   * field stores the table name on which the view is defined.
   */
  tableName: string;
}

/**
 * Index is not used as an independent entity, it is retrieved as part of a
 * Table entity.
 */
export interface IndexEntity {
  /** The name of the index. */
  name: string;
  /** Type of index, for example B-TREE. */
  type: string;
  /**
   * Table columns used as part of the Index, for example B-TREE index should
   * list the columns which constitutes the index.
   */
  tableColumns: string[];
  /** Boolean value indicating whether the index is unique. */
  unique: boolean;
  /** Custom engine specific features. */
  customFeatures: { [key: string]: any } | undefined;
}

/**
 * Trigger is not used as an independent entity, it is retrieved as part of a
 * Table entity.
 */
export interface TriggerEntity {
  /** The name of the trigger. */
  name: string;
  /**
   * The DML, DDL, or database events that fire the trigger, for example
   * INSERT, UPDATE.
   */
  triggeringEvents: string[];
  /**
   * Indicates when the trigger fires, for example BEFORE STATEMENT, AFTER EACH
   * ROW.
   */
  triggerType: string;
  /** The SQL code which creates the trigger. */
  sqlCode: string;
  /** Custom engine specific features. */
  customFeatures: { [key: string]: any } | undefined;
}

/** View's parent is a schema. */
export interface ViewEntity {
  /** The SQL code which creates the view. */
  sqlCode: string;
  /** Custom engine specific features. */
  customFeatures:
    | { [key: string]: any }
    | undefined;
  /** View constraints. */
  constraints: ConstraintEntity[];
}

/** Sequence's parent is a schema. */
export interface SequenceEntity {
  /** Increment value for the sequence. */
  increment: Long;
  /**
   * Start number for the sequence represented as bytes to accommodate large.
   * numbers
   */
  startValue: Buffer;
  /**
   * Maximum number for the sequence represented as bytes to accommodate large.
   * numbers
   */
  maxValue: Buffer;
  /**
   * Minimum number for the sequence represented as bytes to accommodate large.
   * numbers
   */
  minValue: Buffer;
  /** Indicates whether the sequence value should cycle through. */
  cycle: boolean;
  /** Indicates number of entries to cache / precreate. */
  cache: Long;
  /** Custom engine specific features. */
  customFeatures: { [key: string]: any } | undefined;
}

/** Stored procedure's parent is a schema. */
export interface StoredProcedureEntity {
  /** The SQL code which creates the stored procedure. */
  sqlCode: string;
  /** Custom engine specific features. */
  customFeatures: { [key: string]: any } | undefined;
}

/** Function's parent is a schema. */
export interface FunctionEntity {
  /** The SQL code which creates the function. */
  sqlCode: string;
  /** Custom engine specific features. */
  customFeatures: { [key: string]: any } | undefined;
}

/** MaterializedView's parent is a schema. */
export interface MaterializedViewEntity {
  /** The SQL code which creates the view. */
  sqlCode: string;
  /** Custom engine specific features. */
  customFeatures: { [key: string]: any } | undefined;
}

/** Synonym's parent is a schema. */
export interface SynonymEntity {
  /** The name of the entity for which the synonym is being created (the source). */
  sourceEntity: string;
  /**
   * The type of the entity for which the synonym is being created
   * (usually a table or a sequence).
   */
  sourceType: DatabaseEntityType;
  /** Custom engine specific features. */
  customFeatures: { [key: string]: any } | undefined;
}

/** Package's parent is a schema. */
export interface PackageEntity {
  /** The SQL code which creates the package. */
  packageSqlCode: string;
  /**
   * The SQL code which creates the package body. If the package specification
   * has cursors or subprograms, then the package body is mandatory.
   */
  packageBody: string;
  /** Custom engine specific features. */
  customFeatures: { [key: string]: any } | undefined;
}

/** UDT's parent is a schema. */
export interface UDTEntity {
  /** The SQL code which creates the udt. */
  udtSqlCode: string;
  /** The SQL code which creates the udt body. */
  udtBody: string;
  /** Custom engine specific features. */
  customFeatures: { [key: string]: any } | undefined;
}

/** Details of the mappings of a database entity. */
export interface EntityMapping {
  /**
   * Source entity full name.
   * The source entity can also be a column, index or constraint using the
   * same naming notation schema.table.column.
   */
  sourceEntity: string;
  /**
   * Target entity full name.
   * The draft entity can also include a column, index or constraint using the
   * same naming notation schema.table.column.
   */
  draftEntity: string;
  /** Type of source entity. */
  sourceType: DatabaseEntityType;
  /** Type of draft entity. */
  draftType: DatabaseEntityType;
  /**
   * Entity mapping log entries.
   * Multiple rules can be effective and contribute changes to a converted
   * entity, such as a rule can handle the entity name, another rule can handle
   * an entity type. In addition, rules which did not change the entity are also
   * logged along with the reason preventing them to do so.
   */
  mappingLog: EntityMappingLogEntry[];
}

/** A single record of a rule which was used for a mapping. */
export interface EntityMappingLogEntry {
  /** Which rule caused this log entry. */
  ruleId: string;
  /** Rule revision ID. */
  ruleRevisionId: string;
  /** Comment. */
  mappingComment: string;
}

/** A single DDL statement for a specific entity */
export interface EntityDdl {
  /** Type of DDL (Create, Alter). */
  ddlType: string;
  /** The name of the database entity the ddl refers to. */
  entity: string;
  /** The actual ddl code. */
  ddl: string;
  /** The entity type (if the DDL is for a sub entity). */
  entityType: DatabaseEntityType;
  /** EntityIssues found for this ddl. */
  issueId: string[];
}

/** Issue related to the entity. */
export interface EntityIssue {
  /** Unique Issue ID. */
  id: string;
  /** The type of the issue. */
  type: EntityIssue_IssueType;
  /** Severity of the issue */
  severity: EntityIssue_IssueSeverity;
  /** Issue detailed message */
  message: string;
  /** Error/Warning code */
  code: string;
  /** The ddl which caused the issue, if relevant. */
  ddl?:
    | string
    | undefined;
  /** The position of the issue found, if relevant. */
  position?:
    | EntityIssue_Position
    | undefined;
  /** The entity type (if the DDL is for a sub entity). */
  entityType: DatabaseEntityType;
}

/** Type of issue. */
export enum EntityIssue_IssueType {
  /** ISSUE_TYPE_UNSPECIFIED - Unspecified issue type. */
  ISSUE_TYPE_UNSPECIFIED = 0,
  /** ISSUE_TYPE_DDL - Issue originated from the DDL */
  ISSUE_TYPE_DDL = 1,
  /** ISSUE_TYPE_APPLY - Issue originated during the apply process */
  ISSUE_TYPE_APPLY = 2,
  /** ISSUE_TYPE_CONVERT - Issue originated during the convert process */
  ISSUE_TYPE_CONVERT = 3,
  UNRECOGNIZED = -1,
}

export function entityIssue_IssueTypeFromJSON(object: any): EntityIssue_IssueType {
  switch (object) {
    case 0:
    case "ISSUE_TYPE_UNSPECIFIED":
      return EntityIssue_IssueType.ISSUE_TYPE_UNSPECIFIED;
    case 1:
    case "ISSUE_TYPE_DDL":
      return EntityIssue_IssueType.ISSUE_TYPE_DDL;
    case 2:
    case "ISSUE_TYPE_APPLY":
      return EntityIssue_IssueType.ISSUE_TYPE_APPLY;
    case 3:
    case "ISSUE_TYPE_CONVERT":
      return EntityIssue_IssueType.ISSUE_TYPE_CONVERT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EntityIssue_IssueType.UNRECOGNIZED;
  }
}

export function entityIssue_IssueTypeToJSON(object: EntityIssue_IssueType): string {
  switch (object) {
    case EntityIssue_IssueType.ISSUE_TYPE_UNSPECIFIED:
      return "ISSUE_TYPE_UNSPECIFIED";
    case EntityIssue_IssueType.ISSUE_TYPE_DDL:
      return "ISSUE_TYPE_DDL";
    case EntityIssue_IssueType.ISSUE_TYPE_APPLY:
      return "ISSUE_TYPE_APPLY";
    case EntityIssue_IssueType.ISSUE_TYPE_CONVERT:
      return "ISSUE_TYPE_CONVERT";
    case EntityIssue_IssueType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Severity of issue. */
export enum EntityIssue_IssueSeverity {
  /** ISSUE_SEVERITY_UNSPECIFIED - Unspecified issue severity */
  ISSUE_SEVERITY_UNSPECIFIED = 0,
  /** ISSUE_SEVERITY_INFO - Info */
  ISSUE_SEVERITY_INFO = 1,
  /** ISSUE_SEVERITY_WARNING - Warning */
  ISSUE_SEVERITY_WARNING = 2,
  /** ISSUE_SEVERITY_ERROR - Error */
  ISSUE_SEVERITY_ERROR = 3,
  UNRECOGNIZED = -1,
}

export function entityIssue_IssueSeverityFromJSON(object: any): EntityIssue_IssueSeverity {
  switch (object) {
    case 0:
    case "ISSUE_SEVERITY_UNSPECIFIED":
      return EntityIssue_IssueSeverity.ISSUE_SEVERITY_UNSPECIFIED;
    case 1:
    case "ISSUE_SEVERITY_INFO":
      return EntityIssue_IssueSeverity.ISSUE_SEVERITY_INFO;
    case 2:
    case "ISSUE_SEVERITY_WARNING":
      return EntityIssue_IssueSeverity.ISSUE_SEVERITY_WARNING;
    case 3:
    case "ISSUE_SEVERITY_ERROR":
      return EntityIssue_IssueSeverity.ISSUE_SEVERITY_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EntityIssue_IssueSeverity.UNRECOGNIZED;
  }
}

export function entityIssue_IssueSeverityToJSON(object: EntityIssue_IssueSeverity): string {
  switch (object) {
    case EntityIssue_IssueSeverity.ISSUE_SEVERITY_UNSPECIFIED:
      return "ISSUE_SEVERITY_UNSPECIFIED";
    case EntityIssue_IssueSeverity.ISSUE_SEVERITY_INFO:
      return "ISSUE_SEVERITY_INFO";
    case EntityIssue_IssueSeverity.ISSUE_SEVERITY_WARNING:
      return "ISSUE_SEVERITY_WARNING";
    case EntityIssue_IssueSeverity.ISSUE_SEVERITY_ERROR:
      return "ISSUE_SEVERITY_ERROR";
    case EntityIssue_IssueSeverity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Issue position. */
export interface EntityIssue_Position {
  /** Issue line number */
  line: number;
  /** Issue column number */
  column: number;
  /** Issue offset */
  offset: number;
  /** Issue length */
  length: number;
}

function createBaseDatabaseEngineInfo(): DatabaseEngineInfo {
  return { engine: 0, version: "" };
}

export const DatabaseEngineInfo: MessageFns<DatabaseEngineInfo> = {
  encode(message: DatabaseEngineInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.engine !== 0) {
      writer.uint32(8).int32(message.engine);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseEngineInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseEngineInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.engine = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseEngineInfo {
    return {
      engine: isSet(object.engine) ? databaseEngineFromJSON(object.engine) : 0,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: DatabaseEngineInfo): unknown {
    const obj: any = {};
    if (message.engine !== 0) {
      obj.engine = databaseEngineToJSON(message.engine);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseEngineInfo>): DatabaseEngineInfo {
    return DatabaseEngineInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseEngineInfo>): DatabaseEngineInfo {
    const message = createBaseDatabaseEngineInfo();
    message.engine = object.engine ?? 0;
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseConversionWorkspace(): ConversionWorkspace {
  return {
    name: "",
    source: undefined,
    destination: undefined,
    globalSettings: {},
    hasUncommittedChanges: false,
    latestCommitId: "",
    latestCommitTime: undefined,
    createTime: undefined,
    updateTime: undefined,
    displayName: "",
  };
}

export const ConversionWorkspace: MessageFns<ConversionWorkspace> = {
  encode(message: ConversionWorkspace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.source !== undefined) {
      DatabaseEngineInfo.encode(message.source, writer.uint32(18).fork()).join();
    }
    if (message.destination !== undefined) {
      DatabaseEngineInfo.encode(message.destination, writer.uint32(26).fork()).join();
    }
    Object.entries(message.globalSettings).forEach(([key, value]) => {
      ConversionWorkspace_GlobalSettingsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.hasUncommittedChanges !== false) {
      writer.uint32(40).bool(message.hasUncommittedChanges);
    }
    if (message.latestCommitId !== "") {
      writer.uint32(50).string(message.latestCommitId);
    }
    if (message.latestCommitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.latestCommitTime), writer.uint32(58).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(90).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionWorkspace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionWorkspace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = DatabaseEngineInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destination = DatabaseEngineInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = ConversionWorkspace_GlobalSettingsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.globalSettings[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.hasUncommittedChanges = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.latestCommitId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.latestCommitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionWorkspace {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      source: isSet(object.source) ? DatabaseEngineInfo.fromJSON(object.source) : undefined,
      destination: isSet(object.destination) ? DatabaseEngineInfo.fromJSON(object.destination) : undefined,
      globalSettings: isObject(object.globalSettings)
        ? Object.entries(object.globalSettings).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      hasUncommittedChanges: isSet(object.hasUncommittedChanges)
        ? globalThis.Boolean(object.hasUncommittedChanges)
        : false,
      latestCommitId: isSet(object.latestCommitId) ? globalThis.String(object.latestCommitId) : "",
      latestCommitTime: isSet(object.latestCommitTime) ? fromJsonTimestamp(object.latestCommitTime) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: ConversionWorkspace): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.source !== undefined) {
      obj.source = DatabaseEngineInfo.toJSON(message.source);
    }
    if (message.destination !== undefined) {
      obj.destination = DatabaseEngineInfo.toJSON(message.destination);
    }
    if (message.globalSettings) {
      const entries = Object.entries(message.globalSettings);
      if (entries.length > 0) {
        obj.globalSettings = {};
        entries.forEach(([k, v]) => {
          obj.globalSettings[k] = v;
        });
      }
    }
    if (message.hasUncommittedChanges !== false) {
      obj.hasUncommittedChanges = message.hasUncommittedChanges;
    }
    if (message.latestCommitId !== "") {
      obj.latestCommitId = message.latestCommitId;
    }
    if (message.latestCommitTime !== undefined) {
      obj.latestCommitTime = message.latestCommitTime.toISOString();
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionWorkspace>): ConversionWorkspace {
    return ConversionWorkspace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversionWorkspace>): ConversionWorkspace {
    const message = createBaseConversionWorkspace();
    message.name = object.name ?? "";
    message.source = (object.source !== undefined && object.source !== null)
      ? DatabaseEngineInfo.fromPartial(object.source)
      : undefined;
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? DatabaseEngineInfo.fromPartial(object.destination)
      : undefined;
    message.globalSettings = Object.entries(object.globalSettings ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.hasUncommittedChanges = object.hasUncommittedChanges ?? false;
    message.latestCommitId = object.latestCommitId ?? "";
    message.latestCommitTime = object.latestCommitTime ?? undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseConversionWorkspace_GlobalSettingsEntry(): ConversionWorkspace_GlobalSettingsEntry {
  return { key: "", value: "" };
}

export const ConversionWorkspace_GlobalSettingsEntry: MessageFns<ConversionWorkspace_GlobalSettingsEntry> = {
  encode(message: ConversionWorkspace_GlobalSettingsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionWorkspace_GlobalSettingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionWorkspace_GlobalSettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionWorkspace_GlobalSettingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConversionWorkspace_GlobalSettingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionWorkspace_GlobalSettingsEntry>): ConversionWorkspace_GlobalSettingsEntry {
    return ConversionWorkspace_GlobalSettingsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversionWorkspace_GlobalSettingsEntry>): ConversionWorkspace_GlobalSettingsEntry {
    const message = createBaseConversionWorkspace_GlobalSettingsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBackgroundJobLogEntry(): BackgroundJobLogEntry {
  return {
    id: "",
    jobType: 0,
    startTime: undefined,
    finishTime: undefined,
    completionState: 0,
    completionComment: "",
    requestAutocommit: false,
    seedJobDetails: undefined,
    importRulesJobDetails: undefined,
    convertJobDetails: undefined,
    applyJobDetails: undefined,
  };
}

export const BackgroundJobLogEntry: MessageFns<BackgroundJobLogEntry> = {
  encode(message: BackgroundJobLogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.jobType !== 0) {
      writer.uint32(16).int32(message.jobType);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).join();
    }
    if (message.finishTime !== undefined) {
      Timestamp.encode(toTimestamp(message.finishTime), writer.uint32(34).fork()).join();
    }
    if (message.completionState !== 0) {
      writer.uint32(40).int32(message.completionState);
    }
    if (message.completionComment !== "") {
      writer.uint32(50).string(message.completionComment);
    }
    if (message.requestAutocommit !== false) {
      writer.uint32(56).bool(message.requestAutocommit);
    }
    if (message.seedJobDetails !== undefined) {
      BackgroundJobLogEntry_SeedJobDetails.encode(message.seedJobDetails, writer.uint32(802).fork()).join();
    }
    if (message.importRulesJobDetails !== undefined) {
      BackgroundJobLogEntry_ImportRulesJobDetails.encode(message.importRulesJobDetails, writer.uint32(810).fork())
        .join();
    }
    if (message.convertJobDetails !== undefined) {
      BackgroundJobLogEntry_ConvertJobDetails.encode(message.convertJobDetails, writer.uint32(818).fork()).join();
    }
    if (message.applyJobDetails !== undefined) {
      BackgroundJobLogEntry_ApplyJobDetails.encode(message.applyJobDetails, writer.uint32(826).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundJobLogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundJobLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.jobType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.finishTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.completionState = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.completionComment = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.requestAutocommit = reader.bool();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.seedJobDetails = BackgroundJobLogEntry_SeedJobDetails.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.importRulesJobDetails = BackgroundJobLogEntry_ImportRulesJobDetails.decode(reader, reader.uint32());
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.convertJobDetails = BackgroundJobLogEntry_ConvertJobDetails.decode(reader, reader.uint32());
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }

          message.applyJobDetails = BackgroundJobLogEntry_ApplyJobDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundJobLogEntry {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      jobType: isSet(object.jobType) ? backgroundJobTypeFromJSON(object.jobType) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      finishTime: isSet(object.finishTime) ? fromJsonTimestamp(object.finishTime) : undefined,
      completionState: isSet(object.completionState)
        ? backgroundJobLogEntry_JobCompletionStateFromJSON(object.completionState)
        : 0,
      completionComment: isSet(object.completionComment) ? globalThis.String(object.completionComment) : "",
      requestAutocommit: isSet(object.requestAutocommit) ? globalThis.Boolean(object.requestAutocommit) : false,
      seedJobDetails: isSet(object.seedJobDetails)
        ? BackgroundJobLogEntry_SeedJobDetails.fromJSON(object.seedJobDetails)
        : undefined,
      importRulesJobDetails: isSet(object.importRulesJobDetails)
        ? BackgroundJobLogEntry_ImportRulesJobDetails.fromJSON(object.importRulesJobDetails)
        : undefined,
      convertJobDetails: isSet(object.convertJobDetails)
        ? BackgroundJobLogEntry_ConvertJobDetails.fromJSON(object.convertJobDetails)
        : undefined,
      applyJobDetails: isSet(object.applyJobDetails)
        ? BackgroundJobLogEntry_ApplyJobDetails.fromJSON(object.applyJobDetails)
        : undefined,
    };
  },

  toJSON(message: BackgroundJobLogEntry): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.jobType !== 0) {
      obj.jobType = backgroundJobTypeToJSON(message.jobType);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.finishTime !== undefined) {
      obj.finishTime = message.finishTime.toISOString();
    }
    if (message.completionState !== 0) {
      obj.completionState = backgroundJobLogEntry_JobCompletionStateToJSON(message.completionState);
    }
    if (message.completionComment !== "") {
      obj.completionComment = message.completionComment;
    }
    if (message.requestAutocommit !== false) {
      obj.requestAutocommit = message.requestAutocommit;
    }
    if (message.seedJobDetails !== undefined) {
      obj.seedJobDetails = BackgroundJobLogEntry_SeedJobDetails.toJSON(message.seedJobDetails);
    }
    if (message.importRulesJobDetails !== undefined) {
      obj.importRulesJobDetails = BackgroundJobLogEntry_ImportRulesJobDetails.toJSON(message.importRulesJobDetails);
    }
    if (message.convertJobDetails !== undefined) {
      obj.convertJobDetails = BackgroundJobLogEntry_ConvertJobDetails.toJSON(message.convertJobDetails);
    }
    if (message.applyJobDetails !== undefined) {
      obj.applyJobDetails = BackgroundJobLogEntry_ApplyJobDetails.toJSON(message.applyJobDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<BackgroundJobLogEntry>): BackgroundJobLogEntry {
    return BackgroundJobLogEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackgroundJobLogEntry>): BackgroundJobLogEntry {
    const message = createBaseBackgroundJobLogEntry();
    message.id = object.id ?? "";
    message.jobType = object.jobType ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.finishTime = object.finishTime ?? undefined;
    message.completionState = object.completionState ?? 0;
    message.completionComment = object.completionComment ?? "";
    message.requestAutocommit = object.requestAutocommit ?? false;
    message.seedJobDetails = (object.seedJobDetails !== undefined && object.seedJobDetails !== null)
      ? BackgroundJobLogEntry_SeedJobDetails.fromPartial(object.seedJobDetails)
      : undefined;
    message.importRulesJobDetails =
      (object.importRulesJobDetails !== undefined && object.importRulesJobDetails !== null)
        ? BackgroundJobLogEntry_ImportRulesJobDetails.fromPartial(object.importRulesJobDetails)
        : undefined;
    message.convertJobDetails = (object.convertJobDetails !== undefined && object.convertJobDetails !== null)
      ? BackgroundJobLogEntry_ConvertJobDetails.fromPartial(object.convertJobDetails)
      : undefined;
    message.applyJobDetails = (object.applyJobDetails !== undefined && object.applyJobDetails !== null)
      ? BackgroundJobLogEntry_ApplyJobDetails.fromPartial(object.applyJobDetails)
      : undefined;
    return message;
  },
};

function createBaseBackgroundJobLogEntry_SeedJobDetails(): BackgroundJobLogEntry_SeedJobDetails {
  return { connectionProfile: "" };
}

export const BackgroundJobLogEntry_SeedJobDetails: MessageFns<BackgroundJobLogEntry_SeedJobDetails> = {
  encode(message: BackgroundJobLogEntry_SeedJobDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionProfile !== "") {
      writer.uint32(10).string(message.connectionProfile);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundJobLogEntry_SeedJobDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundJobLogEntry_SeedJobDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.connectionProfile = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundJobLogEntry_SeedJobDetails {
    return { connectionProfile: isSet(object.connectionProfile) ? globalThis.String(object.connectionProfile) : "" };
  },

  toJSON(message: BackgroundJobLogEntry_SeedJobDetails): unknown {
    const obj: any = {};
    if (message.connectionProfile !== "") {
      obj.connectionProfile = message.connectionProfile;
    }
    return obj;
  },

  create(base?: DeepPartial<BackgroundJobLogEntry_SeedJobDetails>): BackgroundJobLogEntry_SeedJobDetails {
    return BackgroundJobLogEntry_SeedJobDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackgroundJobLogEntry_SeedJobDetails>): BackgroundJobLogEntry_SeedJobDetails {
    const message = createBaseBackgroundJobLogEntry_SeedJobDetails();
    message.connectionProfile = object.connectionProfile ?? "";
    return message;
  },
};

function createBaseBackgroundJobLogEntry_ImportRulesJobDetails(): BackgroundJobLogEntry_ImportRulesJobDetails {
  return { files: [], fileFormat: 0 };
}

export const BackgroundJobLogEntry_ImportRulesJobDetails: MessageFns<BackgroundJobLogEntry_ImportRulesJobDetails> = {
  encode(
    message: BackgroundJobLogEntry_ImportRulesJobDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.files) {
      writer.uint32(10).string(v!);
    }
    if (message.fileFormat !== 0) {
      writer.uint32(16).int32(message.fileFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundJobLogEntry_ImportRulesJobDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundJobLogEntry_ImportRulesJobDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.files.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fileFormat = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundJobLogEntry_ImportRulesJobDetails {
    return {
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => globalThis.String(e)) : [],
      fileFormat: isSet(object.fileFormat) ? importRulesFileFormatFromJSON(object.fileFormat) : 0,
    };
  },

  toJSON(message: BackgroundJobLogEntry_ImportRulesJobDetails): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files;
    }
    if (message.fileFormat !== 0) {
      obj.fileFormat = importRulesFileFormatToJSON(message.fileFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<BackgroundJobLogEntry_ImportRulesJobDetails>): BackgroundJobLogEntry_ImportRulesJobDetails {
    return BackgroundJobLogEntry_ImportRulesJobDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BackgroundJobLogEntry_ImportRulesJobDetails>,
  ): BackgroundJobLogEntry_ImportRulesJobDetails {
    const message = createBaseBackgroundJobLogEntry_ImportRulesJobDetails();
    message.files = object.files?.map((e) => e) || [];
    message.fileFormat = object.fileFormat ?? 0;
    return message;
  },
};

function createBaseBackgroundJobLogEntry_ConvertJobDetails(): BackgroundJobLogEntry_ConvertJobDetails {
  return { filter: "" };
}

export const BackgroundJobLogEntry_ConvertJobDetails: MessageFns<BackgroundJobLogEntry_ConvertJobDetails> = {
  encode(message: BackgroundJobLogEntry_ConvertJobDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundJobLogEntry_ConvertJobDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundJobLogEntry_ConvertJobDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundJobLogEntry_ConvertJobDetails {
    return { filter: isSet(object.filter) ? globalThis.String(object.filter) : "" };
  },

  toJSON(message: BackgroundJobLogEntry_ConvertJobDetails): unknown {
    const obj: any = {};
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<BackgroundJobLogEntry_ConvertJobDetails>): BackgroundJobLogEntry_ConvertJobDetails {
    return BackgroundJobLogEntry_ConvertJobDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackgroundJobLogEntry_ConvertJobDetails>): BackgroundJobLogEntry_ConvertJobDetails {
    const message = createBaseBackgroundJobLogEntry_ConvertJobDetails();
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseBackgroundJobLogEntry_ApplyJobDetails(): BackgroundJobLogEntry_ApplyJobDetails {
  return { connectionProfile: "", filter: "" };
}

export const BackgroundJobLogEntry_ApplyJobDetails: MessageFns<BackgroundJobLogEntry_ApplyJobDetails> = {
  encode(message: BackgroundJobLogEntry_ApplyJobDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionProfile !== "") {
      writer.uint32(10).string(message.connectionProfile);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundJobLogEntry_ApplyJobDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundJobLogEntry_ApplyJobDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.connectionProfile = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundJobLogEntry_ApplyJobDetails {
    return {
      connectionProfile: isSet(object.connectionProfile) ? globalThis.String(object.connectionProfile) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: BackgroundJobLogEntry_ApplyJobDetails): unknown {
    const obj: any = {};
    if (message.connectionProfile !== "") {
      obj.connectionProfile = message.connectionProfile;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<BackgroundJobLogEntry_ApplyJobDetails>): BackgroundJobLogEntry_ApplyJobDetails {
    return BackgroundJobLogEntry_ApplyJobDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackgroundJobLogEntry_ApplyJobDetails>): BackgroundJobLogEntry_ApplyJobDetails {
    const message = createBaseBackgroundJobLogEntry_ApplyJobDetails();
    message.connectionProfile = object.connectionProfile ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseMappingRuleFilter(): MappingRuleFilter {
  return { parentEntity: "", entityNamePrefix: "", entityNameSuffix: "", entityNameContains: "", entities: [] };
}

export const MappingRuleFilter: MessageFns<MappingRuleFilter> = {
  encode(message: MappingRuleFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parentEntity !== "") {
      writer.uint32(10).string(message.parentEntity);
    }
    if (message.entityNamePrefix !== "") {
      writer.uint32(18).string(message.entityNamePrefix);
    }
    if (message.entityNameSuffix !== "") {
      writer.uint32(26).string(message.entityNameSuffix);
    }
    if (message.entityNameContains !== "") {
      writer.uint32(34).string(message.entityNameContains);
    }
    for (const v of message.entities) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MappingRuleFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMappingRuleFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parentEntity = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityNamePrefix = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entityNameSuffix = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.entityNameContains = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.entities.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MappingRuleFilter {
    return {
      parentEntity: isSet(object.parentEntity) ? globalThis.String(object.parentEntity) : "",
      entityNamePrefix: isSet(object.entityNamePrefix) ? globalThis.String(object.entityNamePrefix) : "",
      entityNameSuffix: isSet(object.entityNameSuffix) ? globalThis.String(object.entityNameSuffix) : "",
      entityNameContains: isSet(object.entityNameContains) ? globalThis.String(object.entityNameContains) : "",
      entities: globalThis.Array.isArray(object?.entities) ? object.entities.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MappingRuleFilter): unknown {
    const obj: any = {};
    if (message.parentEntity !== "") {
      obj.parentEntity = message.parentEntity;
    }
    if (message.entityNamePrefix !== "") {
      obj.entityNamePrefix = message.entityNamePrefix;
    }
    if (message.entityNameSuffix !== "") {
      obj.entityNameSuffix = message.entityNameSuffix;
    }
    if (message.entityNameContains !== "") {
      obj.entityNameContains = message.entityNameContains;
    }
    if (message.entities?.length) {
      obj.entities = message.entities;
    }
    return obj;
  },

  create(base?: DeepPartial<MappingRuleFilter>): MappingRuleFilter {
    return MappingRuleFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MappingRuleFilter>): MappingRuleFilter {
    const message = createBaseMappingRuleFilter();
    message.parentEntity = object.parentEntity ?? "";
    message.entityNamePrefix = object.entityNamePrefix ?? "";
    message.entityNameSuffix = object.entityNameSuffix ?? "";
    message.entityNameContains = object.entityNameContains ?? "";
    message.entities = object.entities?.map((e) => e) || [];
    return message;
  },
};

function createBaseMappingRule(): MappingRule {
  return {
    name: "",
    displayName: "",
    state: 0,
    ruleScope: 0,
    filter: undefined,
    ruleOrder: Long.ZERO,
    revisionId: "",
    revisionCreateTime: undefined,
    singleEntityRename: undefined,
    multiEntityRename: undefined,
    entityMove: undefined,
    singleColumnChange: undefined,
    multiColumnDataTypeChange: undefined,
    conditionalColumnSetValue: undefined,
    convertRowidColumn: undefined,
    setTablePrimaryKey: undefined,
    singlePackageChange: undefined,
    sourceSqlChange: undefined,
    filterTableColumns: undefined,
  };
}

export const MappingRule: MessageFns<MappingRule> = {
  encode(message: MappingRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.ruleScope !== 0) {
      writer.uint32(32).int32(message.ruleScope);
    }
    if (message.filter !== undefined) {
      MappingRuleFilter.encode(message.filter, writer.uint32(42).fork()).join();
    }
    if (!message.ruleOrder.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.ruleOrder.toString());
    }
    if (message.revisionId !== "") {
      writer.uint32(58).string(message.revisionId);
    }
    if (message.revisionCreateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionCreateTime), writer.uint32(66).fork()).join();
    }
    if (message.singleEntityRename !== undefined) {
      SingleEntityRename.encode(message.singleEntityRename, writer.uint32(818).fork()).join();
    }
    if (message.multiEntityRename !== undefined) {
      MultiEntityRename.encode(message.multiEntityRename, writer.uint32(826).fork()).join();
    }
    if (message.entityMove !== undefined) {
      EntityMove.encode(message.entityMove, writer.uint32(842).fork()).join();
    }
    if (message.singleColumnChange !== undefined) {
      SingleColumnChange.encode(message.singleColumnChange, writer.uint32(850).fork()).join();
    }
    if (message.multiColumnDataTypeChange !== undefined) {
      MultiColumnDatatypeChange.encode(message.multiColumnDataTypeChange, writer.uint32(858).fork()).join();
    }
    if (message.conditionalColumnSetValue !== undefined) {
      ConditionalColumnSetValue.encode(message.conditionalColumnSetValue, writer.uint32(866).fork()).join();
    }
    if (message.convertRowidColumn !== undefined) {
      ConvertRowIdToColumn.encode(message.convertRowidColumn, writer.uint32(914).fork()).join();
    }
    if (message.setTablePrimaryKey !== undefined) {
      SetTablePrimaryKey.encode(message.setTablePrimaryKey, writer.uint32(922).fork()).join();
    }
    if (message.singlePackageChange !== undefined) {
      SinglePackageChange.encode(message.singlePackageChange, writer.uint32(930).fork()).join();
    }
    if (message.sourceSqlChange !== undefined) {
      SourceSqlChange.encode(message.sourceSqlChange, writer.uint32(938).fork()).join();
    }
    if (message.filterTableColumns !== undefined) {
      FilterTableColumns.encode(message.filterTableColumns, writer.uint32(946).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MappingRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMappingRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ruleScope = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = MappingRuleFilter.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.ruleOrder = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.revisionCreateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.singleEntityRename = SingleEntityRename.decode(reader, reader.uint32());
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }

          message.multiEntityRename = MultiEntityRename.decode(reader, reader.uint32());
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }

          message.entityMove = EntityMove.decode(reader, reader.uint32());
          continue;
        case 106:
          if (tag !== 850) {
            break;
          }

          message.singleColumnChange = SingleColumnChange.decode(reader, reader.uint32());
          continue;
        case 107:
          if (tag !== 858) {
            break;
          }

          message.multiColumnDataTypeChange = MultiColumnDatatypeChange.decode(reader, reader.uint32());
          continue;
        case 108:
          if (tag !== 866) {
            break;
          }

          message.conditionalColumnSetValue = ConditionalColumnSetValue.decode(reader, reader.uint32());
          continue;
        case 114:
          if (tag !== 914) {
            break;
          }

          message.convertRowidColumn = ConvertRowIdToColumn.decode(reader, reader.uint32());
          continue;
        case 115:
          if (tag !== 922) {
            break;
          }

          message.setTablePrimaryKey = SetTablePrimaryKey.decode(reader, reader.uint32());
          continue;
        case 116:
          if (tag !== 930) {
            break;
          }

          message.singlePackageChange = SinglePackageChange.decode(reader, reader.uint32());
          continue;
        case 117:
          if (tag !== 938) {
            break;
          }

          message.sourceSqlChange = SourceSqlChange.decode(reader, reader.uint32());
          continue;
        case 118:
          if (tag !== 946) {
            break;
          }

          message.filterTableColumns = FilterTableColumns.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MappingRule {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      state: isSet(object.state) ? mappingRule_StateFromJSON(object.state) : 0,
      ruleScope: isSet(object.ruleScope) ? databaseEntityTypeFromJSON(object.ruleScope) : 0,
      filter: isSet(object.filter) ? MappingRuleFilter.fromJSON(object.filter) : undefined,
      ruleOrder: isSet(object.ruleOrder) ? Long.fromValue(object.ruleOrder) : Long.ZERO,
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
      revisionCreateTime: isSet(object.revisionCreateTime) ? fromJsonTimestamp(object.revisionCreateTime) : undefined,
      singleEntityRename: isSet(object.singleEntityRename)
        ? SingleEntityRename.fromJSON(object.singleEntityRename)
        : undefined,
      multiEntityRename: isSet(object.multiEntityRename)
        ? MultiEntityRename.fromJSON(object.multiEntityRename)
        : undefined,
      entityMove: isSet(object.entityMove) ? EntityMove.fromJSON(object.entityMove) : undefined,
      singleColumnChange: isSet(object.singleColumnChange)
        ? SingleColumnChange.fromJSON(object.singleColumnChange)
        : undefined,
      multiColumnDataTypeChange: isSet(object.multiColumnDataTypeChange)
        ? MultiColumnDatatypeChange.fromJSON(object.multiColumnDataTypeChange)
        : undefined,
      conditionalColumnSetValue: isSet(object.conditionalColumnSetValue)
        ? ConditionalColumnSetValue.fromJSON(object.conditionalColumnSetValue)
        : undefined,
      convertRowidColumn: isSet(object.convertRowidColumn)
        ? ConvertRowIdToColumn.fromJSON(object.convertRowidColumn)
        : undefined,
      setTablePrimaryKey: isSet(object.setTablePrimaryKey)
        ? SetTablePrimaryKey.fromJSON(object.setTablePrimaryKey)
        : undefined,
      singlePackageChange: isSet(object.singlePackageChange)
        ? SinglePackageChange.fromJSON(object.singlePackageChange)
        : undefined,
      sourceSqlChange: isSet(object.sourceSqlChange) ? SourceSqlChange.fromJSON(object.sourceSqlChange) : undefined,
      filterTableColumns: isSet(object.filterTableColumns)
        ? FilterTableColumns.fromJSON(object.filterTableColumns)
        : undefined,
    };
  },

  toJSON(message: MappingRule): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.state !== 0) {
      obj.state = mappingRule_StateToJSON(message.state);
    }
    if (message.ruleScope !== 0) {
      obj.ruleScope = databaseEntityTypeToJSON(message.ruleScope);
    }
    if (message.filter !== undefined) {
      obj.filter = MappingRuleFilter.toJSON(message.filter);
    }
    if (!message.ruleOrder.equals(Long.ZERO)) {
      obj.ruleOrder = (message.ruleOrder || Long.ZERO).toString();
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.revisionCreateTime !== undefined) {
      obj.revisionCreateTime = message.revisionCreateTime.toISOString();
    }
    if (message.singleEntityRename !== undefined) {
      obj.singleEntityRename = SingleEntityRename.toJSON(message.singleEntityRename);
    }
    if (message.multiEntityRename !== undefined) {
      obj.multiEntityRename = MultiEntityRename.toJSON(message.multiEntityRename);
    }
    if (message.entityMove !== undefined) {
      obj.entityMove = EntityMove.toJSON(message.entityMove);
    }
    if (message.singleColumnChange !== undefined) {
      obj.singleColumnChange = SingleColumnChange.toJSON(message.singleColumnChange);
    }
    if (message.multiColumnDataTypeChange !== undefined) {
      obj.multiColumnDataTypeChange = MultiColumnDatatypeChange.toJSON(message.multiColumnDataTypeChange);
    }
    if (message.conditionalColumnSetValue !== undefined) {
      obj.conditionalColumnSetValue = ConditionalColumnSetValue.toJSON(message.conditionalColumnSetValue);
    }
    if (message.convertRowidColumn !== undefined) {
      obj.convertRowidColumn = ConvertRowIdToColumn.toJSON(message.convertRowidColumn);
    }
    if (message.setTablePrimaryKey !== undefined) {
      obj.setTablePrimaryKey = SetTablePrimaryKey.toJSON(message.setTablePrimaryKey);
    }
    if (message.singlePackageChange !== undefined) {
      obj.singlePackageChange = SinglePackageChange.toJSON(message.singlePackageChange);
    }
    if (message.sourceSqlChange !== undefined) {
      obj.sourceSqlChange = SourceSqlChange.toJSON(message.sourceSqlChange);
    }
    if (message.filterTableColumns !== undefined) {
      obj.filterTableColumns = FilterTableColumns.toJSON(message.filterTableColumns);
    }
    return obj;
  },

  create(base?: DeepPartial<MappingRule>): MappingRule {
    return MappingRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MappingRule>): MappingRule {
    const message = createBaseMappingRule();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.state = object.state ?? 0;
    message.ruleScope = object.ruleScope ?? 0;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? MappingRuleFilter.fromPartial(object.filter)
      : undefined;
    message.ruleOrder = (object.ruleOrder !== undefined && object.ruleOrder !== null)
      ? Long.fromValue(object.ruleOrder)
      : Long.ZERO;
    message.revisionId = object.revisionId ?? "";
    message.revisionCreateTime = object.revisionCreateTime ?? undefined;
    message.singleEntityRename = (object.singleEntityRename !== undefined && object.singleEntityRename !== null)
      ? SingleEntityRename.fromPartial(object.singleEntityRename)
      : undefined;
    message.multiEntityRename = (object.multiEntityRename !== undefined && object.multiEntityRename !== null)
      ? MultiEntityRename.fromPartial(object.multiEntityRename)
      : undefined;
    message.entityMove = (object.entityMove !== undefined && object.entityMove !== null)
      ? EntityMove.fromPartial(object.entityMove)
      : undefined;
    message.singleColumnChange = (object.singleColumnChange !== undefined && object.singleColumnChange !== null)
      ? SingleColumnChange.fromPartial(object.singleColumnChange)
      : undefined;
    message.multiColumnDataTypeChange =
      (object.multiColumnDataTypeChange !== undefined && object.multiColumnDataTypeChange !== null)
        ? MultiColumnDatatypeChange.fromPartial(object.multiColumnDataTypeChange)
        : undefined;
    message.conditionalColumnSetValue =
      (object.conditionalColumnSetValue !== undefined && object.conditionalColumnSetValue !== null)
        ? ConditionalColumnSetValue.fromPartial(object.conditionalColumnSetValue)
        : undefined;
    message.convertRowidColumn = (object.convertRowidColumn !== undefined && object.convertRowidColumn !== null)
      ? ConvertRowIdToColumn.fromPartial(object.convertRowidColumn)
      : undefined;
    message.setTablePrimaryKey = (object.setTablePrimaryKey !== undefined && object.setTablePrimaryKey !== null)
      ? SetTablePrimaryKey.fromPartial(object.setTablePrimaryKey)
      : undefined;
    message.singlePackageChange = (object.singlePackageChange !== undefined && object.singlePackageChange !== null)
      ? SinglePackageChange.fromPartial(object.singlePackageChange)
      : undefined;
    message.sourceSqlChange = (object.sourceSqlChange !== undefined && object.sourceSqlChange !== null)
      ? SourceSqlChange.fromPartial(object.sourceSqlChange)
      : undefined;
    message.filterTableColumns = (object.filterTableColumns !== undefined && object.filterTableColumns !== null)
      ? FilterTableColumns.fromPartial(object.filterTableColumns)
      : undefined;
    return message;
  },
};

function createBaseSingleEntityRename(): SingleEntityRename {
  return { newName: "" };
}

export const SingleEntityRename: MessageFns<SingleEntityRename> = {
  encode(message: SingleEntityRename, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newName !== "") {
      writer.uint32(10).string(message.newName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleEntityRename {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleEntityRename();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.newName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleEntityRename {
    return { newName: isSet(object.newName) ? globalThis.String(object.newName) : "" };
  },

  toJSON(message: SingleEntityRename): unknown {
    const obj: any = {};
    if (message.newName !== "") {
      obj.newName = message.newName;
    }
    return obj;
  },

  create(base?: DeepPartial<SingleEntityRename>): SingleEntityRename {
    return SingleEntityRename.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SingleEntityRename>): SingleEntityRename {
    const message = createBaseSingleEntityRename();
    message.newName = object.newName ?? "";
    return message;
  },
};

function createBaseMultiEntityRename(): MultiEntityRename {
  return { newNamePattern: "", sourceNameTransformation: 0 };
}

export const MultiEntityRename: MessageFns<MultiEntityRename> = {
  encode(message: MultiEntityRename, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newNamePattern !== "") {
      writer.uint32(10).string(message.newNamePattern);
    }
    if (message.sourceNameTransformation !== 0) {
      writer.uint32(16).int32(message.sourceNameTransformation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiEntityRename {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiEntityRename();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.newNamePattern = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sourceNameTransformation = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiEntityRename {
    return {
      newNamePattern: isSet(object.newNamePattern) ? globalThis.String(object.newNamePattern) : "",
      sourceNameTransformation: isSet(object.sourceNameTransformation)
        ? entityNameTransformationFromJSON(object.sourceNameTransformation)
        : 0,
    };
  },

  toJSON(message: MultiEntityRename): unknown {
    const obj: any = {};
    if (message.newNamePattern !== "") {
      obj.newNamePattern = message.newNamePattern;
    }
    if (message.sourceNameTransformation !== 0) {
      obj.sourceNameTransformation = entityNameTransformationToJSON(message.sourceNameTransformation);
    }
    return obj;
  },

  create(base?: DeepPartial<MultiEntityRename>): MultiEntityRename {
    return MultiEntityRename.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultiEntityRename>): MultiEntityRename {
    const message = createBaseMultiEntityRename();
    message.newNamePattern = object.newNamePattern ?? "";
    message.sourceNameTransformation = object.sourceNameTransformation ?? 0;
    return message;
  },
};

function createBaseEntityMove(): EntityMove {
  return { newSchema: "" };
}

export const EntityMove: MessageFns<EntityMove> = {
  encode(message: EntityMove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newSchema !== "") {
      writer.uint32(10).string(message.newSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityMove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.newSchema = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityMove {
    return { newSchema: isSet(object.newSchema) ? globalThis.String(object.newSchema) : "" };
  },

  toJSON(message: EntityMove): unknown {
    const obj: any = {};
    if (message.newSchema !== "") {
      obj.newSchema = message.newSchema;
    }
    return obj;
  },

  create(base?: DeepPartial<EntityMove>): EntityMove {
    return EntityMove.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityMove>): EntityMove {
    const message = createBaseEntityMove();
    message.newSchema = object.newSchema ?? "";
    return message;
  },
};

function createBaseSingleColumnChange(): SingleColumnChange {
  return {
    dataType: "",
    charset: "",
    collation: "",
    length: Long.ZERO,
    precision: 0,
    scale: 0,
    fractionalSecondsPrecision: 0,
    array: false,
    arrayLength: 0,
    nullable: false,
    autoGenerated: false,
    udt: false,
    customFeatures: undefined,
    setValues: [],
    comment: "",
  };
}

export const SingleColumnChange: MessageFns<SingleColumnChange> = {
  encode(message: SingleColumnChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataType !== "") {
      writer.uint32(10).string(message.dataType);
    }
    if (message.charset !== "") {
      writer.uint32(18).string(message.charset);
    }
    if (message.collation !== "") {
      writer.uint32(26).string(message.collation);
    }
    if (!message.length.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.length.toString());
    }
    if (message.precision !== 0) {
      writer.uint32(40).int32(message.precision);
    }
    if (message.scale !== 0) {
      writer.uint32(48).int32(message.scale);
    }
    if (message.fractionalSecondsPrecision !== 0) {
      writer.uint32(56).int32(message.fractionalSecondsPrecision);
    }
    if (message.array !== false) {
      writer.uint32(64).bool(message.array);
    }
    if (message.arrayLength !== 0) {
      writer.uint32(72).int32(message.arrayLength);
    }
    if (message.nullable !== false) {
      writer.uint32(80).bool(message.nullable);
    }
    if (message.autoGenerated !== false) {
      writer.uint32(88).bool(message.autoGenerated);
    }
    if (message.udt !== false) {
      writer.uint32(96).bool(message.udt);
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(106).fork()).join();
    }
    for (const v of message.setValues) {
      writer.uint32(114).string(v!);
    }
    if (message.comment !== "") {
      writer.uint32(122).string(message.comment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SingleColumnChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSingleColumnChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.charset = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.collation = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.length = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.precision = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.scale = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.fractionalSecondsPrecision = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.array = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.arrayLength = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.autoGenerated = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.udt = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.setValues.push(reader.string());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SingleColumnChange {
    return {
      dataType: isSet(object.dataType) ? globalThis.String(object.dataType) : "",
      charset: isSet(object.charset) ? globalThis.String(object.charset) : "",
      collation: isSet(object.collation) ? globalThis.String(object.collation) : "",
      length: isSet(object.length) ? Long.fromValue(object.length) : Long.ZERO,
      precision: isSet(object.precision) ? globalThis.Number(object.precision) : 0,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
      fractionalSecondsPrecision: isSet(object.fractionalSecondsPrecision)
        ? globalThis.Number(object.fractionalSecondsPrecision)
        : 0,
      array: isSet(object.array) ? globalThis.Boolean(object.array) : false,
      arrayLength: isSet(object.arrayLength) ? globalThis.Number(object.arrayLength) : 0,
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      autoGenerated: isSet(object.autoGenerated) ? globalThis.Boolean(object.autoGenerated) : false,
      udt: isSet(object.udt) ? globalThis.Boolean(object.udt) : false,
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
      setValues: globalThis.Array.isArray(object?.setValues)
        ? object.setValues.map((e: any) => globalThis.String(e))
        : [],
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: SingleColumnChange): unknown {
    const obj: any = {};
    if (message.dataType !== "") {
      obj.dataType = message.dataType;
    }
    if (message.charset !== "") {
      obj.charset = message.charset;
    }
    if (message.collation !== "") {
      obj.collation = message.collation;
    }
    if (!message.length.equals(Long.ZERO)) {
      obj.length = (message.length || Long.ZERO).toString();
    }
    if (message.precision !== 0) {
      obj.precision = Math.round(message.precision);
    }
    if (message.scale !== 0) {
      obj.scale = Math.round(message.scale);
    }
    if (message.fractionalSecondsPrecision !== 0) {
      obj.fractionalSecondsPrecision = Math.round(message.fractionalSecondsPrecision);
    }
    if (message.array !== false) {
      obj.array = message.array;
    }
    if (message.arrayLength !== 0) {
      obj.arrayLength = Math.round(message.arrayLength);
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.autoGenerated !== false) {
      obj.autoGenerated = message.autoGenerated;
    }
    if (message.udt !== false) {
      obj.udt = message.udt;
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    if (message.setValues?.length) {
      obj.setValues = message.setValues;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create(base?: DeepPartial<SingleColumnChange>): SingleColumnChange {
    return SingleColumnChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SingleColumnChange>): SingleColumnChange {
    const message = createBaseSingleColumnChange();
    message.dataType = object.dataType ?? "";
    message.charset = object.charset ?? "";
    message.collation = object.collation ?? "";
    message.length = (object.length !== undefined && object.length !== null)
      ? Long.fromValue(object.length)
      : Long.ZERO;
    message.precision = object.precision ?? 0;
    message.scale = object.scale ?? 0;
    message.fractionalSecondsPrecision = object.fractionalSecondsPrecision ?? 0;
    message.array = object.array ?? false;
    message.arrayLength = object.arrayLength ?? 0;
    message.nullable = object.nullable ?? false;
    message.autoGenerated = object.autoGenerated ?? false;
    message.udt = object.udt ?? false;
    message.customFeatures = object.customFeatures ?? undefined;
    message.setValues = object.setValues?.map((e) => e) || [];
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseMultiColumnDatatypeChange(): MultiColumnDatatypeChange {
  return {
    sourceDataTypeFilter: "",
    sourceTextFilter: undefined,
    sourceNumericFilter: undefined,
    newDataType: "",
    overrideLength: Long.ZERO,
    overrideScale: 0,
    overridePrecision: 0,
    overrideFractionalSecondsPrecision: 0,
    customFeatures: undefined,
  };
}

export const MultiColumnDatatypeChange: MessageFns<MultiColumnDatatypeChange> = {
  encode(message: MultiColumnDatatypeChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceDataTypeFilter !== "") {
      writer.uint32(10).string(message.sourceDataTypeFilter);
    }
    if (message.sourceTextFilter !== undefined) {
      SourceTextFilter.encode(message.sourceTextFilter, writer.uint32(802).fork()).join();
    }
    if (message.sourceNumericFilter !== undefined) {
      SourceNumericFilter.encode(message.sourceNumericFilter, writer.uint32(810).fork()).join();
    }
    if (message.newDataType !== "") {
      writer.uint32(18).string(message.newDataType);
    }
    if (!message.overrideLength.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.overrideLength.toString());
    }
    if (message.overrideScale !== 0) {
      writer.uint32(32).int32(message.overrideScale);
    }
    if (message.overridePrecision !== 0) {
      writer.uint32(40).int32(message.overridePrecision);
    }
    if (message.overrideFractionalSecondsPrecision !== 0) {
      writer.uint32(48).int32(message.overrideFractionalSecondsPrecision);
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiColumnDatatypeChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiColumnDatatypeChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceDataTypeFilter = reader.string();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.sourceTextFilter = SourceTextFilter.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.sourceNumericFilter = SourceNumericFilter.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newDataType = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.overrideLength = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.overrideScale = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.overridePrecision = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.overrideFractionalSecondsPrecision = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiColumnDatatypeChange {
    return {
      sourceDataTypeFilter: isSet(object.sourceDataTypeFilter) ? globalThis.String(object.sourceDataTypeFilter) : "",
      sourceTextFilter: isSet(object.sourceTextFilter) ? SourceTextFilter.fromJSON(object.sourceTextFilter) : undefined,
      sourceNumericFilter: isSet(object.sourceNumericFilter)
        ? SourceNumericFilter.fromJSON(object.sourceNumericFilter)
        : undefined,
      newDataType: isSet(object.newDataType) ? globalThis.String(object.newDataType) : "",
      overrideLength: isSet(object.overrideLength) ? Long.fromValue(object.overrideLength) : Long.ZERO,
      overrideScale: isSet(object.overrideScale) ? globalThis.Number(object.overrideScale) : 0,
      overridePrecision: isSet(object.overridePrecision) ? globalThis.Number(object.overridePrecision) : 0,
      overrideFractionalSecondsPrecision: isSet(object.overrideFractionalSecondsPrecision)
        ? globalThis.Number(object.overrideFractionalSecondsPrecision)
        : 0,
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
    };
  },

  toJSON(message: MultiColumnDatatypeChange): unknown {
    const obj: any = {};
    if (message.sourceDataTypeFilter !== "") {
      obj.sourceDataTypeFilter = message.sourceDataTypeFilter;
    }
    if (message.sourceTextFilter !== undefined) {
      obj.sourceTextFilter = SourceTextFilter.toJSON(message.sourceTextFilter);
    }
    if (message.sourceNumericFilter !== undefined) {
      obj.sourceNumericFilter = SourceNumericFilter.toJSON(message.sourceNumericFilter);
    }
    if (message.newDataType !== "") {
      obj.newDataType = message.newDataType;
    }
    if (!message.overrideLength.equals(Long.ZERO)) {
      obj.overrideLength = (message.overrideLength || Long.ZERO).toString();
    }
    if (message.overrideScale !== 0) {
      obj.overrideScale = Math.round(message.overrideScale);
    }
    if (message.overridePrecision !== 0) {
      obj.overridePrecision = Math.round(message.overridePrecision);
    }
    if (message.overrideFractionalSecondsPrecision !== 0) {
      obj.overrideFractionalSecondsPrecision = Math.round(message.overrideFractionalSecondsPrecision);
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    return obj;
  },

  create(base?: DeepPartial<MultiColumnDatatypeChange>): MultiColumnDatatypeChange {
    return MultiColumnDatatypeChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultiColumnDatatypeChange>): MultiColumnDatatypeChange {
    const message = createBaseMultiColumnDatatypeChange();
    message.sourceDataTypeFilter = object.sourceDataTypeFilter ?? "";
    message.sourceTextFilter = (object.sourceTextFilter !== undefined && object.sourceTextFilter !== null)
      ? SourceTextFilter.fromPartial(object.sourceTextFilter)
      : undefined;
    message.sourceNumericFilter = (object.sourceNumericFilter !== undefined && object.sourceNumericFilter !== null)
      ? SourceNumericFilter.fromPartial(object.sourceNumericFilter)
      : undefined;
    message.newDataType = object.newDataType ?? "";
    message.overrideLength = (object.overrideLength !== undefined && object.overrideLength !== null)
      ? Long.fromValue(object.overrideLength)
      : Long.ZERO;
    message.overrideScale = object.overrideScale ?? 0;
    message.overridePrecision = object.overridePrecision ?? 0;
    message.overrideFractionalSecondsPrecision = object.overrideFractionalSecondsPrecision ?? 0;
    message.customFeatures = object.customFeatures ?? undefined;
    return message;
  },
};

function createBaseSourceTextFilter(): SourceTextFilter {
  return { sourceMinLengthFilter: Long.ZERO, sourceMaxLengthFilter: Long.ZERO };
}

export const SourceTextFilter: MessageFns<SourceTextFilter> = {
  encode(message: SourceTextFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.sourceMinLengthFilter.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.sourceMinLengthFilter.toString());
    }
    if (!message.sourceMaxLengthFilter.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.sourceMaxLengthFilter.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceTextFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceTextFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourceMinLengthFilter = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sourceMaxLengthFilter = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceTextFilter {
    return {
      sourceMinLengthFilter: isSet(object.sourceMinLengthFilter)
        ? Long.fromValue(object.sourceMinLengthFilter)
        : Long.ZERO,
      sourceMaxLengthFilter: isSet(object.sourceMaxLengthFilter)
        ? Long.fromValue(object.sourceMaxLengthFilter)
        : Long.ZERO,
    };
  },

  toJSON(message: SourceTextFilter): unknown {
    const obj: any = {};
    if (!message.sourceMinLengthFilter.equals(Long.ZERO)) {
      obj.sourceMinLengthFilter = (message.sourceMinLengthFilter || Long.ZERO).toString();
    }
    if (!message.sourceMaxLengthFilter.equals(Long.ZERO)) {
      obj.sourceMaxLengthFilter = (message.sourceMaxLengthFilter || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SourceTextFilter>): SourceTextFilter {
    return SourceTextFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceTextFilter>): SourceTextFilter {
    const message = createBaseSourceTextFilter();
    message.sourceMinLengthFilter =
      (object.sourceMinLengthFilter !== undefined && object.sourceMinLengthFilter !== null)
        ? Long.fromValue(object.sourceMinLengthFilter)
        : Long.ZERO;
    message.sourceMaxLengthFilter =
      (object.sourceMaxLengthFilter !== undefined && object.sourceMaxLengthFilter !== null)
        ? Long.fromValue(object.sourceMaxLengthFilter)
        : Long.ZERO;
    return message;
  },
};

function createBaseSourceNumericFilter(): SourceNumericFilter {
  return {
    sourceMinScaleFilter: 0,
    sourceMaxScaleFilter: 0,
    sourceMinPrecisionFilter: 0,
    sourceMaxPrecisionFilter: 0,
    numericFilterOption: 0,
  };
}

export const SourceNumericFilter: MessageFns<SourceNumericFilter> = {
  encode(message: SourceNumericFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceMinScaleFilter !== 0) {
      writer.uint32(8).int32(message.sourceMinScaleFilter);
    }
    if (message.sourceMaxScaleFilter !== 0) {
      writer.uint32(16).int32(message.sourceMaxScaleFilter);
    }
    if (message.sourceMinPrecisionFilter !== 0) {
      writer.uint32(24).int32(message.sourceMinPrecisionFilter);
    }
    if (message.sourceMaxPrecisionFilter !== 0) {
      writer.uint32(32).int32(message.sourceMaxPrecisionFilter);
    }
    if (message.numericFilterOption !== 0) {
      writer.uint32(40).int32(message.numericFilterOption);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceNumericFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceNumericFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sourceMinScaleFilter = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sourceMaxScaleFilter = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sourceMinPrecisionFilter = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sourceMaxPrecisionFilter = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.numericFilterOption = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceNumericFilter {
    return {
      sourceMinScaleFilter: isSet(object.sourceMinScaleFilter) ? globalThis.Number(object.sourceMinScaleFilter) : 0,
      sourceMaxScaleFilter: isSet(object.sourceMaxScaleFilter) ? globalThis.Number(object.sourceMaxScaleFilter) : 0,
      sourceMinPrecisionFilter: isSet(object.sourceMinPrecisionFilter)
        ? globalThis.Number(object.sourceMinPrecisionFilter)
        : 0,
      sourceMaxPrecisionFilter: isSet(object.sourceMaxPrecisionFilter)
        ? globalThis.Number(object.sourceMaxPrecisionFilter)
        : 0,
      numericFilterOption: isSet(object.numericFilterOption)
        ? numericFilterOptionFromJSON(object.numericFilterOption)
        : 0,
    };
  },

  toJSON(message: SourceNumericFilter): unknown {
    const obj: any = {};
    if (message.sourceMinScaleFilter !== 0) {
      obj.sourceMinScaleFilter = Math.round(message.sourceMinScaleFilter);
    }
    if (message.sourceMaxScaleFilter !== 0) {
      obj.sourceMaxScaleFilter = Math.round(message.sourceMaxScaleFilter);
    }
    if (message.sourceMinPrecisionFilter !== 0) {
      obj.sourceMinPrecisionFilter = Math.round(message.sourceMinPrecisionFilter);
    }
    if (message.sourceMaxPrecisionFilter !== 0) {
      obj.sourceMaxPrecisionFilter = Math.round(message.sourceMaxPrecisionFilter);
    }
    if (message.numericFilterOption !== 0) {
      obj.numericFilterOption = numericFilterOptionToJSON(message.numericFilterOption);
    }
    return obj;
  },

  create(base?: DeepPartial<SourceNumericFilter>): SourceNumericFilter {
    return SourceNumericFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceNumericFilter>): SourceNumericFilter {
    const message = createBaseSourceNumericFilter();
    message.sourceMinScaleFilter = object.sourceMinScaleFilter ?? 0;
    message.sourceMaxScaleFilter = object.sourceMaxScaleFilter ?? 0;
    message.sourceMinPrecisionFilter = object.sourceMinPrecisionFilter ?? 0;
    message.sourceMaxPrecisionFilter = object.sourceMaxPrecisionFilter ?? 0;
    message.numericFilterOption = object.numericFilterOption ?? 0;
    return message;
  },
};

function createBaseConditionalColumnSetValue(): ConditionalColumnSetValue {
  return {
    sourceTextFilter: undefined,
    sourceNumericFilter: undefined,
    valueTransformation: undefined,
    customFeatures: undefined,
  };
}

export const ConditionalColumnSetValue: MessageFns<ConditionalColumnSetValue> = {
  encode(message: ConditionalColumnSetValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceTextFilter !== undefined) {
      SourceTextFilter.encode(message.sourceTextFilter, writer.uint32(802).fork()).join();
    }
    if (message.sourceNumericFilter !== undefined) {
      SourceNumericFilter.encode(message.sourceNumericFilter, writer.uint32(810).fork()).join();
    }
    if (message.valueTransformation !== undefined) {
      ValueTransformation.encode(message.valueTransformation, writer.uint32(10).fork()).join();
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionalColumnSetValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionalColumnSetValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 100:
          if (tag !== 802) {
            break;
          }

          message.sourceTextFilter = SourceTextFilter.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.sourceNumericFilter = SourceNumericFilter.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.valueTransformation = ValueTransformation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConditionalColumnSetValue {
    return {
      sourceTextFilter: isSet(object.sourceTextFilter) ? SourceTextFilter.fromJSON(object.sourceTextFilter) : undefined,
      sourceNumericFilter: isSet(object.sourceNumericFilter)
        ? SourceNumericFilter.fromJSON(object.sourceNumericFilter)
        : undefined,
      valueTransformation: isSet(object.valueTransformation)
        ? ValueTransformation.fromJSON(object.valueTransformation)
        : undefined,
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
    };
  },

  toJSON(message: ConditionalColumnSetValue): unknown {
    const obj: any = {};
    if (message.sourceTextFilter !== undefined) {
      obj.sourceTextFilter = SourceTextFilter.toJSON(message.sourceTextFilter);
    }
    if (message.sourceNumericFilter !== undefined) {
      obj.sourceNumericFilter = SourceNumericFilter.toJSON(message.sourceNumericFilter);
    }
    if (message.valueTransformation !== undefined) {
      obj.valueTransformation = ValueTransformation.toJSON(message.valueTransformation);
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    return obj;
  },

  create(base?: DeepPartial<ConditionalColumnSetValue>): ConditionalColumnSetValue {
    return ConditionalColumnSetValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConditionalColumnSetValue>): ConditionalColumnSetValue {
    const message = createBaseConditionalColumnSetValue();
    message.sourceTextFilter = (object.sourceTextFilter !== undefined && object.sourceTextFilter !== null)
      ? SourceTextFilter.fromPartial(object.sourceTextFilter)
      : undefined;
    message.sourceNumericFilter = (object.sourceNumericFilter !== undefined && object.sourceNumericFilter !== null)
      ? SourceNumericFilter.fromPartial(object.sourceNumericFilter)
      : undefined;
    message.valueTransformation = (object.valueTransformation !== undefined && object.valueTransformation !== null)
      ? ValueTransformation.fromPartial(object.valueTransformation)
      : undefined;
    message.customFeatures = object.customFeatures ?? undefined;
    return message;
  },
};

function createBaseValueTransformation(): ValueTransformation {
  return {
    isNull: undefined,
    valueList: undefined,
    intComparison: undefined,
    doubleComparison: undefined,
    assignNull: undefined,
    assignSpecificValue: undefined,
    assignMinValue: undefined,
    assignMaxValue: undefined,
    roundScale: undefined,
    applyHash: undefined,
  };
}

export const ValueTransformation: MessageFns<ValueTransformation> = {
  encode(message: ValueTransformation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isNull !== undefined) {
      Empty.encode(message.isNull, writer.uint32(802).fork()).join();
    }
    if (message.valueList !== undefined) {
      ValueListFilter.encode(message.valueList, writer.uint32(810).fork()).join();
    }
    if (message.intComparison !== undefined) {
      IntComparisonFilter.encode(message.intComparison, writer.uint32(818).fork()).join();
    }
    if (message.doubleComparison !== undefined) {
      DoubleComparisonFilter.encode(message.doubleComparison, writer.uint32(826).fork()).join();
    }
    if (message.assignNull !== undefined) {
      Empty.encode(message.assignNull, writer.uint32(1602).fork()).join();
    }
    if (message.assignSpecificValue !== undefined) {
      AssignSpecificValue.encode(message.assignSpecificValue, writer.uint32(1610).fork()).join();
    }
    if (message.assignMinValue !== undefined) {
      Empty.encode(message.assignMinValue, writer.uint32(1618).fork()).join();
    }
    if (message.assignMaxValue !== undefined) {
      Empty.encode(message.assignMaxValue, writer.uint32(1626).fork()).join();
    }
    if (message.roundScale !== undefined) {
      RoundToScale.encode(message.roundScale, writer.uint32(1634).fork()).join();
    }
    if (message.applyHash !== undefined) {
      ApplyHash.encode(message.applyHash, writer.uint32(1642).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValueTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValueTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 100:
          if (tag !== 802) {
            break;
          }

          message.isNull = Empty.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.valueList = ValueListFilter.decode(reader, reader.uint32());
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.intComparison = IntComparisonFilter.decode(reader, reader.uint32());
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }

          message.doubleComparison = DoubleComparisonFilter.decode(reader, reader.uint32());
          continue;
        case 200:
          if (tag !== 1602) {
            break;
          }

          message.assignNull = Empty.decode(reader, reader.uint32());
          continue;
        case 201:
          if (tag !== 1610) {
            break;
          }

          message.assignSpecificValue = AssignSpecificValue.decode(reader, reader.uint32());
          continue;
        case 202:
          if (tag !== 1618) {
            break;
          }

          message.assignMinValue = Empty.decode(reader, reader.uint32());
          continue;
        case 203:
          if (tag !== 1626) {
            break;
          }

          message.assignMaxValue = Empty.decode(reader, reader.uint32());
          continue;
        case 204:
          if (tag !== 1634) {
            break;
          }

          message.roundScale = RoundToScale.decode(reader, reader.uint32());
          continue;
        case 205:
          if (tag !== 1642) {
            break;
          }

          message.applyHash = ApplyHash.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValueTransformation {
    return {
      isNull: isSet(object.isNull) ? Empty.fromJSON(object.isNull) : undefined,
      valueList: isSet(object.valueList) ? ValueListFilter.fromJSON(object.valueList) : undefined,
      intComparison: isSet(object.intComparison) ? IntComparisonFilter.fromJSON(object.intComparison) : undefined,
      doubleComparison: isSet(object.doubleComparison)
        ? DoubleComparisonFilter.fromJSON(object.doubleComparison)
        : undefined,
      assignNull: isSet(object.assignNull) ? Empty.fromJSON(object.assignNull) : undefined,
      assignSpecificValue: isSet(object.assignSpecificValue)
        ? AssignSpecificValue.fromJSON(object.assignSpecificValue)
        : undefined,
      assignMinValue: isSet(object.assignMinValue) ? Empty.fromJSON(object.assignMinValue) : undefined,
      assignMaxValue: isSet(object.assignMaxValue) ? Empty.fromJSON(object.assignMaxValue) : undefined,
      roundScale: isSet(object.roundScale) ? RoundToScale.fromJSON(object.roundScale) : undefined,
      applyHash: isSet(object.applyHash) ? ApplyHash.fromJSON(object.applyHash) : undefined,
    };
  },

  toJSON(message: ValueTransformation): unknown {
    const obj: any = {};
    if (message.isNull !== undefined) {
      obj.isNull = Empty.toJSON(message.isNull);
    }
    if (message.valueList !== undefined) {
      obj.valueList = ValueListFilter.toJSON(message.valueList);
    }
    if (message.intComparison !== undefined) {
      obj.intComparison = IntComparisonFilter.toJSON(message.intComparison);
    }
    if (message.doubleComparison !== undefined) {
      obj.doubleComparison = DoubleComparisonFilter.toJSON(message.doubleComparison);
    }
    if (message.assignNull !== undefined) {
      obj.assignNull = Empty.toJSON(message.assignNull);
    }
    if (message.assignSpecificValue !== undefined) {
      obj.assignSpecificValue = AssignSpecificValue.toJSON(message.assignSpecificValue);
    }
    if (message.assignMinValue !== undefined) {
      obj.assignMinValue = Empty.toJSON(message.assignMinValue);
    }
    if (message.assignMaxValue !== undefined) {
      obj.assignMaxValue = Empty.toJSON(message.assignMaxValue);
    }
    if (message.roundScale !== undefined) {
      obj.roundScale = RoundToScale.toJSON(message.roundScale);
    }
    if (message.applyHash !== undefined) {
      obj.applyHash = ApplyHash.toJSON(message.applyHash);
    }
    return obj;
  },

  create(base?: DeepPartial<ValueTransformation>): ValueTransformation {
    return ValueTransformation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValueTransformation>): ValueTransformation {
    const message = createBaseValueTransformation();
    message.isNull = (object.isNull !== undefined && object.isNull !== null)
      ? Empty.fromPartial(object.isNull)
      : undefined;
    message.valueList = (object.valueList !== undefined && object.valueList !== null)
      ? ValueListFilter.fromPartial(object.valueList)
      : undefined;
    message.intComparison = (object.intComparison !== undefined && object.intComparison !== null)
      ? IntComparisonFilter.fromPartial(object.intComparison)
      : undefined;
    message.doubleComparison = (object.doubleComparison !== undefined && object.doubleComparison !== null)
      ? DoubleComparisonFilter.fromPartial(object.doubleComparison)
      : undefined;
    message.assignNull = (object.assignNull !== undefined && object.assignNull !== null)
      ? Empty.fromPartial(object.assignNull)
      : undefined;
    message.assignSpecificValue = (object.assignSpecificValue !== undefined && object.assignSpecificValue !== null)
      ? AssignSpecificValue.fromPartial(object.assignSpecificValue)
      : undefined;
    message.assignMinValue = (object.assignMinValue !== undefined && object.assignMinValue !== null)
      ? Empty.fromPartial(object.assignMinValue)
      : undefined;
    message.assignMaxValue = (object.assignMaxValue !== undefined && object.assignMaxValue !== null)
      ? Empty.fromPartial(object.assignMaxValue)
      : undefined;
    message.roundScale = (object.roundScale !== undefined && object.roundScale !== null)
      ? RoundToScale.fromPartial(object.roundScale)
      : undefined;
    message.applyHash = (object.applyHash !== undefined && object.applyHash !== null)
      ? ApplyHash.fromPartial(object.applyHash)
      : undefined;
    return message;
  },
};

function createBaseConvertRowIdToColumn(): ConvertRowIdToColumn {
  return { onlyIfNoPrimaryKey: false };
}

export const ConvertRowIdToColumn: MessageFns<ConvertRowIdToColumn> = {
  encode(message: ConvertRowIdToColumn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.onlyIfNoPrimaryKey !== false) {
      writer.uint32(8).bool(message.onlyIfNoPrimaryKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConvertRowIdToColumn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConvertRowIdToColumn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.onlyIfNoPrimaryKey = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConvertRowIdToColumn {
    return {
      onlyIfNoPrimaryKey: isSet(object.onlyIfNoPrimaryKey) ? globalThis.Boolean(object.onlyIfNoPrimaryKey) : false,
    };
  },

  toJSON(message: ConvertRowIdToColumn): unknown {
    const obj: any = {};
    if (message.onlyIfNoPrimaryKey !== false) {
      obj.onlyIfNoPrimaryKey = message.onlyIfNoPrimaryKey;
    }
    return obj;
  },

  create(base?: DeepPartial<ConvertRowIdToColumn>): ConvertRowIdToColumn {
    return ConvertRowIdToColumn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConvertRowIdToColumn>): ConvertRowIdToColumn {
    const message = createBaseConvertRowIdToColumn();
    message.onlyIfNoPrimaryKey = object.onlyIfNoPrimaryKey ?? false;
    return message;
  },
};

function createBaseSetTablePrimaryKey(): SetTablePrimaryKey {
  return { primaryKeyColumns: [], primaryKey: "" };
}

export const SetTablePrimaryKey: MessageFns<SetTablePrimaryKey> = {
  encode(message: SetTablePrimaryKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.primaryKeyColumns) {
      writer.uint32(10).string(v!);
    }
    if (message.primaryKey !== "") {
      writer.uint32(18).string(message.primaryKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetTablePrimaryKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetTablePrimaryKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.primaryKeyColumns.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.primaryKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetTablePrimaryKey {
    return {
      primaryKeyColumns: globalThis.Array.isArray(object?.primaryKeyColumns)
        ? object.primaryKeyColumns.map((e: any) => globalThis.String(e))
        : [],
      primaryKey: isSet(object.primaryKey) ? globalThis.String(object.primaryKey) : "",
    };
  },

  toJSON(message: SetTablePrimaryKey): unknown {
    const obj: any = {};
    if (message.primaryKeyColumns?.length) {
      obj.primaryKeyColumns = message.primaryKeyColumns;
    }
    if (message.primaryKey !== "") {
      obj.primaryKey = message.primaryKey;
    }
    return obj;
  },

  create(base?: DeepPartial<SetTablePrimaryKey>): SetTablePrimaryKey {
    return SetTablePrimaryKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetTablePrimaryKey>): SetTablePrimaryKey {
    const message = createBaseSetTablePrimaryKey();
    message.primaryKeyColumns = object.primaryKeyColumns?.map((e) => e) || [];
    message.primaryKey = object.primaryKey ?? "";
    return message;
  },
};

function createBaseSinglePackageChange(): SinglePackageChange {
  return { packageDescription: "", packageBody: "" };
}

export const SinglePackageChange: MessageFns<SinglePackageChange> = {
  encode(message: SinglePackageChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packageDescription !== "") {
      writer.uint32(10).string(message.packageDescription);
    }
    if (message.packageBody !== "") {
      writer.uint32(18).string(message.packageBody);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SinglePackageChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSinglePackageChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.packageDescription = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.packageBody = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SinglePackageChange {
    return {
      packageDescription: isSet(object.packageDescription) ? globalThis.String(object.packageDescription) : "",
      packageBody: isSet(object.packageBody) ? globalThis.String(object.packageBody) : "",
    };
  },

  toJSON(message: SinglePackageChange): unknown {
    const obj: any = {};
    if (message.packageDescription !== "") {
      obj.packageDescription = message.packageDescription;
    }
    if (message.packageBody !== "") {
      obj.packageBody = message.packageBody;
    }
    return obj;
  },

  create(base?: DeepPartial<SinglePackageChange>): SinglePackageChange {
    return SinglePackageChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SinglePackageChange>): SinglePackageChange {
    const message = createBaseSinglePackageChange();
    message.packageDescription = object.packageDescription ?? "";
    message.packageBody = object.packageBody ?? "";
    return message;
  },
};

function createBaseSourceSqlChange(): SourceSqlChange {
  return { sqlCode: "" };
}

export const SourceSqlChange: MessageFns<SourceSqlChange> = {
  encode(message: SourceSqlChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sqlCode !== "") {
      writer.uint32(10).string(message.sqlCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceSqlChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceSqlChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sqlCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceSqlChange {
    return { sqlCode: isSet(object.sqlCode) ? globalThis.String(object.sqlCode) : "" };
  },

  toJSON(message: SourceSqlChange): unknown {
    const obj: any = {};
    if (message.sqlCode !== "") {
      obj.sqlCode = message.sqlCode;
    }
    return obj;
  },

  create(base?: DeepPartial<SourceSqlChange>): SourceSqlChange {
    return SourceSqlChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceSqlChange>): SourceSqlChange {
    const message = createBaseSourceSqlChange();
    message.sqlCode = object.sqlCode ?? "";
    return message;
  },
};

function createBaseFilterTableColumns(): FilterTableColumns {
  return { includeColumns: [], excludeColumns: [] };
}

export const FilterTableColumns: MessageFns<FilterTableColumns> = {
  encode(message: FilterTableColumns, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.includeColumns) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.excludeColumns) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterTableColumns {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterTableColumns();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.includeColumns.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.excludeColumns.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterTableColumns {
    return {
      includeColumns: globalThis.Array.isArray(object?.includeColumns)
        ? object.includeColumns.map((e: any) => globalThis.String(e))
        : [],
      excludeColumns: globalThis.Array.isArray(object?.excludeColumns)
        ? object.excludeColumns.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: FilterTableColumns): unknown {
    const obj: any = {};
    if (message.includeColumns?.length) {
      obj.includeColumns = message.includeColumns;
    }
    if (message.excludeColumns?.length) {
      obj.excludeColumns = message.excludeColumns;
    }
    return obj;
  },

  create(base?: DeepPartial<FilterTableColumns>): FilterTableColumns {
    return FilterTableColumns.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilterTableColumns>): FilterTableColumns {
    const message = createBaseFilterTableColumns();
    message.includeColumns = object.includeColumns?.map((e) => e) || [];
    message.excludeColumns = object.excludeColumns?.map((e) => e) || [];
    return message;
  },
};

function createBaseValueListFilter(): ValueListFilter {
  return { valuePresentList: 0, values: [], ignoreCase: false };
}

export const ValueListFilter: MessageFns<ValueListFilter> = {
  encode(message: ValueListFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valuePresentList !== 0) {
      writer.uint32(8).int32(message.valuePresentList);
    }
    for (const v of message.values) {
      writer.uint32(18).string(v!);
    }
    if (message.ignoreCase !== false) {
      writer.uint32(24).bool(message.ignoreCase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValueListFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValueListFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valuePresentList = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.values.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ignoreCase = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValueListFilter {
    return {
      valuePresentList: isSet(object.valuePresentList) ? valuePresentInListFromJSON(object.valuePresentList) : 0,
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
      ignoreCase: isSet(object.ignoreCase) ? globalThis.Boolean(object.ignoreCase) : false,
    };
  },

  toJSON(message: ValueListFilter): unknown {
    const obj: any = {};
    if (message.valuePresentList !== 0) {
      obj.valuePresentList = valuePresentInListToJSON(message.valuePresentList);
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.ignoreCase !== false) {
      obj.ignoreCase = message.ignoreCase;
    }
    return obj;
  },

  create(base?: DeepPartial<ValueListFilter>): ValueListFilter {
    return ValueListFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValueListFilter>): ValueListFilter {
    const message = createBaseValueListFilter();
    message.valuePresentList = object.valuePresentList ?? 0;
    message.values = object.values?.map((e) => e) || [];
    message.ignoreCase = object.ignoreCase ?? false;
    return message;
  },
};

function createBaseIntComparisonFilter(): IntComparisonFilter {
  return { valueComparison: 0, value: Long.ZERO };
}

export const IntComparisonFilter: MessageFns<IntComparisonFilter> = {
  encode(message: IntComparisonFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valueComparison !== 0) {
      writer.uint32(8).int32(message.valueComparison);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntComparisonFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntComparisonFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valueComparison = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntComparisonFilter {
    return {
      valueComparison: isSet(object.valueComparison) ? valueComparisonFromJSON(object.valueComparison) : 0,
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: IntComparisonFilter): unknown {
    const obj: any = {};
    if (message.valueComparison !== 0) {
      obj.valueComparison = valueComparisonToJSON(message.valueComparison);
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<IntComparisonFilter>): IntComparisonFilter {
    return IntComparisonFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntComparisonFilter>): IntComparisonFilter {
    const message = createBaseIntComparisonFilter();
    message.valueComparison = object.valueComparison ?? 0;
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseDoubleComparisonFilter(): DoubleComparisonFilter {
  return { valueComparison: 0, value: 0 };
}

export const DoubleComparisonFilter: MessageFns<DoubleComparisonFilter> = {
  encode(message: DoubleComparisonFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valueComparison !== 0) {
      writer.uint32(8).int32(message.valueComparison);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleComparisonFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleComparisonFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valueComparison = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleComparisonFilter {
    return {
      valueComparison: isSet(object.valueComparison) ? valueComparisonFromJSON(object.valueComparison) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: DoubleComparisonFilter): unknown {
    const obj: any = {};
    if (message.valueComparison !== 0) {
      obj.valueComparison = valueComparisonToJSON(message.valueComparison);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleComparisonFilter>): DoubleComparisonFilter {
    return DoubleComparisonFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleComparisonFilter>): DoubleComparisonFilter {
    const message = createBaseDoubleComparisonFilter();
    message.valueComparison = object.valueComparison ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseAssignSpecificValue(): AssignSpecificValue {
  return { value: "" };
}

export const AssignSpecificValue: MessageFns<AssignSpecificValue> = {
  encode(message: AssignSpecificValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignSpecificValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignSpecificValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignSpecificValue {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: AssignSpecificValue): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AssignSpecificValue>): AssignSpecificValue {
    return AssignSpecificValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssignSpecificValue>): AssignSpecificValue {
    const message = createBaseAssignSpecificValue();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseApplyHash(): ApplyHash {
  return { uuidFromBytes: undefined };
}

export const ApplyHash: MessageFns<ApplyHash> = {
  encode(message: ApplyHash, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuidFromBytes !== undefined) {
      Empty.encode(message.uuidFromBytes, writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyHash {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyHash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 100:
          if (tag !== 802) {
            break;
          }

          message.uuidFromBytes = Empty.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyHash {
    return { uuidFromBytes: isSet(object.uuidFromBytes) ? Empty.fromJSON(object.uuidFromBytes) : undefined };
  },

  toJSON(message: ApplyHash): unknown {
    const obj: any = {};
    if (message.uuidFromBytes !== undefined) {
      obj.uuidFromBytes = Empty.toJSON(message.uuidFromBytes);
    }
    return obj;
  },

  create(base?: DeepPartial<ApplyHash>): ApplyHash {
    return ApplyHash.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApplyHash>): ApplyHash {
    const message = createBaseApplyHash();
    message.uuidFromBytes = (object.uuidFromBytes !== undefined && object.uuidFromBytes !== null)
      ? Empty.fromPartial(object.uuidFromBytes)
      : undefined;
    return message;
  },
};

function createBaseRoundToScale(): RoundToScale {
  return { scale: 0 };
}

export const RoundToScale: MessageFns<RoundToScale> = {
  encode(message: RoundToScale, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scale !== 0) {
      writer.uint32(8).int32(message.scale);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoundToScale {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoundToScale();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.scale = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoundToScale {
    return { scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0 };
  },

  toJSON(message: RoundToScale): unknown {
    const obj: any = {};
    if (message.scale !== 0) {
      obj.scale = Math.round(message.scale);
    }
    return obj;
  },

  create(base?: DeepPartial<RoundToScale>): RoundToScale {
    return RoundToScale.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoundToScale>): RoundToScale {
    const message = createBaseRoundToScale();
    message.scale = object.scale ?? 0;
    return message;
  },
};

function createBaseDatabaseEntity(): DatabaseEntity {
  return {
    shortName: "",
    parentEntity: "",
    tree: 0,
    entityType: 0,
    mappings: [],
    entityDdl: [],
    issues: [],
    database: undefined,
    schema: undefined,
    table: undefined,
    view: undefined,
    sequence: undefined,
    storedProcedure: undefined,
    databaseFunction: undefined,
    synonym: undefined,
    databasePackage: undefined,
    udt: undefined,
    materializedView: undefined,
  };
}

export const DatabaseEntity: MessageFns<DatabaseEntity> = {
  encode(message: DatabaseEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shortName !== "") {
      writer.uint32(10).string(message.shortName);
    }
    if (message.parentEntity !== "") {
      writer.uint32(18).string(message.parentEntity);
    }
    if (message.tree !== 0) {
      writer.uint32(24).int32(message.tree);
    }
    if (message.entityType !== 0) {
      writer.uint32(32).int32(message.entityType);
    }
    for (const v of message.mappings) {
      EntityMapping.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.entityDdl) {
      EntityDdl.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.issues) {
      EntityIssue.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.database !== undefined) {
      DatabaseInstanceEntity.encode(message.database, writer.uint32(810).fork()).join();
    }
    if (message.schema !== undefined) {
      SchemaEntity.encode(message.schema, writer.uint32(818).fork()).join();
    }
    if (message.table !== undefined) {
      TableEntity.encode(message.table, writer.uint32(826).fork()).join();
    }
    if (message.view !== undefined) {
      ViewEntity.encode(message.view, writer.uint32(834).fork()).join();
    }
    if (message.sequence !== undefined) {
      SequenceEntity.encode(message.sequence, writer.uint32(842).fork()).join();
    }
    if (message.storedProcedure !== undefined) {
      StoredProcedureEntity.encode(message.storedProcedure, writer.uint32(850).fork()).join();
    }
    if (message.databaseFunction !== undefined) {
      FunctionEntity.encode(message.databaseFunction, writer.uint32(858).fork()).join();
    }
    if (message.synonym !== undefined) {
      SynonymEntity.encode(message.synonym, writer.uint32(866).fork()).join();
    }
    if (message.databasePackage !== undefined) {
      PackageEntity.encode(message.databasePackage, writer.uint32(874).fork()).join();
    }
    if (message.udt !== undefined) {
      UDTEntity.encode(message.udt, writer.uint32(882).fork()).join();
    }
    if (message.materializedView !== undefined) {
      MaterializedViewEntity.encode(message.materializedView, writer.uint32(890).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.shortName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parentEntity = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tree = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.entityType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mappings.push(EntityMapping.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.entityDdl.push(EntityDdl.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.issues.push(EntityIssue.decode(reader, reader.uint32()));
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.database = DatabaseInstanceEntity.decode(reader, reader.uint32());
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.schema = SchemaEntity.decode(reader, reader.uint32());
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }

          message.table = TableEntity.decode(reader, reader.uint32());
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }

          message.view = ViewEntity.decode(reader, reader.uint32());
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }

          message.sequence = SequenceEntity.decode(reader, reader.uint32());
          continue;
        case 106:
          if (tag !== 850) {
            break;
          }

          message.storedProcedure = StoredProcedureEntity.decode(reader, reader.uint32());
          continue;
        case 107:
          if (tag !== 858) {
            break;
          }

          message.databaseFunction = FunctionEntity.decode(reader, reader.uint32());
          continue;
        case 108:
          if (tag !== 866) {
            break;
          }

          message.synonym = SynonymEntity.decode(reader, reader.uint32());
          continue;
        case 109:
          if (tag !== 874) {
            break;
          }

          message.databasePackage = PackageEntity.decode(reader, reader.uint32());
          continue;
        case 110:
          if (tag !== 882) {
            break;
          }

          message.udt = UDTEntity.decode(reader, reader.uint32());
          continue;
        case 111:
          if (tag !== 890) {
            break;
          }

          message.materializedView = MaterializedViewEntity.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseEntity {
    return {
      shortName: isSet(object.shortName) ? globalThis.String(object.shortName) : "",
      parentEntity: isSet(object.parentEntity) ? globalThis.String(object.parentEntity) : "",
      tree: isSet(object.tree) ? databaseEntity_TreeTypeFromJSON(object.tree) : 0,
      entityType: isSet(object.entityType) ? databaseEntityTypeFromJSON(object.entityType) : 0,
      mappings: globalThis.Array.isArray(object?.mappings)
        ? object.mappings.map((e: any) => EntityMapping.fromJSON(e))
        : [],
      entityDdl: globalThis.Array.isArray(object?.entityDdl)
        ? object.entityDdl.map((e: any) => EntityDdl.fromJSON(e))
        : [],
      issues: globalThis.Array.isArray(object?.issues) ? object.issues.map((e: any) => EntityIssue.fromJSON(e)) : [],
      database: isSet(object.database) ? DatabaseInstanceEntity.fromJSON(object.database) : undefined,
      schema: isSet(object.schema) ? SchemaEntity.fromJSON(object.schema) : undefined,
      table: isSet(object.table) ? TableEntity.fromJSON(object.table) : undefined,
      view: isSet(object.view) ? ViewEntity.fromJSON(object.view) : undefined,
      sequence: isSet(object.sequence) ? SequenceEntity.fromJSON(object.sequence) : undefined,
      storedProcedure: isSet(object.storedProcedure)
        ? StoredProcedureEntity.fromJSON(object.storedProcedure)
        : undefined,
      databaseFunction: isSet(object.databaseFunction) ? FunctionEntity.fromJSON(object.databaseFunction) : undefined,
      synonym: isSet(object.synonym) ? SynonymEntity.fromJSON(object.synonym) : undefined,
      databasePackage: isSet(object.databasePackage) ? PackageEntity.fromJSON(object.databasePackage) : undefined,
      udt: isSet(object.udt) ? UDTEntity.fromJSON(object.udt) : undefined,
      materializedView: isSet(object.materializedView)
        ? MaterializedViewEntity.fromJSON(object.materializedView)
        : undefined,
    };
  },

  toJSON(message: DatabaseEntity): unknown {
    const obj: any = {};
    if (message.shortName !== "") {
      obj.shortName = message.shortName;
    }
    if (message.parentEntity !== "") {
      obj.parentEntity = message.parentEntity;
    }
    if (message.tree !== 0) {
      obj.tree = databaseEntity_TreeTypeToJSON(message.tree);
    }
    if (message.entityType !== 0) {
      obj.entityType = databaseEntityTypeToJSON(message.entityType);
    }
    if (message.mappings?.length) {
      obj.mappings = message.mappings.map((e) => EntityMapping.toJSON(e));
    }
    if (message.entityDdl?.length) {
      obj.entityDdl = message.entityDdl.map((e) => EntityDdl.toJSON(e));
    }
    if (message.issues?.length) {
      obj.issues = message.issues.map((e) => EntityIssue.toJSON(e));
    }
    if (message.database !== undefined) {
      obj.database = DatabaseInstanceEntity.toJSON(message.database);
    }
    if (message.schema !== undefined) {
      obj.schema = SchemaEntity.toJSON(message.schema);
    }
    if (message.table !== undefined) {
      obj.table = TableEntity.toJSON(message.table);
    }
    if (message.view !== undefined) {
      obj.view = ViewEntity.toJSON(message.view);
    }
    if (message.sequence !== undefined) {
      obj.sequence = SequenceEntity.toJSON(message.sequence);
    }
    if (message.storedProcedure !== undefined) {
      obj.storedProcedure = StoredProcedureEntity.toJSON(message.storedProcedure);
    }
    if (message.databaseFunction !== undefined) {
      obj.databaseFunction = FunctionEntity.toJSON(message.databaseFunction);
    }
    if (message.synonym !== undefined) {
      obj.synonym = SynonymEntity.toJSON(message.synonym);
    }
    if (message.databasePackage !== undefined) {
      obj.databasePackage = PackageEntity.toJSON(message.databasePackage);
    }
    if (message.udt !== undefined) {
      obj.udt = UDTEntity.toJSON(message.udt);
    }
    if (message.materializedView !== undefined) {
      obj.materializedView = MaterializedViewEntity.toJSON(message.materializedView);
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseEntity>): DatabaseEntity {
    return DatabaseEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseEntity>): DatabaseEntity {
    const message = createBaseDatabaseEntity();
    message.shortName = object.shortName ?? "";
    message.parentEntity = object.parentEntity ?? "";
    message.tree = object.tree ?? 0;
    message.entityType = object.entityType ?? 0;
    message.mappings = object.mappings?.map((e) => EntityMapping.fromPartial(e)) || [];
    message.entityDdl = object.entityDdl?.map((e) => EntityDdl.fromPartial(e)) || [];
    message.issues = object.issues?.map((e) => EntityIssue.fromPartial(e)) || [];
    message.database = (object.database !== undefined && object.database !== null)
      ? DatabaseInstanceEntity.fromPartial(object.database)
      : undefined;
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? SchemaEntity.fromPartial(object.schema)
      : undefined;
    message.table = (object.table !== undefined && object.table !== null)
      ? TableEntity.fromPartial(object.table)
      : undefined;
    message.view = (object.view !== undefined && object.view !== null)
      ? ViewEntity.fromPartial(object.view)
      : undefined;
    message.sequence = (object.sequence !== undefined && object.sequence !== null)
      ? SequenceEntity.fromPartial(object.sequence)
      : undefined;
    message.storedProcedure = (object.storedProcedure !== undefined && object.storedProcedure !== null)
      ? StoredProcedureEntity.fromPartial(object.storedProcedure)
      : undefined;
    message.databaseFunction = (object.databaseFunction !== undefined && object.databaseFunction !== null)
      ? FunctionEntity.fromPartial(object.databaseFunction)
      : undefined;
    message.synonym = (object.synonym !== undefined && object.synonym !== null)
      ? SynonymEntity.fromPartial(object.synonym)
      : undefined;
    message.databasePackage = (object.databasePackage !== undefined && object.databasePackage !== null)
      ? PackageEntity.fromPartial(object.databasePackage)
      : undefined;
    message.udt = (object.udt !== undefined && object.udt !== null) ? UDTEntity.fromPartial(object.udt) : undefined;
    message.materializedView = (object.materializedView !== undefined && object.materializedView !== null)
      ? MaterializedViewEntity.fromPartial(object.materializedView)
      : undefined;
    return message;
  },
};

function createBaseDatabaseInstanceEntity(): DatabaseInstanceEntity {
  return { customFeatures: undefined };
}

export const DatabaseInstanceEntity: MessageFns<DatabaseInstanceEntity> = {
  encode(message: DatabaseInstanceEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseInstanceEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseInstanceEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseInstanceEntity {
    return { customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined };
  },

  toJSON(message: DatabaseInstanceEntity): unknown {
    const obj: any = {};
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseInstanceEntity>): DatabaseInstanceEntity {
    return DatabaseInstanceEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseInstanceEntity>): DatabaseInstanceEntity {
    const message = createBaseDatabaseInstanceEntity();
    message.customFeatures = object.customFeatures ?? undefined;
    return message;
  },
};

function createBaseSchemaEntity(): SchemaEntity {
  return { customFeatures: undefined };
}

export const SchemaEntity: MessageFns<SchemaEntity> = {
  encode(message: SchemaEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchemaEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaEntity {
    return { customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined };
  },

  toJSON(message: SchemaEntity): unknown {
    const obj: any = {};
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaEntity>): SchemaEntity {
    return SchemaEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaEntity>): SchemaEntity {
    const message = createBaseSchemaEntity();
    message.customFeatures = object.customFeatures ?? undefined;
    return message;
  },
};

function createBaseTableEntity(): TableEntity {
  return { columns: [], constraints: [], indices: [], triggers: [], customFeatures: undefined, comment: "" };
}

export const TableEntity: MessageFns<TableEntity> = {
  encode(message: TableEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.columns) {
      ColumnEntity.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.constraints) {
      ConstraintEntity.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.indices) {
      IndexEntity.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.triggers) {
      TriggerEntity.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(42).fork()).join();
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columns.push(ColumnEntity.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.constraints.push(ConstraintEntity.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.indices.push(IndexEntity.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.triggers.push(TriggerEntity.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableEntity {
    return {
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnEntity.fromJSON(e))
        : [],
      constraints: globalThis.Array.isArray(object?.constraints)
        ? object.constraints.map((e: any) => ConstraintEntity.fromJSON(e))
        : [],
      indices: globalThis.Array.isArray(object?.indices) ? object.indices.map((e: any) => IndexEntity.fromJSON(e)) : [],
      triggers: globalThis.Array.isArray(object?.triggers)
        ? object.triggers.map((e: any) => TriggerEntity.fromJSON(e))
        : [],
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: TableEntity): unknown {
    const obj: any = {};
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnEntity.toJSON(e));
    }
    if (message.constraints?.length) {
      obj.constraints = message.constraints.map((e) => ConstraintEntity.toJSON(e));
    }
    if (message.indices?.length) {
      obj.indices = message.indices.map((e) => IndexEntity.toJSON(e));
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => TriggerEntity.toJSON(e));
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create(base?: DeepPartial<TableEntity>): TableEntity {
    return TableEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableEntity>): TableEntity {
    const message = createBaseTableEntity();
    message.columns = object.columns?.map((e) => ColumnEntity.fromPartial(e)) || [];
    message.constraints = object.constraints?.map((e) => ConstraintEntity.fromPartial(e)) || [];
    message.indices = object.indices?.map((e) => IndexEntity.fromPartial(e)) || [];
    message.triggers = object.triggers?.map((e) => TriggerEntity.fromPartial(e)) || [];
    message.customFeatures = object.customFeatures ?? undefined;
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseColumnEntity(): ColumnEntity {
  return {
    name: "",
    dataType: "",
    charset: "",
    collation: "",
    length: Long.ZERO,
    precision: 0,
    scale: 0,
    fractionalSecondsPrecision: 0,
    array: false,
    arrayLength: 0,
    nullable: false,
    autoGenerated: false,
    udt: false,
    customFeatures: undefined,
    setValues: [],
    comment: "",
    ordinalPosition: 0,
    defaultValue: "",
  };
}

export const ColumnEntity: MessageFns<ColumnEntity> = {
  encode(message: ColumnEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataType !== "") {
      writer.uint32(18).string(message.dataType);
    }
    if (message.charset !== "") {
      writer.uint32(26).string(message.charset);
    }
    if (message.collation !== "") {
      writer.uint32(34).string(message.collation);
    }
    if (!message.length.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.length.toString());
    }
    if (message.precision !== 0) {
      writer.uint32(48).int32(message.precision);
    }
    if (message.scale !== 0) {
      writer.uint32(56).int32(message.scale);
    }
    if (message.fractionalSecondsPrecision !== 0) {
      writer.uint32(64).int32(message.fractionalSecondsPrecision);
    }
    if (message.array !== false) {
      writer.uint32(72).bool(message.array);
    }
    if (message.arrayLength !== 0) {
      writer.uint32(80).int32(message.arrayLength);
    }
    if (message.nullable !== false) {
      writer.uint32(88).bool(message.nullable);
    }
    if (message.autoGenerated !== false) {
      writer.uint32(96).bool(message.autoGenerated);
    }
    if (message.udt !== false) {
      writer.uint32(104).bool(message.udt);
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(114).fork()).join();
    }
    for (const v of message.setValues) {
      writer.uint32(122).string(v!);
    }
    if (message.comment !== "") {
      writer.uint32(130).string(message.comment);
    }
    if (message.ordinalPosition !== 0) {
      writer.uint32(136).int32(message.ordinalPosition);
    }
    if (message.defaultValue !== "") {
      writer.uint32(146).string(message.defaultValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.charset = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.collation = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.length = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.precision = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.scale = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.fractionalSecondsPrecision = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.array = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.arrayLength = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.autoGenerated = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.udt = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.setValues.push(reader.string());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.ordinalPosition = reader.int32();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.defaultValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnEntity {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? globalThis.String(object.dataType) : "",
      charset: isSet(object.charset) ? globalThis.String(object.charset) : "",
      collation: isSet(object.collation) ? globalThis.String(object.collation) : "",
      length: isSet(object.length) ? Long.fromValue(object.length) : Long.ZERO,
      precision: isSet(object.precision) ? globalThis.Number(object.precision) : 0,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
      fractionalSecondsPrecision: isSet(object.fractionalSecondsPrecision)
        ? globalThis.Number(object.fractionalSecondsPrecision)
        : 0,
      array: isSet(object.array) ? globalThis.Boolean(object.array) : false,
      arrayLength: isSet(object.arrayLength) ? globalThis.Number(object.arrayLength) : 0,
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      autoGenerated: isSet(object.autoGenerated) ? globalThis.Boolean(object.autoGenerated) : false,
      udt: isSet(object.udt) ? globalThis.Boolean(object.udt) : false,
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
      setValues: globalThis.Array.isArray(object?.setValues)
        ? object.setValues.map((e: any) => globalThis.String(e))
        : [],
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      ordinalPosition: isSet(object.ordinalPosition) ? globalThis.Number(object.ordinalPosition) : 0,
      defaultValue: isSet(object.defaultValue) ? globalThis.String(object.defaultValue) : "",
    };
  },

  toJSON(message: ColumnEntity): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== "") {
      obj.dataType = message.dataType;
    }
    if (message.charset !== "") {
      obj.charset = message.charset;
    }
    if (message.collation !== "") {
      obj.collation = message.collation;
    }
    if (!message.length.equals(Long.ZERO)) {
      obj.length = (message.length || Long.ZERO).toString();
    }
    if (message.precision !== 0) {
      obj.precision = Math.round(message.precision);
    }
    if (message.scale !== 0) {
      obj.scale = Math.round(message.scale);
    }
    if (message.fractionalSecondsPrecision !== 0) {
      obj.fractionalSecondsPrecision = Math.round(message.fractionalSecondsPrecision);
    }
    if (message.array !== false) {
      obj.array = message.array;
    }
    if (message.arrayLength !== 0) {
      obj.arrayLength = Math.round(message.arrayLength);
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.autoGenerated !== false) {
      obj.autoGenerated = message.autoGenerated;
    }
    if (message.udt !== false) {
      obj.udt = message.udt;
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    if (message.setValues?.length) {
      obj.setValues = message.setValues;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.ordinalPosition !== 0) {
      obj.ordinalPosition = Math.round(message.ordinalPosition);
    }
    if (message.defaultValue !== "") {
      obj.defaultValue = message.defaultValue;
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnEntity>): ColumnEntity {
    return ColumnEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnEntity>): ColumnEntity {
    const message = createBaseColumnEntity();
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? "";
    message.charset = object.charset ?? "";
    message.collation = object.collation ?? "";
    message.length = (object.length !== undefined && object.length !== null)
      ? Long.fromValue(object.length)
      : Long.ZERO;
    message.precision = object.precision ?? 0;
    message.scale = object.scale ?? 0;
    message.fractionalSecondsPrecision = object.fractionalSecondsPrecision ?? 0;
    message.array = object.array ?? false;
    message.arrayLength = object.arrayLength ?? 0;
    message.nullable = object.nullable ?? false;
    message.autoGenerated = object.autoGenerated ?? false;
    message.udt = object.udt ?? false;
    message.customFeatures = object.customFeatures ?? undefined;
    message.setValues = object.setValues?.map((e) => e) || [];
    message.comment = object.comment ?? "";
    message.ordinalPosition = object.ordinalPosition ?? 0;
    message.defaultValue = object.defaultValue ?? "";
    return message;
  },
};

function createBaseConstraintEntity(): ConstraintEntity {
  return {
    name: "",
    type: "",
    tableColumns: [],
    customFeatures: undefined,
    referenceColumns: [],
    referenceTable: "",
    tableName: "",
  };
}

export const ConstraintEntity: MessageFns<ConstraintEntity> = {
  encode(message: ConstraintEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    for (const v of message.tableColumns) {
      writer.uint32(26).string(v!);
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(34).fork()).join();
    }
    for (const v of message.referenceColumns) {
      writer.uint32(42).string(v!);
    }
    if (message.referenceTable !== "") {
      writer.uint32(50).string(message.referenceTable);
    }
    if (message.tableName !== "") {
      writer.uint32(58).string(message.tableName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConstraintEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConstraintEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tableColumns.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.referenceColumns.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.referenceTable = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.tableName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConstraintEntity {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      tableColumns: globalThis.Array.isArray(object?.tableColumns)
        ? object.tableColumns.map((e: any) => globalThis.String(e))
        : [],
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
      referenceColumns: globalThis.Array.isArray(object?.referenceColumns)
        ? object.referenceColumns.map((e: any) => globalThis.String(e))
        : [],
      referenceTable: isSet(object.referenceTable) ? globalThis.String(object.referenceTable) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
    };
  },

  toJSON(message: ConstraintEntity): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.tableColumns?.length) {
      obj.tableColumns = message.tableColumns;
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    if (message.referenceColumns?.length) {
      obj.referenceColumns = message.referenceColumns;
    }
    if (message.referenceTable !== "") {
      obj.referenceTable = message.referenceTable;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    return obj;
  },

  create(base?: DeepPartial<ConstraintEntity>): ConstraintEntity {
    return ConstraintEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConstraintEntity>): ConstraintEntity {
    const message = createBaseConstraintEntity();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.tableColumns = object.tableColumns?.map((e) => e) || [];
    message.customFeatures = object.customFeatures ?? undefined;
    message.referenceColumns = object.referenceColumns?.map((e) => e) || [];
    message.referenceTable = object.referenceTable ?? "";
    message.tableName = object.tableName ?? "";
    return message;
  },
};

function createBaseIndexEntity(): IndexEntity {
  return { name: "", type: "", tableColumns: [], unique: false, customFeatures: undefined };
}

export const IndexEntity: MessageFns<IndexEntity> = {
  encode(message: IndexEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    for (const v of message.tableColumns) {
      writer.uint32(26).string(v!);
    }
    if (message.unique !== false) {
      writer.uint32(32).bool(message.unique);
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tableColumns.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.unique = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexEntity {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      tableColumns: globalThis.Array.isArray(object?.tableColumns)
        ? object.tableColumns.map((e: any) => globalThis.String(e))
        : [],
      unique: isSet(object.unique) ? globalThis.Boolean(object.unique) : false,
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
    };
  },

  toJSON(message: IndexEntity): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.tableColumns?.length) {
      obj.tableColumns = message.tableColumns;
    }
    if (message.unique !== false) {
      obj.unique = message.unique;
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    return obj;
  },

  create(base?: DeepPartial<IndexEntity>): IndexEntity {
    return IndexEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexEntity>): IndexEntity {
    const message = createBaseIndexEntity();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.tableColumns = object.tableColumns?.map((e) => e) || [];
    message.unique = object.unique ?? false;
    message.customFeatures = object.customFeatures ?? undefined;
    return message;
  },
};

function createBaseTriggerEntity(): TriggerEntity {
  return { name: "", triggeringEvents: [], triggerType: "", sqlCode: "", customFeatures: undefined };
}

export const TriggerEntity: MessageFns<TriggerEntity> = {
  encode(message: TriggerEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.triggeringEvents) {
      writer.uint32(18).string(v!);
    }
    if (message.triggerType !== "") {
      writer.uint32(26).string(message.triggerType);
    }
    if (message.sqlCode !== "") {
      writer.uint32(34).string(message.sqlCode);
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TriggerEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTriggerEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.triggeringEvents.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.triggerType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sqlCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TriggerEntity {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      triggeringEvents: globalThis.Array.isArray(object?.triggeringEvents)
        ? object.triggeringEvents.map((e: any) => globalThis.String(e))
        : [],
      triggerType: isSet(object.triggerType) ? globalThis.String(object.triggerType) : "",
      sqlCode: isSet(object.sqlCode) ? globalThis.String(object.sqlCode) : "",
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
    };
  },

  toJSON(message: TriggerEntity): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.triggeringEvents?.length) {
      obj.triggeringEvents = message.triggeringEvents;
    }
    if (message.triggerType !== "") {
      obj.triggerType = message.triggerType;
    }
    if (message.sqlCode !== "") {
      obj.sqlCode = message.sqlCode;
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    return obj;
  },

  create(base?: DeepPartial<TriggerEntity>): TriggerEntity {
    return TriggerEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TriggerEntity>): TriggerEntity {
    const message = createBaseTriggerEntity();
    message.name = object.name ?? "";
    message.triggeringEvents = object.triggeringEvents?.map((e) => e) || [];
    message.triggerType = object.triggerType ?? "";
    message.sqlCode = object.sqlCode ?? "";
    message.customFeatures = object.customFeatures ?? undefined;
    return message;
  },
};

function createBaseViewEntity(): ViewEntity {
  return { sqlCode: "", customFeatures: undefined, constraints: [] };
}

export const ViewEntity: MessageFns<ViewEntity> = {
  encode(message: ViewEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sqlCode !== "") {
      writer.uint32(10).string(message.sqlCode);
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(18).fork()).join();
    }
    for (const v of message.constraints) {
      ConstraintEntity.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sqlCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.constraints.push(ConstraintEntity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewEntity {
    return {
      sqlCode: isSet(object.sqlCode) ? globalThis.String(object.sqlCode) : "",
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
      constraints: globalThis.Array.isArray(object?.constraints)
        ? object.constraints.map((e: any) => ConstraintEntity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ViewEntity): unknown {
    const obj: any = {};
    if (message.sqlCode !== "") {
      obj.sqlCode = message.sqlCode;
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    if (message.constraints?.length) {
      obj.constraints = message.constraints.map((e) => ConstraintEntity.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ViewEntity>): ViewEntity {
    return ViewEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ViewEntity>): ViewEntity {
    const message = createBaseViewEntity();
    message.sqlCode = object.sqlCode ?? "";
    message.customFeatures = object.customFeatures ?? undefined;
    message.constraints = object.constraints?.map((e) => ConstraintEntity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSequenceEntity(): SequenceEntity {
  return {
    increment: Long.ZERO,
    startValue: Buffer.alloc(0),
    maxValue: Buffer.alloc(0),
    minValue: Buffer.alloc(0),
    cycle: false,
    cache: Long.ZERO,
    customFeatures: undefined,
  };
}

export const SequenceEntity: MessageFns<SequenceEntity> = {
  encode(message: SequenceEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.increment.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.increment.toString());
    }
    if (message.startValue.length !== 0) {
      writer.uint32(18).bytes(message.startValue);
    }
    if (message.maxValue.length !== 0) {
      writer.uint32(26).bytes(message.maxValue);
    }
    if (message.minValue.length !== 0) {
      writer.uint32(34).bytes(message.minValue);
    }
    if (message.cycle !== false) {
      writer.uint32(40).bool(message.cycle);
    }
    if (!message.cache.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.cache.toString());
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SequenceEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSequenceEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.increment = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startValue = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maxValue = Buffer.from(reader.bytes());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.minValue = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.cycle = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cache = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SequenceEntity {
    return {
      increment: isSet(object.increment) ? Long.fromValue(object.increment) : Long.ZERO,
      startValue: isSet(object.startValue) ? Buffer.from(bytesFromBase64(object.startValue)) : Buffer.alloc(0),
      maxValue: isSet(object.maxValue) ? Buffer.from(bytesFromBase64(object.maxValue)) : Buffer.alloc(0),
      minValue: isSet(object.minValue) ? Buffer.from(bytesFromBase64(object.minValue)) : Buffer.alloc(0),
      cycle: isSet(object.cycle) ? globalThis.Boolean(object.cycle) : false,
      cache: isSet(object.cache) ? Long.fromValue(object.cache) : Long.ZERO,
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
    };
  },

  toJSON(message: SequenceEntity): unknown {
    const obj: any = {};
    if (!message.increment.equals(Long.ZERO)) {
      obj.increment = (message.increment || Long.ZERO).toString();
    }
    if (message.startValue.length !== 0) {
      obj.startValue = base64FromBytes(message.startValue);
    }
    if (message.maxValue.length !== 0) {
      obj.maxValue = base64FromBytes(message.maxValue);
    }
    if (message.minValue.length !== 0) {
      obj.minValue = base64FromBytes(message.minValue);
    }
    if (message.cycle !== false) {
      obj.cycle = message.cycle;
    }
    if (!message.cache.equals(Long.ZERO)) {
      obj.cache = (message.cache || Long.ZERO).toString();
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    return obj;
  },

  create(base?: DeepPartial<SequenceEntity>): SequenceEntity {
    return SequenceEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SequenceEntity>): SequenceEntity {
    const message = createBaseSequenceEntity();
    message.increment = (object.increment !== undefined && object.increment !== null)
      ? Long.fromValue(object.increment)
      : Long.ZERO;
    message.startValue = object.startValue ?? Buffer.alloc(0);
    message.maxValue = object.maxValue ?? Buffer.alloc(0);
    message.minValue = object.minValue ?? Buffer.alloc(0);
    message.cycle = object.cycle ?? false;
    message.cache = (object.cache !== undefined && object.cache !== null) ? Long.fromValue(object.cache) : Long.ZERO;
    message.customFeatures = object.customFeatures ?? undefined;
    return message;
  },
};

function createBaseStoredProcedureEntity(): StoredProcedureEntity {
  return { sqlCode: "", customFeatures: undefined };
}

export const StoredProcedureEntity: MessageFns<StoredProcedureEntity> = {
  encode(message: StoredProcedureEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sqlCode !== "") {
      writer.uint32(10).string(message.sqlCode);
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoredProcedureEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoredProcedureEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sqlCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StoredProcedureEntity {
    return {
      sqlCode: isSet(object.sqlCode) ? globalThis.String(object.sqlCode) : "",
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
    };
  },

  toJSON(message: StoredProcedureEntity): unknown {
    const obj: any = {};
    if (message.sqlCode !== "") {
      obj.sqlCode = message.sqlCode;
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    return obj;
  },

  create(base?: DeepPartial<StoredProcedureEntity>): StoredProcedureEntity {
    return StoredProcedureEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StoredProcedureEntity>): StoredProcedureEntity {
    const message = createBaseStoredProcedureEntity();
    message.sqlCode = object.sqlCode ?? "";
    message.customFeatures = object.customFeatures ?? undefined;
    return message;
  },
};

function createBaseFunctionEntity(): FunctionEntity {
  return { sqlCode: "", customFeatures: undefined };
}

export const FunctionEntity: MessageFns<FunctionEntity> = {
  encode(message: FunctionEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sqlCode !== "") {
      writer.uint32(10).string(message.sqlCode);
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sqlCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionEntity {
    return {
      sqlCode: isSet(object.sqlCode) ? globalThis.String(object.sqlCode) : "",
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
    };
  },

  toJSON(message: FunctionEntity): unknown {
    const obj: any = {};
    if (message.sqlCode !== "") {
      obj.sqlCode = message.sqlCode;
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionEntity>): FunctionEntity {
    return FunctionEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionEntity>): FunctionEntity {
    const message = createBaseFunctionEntity();
    message.sqlCode = object.sqlCode ?? "";
    message.customFeatures = object.customFeatures ?? undefined;
    return message;
  },
};

function createBaseMaterializedViewEntity(): MaterializedViewEntity {
  return { sqlCode: "", customFeatures: undefined };
}

export const MaterializedViewEntity: MessageFns<MaterializedViewEntity> = {
  encode(message: MaterializedViewEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sqlCode !== "") {
      writer.uint32(10).string(message.sqlCode);
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaterializedViewEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaterializedViewEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sqlCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaterializedViewEntity {
    return {
      sqlCode: isSet(object.sqlCode) ? globalThis.String(object.sqlCode) : "",
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
    };
  },

  toJSON(message: MaterializedViewEntity): unknown {
    const obj: any = {};
    if (message.sqlCode !== "") {
      obj.sqlCode = message.sqlCode;
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    return obj;
  },

  create(base?: DeepPartial<MaterializedViewEntity>): MaterializedViewEntity {
    return MaterializedViewEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaterializedViewEntity>): MaterializedViewEntity {
    const message = createBaseMaterializedViewEntity();
    message.sqlCode = object.sqlCode ?? "";
    message.customFeatures = object.customFeatures ?? undefined;
    return message;
  },
};

function createBaseSynonymEntity(): SynonymEntity {
  return { sourceEntity: "", sourceType: 0, customFeatures: undefined };
}

export const SynonymEntity: MessageFns<SynonymEntity> = {
  encode(message: SynonymEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceEntity !== "") {
      writer.uint32(10).string(message.sourceEntity);
    }
    if (message.sourceType !== 0) {
      writer.uint32(16).int32(message.sourceType);
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SynonymEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSynonymEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceEntity = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sourceType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SynonymEntity {
    return {
      sourceEntity: isSet(object.sourceEntity) ? globalThis.String(object.sourceEntity) : "",
      sourceType: isSet(object.sourceType) ? databaseEntityTypeFromJSON(object.sourceType) : 0,
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
    };
  },

  toJSON(message: SynonymEntity): unknown {
    const obj: any = {};
    if (message.sourceEntity !== "") {
      obj.sourceEntity = message.sourceEntity;
    }
    if (message.sourceType !== 0) {
      obj.sourceType = databaseEntityTypeToJSON(message.sourceType);
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    return obj;
  },

  create(base?: DeepPartial<SynonymEntity>): SynonymEntity {
    return SynonymEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SynonymEntity>): SynonymEntity {
    const message = createBaseSynonymEntity();
    message.sourceEntity = object.sourceEntity ?? "";
    message.sourceType = object.sourceType ?? 0;
    message.customFeatures = object.customFeatures ?? undefined;
    return message;
  },
};

function createBasePackageEntity(): PackageEntity {
  return { packageSqlCode: "", packageBody: "", customFeatures: undefined };
}

export const PackageEntity: MessageFns<PackageEntity> = {
  encode(message: PackageEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packageSqlCode !== "") {
      writer.uint32(10).string(message.packageSqlCode);
    }
    if (message.packageBody !== "") {
      writer.uint32(18).string(message.packageBody);
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PackageEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePackageEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.packageSqlCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.packageBody = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PackageEntity {
    return {
      packageSqlCode: isSet(object.packageSqlCode) ? globalThis.String(object.packageSqlCode) : "",
      packageBody: isSet(object.packageBody) ? globalThis.String(object.packageBody) : "",
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
    };
  },

  toJSON(message: PackageEntity): unknown {
    const obj: any = {};
    if (message.packageSqlCode !== "") {
      obj.packageSqlCode = message.packageSqlCode;
    }
    if (message.packageBody !== "") {
      obj.packageBody = message.packageBody;
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    return obj;
  },

  create(base?: DeepPartial<PackageEntity>): PackageEntity {
    return PackageEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PackageEntity>): PackageEntity {
    const message = createBasePackageEntity();
    message.packageSqlCode = object.packageSqlCode ?? "";
    message.packageBody = object.packageBody ?? "";
    message.customFeatures = object.customFeatures ?? undefined;
    return message;
  },
};

function createBaseUDTEntity(): UDTEntity {
  return { udtSqlCode: "", udtBody: "", customFeatures: undefined };
}

export const UDTEntity: MessageFns<UDTEntity> = {
  encode(message: UDTEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.udtSqlCode !== "") {
      writer.uint32(10).string(message.udtSqlCode);
    }
    if (message.udtBody !== "") {
      writer.uint32(18).string(message.udtBody);
    }
    if (message.customFeatures !== undefined) {
      Struct.encode(Struct.wrap(message.customFeatures), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UDTEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUDTEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.udtSqlCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.udtBody = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customFeatures = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UDTEntity {
    return {
      udtSqlCode: isSet(object.udtSqlCode) ? globalThis.String(object.udtSqlCode) : "",
      udtBody: isSet(object.udtBody) ? globalThis.String(object.udtBody) : "",
      customFeatures: isObject(object.customFeatures) ? object.customFeatures : undefined,
    };
  },

  toJSON(message: UDTEntity): unknown {
    const obj: any = {};
    if (message.udtSqlCode !== "") {
      obj.udtSqlCode = message.udtSqlCode;
    }
    if (message.udtBody !== "") {
      obj.udtBody = message.udtBody;
    }
    if (message.customFeatures !== undefined) {
      obj.customFeatures = message.customFeatures;
    }
    return obj;
  },

  create(base?: DeepPartial<UDTEntity>): UDTEntity {
    return UDTEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UDTEntity>): UDTEntity {
    const message = createBaseUDTEntity();
    message.udtSqlCode = object.udtSqlCode ?? "";
    message.udtBody = object.udtBody ?? "";
    message.customFeatures = object.customFeatures ?? undefined;
    return message;
  },
};

function createBaseEntityMapping(): EntityMapping {
  return { sourceEntity: "", draftEntity: "", sourceType: 0, draftType: 0, mappingLog: [] };
}

export const EntityMapping: MessageFns<EntityMapping> = {
  encode(message: EntityMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceEntity !== "") {
      writer.uint32(10).string(message.sourceEntity);
    }
    if (message.draftEntity !== "") {
      writer.uint32(18).string(message.draftEntity);
    }
    if (message.sourceType !== 0) {
      writer.uint32(32).int32(message.sourceType);
    }
    if (message.draftType !== 0) {
      writer.uint32(40).int32(message.draftType);
    }
    for (const v of message.mappingLog) {
      EntityMappingLogEntry.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceEntity = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.draftEntity = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sourceType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.draftType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mappingLog.push(EntityMappingLogEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityMapping {
    return {
      sourceEntity: isSet(object.sourceEntity) ? globalThis.String(object.sourceEntity) : "",
      draftEntity: isSet(object.draftEntity) ? globalThis.String(object.draftEntity) : "",
      sourceType: isSet(object.sourceType) ? databaseEntityTypeFromJSON(object.sourceType) : 0,
      draftType: isSet(object.draftType) ? databaseEntityTypeFromJSON(object.draftType) : 0,
      mappingLog: globalThis.Array.isArray(object?.mappingLog)
        ? object.mappingLog.map((e: any) => EntityMappingLogEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EntityMapping): unknown {
    const obj: any = {};
    if (message.sourceEntity !== "") {
      obj.sourceEntity = message.sourceEntity;
    }
    if (message.draftEntity !== "") {
      obj.draftEntity = message.draftEntity;
    }
    if (message.sourceType !== 0) {
      obj.sourceType = databaseEntityTypeToJSON(message.sourceType);
    }
    if (message.draftType !== 0) {
      obj.draftType = databaseEntityTypeToJSON(message.draftType);
    }
    if (message.mappingLog?.length) {
      obj.mappingLog = message.mappingLog.map((e) => EntityMappingLogEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EntityMapping>): EntityMapping {
    return EntityMapping.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityMapping>): EntityMapping {
    const message = createBaseEntityMapping();
    message.sourceEntity = object.sourceEntity ?? "";
    message.draftEntity = object.draftEntity ?? "";
    message.sourceType = object.sourceType ?? 0;
    message.draftType = object.draftType ?? 0;
    message.mappingLog = object.mappingLog?.map((e) => EntityMappingLogEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEntityMappingLogEntry(): EntityMappingLogEntry {
  return { ruleId: "", ruleRevisionId: "", mappingComment: "" };
}

export const EntityMappingLogEntry: MessageFns<EntityMappingLogEntry> = {
  encode(message: EntityMappingLogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ruleId !== "") {
      writer.uint32(10).string(message.ruleId);
    }
    if (message.ruleRevisionId !== "") {
      writer.uint32(18).string(message.ruleRevisionId);
    }
    if (message.mappingComment !== "") {
      writer.uint32(26).string(message.mappingComment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityMappingLogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityMappingLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ruleId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ruleRevisionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mappingComment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityMappingLogEntry {
    return {
      ruleId: isSet(object.ruleId) ? globalThis.String(object.ruleId) : "",
      ruleRevisionId: isSet(object.ruleRevisionId) ? globalThis.String(object.ruleRevisionId) : "",
      mappingComment: isSet(object.mappingComment) ? globalThis.String(object.mappingComment) : "",
    };
  },

  toJSON(message: EntityMappingLogEntry): unknown {
    const obj: any = {};
    if (message.ruleId !== "") {
      obj.ruleId = message.ruleId;
    }
    if (message.ruleRevisionId !== "") {
      obj.ruleRevisionId = message.ruleRevisionId;
    }
    if (message.mappingComment !== "") {
      obj.mappingComment = message.mappingComment;
    }
    return obj;
  },

  create(base?: DeepPartial<EntityMappingLogEntry>): EntityMappingLogEntry {
    return EntityMappingLogEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityMappingLogEntry>): EntityMappingLogEntry {
    const message = createBaseEntityMappingLogEntry();
    message.ruleId = object.ruleId ?? "";
    message.ruleRevisionId = object.ruleRevisionId ?? "";
    message.mappingComment = object.mappingComment ?? "";
    return message;
  },
};

function createBaseEntityDdl(): EntityDdl {
  return { ddlType: "", entity: "", ddl: "", entityType: 0, issueId: [] };
}

export const EntityDdl: MessageFns<EntityDdl> = {
  encode(message: EntityDdl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ddlType !== "") {
      writer.uint32(10).string(message.ddlType);
    }
    if (message.entity !== "") {
      writer.uint32(18).string(message.entity);
    }
    if (message.ddl !== "") {
      writer.uint32(26).string(message.ddl);
    }
    if (message.entityType !== 0) {
      writer.uint32(32).int32(message.entityType);
    }
    for (const v of message.issueId) {
      writer.uint32(802).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityDdl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityDdl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ddlType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entity = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ddl = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.entityType = reader.int32() as any;
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.issueId.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityDdl {
    return {
      ddlType: isSet(object.ddlType) ? globalThis.String(object.ddlType) : "",
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      ddl: isSet(object.ddl) ? globalThis.String(object.ddl) : "",
      entityType: isSet(object.entityType) ? databaseEntityTypeFromJSON(object.entityType) : 0,
      issueId: globalThis.Array.isArray(object?.issueId) ? object.issueId.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: EntityDdl): unknown {
    const obj: any = {};
    if (message.ddlType !== "") {
      obj.ddlType = message.ddlType;
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.ddl !== "") {
      obj.ddl = message.ddl;
    }
    if (message.entityType !== 0) {
      obj.entityType = databaseEntityTypeToJSON(message.entityType);
    }
    if (message.issueId?.length) {
      obj.issueId = message.issueId;
    }
    return obj;
  },

  create(base?: DeepPartial<EntityDdl>): EntityDdl {
    return EntityDdl.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityDdl>): EntityDdl {
    const message = createBaseEntityDdl();
    message.ddlType = object.ddlType ?? "";
    message.entity = object.entity ?? "";
    message.ddl = object.ddl ?? "";
    message.entityType = object.entityType ?? 0;
    message.issueId = object.issueId?.map((e) => e) || [];
    return message;
  },
};

function createBaseEntityIssue(): EntityIssue {
  return { id: "", type: 0, severity: 0, message: "", code: "", ddl: undefined, position: undefined, entityType: 0 };
}

export const EntityIssue: MessageFns<EntityIssue> = {
  encode(message: EntityIssue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.severity !== 0) {
      writer.uint32(24).int32(message.severity);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    if (message.code !== "") {
      writer.uint32(42).string(message.code);
    }
    if (message.ddl !== undefined) {
      writer.uint32(50).string(message.ddl);
    }
    if (message.position !== undefined) {
      EntityIssue_Position.encode(message.position, writer.uint32(58).fork()).join();
    }
    if (message.entityType !== 0) {
      writer.uint32(64).int32(message.entityType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityIssue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityIssue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.code = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.ddl = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.position = EntityIssue_Position.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.entityType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityIssue {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? entityIssue_IssueTypeFromJSON(object.type) : 0,
      severity: isSet(object.severity) ? entityIssue_IssueSeverityFromJSON(object.severity) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      ddl: isSet(object.ddl) ? globalThis.String(object.ddl) : undefined,
      position: isSet(object.position) ? EntityIssue_Position.fromJSON(object.position) : undefined,
      entityType: isSet(object.entityType) ? databaseEntityTypeFromJSON(object.entityType) : 0,
    };
  },

  toJSON(message: EntityIssue): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== 0) {
      obj.type = entityIssue_IssueTypeToJSON(message.type);
    }
    if (message.severity !== 0) {
      obj.severity = entityIssue_IssueSeverityToJSON(message.severity);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.ddl !== undefined) {
      obj.ddl = message.ddl;
    }
    if (message.position !== undefined) {
      obj.position = EntityIssue_Position.toJSON(message.position);
    }
    if (message.entityType !== 0) {
      obj.entityType = databaseEntityTypeToJSON(message.entityType);
    }
    return obj;
  },

  create(base?: DeepPartial<EntityIssue>): EntityIssue {
    return EntityIssue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityIssue>): EntityIssue {
    const message = createBaseEntityIssue();
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.severity = object.severity ?? 0;
    message.message = object.message ?? "";
    message.code = object.code ?? "";
    message.ddl = object.ddl ?? undefined;
    message.position = (object.position !== undefined && object.position !== null)
      ? EntityIssue_Position.fromPartial(object.position)
      : undefined;
    message.entityType = object.entityType ?? 0;
    return message;
  },
};

function createBaseEntityIssue_Position(): EntityIssue_Position {
  return { line: 0, column: 0, offset: 0, length: 0 };
}

export const EntityIssue_Position: MessageFns<EntityIssue_Position> = {
  encode(message: EntityIssue_Position, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.line !== 0) {
      writer.uint32(8).int32(message.line);
    }
    if (message.column !== 0) {
      writer.uint32(16).int32(message.column);
    }
    if (message.offset !== 0) {
      writer.uint32(24).int32(message.offset);
    }
    if (message.length !== 0) {
      writer.uint32(32).int32(message.length);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityIssue_Position {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityIssue_Position();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.line = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.column = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.offset = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.length = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityIssue_Position {
    return {
      line: isSet(object.line) ? globalThis.Number(object.line) : 0,
      column: isSet(object.column) ? globalThis.Number(object.column) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
    };
  },

  toJSON(message: EntityIssue_Position): unknown {
    const obj: any = {};
    if (message.line !== 0) {
      obj.line = Math.round(message.line);
    }
    if (message.column !== 0) {
      obj.column = Math.round(message.column);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    return obj;
  },

  create(base?: DeepPartial<EntityIssue_Position>): EntityIssue_Position {
    return EntityIssue_Position.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityIssue_Position>): EntityIssue_Position {
    const message = createBaseEntityIssue_Position();
    message.line = object.line ?? 0;
    message.column = object.column ?? 0;
    message.offset = object.offset ?? 0;
    message.length = object.length ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
