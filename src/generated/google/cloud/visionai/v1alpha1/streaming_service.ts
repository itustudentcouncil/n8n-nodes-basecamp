// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/visionai/v1alpha1/streaming_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Packet } from "./streaming_resources.js";

export const protobufPackage = "google.cloud.visionai.v1alpha1";

/** The lease type. */
export enum LeaseType {
  /** LEASE_TYPE_UNSPECIFIED - Lease type unspecified. */
  LEASE_TYPE_UNSPECIFIED = 0,
  /** LEASE_TYPE_READER - Lease for stream reader. */
  LEASE_TYPE_READER = 1,
  /** LEASE_TYPE_WRITER - Lease for stream writer. */
  LEASE_TYPE_WRITER = 2,
  UNRECOGNIZED = -1,
}

export function leaseTypeFromJSON(object: any): LeaseType {
  switch (object) {
    case 0:
    case "LEASE_TYPE_UNSPECIFIED":
      return LeaseType.LEASE_TYPE_UNSPECIFIED;
    case 1:
    case "LEASE_TYPE_READER":
      return LeaseType.LEASE_TYPE_READER;
    case 2:
    case "LEASE_TYPE_WRITER":
      return LeaseType.LEASE_TYPE_WRITER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LeaseType.UNRECOGNIZED;
  }
}

export function leaseTypeToJSON(object: LeaseType): string {
  switch (object) {
    case LeaseType.LEASE_TYPE_UNSPECIFIED:
      return "LEASE_TYPE_UNSPECIFIED";
    case LeaseType.LEASE_TYPE_READER:
      return "LEASE_TYPE_READER";
    case LeaseType.LEASE_TYPE_WRITER:
      return "LEASE_TYPE_WRITER";
    case LeaseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for ReceiveEvents. */
export interface ReceiveEventsRequest {
  /** The setup request to setup the RPC connection. */
  setupRequest?:
    | ReceiveEventsRequest_SetupRequest
    | undefined;
  /** This request checkpoints the consumer's read progress. */
  commitRequest?: CommitRequest | undefined;
}

/**
 * SetupRequest is the first message sent to the service to setup the RPC
 * connection.
 */
export interface ReceiveEventsRequest_SetupRequest {
  /** The cluster name. */
  cluster: string;
  /** The stream name. The service will return the events for the given stream. */
  stream: string;
  /**
   * A name for the receiver to self-identify.
   *
   * This is used to keep track of a receiver's read progress.
   */
  receiver: string;
  /** Controller mode configuration for receiving events from the server. */
  controlledMode:
    | ControlledMode
    | undefined;
  /**
   * The maximum duration of server silence before the client determines the
   * server unreachable.
   *
   * The client must either receive an `Event` update or a heart beat message
   * before this duration expires; otherwise, the client will automatically
   * cancel the current connection and retry.
   */
  heartbeatInterval:
    | Duration
    | undefined;
  /**
   * The grace period after which a `writes_done_request` is issued, that a
   * `WritesDone` is expected from the client.
   *
   * The server is free to cancel the RPC should this expire.
   *
   * A system default will be chosen if unset.
   */
  writesDoneGracePeriod: Duration | undefined;
}

/** The event update message. */
export interface EventUpdate {
  /** The name of the stream that the event is attached to. */
  stream: string;
  /** The name of the event. */
  event: string;
  /** The name of the series. */
  series: string;
  /** The timestamp when the Event update happens. */
  updateTime:
    | Date
    | undefined;
  /**
   * The offset of the message that will be used to acknowledge of the message
   * receiving.
   */
  offset: Long;
}

/** Control message for a ReceiveEventsResponse. */
export interface ReceiveEventsControlResponse {
  /** A server heartbeat. */
  heartbeat?:
    | boolean
    | undefined;
  /**
   * A request to the receiver to complete any final writes followed by a
   * `WritesDone`; e.g. issue any final `CommitRequest`s.
   *
   * May be ignored if `WritesDone` has already been issued at any point
   * prior to receiving this message.
   *
   * If `WritesDone` does not get issued, then the server will forcefully
   * cancel the connection, and the receiver will likely receive an
   * uninformative after `Read` returns `false` and `Finish` is called.
   */
  writesDoneRequest?: boolean | undefined;
}

/** Response message for the ReceiveEvents. */
export interface ReceiveEventsResponse {
  /** The event update message. */
  eventUpdate?:
    | EventUpdate
    | undefined;
  /** A control message from the server. */
  control?: ReceiveEventsControlResponse | undefined;
}

/** The lease message. */
export interface Lease {
  /** The lease id. */
  id: string;
  /** The series name. */
  series: string;
  /** The owner name. */
  owner: string;
  /** The lease expire time. */
  expireTime:
    | Date
    | undefined;
  /** The lease type. */
  leaseType: LeaseType;
}

/** Request message for acquiring a lease. */
export interface AcquireLeaseRequest {
  /** The series name. */
  series: string;
  /** The owner name. */
  owner: string;
  /** The lease term. */
  term:
    | Duration
    | undefined;
  /** The lease type. */
  leaseType: LeaseType;
}

/** Request message for renewing a lease. */
export interface RenewLeaseRequest {
  /** Lease id. */
  id: string;
  /** Series name. */
  series: string;
  /** Lease owner. */
  owner: string;
  /** Lease term. */
  term: Duration | undefined;
}

/** Request message for releasing lease. */
export interface ReleaseLeaseRequest {
  /** Lease id. */
  id: string;
  /** Series name. */
  series: string;
  /** Lease owner. */
  owner: string;
}

/** Response message for release lease. */
export interface ReleaseLeaseResponse {
}

/** RequestMetadata is the metadata message for the request. */
export interface RequestMetadata {
  /** Stream name. */
  stream: string;
  /** Evevt name. */
  event: string;
  /** Series name. */
  series: string;
  /** Lease id. */
  leaseId: string;
  /** Owner name. */
  owner: string;
  /**
   * Lease term specifies how long the client wants the session to be maintained
   * by the server after the client leaves. If the lease term is not set, the
   * server will release the session immediately and the client cannot reconnect
   * to the same session later.
   */
  leaseTerm: Duration | undefined;
}

/** Request message for sending packets. */
export interface SendPacketsRequest {
  /** Packets sent over the streaming rpc. */
  packet?:
    | Packet
    | undefined;
  /** The first message of the streaming rpc including the request metadata. */
  metadata?: RequestMetadata | undefined;
}

/** Response message for sending packets. */
export interface SendPacketsResponse {
}

/** Request message for receiving packets. */
export interface ReceivePacketsRequest {
  /**
   * The request to setup the initial state of session.
   *
   * The client must send and only send this as the first message.
   */
  setupRequest?:
    | ReceivePacketsRequest_SetupRequest
    | undefined;
  /** This request checkpoints the consumer's read progress. */
  commitRequest?: CommitRequest | undefined;
}

/** The message specifying the initial settings for the ReceivePackets session. */
export interface ReceivePacketsRequest_SetupRequest {
  /** Options for configuring eager mode. */
  eagerReceiveMode?:
    | EagerMode
    | undefined;
  /** Options for configuring controlled mode. */
  controlledReceiveMode?:
    | ControlledMode
    | undefined;
  /** The configurations that specify where packets are retrieved. */
  metadata:
    | RequestMetadata
    | undefined;
  /**
   * A name for the receiver to self-identify.
   *
   * This is used to keep track of a receiver's read progress.
   */
  receiver: string;
  /**
   * The maximum duration of server silence before the client determines the
   * server unreachable.
   *
   * The client must either receive a `Packet` or a heart beat message before
   * this duration expires; otherwise, the client will automatically cancel
   * the current connection and retry.
   */
  heartbeatInterval:
    | Duration
    | undefined;
  /**
   * The grace period after which a `writes_done_request` is issued, that a
   * `WritesDone` is expected from the client.
   *
   * The server is free to cancel the RPC should this expire.
   *
   * A system default will be chosen if unset.
   */
  writesDoneGracePeriod: Duration | undefined;
}

/** Control message for a ReceivePacketsResponse. */
export interface ReceivePacketsControlResponse {
  /** A server heartbeat. */
  heartbeat?:
    | boolean
    | undefined;
  /**
   * A request to the receiver to complete any final writes followed by a
   * `WritesDone`; e.g. issue any final `CommitRequest`s.
   *
   * May be ignored if `WritesDone` has already been issued at any point
   * prior to receiving this message.
   *
   * If `WritesDone` does not get issued, then the server will forcefully
   * cancel the connection, and the receiver will likely receive an
   * uninformative after `Read` returns `false` and `Finish` is called.
   */
  writesDoneRequest?: boolean | undefined;
}

/** Response message from ReceivePackets. */
export interface ReceivePacketsResponse {
  /** A genuine data payload originating from the sender. */
  packet?:
    | Packet
    | undefined;
  /** A control message from the server. */
  control?: ReceivePacketsControlResponse | undefined;
}

/** The options for receiver under the eager mode. */
export interface EagerMode {
}

/** The options for receiver under the controlled mode. */
export interface ControlledMode {
  /**
   * This can be set to the following logical starting points:
   *
   * "begin": This will read from the earliest available message.
   *
   * "most-recent": This will read from the latest available message.
   *
   * "end": This will read only future messages.
   *
   * "stored": This will resume reads one past the last committed offset.
   *           It is the only option that resumes progress; all others
   *           jump unilaterally.
   */
  startingLogicalOffset?:
    | string
    | undefined;
  /**
   * This is the logical starting point to fallback upon should the
   * specified starting offset be unavailable.
   *
   * This can be one of the following values:
   *
   * "begin": This will read from the earliest available message.
   *
   * "end": This will read only future messages.
   */
  fallbackStartingOffset: string;
}

/**
 * The message for explicitly committing the read progress.
 *
 * This may only be used when `ReceivePacketsControlledMode` is set in the
 * initial setup request.
 */
export interface CommitRequest {
  /** The offset to commit. */
  offset: Long;
}

function createBaseReceiveEventsRequest(): ReceiveEventsRequest {
  return { setupRequest: undefined, commitRequest: undefined };
}

export const ReceiveEventsRequest: MessageFns<ReceiveEventsRequest> = {
  encode(message: ReceiveEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.setupRequest !== undefined) {
      ReceiveEventsRequest_SetupRequest.encode(message.setupRequest, writer.uint32(10).fork()).join();
    }
    if (message.commitRequest !== undefined) {
      CommitRequest.encode(message.commitRequest, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiveEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiveEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.setupRequest = ReceiveEventsRequest_SetupRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commitRequest = CommitRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiveEventsRequest {
    return {
      setupRequest: isSet(object.setupRequest)
        ? ReceiveEventsRequest_SetupRequest.fromJSON(object.setupRequest)
        : undefined,
      commitRequest: isSet(object.commitRequest) ? CommitRequest.fromJSON(object.commitRequest) : undefined,
    };
  },

  toJSON(message: ReceiveEventsRequest): unknown {
    const obj: any = {};
    if (message.setupRequest !== undefined) {
      obj.setupRequest = ReceiveEventsRequest_SetupRequest.toJSON(message.setupRequest);
    }
    if (message.commitRequest !== undefined) {
      obj.commitRequest = CommitRequest.toJSON(message.commitRequest);
    }
    return obj;
  },

  create(base?: DeepPartial<ReceiveEventsRequest>): ReceiveEventsRequest {
    return ReceiveEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReceiveEventsRequest>): ReceiveEventsRequest {
    const message = createBaseReceiveEventsRequest();
    message.setupRequest = (object.setupRequest !== undefined && object.setupRequest !== null)
      ? ReceiveEventsRequest_SetupRequest.fromPartial(object.setupRequest)
      : undefined;
    message.commitRequest = (object.commitRequest !== undefined && object.commitRequest !== null)
      ? CommitRequest.fromPartial(object.commitRequest)
      : undefined;
    return message;
  },
};

function createBaseReceiveEventsRequest_SetupRequest(): ReceiveEventsRequest_SetupRequest {
  return {
    cluster: "",
    stream: "",
    receiver: "",
    controlledMode: undefined,
    heartbeatInterval: undefined,
    writesDoneGracePeriod: undefined,
  };
}

export const ReceiveEventsRequest_SetupRequest: MessageFns<ReceiveEventsRequest_SetupRequest> = {
  encode(message: ReceiveEventsRequest_SetupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster !== "") {
      writer.uint32(10).string(message.cluster);
    }
    if (message.stream !== "") {
      writer.uint32(18).string(message.stream);
    }
    if (message.receiver !== "") {
      writer.uint32(26).string(message.receiver);
    }
    if (message.controlledMode !== undefined) {
      ControlledMode.encode(message.controlledMode, writer.uint32(34).fork()).join();
    }
    if (message.heartbeatInterval !== undefined) {
      Duration.encode(message.heartbeatInterval, writer.uint32(42).fork()).join();
    }
    if (message.writesDoneGracePeriod !== undefined) {
      Duration.encode(message.writesDoneGracePeriod, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiveEventsRequest_SetupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiveEventsRequest_SetupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cluster = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stream = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.receiver = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.controlledMode = ControlledMode.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.heartbeatInterval = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.writesDoneGracePeriod = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiveEventsRequest_SetupRequest {
    return {
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "",
      stream: isSet(object.stream) ? globalThis.String(object.stream) : "",
      receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
      controlledMode: isSet(object.controlledMode) ? ControlledMode.fromJSON(object.controlledMode) : undefined,
      heartbeatInterval: isSet(object.heartbeatInterval) ? Duration.fromJSON(object.heartbeatInterval) : undefined,
      writesDoneGracePeriod: isSet(object.writesDoneGracePeriod)
        ? Duration.fromJSON(object.writesDoneGracePeriod)
        : undefined,
    };
  },

  toJSON(message: ReceiveEventsRequest_SetupRequest): unknown {
    const obj: any = {};
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    if (message.receiver !== "") {
      obj.receiver = message.receiver;
    }
    if (message.controlledMode !== undefined) {
      obj.controlledMode = ControlledMode.toJSON(message.controlledMode);
    }
    if (message.heartbeatInterval !== undefined) {
      obj.heartbeatInterval = Duration.toJSON(message.heartbeatInterval);
    }
    if (message.writesDoneGracePeriod !== undefined) {
      obj.writesDoneGracePeriod = Duration.toJSON(message.writesDoneGracePeriod);
    }
    return obj;
  },

  create(base?: DeepPartial<ReceiveEventsRequest_SetupRequest>): ReceiveEventsRequest_SetupRequest {
    return ReceiveEventsRequest_SetupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReceiveEventsRequest_SetupRequest>): ReceiveEventsRequest_SetupRequest {
    const message = createBaseReceiveEventsRequest_SetupRequest();
    message.cluster = object.cluster ?? "";
    message.stream = object.stream ?? "";
    message.receiver = object.receiver ?? "";
    message.controlledMode = (object.controlledMode !== undefined && object.controlledMode !== null)
      ? ControlledMode.fromPartial(object.controlledMode)
      : undefined;
    message.heartbeatInterval = (object.heartbeatInterval !== undefined && object.heartbeatInterval !== null)
      ? Duration.fromPartial(object.heartbeatInterval)
      : undefined;
    message.writesDoneGracePeriod =
      (object.writesDoneGracePeriod !== undefined && object.writesDoneGracePeriod !== null)
        ? Duration.fromPartial(object.writesDoneGracePeriod)
        : undefined;
    return message;
  },
};

function createBaseEventUpdate(): EventUpdate {
  return { stream: "", event: "", series: "", updateTime: undefined, offset: Long.ZERO };
}

export const EventUpdate: MessageFns<EventUpdate> = {
  encode(message: EventUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stream !== "") {
      writer.uint32(10).string(message.stream);
    }
    if (message.event !== "") {
      writer.uint32(18).string(message.event);
    }
    if (message.series !== "") {
      writer.uint32(26).string(message.series);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (!message.offset.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.offset.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stream = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.event = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.series = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventUpdate {
    return {
      stream: isSet(object.stream) ? globalThis.String(object.stream) : "",
      event: isSet(object.event) ? globalThis.String(object.event) : "",
      series: isSet(object.series) ? globalThis.String(object.series) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.ZERO,
    };
  },

  toJSON(message: EventUpdate): unknown {
    const obj: any = {};
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    if (message.event !== "") {
      obj.event = message.event;
    }
    if (message.series !== "") {
      obj.series = message.series;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (!message.offset.equals(Long.ZERO)) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EventUpdate>): EventUpdate {
    return EventUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventUpdate>): EventUpdate {
    const message = createBaseEventUpdate();
    message.stream = object.stream ?? "";
    message.event = object.event ?? "";
    message.series = object.series ?? "";
    message.updateTime = object.updateTime ?? undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.ZERO;
    return message;
  },
};

function createBaseReceiveEventsControlResponse(): ReceiveEventsControlResponse {
  return { heartbeat: undefined, writesDoneRequest: undefined };
}

export const ReceiveEventsControlResponse: MessageFns<ReceiveEventsControlResponse> = {
  encode(message: ReceiveEventsControlResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.heartbeat !== undefined) {
      writer.uint32(8).bool(message.heartbeat);
    }
    if (message.writesDoneRequest !== undefined) {
      writer.uint32(16).bool(message.writesDoneRequest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiveEventsControlResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiveEventsControlResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heartbeat = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.writesDoneRequest = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiveEventsControlResponse {
    return {
      heartbeat: isSet(object.heartbeat) ? globalThis.Boolean(object.heartbeat) : undefined,
      writesDoneRequest: isSet(object.writesDoneRequest) ? globalThis.Boolean(object.writesDoneRequest) : undefined,
    };
  },

  toJSON(message: ReceiveEventsControlResponse): unknown {
    const obj: any = {};
    if (message.heartbeat !== undefined) {
      obj.heartbeat = message.heartbeat;
    }
    if (message.writesDoneRequest !== undefined) {
      obj.writesDoneRequest = message.writesDoneRequest;
    }
    return obj;
  },

  create(base?: DeepPartial<ReceiveEventsControlResponse>): ReceiveEventsControlResponse {
    return ReceiveEventsControlResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReceiveEventsControlResponse>): ReceiveEventsControlResponse {
    const message = createBaseReceiveEventsControlResponse();
    message.heartbeat = object.heartbeat ?? undefined;
    message.writesDoneRequest = object.writesDoneRequest ?? undefined;
    return message;
  },
};

function createBaseReceiveEventsResponse(): ReceiveEventsResponse {
  return { eventUpdate: undefined, control: undefined };
}

export const ReceiveEventsResponse: MessageFns<ReceiveEventsResponse> = {
  encode(message: ReceiveEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventUpdate !== undefined) {
      EventUpdate.encode(message.eventUpdate, writer.uint32(10).fork()).join();
    }
    if (message.control !== undefined) {
      ReceiveEventsControlResponse.encode(message.control, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceiveEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiveEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventUpdate = EventUpdate.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.control = ReceiveEventsControlResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiveEventsResponse {
    return {
      eventUpdate: isSet(object.eventUpdate) ? EventUpdate.fromJSON(object.eventUpdate) : undefined,
      control: isSet(object.control) ? ReceiveEventsControlResponse.fromJSON(object.control) : undefined,
    };
  },

  toJSON(message: ReceiveEventsResponse): unknown {
    const obj: any = {};
    if (message.eventUpdate !== undefined) {
      obj.eventUpdate = EventUpdate.toJSON(message.eventUpdate);
    }
    if (message.control !== undefined) {
      obj.control = ReceiveEventsControlResponse.toJSON(message.control);
    }
    return obj;
  },

  create(base?: DeepPartial<ReceiveEventsResponse>): ReceiveEventsResponse {
    return ReceiveEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReceiveEventsResponse>): ReceiveEventsResponse {
    const message = createBaseReceiveEventsResponse();
    message.eventUpdate = (object.eventUpdate !== undefined && object.eventUpdate !== null)
      ? EventUpdate.fromPartial(object.eventUpdate)
      : undefined;
    message.control = (object.control !== undefined && object.control !== null)
      ? ReceiveEventsControlResponse.fromPartial(object.control)
      : undefined;
    return message;
  },
};

function createBaseLease(): Lease {
  return { id: "", series: "", owner: "", expireTime: undefined, leaseType: 0 };
}

export const Lease: MessageFns<Lease> = {
  encode(message: Lease, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.series !== "") {
      writer.uint32(18).string(message.series);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(34).fork()).join();
    }
    if (message.leaseType !== 0) {
      writer.uint32(40).int32(message.leaseType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Lease {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLease();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.series = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.leaseType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Lease {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      series: isSet(object.series) ? globalThis.String(object.series) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      leaseType: isSet(object.leaseType) ? leaseTypeFromJSON(object.leaseType) : 0,
    };
  },

  toJSON(message: Lease): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.series !== "") {
      obj.series = message.series;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.leaseType !== 0) {
      obj.leaseType = leaseTypeToJSON(message.leaseType);
    }
    return obj;
  },

  create(base?: DeepPartial<Lease>): Lease {
    return Lease.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Lease>): Lease {
    const message = createBaseLease();
    message.id = object.id ?? "";
    message.series = object.series ?? "";
    message.owner = object.owner ?? "";
    message.expireTime = object.expireTime ?? undefined;
    message.leaseType = object.leaseType ?? 0;
    return message;
  },
};

function createBaseAcquireLeaseRequest(): AcquireLeaseRequest {
  return { series: "", owner: "", term: undefined, leaseType: 0 };
}

export const AcquireLeaseRequest: MessageFns<AcquireLeaseRequest> = {
  encode(message: AcquireLeaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.series !== "") {
      writer.uint32(10).string(message.series);
    }
    if (message.owner !== "") {
      writer.uint32(18).string(message.owner);
    }
    if (message.term !== undefined) {
      Duration.encode(message.term, writer.uint32(26).fork()).join();
    }
    if (message.leaseType !== 0) {
      writer.uint32(32).int32(message.leaseType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcquireLeaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcquireLeaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.series = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.term = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.leaseType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcquireLeaseRequest {
    return {
      series: isSet(object.series) ? globalThis.String(object.series) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      term: isSet(object.term) ? Duration.fromJSON(object.term) : undefined,
      leaseType: isSet(object.leaseType) ? leaseTypeFromJSON(object.leaseType) : 0,
    };
  },

  toJSON(message: AcquireLeaseRequest): unknown {
    const obj: any = {};
    if (message.series !== "") {
      obj.series = message.series;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.term !== undefined) {
      obj.term = Duration.toJSON(message.term);
    }
    if (message.leaseType !== 0) {
      obj.leaseType = leaseTypeToJSON(message.leaseType);
    }
    return obj;
  },

  create(base?: DeepPartial<AcquireLeaseRequest>): AcquireLeaseRequest {
    return AcquireLeaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcquireLeaseRequest>): AcquireLeaseRequest {
    const message = createBaseAcquireLeaseRequest();
    message.series = object.series ?? "";
    message.owner = object.owner ?? "";
    message.term = (object.term !== undefined && object.term !== null) ? Duration.fromPartial(object.term) : undefined;
    message.leaseType = object.leaseType ?? 0;
    return message;
  },
};

function createBaseRenewLeaseRequest(): RenewLeaseRequest {
  return { id: "", series: "", owner: "", term: undefined };
}

export const RenewLeaseRequest: MessageFns<RenewLeaseRequest> = {
  encode(message: RenewLeaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.series !== "") {
      writer.uint32(18).string(message.series);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.term !== undefined) {
      Duration.encode(message.term, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewLeaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewLeaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.series = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.term = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewLeaseRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      series: isSet(object.series) ? globalThis.String(object.series) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      term: isSet(object.term) ? Duration.fromJSON(object.term) : undefined,
    };
  },

  toJSON(message: RenewLeaseRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.series !== "") {
      obj.series = message.series;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.term !== undefined) {
      obj.term = Duration.toJSON(message.term);
    }
    return obj;
  },

  create(base?: DeepPartial<RenewLeaseRequest>): RenewLeaseRequest {
    return RenewLeaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenewLeaseRequest>): RenewLeaseRequest {
    const message = createBaseRenewLeaseRequest();
    message.id = object.id ?? "";
    message.series = object.series ?? "";
    message.owner = object.owner ?? "";
    message.term = (object.term !== undefined && object.term !== null) ? Duration.fromPartial(object.term) : undefined;
    return message;
  },
};

function createBaseReleaseLeaseRequest(): ReleaseLeaseRequest {
  return { id: "", series: "", owner: "" };
}

export const ReleaseLeaseRequest: MessageFns<ReleaseLeaseRequest> = {
  encode(message: ReleaseLeaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.series !== "") {
      writer.uint32(18).string(message.series);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseLeaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseLeaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.series = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseLeaseRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      series: isSet(object.series) ? globalThis.String(object.series) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
    };
  },

  toJSON(message: ReleaseLeaseRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.series !== "") {
      obj.series = message.series;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create(base?: DeepPartial<ReleaseLeaseRequest>): ReleaseLeaseRequest {
    return ReleaseLeaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReleaseLeaseRequest>): ReleaseLeaseRequest {
    const message = createBaseReleaseLeaseRequest();
    message.id = object.id ?? "";
    message.series = object.series ?? "";
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseReleaseLeaseResponse(): ReleaseLeaseResponse {
  return {};
}

export const ReleaseLeaseResponse: MessageFns<ReleaseLeaseResponse> = {
  encode(_: ReleaseLeaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseLeaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseLeaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ReleaseLeaseResponse {
    return {};
  },

  toJSON(_: ReleaseLeaseResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ReleaseLeaseResponse>): ReleaseLeaseResponse {
    return ReleaseLeaseResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ReleaseLeaseResponse>): ReleaseLeaseResponse {
    const message = createBaseReleaseLeaseResponse();
    return message;
  },
};

function createBaseRequestMetadata(): RequestMetadata {
  return { stream: "", event: "", series: "", leaseId: "", owner: "", leaseTerm: undefined };
}

export const RequestMetadata: MessageFns<RequestMetadata> = {
  encode(message: RequestMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stream !== "") {
      writer.uint32(10).string(message.stream);
    }
    if (message.event !== "") {
      writer.uint32(18).string(message.event);
    }
    if (message.series !== "") {
      writer.uint32(26).string(message.series);
    }
    if (message.leaseId !== "") {
      writer.uint32(34).string(message.leaseId);
    }
    if (message.owner !== "") {
      writer.uint32(42).string(message.owner);
    }
    if (message.leaseTerm !== undefined) {
      Duration.encode(message.leaseTerm, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stream = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.event = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.series = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.leaseId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.leaseTerm = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMetadata {
    return {
      stream: isSet(object.stream) ? globalThis.String(object.stream) : "",
      event: isSet(object.event) ? globalThis.String(object.event) : "",
      series: isSet(object.series) ? globalThis.String(object.series) : "",
      leaseId: isSet(object.leaseId) ? globalThis.String(object.leaseId) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      leaseTerm: isSet(object.leaseTerm) ? Duration.fromJSON(object.leaseTerm) : undefined,
    };
  },

  toJSON(message: RequestMetadata): unknown {
    const obj: any = {};
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    if (message.event !== "") {
      obj.event = message.event;
    }
    if (message.series !== "") {
      obj.series = message.series;
    }
    if (message.leaseId !== "") {
      obj.leaseId = message.leaseId;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.leaseTerm !== undefined) {
      obj.leaseTerm = Duration.toJSON(message.leaseTerm);
    }
    return obj;
  },

  create(base?: DeepPartial<RequestMetadata>): RequestMetadata {
    return RequestMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestMetadata>): RequestMetadata {
    const message = createBaseRequestMetadata();
    message.stream = object.stream ?? "";
    message.event = object.event ?? "";
    message.series = object.series ?? "";
    message.leaseId = object.leaseId ?? "";
    message.owner = object.owner ?? "";
    message.leaseTerm = (object.leaseTerm !== undefined && object.leaseTerm !== null)
      ? Duration.fromPartial(object.leaseTerm)
      : undefined;
    return message;
  },
};

function createBaseSendPacketsRequest(): SendPacketsRequest {
  return { packet: undefined, metadata: undefined };
}

export const SendPacketsRequest: MessageFns<SendPacketsRequest> = {
  encode(message: SendPacketsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packet !== undefined) {
      Packet.encode(message.packet, writer.uint32(10).fork()).join();
    }
    if (message.metadata !== undefined) {
      RequestMetadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendPacketsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendPacketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.packet = Packet.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metadata = RequestMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendPacketsRequest {
    return {
      packet: isSet(object.packet) ? Packet.fromJSON(object.packet) : undefined,
      metadata: isSet(object.metadata) ? RequestMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: SendPacketsRequest): unknown {
    const obj: any = {};
    if (message.packet !== undefined) {
      obj.packet = Packet.toJSON(message.packet);
    }
    if (message.metadata !== undefined) {
      obj.metadata = RequestMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<SendPacketsRequest>): SendPacketsRequest {
    return SendPacketsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendPacketsRequest>): SendPacketsRequest {
    const message = createBaseSendPacketsRequest();
    message.packet = (object.packet !== undefined && object.packet !== null)
      ? Packet.fromPartial(object.packet)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? RequestMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseSendPacketsResponse(): SendPacketsResponse {
  return {};
}

export const SendPacketsResponse: MessageFns<SendPacketsResponse> = {
  encode(_: SendPacketsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendPacketsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendPacketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SendPacketsResponse {
    return {};
  },

  toJSON(_: SendPacketsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SendPacketsResponse>): SendPacketsResponse {
    return SendPacketsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SendPacketsResponse>): SendPacketsResponse {
    const message = createBaseSendPacketsResponse();
    return message;
  },
};

function createBaseReceivePacketsRequest(): ReceivePacketsRequest {
  return { setupRequest: undefined, commitRequest: undefined };
}

export const ReceivePacketsRequest: MessageFns<ReceivePacketsRequest> = {
  encode(message: ReceivePacketsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.setupRequest !== undefined) {
      ReceivePacketsRequest_SetupRequest.encode(message.setupRequest, writer.uint32(50).fork()).join();
    }
    if (message.commitRequest !== undefined) {
      CommitRequest.encode(message.commitRequest, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceivePacketsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceivePacketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.setupRequest = ReceivePacketsRequest_SetupRequest.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.commitRequest = CommitRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceivePacketsRequest {
    return {
      setupRequest: isSet(object.setupRequest)
        ? ReceivePacketsRequest_SetupRequest.fromJSON(object.setupRequest)
        : undefined,
      commitRequest: isSet(object.commitRequest) ? CommitRequest.fromJSON(object.commitRequest) : undefined,
    };
  },

  toJSON(message: ReceivePacketsRequest): unknown {
    const obj: any = {};
    if (message.setupRequest !== undefined) {
      obj.setupRequest = ReceivePacketsRequest_SetupRequest.toJSON(message.setupRequest);
    }
    if (message.commitRequest !== undefined) {
      obj.commitRequest = CommitRequest.toJSON(message.commitRequest);
    }
    return obj;
  },

  create(base?: DeepPartial<ReceivePacketsRequest>): ReceivePacketsRequest {
    return ReceivePacketsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReceivePacketsRequest>): ReceivePacketsRequest {
    const message = createBaseReceivePacketsRequest();
    message.setupRequest = (object.setupRequest !== undefined && object.setupRequest !== null)
      ? ReceivePacketsRequest_SetupRequest.fromPartial(object.setupRequest)
      : undefined;
    message.commitRequest = (object.commitRequest !== undefined && object.commitRequest !== null)
      ? CommitRequest.fromPartial(object.commitRequest)
      : undefined;
    return message;
  },
};

function createBaseReceivePacketsRequest_SetupRequest(): ReceivePacketsRequest_SetupRequest {
  return {
    eagerReceiveMode: undefined,
    controlledReceiveMode: undefined,
    metadata: undefined,
    receiver: "",
    heartbeatInterval: undefined,
    writesDoneGracePeriod: undefined,
  };
}

export const ReceivePacketsRequest_SetupRequest: MessageFns<ReceivePacketsRequest_SetupRequest> = {
  encode(message: ReceivePacketsRequest_SetupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eagerReceiveMode !== undefined) {
      EagerMode.encode(message.eagerReceiveMode, writer.uint32(26).fork()).join();
    }
    if (message.controlledReceiveMode !== undefined) {
      ControlledMode.encode(message.controlledReceiveMode, writer.uint32(34).fork()).join();
    }
    if (message.metadata !== undefined) {
      RequestMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.receiver !== "") {
      writer.uint32(18).string(message.receiver);
    }
    if (message.heartbeatInterval !== undefined) {
      Duration.encode(message.heartbeatInterval, writer.uint32(42).fork()).join();
    }
    if (message.writesDoneGracePeriod !== undefined) {
      Duration.encode(message.writesDoneGracePeriod, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceivePacketsRequest_SetupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceivePacketsRequest_SetupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eagerReceiveMode = EagerMode.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.controlledReceiveMode = ControlledMode.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = RequestMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.receiver = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.heartbeatInterval = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.writesDoneGracePeriod = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceivePacketsRequest_SetupRequest {
    return {
      eagerReceiveMode: isSet(object.eagerReceiveMode) ? EagerMode.fromJSON(object.eagerReceiveMode) : undefined,
      controlledReceiveMode: isSet(object.controlledReceiveMode)
        ? ControlledMode.fromJSON(object.controlledReceiveMode)
        : undefined,
      metadata: isSet(object.metadata) ? RequestMetadata.fromJSON(object.metadata) : undefined,
      receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
      heartbeatInterval: isSet(object.heartbeatInterval) ? Duration.fromJSON(object.heartbeatInterval) : undefined,
      writesDoneGracePeriod: isSet(object.writesDoneGracePeriod)
        ? Duration.fromJSON(object.writesDoneGracePeriod)
        : undefined,
    };
  },

  toJSON(message: ReceivePacketsRequest_SetupRequest): unknown {
    const obj: any = {};
    if (message.eagerReceiveMode !== undefined) {
      obj.eagerReceiveMode = EagerMode.toJSON(message.eagerReceiveMode);
    }
    if (message.controlledReceiveMode !== undefined) {
      obj.controlledReceiveMode = ControlledMode.toJSON(message.controlledReceiveMode);
    }
    if (message.metadata !== undefined) {
      obj.metadata = RequestMetadata.toJSON(message.metadata);
    }
    if (message.receiver !== "") {
      obj.receiver = message.receiver;
    }
    if (message.heartbeatInterval !== undefined) {
      obj.heartbeatInterval = Duration.toJSON(message.heartbeatInterval);
    }
    if (message.writesDoneGracePeriod !== undefined) {
      obj.writesDoneGracePeriod = Duration.toJSON(message.writesDoneGracePeriod);
    }
    return obj;
  },

  create(base?: DeepPartial<ReceivePacketsRequest_SetupRequest>): ReceivePacketsRequest_SetupRequest {
    return ReceivePacketsRequest_SetupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReceivePacketsRequest_SetupRequest>): ReceivePacketsRequest_SetupRequest {
    const message = createBaseReceivePacketsRequest_SetupRequest();
    message.eagerReceiveMode = (object.eagerReceiveMode !== undefined && object.eagerReceiveMode !== null)
      ? EagerMode.fromPartial(object.eagerReceiveMode)
      : undefined;
    message.controlledReceiveMode =
      (object.controlledReceiveMode !== undefined && object.controlledReceiveMode !== null)
        ? ControlledMode.fromPartial(object.controlledReceiveMode)
        : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? RequestMetadata.fromPartial(object.metadata)
      : undefined;
    message.receiver = object.receiver ?? "";
    message.heartbeatInterval = (object.heartbeatInterval !== undefined && object.heartbeatInterval !== null)
      ? Duration.fromPartial(object.heartbeatInterval)
      : undefined;
    message.writesDoneGracePeriod =
      (object.writesDoneGracePeriod !== undefined && object.writesDoneGracePeriod !== null)
        ? Duration.fromPartial(object.writesDoneGracePeriod)
        : undefined;
    return message;
  },
};

function createBaseReceivePacketsControlResponse(): ReceivePacketsControlResponse {
  return { heartbeat: undefined, writesDoneRequest: undefined };
}

export const ReceivePacketsControlResponse: MessageFns<ReceivePacketsControlResponse> = {
  encode(message: ReceivePacketsControlResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.heartbeat !== undefined) {
      writer.uint32(8).bool(message.heartbeat);
    }
    if (message.writesDoneRequest !== undefined) {
      writer.uint32(16).bool(message.writesDoneRequest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceivePacketsControlResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceivePacketsControlResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.heartbeat = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.writesDoneRequest = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceivePacketsControlResponse {
    return {
      heartbeat: isSet(object.heartbeat) ? globalThis.Boolean(object.heartbeat) : undefined,
      writesDoneRequest: isSet(object.writesDoneRequest) ? globalThis.Boolean(object.writesDoneRequest) : undefined,
    };
  },

  toJSON(message: ReceivePacketsControlResponse): unknown {
    const obj: any = {};
    if (message.heartbeat !== undefined) {
      obj.heartbeat = message.heartbeat;
    }
    if (message.writesDoneRequest !== undefined) {
      obj.writesDoneRequest = message.writesDoneRequest;
    }
    return obj;
  },

  create(base?: DeepPartial<ReceivePacketsControlResponse>): ReceivePacketsControlResponse {
    return ReceivePacketsControlResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReceivePacketsControlResponse>): ReceivePacketsControlResponse {
    const message = createBaseReceivePacketsControlResponse();
    message.heartbeat = object.heartbeat ?? undefined;
    message.writesDoneRequest = object.writesDoneRequest ?? undefined;
    return message;
  },
};

function createBaseReceivePacketsResponse(): ReceivePacketsResponse {
  return { packet: undefined, control: undefined };
}

export const ReceivePacketsResponse: MessageFns<ReceivePacketsResponse> = {
  encode(message: ReceivePacketsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packet !== undefined) {
      Packet.encode(message.packet, writer.uint32(10).fork()).join();
    }
    if (message.control !== undefined) {
      ReceivePacketsControlResponse.encode(message.control, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceivePacketsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceivePacketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.packet = Packet.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.control = ReceivePacketsControlResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceivePacketsResponse {
    return {
      packet: isSet(object.packet) ? Packet.fromJSON(object.packet) : undefined,
      control: isSet(object.control) ? ReceivePacketsControlResponse.fromJSON(object.control) : undefined,
    };
  },

  toJSON(message: ReceivePacketsResponse): unknown {
    const obj: any = {};
    if (message.packet !== undefined) {
      obj.packet = Packet.toJSON(message.packet);
    }
    if (message.control !== undefined) {
      obj.control = ReceivePacketsControlResponse.toJSON(message.control);
    }
    return obj;
  },

  create(base?: DeepPartial<ReceivePacketsResponse>): ReceivePacketsResponse {
    return ReceivePacketsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReceivePacketsResponse>): ReceivePacketsResponse {
    const message = createBaseReceivePacketsResponse();
    message.packet = (object.packet !== undefined && object.packet !== null)
      ? Packet.fromPartial(object.packet)
      : undefined;
    message.control = (object.control !== undefined && object.control !== null)
      ? ReceivePacketsControlResponse.fromPartial(object.control)
      : undefined;
    return message;
  },
};

function createBaseEagerMode(): EagerMode {
  return {};
}

export const EagerMode: MessageFns<EagerMode> = {
  encode(_: EagerMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EagerMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEagerMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EagerMode {
    return {};
  },

  toJSON(_: EagerMode): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<EagerMode>): EagerMode {
    return EagerMode.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<EagerMode>): EagerMode {
    const message = createBaseEagerMode();
    return message;
  },
};

function createBaseControlledMode(): ControlledMode {
  return { startingLogicalOffset: undefined, fallbackStartingOffset: "" };
}

export const ControlledMode: MessageFns<ControlledMode> = {
  encode(message: ControlledMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startingLogicalOffset !== undefined) {
      writer.uint32(10).string(message.startingLogicalOffset);
    }
    if (message.fallbackStartingOffset !== "") {
      writer.uint32(18).string(message.fallbackStartingOffset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlledMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlledMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startingLogicalOffset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fallbackStartingOffset = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlledMode {
    return {
      startingLogicalOffset: isSet(object.startingLogicalOffset)
        ? globalThis.String(object.startingLogicalOffset)
        : undefined,
      fallbackStartingOffset: isSet(object.fallbackStartingOffset)
        ? globalThis.String(object.fallbackStartingOffset)
        : "",
    };
  },

  toJSON(message: ControlledMode): unknown {
    const obj: any = {};
    if (message.startingLogicalOffset !== undefined) {
      obj.startingLogicalOffset = message.startingLogicalOffset;
    }
    if (message.fallbackStartingOffset !== "") {
      obj.fallbackStartingOffset = message.fallbackStartingOffset;
    }
    return obj;
  },

  create(base?: DeepPartial<ControlledMode>): ControlledMode {
    return ControlledMode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ControlledMode>): ControlledMode {
    const message = createBaseControlledMode();
    message.startingLogicalOffset = object.startingLogicalOffset ?? undefined;
    message.fallbackStartingOffset = object.fallbackStartingOffset ?? "";
    return message;
  },
};

function createBaseCommitRequest(): CommitRequest {
  return { offset: Long.ZERO };
}

export const CommitRequest: MessageFns<CommitRequest> = {
  encode(message: CommitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.offset.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.offset.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitRequest {
    return { offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.ZERO };
  },

  toJSON(message: CommitRequest): unknown {
    const obj: any = {};
    if (!message.offset.equals(Long.ZERO)) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<CommitRequest>): CommitRequest {
    return CommitRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitRequest>): CommitRequest {
    const message = createBaseCommitRequest();
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.ZERO;
    return message;
  },
};

/** Streaming service for receiving and sending packets. */
export type StreamingServiceDefinition = typeof StreamingServiceDefinition;
export const StreamingServiceDefinition = {
  name: "StreamingService",
  fullName: "google.cloud.visionai.v1alpha1.StreamingService",
  methods: {
    /** Send packets to the series. */
    sendPackets: {
      name: "SendPackets",
      requestType: SendPacketsRequest,
      requestStream: true,
      responseType: SendPacketsResponse,
      responseStream: true,
      options: {},
    },
    /** Receive packets from the series. */
    receivePackets: {
      name: "ReceivePackets",
      requestType: ReceivePacketsRequest,
      requestStream: true,
      responseType: ReceivePacketsResponse,
      responseStream: true,
      options: {},
    },
    /** Receive events given the stream name. */
    receiveEvents: {
      name: "ReceiveEvents",
      requestType: ReceiveEventsRequest,
      requestStream: true,
      responseType: ReceiveEventsResponse,
      responseStream: true,
      options: {},
    },
    /** AcquireLease acquires a lease. */
    acquireLease: {
      name: "AcquireLease",
      requestType: AcquireLeaseRequest,
      requestStream: false,
      responseType: Lease,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              79,
              58,
              1,
              42,
              34,
              74,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              115,
              101,
              114,
              105,
              101,
              115,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              97,
              99,
              113,
              117,
              105,
              114,
              101,
              76,
              101,
              97,
              115,
              101,
            ]),
          ],
        },
      },
    },
    /** RenewLease renews a lease. */
    renewLease: {
      name: "RenewLease",
      requestType: RenewLeaseRequest,
      requestStream: false,
      responseType: Lease,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              77,
              58,
              1,
              42,
              34,
              72,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              115,
              101,
              114,
              105,
              101,
              115,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              110,
              101,
              119,
              76,
              101,
              97,
              115,
              101,
            ]),
          ],
        },
      },
    },
    /** RleaseLease releases a lease. */
    releaseLease: {
      name: "ReleaseLease",
      requestType: ReleaseLeaseRequest,
      requestStream: false,
      responseType: ReleaseLeaseResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              79,
              58,
              1,
              42,
              34,
              74,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              115,
              101,
              114,
              105,
              101,
              115,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              76,
              101,
              97,
              115,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface StreamingServiceImplementation<CallContextExt = {}> {
  /** Send packets to the series. */
  sendPackets(
    request: AsyncIterable<SendPacketsRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<SendPacketsResponse>>;
  /** Receive packets from the series. */
  receivePackets(
    request: AsyncIterable<ReceivePacketsRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<ReceivePacketsResponse>>;
  /** Receive events given the stream name. */
  receiveEvents(
    request: AsyncIterable<ReceiveEventsRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<ReceiveEventsResponse>>;
  /** AcquireLease acquires a lease. */
  acquireLease(request: AcquireLeaseRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Lease>>;
  /** RenewLease renews a lease. */
  renewLease(request: RenewLeaseRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Lease>>;
  /** RleaseLease releases a lease. */
  releaseLease(
    request: ReleaseLeaseRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReleaseLeaseResponse>>;
}

export interface StreamingServiceClient<CallOptionsExt = {}> {
  /** Send packets to the series. */
  sendPackets(
    request: AsyncIterable<DeepPartial<SendPacketsRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<SendPacketsResponse>;
  /** Receive packets from the series. */
  receivePackets(
    request: AsyncIterable<DeepPartial<ReceivePacketsRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<ReceivePacketsResponse>;
  /** Receive events given the stream name. */
  receiveEvents(
    request: AsyncIterable<DeepPartial<ReceiveEventsRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<ReceiveEventsResponse>;
  /** AcquireLease acquires a lease. */
  acquireLease(request: DeepPartial<AcquireLeaseRequest>, options?: CallOptions & CallOptionsExt): Promise<Lease>;
  /** RenewLease renews a lease. */
  renewLease(request: DeepPartial<RenewLeaseRequest>, options?: CallOptions & CallOptionsExt): Promise<Lease>;
  /** RleaseLease releases a lease. */
  releaseLease(
    request: DeepPartial<ReleaseLeaseRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReleaseLeaseResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
