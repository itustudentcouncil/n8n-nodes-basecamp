// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/visionai/v1alpha1/warehouse.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Any } from "../../../protobuf/any.js";
import { Duration } from "../../../protobuf/duration.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Struct } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { DateTime } from "../../../type/datetime.js";

export const protobufPackage = "google.cloud.visionai.v1alpha1";

/** Different types for a facet bucket. */
export enum FacetBucketType {
  /** FACET_BUCKET_TYPE_UNSPECIFIED - Unspecified type. */
  FACET_BUCKET_TYPE_UNSPECIFIED = 0,
  /** FACET_BUCKET_TYPE_VALUE - Value type. */
  FACET_BUCKET_TYPE_VALUE = 1,
  /** FACET_BUCKET_TYPE_DATETIME - Datetime type. */
  FACET_BUCKET_TYPE_DATETIME = 2,
  /** FACET_BUCKET_TYPE_FIXED_RANGE - Fixed Range type. */
  FACET_BUCKET_TYPE_FIXED_RANGE = 3,
  /** FACET_BUCKET_TYPE_CUSTOM_RANGE - Custom Range type. */
  FACET_BUCKET_TYPE_CUSTOM_RANGE = 4,
  UNRECOGNIZED = -1,
}

export function facetBucketTypeFromJSON(object: any): FacetBucketType {
  switch (object) {
    case 0:
    case "FACET_BUCKET_TYPE_UNSPECIFIED":
      return FacetBucketType.FACET_BUCKET_TYPE_UNSPECIFIED;
    case 1:
    case "FACET_BUCKET_TYPE_VALUE":
      return FacetBucketType.FACET_BUCKET_TYPE_VALUE;
    case 2:
    case "FACET_BUCKET_TYPE_DATETIME":
      return FacetBucketType.FACET_BUCKET_TYPE_DATETIME;
    case 3:
    case "FACET_BUCKET_TYPE_FIXED_RANGE":
      return FacetBucketType.FACET_BUCKET_TYPE_FIXED_RANGE;
    case 4:
    case "FACET_BUCKET_TYPE_CUSTOM_RANGE":
      return FacetBucketType.FACET_BUCKET_TYPE_CUSTOM_RANGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FacetBucketType.UNRECOGNIZED;
  }
}

export function facetBucketTypeToJSON(object: FacetBucketType): string {
  switch (object) {
    case FacetBucketType.FACET_BUCKET_TYPE_UNSPECIFIED:
      return "FACET_BUCKET_TYPE_UNSPECIFIED";
    case FacetBucketType.FACET_BUCKET_TYPE_VALUE:
      return "FACET_BUCKET_TYPE_VALUE";
    case FacetBucketType.FACET_BUCKET_TYPE_DATETIME:
      return "FACET_BUCKET_TYPE_DATETIME";
    case FacetBucketType.FACET_BUCKET_TYPE_FIXED_RANGE:
      return "FACET_BUCKET_TYPE_FIXED_RANGE";
    case FacetBucketType.FACET_BUCKET_TYPE_CUSTOM_RANGE:
      return "FACET_BUCKET_TYPE_CUSTOM_RANGE";
    case FacetBucketType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for CreateAssetRequest. */
export interface CreateAssetRequest {
  /**
   * Required. The parent resource where this asset will be created.
   * Format: projects/* /locations/* /corpora/*
   */
  parent: string;
  /** Required. The asset to create. */
  asset:
    | Asset
    | undefined;
  /**
   * Optional. The ID to use for the asset, which will become the final component of
   * the asset's resource name if user choose to specify. Otherwise, asset id
   * will be generated by system.
   *
   * This value should be up to 63 characters, and valid characters
   * are /[a-z][0-9]-/. The first character must be a letter, the last could be
   * a letter or a number.
   */
  assetId?: string | undefined;
}

/** Request message for GetAsset. */
export interface GetAssetRequest {
  /**
   * Required. The name of the asset to retrieve.
   * Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}
   */
  name: string;
}

/** Request message for ListAssets. */
export interface ListAssetsRequest {
  /**
   * Required. The parent, which owns this collection of assets.
   * Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}
   */
  parent: string;
  /**
   * The maximum number of assets to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 assets will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListAssets` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListAssets` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

/** Response message for ListAssets. */
export interface ListAssetsResponse {
  /** The assets from the specified corpus. */
  assets: Asset[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Response message for UpdateAsset. */
export interface UpdateAssetRequest {
  /**
   * Required. The asset to update.
   *
   * The asset's `name` field is used to identify the asset to be updated.
   * Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}
   */
  asset:
    | Asset
    | undefined;
  /** The list of fields to be updated. */
  updateMask: string[] | undefined;
}

/** Request message for DeleteAsset. */
export interface DeleteAssetRequest {
  /**
   * Required. The name of the asset to delete.
   * Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}
   */
  name: string;
}

/**
 * An asset is a resource in corpus. It represents a media object inside corpus,
 * contains metadata and another resource annotation. Different feature could be
 * applied to the asset to generate annotations. User could specified annotation
 * related to the target asset.
 */
export interface Asset {
  /**
   * Resource name of the asset.
   * Form:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}`
   */
  name: string;
  /**
   * The duration for which all media assets, associated metadata, and search
   * documents can exist. If not set, then it will using the default ttl in the
   * parent corpus resource.
   */
  ttl: Duration | undefined;
}

/** Request message of CreateCorpus API. */
export interface CreateCorpusRequest {
  /** Required. Form: `projects/{project_number}/locations/{location_id}` */
  parent: string;
  /** Required. The corpus to be created. */
  corpus: Corpus | undefined;
}

/** Metadata for CreateCorpus API. */
export interface CreateCorpusMetadata {
}

/**
 * Corpus is a set of video contents for management. Within a corpus, videos
 * share the same data schema. Search is also restricted within a single corpus.
 */
export interface Corpus {
  /**
   * Resource name of the corpus.
   * Form:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}`
   */
  name: string;
  /**
   * Required. The corpus name to shown in the UI. The name can be up to 32 characters
   * long.
   */
  displayName: string;
  /** Optional. Description of the corpus. Can be up to 25000 characters long. */
  description: string;
  /**
   * Required. The default TTL value for all assets under the corpus without a asset level
   * user-defined TTL with a maximum of 10 years. This is required for all
   * corpora.
   */
  defaultTtl: Duration | undefined;
}

/** Request message for GetCorpus. */
export interface GetCorpusRequest {
  /** Required. The resource name of the corpus to retrieve. */
  name: string;
}

/** Request message for UpdateCorpus. */
export interface UpdateCorpusRequest {
  /** Required. The corpus which replaces the resource on the server. */
  corpus:
    | Corpus
    | undefined;
  /** The list of fields to be updated. */
  updateMask: string[] | undefined;
}

/** Request message for ListCorpora. */
export interface ListCorporaRequest {
  /** Required. The resource name of the project from which to list corpora. */
  parent: string;
  /**
   * Requested page size. API may return fewer results than requested.
   * If negative, INVALID_ARGUMENT error will be returned.
   * If unspecified or 0, API will pick a default size, which is 10.
   * If the requested page size is larger than the maximum size, API will pick
   * use the maximum size, which is 20.
   */
  pageSize: number;
  /**
   * A token identifying a page of results for the server to return.
   * Typically obtained via [ListCorpora.next_page_token][] of the previous
   * [Warehouse.ListCorpora][google.cloud.visionai.v1alpha1.Warehouse.ListCorpora] call.
   */
  pageToken: string;
}

/** Response message for ListCorpora. */
export interface ListCorporaResponse {
  /** The corpora in the project. */
  corpora: Corpus[];
  /**
   * A token to retrieve next page of results.
   * Pass to [ListCorporaRequest.page_token][google.cloud.visionai.v1alpha1.ListCorporaRequest.page_token] to obtain that page.
   */
  nextPageToken: string;
}

/** Request message for DeleteCorpus. */
export interface DeleteCorpusRequest {
  /** Required. The resource name of the corpus to delete. */
  name: string;
}

/** Request message for CreateDataSchema. */
export interface CreateDataSchemaRequest {
  /**
   * Required. The parent resource where this data schema will be created.
   * Format: projects/* /locations/* /corpora/*
   */
  parent: string;
  /** Required. The data schema to create. */
  dataSchema: DataSchema | undefined;
}

/**
 * Data schema indicates how the user specified annotation is interpreted in the
 * system.
 */
export interface DataSchema {
  /**
   * Resource name of the data schema in the form of:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/dataSchemas/{data_schema}`
   * where {data_schema} part should be the same as the `key` field below.
   */
  name: string;
  /**
   * Required. The key of this data schema. This key should be matching the key of user
   * specified annotation and unique inside corpus. This value can be up to
   * 63 characters, and valid characters are /[a-z][0-9]-/. The first character
   * must be a letter, the last could be a letter or a number.
   */
  key: string;
  /** The schema details mapping to the key. */
  schemaDetails: DataSchemaDetails | undefined;
}

/**
 * Data schema details indicates the data type and the data struct corresponding
 * to the key of user specified annotation.
 */
export interface DataSchemaDetails {
  /** Type of the annotation. */
  type: DataSchemaDetails_DataType;
  /** Config for protobuf any type. */
  protoAnyConfig:
    | DataSchemaDetails_ProtoAnyConfig
    | undefined;
  /** The granularity associated with this DataSchema. */
  granularity: DataSchemaDetails_Granularity;
  /** The search strategy to be applied on the `key` above. */
  searchStrategy: DataSchemaDetails_SearchStrategy | undefined;
}

/** Data type of the annotation. */
export enum DataSchemaDetails_DataType {
  /** DATA_TYPE_UNSPECIFIED - Unspecified type. */
  DATA_TYPE_UNSPECIFIED = 0,
  /**
   * INTEGER - Integer type.
   * Allowed search strategies:
   * - DataSchema.SearchStrategy.NO_SEARCH,
   * - DataSchema.SearchStrategy.EXACT_SEARCH.
   *   Supports query by IntRangeArray.
   */
  INTEGER = 1,
  /**
   * FLOAT - Float type.
   * Allowed search strategies:
   * - DataSchema.SearchStrategy.NO_SEARCH,
   * - DataSchema.SearchStrategy.EXACT_SEARCH.
   *   Supports query by FloatRangeArray.
   */
  FLOAT = 2,
  /**
   * STRING - String type.
   * Allowed search strategies:
   * - DataSchema.SearchStrategy.NO_SEARCH,
   * - DataSchema.SearchStrategy.EXACT_SEARCH,
   * - DataSchema.SearchStrategy.SMART_SEARCH.
   */
  STRING = 3,
  /**
   * DATETIME - Supported formats:
   * %Y-%m-%dT%H:%M:%E*S%E*z (absl::RFC3339_full)
   * %Y-%m-%dT%H:%M:%E*S
   * %Y-%m-%dT%H:%M%E*z
   * %Y-%m-%dT%H:%M
   * %Y-%m-%dT%H%E*z
   * %Y-%m-%dT%H
   * %Y-%m-%d%E*z
   * %Y-%m-%d
   * %Y-%m
   * %Y
   * Allowed search strategies:
   * - DataSchema.SearchStrategy.NO_SEARCH,
   * - DataSchema.SearchStrategy.EXACT_SEARCH.
   *   Supports query by DateTimeRangeArray.
   */
  DATETIME = 5,
  /**
   * GEO_COORDINATE - Geo coordinate type.
   * Allowed search strategies:
   * - DataSchema.SearchStrategy.NO_SEARCH,
   * - DataSchema.SearchStrategy.EXACT_SEARCH.
   *   Supports query by GeoLocationArray.
   */
  GEO_COORDINATE = 7,
  /**
   * PROTO_ANY - Type to pass any proto as available in annotations.proto. Only use
   * internally.
   * Available proto types and its corresponding search behavior:
   * - ImageObjectDetectionPredictionResult, allows SMART_SEARCH on
   *   display_names and NO_SEARCH.
   * - ClassificationPredictionResult, allows SMART_SEARCH on display_names
   *   and NO_SEARCH.
   * - ImageSegmentationPredictionResult, allows NO_SEARCH.
   * - VideoActionRecognitionPredictionResult, allows SMART_SEARCH on
   *   display_name and NO_SEARCH.
   * - VideoObjectTrackingPredictionResult, allows SMART_SEARCH on
   *   display_name and NO_SEARCH.
   * - VideoClassificationPredictionResult, allows SMART_SEARCH on
   *   display_name and NO_SEARCH.
   * - OccupancyCountingPredictionResult, allows EXACT_SEARCH on
   *   stats.full_frame_count.count and NO_SEARCH.
   * - ObjectDetectionPredictionResult, allows SMART_SEARCH on
   *   identified_boxes.entity.label_string and NO_SEARCH.
   */
  PROTO_ANY = 8,
  /**
   * BOOLEAN - Boolean type.
   * Allowed search strategies:
   * - DataSchema.SearchStrategy.NO_SEARCH,
   * - DataSchema.SearchStrategy.EXACT_SEARCH.
   */
  BOOLEAN = 9,
  UNRECOGNIZED = -1,
}

export function dataSchemaDetails_DataTypeFromJSON(object: any): DataSchemaDetails_DataType {
  switch (object) {
    case 0:
    case "DATA_TYPE_UNSPECIFIED":
      return DataSchemaDetails_DataType.DATA_TYPE_UNSPECIFIED;
    case 1:
    case "INTEGER":
      return DataSchemaDetails_DataType.INTEGER;
    case 2:
    case "FLOAT":
      return DataSchemaDetails_DataType.FLOAT;
    case 3:
    case "STRING":
      return DataSchemaDetails_DataType.STRING;
    case 5:
    case "DATETIME":
      return DataSchemaDetails_DataType.DATETIME;
    case 7:
    case "GEO_COORDINATE":
      return DataSchemaDetails_DataType.GEO_COORDINATE;
    case 8:
    case "PROTO_ANY":
      return DataSchemaDetails_DataType.PROTO_ANY;
    case 9:
    case "BOOLEAN":
      return DataSchemaDetails_DataType.BOOLEAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSchemaDetails_DataType.UNRECOGNIZED;
  }
}

export function dataSchemaDetails_DataTypeToJSON(object: DataSchemaDetails_DataType): string {
  switch (object) {
    case DataSchemaDetails_DataType.DATA_TYPE_UNSPECIFIED:
      return "DATA_TYPE_UNSPECIFIED";
    case DataSchemaDetails_DataType.INTEGER:
      return "INTEGER";
    case DataSchemaDetails_DataType.FLOAT:
      return "FLOAT";
    case DataSchemaDetails_DataType.STRING:
      return "STRING";
    case DataSchemaDetails_DataType.DATETIME:
      return "DATETIME";
    case DataSchemaDetails_DataType.GEO_COORDINATE:
      return "GEO_COORDINATE";
    case DataSchemaDetails_DataType.PROTO_ANY:
      return "PROTO_ANY";
    case DataSchemaDetails_DataType.BOOLEAN:
      return "BOOLEAN";
    case DataSchemaDetails_DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The granularity of annotations under this DataSchema. */
export enum DataSchemaDetails_Granularity {
  /** GRANULARITY_UNSPECIFIED - Unspecified granularity. */
  GRANULARITY_UNSPECIFIED = 0,
  /** GRANULARITY_ASSET_LEVEL - Asset-level granularity (annotations must not contain partition info). */
  GRANULARITY_ASSET_LEVEL = 1,
  /** GRANULARITY_PARTITION_LEVEL - Partition-level granularity (annotations must contain partition info). */
  GRANULARITY_PARTITION_LEVEL = 2,
  UNRECOGNIZED = -1,
}

export function dataSchemaDetails_GranularityFromJSON(object: any): DataSchemaDetails_Granularity {
  switch (object) {
    case 0:
    case "GRANULARITY_UNSPECIFIED":
      return DataSchemaDetails_Granularity.GRANULARITY_UNSPECIFIED;
    case 1:
    case "GRANULARITY_ASSET_LEVEL":
      return DataSchemaDetails_Granularity.GRANULARITY_ASSET_LEVEL;
    case 2:
    case "GRANULARITY_PARTITION_LEVEL":
      return DataSchemaDetails_Granularity.GRANULARITY_PARTITION_LEVEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSchemaDetails_Granularity.UNRECOGNIZED;
  }
}

export function dataSchemaDetails_GranularityToJSON(object: DataSchemaDetails_Granularity): string {
  switch (object) {
    case DataSchemaDetails_Granularity.GRANULARITY_UNSPECIFIED:
      return "GRANULARITY_UNSPECIFIED";
    case DataSchemaDetails_Granularity.GRANULARITY_ASSET_LEVEL:
      return "GRANULARITY_ASSET_LEVEL";
    case DataSchemaDetails_Granularity.GRANULARITY_PARTITION_LEVEL:
      return "GRANULARITY_PARTITION_LEVEL";
    case DataSchemaDetails_Granularity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The configuration for `PROTO_ANY` data type. */
export interface DataSchemaDetails_ProtoAnyConfig {
  /** The type URI of the proto message. */
  typeUri: string;
}

/** The search strategy for annotations value of the `key`. */
export interface DataSchemaDetails_SearchStrategy {
  /**
   * The type of search strategy to be applied on the `key` above.
   * The allowed `search_strategy_type` is different for different data types,
   * which is documented in the DataSchemaDetails.DataType. Specifying
   * unsupported `search_strategy_type` for data types will result in
   * INVALID_ARGUMENT error.
   */
  searchStrategyType: DataSchemaDetails_SearchStrategy_SearchStrategyType;
}

/** The types of search strategies to be applied on the annotation key. */
export enum DataSchemaDetails_SearchStrategy_SearchStrategyType {
  /** NO_SEARCH - Annotatation values of the `key` above will not be searchable. */
  NO_SEARCH = 0,
  /**
   * EXACT_SEARCH - When searching with `key`, the value must be exactly as the annotation
   * value that has been ingested.
   */
  EXACT_SEARCH = 1,
  /**
   * SMART_SEARCH - When searching with `key`, Warehouse will perform broad search based on
   * semantic of the annotation value.
   */
  SMART_SEARCH = 2,
  UNRECOGNIZED = -1,
}

export function dataSchemaDetails_SearchStrategy_SearchStrategyTypeFromJSON(
  object: any,
): DataSchemaDetails_SearchStrategy_SearchStrategyType {
  switch (object) {
    case 0:
    case "NO_SEARCH":
      return DataSchemaDetails_SearchStrategy_SearchStrategyType.NO_SEARCH;
    case 1:
    case "EXACT_SEARCH":
      return DataSchemaDetails_SearchStrategy_SearchStrategyType.EXACT_SEARCH;
    case 2:
    case "SMART_SEARCH":
      return DataSchemaDetails_SearchStrategy_SearchStrategyType.SMART_SEARCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSchemaDetails_SearchStrategy_SearchStrategyType.UNRECOGNIZED;
  }
}

export function dataSchemaDetails_SearchStrategy_SearchStrategyTypeToJSON(
  object: DataSchemaDetails_SearchStrategy_SearchStrategyType,
): string {
  switch (object) {
    case DataSchemaDetails_SearchStrategy_SearchStrategyType.NO_SEARCH:
      return "NO_SEARCH";
    case DataSchemaDetails_SearchStrategy_SearchStrategyType.EXACT_SEARCH:
      return "EXACT_SEARCH";
    case DataSchemaDetails_SearchStrategy_SearchStrategyType.SMART_SEARCH:
      return "SMART_SEARCH";
    case DataSchemaDetails_SearchStrategy_SearchStrategyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for UpdateDataSchema. */
export interface UpdateDataSchemaRequest {
  /**
   * Required. The data schema's `name` field is used to identify the data schema to be
   * updated. Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}/dataSchemas/{data_schema}
   */
  dataSchema:
    | DataSchema
    | undefined;
  /** The list of fields to be updated. */
  updateMask: string[] | undefined;
}

/** Request message for GetDataSchema. */
export interface GetDataSchemaRequest {
  /**
   * Required. The name of the data schema to retrieve.
   * Format:
   * projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/dataSchemas/{data_schema_id}
   */
  name: string;
}

/** Request message for DeleteDataSchema. */
export interface DeleteDataSchemaRequest {
  /**
   * Required. The name of the data schema to delete.
   * Format:
   * projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/dataSchemas/{data_schema_id}
   */
  name: string;
}

/** Request message for ListDataSchemas. */
export interface ListDataSchemasRequest {
  /**
   * Required. The parent, which owns this collection of data schemas.
   * Format:
   * projects/{project_number}/locations/{location_id}/corpora/{corpus_id}
   */
  parent: string;
  /**
   * The maximum number of data schemas to return. The service may return fewer
   * than this value. If unspecified, at most 50 data schemas will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListDataSchemas` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListDataSchemas` must
   * match the call that provided the page token.
   */
  pageToken: string;
}

/** Response message for ListDataSchemas. */
export interface ListDataSchemasResponse {
  /** The data schemas from the specified corpus. */
  dataSchemas: DataSchema[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request message for CreateAnnotation. */
export interface CreateAnnotationRequest {
  /**
   * Required. The parent resource where this annotation will be created.
   * Format: projects/* /locations/* /corpora/* /assets/*
   */
  parent: string;
  /** Required. The annotation to create. */
  annotation:
    | Annotation
    | undefined;
  /**
   * Optional. The ID to use for the annotation, which will become the final component of
   * the annotation's resource name if user choose to specify. Otherwise,
   * annotation id will be generated by system.
   *
   * This value should be up to 63 characters, and valid characters
   * are /[a-z][0-9]-/. The first character must be a letter, the last could be
   * a letter or a number.
   */
  annotationId?: string | undefined;
}

/**
 * An annotation is a resource in asset. It represents a key-value mapping of
 * content in asset.
 */
export interface Annotation {
  /**
   * Resource name of the annotation.
   * Form:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}/annotations/{annotation}`
   */
  name: string;
  /** User provided annotation. */
  userSpecifiedAnnotation: UserSpecifiedAnnotation | undefined;
}

/** Annotation provided by users. */
export interface UserSpecifiedAnnotation {
  /** Required. Key of the annotation. The key must be set with type by CreateDataSchema. */
  key: string;
  /**
   * Value of the annotation. The value must be able to convert
   * to the type according to the data schema.
   */
  value:
    | AnnotationValue
    | undefined;
  /** Partition information in time and space for the sub-asset level annotation. */
  partition: Partition | undefined;
}

/** Location Coordinate Representation */
export interface GeoCoordinate {
  /** Latitude Coordinate. Degrees [-90 .. 90] */
  latitude: number;
  /** Longitude Coordinate. Degrees [-180 .. 180] */
  longitude: number;
}

/** Value of annotation, including all types available in data schema. */
export interface AnnotationValue {
  /** Value of int type annotation. */
  intValue?:
    | Long
    | undefined;
  /** Value of float type annotation. */
  floatValue?:
    | number
    | undefined;
  /** Value of string type annotation. */
  strValue?:
    | string
    | undefined;
  /** Value of date time type annotation. */
  datetimeValue?:
    | string
    | undefined;
  /** Value of geo coordinate type annotation. */
  geoCoordinate?:
    | GeoCoordinate
    | undefined;
  /** Value of any proto value. */
  protoAnyValue?:
    | Any
    | undefined;
  /** Value of boolean type annotation. */
  boolValue?:
    | boolean
    | undefined;
  /** Value of customized struct annotation. */
  customizedStructDataValue?: { [key: string]: any } | undefined;
}

/** Request message for GetAnnotation API. */
export interface ListAnnotationsRequest {
  /**
   * The parent, which owns this collection of annotations.
   * Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}
   */
  parent: string;
  /**
   * The maximum number of annotations to return. The service may return fewer
   * than this value. If unspecified, at most 50 annotations will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListAnnotations` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListAnnotations` must
   * match the call that provided the page token.
   */
  pageToken: string;
  /**
   * The filter applied to the returned list.
   * We only support filtering for the following fields:
   * `partition.temporal_partition.start_time`,
   * `partition.temporal_partition.end_time`, and `key`.
   * Timestamps are specified in the RFC-3339 format, and only one restriction
   * may be applied per field, joined by conjunctions.
   * Format:
   * "partition.temporal_partition.start_time > "2012-04-21T11:30:00-04:00" AND
   * partition.temporal_partition.end_time < "2012-04-22T11:30:00-04:00" AND
   * key = "example_key""
   */
  filter: string;
}

/** Request message for ListAnnotations API. */
export interface ListAnnotationsResponse {
  /** The annotations from the specified asset. */
  annotations: Annotation[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request message for GetAnnotation API. */
export interface GetAnnotationRequest {
  /**
   * Required. The name of the annotation to retrieve.
   * Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}/annotations/{annotation}
   */
  name: string;
}

/** Request message for UpdateAnnotation API. */
export interface UpdateAnnotationRequest {
  /**
   * Required. The annotation to update.
   * The annotation's `name` field is used to identify the annotation to be
   * updated. Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}/annotations/{annotation}
   */
  annotation:
    | Annotation
    | undefined;
  /** The list of fields to be updated. */
  updateMask: string[] | undefined;
}

/** Request message for DeleteAnnotation API. */
export interface DeleteAnnotationRequest {
  /**
   * Required. The name of the annotation to delete.
   * Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}/annotations/{annotation}
   */
  name: string;
}

/** Request message for CreateSearchConfig. */
export interface CreateSearchConfigRequest {
  /**
   * Required. The parent resource where this search configuration will be created.
   * Format: projects/* /locations/* /corpora/*
   */
  parent: string;
  /** Required. The search config to create. */
  searchConfig:
    | SearchConfig
    | undefined;
  /**
   * Required. ID to use for the new search config. Will become the final component of the
   * SearchConfig's resource name. This value should be up to 63 characters, and
   * valid characters are /[a-z][0-9]-_/. The first character must be a letter,
   * the last could be a letter or a number.
   */
  searchConfigId: string;
}

/** Request message for UpdateSearchConfig. */
export interface UpdateSearchConfigRequest {
  /**
   * Required. The search configuration to update.
   *
   * The search configuration's `name` field is used to identify the resource to
   * be updated. Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}/searchConfigs/{search_config}
   */
  searchConfig:
    | SearchConfig
    | undefined;
  /**
   * The list of fields to be updated. If left unset, all field paths will be
   * updated/overwritten.
   */
  updateMask: string[] | undefined;
}

/** Request message for GetSearchConfig. */
export interface GetSearchConfigRequest {
  /**
   * Required. The name of the search configuration to retrieve.
   * Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}/searchConfigs/{search_config}
   */
  name: string;
}

/** Request message for DeleteSearchConfig. */
export interface DeleteSearchConfigRequest {
  /**
   * Required. The name of the search configuration to delete.
   * Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}/searchConfigs/{search_config}
   */
  name: string;
}

/** Request message for ListSearchConfigs. */
export interface ListSearchConfigsRequest {
  /**
   * Required. The parent, which owns this collection of search configurations.
   * Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}
   */
  parent: string;
  /**
   * The maximum number of search configurations to return. The service may
   * return fewer than this value. If unspecified, a page size of 50 will be
   * used. The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListSearchConfigs` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListSearchConfigs` must match the call that provided the page
   * token.
   */
  pageToken: string;
}

/** Response message for ListSearchConfigs. */
export interface ListSearchConfigsResponse {
  /** The search configurations from the specified corpus. */
  searchConfigs: SearchConfig[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/**
 * SearchConfig stores different properties that will affect search
 * behaviors and search results.
 */
export interface SearchConfig {
  /**
   * Resource name of the search configuration.
   * For CustomSearchCriteria, search_config would be the search
   * operator name. For Facets, search_config would be the facet
   * dimension name.
   * Form:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/searchConfigs/{search_config}`
   */
  name: string;
  /** Establishes a FacetDimension and associated specifications. */
  facetProperty:
    | FacetProperty
    | undefined;
  /** Creates a mapping between a custom SearchCriteria and one or more UGA keys. */
  searchCriteriaProperty: SearchCriteriaProperty | undefined;
}

/** Central configuration for a facet. */
export interface FacetProperty {
  /** Fixed range facet bucket config. */
  fixedRangeBucketSpec?:
    | FacetProperty_FixedRangeBucketSpec
    | undefined;
  /** Custom range facet bucket config. */
  customRangeBucketSpec?:
    | FacetProperty_CustomRangeBucketSpec
    | undefined;
  /** Datetime range facet bucket config. */
  datetimeBucketSpec?:
    | FacetProperty_DateTimeBucketSpec
    | undefined;
  /**
   * Name of the facets, which are the dimensions users want to use to refine
   * search results. `mapped_fields` will match UserSpecifiedDataSchema keys.
   *
   * For example, user can add a bunch of UGAs with the same key, such as
   * player:adam, player:bob, player:charles. When multiple mapped_fields are
   * specified, will merge their value together as final facet value. E.g.
   * home_team: a, home_team:b, away_team:a, away_team:c, when facet_field =
   * [home_team, away_team], facet_value will be [a, b, c].
   *
   * UNLESS this is a 1:1 facet dimension (mapped_fields.size() == 1) AND the
   * mapped_field equals the parent SearchConfig.name, the parent must
   * also contain a SearchCriteriaProperty that maps to the same fields.
   * mapped_fields must not be empty.
   */
  mappedFields: string[];
  /** Display name of the facet. To be used by UI for facet rendering. */
  displayName: string;
  /**
   * Maximum number of unique bucket to return for one facet. Bucket number can
   * be large for high-cardinality facet such as "player". We only return top-n
   * most related ones to user. If it's <= 0, the server will decide the
   * appropriate result_size.
   */
  resultSize: Long;
  /** Facet bucket type e.g. value, range. */
  bucketType: FacetBucketType;
}

/**
 * If bucket type is FIXED_RANGE, specify how values are bucketized. Use
 * FixedRangeBucketSpec when you want to create multiple buckets with equal
 * granularities. Using integer bucket value as an example, when
 * bucket_start = 0, bucket_granularity = 10, bucket_count = 5, this facet
 * will be aggregated via the following buckets:
 * [-inf, 0), [0, 10), [10, 20), [20, 30), [30, inf).
 * Notably, bucket_count <= 1 is an invalid spec.
 */
export interface FacetProperty_FixedRangeBucketSpec {
  /**
   * Lower bound of the bucket. NOTE: Only integer type is currently supported
   * for this field.
   */
  bucketStart:
    | FacetValue
    | undefined;
  /**
   * Bucket granularity. NOTE: Only integer type is currently supported for
   * this field.
   */
  bucketGranularity:
    | FacetValue
    | undefined;
  /** Total number of buckets. */
  bucketCount: number;
}

/**
 * If bucket type is CUSTOM_RANGE, specify how values are bucketized. Use
 * integer bucket value as an example, when the endpoints are 0, 10, 100, and
 * 1000, we will generate the following facets:
 * [-inf, 0), [0, 10), [10, 100), [100, 1000), [1000, inf).
 * Notably:
 * - endpoints must be listed in ascending order. Otherwise, the SearchConfig
 *   API will reject the facet config.
 * - < 1 endpoints is an invalid spec.
 */
export interface FacetProperty_CustomRangeBucketSpec {
  /** Currently, only integer type is supported for this field. */
  endpoints: FacetValue[];
}

/** If bucket type is DATE, specify how date values are bucketized. */
export interface FacetProperty_DateTimeBucketSpec {
  /** Granularity of date type facet. */
  granularity: FacetProperty_DateTimeBucketSpec_Granularity;
}

/** Granularity enum for the datetime bucket. */
export enum FacetProperty_DateTimeBucketSpec_Granularity {
  /** GRANULARITY_UNSPECIFIED - Unspecified granularity. */
  GRANULARITY_UNSPECIFIED = 0,
  /** YEAR - Granularity is year. */
  YEAR = 1,
  /** MONTH - Granularity is month. */
  MONTH = 2,
  /** DAY - Granularity is day. */
  DAY = 3,
  UNRECOGNIZED = -1,
}

export function facetProperty_DateTimeBucketSpec_GranularityFromJSON(
  object: any,
): FacetProperty_DateTimeBucketSpec_Granularity {
  switch (object) {
    case 0:
    case "GRANULARITY_UNSPECIFIED":
      return FacetProperty_DateTimeBucketSpec_Granularity.GRANULARITY_UNSPECIFIED;
    case 1:
    case "YEAR":
      return FacetProperty_DateTimeBucketSpec_Granularity.YEAR;
    case 2:
    case "MONTH":
      return FacetProperty_DateTimeBucketSpec_Granularity.MONTH;
    case 3:
    case "DAY":
      return FacetProperty_DateTimeBucketSpec_Granularity.DAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FacetProperty_DateTimeBucketSpec_Granularity.UNRECOGNIZED;
  }
}

export function facetProperty_DateTimeBucketSpec_GranularityToJSON(
  object: FacetProperty_DateTimeBucketSpec_Granularity,
): string {
  switch (object) {
    case FacetProperty_DateTimeBucketSpec_Granularity.GRANULARITY_UNSPECIFIED:
      return "GRANULARITY_UNSPECIFIED";
    case FacetProperty_DateTimeBucketSpec_Granularity.YEAR:
      return "YEAR";
    case FacetProperty_DateTimeBucketSpec_Granularity.MONTH:
      return "MONTH";
    case FacetProperty_DateTimeBucketSpec_Granularity.DAY:
      return "DAY";
    case FacetProperty_DateTimeBucketSpec_Granularity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Central configuration for custom search criteria. */
export interface SearchCriteriaProperty {
  /**
   * Each mapped_field corresponds to a UGA key. To understand how this property
   * works, take the following example. In the SearchConfig table, the
   * user adds this entry:
   *   search_config {
   *     name: "person"
   *     search_criteria_property {
   *       mapped_fields: "player"
   *       mapped_fields: "coach"
   *     }
   *   }
   *
   * Now, when a user issues a query like:
   *   criteria {
   *     field: "person"
   *     text_array {
   *       txt_values: "Tom Brady"
   *       txt_values: "Bill Belichick"
   *     }
   *   }
   *
   * MWH search will return search documents where (player=Tom Brady ||
   * coach=Tom Brady || player=Bill Belichick || coach=Bill Belichick).
   */
  mappedFields: string[];
}

/** Definition of a single value with generic type. */
export interface FacetValue {
  /** String type value. */
  stringValue?:
    | string
    | undefined;
  /** Integer type value. */
  integerValue?:
    | Long
    | undefined;
  /** Datetime type value. */
  datetimeValue?: DateTime | undefined;
}

/** Holds the facet value, selections state, and metadata. */
export interface FacetBucket {
  /** Singular value. */
  value?:
    | FacetValue
    | undefined;
  /** Range value. */
  range?:
    | FacetBucket_Range
    | undefined;
  /**
   * Whether one facet bucket is selected. This field represents user's facet
   * selection. It is set by frontend in SearchVideosRequest.
   */
  selected: boolean;
}

/** The range of values [start, end) for which faceting is applied. */
export interface FacetBucket_Range {
  /** Start of the range. Non-existence indicates some bound (e.g. -inf). */
  start:
    | FacetValue
    | undefined;
  /** End of the range. Non-existence indicates some bound (e.g. inf). */
  end: FacetValue | undefined;
}

/**
 * A group of facet buckets to be passed back and forth between backend &
 * frontend.
 */
export interface FacetGroup {
  /** Unique id of the facet group. */
  facetId: string;
  /** Display name of the facet. To be used by UI for facet rendering. */
  displayName: string;
  /**
   * Buckets associated with the facet. E.g. for "Team" facet, the bucket
   * can be 49ers, patriots, etc.
   */
  buckets: FacetBucket[];
  /** Facet bucket type. */
  bucketType: FacetBucketType;
  /**
   * If true, return query matched annotations for this facet group's selection.
   * This option is only applicable for facets based on partition level
   * annotations. It supports the following facet values:
   *  - INTEGER
   *  - STRING (DataSchema.SearchStrategy.EXACT_SEARCH only)
   */
  fetchMatchedAnnotations: boolean;
}

/** Request message for IngestAsset API. */
export interface IngestAssetRequest {
  /**
   * Provides information for the data and the asset resource name that the
   * data belongs to. The first `IngestAssetRequest` message must only contain
   * a `Config` message.
   */
  config?:
    | IngestAssetRequest_Config
    | undefined;
  /** Data to be ingested. */
  timeIndexedData?: IngestAssetRequest_TimeIndexedData | undefined;
}

/** Configuration for the data. */
export interface IngestAssetRequest_Config {
  /** Type information for video data. */
  videoType?:
    | IngestAssetRequest_Config_VideoType
    | undefined;
  /** Required. The resource name of the asset that the ingested data belongs to. */
  asset: string;
}

/** Type information for video data. */
export interface IngestAssetRequest_Config_VideoType {
  /** Container format of the video data. */
  containerFormat: IngestAssetRequest_Config_VideoType_ContainerFormat;
}

/** Container format of the video. */
export enum IngestAssetRequest_Config_VideoType_ContainerFormat {
  /** CONTAINER_FORMAT_UNSPECIFIED - The default type, not supposed to be used. */
  CONTAINER_FORMAT_UNSPECIFIED = 0,
  /** CONTAINER_FORMAT_MP4 - Mp4 container format. */
  CONTAINER_FORMAT_MP4 = 1,
  UNRECOGNIZED = -1,
}

export function ingestAssetRequest_Config_VideoType_ContainerFormatFromJSON(
  object: any,
): IngestAssetRequest_Config_VideoType_ContainerFormat {
  switch (object) {
    case 0:
    case "CONTAINER_FORMAT_UNSPECIFIED":
      return IngestAssetRequest_Config_VideoType_ContainerFormat.CONTAINER_FORMAT_UNSPECIFIED;
    case 1:
    case "CONTAINER_FORMAT_MP4":
      return IngestAssetRequest_Config_VideoType_ContainerFormat.CONTAINER_FORMAT_MP4;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IngestAssetRequest_Config_VideoType_ContainerFormat.UNRECOGNIZED;
  }
}

export function ingestAssetRequest_Config_VideoType_ContainerFormatToJSON(
  object: IngestAssetRequest_Config_VideoType_ContainerFormat,
): string {
  switch (object) {
    case IngestAssetRequest_Config_VideoType_ContainerFormat.CONTAINER_FORMAT_UNSPECIFIED:
      return "CONTAINER_FORMAT_UNSPECIFIED";
    case IngestAssetRequest_Config_VideoType_ContainerFormat.CONTAINER_FORMAT_MP4:
      return "CONTAINER_FORMAT_MP4";
    case IngestAssetRequest_Config_VideoType_ContainerFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Contains the data and the corresponding time range this data is for. */
export interface IngestAssetRequest_TimeIndexedData {
  /** Data to be ingested. */
  data: Buffer;
  /** Time range of the data. */
  temporalPartition: Partition_TemporalPartition | undefined;
}

/** Response message for IngestAsset API. */
export interface IngestAssetResponse {
  /** Time range of the data that has been successfully ingested. */
  successfullyIngestedPartition: Partition_TemporalPartition | undefined;
}

/** Request message for ClipAsset API. */
export interface ClipAssetRequest {
  /**
   * Required. The resource name of the asset to request clips for.
   * Form:
   * 'projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}'
   */
  name: string;
  /** Required. The time range to request clips for. */
  temporalPartition: Partition_TemporalPartition | undefined;
}

/** Response message for ClipAsset API. */
export interface ClipAssetResponse {
  /**
   * A list of signed uris to download the video clips that cover the requested
   * time range ordered by time.
   */
  timeIndexedUris: ClipAssetResponse_TimeIndexedUri[];
}

/** Signed uri with corresponding time range. */
export interface ClipAssetResponse_TimeIndexedUri {
  /** Time range of the video that the uri is for. */
  temporalPartition:
    | Partition_TemporalPartition
    | undefined;
  /** Signed uri to download the video clip. */
  uri: string;
}

/** Request message for GenerateHlsUri API. */
export interface GenerateHlsUriRequest {
  /**
   * Required. The resource name of the asset to request clips for.
   * Form:
   * 'projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}'
   */
  name: string;
  /** Required. The time range to request clips for. */
  temporalPartitions: Partition_TemporalPartition[];
}

/** Response message for GenerateHlsUri API. */
export interface GenerateHlsUriResponse {
  /**
   * A signed uri to download the HLS manifest corresponding to the requested
   * times.
   */
  uri: string;
  /**
   * A list of temporal partitions of the content returned in the order they
   * appear in the stream.
   */
  temporalPartitions: Partition_TemporalPartition[];
}

/** Request message for SearchAssets. */
export interface SearchAssetsRequest {
  /**
   * Required. The parent corpus to search.
   * Form: `projects/{project_id}/locations/{location_id}/corpora/{corpus_id}'
   */
  corpus: string;
  /**
   * The number of results to be returned in this page. If it's 0, the server
   * will decide the appropriate page_size.
   */
  pageSize: number;
  /**
   * The continuation token to fetch the next page. If empty, it means it is
   * fetching the first page.
   */
  pageToken: string;
  /**
   * Time ranges that matching video content must fall within. If no ranges are
   * provided, there will be no time restriction. This field is treated just
   * like the criteria below, but defined separately for convenience as it is
   * used frequently. Note that if the end_time is in the future, it will be
   * clamped to the time the request was received.
   */
  contentTimeRanges:
    | DateTimeRangeArray
    | undefined;
  /** Criteria applied to search results. */
  criteria: Criteria[];
  /**
   * Stores most recent facet selection state. Only facet groups with user's
   * selection will be presented here. Selection state is either selected or
   * unselected. Only selected facet buckets will be used as search criteria.
   */
  facetSelections: FacetGroup[];
  /**
   * A list of annotation keys to specify the annotations to be retrieved and
   * returned with each search result.
   * Annotation granularity must be GRANULARITY_ASSET_LEVEL and its search
   * strategy must not be NO_SEARCH.
   */
  resultAnnotationKeys: string[];
}

/**
 * The metadata for DeleteAsset API that embeds in
 * [metadata][google.longrunning.Operation.metadata] field.
 */
export interface DeleteAssetMetadata {
}

/** Stores the criteria-annotation matching results for each search result item. */
export interface AnnotationMatchingResult {
  /**
   * The criteria used for matching. It can be an input search criteria or a
   * criteria converted from a facet selection.
   */
  criteria:
    | Criteria
    | undefined;
  /** Matched annotations for the criteria. */
  matchedAnnotations: Annotation[];
  /**
   * Status of the match result. Possible values:
   * FAILED_PRECONDITION - the criteria is not eligible for match.
   * OK - matching is performed.
   */
  status: Status | undefined;
}

/** Search result contains asset name and corresponding time ranges. */
export interface SearchResultItem {
  /**
   * The resource name of the asset.
   * Form:
   * 'projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}'
   */
  asset: string;
  /**
   * The matched asset segments.
   * Deprecated: please use singular `segment` field.
   *
   * @deprecated
   */
  segments: Partition_TemporalPartition[];
  /** The matched asset segment. */
  segment:
    | Partition_TemporalPartition
    | undefined;
  /**
   * Search result annotations specified by result_annotation_keys in search
   * request.
   */
  requestedAnnotations: Annotation[];
  /**
   * Criteria or facet-selection based annotation matching results associated to
   * this search result item. Only contains results for criteria or
   * facet_selections with fetch_matched_annotations=true.
   */
  annotationMatchingResults: AnnotationMatchingResult[];
}

/** Response message for SearchAssets. */
export interface SearchAssetsResponse {
  /** Returned search results. */
  searchResultItems: SearchResultItem[];
  /** The next-page continuation token. */
  nextPageToken: string;
  /**
   * Facet search results of a given query, which contains user's
   * already-selected facet values and updated facet search results.
   */
  facetResults: FacetGroup[];
}

/** Integer range type. */
export interface IntRange {
  /** Start of the int range. */
  start?:
    | Long
    | undefined;
  /** End of the int range. */
  end?: Long | undefined;
}

/** Float range type. */
export interface FloatRange {
  /** Start of the float range. */
  start?:
    | number
    | undefined;
  /** End of the float range. */
  end?: number | undefined;
}

/** A list of string-type values. */
export interface StringArray {
  /** String type values. */
  txtValues: string[];
}

/** A list of integer range values. */
export interface IntRangeArray {
  /** Int range values. */
  intRanges: IntRange[];
}

/** A list of float range values. */
export interface FloatRangeArray {
  /** Float range values. */
  floatRanges: FloatRange[];
}

/** Datetime range type. */
export interface DateTimeRange {
  /** Start date time. */
  start:
    | DateTime
    | undefined;
  /** End data time. */
  end: DateTime | undefined;
}

/** A list of datetime range values. */
export interface DateTimeRangeArray {
  /** Date time ranges. */
  dateTimeRanges: DateTimeRange[];
}

/** Representation of a circle area. */
export interface CircleArea {
  /** Latitude of circle area's center. Degrees [-90 .. 90] */
  latitude: number;
  /** Longitude of circle area's center. Degrees [-180 .. 180] */
  longitude: number;
  /** Radius of the circle area in meters. */
  radiusMeter: number;
}

/** A list of locations. */
export interface GeoLocationArray {
  /** A list of circle areas. */
  circleAreas: CircleArea[];
}

export interface BoolValue {
  value: boolean;
}

/** Filter criteria applied to current search results. */
export interface Criteria {
  /** The text values associated with the field. */
  textArray?:
    | StringArray
    | undefined;
  /** The integer ranges associated with the field. */
  intRangeArray?:
    | IntRangeArray
    | undefined;
  /** The float ranges associated with the field. */
  floatRangeArray?:
    | FloatRangeArray
    | undefined;
  /** The datetime ranges associated with the field. */
  dateTimeRangeArray?:
    | DateTimeRangeArray
    | undefined;
  /** Geo Location array. */
  geoLocationArray?:
    | GeoLocationArray
    | undefined;
  /** A Boolean value. */
  boolValue?:
    | BoolValue
    | undefined;
  /** The UGA field or ML field to apply filtering criteria. */
  field: string;
  /**
   * If true, return query matched annotations for this criteria.
   * This option is only applicable for partition level annotations and supports
   * the following data types:
   *  - INTEGER
   *  - FLOAT
   *  - STRING (DataSchema.SearchStrategy.EXACT_SEARCH only)
   *  - BOOLEAN
   */
  fetchMatchedAnnotations: boolean;
}

/**
 * Partition to specify the partition in time and space for sub-asset level
 * annotation.
 */
export interface Partition {
  /** Partition of asset in time. */
  temporalPartition:
    | Partition_TemporalPartition
    | undefined;
  /** Partition of asset in space. */
  spatialPartition: Partition_SpatialPartition | undefined;
}

/** Partition of asset in UTC Epoch time. */
export interface Partition_TemporalPartition {
  /** Start time of the partition. */
  startTime:
    | Date
    | undefined;
  /** End time of the partition. */
  endTime: Date | undefined;
}

/** Partition of asset in space. */
export interface Partition_SpatialPartition {
  /** The minimum x coordinate value. */
  xMin?:
    | Long
    | undefined;
  /** The minimum y coordinate value. */
  yMin?:
    | Long
    | undefined;
  /** The maximum x coordinate value. */
  xMax?:
    | Long
    | undefined;
  /** The maximum y coordinate value. */
  yMax?: Long | undefined;
}

function createBaseCreateAssetRequest(): CreateAssetRequest {
  return { parent: "", asset: undefined, assetId: undefined };
}

export const CreateAssetRequest: MessageFns<CreateAssetRequest> = {
  encode(message: CreateAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(18).fork()).join();
    }
    if (message.assetId !== undefined) {
      writer.uint32(26).string(message.assetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.assetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAssetRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : undefined,
    };
  },

  toJSON(message: CreateAssetRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.assetId !== undefined) {
      obj.assetId = message.assetId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAssetRequest>): CreateAssetRequest {
    return CreateAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAssetRequest>): CreateAssetRequest {
    const message = createBaseCreateAssetRequest();
    message.parent = object.parent ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.assetId = object.assetId ?? undefined;
    return message;
  },
};

function createBaseGetAssetRequest(): GetAssetRequest {
  return { name: "" };
}

export const GetAssetRequest: MessageFns<GetAssetRequest> = {
  encode(message: GetAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetRequest>): GetAssetRequest {
    return GetAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetRequest>): GetAssetRequest {
    const message = createBaseGetAssetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListAssetsRequest(): ListAssetsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListAssetsRequest: MessageFns<ListAssetsRequest> = {
  encode(message: ListAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListAssetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAssetsRequest>): ListAssetsRequest {
    return ListAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAssetsRequest>): ListAssetsRequest {
    const message = createBaseListAssetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListAssetsResponse(): ListAssetsResponse {
  return { assets: [], nextPageToken: "" };
}

export const ListAssetsResponse: MessageFns<ListAssetsResponse> = {
  encode(message: ListAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assets) {
      Asset.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assets.push(Asset.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsResponse {
    return {
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => Asset.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAssetsResponse): unknown {
    const obj: any = {};
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => Asset.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAssetsResponse>): ListAssetsResponse {
    return ListAssetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAssetsResponse>): ListAssetsResponse {
    const message = createBaseListAssetsResponse();
    message.assets = object.assets?.map((e) => Asset.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateAssetRequest(): UpdateAssetRequest {
  return { asset: undefined, updateMask: undefined };
}

export const UpdateAssetRequest: MessageFns<UpdateAssetRequest> = {
  encode(message: UpdateAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAssetRequest {
    return {
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateAssetRequest): unknown {
    const obj: any = {};
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAssetRequest>): UpdateAssetRequest {
    return UpdateAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAssetRequest>): UpdateAssetRequest {
    const message = createBaseUpdateAssetRequest();
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteAssetRequest(): DeleteAssetRequest {
  return { name: "" };
}

export const DeleteAssetRequest: MessageFns<DeleteAssetRequest> = {
  encode(message: DeleteAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAssetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAssetRequest>): DeleteAssetRequest {
    return DeleteAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAssetRequest>): DeleteAssetRequest {
    const message = createBaseDeleteAssetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAsset(): Asset {
  return { name: "", ttl: undefined };
}

export const Asset: MessageFns<Asset> = {
  encode(message: Asset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    return obj;
  },

  create(base?: DeepPartial<Asset>): Asset {
    return Asset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset>): Asset {
    const message = createBaseAsset();
    message.name = object.name ?? "";
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    return message;
  },
};

function createBaseCreateCorpusRequest(): CreateCorpusRequest {
  return { parent: "", corpus: undefined };
}

export const CreateCorpusRequest: MessageFns<CreateCorpusRequest> = {
  encode(message: CreateCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.corpus !== undefined) {
      Corpus.encode(message.corpus, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.corpus = Corpus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCorpusRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      corpus: isSet(object.corpus) ? Corpus.fromJSON(object.corpus) : undefined,
    };
  },

  toJSON(message: CreateCorpusRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.corpus !== undefined) {
      obj.corpus = Corpus.toJSON(message.corpus);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCorpusRequest>): CreateCorpusRequest {
    return CreateCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCorpusRequest>): CreateCorpusRequest {
    const message = createBaseCreateCorpusRequest();
    message.parent = object.parent ?? "";
    message.corpus = (object.corpus !== undefined && object.corpus !== null)
      ? Corpus.fromPartial(object.corpus)
      : undefined;
    return message;
  },
};

function createBaseCreateCorpusMetadata(): CreateCorpusMetadata {
  return {};
}

export const CreateCorpusMetadata: MessageFns<CreateCorpusMetadata> = {
  encode(_: CreateCorpusMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCorpusMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCorpusMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreateCorpusMetadata {
    return {};
  },

  toJSON(_: CreateCorpusMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CreateCorpusMetadata>): CreateCorpusMetadata {
    return CreateCorpusMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CreateCorpusMetadata>): CreateCorpusMetadata {
    const message = createBaseCreateCorpusMetadata();
    return message;
  },
};

function createBaseCorpus(): Corpus {
  return { name: "", displayName: "", description: "", defaultTtl: undefined };
}

export const Corpus: MessageFns<Corpus> = {
  encode(message: Corpus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.defaultTtl !== undefined) {
      Duration.encode(message.defaultTtl, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Corpus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCorpus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.defaultTtl = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Corpus {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      defaultTtl: isSet(object.defaultTtl) ? Duration.fromJSON(object.defaultTtl) : undefined,
    };
  },

  toJSON(message: Corpus): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.defaultTtl !== undefined) {
      obj.defaultTtl = Duration.toJSON(message.defaultTtl);
    }
    return obj;
  },

  create(base?: DeepPartial<Corpus>): Corpus {
    return Corpus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Corpus>): Corpus {
    const message = createBaseCorpus();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.defaultTtl = (object.defaultTtl !== undefined && object.defaultTtl !== null)
      ? Duration.fromPartial(object.defaultTtl)
      : undefined;
    return message;
  },
};

function createBaseGetCorpusRequest(): GetCorpusRequest {
  return { name: "" };
}

export const GetCorpusRequest: MessageFns<GetCorpusRequest> = {
  encode(message: GetCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCorpusRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCorpusRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCorpusRequest>): GetCorpusRequest {
    return GetCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCorpusRequest>): GetCorpusRequest {
    const message = createBaseGetCorpusRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateCorpusRequest(): UpdateCorpusRequest {
  return { corpus: undefined, updateMask: undefined };
}

export const UpdateCorpusRequest: MessageFns<UpdateCorpusRequest> = {
  encode(message: UpdateCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.corpus !== undefined) {
      Corpus.encode(message.corpus, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.corpus = Corpus.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCorpusRequest {
    return {
      corpus: isSet(object.corpus) ? Corpus.fromJSON(object.corpus) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateCorpusRequest): unknown {
    const obj: any = {};
    if (message.corpus !== undefined) {
      obj.corpus = Corpus.toJSON(message.corpus);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCorpusRequest>): UpdateCorpusRequest {
    return UpdateCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCorpusRequest>): UpdateCorpusRequest {
    const message = createBaseUpdateCorpusRequest();
    message.corpus = (object.corpus !== undefined && object.corpus !== null)
      ? Corpus.fromPartial(object.corpus)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseListCorporaRequest(): ListCorporaRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListCorporaRequest: MessageFns<ListCorporaRequest> = {
  encode(message: ListCorporaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCorporaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCorporaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCorporaRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListCorporaRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCorporaRequest>): ListCorporaRequest {
    return ListCorporaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCorporaRequest>): ListCorporaRequest {
    const message = createBaseListCorporaRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListCorporaResponse(): ListCorporaResponse {
  return { corpora: [], nextPageToken: "" };
}

export const ListCorporaResponse: MessageFns<ListCorporaResponse> = {
  encode(message: ListCorporaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.corpora) {
      Corpus.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCorporaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCorporaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.corpora.push(Corpus.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCorporaResponse {
    return {
      corpora: globalThis.Array.isArray(object?.corpora) ? object.corpora.map((e: any) => Corpus.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListCorporaResponse): unknown {
    const obj: any = {};
    if (message.corpora?.length) {
      obj.corpora = message.corpora.map((e) => Corpus.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCorporaResponse>): ListCorporaResponse {
    return ListCorporaResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCorporaResponse>): ListCorporaResponse {
    const message = createBaseListCorporaResponse();
    message.corpora = object.corpora?.map((e) => Corpus.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteCorpusRequest(): DeleteCorpusRequest {
  return { name: "" };
}

export const DeleteCorpusRequest: MessageFns<DeleteCorpusRequest> = {
  encode(message: DeleteCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCorpusRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteCorpusRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCorpusRequest>): DeleteCorpusRequest {
    return DeleteCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCorpusRequest>): DeleteCorpusRequest {
    const message = createBaseDeleteCorpusRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateDataSchemaRequest(): CreateDataSchemaRequest {
  return { parent: "", dataSchema: undefined };
}

export const CreateDataSchemaRequest: MessageFns<CreateDataSchemaRequest> = {
  encode(message: CreateDataSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.dataSchema !== undefined) {
      DataSchema.encode(message.dataSchema, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDataSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDataSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataSchema = DataSchema.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDataSchemaRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      dataSchema: isSet(object.dataSchema) ? DataSchema.fromJSON(object.dataSchema) : undefined,
    };
  },

  toJSON(message: CreateDataSchemaRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.dataSchema !== undefined) {
      obj.dataSchema = DataSchema.toJSON(message.dataSchema);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDataSchemaRequest>): CreateDataSchemaRequest {
    return CreateDataSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDataSchemaRequest>): CreateDataSchemaRequest {
    const message = createBaseCreateDataSchemaRequest();
    message.parent = object.parent ?? "";
    message.dataSchema = (object.dataSchema !== undefined && object.dataSchema !== null)
      ? DataSchema.fromPartial(object.dataSchema)
      : undefined;
    return message;
  },
};

function createBaseDataSchema(): DataSchema {
  return { name: "", key: "", schemaDetails: undefined };
}

export const DataSchema: MessageFns<DataSchema> = {
  encode(message: DataSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.schemaDetails !== undefined) {
      DataSchemaDetails.encode(message.schemaDetails, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.schemaDetails = DataSchemaDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSchema {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      schemaDetails: isSet(object.schemaDetails) ? DataSchemaDetails.fromJSON(object.schemaDetails) : undefined,
    };
  },

  toJSON(message: DataSchema): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.schemaDetails !== undefined) {
      obj.schemaDetails = DataSchemaDetails.toJSON(message.schemaDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<DataSchema>): DataSchema {
    return DataSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSchema>): DataSchema {
    const message = createBaseDataSchema();
    message.name = object.name ?? "";
    message.key = object.key ?? "";
    message.schemaDetails = (object.schemaDetails !== undefined && object.schemaDetails !== null)
      ? DataSchemaDetails.fromPartial(object.schemaDetails)
      : undefined;
    return message;
  },
};

function createBaseDataSchemaDetails(): DataSchemaDetails {
  return { type: 0, protoAnyConfig: undefined, granularity: 0, searchStrategy: undefined };
}

export const DataSchemaDetails: MessageFns<DataSchemaDetails> = {
  encode(message: DataSchemaDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.protoAnyConfig !== undefined) {
      DataSchemaDetails_ProtoAnyConfig.encode(message.protoAnyConfig, writer.uint32(50).fork()).join();
    }
    if (message.granularity !== 0) {
      writer.uint32(40).int32(message.granularity);
    }
    if (message.searchStrategy !== undefined) {
      DataSchemaDetails_SearchStrategy.encode(message.searchStrategy, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSchemaDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSchemaDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.protoAnyConfig = DataSchemaDetails_ProtoAnyConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.granularity = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.searchStrategy = DataSchemaDetails_SearchStrategy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSchemaDetails {
    return {
      type: isSet(object.type) ? dataSchemaDetails_DataTypeFromJSON(object.type) : 0,
      protoAnyConfig: isSet(object.protoAnyConfig)
        ? DataSchemaDetails_ProtoAnyConfig.fromJSON(object.protoAnyConfig)
        : undefined,
      granularity: isSet(object.granularity) ? dataSchemaDetails_GranularityFromJSON(object.granularity) : 0,
      searchStrategy: isSet(object.searchStrategy)
        ? DataSchemaDetails_SearchStrategy.fromJSON(object.searchStrategy)
        : undefined,
    };
  },

  toJSON(message: DataSchemaDetails): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = dataSchemaDetails_DataTypeToJSON(message.type);
    }
    if (message.protoAnyConfig !== undefined) {
      obj.protoAnyConfig = DataSchemaDetails_ProtoAnyConfig.toJSON(message.protoAnyConfig);
    }
    if (message.granularity !== 0) {
      obj.granularity = dataSchemaDetails_GranularityToJSON(message.granularity);
    }
    if (message.searchStrategy !== undefined) {
      obj.searchStrategy = DataSchemaDetails_SearchStrategy.toJSON(message.searchStrategy);
    }
    return obj;
  },

  create(base?: DeepPartial<DataSchemaDetails>): DataSchemaDetails {
    return DataSchemaDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSchemaDetails>): DataSchemaDetails {
    const message = createBaseDataSchemaDetails();
    message.type = object.type ?? 0;
    message.protoAnyConfig = (object.protoAnyConfig !== undefined && object.protoAnyConfig !== null)
      ? DataSchemaDetails_ProtoAnyConfig.fromPartial(object.protoAnyConfig)
      : undefined;
    message.granularity = object.granularity ?? 0;
    message.searchStrategy = (object.searchStrategy !== undefined && object.searchStrategy !== null)
      ? DataSchemaDetails_SearchStrategy.fromPartial(object.searchStrategy)
      : undefined;
    return message;
  },
};

function createBaseDataSchemaDetails_ProtoAnyConfig(): DataSchemaDetails_ProtoAnyConfig {
  return { typeUri: "" };
}

export const DataSchemaDetails_ProtoAnyConfig: MessageFns<DataSchemaDetails_ProtoAnyConfig> = {
  encode(message: DataSchemaDetails_ProtoAnyConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typeUri !== "") {
      writer.uint32(10).string(message.typeUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSchemaDetails_ProtoAnyConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSchemaDetails_ProtoAnyConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.typeUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSchemaDetails_ProtoAnyConfig {
    return { typeUri: isSet(object.typeUri) ? globalThis.String(object.typeUri) : "" };
  },

  toJSON(message: DataSchemaDetails_ProtoAnyConfig): unknown {
    const obj: any = {};
    if (message.typeUri !== "") {
      obj.typeUri = message.typeUri;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSchemaDetails_ProtoAnyConfig>): DataSchemaDetails_ProtoAnyConfig {
    return DataSchemaDetails_ProtoAnyConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSchemaDetails_ProtoAnyConfig>): DataSchemaDetails_ProtoAnyConfig {
    const message = createBaseDataSchemaDetails_ProtoAnyConfig();
    message.typeUri = object.typeUri ?? "";
    return message;
  },
};

function createBaseDataSchemaDetails_SearchStrategy(): DataSchemaDetails_SearchStrategy {
  return { searchStrategyType: 0 };
}

export const DataSchemaDetails_SearchStrategy: MessageFns<DataSchemaDetails_SearchStrategy> = {
  encode(message: DataSchemaDetails_SearchStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchStrategyType !== 0) {
      writer.uint32(8).int32(message.searchStrategyType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSchemaDetails_SearchStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSchemaDetails_SearchStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.searchStrategyType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSchemaDetails_SearchStrategy {
    return {
      searchStrategyType: isSet(object.searchStrategyType)
        ? dataSchemaDetails_SearchStrategy_SearchStrategyTypeFromJSON(object.searchStrategyType)
        : 0,
    };
  },

  toJSON(message: DataSchemaDetails_SearchStrategy): unknown {
    const obj: any = {};
    if (message.searchStrategyType !== 0) {
      obj.searchStrategyType = dataSchemaDetails_SearchStrategy_SearchStrategyTypeToJSON(message.searchStrategyType);
    }
    return obj;
  },

  create(base?: DeepPartial<DataSchemaDetails_SearchStrategy>): DataSchemaDetails_SearchStrategy {
    return DataSchemaDetails_SearchStrategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSchemaDetails_SearchStrategy>): DataSchemaDetails_SearchStrategy {
    const message = createBaseDataSchemaDetails_SearchStrategy();
    message.searchStrategyType = object.searchStrategyType ?? 0;
    return message;
  },
};

function createBaseUpdateDataSchemaRequest(): UpdateDataSchemaRequest {
  return { dataSchema: undefined, updateMask: undefined };
}

export const UpdateDataSchemaRequest: MessageFns<UpdateDataSchemaRequest> = {
  encode(message: UpdateDataSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataSchema !== undefined) {
      DataSchema.encode(message.dataSchema, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDataSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDataSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSchema = DataSchema.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDataSchemaRequest {
    return {
      dataSchema: isSet(object.dataSchema) ? DataSchema.fromJSON(object.dataSchema) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateDataSchemaRequest): unknown {
    const obj: any = {};
    if (message.dataSchema !== undefined) {
      obj.dataSchema = DataSchema.toJSON(message.dataSchema);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDataSchemaRequest>): UpdateDataSchemaRequest {
    return UpdateDataSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDataSchemaRequest>): UpdateDataSchemaRequest {
    const message = createBaseUpdateDataSchemaRequest();
    message.dataSchema = (object.dataSchema !== undefined && object.dataSchema !== null)
      ? DataSchema.fromPartial(object.dataSchema)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetDataSchemaRequest(): GetDataSchemaRequest {
  return { name: "" };
}

export const GetDataSchemaRequest: MessageFns<GetDataSchemaRequest> = {
  encode(message: GetDataSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDataSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDataSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDataSchemaRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDataSchemaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDataSchemaRequest>): GetDataSchemaRequest {
    return GetDataSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDataSchemaRequest>): GetDataSchemaRequest {
    const message = createBaseGetDataSchemaRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteDataSchemaRequest(): DeleteDataSchemaRequest {
  return { name: "" };
}

export const DeleteDataSchemaRequest: MessageFns<DeleteDataSchemaRequest> = {
  encode(message: DeleteDataSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDataSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDataSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDataSchemaRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteDataSchemaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDataSchemaRequest>): DeleteDataSchemaRequest {
    return DeleteDataSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDataSchemaRequest>): DeleteDataSchemaRequest {
    const message = createBaseDeleteDataSchemaRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListDataSchemasRequest(): ListDataSchemasRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListDataSchemasRequest: MessageFns<ListDataSchemasRequest> = {
  encode(message: ListDataSchemasRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDataSchemasRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDataSchemasRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDataSchemasRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListDataSchemasRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDataSchemasRequest>): ListDataSchemasRequest {
    return ListDataSchemasRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDataSchemasRequest>): ListDataSchemasRequest {
    const message = createBaseListDataSchemasRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListDataSchemasResponse(): ListDataSchemasResponse {
  return { dataSchemas: [], nextPageToken: "" };
}

export const ListDataSchemasResponse: MessageFns<ListDataSchemasResponse> = {
  encode(message: ListDataSchemasResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dataSchemas) {
      DataSchema.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDataSchemasResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDataSchemasResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSchemas.push(DataSchema.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDataSchemasResponse {
    return {
      dataSchemas: globalThis.Array.isArray(object?.dataSchemas)
        ? object.dataSchemas.map((e: any) => DataSchema.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDataSchemasResponse): unknown {
    const obj: any = {};
    if (message.dataSchemas?.length) {
      obj.dataSchemas = message.dataSchemas.map((e) => DataSchema.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDataSchemasResponse>): ListDataSchemasResponse {
    return ListDataSchemasResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDataSchemasResponse>): ListDataSchemasResponse {
    const message = createBaseListDataSchemasResponse();
    message.dataSchemas = object.dataSchemas?.map((e) => DataSchema.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateAnnotationRequest(): CreateAnnotationRequest {
  return { parent: "", annotation: undefined, annotationId: undefined };
}

export const CreateAnnotationRequest: MessageFns<CreateAnnotationRequest> = {
  encode(message: CreateAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.annotation !== undefined) {
      Annotation.encode(message.annotation, writer.uint32(18).fork()).join();
    }
    if (message.annotationId !== undefined) {
      writer.uint32(26).string(message.annotationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotation = Annotation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.annotationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAnnotationRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      annotation: isSet(object.annotation) ? Annotation.fromJSON(object.annotation) : undefined,
      annotationId: isSet(object.annotationId) ? globalThis.String(object.annotationId) : undefined,
    };
  },

  toJSON(message: CreateAnnotationRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.annotation !== undefined) {
      obj.annotation = Annotation.toJSON(message.annotation);
    }
    if (message.annotationId !== undefined) {
      obj.annotationId = message.annotationId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAnnotationRequest>): CreateAnnotationRequest {
    return CreateAnnotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAnnotationRequest>): CreateAnnotationRequest {
    const message = createBaseCreateAnnotationRequest();
    message.parent = object.parent ?? "";
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Annotation.fromPartial(object.annotation)
      : undefined;
    message.annotationId = object.annotationId ?? undefined;
    return message;
  },
};

function createBaseAnnotation(): Annotation {
  return { name: "", userSpecifiedAnnotation: undefined };
}

export const Annotation: MessageFns<Annotation> = {
  encode(message: Annotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.userSpecifiedAnnotation !== undefined) {
      UserSpecifiedAnnotation.encode(message.userSpecifiedAnnotation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Annotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userSpecifiedAnnotation = UserSpecifiedAnnotation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Annotation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      userSpecifiedAnnotation: isSet(object.userSpecifiedAnnotation)
        ? UserSpecifiedAnnotation.fromJSON(object.userSpecifiedAnnotation)
        : undefined,
    };
  },

  toJSON(message: Annotation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.userSpecifiedAnnotation !== undefined) {
      obj.userSpecifiedAnnotation = UserSpecifiedAnnotation.toJSON(message.userSpecifiedAnnotation);
    }
    return obj;
  },

  create(base?: DeepPartial<Annotation>): Annotation {
    return Annotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Annotation>): Annotation {
    const message = createBaseAnnotation();
    message.name = object.name ?? "";
    message.userSpecifiedAnnotation =
      (object.userSpecifiedAnnotation !== undefined && object.userSpecifiedAnnotation !== null)
        ? UserSpecifiedAnnotation.fromPartial(object.userSpecifiedAnnotation)
        : undefined;
    return message;
  },
};

function createBaseUserSpecifiedAnnotation(): UserSpecifiedAnnotation {
  return { key: "", value: undefined, partition: undefined };
}

export const UserSpecifiedAnnotation: MessageFns<UserSpecifiedAnnotation> = {
  encode(message: UserSpecifiedAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AnnotationValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    if (message.partition !== undefined) {
      Partition.encode(message.partition, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSpecifiedAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSpecifiedAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AnnotationValue.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.partition = Partition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSpecifiedAnnotation {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AnnotationValue.fromJSON(object.value) : undefined,
      partition: isSet(object.partition) ? Partition.fromJSON(object.partition) : undefined,
    };
  },

  toJSON(message: UserSpecifiedAnnotation): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AnnotationValue.toJSON(message.value);
    }
    if (message.partition !== undefined) {
      obj.partition = Partition.toJSON(message.partition);
    }
    return obj;
  },

  create(base?: DeepPartial<UserSpecifiedAnnotation>): UserSpecifiedAnnotation {
    return UserSpecifiedAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSpecifiedAnnotation>): UserSpecifiedAnnotation {
    const message = createBaseUserSpecifiedAnnotation();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AnnotationValue.fromPartial(object.value)
      : undefined;
    message.partition = (object.partition !== undefined && object.partition !== null)
      ? Partition.fromPartial(object.partition)
      : undefined;
    return message;
  },
};

function createBaseGeoCoordinate(): GeoCoordinate {
  return { latitude: 0, longitude: 0 };
}

export const GeoCoordinate: MessageFns<GeoCoordinate> = {
  encode(message: GeoCoordinate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latitude !== 0) {
      writer.uint32(9).double(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(17).double(message.longitude);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoCoordinate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoCoordinate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.latitude = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.longitude = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoCoordinate {
    return {
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
    };
  },

  toJSON(message: GeoCoordinate): unknown {
    const obj: any = {};
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    return obj;
  },

  create(base?: DeepPartial<GeoCoordinate>): GeoCoordinate {
    return GeoCoordinate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeoCoordinate>): GeoCoordinate {
    const message = createBaseGeoCoordinate();
    message.latitude = object.latitude ?? 0;
    message.longitude = object.longitude ?? 0;
    return message;
  },
};

function createBaseAnnotationValue(): AnnotationValue {
  return {
    intValue: undefined,
    floatValue: undefined,
    strValue: undefined,
    datetimeValue: undefined,
    geoCoordinate: undefined,
    protoAnyValue: undefined,
    boolValue: undefined,
    customizedStructDataValue: undefined,
  };
}

export const AnnotationValue: MessageFns<AnnotationValue> = {
  encode(message: AnnotationValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intValue !== undefined) {
      writer.uint32(8).int64(message.intValue.toString());
    }
    if (message.floatValue !== undefined) {
      writer.uint32(21).float(message.floatValue);
    }
    if (message.strValue !== undefined) {
      writer.uint32(26).string(message.strValue);
    }
    if (message.datetimeValue !== undefined) {
      writer.uint32(42).string(message.datetimeValue);
    }
    if (message.geoCoordinate !== undefined) {
      GeoCoordinate.encode(message.geoCoordinate, writer.uint32(58).fork()).join();
    }
    if (message.protoAnyValue !== undefined) {
      Any.encode(message.protoAnyValue, writer.uint32(66).fork()).join();
    }
    if (message.boolValue !== undefined) {
      writer.uint32(72).bool(message.boolValue);
    }
    if (message.customizedStructDataValue !== undefined) {
      Struct.encode(Struct.wrap(message.customizedStructDataValue), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.intValue = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.floatValue = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.strValue = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.datetimeValue = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.geoCoordinate = GeoCoordinate.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.protoAnyValue = Any.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.customizedStructDataValue = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationValue {
    return {
      intValue: isSet(object.intValue) ? Long.fromValue(object.intValue) : undefined,
      floatValue: isSet(object.floatValue) ? globalThis.Number(object.floatValue) : undefined,
      strValue: isSet(object.strValue) ? globalThis.String(object.strValue) : undefined,
      datetimeValue: isSet(object.datetimeValue) ? globalThis.String(object.datetimeValue) : undefined,
      geoCoordinate: isSet(object.geoCoordinate) ? GeoCoordinate.fromJSON(object.geoCoordinate) : undefined,
      protoAnyValue: isSet(object.protoAnyValue) ? Any.fromJSON(object.protoAnyValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      customizedStructDataValue: isObject(object.customizedStructDataValue)
        ? object.customizedStructDataValue
        : undefined,
    };
  },

  toJSON(message: AnnotationValue): unknown {
    const obj: any = {};
    if (message.intValue !== undefined) {
      obj.intValue = (message.intValue || Long.ZERO).toString();
    }
    if (message.floatValue !== undefined) {
      obj.floatValue = message.floatValue;
    }
    if (message.strValue !== undefined) {
      obj.strValue = message.strValue;
    }
    if (message.datetimeValue !== undefined) {
      obj.datetimeValue = message.datetimeValue;
    }
    if (message.geoCoordinate !== undefined) {
      obj.geoCoordinate = GeoCoordinate.toJSON(message.geoCoordinate);
    }
    if (message.protoAnyValue !== undefined) {
      obj.protoAnyValue = Any.toJSON(message.protoAnyValue);
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.customizedStructDataValue !== undefined) {
      obj.customizedStructDataValue = message.customizedStructDataValue;
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotationValue>): AnnotationValue {
    return AnnotationValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotationValue>): AnnotationValue {
    const message = createBaseAnnotationValue();
    message.intValue = (object.intValue !== undefined && object.intValue !== null)
      ? Long.fromValue(object.intValue)
      : undefined;
    message.floatValue = object.floatValue ?? undefined;
    message.strValue = object.strValue ?? undefined;
    message.datetimeValue = object.datetimeValue ?? undefined;
    message.geoCoordinate = (object.geoCoordinate !== undefined && object.geoCoordinate !== null)
      ? GeoCoordinate.fromPartial(object.geoCoordinate)
      : undefined;
    message.protoAnyValue = (object.protoAnyValue !== undefined && object.protoAnyValue !== null)
      ? Any.fromPartial(object.protoAnyValue)
      : undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.customizedStructDataValue = object.customizedStructDataValue ?? undefined;
    return message;
  },
};

function createBaseListAnnotationsRequest(): ListAnnotationsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListAnnotationsRequest: MessageFns<ListAnnotationsRequest> = {
  encode(message: ListAnnotationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAnnotationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAnnotationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAnnotationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListAnnotationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAnnotationsRequest>): ListAnnotationsRequest {
    return ListAnnotationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAnnotationsRequest>): ListAnnotationsRequest {
    const message = createBaseListAnnotationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListAnnotationsResponse(): ListAnnotationsResponse {
  return { annotations: [], nextPageToken: "" };
}

export const ListAnnotationsResponse: MessageFns<ListAnnotationsResponse> = {
  encode(message: ListAnnotationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAnnotationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAnnotationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAnnotationsResponse {
    return {
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAnnotationsResponse): unknown {
    const obj: any = {};
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => Annotation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAnnotationsResponse>): ListAnnotationsResponse {
    return ListAnnotationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAnnotationsResponse>): ListAnnotationsResponse {
    const message = createBaseListAnnotationsResponse();
    message.annotations = object.annotations?.map((e) => Annotation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetAnnotationRequest(): GetAnnotationRequest {
  return { name: "" };
}

export const GetAnnotationRequest: MessageFns<GetAnnotationRequest> = {
  encode(message: GetAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAnnotationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAnnotationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAnnotationRequest>): GetAnnotationRequest {
    return GetAnnotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAnnotationRequest>): GetAnnotationRequest {
    const message = createBaseGetAnnotationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateAnnotationRequest(): UpdateAnnotationRequest {
  return { annotation: undefined, updateMask: undefined };
}

export const UpdateAnnotationRequest: MessageFns<UpdateAnnotationRequest> = {
  encode(message: UpdateAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotation !== undefined) {
      Annotation.encode(message.annotation, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotation = Annotation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAnnotationRequest {
    return {
      annotation: isSet(object.annotation) ? Annotation.fromJSON(object.annotation) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateAnnotationRequest): unknown {
    const obj: any = {};
    if (message.annotation !== undefined) {
      obj.annotation = Annotation.toJSON(message.annotation);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAnnotationRequest>): UpdateAnnotationRequest {
    return UpdateAnnotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAnnotationRequest>): UpdateAnnotationRequest {
    const message = createBaseUpdateAnnotationRequest();
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Annotation.fromPartial(object.annotation)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteAnnotationRequest(): DeleteAnnotationRequest {
  return { name: "" };
}

export const DeleteAnnotationRequest: MessageFns<DeleteAnnotationRequest> = {
  encode(message: DeleteAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAnnotationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteAnnotationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAnnotationRequest>): DeleteAnnotationRequest {
    return DeleteAnnotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAnnotationRequest>): DeleteAnnotationRequest {
    const message = createBaseDeleteAnnotationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateSearchConfigRequest(): CreateSearchConfigRequest {
  return { parent: "", searchConfig: undefined, searchConfigId: "" };
}

export const CreateSearchConfigRequest: MessageFns<CreateSearchConfigRequest> = {
  encode(message: CreateSearchConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.searchConfig !== undefined) {
      SearchConfig.encode(message.searchConfig, writer.uint32(18).fork()).join();
    }
    if (message.searchConfigId !== "") {
      writer.uint32(26).string(message.searchConfigId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSearchConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSearchConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.searchConfig = SearchConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.searchConfigId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSearchConfigRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      searchConfig: isSet(object.searchConfig) ? SearchConfig.fromJSON(object.searchConfig) : undefined,
      searchConfigId: isSet(object.searchConfigId) ? globalThis.String(object.searchConfigId) : "",
    };
  },

  toJSON(message: CreateSearchConfigRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.searchConfig !== undefined) {
      obj.searchConfig = SearchConfig.toJSON(message.searchConfig);
    }
    if (message.searchConfigId !== "") {
      obj.searchConfigId = message.searchConfigId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSearchConfigRequest>): CreateSearchConfigRequest {
    return CreateSearchConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSearchConfigRequest>): CreateSearchConfigRequest {
    const message = createBaseCreateSearchConfigRequest();
    message.parent = object.parent ?? "";
    message.searchConfig = (object.searchConfig !== undefined && object.searchConfig !== null)
      ? SearchConfig.fromPartial(object.searchConfig)
      : undefined;
    message.searchConfigId = object.searchConfigId ?? "";
    return message;
  },
};

function createBaseUpdateSearchConfigRequest(): UpdateSearchConfigRequest {
  return { searchConfig: undefined, updateMask: undefined };
}

export const UpdateSearchConfigRequest: MessageFns<UpdateSearchConfigRequest> = {
  encode(message: UpdateSearchConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchConfig !== undefined) {
      SearchConfig.encode(message.searchConfig, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSearchConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSearchConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchConfig = SearchConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSearchConfigRequest {
    return {
      searchConfig: isSet(object.searchConfig) ? SearchConfig.fromJSON(object.searchConfig) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateSearchConfigRequest): unknown {
    const obj: any = {};
    if (message.searchConfig !== undefined) {
      obj.searchConfig = SearchConfig.toJSON(message.searchConfig);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSearchConfigRequest>): UpdateSearchConfigRequest {
    return UpdateSearchConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSearchConfigRequest>): UpdateSearchConfigRequest {
    const message = createBaseUpdateSearchConfigRequest();
    message.searchConfig = (object.searchConfig !== undefined && object.searchConfig !== null)
      ? SearchConfig.fromPartial(object.searchConfig)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetSearchConfigRequest(): GetSearchConfigRequest {
  return { name: "" };
}

export const GetSearchConfigRequest: MessageFns<GetSearchConfigRequest> = {
  encode(message: GetSearchConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSearchConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSearchConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSearchConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSearchConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSearchConfigRequest>): GetSearchConfigRequest {
    return GetSearchConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSearchConfigRequest>): GetSearchConfigRequest {
    const message = createBaseGetSearchConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteSearchConfigRequest(): DeleteSearchConfigRequest {
  return { name: "" };
}

export const DeleteSearchConfigRequest: MessageFns<DeleteSearchConfigRequest> = {
  encode(message: DeleteSearchConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSearchConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSearchConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSearchConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteSearchConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSearchConfigRequest>): DeleteSearchConfigRequest {
    return DeleteSearchConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSearchConfigRequest>): DeleteSearchConfigRequest {
    const message = createBaseDeleteSearchConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListSearchConfigsRequest(): ListSearchConfigsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListSearchConfigsRequest: MessageFns<ListSearchConfigsRequest> = {
  encode(message: ListSearchConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSearchConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSearchConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSearchConfigsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSearchConfigsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSearchConfigsRequest>): ListSearchConfigsRequest {
    return ListSearchConfigsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSearchConfigsRequest>): ListSearchConfigsRequest {
    const message = createBaseListSearchConfigsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSearchConfigsResponse(): ListSearchConfigsResponse {
  return { searchConfigs: [], nextPageToken: "" };
}

export const ListSearchConfigsResponse: MessageFns<ListSearchConfigsResponse> = {
  encode(message: ListSearchConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.searchConfigs) {
      SearchConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSearchConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSearchConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchConfigs.push(SearchConfig.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSearchConfigsResponse {
    return {
      searchConfigs: globalThis.Array.isArray(object?.searchConfigs)
        ? object.searchConfigs.map((e: any) => SearchConfig.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSearchConfigsResponse): unknown {
    const obj: any = {};
    if (message.searchConfigs?.length) {
      obj.searchConfigs = message.searchConfigs.map((e) => SearchConfig.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSearchConfigsResponse>): ListSearchConfigsResponse {
    return ListSearchConfigsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSearchConfigsResponse>): ListSearchConfigsResponse {
    const message = createBaseListSearchConfigsResponse();
    message.searchConfigs = object.searchConfigs?.map((e) => SearchConfig.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSearchConfig(): SearchConfig {
  return { name: "", facetProperty: undefined, searchCriteriaProperty: undefined };
}

export const SearchConfig: MessageFns<SearchConfig> = {
  encode(message: SearchConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.facetProperty !== undefined) {
      FacetProperty.encode(message.facetProperty, writer.uint32(18).fork()).join();
    }
    if (message.searchCriteriaProperty !== undefined) {
      SearchCriteriaProperty.encode(message.searchCriteriaProperty, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.facetProperty = FacetProperty.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.searchCriteriaProperty = SearchCriteriaProperty.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      facetProperty: isSet(object.facetProperty) ? FacetProperty.fromJSON(object.facetProperty) : undefined,
      searchCriteriaProperty: isSet(object.searchCriteriaProperty)
        ? SearchCriteriaProperty.fromJSON(object.searchCriteriaProperty)
        : undefined,
    };
  },

  toJSON(message: SearchConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.facetProperty !== undefined) {
      obj.facetProperty = FacetProperty.toJSON(message.facetProperty);
    }
    if (message.searchCriteriaProperty !== undefined) {
      obj.searchCriteriaProperty = SearchCriteriaProperty.toJSON(message.searchCriteriaProperty);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchConfig>): SearchConfig {
    return SearchConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchConfig>): SearchConfig {
    const message = createBaseSearchConfig();
    message.name = object.name ?? "";
    message.facetProperty = (object.facetProperty !== undefined && object.facetProperty !== null)
      ? FacetProperty.fromPartial(object.facetProperty)
      : undefined;
    message.searchCriteriaProperty =
      (object.searchCriteriaProperty !== undefined && object.searchCriteriaProperty !== null)
        ? SearchCriteriaProperty.fromPartial(object.searchCriteriaProperty)
        : undefined;
    return message;
  },
};

function createBaseFacetProperty(): FacetProperty {
  return {
    fixedRangeBucketSpec: undefined,
    customRangeBucketSpec: undefined,
    datetimeBucketSpec: undefined,
    mappedFields: [],
    displayName: "",
    resultSize: Long.ZERO,
    bucketType: 0,
  };
}

export const FacetProperty: MessageFns<FacetProperty> = {
  encode(message: FacetProperty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fixedRangeBucketSpec !== undefined) {
      FacetProperty_FixedRangeBucketSpec.encode(message.fixedRangeBucketSpec, writer.uint32(42).fork()).join();
    }
    if (message.customRangeBucketSpec !== undefined) {
      FacetProperty_CustomRangeBucketSpec.encode(message.customRangeBucketSpec, writer.uint32(50).fork()).join();
    }
    if (message.datetimeBucketSpec !== undefined) {
      FacetProperty_DateTimeBucketSpec.encode(message.datetimeBucketSpec, writer.uint32(58).fork()).join();
    }
    for (const v of message.mappedFields) {
      writer.uint32(10).string(v!);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (!message.resultSize.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.resultSize.toString());
    }
    if (message.bucketType !== 0) {
      writer.uint32(32).int32(message.bucketType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetProperty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.fixedRangeBucketSpec = FacetProperty_FixedRangeBucketSpec.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.customRangeBucketSpec = FacetProperty_CustomRangeBucketSpec.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.datetimeBucketSpec = FacetProperty_DateTimeBucketSpec.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mappedFields.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.resultSize = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bucketType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetProperty {
    return {
      fixedRangeBucketSpec: isSet(object.fixedRangeBucketSpec)
        ? FacetProperty_FixedRangeBucketSpec.fromJSON(object.fixedRangeBucketSpec)
        : undefined,
      customRangeBucketSpec: isSet(object.customRangeBucketSpec)
        ? FacetProperty_CustomRangeBucketSpec.fromJSON(object.customRangeBucketSpec)
        : undefined,
      datetimeBucketSpec: isSet(object.datetimeBucketSpec)
        ? FacetProperty_DateTimeBucketSpec.fromJSON(object.datetimeBucketSpec)
        : undefined,
      mappedFields: globalThis.Array.isArray(object?.mappedFields)
        ? object.mappedFields.map((e: any) => globalThis.String(e))
        : [],
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      resultSize: isSet(object.resultSize) ? Long.fromValue(object.resultSize) : Long.ZERO,
      bucketType: isSet(object.bucketType) ? facetBucketTypeFromJSON(object.bucketType) : 0,
    };
  },

  toJSON(message: FacetProperty): unknown {
    const obj: any = {};
    if (message.fixedRangeBucketSpec !== undefined) {
      obj.fixedRangeBucketSpec = FacetProperty_FixedRangeBucketSpec.toJSON(message.fixedRangeBucketSpec);
    }
    if (message.customRangeBucketSpec !== undefined) {
      obj.customRangeBucketSpec = FacetProperty_CustomRangeBucketSpec.toJSON(message.customRangeBucketSpec);
    }
    if (message.datetimeBucketSpec !== undefined) {
      obj.datetimeBucketSpec = FacetProperty_DateTimeBucketSpec.toJSON(message.datetimeBucketSpec);
    }
    if (message.mappedFields?.length) {
      obj.mappedFields = message.mappedFields;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (!message.resultSize.equals(Long.ZERO)) {
      obj.resultSize = (message.resultSize || Long.ZERO).toString();
    }
    if (message.bucketType !== 0) {
      obj.bucketType = facetBucketTypeToJSON(message.bucketType);
    }
    return obj;
  },

  create(base?: DeepPartial<FacetProperty>): FacetProperty {
    return FacetProperty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetProperty>): FacetProperty {
    const message = createBaseFacetProperty();
    message.fixedRangeBucketSpec = (object.fixedRangeBucketSpec !== undefined && object.fixedRangeBucketSpec !== null)
      ? FacetProperty_FixedRangeBucketSpec.fromPartial(object.fixedRangeBucketSpec)
      : undefined;
    message.customRangeBucketSpec =
      (object.customRangeBucketSpec !== undefined && object.customRangeBucketSpec !== null)
        ? FacetProperty_CustomRangeBucketSpec.fromPartial(object.customRangeBucketSpec)
        : undefined;
    message.datetimeBucketSpec = (object.datetimeBucketSpec !== undefined && object.datetimeBucketSpec !== null)
      ? FacetProperty_DateTimeBucketSpec.fromPartial(object.datetimeBucketSpec)
      : undefined;
    message.mappedFields = object.mappedFields?.map((e) => e) || [];
    message.displayName = object.displayName ?? "";
    message.resultSize = (object.resultSize !== undefined && object.resultSize !== null)
      ? Long.fromValue(object.resultSize)
      : Long.ZERO;
    message.bucketType = object.bucketType ?? 0;
    return message;
  },
};

function createBaseFacetProperty_FixedRangeBucketSpec(): FacetProperty_FixedRangeBucketSpec {
  return { bucketStart: undefined, bucketGranularity: undefined, bucketCount: 0 };
}

export const FacetProperty_FixedRangeBucketSpec: MessageFns<FacetProperty_FixedRangeBucketSpec> = {
  encode(message: FacetProperty_FixedRangeBucketSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketStart !== undefined) {
      FacetValue.encode(message.bucketStart, writer.uint32(10).fork()).join();
    }
    if (message.bucketGranularity !== undefined) {
      FacetValue.encode(message.bucketGranularity, writer.uint32(18).fork()).join();
    }
    if (message.bucketCount !== 0) {
      writer.uint32(24).int32(message.bucketCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetProperty_FixedRangeBucketSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetProperty_FixedRangeBucketSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bucketStart = FacetValue.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bucketGranularity = FacetValue.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.bucketCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetProperty_FixedRangeBucketSpec {
    return {
      bucketStart: isSet(object.bucketStart) ? FacetValue.fromJSON(object.bucketStart) : undefined,
      bucketGranularity: isSet(object.bucketGranularity) ? FacetValue.fromJSON(object.bucketGranularity) : undefined,
      bucketCount: isSet(object.bucketCount) ? globalThis.Number(object.bucketCount) : 0,
    };
  },

  toJSON(message: FacetProperty_FixedRangeBucketSpec): unknown {
    const obj: any = {};
    if (message.bucketStart !== undefined) {
      obj.bucketStart = FacetValue.toJSON(message.bucketStart);
    }
    if (message.bucketGranularity !== undefined) {
      obj.bucketGranularity = FacetValue.toJSON(message.bucketGranularity);
    }
    if (message.bucketCount !== 0) {
      obj.bucketCount = Math.round(message.bucketCount);
    }
    return obj;
  },

  create(base?: DeepPartial<FacetProperty_FixedRangeBucketSpec>): FacetProperty_FixedRangeBucketSpec {
    return FacetProperty_FixedRangeBucketSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetProperty_FixedRangeBucketSpec>): FacetProperty_FixedRangeBucketSpec {
    const message = createBaseFacetProperty_FixedRangeBucketSpec();
    message.bucketStart = (object.bucketStart !== undefined && object.bucketStart !== null)
      ? FacetValue.fromPartial(object.bucketStart)
      : undefined;
    message.bucketGranularity = (object.bucketGranularity !== undefined && object.bucketGranularity !== null)
      ? FacetValue.fromPartial(object.bucketGranularity)
      : undefined;
    message.bucketCount = object.bucketCount ?? 0;
    return message;
  },
};

function createBaseFacetProperty_CustomRangeBucketSpec(): FacetProperty_CustomRangeBucketSpec {
  return { endpoints: [] };
}

export const FacetProperty_CustomRangeBucketSpec: MessageFns<FacetProperty_CustomRangeBucketSpec> = {
  encode(message: FacetProperty_CustomRangeBucketSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.endpoints) {
      FacetValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetProperty_CustomRangeBucketSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetProperty_CustomRangeBucketSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.endpoints.push(FacetValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetProperty_CustomRangeBucketSpec {
    return {
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => FacetValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FacetProperty_CustomRangeBucketSpec): unknown {
    const obj: any = {};
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints.map((e) => FacetValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FacetProperty_CustomRangeBucketSpec>): FacetProperty_CustomRangeBucketSpec {
    return FacetProperty_CustomRangeBucketSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetProperty_CustomRangeBucketSpec>): FacetProperty_CustomRangeBucketSpec {
    const message = createBaseFacetProperty_CustomRangeBucketSpec();
    message.endpoints = object.endpoints?.map((e) => FacetValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFacetProperty_DateTimeBucketSpec(): FacetProperty_DateTimeBucketSpec {
  return { granularity: 0 };
}

export const FacetProperty_DateTimeBucketSpec: MessageFns<FacetProperty_DateTimeBucketSpec> = {
  encode(message: FacetProperty_DateTimeBucketSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.granularity !== 0) {
      writer.uint32(8).int32(message.granularity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetProperty_DateTimeBucketSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetProperty_DateTimeBucketSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.granularity = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetProperty_DateTimeBucketSpec {
    return {
      granularity: isSet(object.granularity)
        ? facetProperty_DateTimeBucketSpec_GranularityFromJSON(object.granularity)
        : 0,
    };
  },

  toJSON(message: FacetProperty_DateTimeBucketSpec): unknown {
    const obj: any = {};
    if (message.granularity !== 0) {
      obj.granularity = facetProperty_DateTimeBucketSpec_GranularityToJSON(message.granularity);
    }
    return obj;
  },

  create(base?: DeepPartial<FacetProperty_DateTimeBucketSpec>): FacetProperty_DateTimeBucketSpec {
    return FacetProperty_DateTimeBucketSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetProperty_DateTimeBucketSpec>): FacetProperty_DateTimeBucketSpec {
    const message = createBaseFacetProperty_DateTimeBucketSpec();
    message.granularity = object.granularity ?? 0;
    return message;
  },
};

function createBaseSearchCriteriaProperty(): SearchCriteriaProperty {
  return { mappedFields: [] };
}

export const SearchCriteriaProperty: MessageFns<SearchCriteriaProperty> = {
  encode(message: SearchCriteriaProperty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mappedFields) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchCriteriaProperty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchCriteriaProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mappedFields.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchCriteriaProperty {
    return {
      mappedFields: globalThis.Array.isArray(object?.mappedFields)
        ? object.mappedFields.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SearchCriteriaProperty): unknown {
    const obj: any = {};
    if (message.mappedFields?.length) {
      obj.mappedFields = message.mappedFields;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchCriteriaProperty>): SearchCriteriaProperty {
    return SearchCriteriaProperty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchCriteriaProperty>): SearchCriteriaProperty {
    const message = createBaseSearchCriteriaProperty();
    message.mappedFields = object.mappedFields?.map((e) => e) || [];
    return message;
  },
};

function createBaseFacetValue(): FacetValue {
  return { stringValue: undefined, integerValue: undefined, datetimeValue: undefined };
}

export const FacetValue: MessageFns<FacetValue> = {
  encode(message: FacetValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== undefined) {
      writer.uint32(10).string(message.stringValue);
    }
    if (message.integerValue !== undefined) {
      writer.uint32(16).int64(message.integerValue.toString());
    }
    if (message.datetimeValue !== undefined) {
      DateTime.encode(message.datetimeValue, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.integerValue = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.datetimeValue = DateTime.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetValue {
    return {
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      integerValue: isSet(object.integerValue) ? Long.fromValue(object.integerValue) : undefined,
      datetimeValue: isSet(object.datetimeValue) ? DateTime.fromJSON(object.datetimeValue) : undefined,
    };
  },

  toJSON(message: FacetValue): unknown {
    const obj: any = {};
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.integerValue !== undefined) {
      obj.integerValue = (message.integerValue || Long.ZERO).toString();
    }
    if (message.datetimeValue !== undefined) {
      obj.datetimeValue = DateTime.toJSON(message.datetimeValue);
    }
    return obj;
  },

  create(base?: DeepPartial<FacetValue>): FacetValue {
    return FacetValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetValue>): FacetValue {
    const message = createBaseFacetValue();
    message.stringValue = object.stringValue ?? undefined;
    message.integerValue = (object.integerValue !== undefined && object.integerValue !== null)
      ? Long.fromValue(object.integerValue)
      : undefined;
    message.datetimeValue = (object.datetimeValue !== undefined && object.datetimeValue !== null)
      ? DateTime.fromPartial(object.datetimeValue)
      : undefined;
    return message;
  },
};

function createBaseFacetBucket(): FacetBucket {
  return { value: undefined, range: undefined, selected: false };
}

export const FacetBucket: MessageFns<FacetBucket> = {
  encode(message: FacetBucket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      FacetValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    if (message.range !== undefined) {
      FacetBucket_Range.encode(message.range, writer.uint32(34).fork()).join();
    }
    if (message.selected !== false) {
      writer.uint32(24).bool(message.selected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetBucket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetBucket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = FacetValue.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.range = FacetBucket_Range.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.selected = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetBucket {
    return {
      value: isSet(object.value) ? FacetValue.fromJSON(object.value) : undefined,
      range: isSet(object.range) ? FacetBucket_Range.fromJSON(object.range) : undefined,
      selected: isSet(object.selected) ? globalThis.Boolean(object.selected) : false,
    };
  },

  toJSON(message: FacetBucket): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = FacetValue.toJSON(message.value);
    }
    if (message.range !== undefined) {
      obj.range = FacetBucket_Range.toJSON(message.range);
    }
    if (message.selected !== false) {
      obj.selected = message.selected;
    }
    return obj;
  },

  create(base?: DeepPartial<FacetBucket>): FacetBucket {
    return FacetBucket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetBucket>): FacetBucket {
    const message = createBaseFacetBucket();
    message.value = (object.value !== undefined && object.value !== null)
      ? FacetValue.fromPartial(object.value)
      : undefined;
    message.range = (object.range !== undefined && object.range !== null)
      ? FacetBucket_Range.fromPartial(object.range)
      : undefined;
    message.selected = object.selected ?? false;
    return message;
  },
};

function createBaseFacetBucket_Range(): FacetBucket_Range {
  return { start: undefined, end: undefined };
}

export const FacetBucket_Range: MessageFns<FacetBucket_Range> = {
  encode(message: FacetBucket_Range, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      FacetValue.encode(message.start, writer.uint32(10).fork()).join();
    }
    if (message.end !== undefined) {
      FacetValue.encode(message.end, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetBucket_Range {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetBucket_Range();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.start = FacetValue.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.end = FacetValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetBucket_Range {
    return {
      start: isSet(object.start) ? FacetValue.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? FacetValue.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: FacetBucket_Range): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = FacetValue.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = FacetValue.toJSON(message.end);
    }
    return obj;
  },

  create(base?: DeepPartial<FacetBucket_Range>): FacetBucket_Range {
    return FacetBucket_Range.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetBucket_Range>): FacetBucket_Range {
    const message = createBaseFacetBucket_Range();
    message.start = (object.start !== undefined && object.start !== null)
      ? FacetValue.fromPartial(object.start)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? FacetValue.fromPartial(object.end) : undefined;
    return message;
  },
};

function createBaseFacetGroup(): FacetGroup {
  return { facetId: "", displayName: "", buckets: [], bucketType: 0, fetchMatchedAnnotations: false };
}

export const FacetGroup: MessageFns<FacetGroup> = {
  encode(message: FacetGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.facetId !== "") {
      writer.uint32(10).string(message.facetId);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.buckets) {
      FacetBucket.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.bucketType !== 0) {
      writer.uint32(32).int32(message.bucketType);
    }
    if (message.fetchMatchedAnnotations !== false) {
      writer.uint32(40).bool(message.fetchMatchedAnnotations);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.facetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.buckets.push(FacetBucket.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bucketType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.fetchMatchedAnnotations = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetGroup {
    return {
      facetId: isSet(object.facetId) ? globalThis.String(object.facetId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      buckets: globalThis.Array.isArray(object?.buckets) ? object.buckets.map((e: any) => FacetBucket.fromJSON(e)) : [],
      bucketType: isSet(object.bucketType) ? facetBucketTypeFromJSON(object.bucketType) : 0,
      fetchMatchedAnnotations: isSet(object.fetchMatchedAnnotations)
        ? globalThis.Boolean(object.fetchMatchedAnnotations)
        : false,
    };
  },

  toJSON(message: FacetGroup): unknown {
    const obj: any = {};
    if (message.facetId !== "") {
      obj.facetId = message.facetId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.buckets?.length) {
      obj.buckets = message.buckets.map((e) => FacetBucket.toJSON(e));
    }
    if (message.bucketType !== 0) {
      obj.bucketType = facetBucketTypeToJSON(message.bucketType);
    }
    if (message.fetchMatchedAnnotations !== false) {
      obj.fetchMatchedAnnotations = message.fetchMatchedAnnotations;
    }
    return obj;
  },

  create(base?: DeepPartial<FacetGroup>): FacetGroup {
    return FacetGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetGroup>): FacetGroup {
    const message = createBaseFacetGroup();
    message.facetId = object.facetId ?? "";
    message.displayName = object.displayName ?? "";
    message.buckets = object.buckets?.map((e) => FacetBucket.fromPartial(e)) || [];
    message.bucketType = object.bucketType ?? 0;
    message.fetchMatchedAnnotations = object.fetchMatchedAnnotations ?? false;
    return message;
  },
};

function createBaseIngestAssetRequest(): IngestAssetRequest {
  return { config: undefined, timeIndexedData: undefined };
}

export const IngestAssetRequest: MessageFns<IngestAssetRequest> = {
  encode(message: IngestAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      IngestAssetRequest_Config.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.timeIndexedData !== undefined) {
      IngestAssetRequest_TimeIndexedData.encode(message.timeIndexedData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngestAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngestAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.config = IngestAssetRequest_Config.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeIndexedData = IngestAssetRequest_TimeIndexedData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngestAssetRequest {
    return {
      config: isSet(object.config) ? IngestAssetRequest_Config.fromJSON(object.config) : undefined,
      timeIndexedData: isSet(object.timeIndexedData)
        ? IngestAssetRequest_TimeIndexedData.fromJSON(object.timeIndexedData)
        : undefined,
    };
  },

  toJSON(message: IngestAssetRequest): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = IngestAssetRequest_Config.toJSON(message.config);
    }
    if (message.timeIndexedData !== undefined) {
      obj.timeIndexedData = IngestAssetRequest_TimeIndexedData.toJSON(message.timeIndexedData);
    }
    return obj;
  },

  create(base?: DeepPartial<IngestAssetRequest>): IngestAssetRequest {
    return IngestAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IngestAssetRequest>): IngestAssetRequest {
    const message = createBaseIngestAssetRequest();
    message.config = (object.config !== undefined && object.config !== null)
      ? IngestAssetRequest_Config.fromPartial(object.config)
      : undefined;
    message.timeIndexedData = (object.timeIndexedData !== undefined && object.timeIndexedData !== null)
      ? IngestAssetRequest_TimeIndexedData.fromPartial(object.timeIndexedData)
      : undefined;
    return message;
  },
};

function createBaseIngestAssetRequest_Config(): IngestAssetRequest_Config {
  return { videoType: undefined, asset: "" };
}

export const IngestAssetRequest_Config: MessageFns<IngestAssetRequest_Config> = {
  encode(message: IngestAssetRequest_Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoType !== undefined) {
      IngestAssetRequest_Config_VideoType.encode(message.videoType, writer.uint32(18).fork()).join();
    }
    if (message.asset !== "") {
      writer.uint32(10).string(message.asset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngestAssetRequest_Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngestAssetRequest_Config();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.videoType = IngestAssetRequest_Config_VideoType.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngestAssetRequest_Config {
    return {
      videoType: isSet(object.videoType) ? IngestAssetRequest_Config_VideoType.fromJSON(object.videoType) : undefined,
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
    };
  },

  toJSON(message: IngestAssetRequest_Config): unknown {
    const obj: any = {};
    if (message.videoType !== undefined) {
      obj.videoType = IngestAssetRequest_Config_VideoType.toJSON(message.videoType);
    }
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    return obj;
  },

  create(base?: DeepPartial<IngestAssetRequest_Config>): IngestAssetRequest_Config {
    return IngestAssetRequest_Config.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IngestAssetRequest_Config>): IngestAssetRequest_Config {
    const message = createBaseIngestAssetRequest_Config();
    message.videoType = (object.videoType !== undefined && object.videoType !== null)
      ? IngestAssetRequest_Config_VideoType.fromPartial(object.videoType)
      : undefined;
    message.asset = object.asset ?? "";
    return message;
  },
};

function createBaseIngestAssetRequest_Config_VideoType(): IngestAssetRequest_Config_VideoType {
  return { containerFormat: 0 };
}

export const IngestAssetRequest_Config_VideoType: MessageFns<IngestAssetRequest_Config_VideoType> = {
  encode(message: IngestAssetRequest_Config_VideoType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containerFormat !== 0) {
      writer.uint32(8).int32(message.containerFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngestAssetRequest_Config_VideoType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngestAssetRequest_Config_VideoType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.containerFormat = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngestAssetRequest_Config_VideoType {
    return {
      containerFormat: isSet(object.containerFormat)
        ? ingestAssetRequest_Config_VideoType_ContainerFormatFromJSON(object.containerFormat)
        : 0,
    };
  },

  toJSON(message: IngestAssetRequest_Config_VideoType): unknown {
    const obj: any = {};
    if (message.containerFormat !== 0) {
      obj.containerFormat = ingestAssetRequest_Config_VideoType_ContainerFormatToJSON(message.containerFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<IngestAssetRequest_Config_VideoType>): IngestAssetRequest_Config_VideoType {
    return IngestAssetRequest_Config_VideoType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IngestAssetRequest_Config_VideoType>): IngestAssetRequest_Config_VideoType {
    const message = createBaseIngestAssetRequest_Config_VideoType();
    message.containerFormat = object.containerFormat ?? 0;
    return message;
  },
};

function createBaseIngestAssetRequest_TimeIndexedData(): IngestAssetRequest_TimeIndexedData {
  return { data: Buffer.alloc(0), temporalPartition: undefined };
}

export const IngestAssetRequest_TimeIndexedData: MessageFns<IngestAssetRequest_TimeIndexedData> = {
  encode(message: IngestAssetRequest_TimeIndexedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.temporalPartition !== undefined) {
      Partition_TemporalPartition.encode(message.temporalPartition, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngestAssetRequest_TimeIndexedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngestAssetRequest_TimeIndexedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.temporalPartition = Partition_TemporalPartition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngestAssetRequest_TimeIndexedData {
    return {
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      temporalPartition: isSet(object.temporalPartition)
        ? Partition_TemporalPartition.fromJSON(object.temporalPartition)
        : undefined,
    };
  },

  toJSON(message: IngestAssetRequest_TimeIndexedData): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.temporalPartition !== undefined) {
      obj.temporalPartition = Partition_TemporalPartition.toJSON(message.temporalPartition);
    }
    return obj;
  },

  create(base?: DeepPartial<IngestAssetRequest_TimeIndexedData>): IngestAssetRequest_TimeIndexedData {
    return IngestAssetRequest_TimeIndexedData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IngestAssetRequest_TimeIndexedData>): IngestAssetRequest_TimeIndexedData {
    const message = createBaseIngestAssetRequest_TimeIndexedData();
    message.data = object.data ?? Buffer.alloc(0);
    message.temporalPartition = (object.temporalPartition !== undefined && object.temporalPartition !== null)
      ? Partition_TemporalPartition.fromPartial(object.temporalPartition)
      : undefined;
    return message;
  },
};

function createBaseIngestAssetResponse(): IngestAssetResponse {
  return { successfullyIngestedPartition: undefined };
}

export const IngestAssetResponse: MessageFns<IngestAssetResponse> = {
  encode(message: IngestAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.successfullyIngestedPartition !== undefined) {
      Partition_TemporalPartition.encode(message.successfullyIngestedPartition, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngestAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngestAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.successfullyIngestedPartition = Partition_TemporalPartition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngestAssetResponse {
    return {
      successfullyIngestedPartition: isSet(object.successfullyIngestedPartition)
        ? Partition_TemporalPartition.fromJSON(object.successfullyIngestedPartition)
        : undefined,
    };
  },

  toJSON(message: IngestAssetResponse): unknown {
    const obj: any = {};
    if (message.successfullyIngestedPartition !== undefined) {
      obj.successfullyIngestedPartition = Partition_TemporalPartition.toJSON(message.successfullyIngestedPartition);
    }
    return obj;
  },

  create(base?: DeepPartial<IngestAssetResponse>): IngestAssetResponse {
    return IngestAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IngestAssetResponse>): IngestAssetResponse {
    const message = createBaseIngestAssetResponse();
    message.successfullyIngestedPartition =
      (object.successfullyIngestedPartition !== undefined && object.successfullyIngestedPartition !== null)
        ? Partition_TemporalPartition.fromPartial(object.successfullyIngestedPartition)
        : undefined;
    return message;
  },
};

function createBaseClipAssetRequest(): ClipAssetRequest {
  return { name: "", temporalPartition: undefined };
}

export const ClipAssetRequest: MessageFns<ClipAssetRequest> = {
  encode(message: ClipAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.temporalPartition !== undefined) {
      Partition_TemporalPartition.encode(message.temporalPartition, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClipAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClipAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.temporalPartition = Partition_TemporalPartition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClipAssetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      temporalPartition: isSet(object.temporalPartition)
        ? Partition_TemporalPartition.fromJSON(object.temporalPartition)
        : undefined,
    };
  },

  toJSON(message: ClipAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.temporalPartition !== undefined) {
      obj.temporalPartition = Partition_TemporalPartition.toJSON(message.temporalPartition);
    }
    return obj;
  },

  create(base?: DeepPartial<ClipAssetRequest>): ClipAssetRequest {
    return ClipAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClipAssetRequest>): ClipAssetRequest {
    const message = createBaseClipAssetRequest();
    message.name = object.name ?? "";
    message.temporalPartition = (object.temporalPartition !== undefined && object.temporalPartition !== null)
      ? Partition_TemporalPartition.fromPartial(object.temporalPartition)
      : undefined;
    return message;
  },
};

function createBaseClipAssetResponse(): ClipAssetResponse {
  return { timeIndexedUris: [] };
}

export const ClipAssetResponse: MessageFns<ClipAssetResponse> = {
  encode(message: ClipAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.timeIndexedUris) {
      ClipAssetResponse_TimeIndexedUri.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClipAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClipAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeIndexedUris.push(ClipAssetResponse_TimeIndexedUri.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClipAssetResponse {
    return {
      timeIndexedUris: globalThis.Array.isArray(object?.timeIndexedUris)
        ? object.timeIndexedUris.map((e: any) => ClipAssetResponse_TimeIndexedUri.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClipAssetResponse): unknown {
    const obj: any = {};
    if (message.timeIndexedUris?.length) {
      obj.timeIndexedUris = message.timeIndexedUris.map((e) => ClipAssetResponse_TimeIndexedUri.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ClipAssetResponse>): ClipAssetResponse {
    return ClipAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClipAssetResponse>): ClipAssetResponse {
    const message = createBaseClipAssetResponse();
    message.timeIndexedUris = object.timeIndexedUris?.map((e) => ClipAssetResponse_TimeIndexedUri.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClipAssetResponse_TimeIndexedUri(): ClipAssetResponse_TimeIndexedUri {
  return { temporalPartition: undefined, uri: "" };
}

export const ClipAssetResponse_TimeIndexedUri: MessageFns<ClipAssetResponse_TimeIndexedUri> = {
  encode(message: ClipAssetResponse_TimeIndexedUri, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.temporalPartition !== undefined) {
      Partition_TemporalPartition.encode(message.temporalPartition, writer.uint32(10).fork()).join();
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClipAssetResponse_TimeIndexedUri {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClipAssetResponse_TimeIndexedUri();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.temporalPartition = Partition_TemporalPartition.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClipAssetResponse_TimeIndexedUri {
    return {
      temporalPartition: isSet(object.temporalPartition)
        ? Partition_TemporalPartition.fromJSON(object.temporalPartition)
        : undefined,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
    };
  },

  toJSON(message: ClipAssetResponse_TimeIndexedUri): unknown {
    const obj: any = {};
    if (message.temporalPartition !== undefined) {
      obj.temporalPartition = Partition_TemporalPartition.toJSON(message.temporalPartition);
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<ClipAssetResponse_TimeIndexedUri>): ClipAssetResponse_TimeIndexedUri {
    return ClipAssetResponse_TimeIndexedUri.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClipAssetResponse_TimeIndexedUri>): ClipAssetResponse_TimeIndexedUri {
    const message = createBaseClipAssetResponse_TimeIndexedUri();
    message.temporalPartition = (object.temporalPartition !== undefined && object.temporalPartition !== null)
      ? Partition_TemporalPartition.fromPartial(object.temporalPartition)
      : undefined;
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseGenerateHlsUriRequest(): GenerateHlsUriRequest {
  return { name: "", temporalPartitions: [] };
}

export const GenerateHlsUriRequest: MessageFns<GenerateHlsUriRequest> = {
  encode(message: GenerateHlsUriRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.temporalPartitions) {
      Partition_TemporalPartition.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateHlsUriRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateHlsUriRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.temporalPartitions.push(Partition_TemporalPartition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateHlsUriRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      temporalPartitions: globalThis.Array.isArray(object?.temporalPartitions)
        ? object.temporalPartitions.map((e: any) => Partition_TemporalPartition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateHlsUriRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.temporalPartitions?.length) {
      obj.temporalPartitions = message.temporalPartitions.map((e) => Partition_TemporalPartition.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateHlsUriRequest>): GenerateHlsUriRequest {
    return GenerateHlsUriRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateHlsUriRequest>): GenerateHlsUriRequest {
    const message = createBaseGenerateHlsUriRequest();
    message.name = object.name ?? "";
    message.temporalPartitions = object.temporalPartitions?.map((e) => Partition_TemporalPartition.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseGenerateHlsUriResponse(): GenerateHlsUriResponse {
  return { uri: "", temporalPartitions: [] };
}

export const GenerateHlsUriResponse: MessageFns<GenerateHlsUriResponse> = {
  encode(message: GenerateHlsUriResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    for (const v of message.temporalPartitions) {
      Partition_TemporalPartition.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateHlsUriResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateHlsUriResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.temporalPartitions.push(Partition_TemporalPartition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateHlsUriResponse {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      temporalPartitions: globalThis.Array.isArray(object?.temporalPartitions)
        ? object.temporalPartitions.map((e: any) => Partition_TemporalPartition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateHlsUriResponse): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.temporalPartitions?.length) {
      obj.temporalPartitions = message.temporalPartitions.map((e) => Partition_TemporalPartition.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateHlsUriResponse>): GenerateHlsUriResponse {
    return GenerateHlsUriResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateHlsUriResponse>): GenerateHlsUriResponse {
    const message = createBaseGenerateHlsUriResponse();
    message.uri = object.uri ?? "";
    message.temporalPartitions = object.temporalPartitions?.map((e) => Partition_TemporalPartition.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseSearchAssetsRequest(): SearchAssetsRequest {
  return {
    corpus: "",
    pageSize: 0,
    pageToken: "",
    contentTimeRanges: undefined,
    criteria: [],
    facetSelections: [],
    resultAnnotationKeys: [],
  };
}

export const SearchAssetsRequest: MessageFns<SearchAssetsRequest> = {
  encode(message: SearchAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.corpus !== "") {
      writer.uint32(10).string(message.corpus);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.contentTimeRanges !== undefined) {
      DateTimeRangeArray.encode(message.contentTimeRanges, writer.uint32(42).fork()).join();
    }
    for (const v of message.criteria) {
      Criteria.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.facetSelections) {
      FacetGroup.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.resultAnnotationKeys) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.corpus = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contentTimeRanges = DateTimeRangeArray.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.criteria.push(Criteria.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.facetSelections.push(FacetGroup.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.resultAnnotationKeys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAssetsRequest {
    return {
      corpus: isSet(object.corpus) ? globalThis.String(object.corpus) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      contentTimeRanges: isSet(object.contentTimeRanges)
        ? DateTimeRangeArray.fromJSON(object.contentTimeRanges)
        : undefined,
      criteria: globalThis.Array.isArray(object?.criteria) ? object.criteria.map((e: any) => Criteria.fromJSON(e)) : [],
      facetSelections: globalThis.Array.isArray(object?.facetSelections)
        ? object.facetSelections.map((e: any) => FacetGroup.fromJSON(e))
        : [],
      resultAnnotationKeys: globalThis.Array.isArray(object?.resultAnnotationKeys)
        ? object.resultAnnotationKeys.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SearchAssetsRequest): unknown {
    const obj: any = {};
    if (message.corpus !== "") {
      obj.corpus = message.corpus;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.contentTimeRanges !== undefined) {
      obj.contentTimeRanges = DateTimeRangeArray.toJSON(message.contentTimeRanges);
    }
    if (message.criteria?.length) {
      obj.criteria = message.criteria.map((e) => Criteria.toJSON(e));
    }
    if (message.facetSelections?.length) {
      obj.facetSelections = message.facetSelections.map((e) => FacetGroup.toJSON(e));
    }
    if (message.resultAnnotationKeys?.length) {
      obj.resultAnnotationKeys = message.resultAnnotationKeys;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAssetsRequest>): SearchAssetsRequest {
    return SearchAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAssetsRequest>): SearchAssetsRequest {
    const message = createBaseSearchAssetsRequest();
    message.corpus = object.corpus ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.contentTimeRanges = (object.contentTimeRanges !== undefined && object.contentTimeRanges !== null)
      ? DateTimeRangeArray.fromPartial(object.contentTimeRanges)
      : undefined;
    message.criteria = object.criteria?.map((e) => Criteria.fromPartial(e)) || [];
    message.facetSelections = object.facetSelections?.map((e) => FacetGroup.fromPartial(e)) || [];
    message.resultAnnotationKeys = object.resultAnnotationKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeleteAssetMetadata(): DeleteAssetMetadata {
  return {};
}

export const DeleteAssetMetadata: MessageFns<DeleteAssetMetadata> = {
  encode(_: DeleteAssetMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAssetMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAssetMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteAssetMetadata {
    return {};
  },

  toJSON(_: DeleteAssetMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DeleteAssetMetadata>): DeleteAssetMetadata {
    return DeleteAssetMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeleteAssetMetadata>): DeleteAssetMetadata {
    const message = createBaseDeleteAssetMetadata();
    return message;
  },
};

function createBaseAnnotationMatchingResult(): AnnotationMatchingResult {
  return { criteria: undefined, matchedAnnotations: [], status: undefined };
}

export const AnnotationMatchingResult: MessageFns<AnnotationMatchingResult> = {
  encode(message: AnnotationMatchingResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.criteria !== undefined) {
      Criteria.encode(message.criteria, writer.uint32(10).fork()).join();
    }
    for (const v of message.matchedAnnotations) {
      Annotation.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationMatchingResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationMatchingResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.criteria = Criteria.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.matchedAnnotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationMatchingResult {
    return {
      criteria: isSet(object.criteria) ? Criteria.fromJSON(object.criteria) : undefined,
      matchedAnnotations: globalThis.Array.isArray(object?.matchedAnnotations)
        ? object.matchedAnnotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: AnnotationMatchingResult): unknown {
    const obj: any = {};
    if (message.criteria !== undefined) {
      obj.criteria = Criteria.toJSON(message.criteria);
    }
    if (message.matchedAnnotations?.length) {
      obj.matchedAnnotations = message.matchedAnnotations.map((e) => Annotation.toJSON(e));
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotationMatchingResult>): AnnotationMatchingResult {
    return AnnotationMatchingResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotationMatchingResult>): AnnotationMatchingResult {
    const message = createBaseAnnotationMatchingResult();
    message.criteria = (object.criteria !== undefined && object.criteria !== null)
      ? Criteria.fromPartial(object.criteria)
      : undefined;
    message.matchedAnnotations = object.matchedAnnotations?.map((e) => Annotation.fromPartial(e)) || [];
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseSearchResultItem(): SearchResultItem {
  return { asset: "", segments: [], segment: undefined, requestedAnnotations: [], annotationMatchingResults: [] };
}

export const SearchResultItem: MessageFns<SearchResultItem> = {
  encode(message: SearchResultItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asset !== "") {
      writer.uint32(10).string(message.asset);
    }
    for (const v of message.segments) {
      Partition_TemporalPartition.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.segment !== undefined) {
      Partition_TemporalPartition.encode(message.segment, writer.uint32(42).fork()).join();
    }
    for (const v of message.requestedAnnotations) {
      Annotation.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.annotationMatchingResults) {
      AnnotationMatchingResult.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResultItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResultItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.segments.push(Partition_TemporalPartition.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.segment = Partition_TemporalPartition.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestedAnnotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.annotationMatchingResults.push(AnnotationMatchingResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResultItem {
    return {
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
      segments: globalThis.Array.isArray(object?.segments)
        ? object.segments.map((e: any) => Partition_TemporalPartition.fromJSON(e))
        : [],
      segment: isSet(object.segment) ? Partition_TemporalPartition.fromJSON(object.segment) : undefined,
      requestedAnnotations: globalThis.Array.isArray(object?.requestedAnnotations)
        ? object.requestedAnnotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      annotationMatchingResults: globalThis.Array.isArray(object?.annotationMatchingResults)
        ? object.annotationMatchingResults.map((e: any) => AnnotationMatchingResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResultItem): unknown {
    const obj: any = {};
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.segments?.length) {
      obj.segments = message.segments.map((e) => Partition_TemporalPartition.toJSON(e));
    }
    if (message.segment !== undefined) {
      obj.segment = Partition_TemporalPartition.toJSON(message.segment);
    }
    if (message.requestedAnnotations?.length) {
      obj.requestedAnnotations = message.requestedAnnotations.map((e) => Annotation.toJSON(e));
    }
    if (message.annotationMatchingResults?.length) {
      obj.annotationMatchingResults = message.annotationMatchingResults.map((e) => AnnotationMatchingResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResultItem>): SearchResultItem {
    return SearchResultItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResultItem>): SearchResultItem {
    const message = createBaseSearchResultItem();
    message.asset = object.asset ?? "";
    message.segments = object.segments?.map((e) => Partition_TemporalPartition.fromPartial(e)) || [];
    message.segment = (object.segment !== undefined && object.segment !== null)
      ? Partition_TemporalPartition.fromPartial(object.segment)
      : undefined;
    message.requestedAnnotations = object.requestedAnnotations?.map((e) => Annotation.fromPartial(e)) || [];
    message.annotationMatchingResults =
      object.annotationMatchingResults?.map((e) => AnnotationMatchingResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchAssetsResponse(): SearchAssetsResponse {
  return { searchResultItems: [], nextPageToken: "", facetResults: [] };
}

export const SearchAssetsResponse: MessageFns<SearchAssetsResponse> = {
  encode(message: SearchAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.searchResultItems) {
      SearchResultItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.facetResults) {
      FacetGroup.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchResultItems.push(SearchResultItem.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.facetResults.push(FacetGroup.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAssetsResponse {
    return {
      searchResultItems: globalThis.Array.isArray(object?.searchResultItems)
        ? object.searchResultItems.map((e: any) => SearchResultItem.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      facetResults: globalThis.Array.isArray(object?.facetResults)
        ? object.facetResults.map((e: any) => FacetGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchAssetsResponse): unknown {
    const obj: any = {};
    if (message.searchResultItems?.length) {
      obj.searchResultItems = message.searchResultItems.map((e) => SearchResultItem.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.facetResults?.length) {
      obj.facetResults = message.facetResults.map((e) => FacetGroup.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAssetsResponse>): SearchAssetsResponse {
    return SearchAssetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAssetsResponse>): SearchAssetsResponse {
    const message = createBaseSearchAssetsResponse();
    message.searchResultItems = object.searchResultItems?.map((e) => SearchResultItem.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.facetResults = object.facetResults?.map((e) => FacetGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIntRange(): IntRange {
  return { start: undefined, end: undefined };
}

export const IntRange: MessageFns<IntRange> = {
  encode(message: IntRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      writer.uint32(8).int64(message.start.toString());
    }
    if (message.end !== undefined) {
      writer.uint32(16).int64(message.end.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntRange {
    return {
      start: isSet(object.start) ? Long.fromValue(object.start) : undefined,
      end: isSet(object.end) ? Long.fromValue(object.end) : undefined,
    };
  },

  toJSON(message: IntRange): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = (message.start || Long.ZERO).toString();
    }
    if (message.end !== undefined) {
      obj.end = (message.end || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<IntRange>): IntRange {
    return IntRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntRange>): IntRange {
    const message = createBaseIntRange();
    message.start = (object.start !== undefined && object.start !== null) ? Long.fromValue(object.start) : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? Long.fromValue(object.end) : undefined;
    return message;
  },
};

function createBaseFloatRange(): FloatRange {
  return { start: undefined, end: undefined };
}

export const FloatRange: MessageFns<FloatRange> = {
  encode(message: FloatRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      writer.uint32(13).float(message.start);
    }
    if (message.end !== undefined) {
      writer.uint32(21).float(message.end);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.start = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.end = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatRange {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : undefined,
      end: isSet(object.end) ? globalThis.Number(object.end) : undefined,
    };
  },

  toJSON(message: FloatRange): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = message.start;
    }
    if (message.end !== undefined) {
      obj.end = message.end;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatRange>): FloatRange {
    return FloatRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatRange>): FloatRange {
    const message = createBaseFloatRange();
    message.start = object.start ?? undefined;
    message.end = object.end ?? undefined;
    return message;
  },
};

function createBaseStringArray(): StringArray {
  return { txtValues: [] };
}

export const StringArray: MessageFns<StringArray> = {
  encode(message: StringArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.txtValues) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txtValues.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringArray {
    return {
      txtValues: globalThis.Array.isArray(object?.txtValues)
        ? object.txtValues.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StringArray): unknown {
    const obj: any = {};
    if (message.txtValues?.length) {
      obj.txtValues = message.txtValues;
    }
    return obj;
  },

  create(base?: DeepPartial<StringArray>): StringArray {
    return StringArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringArray>): StringArray {
    const message = createBaseStringArray();
    message.txtValues = object.txtValues?.map((e) => e) || [];
    return message;
  },
};

function createBaseIntRangeArray(): IntRangeArray {
  return { intRanges: [] };
}

export const IntRangeArray: MessageFns<IntRangeArray> = {
  encode(message: IntRangeArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.intRanges) {
      IntRange.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntRangeArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntRangeArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intRanges.push(IntRange.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntRangeArray {
    return {
      intRanges: globalThis.Array.isArray(object?.intRanges)
        ? object.intRanges.map((e: any) => IntRange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IntRangeArray): unknown {
    const obj: any = {};
    if (message.intRanges?.length) {
      obj.intRanges = message.intRanges.map((e) => IntRange.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<IntRangeArray>): IntRangeArray {
    return IntRangeArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntRangeArray>): IntRangeArray {
    const message = createBaseIntRangeArray();
    message.intRanges = object.intRanges?.map((e) => IntRange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFloatRangeArray(): FloatRangeArray {
  return { floatRanges: [] };
}

export const FloatRangeArray: MessageFns<FloatRangeArray> = {
  encode(message: FloatRangeArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.floatRanges) {
      FloatRange.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatRangeArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatRangeArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.floatRanges.push(FloatRange.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatRangeArray {
    return {
      floatRanges: globalThis.Array.isArray(object?.floatRanges)
        ? object.floatRanges.map((e: any) => FloatRange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FloatRangeArray): unknown {
    const obj: any = {};
    if (message.floatRanges?.length) {
      obj.floatRanges = message.floatRanges.map((e) => FloatRange.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FloatRangeArray>): FloatRangeArray {
    return FloatRangeArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatRangeArray>): FloatRangeArray {
    const message = createBaseFloatRangeArray();
    message.floatRanges = object.floatRanges?.map((e) => FloatRange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDateTimeRange(): DateTimeRange {
  return { start: undefined, end: undefined };
}

export const DateTimeRange: MessageFns<DateTimeRange> = {
  encode(message: DateTimeRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      DateTime.encode(message.start, writer.uint32(10).fork()).join();
    }
    if (message.end !== undefined) {
      DateTime.encode(message.end, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateTimeRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateTimeRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.start = DateTime.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.end = DateTime.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateTimeRange {
    return {
      start: isSet(object.start) ? DateTime.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? DateTime.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: DateTimeRange): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = DateTime.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = DateTime.toJSON(message.end);
    }
    return obj;
  },

  create(base?: DeepPartial<DateTimeRange>): DateTimeRange {
    return DateTimeRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DateTimeRange>): DateTimeRange {
    const message = createBaseDateTimeRange();
    message.start = (object.start !== undefined && object.start !== null)
      ? DateTime.fromPartial(object.start)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? DateTime.fromPartial(object.end) : undefined;
    return message;
  },
};

function createBaseDateTimeRangeArray(): DateTimeRangeArray {
  return { dateTimeRanges: [] };
}

export const DateTimeRangeArray: MessageFns<DateTimeRangeArray> = {
  encode(message: DateTimeRangeArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dateTimeRanges) {
      DateTimeRange.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateTimeRangeArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateTimeRangeArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dateTimeRanges.push(DateTimeRange.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateTimeRangeArray {
    return {
      dateTimeRanges: globalThis.Array.isArray(object?.dateTimeRanges)
        ? object.dateTimeRanges.map((e: any) => DateTimeRange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DateTimeRangeArray): unknown {
    const obj: any = {};
    if (message.dateTimeRanges?.length) {
      obj.dateTimeRanges = message.dateTimeRanges.map((e) => DateTimeRange.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DateTimeRangeArray>): DateTimeRangeArray {
    return DateTimeRangeArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DateTimeRangeArray>): DateTimeRangeArray {
    const message = createBaseDateTimeRangeArray();
    message.dateTimeRanges = object.dateTimeRanges?.map((e) => DateTimeRange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCircleArea(): CircleArea {
  return { latitude: 0, longitude: 0, radiusMeter: 0 };
}

export const CircleArea: MessageFns<CircleArea> = {
  encode(message: CircleArea, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latitude !== 0) {
      writer.uint32(9).double(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(17).double(message.longitude);
    }
    if (message.radiusMeter !== 0) {
      writer.uint32(25).double(message.radiusMeter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CircleArea {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCircleArea();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.latitude = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.longitude = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.radiusMeter = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CircleArea {
    return {
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
      radiusMeter: isSet(object.radiusMeter) ? globalThis.Number(object.radiusMeter) : 0,
    };
  },

  toJSON(message: CircleArea): unknown {
    const obj: any = {};
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    if (message.radiusMeter !== 0) {
      obj.radiusMeter = message.radiusMeter;
    }
    return obj;
  },

  create(base?: DeepPartial<CircleArea>): CircleArea {
    return CircleArea.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CircleArea>): CircleArea {
    const message = createBaseCircleArea();
    message.latitude = object.latitude ?? 0;
    message.longitude = object.longitude ?? 0;
    message.radiusMeter = object.radiusMeter ?? 0;
    return message;
  },
};

function createBaseGeoLocationArray(): GeoLocationArray {
  return { circleAreas: [] };
}

export const GeoLocationArray: MessageFns<GeoLocationArray> = {
  encode(message: GeoLocationArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.circleAreas) {
      CircleArea.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoLocationArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoLocationArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.circleAreas.push(CircleArea.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoLocationArray {
    return {
      circleAreas: globalThis.Array.isArray(object?.circleAreas)
        ? object.circleAreas.map((e: any) => CircleArea.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GeoLocationArray): unknown {
    const obj: any = {};
    if (message.circleAreas?.length) {
      obj.circleAreas = message.circleAreas.map((e) => CircleArea.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GeoLocationArray>): GeoLocationArray {
    return GeoLocationArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeoLocationArray>): GeoLocationArray {
    const message = createBaseGeoLocationArray();
    message.circleAreas = object.circleAreas?.map((e) => CircleArea.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBoolValue(): BoolValue {
  return { value: false };
}

export const BoolValue: MessageFns<BoolValue> = {
  encode(message: BoolValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== false) {
      writer.uint32(8).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoolValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoolValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoolValue {
    return { value: isSet(object.value) ? globalThis.Boolean(object.value) : false };
  },

  toJSON(message: BoolValue): unknown {
    const obj: any = {};
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BoolValue>): BoolValue {
    return BoolValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BoolValue>): BoolValue {
    const message = createBaseBoolValue();
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseCriteria(): Criteria {
  return {
    textArray: undefined,
    intRangeArray: undefined,
    floatRangeArray: undefined,
    dateTimeRangeArray: undefined,
    geoLocationArray: undefined,
    boolValue: undefined,
    field: "",
    fetchMatchedAnnotations: false,
  };
}

export const Criteria: MessageFns<Criteria> = {
  encode(message: Criteria, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textArray !== undefined) {
      StringArray.encode(message.textArray, writer.uint32(18).fork()).join();
    }
    if (message.intRangeArray !== undefined) {
      IntRangeArray.encode(message.intRangeArray, writer.uint32(26).fork()).join();
    }
    if (message.floatRangeArray !== undefined) {
      FloatRangeArray.encode(message.floatRangeArray, writer.uint32(34).fork()).join();
    }
    if (message.dateTimeRangeArray !== undefined) {
      DateTimeRangeArray.encode(message.dateTimeRangeArray, writer.uint32(42).fork()).join();
    }
    if (message.geoLocationArray !== undefined) {
      GeoLocationArray.encode(message.geoLocationArray, writer.uint32(50).fork()).join();
    }
    if (message.boolValue !== undefined) {
      BoolValue.encode(message.boolValue, writer.uint32(58).fork()).join();
    }
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.fetchMatchedAnnotations !== false) {
      writer.uint32(64).bool(message.fetchMatchedAnnotations);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Criteria {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCriteria();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textArray = StringArray.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.intRangeArray = IntRangeArray.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.floatRangeArray = FloatRangeArray.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dateTimeRangeArray = DateTimeRangeArray.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.geoLocationArray = GeoLocationArray.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.boolValue = BoolValue.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.fetchMatchedAnnotations = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Criteria {
    return {
      textArray: isSet(object.textArray) ? StringArray.fromJSON(object.textArray) : undefined,
      intRangeArray: isSet(object.intRangeArray) ? IntRangeArray.fromJSON(object.intRangeArray) : undefined,
      floatRangeArray: isSet(object.floatRangeArray) ? FloatRangeArray.fromJSON(object.floatRangeArray) : undefined,
      dateTimeRangeArray: isSet(object.dateTimeRangeArray)
        ? DateTimeRangeArray.fromJSON(object.dateTimeRangeArray)
        : undefined,
      geoLocationArray: isSet(object.geoLocationArray) ? GeoLocationArray.fromJSON(object.geoLocationArray) : undefined,
      boolValue: isSet(object.boolValue) ? BoolValue.fromJSON(object.boolValue) : undefined,
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      fetchMatchedAnnotations: isSet(object.fetchMatchedAnnotations)
        ? globalThis.Boolean(object.fetchMatchedAnnotations)
        : false,
    };
  },

  toJSON(message: Criteria): unknown {
    const obj: any = {};
    if (message.textArray !== undefined) {
      obj.textArray = StringArray.toJSON(message.textArray);
    }
    if (message.intRangeArray !== undefined) {
      obj.intRangeArray = IntRangeArray.toJSON(message.intRangeArray);
    }
    if (message.floatRangeArray !== undefined) {
      obj.floatRangeArray = FloatRangeArray.toJSON(message.floatRangeArray);
    }
    if (message.dateTimeRangeArray !== undefined) {
      obj.dateTimeRangeArray = DateTimeRangeArray.toJSON(message.dateTimeRangeArray);
    }
    if (message.geoLocationArray !== undefined) {
      obj.geoLocationArray = GeoLocationArray.toJSON(message.geoLocationArray);
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = BoolValue.toJSON(message.boolValue);
    }
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.fetchMatchedAnnotations !== false) {
      obj.fetchMatchedAnnotations = message.fetchMatchedAnnotations;
    }
    return obj;
  },

  create(base?: DeepPartial<Criteria>): Criteria {
    return Criteria.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Criteria>): Criteria {
    const message = createBaseCriteria();
    message.textArray = (object.textArray !== undefined && object.textArray !== null)
      ? StringArray.fromPartial(object.textArray)
      : undefined;
    message.intRangeArray = (object.intRangeArray !== undefined && object.intRangeArray !== null)
      ? IntRangeArray.fromPartial(object.intRangeArray)
      : undefined;
    message.floatRangeArray = (object.floatRangeArray !== undefined && object.floatRangeArray !== null)
      ? FloatRangeArray.fromPartial(object.floatRangeArray)
      : undefined;
    message.dateTimeRangeArray = (object.dateTimeRangeArray !== undefined && object.dateTimeRangeArray !== null)
      ? DateTimeRangeArray.fromPartial(object.dateTimeRangeArray)
      : undefined;
    message.geoLocationArray = (object.geoLocationArray !== undefined && object.geoLocationArray !== null)
      ? GeoLocationArray.fromPartial(object.geoLocationArray)
      : undefined;
    message.boolValue = (object.boolValue !== undefined && object.boolValue !== null)
      ? BoolValue.fromPartial(object.boolValue)
      : undefined;
    message.field = object.field ?? "";
    message.fetchMatchedAnnotations = object.fetchMatchedAnnotations ?? false;
    return message;
  },
};

function createBasePartition(): Partition {
  return { temporalPartition: undefined, spatialPartition: undefined };
}

export const Partition: MessageFns<Partition> = {
  encode(message: Partition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.temporalPartition !== undefined) {
      Partition_TemporalPartition.encode(message.temporalPartition, writer.uint32(10).fork()).join();
    }
    if (message.spatialPartition !== undefined) {
      Partition_SpatialPartition.encode(message.spatialPartition, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Partition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.temporalPartition = Partition_TemporalPartition.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spatialPartition = Partition_SpatialPartition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Partition {
    return {
      temporalPartition: isSet(object.temporalPartition)
        ? Partition_TemporalPartition.fromJSON(object.temporalPartition)
        : undefined,
      spatialPartition: isSet(object.spatialPartition)
        ? Partition_SpatialPartition.fromJSON(object.spatialPartition)
        : undefined,
    };
  },

  toJSON(message: Partition): unknown {
    const obj: any = {};
    if (message.temporalPartition !== undefined) {
      obj.temporalPartition = Partition_TemporalPartition.toJSON(message.temporalPartition);
    }
    if (message.spatialPartition !== undefined) {
      obj.spatialPartition = Partition_SpatialPartition.toJSON(message.spatialPartition);
    }
    return obj;
  },

  create(base?: DeepPartial<Partition>): Partition {
    return Partition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Partition>): Partition {
    const message = createBasePartition();
    message.temporalPartition = (object.temporalPartition !== undefined && object.temporalPartition !== null)
      ? Partition_TemporalPartition.fromPartial(object.temporalPartition)
      : undefined;
    message.spatialPartition = (object.spatialPartition !== undefined && object.spatialPartition !== null)
      ? Partition_SpatialPartition.fromPartial(object.spatialPartition)
      : undefined;
    return message;
  },
};

function createBasePartition_TemporalPartition(): Partition_TemporalPartition {
  return { startTime: undefined, endTime: undefined };
}

export const Partition_TemporalPartition: MessageFns<Partition_TemporalPartition> = {
  encode(message: Partition_TemporalPartition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Partition_TemporalPartition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartition_TemporalPartition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Partition_TemporalPartition {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: Partition_TemporalPartition): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Partition_TemporalPartition>): Partition_TemporalPartition {
    return Partition_TemporalPartition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Partition_TemporalPartition>): Partition_TemporalPartition {
    const message = createBasePartition_TemporalPartition();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBasePartition_SpatialPartition(): Partition_SpatialPartition {
  return { xMin: undefined, yMin: undefined, xMax: undefined, yMax: undefined };
}

export const Partition_SpatialPartition: MessageFns<Partition_SpatialPartition> = {
  encode(message: Partition_SpatialPartition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.xMin !== undefined) {
      writer.uint32(8).int64(message.xMin.toString());
    }
    if (message.yMin !== undefined) {
      writer.uint32(16).int64(message.yMin.toString());
    }
    if (message.xMax !== undefined) {
      writer.uint32(24).int64(message.xMax.toString());
    }
    if (message.yMax !== undefined) {
      writer.uint32(32).int64(message.yMax.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Partition_SpatialPartition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartition_SpatialPartition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.xMin = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.yMin = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.xMax = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.yMax = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Partition_SpatialPartition {
    return {
      xMin: isSet(object.xMin) ? Long.fromValue(object.xMin) : undefined,
      yMin: isSet(object.yMin) ? Long.fromValue(object.yMin) : undefined,
      xMax: isSet(object.xMax) ? Long.fromValue(object.xMax) : undefined,
      yMax: isSet(object.yMax) ? Long.fromValue(object.yMax) : undefined,
    };
  },

  toJSON(message: Partition_SpatialPartition): unknown {
    const obj: any = {};
    if (message.xMin !== undefined) {
      obj.xMin = (message.xMin || Long.ZERO).toString();
    }
    if (message.yMin !== undefined) {
      obj.yMin = (message.yMin || Long.ZERO).toString();
    }
    if (message.xMax !== undefined) {
      obj.xMax = (message.xMax || Long.ZERO).toString();
    }
    if (message.yMax !== undefined) {
      obj.yMax = (message.yMax || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Partition_SpatialPartition>): Partition_SpatialPartition {
    return Partition_SpatialPartition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Partition_SpatialPartition>): Partition_SpatialPartition {
    const message = createBasePartition_SpatialPartition();
    message.xMin = (object.xMin !== undefined && object.xMin !== null) ? Long.fromValue(object.xMin) : undefined;
    message.yMin = (object.yMin !== undefined && object.yMin !== null) ? Long.fromValue(object.yMin) : undefined;
    message.xMax = (object.xMax !== undefined && object.xMax !== null) ? Long.fromValue(object.xMax) : undefined;
    message.yMax = (object.yMax !== undefined && object.yMax !== null) ? Long.fromValue(object.yMax) : undefined;
    return message;
  },
};

/** Service that manages media content + metadata for streaming. */
export type WarehouseDefinition = typeof WarehouseDefinition;
export const WarehouseDefinition = {
  name: "Warehouse",
  fullName: "google.cloud.visionai.v1alpha1.Warehouse",
  methods: {
    /** Creates an asset inside corpus. */
    createAsset: {
      name: "CreateAsset",
      requestType: CreateAssetRequest,
      requestStream: false,
      responseType: Asset,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              97,
              115,
              115,
              101,
              116,
              44,
              97,
              115,
              115,
              101,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              67,
              58,
              5,
              97,
              115,
              115,
              101,
              116,
              34,
              58,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates an asset inside corpus. */
    updateAsset: {
      name: "UpdateAsset",
      requestType: UpdateAssetRequest,
      requestStream: false,
      responseType: Asset,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([17, 97, 115, 115, 101, 116, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              73,
              58,
              5,
              97,
              115,
              115,
              101,
              116,
              50,
              64,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              97,
              115,
              115,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Reads an asset inside corpus. */
    getAsset: {
      name: "GetAsset",
      requestType: GetAssetRequest,
      requestStream: false,
      responseType: Asset,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists an list of assets inside corpus. */
    listAssets: {
      name: "ListAssets",
      requestType: ListAssetsRequest,
      requestStream: false,
      responseType: ListAssetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes asset inside corpus. */
    deleteAsset: {
      name: "DeleteAsset",
      requestType: DeleteAssetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              44,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              19,
              68,
              101,
              108,
              101,
              116,
              101,
              65,
              115,
              115,
              101,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              42,
              58,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a corpus inside a project. */
    createCorpus: {
      name: "CreateCorpus",
      requestType: CreateCorpusRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              30,
              10,
              6,
              67,
              111,
              114,
              112,
              117,
              115,
              18,
              20,
              67,
              114,
              101,
              97,
              116,
              101,
              67,
              111,
              114,
              112,
              117,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([13, 112, 97, 114, 101, 110, 116, 44, 99, 111, 114, 112, 117, 115])],
          578365826: [
            Buffer.from([
              59,
              58,
              6,
              99,
              111,
              114,
              112,
              117,
              115,
              34,
              49,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
            ]),
          ],
        },
      },
    },
    /** Gets corpus details inside a project. */
    getCorpus: {
      name: "GetCorpus",
      requestType: GetCorpusRequest,
      requestStream: false,
      responseType: Corpus,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              51,
              18,
              49,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates a corpus in a project. */
    updateCorpus: {
      name: "UpdateCorpus",
      requestType: UpdateCorpusRequest,
      requestStream: false,
      responseType: Corpus,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 99, 111, 114, 112, 117, 115, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              6,
              99,
              111,
              114,
              112,
              117,
              115,
              50,
              56,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              99,
              111,
              114,
              112,
              117,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all corpora in a project. */
    listCorpora: {
      name: "ListCorpora",
      requestType: ListCorporaRequest,
      requestStream: false,
      responseType: ListCorporaResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              51,
              18,
              49,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a corpus only if its empty.
     * Returns empty response.
     */
    deleteCorpus: {
      name: "DeleteCorpus",
      requestType: DeleteCorpusRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              51,
              42,
              49,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates data schema inside corpus. */
    createDataSchema: {
      name: "CreateDataSchema",
      requestType: CreateDataSchemaRequest,
      requestStream: false,
      responseType: DataSchema,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([18, 112, 97, 114, 101, 110, 116, 44, 100, 97, 116, 97, 95, 115, 99, 104, 101, 109, 97])],
          578365826: [
            Buffer.from([
              78,
              58,
              11,
              100,
              97,
              116,
              97,
              95,
              115,
              99,
              104,
              101,
              109,
              97,
              34,
              63,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              83,
              99,
              104,
              101,
              109,
              97,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates data schema inside corpus. */
    updateDataSchema: {
      name: "UpdateDataSchema",
      requestType: UpdateDataSchemaRequest,
      requestStream: false,
      responseType: DataSchema,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              100,
              97,
              116,
              97,
              95,
              115,
              99,
              104,
              101,
              109,
              97,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              90,
              58,
              11,
              100,
              97,
              116,
              97,
              95,
              115,
              99,
              104,
              101,
              109,
              97,
              50,
              75,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              100,
              97,
              116,
              97,
              95,
              115,
              99,
              104,
              101,
              109,
              97,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              99,
              104,
              101,
              109,
              97,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets data schema inside corpus. */
    getDataSchema: {
      name: "GetDataSchema",
      requestType: GetDataSchemaRequest,
      requestStream: false,
      responseType: DataSchema,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              65,
              18,
              63,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              99,
              104,
              101,
              109,
              97,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes data schema inside corpus. */
    deleteDataSchema: {
      name: "DeleteDataSchema",
      requestType: DeleteDataSchemaRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              65,
              42,
              63,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              99,
              104,
              101,
              109,
              97,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists a list of data schemas inside corpus. */
    listDataSchemas: {
      name: "ListDataSchemas",
      requestType: ListDataSchemasRequest,
      requestStream: false,
      responseType: ListDataSchemasResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              65,
              18,
              63,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              83,
              99,
              104,
              101,
              109,
              97,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates annotation inside asset. */
    createAnnotation: {
      name: "CreateAnnotation",
      requestType: CreateAnnotationRequest,
      requestStream: false,
      responseType: Annotation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              44,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              86,
              58,
              10,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              34,
              72,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Reads annotation inside asset. */
    getAnnotation: {
      name: "GetAnnotation",
      requestType: GetAnnotationRequest,
      requestStream: false,
      responseType: Annotation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              74,
              18,
              72,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists a list of annotations inside asset. */
    listAnnotations: {
      name: "ListAnnotations",
      requestType: ListAnnotationsRequest,
      requestStream: false,
      responseType: ListAnnotationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              74,
              18,
              72,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates annotation inside asset. */
    updateAnnotation: {
      name: "UpdateAnnotation",
      requestType: UpdateAnnotationRequest,
      requestStream: false,
      responseType: Annotation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              97,
              58,
              10,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              50,
              83,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes annotation inside asset. */
    deleteAnnotation: {
      name: "DeleteAnnotation",
      requestType: DeleteAnnotationRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              74,
              42,
              72,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Ingests data for the asset. It is not allowed to ingest a data chunk which
     * is already expired according to TTL.
     * This method is only available via the gRPC API (not HTTP since
     * bi-directional streaming is not supported via HTTP).
     */
    ingestAsset: {
      name: "IngestAsset",
      requestType: IngestAssetRequest,
      requestStream: true,
      responseType: IngestAssetResponse,
      responseStream: true,
      options: {},
    },
    /**
     * Generates clips for downloading. The api takes in a time range, and
     * generates a clip of the first content available after start_time and
     * before end_time, which may overflow beyond these bounds.
     * Returned clips are truncated if the total size of the clips are larger
     * than 100MB.
     */
    clipAsset: {
      name: "ClipAsset",
      requestType: ClipAssetRequest,
      requestStream: false,
      responseType: ClipAssetResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              99,
              108,
              105,
              112,
            ]),
          ],
        },
      },
    },
    /**
     * Generates a uri for an HLS manifest. The api takes in a collection of time
     * ranges, and generates a URI for an HLS manifest that covers all the
     * requested time ranges.
     */
    generateHlsUri: {
      name: "GenerateHlsUri",
      requestType: GenerateHlsUriRequest,
      requestStream: false,
      responseType: GenerateHlsUriResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              78,
              58,
              1,
              42,
              34,
              73,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              72,
              108,
              115,
              85,
              114,
              105,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a search configuration inside a corpus.
     *
     * Please follow the rules below to create a valid CreateSearchConfigRequest.
     * --- General Rules ---
     * 1. Request.search_config_id must not be associated with an existing
     *    SearchConfig.
     * 2. Request must contain at least one non-empty search_criteria_property or
     *    facet_property.
     * 3. mapped_fields must not be empty, and must map to existing UGA keys.
     * 4. All mapped_fields must be of the same type.
     * 5. All mapped_fields must share the same granularity.
     * 6. All mapped_fields must share the same semantic SearchConfig match
     *    options.
     * For property-specific rules, please reference the comments for
     * FacetProperty and SearchCriteriaProperty.
     */
    createSearchConfig: {
      name: "CreateSearchConfig",
      requestType: CreateSearchConfigRequest,
      requestStream: false,
      responseType: SearchConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              37,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              82,
              58,
              13,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              34,
              65,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a search configuration inside a corpus.
     *
     * Please follow the rules below to create a valid UpdateSearchConfigRequest.
     * --- General Rules ---
     * 1. Request.search_configuration.name must already exist.
     * 2. Request must contain at least one non-empty search_criteria_property or
     * facet_property.
     * 3. mapped_fields must not be empty, and must map to existing UGA keys.
     * 4. All mapped_fields must be of the same type.
     * 5. All mapped_fields must share the same granularity.
     * 6. All mapped_fields must share the same semantic SearchConfig match
     *    options.
     * For property-specific rules, please reference the comments for
     * FacetProperty and SearchCriteriaProperty.
     */
    updateSearchConfig: {
      name: "UpdateSearchConfig",
      requestType: UpdateSearchConfigRequest,
      requestStream: false,
      responseType: SearchConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              25,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              96,
              58,
              13,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              50,
              79,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets a search configuration inside a corpus. */
    getSearchConfig: {
      name: "GetSearchConfig",
      requestType: GetSearchConfigRequest,
      requestStream: false,
      responseType: SearchConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              67,
              18,
              65,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a search configuration inside a corpus.
     *
     * For a DeleteSearchConfigRequest to be valid,
     * Request.search_configuration.name must already exist.
     */
    deleteSearchConfig: {
      name: "DeleteSearchConfig",
      requestType: DeleteSearchConfigRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              67,
              42,
              65,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all search configurations inside a corpus. */
    listSearchConfigs: {
      name: "ListSearchConfigs",
      requestType: ListSearchConfigsRequest,
      requestStream: false,
      responseType: ListSearchConfigsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              67,
              18,
              65,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Search media asset. */
    searchAssets: {
      name: "SearchAssets",
      requestType: SearchAssetsRequest,
      requestStream: false,
      responseType: SearchAssetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              99,
              111,
              114,
              112,
              117,
              115,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              65,
              115,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface WarehouseServiceImplementation<CallContextExt = {}> {
  /** Creates an asset inside corpus. */
  createAsset(request: CreateAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Asset>>;
  /** Updates an asset inside corpus. */
  updateAsset(request: UpdateAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Asset>>;
  /** Reads an asset inside corpus. */
  getAsset(request: GetAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Asset>>;
  /** Lists an list of assets inside corpus. */
  listAssets(
    request: ListAssetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAssetsResponse>>;
  /** Deletes asset inside corpus. */
  deleteAsset(request: DeleteAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Creates a corpus inside a project. */
  createCorpus(request: CreateCorpusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Gets corpus details inside a project. */
  getCorpus(request: GetCorpusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Corpus>>;
  /** Updates a corpus in a project. */
  updateCorpus(request: UpdateCorpusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Corpus>>;
  /** Lists all corpora in a project. */
  listCorpora(
    request: ListCorporaRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCorporaResponse>>;
  /**
   * Deletes a corpus only if its empty.
   * Returns empty response.
   */
  deleteCorpus(request: DeleteCorpusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Creates data schema inside corpus. */
  createDataSchema(
    request: CreateDataSchemaRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DataSchema>>;
  /** Updates data schema inside corpus. */
  updateDataSchema(
    request: UpdateDataSchemaRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DataSchema>>;
  /** Gets data schema inside corpus. */
  getDataSchema(request: GetDataSchemaRequest, context: CallContext & CallContextExt): Promise<DeepPartial<DataSchema>>;
  /** Deletes data schema inside corpus. */
  deleteDataSchema(
    request: DeleteDataSchemaRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Lists a list of data schemas inside corpus. */
  listDataSchemas(
    request: ListDataSchemasRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDataSchemasResponse>>;
  /** Creates annotation inside asset. */
  createAnnotation(
    request: CreateAnnotationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Annotation>>;
  /** Reads annotation inside asset. */
  getAnnotation(request: GetAnnotationRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Annotation>>;
  /** Lists a list of annotations inside asset. */
  listAnnotations(
    request: ListAnnotationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAnnotationsResponse>>;
  /** Updates annotation inside asset. */
  updateAnnotation(
    request: UpdateAnnotationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Annotation>>;
  /** Deletes annotation inside asset. */
  deleteAnnotation(
    request: DeleteAnnotationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Ingests data for the asset. It is not allowed to ingest a data chunk which
   * is already expired according to TTL.
   * This method is only available via the gRPC API (not HTTP since
   * bi-directional streaming is not supported via HTTP).
   */
  ingestAsset(
    request: AsyncIterable<IngestAssetRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<IngestAssetResponse>>;
  /**
   * Generates clips for downloading. The api takes in a time range, and
   * generates a clip of the first content available after start_time and
   * before end_time, which may overflow beyond these bounds.
   * Returned clips are truncated if the total size of the clips are larger
   * than 100MB.
   */
  clipAsset(request: ClipAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ClipAssetResponse>>;
  /**
   * Generates a uri for an HLS manifest. The api takes in a collection of time
   * ranges, and generates a URI for an HLS manifest that covers all the
   * requested time ranges.
   */
  generateHlsUri(
    request: GenerateHlsUriRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateHlsUriResponse>>;
  /**
   * Creates a search configuration inside a corpus.
   *
   * Please follow the rules below to create a valid CreateSearchConfigRequest.
   * --- General Rules ---
   * 1. Request.search_config_id must not be associated with an existing
   *    SearchConfig.
   * 2. Request must contain at least one non-empty search_criteria_property or
   *    facet_property.
   * 3. mapped_fields must not be empty, and must map to existing UGA keys.
   * 4. All mapped_fields must be of the same type.
   * 5. All mapped_fields must share the same granularity.
   * 6. All mapped_fields must share the same semantic SearchConfig match
   *    options.
   * For property-specific rules, please reference the comments for
   * FacetProperty and SearchCriteriaProperty.
   */
  createSearchConfig(
    request: CreateSearchConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchConfig>>;
  /**
   * Updates a search configuration inside a corpus.
   *
   * Please follow the rules below to create a valid UpdateSearchConfigRequest.
   * --- General Rules ---
   * 1. Request.search_configuration.name must already exist.
   * 2. Request must contain at least one non-empty search_criteria_property or
   * facet_property.
   * 3. mapped_fields must not be empty, and must map to existing UGA keys.
   * 4. All mapped_fields must be of the same type.
   * 5. All mapped_fields must share the same granularity.
   * 6. All mapped_fields must share the same semantic SearchConfig match
   *    options.
   * For property-specific rules, please reference the comments for
   * FacetProperty and SearchCriteriaProperty.
   */
  updateSearchConfig(
    request: UpdateSearchConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchConfig>>;
  /** Gets a search configuration inside a corpus. */
  getSearchConfig(
    request: GetSearchConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchConfig>>;
  /**
   * Deletes a search configuration inside a corpus.
   *
   * For a DeleteSearchConfigRequest to be valid,
   * Request.search_configuration.name must already exist.
   */
  deleteSearchConfig(
    request: DeleteSearchConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Lists all search configurations inside a corpus. */
  listSearchConfigs(
    request: ListSearchConfigsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSearchConfigsResponse>>;
  /** Search media asset. */
  searchAssets(
    request: SearchAssetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchAssetsResponse>>;
}

export interface WarehouseClient<CallOptionsExt = {}> {
  /** Creates an asset inside corpus. */
  createAsset(request: DeepPartial<CreateAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Asset>;
  /** Updates an asset inside corpus. */
  updateAsset(request: DeepPartial<UpdateAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Asset>;
  /** Reads an asset inside corpus. */
  getAsset(request: DeepPartial<GetAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Asset>;
  /** Lists an list of assets inside corpus. */
  listAssets(
    request: DeepPartial<ListAssetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAssetsResponse>;
  /** Deletes asset inside corpus. */
  deleteAsset(request: DeepPartial<DeleteAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Creates a corpus inside a project. */
  createCorpus(request: DeepPartial<CreateCorpusRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Gets corpus details inside a project. */
  getCorpus(request: DeepPartial<GetCorpusRequest>, options?: CallOptions & CallOptionsExt): Promise<Corpus>;
  /** Updates a corpus in a project. */
  updateCorpus(request: DeepPartial<UpdateCorpusRequest>, options?: CallOptions & CallOptionsExt): Promise<Corpus>;
  /** Lists all corpora in a project. */
  listCorpora(
    request: DeepPartial<ListCorporaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCorporaResponse>;
  /**
   * Deletes a corpus only if its empty.
   * Returns empty response.
   */
  deleteCorpus(request: DeepPartial<DeleteCorpusRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Creates data schema inside corpus. */
  createDataSchema(
    request: DeepPartial<CreateDataSchemaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DataSchema>;
  /** Updates data schema inside corpus. */
  updateDataSchema(
    request: DeepPartial<UpdateDataSchemaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DataSchema>;
  /** Gets data schema inside corpus. */
  getDataSchema(
    request: DeepPartial<GetDataSchemaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DataSchema>;
  /** Deletes data schema inside corpus. */
  deleteDataSchema(
    request: DeepPartial<DeleteDataSchemaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Lists a list of data schemas inside corpus. */
  listDataSchemas(
    request: DeepPartial<ListDataSchemasRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDataSchemasResponse>;
  /** Creates annotation inside asset. */
  createAnnotation(
    request: DeepPartial<CreateAnnotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Annotation>;
  /** Reads annotation inside asset. */
  getAnnotation(
    request: DeepPartial<GetAnnotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Annotation>;
  /** Lists a list of annotations inside asset. */
  listAnnotations(
    request: DeepPartial<ListAnnotationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAnnotationsResponse>;
  /** Updates annotation inside asset. */
  updateAnnotation(
    request: DeepPartial<UpdateAnnotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Annotation>;
  /** Deletes annotation inside asset. */
  deleteAnnotation(
    request: DeepPartial<DeleteAnnotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Ingests data for the asset. It is not allowed to ingest a data chunk which
   * is already expired according to TTL.
   * This method is only available via the gRPC API (not HTTP since
   * bi-directional streaming is not supported via HTTP).
   */
  ingestAsset(
    request: AsyncIterable<DeepPartial<IngestAssetRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<IngestAssetResponse>;
  /**
   * Generates clips for downloading. The api takes in a time range, and
   * generates a clip of the first content available after start_time and
   * before end_time, which may overflow beyond these bounds.
   * Returned clips are truncated if the total size of the clips are larger
   * than 100MB.
   */
  clipAsset(request: DeepPartial<ClipAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<ClipAssetResponse>;
  /**
   * Generates a uri for an HLS manifest. The api takes in a collection of time
   * ranges, and generates a URI for an HLS manifest that covers all the
   * requested time ranges.
   */
  generateHlsUri(
    request: DeepPartial<GenerateHlsUriRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateHlsUriResponse>;
  /**
   * Creates a search configuration inside a corpus.
   *
   * Please follow the rules below to create a valid CreateSearchConfigRequest.
   * --- General Rules ---
   * 1. Request.search_config_id must not be associated with an existing
   *    SearchConfig.
   * 2. Request must contain at least one non-empty search_criteria_property or
   *    facet_property.
   * 3. mapped_fields must not be empty, and must map to existing UGA keys.
   * 4. All mapped_fields must be of the same type.
   * 5. All mapped_fields must share the same granularity.
   * 6. All mapped_fields must share the same semantic SearchConfig match
   *    options.
   * For property-specific rules, please reference the comments for
   * FacetProperty and SearchCriteriaProperty.
   */
  createSearchConfig(
    request: DeepPartial<CreateSearchConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchConfig>;
  /**
   * Updates a search configuration inside a corpus.
   *
   * Please follow the rules below to create a valid UpdateSearchConfigRequest.
   * --- General Rules ---
   * 1. Request.search_configuration.name must already exist.
   * 2. Request must contain at least one non-empty search_criteria_property or
   * facet_property.
   * 3. mapped_fields must not be empty, and must map to existing UGA keys.
   * 4. All mapped_fields must be of the same type.
   * 5. All mapped_fields must share the same granularity.
   * 6. All mapped_fields must share the same semantic SearchConfig match
   *    options.
   * For property-specific rules, please reference the comments for
   * FacetProperty and SearchCriteriaProperty.
   */
  updateSearchConfig(
    request: DeepPartial<UpdateSearchConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchConfig>;
  /** Gets a search configuration inside a corpus. */
  getSearchConfig(
    request: DeepPartial<GetSearchConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchConfig>;
  /**
   * Deletes a search configuration inside a corpus.
   *
   * For a DeleteSearchConfigRequest to be valid,
   * Request.search_configuration.name must already exist.
   */
  deleteSearchConfig(
    request: DeepPartial<DeleteSearchConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Lists all search configurations inside a corpus. */
  listSearchConfigs(
    request: DeepPartial<ListSearchConfigsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSearchConfigsResponse>;
  /** Search media asset. */
  searchAssets(
    request: DeepPartial<SearchAssetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchAssetsResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
