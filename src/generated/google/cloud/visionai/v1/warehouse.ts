// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/visionai/v1/warehouse.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Any } from "../../../protobuf/any.js";
import { Duration } from "../../../protobuf/duration.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Struct } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { DateTime } from "../../../type/datetime.js";
import { OperationMetadata } from "./common.js";

export const protobufPackage = "google.cloud.visionai.v1";

/** Different types for a facet bucket. */
export enum FacetBucketType {
  /** FACET_BUCKET_TYPE_UNSPECIFIED - Unspecified type. */
  FACET_BUCKET_TYPE_UNSPECIFIED = 0,
  /** FACET_BUCKET_TYPE_VALUE - Value type. */
  FACET_BUCKET_TYPE_VALUE = 1,
  /** FACET_BUCKET_TYPE_DATETIME - Datetime type. */
  FACET_BUCKET_TYPE_DATETIME = 2,
  /** FACET_BUCKET_TYPE_FIXED_RANGE - Fixed Range type. */
  FACET_BUCKET_TYPE_FIXED_RANGE = 3,
  /** FACET_BUCKET_TYPE_CUSTOM_RANGE - Custom Range type. */
  FACET_BUCKET_TYPE_CUSTOM_RANGE = 4,
  UNRECOGNIZED = -1,
}

export function facetBucketTypeFromJSON(object: any): FacetBucketType {
  switch (object) {
    case 0:
    case "FACET_BUCKET_TYPE_UNSPECIFIED":
      return FacetBucketType.FACET_BUCKET_TYPE_UNSPECIFIED;
    case 1:
    case "FACET_BUCKET_TYPE_VALUE":
      return FacetBucketType.FACET_BUCKET_TYPE_VALUE;
    case 2:
    case "FACET_BUCKET_TYPE_DATETIME":
      return FacetBucketType.FACET_BUCKET_TYPE_DATETIME;
    case 3:
    case "FACET_BUCKET_TYPE_FIXED_RANGE":
      return FacetBucketType.FACET_BUCKET_TYPE_FIXED_RANGE;
    case 4:
    case "FACET_BUCKET_TYPE_CUSTOM_RANGE":
      return FacetBucketType.FACET_BUCKET_TYPE_CUSTOM_RANGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FacetBucketType.UNRECOGNIZED;
  }
}

export function facetBucketTypeToJSON(object: FacetBucketType): string {
  switch (object) {
    case FacetBucketType.FACET_BUCKET_TYPE_UNSPECIFIED:
      return "FACET_BUCKET_TYPE_UNSPECIFIED";
    case FacetBucketType.FACET_BUCKET_TYPE_VALUE:
      return "FACET_BUCKET_TYPE_VALUE";
    case FacetBucketType.FACET_BUCKET_TYPE_DATETIME:
      return "FACET_BUCKET_TYPE_DATETIME";
    case FacetBucketType.FACET_BUCKET_TYPE_FIXED_RANGE:
      return "FACET_BUCKET_TYPE_FIXED_RANGE";
    case FacetBucketType.FACET_BUCKET_TYPE_CUSTOM_RANGE:
      return "FACET_BUCKET_TYPE_CUSTOM_RANGE";
    case FacetBucketType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for CreateAssetRequest. */
export interface CreateAssetRequest {
  /**
   * Required. The parent resource where this asset will be created.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}`
   */
  parent: string;
  /** Required. The asset to create. */
  asset:
    | Asset
    | undefined;
  /**
   * Optional. The ID to use for the asset, which will become the final
   * component of the asset's resource name if user choose to specify.
   * Otherwise, asset id will be generated by system.
   *
   * This value should be up to 63 characters, and valid characters
   * are /[a-z][0-9]-/. The first character must be a letter, the last could be
   * a letter or a number.
   */
  assetId?: string | undefined;
}

/** Request message for GetAsset. */
export interface GetAssetRequest {
  /**
   * Required. The name of the asset to retrieve.
   * Format:
   * projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}
   */
  name: string;
}

/** Request message for ListAssets. */
export interface ListAssetsRequest {
  /**
   * Required. The parent, which owns this collection of assets.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}`
   */
  parent: string;
  /**
   * The maximum number of assets to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 assets will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListAssets` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListAssets` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * The filter applied to the returned list.
   * Only the following filterings are supported:
   * "assets_with_contents = true", which returns assets with contents uploaded;
   * "assets_with_contents = false", which returns assets without contents.
   */
  filter: string;
}

/** Response message for ListAssets. */
export interface ListAssetsResponse {
  /** The assets from the specified corpus. */
  assets: Asset[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request message for UpdateAsset. */
export interface UpdateAssetRequest {
  /**
   * Required. The asset to update.
   *
   * The asset's `name` field is used to identify the asset to be updated.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}`
   */
  asset:
    | Asset
    | undefined;
  /** The list of fields to be updated. */
  updateMask: string[] | undefined;
}

/** Request message for DeleteAsset. */
export interface DeleteAssetRequest {
  /**
   * Required. The name of the asset to delete.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}`
   */
  name: string;
}

/** The source of the asset. */
export interface AssetSource {
  /** The source of the asset is from Cloud Storage. */
  assetGcsSource?:
    | AssetSource_AssetGcsSource
    | undefined;
  /** The source of the asset is from content bytes. */
  assetContentData?: AssetSource_AssetContentData | undefined;
}

/** The asset source is from Cloud Storage. */
export interface AssetSource_AssetGcsSource {
  /** Cloud storage uri. */
  gcsUri: string;
}

/** The content of the asset. */
export interface AssetSource_AssetContentData {
  assetContentData: Buffer;
}

/** Request message for UploadAsset. */
export interface UploadAssetRequest {
  /**
   * Required. The resource name of the asset to upload.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}`
   */
  name: string;
  /** The source of the asset. */
  assetSource: AssetSource | undefined;
}

/** Response message for UploadAsset. */
export interface UploadAssetResponse {
}

/** Metadata for UploadAsset. */
export interface UploadAssetMetadata {
  /** The start time of the operation. */
  startTime:
    | Date
    | undefined;
  /** The update time of the operation. */
  updateTime: Date | undefined;
}

/** Request message for GenerateRetrievalUrl API. */
export interface GenerateRetrievalUrlRequest {
  /**
   * Required. The resource name of the asset to request signed url for.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}`
   */
  name: string;
}

/** Response message for GenerateRetrievalUrl API. */
export interface GenerateRetrievalUrlResponse {
  /** A signed url to download the content of the asset. */
  signedUri: string;
}

/**
 * An asset is a resource in corpus. It represents a media object inside corpus,
 * contains metadata and another resource annotation. Different feature could be
 * applied to the asset to generate annotations. User could specified annotation
 * related to the target asset.
 */
export interface Asset {
  /**
   * Resource name of the asset.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}`
   */
  name: string;
  /**
   * The duration for which all media assets, associated metadata, and search
   * documents can exist. If not set, then it will using the default ttl in the
   * parent corpus resource.
   */
  ttl:
    | Duration
    | undefined;
  /**
   * Output only. The original cloud storage source uri that is associated with
   * this asset.
   */
  assetGcsSource: AssetSource_AssetGcsSource | undefined;
}

/** Request message for AnalyzeAsset. */
export interface AnalyzeAssetRequest {
  /**
   * Required. The resource name of the asset to analyze.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}`
   */
  name: string;
}

/** Metadata for AnalyzeAsset. */
export interface AnalyzeAssetMetadata {
  /** The status of analysis on all search capabilities. */
  analysisStatus: AnalyzeAssetMetadata_AnalysisStatus[];
  /** The start time of the operation. */
  startTime:
    | Date
    | undefined;
  /** The update time of the operation. */
  updateTime: Date | undefined;
}

/** The status of analysis on each search capability. */
export interface AnalyzeAssetMetadata_AnalysisStatus {
  state: AnalyzeAssetMetadata_AnalysisStatus_State;
  statusMessage: string;
  /** The search capability requested. */
  searchCapability: SearchCapability | undefined;
}

/** The state of the search capability. */
export enum AnalyzeAssetMetadata_AnalysisStatus_State {
  /** STATE_UNSPECIFIED - The default process state should never happen. */
  STATE_UNSPECIFIED = 0,
  /** IN_PROGRESS - The ml model analysis is in progress. */
  IN_PROGRESS = 1,
  /** SUCCEEDED - The ml model analysis is successfully done. */
  SUCCEEDED = 2,
  /** FAILED - The ml model analysis failed. */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function analyzeAssetMetadata_AnalysisStatus_StateFromJSON(
  object: any,
): AnalyzeAssetMetadata_AnalysisStatus_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return AnalyzeAssetMetadata_AnalysisStatus_State.STATE_UNSPECIFIED;
    case 1:
    case "IN_PROGRESS":
      return AnalyzeAssetMetadata_AnalysisStatus_State.IN_PROGRESS;
    case 2:
    case "SUCCEEDED":
      return AnalyzeAssetMetadata_AnalysisStatus_State.SUCCEEDED;
    case 3:
    case "FAILED":
      return AnalyzeAssetMetadata_AnalysisStatus_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnalyzeAssetMetadata_AnalysisStatus_State.UNRECOGNIZED;
  }
}

export function analyzeAssetMetadata_AnalysisStatus_StateToJSON(
  object: AnalyzeAssetMetadata_AnalysisStatus_State,
): string {
  switch (object) {
    case AnalyzeAssetMetadata_AnalysisStatus_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case AnalyzeAssetMetadata_AnalysisStatus_State.IN_PROGRESS:
      return "IN_PROGRESS";
    case AnalyzeAssetMetadata_AnalysisStatus_State.SUCCEEDED:
      return "SUCCEEDED";
    case AnalyzeAssetMetadata_AnalysisStatus_State.FAILED:
      return "FAILED";
    case AnalyzeAssetMetadata_AnalysisStatus_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Response message for AnalyzeAsset. */
export interface AnalyzeAssetResponse {
}

/** The status of indexing for the asset. */
export interface IndexingStatus {
  /** Output only. State of this asset's indexing. */
  state: IndexingStatus_State;
  /** Detailed message describing the state. */
  statusMessage: string;
}

/** State enum for this asset's indexing. */
export enum IndexingStatus_State {
  /** STATE_UNSPECIFIED - The default process state should never happen. */
  STATE_UNSPECIFIED = 0,
  /** IN_PROGRESS - The indexing is in progress. */
  IN_PROGRESS = 1,
  /** SUCCEEDED - The process is successfully done. */
  SUCCEEDED = 2,
  /** FAILED - The process failed. */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function indexingStatus_StateFromJSON(object: any): IndexingStatus_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return IndexingStatus_State.STATE_UNSPECIFIED;
    case 1:
    case "IN_PROGRESS":
      return IndexingStatus_State.IN_PROGRESS;
    case 2:
    case "SUCCEEDED":
      return IndexingStatus_State.SUCCEEDED;
    case 3:
    case "FAILED":
      return IndexingStatus_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IndexingStatus_State.UNRECOGNIZED;
  }
}

export function indexingStatus_StateToJSON(object: IndexingStatus_State): string {
  switch (object) {
    case IndexingStatus_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case IndexingStatus_State.IN_PROGRESS:
      return "IN_PROGRESS";
    case IndexingStatus_State.SUCCEEDED:
      return "SUCCEEDED";
    case IndexingStatus_State.FAILED:
      return "FAILED";
    case IndexingStatus_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for IndexAsset. */
export interface IndexAssetRequest {
  /**
   * Required. The resource name of the asset to index.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}`
   */
  name: string;
  /**
   * Optional. The name of the index.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/indexes/{index}`
   */
  index: string;
}

/** Metadata for IndexAsset. */
export interface IndexAssetMetadata {
  /** The status of indexing this asset. */
  status:
    | IndexingStatus
    | undefined;
  /** The start time of the operation. */
  startTime:
    | Date
    | undefined;
  /** The update time of the operation. */
  updateTime: Date | undefined;
}

/** Response message for IndexAsset. */
export interface IndexAssetResponse {
}

/** Request message for RemoveIndexAsset. */
export interface RemoveIndexAssetRequest {
  /**
   * Required. The resource name of the asset to index.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}`
   */
  name: string;
  /**
   * Optional. The name of the index.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/indexes/{index}`
   */
  index: string;
}

/** Metadata for RemoveIndexAsset. */
export interface RemoveIndexAssetMetadata {
  /** The status of indexing this asset. */
  indexingStatus:
    | IndexingStatus
    | undefined;
  /** The start time of the operation. */
  startTime:
    | Date
    | undefined;
  /** The update time of the operation. */
  updateTime: Date | undefined;
}

/** Response message for RemoveIndexAsset. */
export interface RemoveIndexAssetResponse {
}

/** An IndexedAsset is an asset that the index is built upon. */
export interface IndexedAsset {
  /**
   * Required. The index that this indexed asset belongs to.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/indexes/{index}`
   */
  index: string;
  /**
   * Required. The resource name of the asset.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}`
   */
  asset: string;
  /** Output only. The create timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update timestamp. */
  updateTime: Date | undefined;
}

/** Request message for ViewIndexedAssets. */
export interface ViewIndexedAssetsRequest {
  /**
   * Required. The index that owns this collection of assets.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/indexes/{index}`
   */
  index: string;
  /**
   * The maximum number of assets to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 assets will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ViewIndexedAssets` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ViewIndexedAssets` must
   * match the call that provided the page token.
   */
  pageToken: string;
  /**
   * The filter applied to the returned list.
   * Only the following filterings are supported:
   * "asset_id = xxxx", which returns asset with specified id.
   * "asset_id = xxxx, yyyy, zzzz", which returns assets with specified ids.
   */
  filter: string;
}

/** Response message for ViewIndexedAssets. */
export interface ViewIndexedAssetsResponse {
  /** The assets from the specified index. */
  indexedAssets: IndexedAsset[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request message of CreateCorpus API. */
export interface CreateCorpusRequest {
  /** Required. Form: `projects/{project_number}/locations/{location_id}` */
  parent: string;
  /** Required. The corpus to be created. */
  corpus: Corpus | undefined;
}

/** Metadata for CreateCorpus API. */
export interface CreateCorpusMetadata {
  /** The create time of the create corpus operation. */
  createTime:
    | Date
    | undefined;
  /** The update time of the create corpus operation. */
  updateTime: Date | undefined;
}

/** The capability and metadata of search capability. */
export interface SearchCapability {
  /** The search capability to enable. */
  type: SearchCapability_Type;
}

/** Capability to perform different search on assets. */
export enum SearchCapability_Type {
  /** TYPE_UNSPECIFIED - Unspecified search capability, should never be used. */
  TYPE_UNSPECIFIED = 0,
  /** EMBEDDING_SEARCH - Embedding search. */
  EMBEDDING_SEARCH = 1,
  UNRECOGNIZED = -1,
}

export function searchCapability_TypeFromJSON(object: any): SearchCapability_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return SearchCapability_Type.TYPE_UNSPECIFIED;
    case 1:
    case "EMBEDDING_SEARCH":
      return SearchCapability_Type.EMBEDDING_SEARCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchCapability_Type.UNRECOGNIZED;
  }
}

export function searchCapability_TypeToJSON(object: SearchCapability_Type): string {
  switch (object) {
    case SearchCapability_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case SearchCapability_Type.EMBEDDING_SEARCH:
      return "EMBEDDING_SEARCH";
    case SearchCapability_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Setting for search capability to enable. */
export interface SearchCapabilitySetting {
  /** The metadata of search capability to enable. */
  searchCapabilities: SearchCapability[];
}

/** Metadata message for CreateCollectionRequest */
export interface CreateCollectionMetadata {
  /** Common metadata of the long-running operation. */
  operationMetadata: OperationMetadata | undefined;
}

/** Request message for CreateCollection. */
export interface CreateCollectionRequest {
  /**
   * Required. The parent resource where this collection will be created.
   * Format: `projects/{project_number}/locations/{location}/corpora/{corpus}`
   */
  parent: string;
  /** Required. The collection resource to be created. */
  collection:
    | Collection
    | undefined;
  /**
   * Optional. The ID to use for the collection, which will become the final
   * component of the resource name if user choose to specify. Otherwise,
   * collection id will be generated by system.
   *
   * This value should be up to 55 characters, and valid characters
   * are /[a-z][0-9]-/. The first character must be a letter, the last could be
   * a letter or a number.
   */
  collectionId?: string | undefined;
}

/** Metadata message for DeleteCollectionRequest */
export interface DeleteCollectionMetadata {
  /** Common metadata of the long-running operation. */
  operationMetadata: OperationMetadata | undefined;
}

/** Request message for DeleteCollectionRequest. */
export interface DeleteCollectionRequest {
  /**
   * Required. The name of the collection to delete. Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/collections/{collection}`
   */
  name: string;
}

/** Request message for GetCollectionRequest. */
export interface GetCollectionRequest {
  /**
   * Required. The name of the collection to retrieve. Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/collections/{collection}`
   */
  name: string;
}

/** Request message for UpdateCollectionRequest. */
export interface UpdateCollectionRequest {
  /**
   * Required. The collection to update.
   *
   * The collection's `name` field is used to identify the collection to be
   * updated. Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/collections/{collection}`
   */
  collection:
    | Collection
    | undefined;
  /**
   * The list of fields to be updated.
   * - Unset `update_mask` or set `update_mask` to be a single "*" only will
   *   update all updatable fields with the value provided in `collection`.
   * - To update `display_name` value to empty string, set it in the
   * `collection`
   *   to empty string, and set `update_mask` with "display_name". Same applies
   *   to other updatable string fields in the `collection`.
   */
  updateMask: string[] | undefined;
}

/** Request message for ListCollections. */
export interface ListCollectionsRequest {
  /**
   * Required. The parent corpus. Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}`
   */
  parent: string;
  /**
   * The maximum number of collections to return. The service may return fewer
   * than this value. If unspecified, at most 50 collections will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListCollectionsRequest` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListCollectionsRequest`
   * must match the call that provided the page token.
   */
  pageToken: string;
}

/** Response message for ListCollections. */
export interface ListCollectionsResponse {
  /** The collections from the specified corpus. */
  collections: Collection[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request message for AddCollectionItem. */
export interface AddCollectionItemRequest {
  /** Required. The item to be added. */
  item: CollectionItem | undefined;
}

/** Response message for AddCollectionItem. */
export interface AddCollectionItemResponse {
  /** The item that has already been added. */
  item: CollectionItem | undefined;
}

/** Request message for RemoveCollectionItem. */
export interface RemoveCollectionItemRequest {
  /** Required. The item to be removed. */
  item: CollectionItem | undefined;
}

/** Request message for RemoveCollectionItem. */
export interface RemoveCollectionItemResponse {
  /** The item that has already been removed. */
  item: CollectionItem | undefined;
}

/** Request message for ViewCollectionItems. */
export interface ViewCollectionItemsRequest {
  /**
   * Required. The collection to view. Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/collections/{collection}`
   */
  collection: string;
  /**
   * The maximum number of collections to return. The service may return fewer
   * than this value. If unspecified, at most 50 collections will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ViewCollectionItemsRequest` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ViewCollectionItemsRequest` must match the call that provided the page
   * token.
   */
  pageToken: string;
}

/** Response message for ViewCollectionItems. */
export interface ViewCollectionItemsResponse {
  /** The items from the specified collection. */
  items: CollectionItem[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/**
 * A collection is a resource in a corpus. It serves as a container of
 * references to original resources.
 */
export interface Collection {
  /**
   * Output only. Resource name of the collection. Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/collections/{collection}`
   */
  name: string;
  /**
   * Optional. The collection name for displaying.
   * The name can be up to 256 characters long.
   */
  displayName: string;
  /**
   * Optional. Description of the collection. Can be up to 25000 characters
   * long.
   */
  description: string;
}

/**
 * A CollectionItem is an item in a collection.
 * Each item is a reference to the original resource in a collection.
 */
export interface CollectionItem {
  /**
   * Required. The collection name that this item belongs to. Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/collections/{collection}`
   */
  collection: string;
  /** Required. The type of item. */
  type: CollectionItem_Type;
  /**
   * Required. The name of the CollectionItem. Its format depends on the `type`
   * above. For ASSET:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}`
   */
  itemResource: string;
}

/** CollectionItem types. */
export enum CollectionItem_Type {
  /** TYPE_UNSPECIFIED - The default type of item should never happen. */
  TYPE_UNSPECIFIED = 0,
  /** ASSET - Asset type item. */
  ASSET = 1,
  UNRECOGNIZED = -1,
}

export function collectionItem_TypeFromJSON(object: any): CollectionItem_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return CollectionItem_Type.TYPE_UNSPECIFIED;
    case 1:
    case "ASSET":
      return CollectionItem_Type.ASSET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CollectionItem_Type.UNRECOGNIZED;
  }
}

export function collectionItem_TypeToJSON(object: CollectionItem_Type): string {
  switch (object) {
    case CollectionItem_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case CollectionItem_Type.ASSET:
      return "ASSET";
    case CollectionItem_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message for creating an Index. */
export interface CreateIndexRequest {
  /**
   * Required. Value for the parent. The resource name of the Corpus under which
   * this index is created. Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}`
   */
  parent: string;
  /**
   * Optional. The ID for the index. This will become the final resource name
   * for the index. If the user does not specify this value, it will be
   * generated by system.
   *
   * This value should be up to 63 characters, and valid characters
   * are /[a-z][0-9]-/. The first character must be a letter, the last could be
   * a letter or a number.
   */
  indexId: string;
  /** Required. The index being created. */
  index: Index | undefined;
}

/** Metadata message for CreateIndexRequest */
export interface CreateIndexMetadata {
  /** Common metadata of the long-running operation. */
  operationMetadata: OperationMetadata | undefined;
}

/** Request message for UpdateIndex. */
export interface UpdateIndexRequest {
  /** Required. The resource being updated. */
  index:
    | Index
    | undefined;
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * Index resource by the update. The fields specified in the update_mask are
   * relative to the resource, not the full request. A field of the resource
   * will be overwritten if it is in the mask. Empty field mask is not allowed.
   * If the mask is "*", it triggers a full update of the index, and also a
   * whole rebuild of index data.
   */
  updateMask: string[] | undefined;
}

/** Metadata message for UpdateIndexRequest */
export interface UpdateIndexMetadata {
  /** Common metadata of the long-running operation. */
  operationMetadata: OperationMetadata | undefined;
}

/** Request message for getting an Index. */
export interface GetIndexRequest {
  /**
   * Required. Name of the Index resource.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/indexes/{index}`
   */
  name: string;
}

/** Request message for listing Indexes. */
export interface ListIndexesRequest {
  /**
   * Required. The parent corpus that owns this collection of indexes.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}`
   */
  parent: string;
  /**
   * The maximum number of indexes to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 indexes will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListIndexes` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListIndexes` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

/** Response message for ListIndexes. */
export interface ListIndexesResponse {
  /** The indexes under the specified corpus. */
  indexes: Index[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request message for DeleteIndex. */
export interface DeleteIndexRequest {
  /**
   * Required. The name of the index to delete.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/indexes/{index}`
   */
  name: string;
}

/** Metadata message for DeleteIndexRequest */
export interface DeleteIndexMetadata {
}

/**
 * An Index is a resource in Corpus. It contains an indexed version of the
 * assets and annotations. When deployed to an endpoint, it will allow users to
 * search the Index.
 */
export interface Index {
  /** Include all assets under the corpus. */
  entireCorpus?:
    | boolean
    | undefined;
  /**
   * Output only. Resource name of the Index resource.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/indexes/{index_id}`
   */
  name: string;
  /** Optional. Optional user-specified display name of the index. */
  displayName: string;
  /** Optional. Optional description of the index. */
  description: string;
  /** Output only. State of the index. */
  state: Index_State;
  /** Output only. The create timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update timestamp. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. References to the deployed index instance.
   * Index of VIDEO_ON_DEMAND corpus can have at most one deployed index.
   * Index of IMAGE corpus can have multiple deployed indexes.
   */
  deployedIndexes: DeployedIndexReference[];
  /**
   * Output only. This boolean field is only set for projects that have Physical
   * Zone Separation enabled via an Org Policy constraint. It is set to true
   * when the index is a valid zone separated index and false if it isn't.
   */
  satisfiesPzs?:
    | boolean
    | undefined;
  /**
   * Output only. This boolean field is only set for projects that have Physical
   * Zone Isolation enabled via an Org Policy constraint. It is set to true when
   * the index is a valid zone isolated index and false if it isn't.
   */
  satisfiesPzi?: boolean | undefined;
}

/**
 * Enum representing the different states through which an Index might cycle
 * during its lifetime.
 */
export enum Index_State {
  /** STATE_UNSPECIFIED - The default value. Should not be used. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - State CREATING. */
  CREATING = 1,
  /** CREATED - State CREATED. */
  CREATED = 2,
  /** UPDATING - State UPDATING. */
  UPDATING = 3,
  UNRECOGNIZED = -1,
}

export function index_StateFromJSON(object: any): Index_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Index_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Index_State.CREATING;
    case 2:
    case "CREATED":
      return Index_State.CREATED;
    case 3:
    case "UPDATING":
      return Index_State.UPDATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Index_State.UNRECOGNIZED;
  }
}

export function index_StateToJSON(object: Index_State): string {
  switch (object) {
    case Index_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Index_State.CREATING:
      return "CREATING";
    case Index_State.CREATED:
      return "CREATED";
    case Index_State.UPDATING:
      return "UPDATING";
    case Index_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Points to a DeployedIndex. */
export interface DeployedIndexReference {
  /** Immutable. A resource name of the IndexEndpoint. */
  indexEndpoint: string;
}

/**
 * Corpus is a set of media contents for management.
 * Within a corpus, media shares the same data schema. Search is also restricted
 * within a single corpus.
 */
export interface Corpus {
  /**
   * Resource name of the corpus.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}`
   */
  name: string;
  /**
   * Required. The corpus name to shown in the UI. The name can be up to 32
   * characters long.
   */
  displayName: string;
  /** Optional. Description of the corpus. Can be up to 25000 characters long. */
  description: string;
  /**
   * Optional. The default TTL value for all assets under the corpus without a
   * asset level user-defined TTL. For STREAM_VIDEO type corpora, this is
   * required and the maximum allowed
   *   default_ttl is 10 years.
   */
  defaultTtl:
    | Duration
    | undefined;
  /** Optional. Type of the asset inside corpus. */
  type: Corpus_Type;
  /** Default search capability setting on corpus level. */
  searchCapabilitySetting:
    | SearchCapabilitySetting
    | undefined;
  /**
   * Output only. This boolean field is only set for projects that have Physical
   * Zone Separation enabled via an Org Policy constraint. It is set to true
   * when the corpus is a valid zone separated corpus and false if it isn't.
   */
  satisfiesPzs?:
    | boolean
    | undefined;
  /**
   * Output only. This boolean field is only set for projects that have Physical
   * Zone Isolation enabled via an Org Policy constraint. It is set to true when
   * the corpus is a valid zone isolated corpus and false if it isn't.
   */
  satisfiesPzi?: boolean | undefined;
}

/** Type of the asset inside the corpus. */
export enum Corpus_Type {
  /**
   * TYPE_UNSPECIFIED - The default type, not supposed to be used. If this default type is used,
   * the corpus will be created as STREAM_VIDEO corpus.
   */
  TYPE_UNSPECIFIED = 0,
  /** STREAM_VIDEO - Asset is a live streaming video. */
  STREAM_VIDEO = 1,
  /** IMAGE - Asset is an image. */
  IMAGE = 2,
  /** VIDEO_ON_DEMAND - Asset is a batch video. */
  VIDEO_ON_DEMAND = 3,
  UNRECOGNIZED = -1,
}

export function corpus_TypeFromJSON(object: any): Corpus_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Corpus_Type.TYPE_UNSPECIFIED;
    case 1:
    case "STREAM_VIDEO":
      return Corpus_Type.STREAM_VIDEO;
    case 2:
    case "IMAGE":
      return Corpus_Type.IMAGE;
    case 3:
    case "VIDEO_ON_DEMAND":
      return Corpus_Type.VIDEO_ON_DEMAND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Corpus_Type.UNRECOGNIZED;
  }
}

export function corpus_TypeToJSON(object: Corpus_Type): string {
  switch (object) {
    case Corpus_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Corpus_Type.STREAM_VIDEO:
      return "STREAM_VIDEO";
    case Corpus_Type.IMAGE:
      return "IMAGE";
    case Corpus_Type.VIDEO_ON_DEMAND:
      return "VIDEO_ON_DEMAND";
    case Corpus_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for GetCorpus. */
export interface GetCorpusRequest {
  /** Required. The resource name of the corpus to retrieve. */
  name: string;
}

/** Request message for UpdateCorpus. */
export interface UpdateCorpusRequest {
  /** Required. The corpus which replaces the resource on the server. */
  corpus:
    | Corpus
    | undefined;
  /** The list of fields to be updated. */
  updateMask: string[] | undefined;
}

/** Request message for ListCorpora. */
export interface ListCorporaRequest {
  /** Required. The resource name of the project from which to list corpora. */
  parent: string;
  /**
   * Requested page size. API may return fewer results than requested.
   * If negative, INVALID_ARGUMENT error will be returned.
   * If unspecified or 0, API will pick a default size, which is 10.
   * If the requested page size is larger than the maximum size, API will pick
   * use the maximum size, which is 20.
   */
  pageSize: number;
  /**
   * A token identifying a page of results for the server to return.
   * Typically obtained via
   * [ListCorporaResponse.next_page_token][google.cloud.visionai.v1.ListCorporaResponse.next_page_token]
   * of the previous
   * [Warehouse.ListCorpora][google.cloud.visionai.v1.Warehouse.ListCorpora]
   * call.
   */
  pageToken: string;
  /**
   * The filter applied to the returned corpora list.
   * Only the following restrictions are supported:
   * `type=<Corpus.Type>`,
   * `type!=<Corpus.Type>`.
   */
  filter: string;
}

/** Response message for ListCorpora. */
export interface ListCorporaResponse {
  /** The corpora in the project. */
  corpora: Corpus[];
  /**
   * A token to retrieve next page of results.
   * Pass to
   * [ListCorporaRequest.page_token][google.cloud.visionai.v1.ListCorporaRequest.page_token]
   * to obtain that page.
   */
  nextPageToken: string;
}

/** Request message for DeleteCorpus. */
export interface DeleteCorpusRequest {
  /** Required. The resource name of the corpus to delete. */
  name: string;
}

/** Request message for AnalyzeCorpus. */
export interface AnalyzeCorpusRequest {
  /**
   * Required. The parent corpus resource where the assets will be analyzed.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}`
   */
  name: string;
}

/** The metadata message for AnalyzeCorpus LRO. */
export interface AnalyzeCorpusMetadata {
  /** The metadata of the operation. */
  metadata: OperationMetadata | undefined;
}

/** The response message for AnalyzeCorpus LRO. */
export interface AnalyzeCorpusResponse {
}

/** Request message for CreateDataSchema. */
export interface CreateDataSchemaRequest {
  /**
   * Required. The parent resource where this data schema will be created.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}`
   */
  parent: string;
  /** Required. The data schema to create. */
  dataSchema: DataSchema | undefined;
}

/**
 * Data schema indicates how the user specified annotation is interpreted in the
 * system.
 */
export interface DataSchema {
  /**
   * Resource name of the data schema in the form of:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/dataSchemas/{data_schema}`
   * where {data_schema} part should be the same as the `key` field below.
   */
  name: string;
  /**
   * Required. The key of this data schema. This key should be matching the key
   * of user specified annotation and unique inside corpus. This value can be up
   * to 63 characters, and valid characters are /[a-z][0-9]-/. The first
   * character must be a letter, the last could be a letter or a number.
   */
  key: string;
  /** The schema details mapping to the key. */
  schemaDetails: DataSchemaDetails | undefined;
}

/**
 * Data schema details indicates the data type and the data struct corresponding
 * to the key of user specified annotation.
 */
export interface DataSchemaDetails {
  /** Type of the annotation. */
  type?:
    | DataSchemaDetails_DataType
    | undefined;
  /** Config for protobuf any type. */
  protoAnyConfig:
    | DataSchemaDetails_ProtoAnyConfig
    | undefined;
  /** Config for List data type. */
  listConfig:
    | DataSchemaDetails_ListConfig
    | undefined;
  /** Config for CustomizedStruct data type. */
  customizedStructConfig:
    | DataSchemaDetails_CustomizedStructConfig
    | undefined;
  /** The granularity associated with this DataSchema. */
  granularity?:
    | DataSchemaDetails_Granularity
    | undefined;
  /** The search strategy to be applied on the `key` above. */
  searchStrategy: DataSchemaDetails_SearchStrategy | undefined;
}

/** Data type of the annotation. */
export enum DataSchemaDetails_DataType {
  /** DATA_TYPE_UNSPECIFIED - Unspecified type. */
  DATA_TYPE_UNSPECIFIED = 0,
  /**
   * INTEGER - Integer type.
   * Allowed search strategies:
   * - DataSchema.SearchStrategy.NO_SEARCH,
   * - DataSchema.SearchStrategy.EXACT_SEARCH.
   *   Supports query by IntRangeArray.
   */
  INTEGER = 1,
  /**
   * FLOAT - Float type.
   * Allowed search strategies:
   * - DataSchema.SearchStrategy.NO_SEARCH,
   * - DataSchema.SearchStrategy.EXACT_SEARCH.
   *   Supports query by FloatRangeArray.
   */
  FLOAT = 2,
  /**
   * STRING - String type.
   * Allowed search strategies:
   * - DataSchema.SearchStrategy.NO_SEARCH,
   * - DataSchema.SearchStrategy.EXACT_SEARCH,
   * - DataSchema.SearchStrategy.SMART_SEARCH.
   */
  STRING = 3,
  /**
   * DATETIME - Supported formats:
   * %Y-%m-%dT%H:%M:%E*S%E*z (absl::RFC3339_full)
   * %Y-%m-%dT%H:%M:%E*S
   * %Y-%m-%dT%H:%M%E*z
   * %Y-%m-%dT%H:%M
   * %Y-%m-%dT%H%E*z
   * %Y-%m-%dT%H
   * %Y-%m-%d%E*z
   * %Y-%m-%d
   * %Y-%m
   * %Y
   * Allowed search strategies:
   * - DataSchema.SearchStrategy.NO_SEARCH,
   * - DataSchema.SearchStrategy.EXACT_SEARCH.
   *   Supports query by DateTimeRangeArray.
   */
  DATETIME = 5,
  /**
   * GEO_COORDINATE - Geo coordinate type.
   * Allowed search strategies:
   * - DataSchema.SearchStrategy.NO_SEARCH,
   * - DataSchema.SearchStrategy.EXACT_SEARCH.
   *   Supports query by GeoLocationArray.
   */
  GEO_COORDINATE = 7,
  /**
   * PROTO_ANY - Type to pass any proto as available in annotations.proto. Only use
   * internally.
   * Available proto types and its corresponding search behavior:
   * - ImageObjectDetectionPredictionResult, allows SMART_SEARCH on
   *   display_names and NO_SEARCH.
   * - ClassificationPredictionResult, allows SMART_SEARCH on display_names
   *   and NO_SEARCH.
   * - ImageSegmentationPredictionResult, allows NO_SEARCH.
   * - VideoActionRecognitionPredictionResult, allows SMART_SEARCH on
   *   display_name and NO_SEARCH.
   * - VideoObjectTrackingPredictionResult, allows SMART_SEARCH on
   *   display_name and NO_SEARCH.
   * - VideoClassificationPredictionResult, allows SMART_SEARCH on
   *   display_name and NO_SEARCH.
   * - OccupancyCountingPredictionResult, allows EXACT_SEARCH on
   *   stats.full_frame_count.count and NO_SEARCH.
   * - ObjectDetectionPredictionResult, allows SMART_SEARCH on
   *   identified_boxes.entity.label_string and NO_SEARCH.
   */
  PROTO_ANY = 8,
  /**
   * BOOLEAN - Boolean type.
   * Allowed search strategies:
   * - DataSchema.SearchStrategy.NO_SEARCH,
   * - DataSchema.SearchStrategy.EXACT_SEARCH.
   */
  BOOLEAN = 9,
  /**
   * LIST - List type.
   *  - Each element in the list must be of the exact same data schema;
   *    otherwise, they are invalid arguments.
   *  - List level cannot set search strategy. Leaf node level can do.
   *  - Elements cannot be another list (no list of list).
   *  - Elements can be CUSTOMIZED_STRUCT, and max number of layers is 10.
   */
  LIST = 10,
  /**
   * CUSTOMIZED_STRUCT - Struct type.
   * - SearchStrategy:
   *   * Data Schema that's CUSTOMIZED_STRUCT cannot set search strategy.
   *   * Leaf-node elements allow setting search strategy based on element's
   *     SearchStrategy restriction.
   * - Nested layer restrictions:
   *   * Data Schema that's CUSTOMIZED_STRUCT allows its fields to be of
   *     CUSTOMIZED_STRUCT as well, but the overall layers restriction is 10.
   */
  CUSTOMIZED_STRUCT = 6,
  UNRECOGNIZED = -1,
}

export function dataSchemaDetails_DataTypeFromJSON(object: any): DataSchemaDetails_DataType {
  switch (object) {
    case 0:
    case "DATA_TYPE_UNSPECIFIED":
      return DataSchemaDetails_DataType.DATA_TYPE_UNSPECIFIED;
    case 1:
    case "INTEGER":
      return DataSchemaDetails_DataType.INTEGER;
    case 2:
    case "FLOAT":
      return DataSchemaDetails_DataType.FLOAT;
    case 3:
    case "STRING":
      return DataSchemaDetails_DataType.STRING;
    case 5:
    case "DATETIME":
      return DataSchemaDetails_DataType.DATETIME;
    case 7:
    case "GEO_COORDINATE":
      return DataSchemaDetails_DataType.GEO_COORDINATE;
    case 8:
    case "PROTO_ANY":
      return DataSchemaDetails_DataType.PROTO_ANY;
    case 9:
    case "BOOLEAN":
      return DataSchemaDetails_DataType.BOOLEAN;
    case 10:
    case "LIST":
      return DataSchemaDetails_DataType.LIST;
    case 6:
    case "CUSTOMIZED_STRUCT":
      return DataSchemaDetails_DataType.CUSTOMIZED_STRUCT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSchemaDetails_DataType.UNRECOGNIZED;
  }
}

export function dataSchemaDetails_DataTypeToJSON(object: DataSchemaDetails_DataType): string {
  switch (object) {
    case DataSchemaDetails_DataType.DATA_TYPE_UNSPECIFIED:
      return "DATA_TYPE_UNSPECIFIED";
    case DataSchemaDetails_DataType.INTEGER:
      return "INTEGER";
    case DataSchemaDetails_DataType.FLOAT:
      return "FLOAT";
    case DataSchemaDetails_DataType.STRING:
      return "STRING";
    case DataSchemaDetails_DataType.DATETIME:
      return "DATETIME";
    case DataSchemaDetails_DataType.GEO_COORDINATE:
      return "GEO_COORDINATE";
    case DataSchemaDetails_DataType.PROTO_ANY:
      return "PROTO_ANY";
    case DataSchemaDetails_DataType.BOOLEAN:
      return "BOOLEAN";
    case DataSchemaDetails_DataType.LIST:
      return "LIST";
    case DataSchemaDetails_DataType.CUSTOMIZED_STRUCT:
      return "CUSTOMIZED_STRUCT";
    case DataSchemaDetails_DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The granularity of annotations under this DataSchema. */
export enum DataSchemaDetails_Granularity {
  /** GRANULARITY_UNSPECIFIED - Unspecified granularity. */
  GRANULARITY_UNSPECIFIED = 0,
  /** GRANULARITY_ASSET_LEVEL - Asset-level granularity (annotations must not contain partition info). */
  GRANULARITY_ASSET_LEVEL = 1,
  /** GRANULARITY_PARTITION_LEVEL - Partition-level granularity (annotations must contain partition info). */
  GRANULARITY_PARTITION_LEVEL = 2,
  UNRECOGNIZED = -1,
}

export function dataSchemaDetails_GranularityFromJSON(object: any): DataSchemaDetails_Granularity {
  switch (object) {
    case 0:
    case "GRANULARITY_UNSPECIFIED":
      return DataSchemaDetails_Granularity.GRANULARITY_UNSPECIFIED;
    case 1:
    case "GRANULARITY_ASSET_LEVEL":
      return DataSchemaDetails_Granularity.GRANULARITY_ASSET_LEVEL;
    case 2:
    case "GRANULARITY_PARTITION_LEVEL":
      return DataSchemaDetails_Granularity.GRANULARITY_PARTITION_LEVEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSchemaDetails_Granularity.UNRECOGNIZED;
  }
}

export function dataSchemaDetails_GranularityToJSON(object: DataSchemaDetails_Granularity): string {
  switch (object) {
    case DataSchemaDetails_Granularity.GRANULARITY_UNSPECIFIED:
      return "GRANULARITY_UNSPECIFIED";
    case DataSchemaDetails_Granularity.GRANULARITY_ASSET_LEVEL:
      return "GRANULARITY_ASSET_LEVEL";
    case DataSchemaDetails_Granularity.GRANULARITY_PARTITION_LEVEL:
      return "GRANULARITY_PARTITION_LEVEL";
    case DataSchemaDetails_Granularity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The configuration for `PROTO_ANY` data type. */
export interface DataSchemaDetails_ProtoAnyConfig {
  /** The type URI of the proto message. */
  typeUri: string;
}

/** The configuration for `LIST` data type. */
export interface DataSchemaDetails_ListConfig {
  /** The value's data schema in the list. */
  valueSchema: DataSchemaDetails | undefined;
}

/** The configuration for `CUSTOMIZED_STRUCT` data type. */
export interface DataSchemaDetails_CustomizedStructConfig {
  /** Direct child elements data schemas. */
  fieldSchemas: { [key: string]: DataSchemaDetails };
}

export interface DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry {
  key: string;
  value: DataSchemaDetails | undefined;
}

/** The search strategy for annotations value of the `key`. */
export interface DataSchemaDetails_SearchStrategy {
  /**
   * The type of search strategy to be applied on the `key` above.
   * The allowed `search_strategy_type` is different for different data types,
   * which is documented in the DataSchemaDetails.DataType. Specifying
   * unsupported `search_strategy_type` for data types will result in
   * INVALID_ARGUMENT error.
   */
  searchStrategyType?:
    | DataSchemaDetails_SearchStrategy_SearchStrategyType
    | undefined;
  /**
   * Optional. Configs the path to the confidence score, and the threshold.
   * Only if the score is greater than the threshold, current field will be
   * built into the index. Only applies to leaf nodes using EXACT_SEARCH or
   * SMART_SEARCH.
   */
  confidenceScoreIndexConfig: DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig | undefined;
}

/** The types of search strategies to be applied on the annotation key. */
export enum DataSchemaDetails_SearchStrategy_SearchStrategyType {
  /** NO_SEARCH - Annotatation values of the `key` above will not be searchable. */
  NO_SEARCH = 0,
  /**
   * EXACT_SEARCH - When searching with `key`, the value must be exactly as the annotation
   * value that has been ingested.
   */
  EXACT_SEARCH = 1,
  /**
   * SMART_SEARCH - When searching with `key`, Warehouse will perform broad search based on
   * semantic of the annotation value.
   */
  SMART_SEARCH = 2,
  UNRECOGNIZED = -1,
}

export function dataSchemaDetails_SearchStrategy_SearchStrategyTypeFromJSON(
  object: any,
): DataSchemaDetails_SearchStrategy_SearchStrategyType {
  switch (object) {
    case 0:
    case "NO_SEARCH":
      return DataSchemaDetails_SearchStrategy_SearchStrategyType.NO_SEARCH;
    case 1:
    case "EXACT_SEARCH":
      return DataSchemaDetails_SearchStrategy_SearchStrategyType.EXACT_SEARCH;
    case 2:
    case "SMART_SEARCH":
      return DataSchemaDetails_SearchStrategy_SearchStrategyType.SMART_SEARCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSchemaDetails_SearchStrategy_SearchStrategyType.UNRECOGNIZED;
  }
}

export function dataSchemaDetails_SearchStrategy_SearchStrategyTypeToJSON(
  object: DataSchemaDetails_SearchStrategy_SearchStrategyType,
): string {
  switch (object) {
    case DataSchemaDetails_SearchStrategy_SearchStrategyType.NO_SEARCH:
      return "NO_SEARCH";
    case DataSchemaDetails_SearchStrategy_SearchStrategyType.EXACT_SEARCH:
      return "EXACT_SEARCH";
    case DataSchemaDetails_SearchStrategy_SearchStrategyType.SMART_SEARCH:
      return "SMART_SEARCH";
    case DataSchemaDetails_SearchStrategy_SearchStrategyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Filter on the confidence score. Only adds to index if the confidence
 * score is higher than the threshold.
 * Example data schema:
 * key: "name-confidence-pair"
 * type: CUSTOMIZED_STRUCT
 * granularity: GRANULARITY_PARTITION_LEVEL
 * customized_struct_config {
 *   field_schemas {
 *     key: "name"
 *     type: STRING
 *     granularity: GRANULARITY_PARTITION_LEVEL
 *     search_strategy {
 *       search_strategy_type: SMART_SEARCH
 *       confidence_score_index_config {
 *         field_path: "name-confidence-pair.score"
 *         threshold: 0.6
 *       }
 *     }
 *   }
 *   field_schemas {
 *     key: "score"
 *     type: FLOAT
 *     granularity: GRANULARITY_PARTITION_LEVEL
 *   }
 * }
 * This means only "name" with score > 0.6 will be indexed.
 */
export interface DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig {
  /**
   * Required. The path to the confidence score field. It is a string that
   * concatenates all the data schema keys along the path. See the example
   * above. If the data schema contains LIST, use '_ENTRIES' to concatenate.
   * Example data schema contains a list:
   * "key": "list-name-score",
   * "schemaDetails": {
   *   "type": "LIST",
   *   "granularity": "GRANULARITY_PARTITION_LEVEL",
   *   "listConfig": {
   *     "valueSchema": {
   *       "type": "CUSTOMIZED_STRUCT",
   *       "granularity": "GRANULARITY_PARTITION_LEVEL",
   *       "customizedStructConfig": {
   *         "fieldSchemas": {
   *           "name": {
   *             "type": "STRING",
   *             "granularity": "GRANULARITY_PARTITION_LEVEL",
   *             "searchStrategy": {
   *               "searchStrategyType": "SMART_SEARCH"
   *               "confidence_score_index_config": {
   *                 "field_path": "list-name-score._ENTRIES.score",
   *                 "threshold": "0.9",
   *               }
   *             }
   *           },
   *           "score": {
   *             "type": "FLOAT",
   *             "granularity": "GRANULARITY_PARTITION_LEVEL",
   *           }
   *         }
   *       }
   *     }
   *   }
   * }
   */
  fieldPath: string;
  /** Required. The threshold. */
  threshold: number;
}

/** Request message for UpdateDataSchema. */
export interface UpdateDataSchemaRequest {
  /**
   * Required. The data schema's `name` field is used to identify the data
   * schema to be updated. Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/dataSchemas/{data_schema}`
   */
  dataSchema:
    | DataSchema
    | undefined;
  /** The list of fields to be updated. */
  updateMask: string[] | undefined;
}

/** Request message for GetDataSchema. */
export interface GetDataSchemaRequest {
  /**
   * Required. The name of the data schema to retrieve.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/dataSchemas/{data_schema_id}`
   */
  name: string;
}

/** Request message for DeleteDataSchema. */
export interface DeleteDataSchemaRequest {
  /**
   * Required. The name of the data schema to delete.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/dataSchemas/{data_schema_id}`
   */
  name: string;
}

/** Request message for ListDataSchemas. */
export interface ListDataSchemasRequest {
  /**
   * Required. The parent, which owns this collection of data schemas.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}`
   */
  parent: string;
  /**
   * The maximum number of data schemas to return. The service may return fewer
   * than this value. If unspecified, at most 50 data schemas will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListDataSchemas` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListDataSchemas` must
   * match the call that provided the page token.
   */
  pageToken: string;
}

/** Response message for ListDataSchemas. */
export interface ListDataSchemasResponse {
  /** The data schemas from the specified corpus. */
  dataSchemas: DataSchema[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request message for CreateAnnotation. */
export interface CreateAnnotationRequest {
  /**
   * Required. The parent resource where this annotation will be created.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}`
   */
  parent: string;
  /** Required. The annotation to create. */
  annotation:
    | Annotation
    | undefined;
  /**
   * Optional. The ID to use for the annotation, which will become the final
   * component of the annotation's resource name if user choose to specify.
   * Otherwise, annotation id will be generated by system.
   *
   * This value should be up to 63 characters, and valid characters
   * are /[a-z][0-9]-/. The first character must be a letter, the last could be
   * a letter or a number.
   */
  annotationId?: string | undefined;
}

/**
 * An annotation is a resource in asset. It represents a key-value mapping of
 * content in asset.
 */
export interface Annotation {
  /**
   * Resource name of the annotation.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}/annotations/{annotation}`
   */
  name: string;
  /** User provided annotation. */
  userSpecifiedAnnotation: UserSpecifiedAnnotation | undefined;
}

/** Annotation provided by users. */
export interface UserSpecifiedAnnotation {
  /**
   * Required. Key of the annotation. The key must be set with type by
   * CreateDataSchema.
   */
  key: string;
  /**
   * Value of the annotation. The value must be able to convert
   * to the type according to the data schema.
   */
  value:
    | AnnotationValue
    | undefined;
  /** Partition information in time and space for the sub-asset level annotation. */
  partition: Partition | undefined;
}

/** Location Coordinate Representation */
export interface GeoCoordinate {
  /** Latitude Coordinate. Degrees [-90 .. 90] */
  latitude: number;
  /** Longitude Coordinate. Degrees [-180 .. 180] */
  longitude: number;
}

/** Value of annotation, including all types available in data schema. */
export interface AnnotationValue {
  /** Value of int type annotation. */
  intValue?:
    | Long
    | undefined;
  /** Value of float type annotation. */
  floatValue?:
    | number
    | undefined;
  /** Value of string type annotation. */
  strValue?:
    | string
    | undefined;
  /** Value of date time type annotation. */
  datetimeValue?:
    | string
    | undefined;
  /** Value of geo coordinate type annotation. */
  geoCoordinate?:
    | GeoCoordinate
    | undefined;
  /** Value of any proto value. */
  protoAnyValue?:
    | Any
    | undefined;
  /** Value of boolean type annotation. */
  boolValue?:
    | boolean
    | undefined;
  /**
   * Value of customized struct annotation. This field does not have effects.
   * Use customized_struct_value instead for customized struct annotation.
   */
  customizedStructDataValue?:
    | { [key: string]: any }
    | undefined;
  /** Value of list type annotation. */
  listValue?:
    | AnnotationList
    | undefined;
  /** Value of custom struct type annotation. */
  customizedStructValue?: AnnotationCustomizedStruct | undefined;
}

/** List representation in annotation. */
export interface AnnotationList {
  /** The values of `LIST` data type annotation. */
  values: AnnotationValue[];
}

/** Customized struct represnation in annotation. */
export interface AnnotationCustomizedStruct {
  /** A map from elements' keys to element's annotation value. */
  elements: { [key: string]: AnnotationValue };
}

export interface AnnotationCustomizedStruct_ElementsEntry {
  key: string;
  value: AnnotationValue | undefined;
}

/** Request message for GetAnnotation API. */
export interface ListAnnotationsRequest {
  /**
   * The parent, which owns this collection of annotations.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}`
   */
  parent: string;
  /**
   * The maximum number of annotations to return. The service may return fewer
   * than this value. If unspecified, at most 50 annotations will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListAnnotations` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListAnnotations` must
   * match the call that provided the page token.
   */
  pageToken: string;
  /**
   * The filter applied to the returned list.
   * We only support filtering for the following fields:
   * For corpus of STREAM_VIDEO type:
   * `partition.temporal_partition.start_time`,
   * `partition.temporal_partition.end_time`, and `key`.
   * For corpus of VIDEO_ON_DEMAND type,
   * `partition.relative_temporal_partition.start_offset`,
   * `partition.relative_temporal_partition.end_offset`, and `key`.
   * For corpus of IMAGE type, only `key` is supported.
   * Timestamps are specified in the RFC-3339 format, and only one restriction
   * may be applied per field, joined by conjunctions.
   * Format:
   * "partition.temporal_partition.start_time > "2012-04-21T11:30:00-04:00" AND
   * partition.temporal_partition.end_time < "2012-04-22T11:30:00-04:00" AND
   * key = "example_key""
   */
  filter: string;
}

/** Request message for ListAnnotations API. */
export interface ListAnnotationsResponse {
  /** The annotations from the specified asset. */
  annotations: Annotation[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request message for GetAnnotation API. */
export interface GetAnnotationRequest {
  /**
   * Required. The name of the annotation to retrieve.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}/annotations/{annotation}`
   */
  name: string;
}

/** Request message for UpdateAnnotation API. */
export interface UpdateAnnotationRequest {
  /**
   * Required. The annotation to update.
   * The annotation's `name` field is used to identify the annotation to be
   * updated. Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}/annotations/{annotation}`
   */
  annotation:
    | Annotation
    | undefined;
  /** The list of fields to be updated. */
  updateMask: string[] | undefined;
}

/** Request message for DeleteAnnotation API. */
export interface DeleteAnnotationRequest {
  /**
   * Required. The name of the annotation to delete.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/assets/{asset}/annotations/{annotation}`
   */
  name: string;
}

/** The request message for ImportAssets. */
export interface ImportAssetsRequest {
  /**
   * The file contains all assets information to be imported.
   * * The file is in JSONL format.
   * * Each line corresponding to one asset.
   * * Each line will be converted into InputImageAsset proto.
   */
  assetsGcsUri?:
    | string
    | undefined;
  /**
   * Required. The parent corpus resource where the assets will be imported.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}`
   */
  parent: string;
}

/** The metadata message for ImportAssets LRO. */
export interface ImportAssetsMetadata {
  /** The metadata of the operation. */
  metadata:
    | OperationMetadata
    | undefined;
  /**
   * The importing status including partial failures, if the implementation can
   * provide such information during the progress of the ImportAssets.
   */
  status: BatchOperationStatus | undefined;
}

/** The batch operation status. */
export interface BatchOperationStatus {
  /**
   * The count of assets (together with their annotations if any) successfully
   * ingested.
   */
  successCount: number;
  /**
   * The count of assets failed to ingested; it might be due to the annotation
   * ingestion error.
   */
  failureCount: number;
}

/** The response message for ImportAssets LRO. */
export interface ImportAssetsResponse {
}

/** Request message for CreateSearchConfig. */
export interface CreateSearchConfigRequest {
  /**
   * Required. The parent resource where this search configuration will be
   * created. Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}`
   */
  parent: string;
  /** Required. The search config to create. */
  searchConfig:
    | SearchConfig
    | undefined;
  /**
   * Required. ID to use for the new search config. Will become the final
   * component of the SearchConfig's resource name. This value should be up to
   * 63 characters, and valid characters are /[a-z][0-9]-_/. The first character
   * must be a letter, the last could be a letter or a number.
   */
  searchConfigId: string;
}

/** Request message for UpdateSearchConfig. */
export interface UpdateSearchConfigRequest {
  /**
   * Required. The search configuration to update.
   *
   * The search configuration's `name` field is used to identify the resource to
   * be updated. Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/searchConfigs/{search_config}`
   */
  searchConfig:
    | SearchConfig
    | undefined;
  /**
   * The list of fields to be updated. If left unset, all field paths will be
   * updated/overwritten.
   */
  updateMask: string[] | undefined;
}

/** Request message for GetSearchConfig. */
export interface GetSearchConfigRequest {
  /**
   * Required. The name of the search configuration to retrieve.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/searchConfigs/{search_config}`
   */
  name: string;
}

/** Request message for DeleteSearchConfig. */
export interface DeleteSearchConfigRequest {
  /**
   * Required. The name of the search configuration to delete.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/searchConfigs/{search_config}`
   */
  name: string;
}

/** Request message for ListSearchConfigs. */
export interface ListSearchConfigsRequest {
  /**
   * Required. The parent, which owns this collection of search configurations.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}`
   */
  parent: string;
  /**
   * The maximum number of search configurations to return. The service may
   * return fewer than this value. If unspecified, a page size of 50 will be
   * used. The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListSearchConfigs` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListSearchConfigs` must match the call that provided the page
   * token.
   */
  pageToken: string;
}

/** Response message for ListSearchConfigs. */
export interface ListSearchConfigsResponse {
  /** The search configurations from the specified corpus. */
  searchConfigs: SearchConfig[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/**
 * SearchConfig stores different properties that will affect search
 * behaviors and search results.
 */
export interface SearchConfig {
  /**
   * Resource name of the search configuration.
   * For CustomSearchCriteria, search_config would be the search
   * operator name. For Facets, search_config would be the facet
   * dimension name.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/searchConfigs/{search_config}`
   */
  name: string;
  /** Establishes a FacetDimension and associated specifications. */
  facetProperty:
    | FacetProperty
    | undefined;
  /** Creates a mapping between a custom SearchCriteria and one or more UGA keys. */
  searchCriteriaProperty: SearchCriteriaProperty | undefined;
}

/** Message representing IndexEndpoint resource. Indexes are deployed into it. */
export interface IndexEndpoint {
  /**
   * Output only. Resource name of the IndexEndpoint.
   * Format:
   * `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint_id}`
   */
  name: string;
  /**
   * Optional. Display name of the IndexEndpoint. Can be up to 32 characters
   * long.
   */
  displayName: string;
  /**
   * Optional. Description of the IndexEndpoint. Can be up to 25000 characters
   * long.
   */
  description: string;
  /** Output only. The Index deployed in this IndexEndpoint. */
  deployedIndex:
    | DeployedIndex
    | undefined;
  /** Output only. IndexEndpoint state. */
  state: IndexEndpoint_State;
  /**
   * Optional. The labels applied to a resource must meet the following
   * requirements:
   *
   * * Each resource can have multiple labels, up to a maximum of 64.
   * * Each label must be a key-value pair.
   * * Keys have a minimum length of 1 character and a maximum length of 63
   *   characters and cannot be empty. Values can be empty and have a maximum
   *   length of 63 characters.
   * * Keys and values can contain only lowercase letters, numeric characters,
   *   underscores, and dashes. All characters must use UTF-8 encoding, and
   *   international characters are allowed.
   * * The key portion of a label must be unique. However, you can use the same
   *   key with multiple resources.
   * * Keys must start with a lowercase letter or international character.
   *
   * See [Google Cloud
   * Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
   * for more details.
   */
  labels: { [key: string]: string };
  /** Output only. Create timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. Update timestamp. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. This boolean field is only set for projects that have Physical
   * Zone Separation enabled via an Org Policy constraint. It is set to true
   * when the index endpoint is a valid zone separated index endpoint and false
   * if it isn't.
   */
  satisfiesPzs?:
    | boolean
    | undefined;
  /**
   * Output only. This boolean field is only set for projects that have Physical
   * Zone Isolation enabled via an Org Policy constraint. It is set to true when
   * the index endpoint is a valid zone isolated index endpoint and false if it
   * isn't.
   */
  satisfiesPzi?: boolean | undefined;
}

/** IndexEndpoint stage. */
export enum IndexEndpoint_State {
  /** STATE_UNSPECIFIED - The default value. Should not be used. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - State CREATING. */
  CREATING = 1,
  /** CREATED - State CREATED. */
  CREATED = 2,
  /** UPDATING - State UPDATING. */
  UPDATING = 3,
  /** FAILED - State FAILED. */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function indexEndpoint_StateFromJSON(object: any): IndexEndpoint_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return IndexEndpoint_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return IndexEndpoint_State.CREATING;
    case 2:
    case "CREATED":
      return IndexEndpoint_State.CREATED;
    case 3:
    case "UPDATING":
      return IndexEndpoint_State.UPDATING;
    case 4:
    case "FAILED":
      return IndexEndpoint_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IndexEndpoint_State.UNRECOGNIZED;
  }
}

export function indexEndpoint_StateToJSON(object: IndexEndpoint_State): string {
  switch (object) {
    case IndexEndpoint_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case IndexEndpoint_State.CREATING:
      return "CREATING";
    case IndexEndpoint_State.CREATED:
      return "CREATED";
    case IndexEndpoint_State.UPDATING:
      return "UPDATING";
    case IndexEndpoint_State.FAILED:
      return "FAILED";
    case IndexEndpoint_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface IndexEndpoint_LabelsEntry {
  key: string;
  value: string;
}

/** Request message for CreateIndexEndpoint. */
export interface CreateIndexEndpointRequest {
  /** Required. Format: `projects/{project}/locations/{location}` */
  parent: string;
  /**
   * Optional. The ID to use for the IndexEndpoint, which will become the final
   * component of the IndexEndpoint's resource name if the user specifies it.
   * Otherwise, IndexEndpoint id will be autogenerated.
   *
   * This value should be up to 63 characters, and valid characters
   * are a-z, 0-9 and dash (-). The first character must be a letter, the last
   * must be a letter or a number.
   */
  indexEndpointId: string;
  /** Required. The resource being created. */
  indexEndpoint: IndexEndpoint | undefined;
}

/** Metadata message for CreateIndexEndpoint. */
export interface CreateIndexEndpointMetadata {
  /** Common metadata of the long-running operation. */
  operationMetadata: OperationMetadata | undefined;
}

/** Request message for GetIndexEndpoint. */
export interface GetIndexEndpointRequest {
  /** Required. Name of the IndexEndpoint resource. */
  name: string;
}

/** Request message for ListIndexEndpoints. */
export interface ListIndexEndpointsRequest {
  /** Required. Format: `projects/{project}/locations/{location}` */
  parent: string;
  /**
   * Optional. Requested page size. Server may return fewer items than
   * requested. The service may return fewer than this value. If unspecified, a
   * page size of 50 will be used. The maximum value is 1000; values above 1000
   * will be coerced to 1000.
   */
  pageSize: number;
  /** Optional. A token identifying a page of results the server should return. */
  pageToken: string;
  /**
   * Optional. The filter applied to the returned list.
   * We only support filtering for the `deployed_image_index.image_index` field.
   * However, to filter by a corpus instead of an image index, simply use
   * `deployed_image_index.corpus`, which will return all endpoints with
   * `deployed_image_index.image_index` inside of the given corpus.
   * A basic filter on image index would look like:
   *   deployed_image_index.image_index =
   *     "projects/123/locations/us-central1/corpora/my_corpus/imageIndexes/my_image_index"
   * A basic filter on corpus would look like:
   *   deployed_image_index.corpus =
   *     "projects/123/locations/us-central1/corpora/my_corpus"
   */
  filter: string;
}

/** Response message for ListIndexEndpoints. */
export interface ListIndexEndpointsResponse {
  /** The list of IndexEndpoints. */
  indexEndpoints: IndexEndpoint[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
}

/** Request message for UpdateIndexEndpoint. */
export interface UpdateIndexEndpointRequest {
  /** Required. The resource being updated. */
  indexEndpoint:
    | IndexEndpoint
    | undefined;
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * IndexEndpoint resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request.
   * A field of the resource will be overwritten if it is in the mask.
   * Empty field mask is not allowed.
   * If the mask is "*", then this is a full replacement of the resource.
   */
  updateMask: string[] | undefined;
}

/** Metadata message for UpdateIndexEndpoint. */
export interface UpdateIndexEndpointMetadata {
  /** Common metadata of the long-running operation. */
  operationMetadata: OperationMetadata | undefined;
}

/** Request message for DeleteIndexEndpoint. */
export interface DeleteIndexEndpointRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** Metadata message for DeleteIndexEndpoint. */
export interface DeleteIndexEndpointMetadata {
  /** Common metadata of the long-running operation. */
  operationMetadata: OperationMetadata | undefined;
}

/** Request message for DeployIndex. */
export interface DeployIndexRequest {
  /**
   * Required. IndexEndpoint the index is deployed to.
   * Format:
   * `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
   */
  indexEndpoint: string;
  /** Required. Index to deploy. */
  deployedIndex: DeployedIndex | undefined;
}

/** DeployIndex response once the operation is done. */
export interface DeployIndexResponse {
}

/** Metadata message for DeployIndex. */
export interface DeployIndexMetadata {
  /** Common metadata of the long-running operation. */
  operationMetadata:
    | OperationMetadata
    | undefined;
  /** Output only. The index being deployed. */
  deployedIndex: string;
}

/** Metadata message for UndeployIndex. */
export interface UndeployIndexMetadata {
  /** Common metadata of the long-running operation. */
  operationMetadata:
    | OperationMetadata
    | undefined;
  /** Output only. The index being undeployed. */
  deployedIndex: string;
}

/** Request message for UndeployIndexEndpoint. */
export interface UndeployIndexRequest {
  /**
   * Required. Resource name of the IndexEndpoint resource on which the
   * undeployment will act. Format:
   * `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
   */
  indexEndpoint: string;
}

/** UndeployIndex response once the operation is done. */
export interface UndeployIndexResponse {
}

/** A deployment of an Index. */
export interface DeployedIndex {
  /**
   * Required. Name of the deployed Index.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/indexes/{index_id}`
   */
  index: string;
}

/** Central configuration for a facet. */
export interface FacetProperty {
  /** Fixed range facet bucket config. */
  fixedRangeBucketSpec?:
    | FacetProperty_FixedRangeBucketSpec
    | undefined;
  /** Custom range facet bucket config. */
  customRangeBucketSpec?:
    | FacetProperty_CustomRangeBucketSpec
    | undefined;
  /** Datetime range facet bucket config. */
  datetimeBucketSpec?:
    | FacetProperty_DateTimeBucketSpec
    | undefined;
  /**
   * Name of the facets, which are the dimensions users want to use to refine
   * search results. `mapped_fields` will match UserSpecifiedDataSchema keys.
   *
   * For example, user can add a bunch of UGAs with the same key, such as
   * player:adam, player:bob, player:charles. When multiple mapped_fields are
   * specified, will merge their value together as final facet value. E.g.
   * home_team: a, home_team:b, away_team:a, away_team:c, when facet_field =
   * [home_team, away_team], facet_value will be [a, b, c].
   *
   * UNLESS this is a 1:1 facet dimension (mapped_fields.size() == 1) AND the
   * mapped_field equals the parent SearchConfig.name, the parent must
   * also contain a SearchCriteriaProperty that maps to the same fields.
   * mapped_fields must not be empty.
   */
  mappedFields: string[];
  /** Display name of the facet. To be used by UI for facet rendering. */
  displayName: string;
  /**
   * Maximum number of unique bucket to return for one facet. Bucket number can
   * be large for high-cardinality facet such as "player". We only return top-n
   * most related ones to user. If it's <= 0, the server will decide the
   * appropriate result_size.
   */
  resultSize: Long;
  /** Facet bucket type e.g. value, range. */
  bucketType: FacetBucketType;
}

/**
 * If bucket type is FIXED_RANGE, specify how values are bucketized. Use
 * FixedRangeBucketSpec when you want to create multiple buckets with equal
 * granularities. Using integer bucket value as an example, when
 * bucket_start = 0, bucket_granularity = 10, bucket_count = 5, this facet
 * will be aggregated via the following buckets:
 * [-inf, 0), [0, 10), [10, 20), [20, 30), [30, inf).
 * Notably, bucket_count <= 1 is an invalid spec.
 */
export interface FacetProperty_FixedRangeBucketSpec {
  /**
   * Lower bound of the bucket. NOTE: Only integer type is currently supported
   * for this field.
   */
  bucketStart:
    | FacetValue
    | undefined;
  /**
   * Bucket granularity. NOTE: Only integer type is currently supported for
   * this field.
   */
  bucketGranularity:
    | FacetValue
    | undefined;
  /** Total number of buckets. */
  bucketCount: number;
}

/**
 * If bucket type is CUSTOM_RANGE, specify how values are bucketized. Use
 * integer bucket value as an example, when the endpoints are 0, 10, 100, and
 * 1000, we will generate the following facets:
 * [-inf, 0), [0, 10), [10, 100), [100, 1000), [1000, inf).
 * Notably:
 * - endpoints must be listed in ascending order. Otherwise, the SearchConfig
 *   API will reject the facet config.
 * - < 1 endpoints is an invalid spec.
 */
export interface FacetProperty_CustomRangeBucketSpec {
  /** Currently, only integer type is supported for this field. */
  endpoints: FacetValue[];
}

/** If bucket type is DATE, specify how date values are bucketized. */
export interface FacetProperty_DateTimeBucketSpec {
  /** Granularity of date type facet. */
  granularity: FacetProperty_DateTimeBucketSpec_Granularity;
}

/** Granularity enum for the datetime bucket. */
export enum FacetProperty_DateTimeBucketSpec_Granularity {
  /** GRANULARITY_UNSPECIFIED - Unspecified granularity. */
  GRANULARITY_UNSPECIFIED = 0,
  /** YEAR - Granularity is year. */
  YEAR = 1,
  /** MONTH - Granularity is month. */
  MONTH = 2,
  /** DAY - Granularity is day. */
  DAY = 3,
  UNRECOGNIZED = -1,
}

export function facetProperty_DateTimeBucketSpec_GranularityFromJSON(
  object: any,
): FacetProperty_DateTimeBucketSpec_Granularity {
  switch (object) {
    case 0:
    case "GRANULARITY_UNSPECIFIED":
      return FacetProperty_DateTimeBucketSpec_Granularity.GRANULARITY_UNSPECIFIED;
    case 1:
    case "YEAR":
      return FacetProperty_DateTimeBucketSpec_Granularity.YEAR;
    case 2:
    case "MONTH":
      return FacetProperty_DateTimeBucketSpec_Granularity.MONTH;
    case 3:
    case "DAY":
      return FacetProperty_DateTimeBucketSpec_Granularity.DAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FacetProperty_DateTimeBucketSpec_Granularity.UNRECOGNIZED;
  }
}

export function facetProperty_DateTimeBucketSpec_GranularityToJSON(
  object: FacetProperty_DateTimeBucketSpec_Granularity,
): string {
  switch (object) {
    case FacetProperty_DateTimeBucketSpec_Granularity.GRANULARITY_UNSPECIFIED:
      return "GRANULARITY_UNSPECIFIED";
    case FacetProperty_DateTimeBucketSpec_Granularity.YEAR:
      return "YEAR";
    case FacetProperty_DateTimeBucketSpec_Granularity.MONTH:
      return "MONTH";
    case FacetProperty_DateTimeBucketSpec_Granularity.DAY:
      return "DAY";
    case FacetProperty_DateTimeBucketSpec_Granularity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Search resource: SearchHypernym.
 * For example,
 * { hypernym: "vehicle"
 *   hyponyms: ["sedan", "truck"] }
 * This means in SMART_SEARCH mode, searching for "vehicle" will also return
 * results with "sedan" or "truck" as annotations.
 */
export interface SearchHypernym {
  /**
   * Resource name of the SearchHypernym.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/searchHypernyms/{search_hypernym}`
   */
  name: string;
  /** Optional. The hypernym. */
  hypernym: string;
  /** Optional. Hyponyms that the hypernym is mapped to. */
  hyponyms: string[];
}

/** Request message for creating SearchHypernym. */
export interface CreateSearchHypernymRequest {
  /**
   * Required. The parent resource where this SearchHypernym will be created.
   * Format: `projects/{project_number}/locations/{location}/corpora/{corpus}`
   */
  parent: string;
  /** Required. The SearchHypernym to create. */
  searchHypernym:
    | SearchHypernym
    | undefined;
  /**
   * Optional. The search hypernym id.
   * If omitted, a random UUID will be generated.
   */
  searchHypernymId?: string | undefined;
}

/** Request message for updating SearchHypernym. */
export interface UpdateSearchHypernymRequest {
  /**
   * Required. The SearchHypernym to update.
   * The search hypernym's `name` field is used to identify the search hypernym
   * to be updated. Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/searchHypernyms/{search_hypernym}`
   */
  searchHypernym:
    | SearchHypernym
    | undefined;
  /**
   * The list of fields to be updated. If left unset, all field paths will be
   * updated/overwritten.
   */
  updateMask: string[] | undefined;
}

/** Request message for getting SearchHypernym. */
export interface GetSearchHypernymRequest {
  /**
   * Required. The name of the SearchHypernym to retrieve.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/searchHypernyms/{search_hypernym}`
   */
  name: string;
}

/** Request message for deleting SearchHypernym. */
export interface DeleteSearchHypernymRequest {
  /**
   * Required. The name of the SearchHypernym to delete.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}/searchHypernyms/{search_hypernym}`
   */
  name: string;
}

/** Request message for listing SearchHypernyms. */
export interface ListSearchHypernymsRequest {
  /**
   * Required. The parent, which owns this collection of SearchHypernyms.
   * Format:
   * `projects/{project_number}/locations/{location}/corpora/{corpus}`
   */
  parent: string;
  /**
   * The maximum number of SearchHypernyms returned. The service may
   * return fewer than this value. If unspecified, a page size of 50 will be
   * used. The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `SearchHypernym` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `SearchHypernym` must match the call that provided the page
   * token.
   */
  pageToken: string;
}

/** Response message for listing SearchHypernyms. */
export interface ListSearchHypernymsResponse {
  /** The SearchHypernyms from the specified corpus. */
  searchHypernyms: SearchHypernym[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Central configuration for custom search criteria. */
export interface SearchCriteriaProperty {
  /**
   * Each mapped_field corresponds to a UGA key. To understand how this property
   * works, take the following example. In the SearchConfig table, the
   * user adds this entry:
   *   search_config {
   *     name: "person"
   *     search_criteria_property {
   *       mapped_fields: "player"
   *       mapped_fields: "coach"
   *     }
   *   }
   *
   * Now, when a user issues a query like:
   *   criteria {
   *     field: "person"
   *     text_array {
   *       txt_values: "Tom Brady"
   *       txt_values: "Bill Belichick"
   *     }
   *   }
   *
   * MWH search will return search documents where (player=Tom Brady ||
   * coach=Tom Brady || player=Bill Belichick || coach=Bill Belichick).
   */
  mappedFields: string[];
}

/** Definition of a single value with generic type. */
export interface FacetValue {
  /** String type value. */
  stringValue?:
    | string
    | undefined;
  /** Integer type value. */
  integerValue?:
    | Long
    | undefined;
  /** Datetime type value. */
  datetimeValue?: DateTime | undefined;
}

/** Holds the facet value, selections state, and metadata. */
export interface FacetBucket {
  /** Singular value. */
  value?:
    | FacetValue
    | undefined;
  /** Range value. */
  range?:
    | FacetBucket_Range
    | undefined;
  /**
   * Whether one facet bucket is selected. This field represents user's facet
   * selection. It is set by frontend in SearchVideosRequest.
   */
  selected: boolean;
}

/** The range of values [start, end) for which faceting is applied. */
export interface FacetBucket_Range {
  /** Start of the range. Non-existence indicates some bound (e.g. -inf). */
  start:
    | FacetValue
    | undefined;
  /** End of the range. Non-existence indicates some bound (e.g. inf). */
  end: FacetValue | undefined;
}

/**
 * A group of facet buckets to be passed back and forth between backend &
 * frontend.
 */
export interface FacetGroup {
  /** Unique id of the facet group. */
  facetId: string;
  /** Display name of the facet. To be used by UI for facet rendering. */
  displayName: string;
  /**
   * Buckets associated with the facet. E.g. for "Team" facet, the bucket
   * can be 49ers, patriots, etc.
   */
  buckets: FacetBucket[];
  /** Facet bucket type. */
  bucketType: FacetBucketType;
  /**
   * If true, return query matched annotations for this facet group's selection.
   * This option is only applicable for facets based on partition level
   * annotations. It supports the following facet values:
   *  - INTEGER
   *  - STRING (DataSchema.SearchStrategy.EXACT_SEARCH only)
   */
  fetchMatchedAnnotations: boolean;
}

/** Request message for IngestAsset API. */
export interface IngestAssetRequest {
  /**
   * Provides information for the data and the asset resource name that the
   * data belongs to. The first `IngestAssetRequest` message must only contain
   * a `Config` message.
   */
  config?:
    | IngestAssetRequest_Config
    | undefined;
  /** Data to be ingested. */
  timeIndexedData?: IngestAssetRequest_TimeIndexedData | undefined;
}

/** Configuration for the data. */
export interface IngestAssetRequest_Config {
  /** Type information for video data. */
  videoType?:
    | IngestAssetRequest_Config_VideoType
    | undefined;
  /**
   * Required. The resource name of the asset that the ingested data belongs
   * to.
   */
  asset: string;
}

/** Type information for video data. */
export interface IngestAssetRequest_Config_VideoType {
  /** Container format of the video data. */
  containerFormat: IngestAssetRequest_Config_VideoType_ContainerFormat;
}

/** Container format of the video. */
export enum IngestAssetRequest_Config_VideoType_ContainerFormat {
  /** CONTAINER_FORMAT_UNSPECIFIED - The default type, not supposed to be used. */
  CONTAINER_FORMAT_UNSPECIFIED = 0,
  /** CONTAINER_FORMAT_MP4 - Mp4 container format. */
  CONTAINER_FORMAT_MP4 = 1,
  UNRECOGNIZED = -1,
}

export function ingestAssetRequest_Config_VideoType_ContainerFormatFromJSON(
  object: any,
): IngestAssetRequest_Config_VideoType_ContainerFormat {
  switch (object) {
    case 0:
    case "CONTAINER_FORMAT_UNSPECIFIED":
      return IngestAssetRequest_Config_VideoType_ContainerFormat.CONTAINER_FORMAT_UNSPECIFIED;
    case 1:
    case "CONTAINER_FORMAT_MP4":
      return IngestAssetRequest_Config_VideoType_ContainerFormat.CONTAINER_FORMAT_MP4;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IngestAssetRequest_Config_VideoType_ContainerFormat.UNRECOGNIZED;
  }
}

export function ingestAssetRequest_Config_VideoType_ContainerFormatToJSON(
  object: IngestAssetRequest_Config_VideoType_ContainerFormat,
): string {
  switch (object) {
    case IngestAssetRequest_Config_VideoType_ContainerFormat.CONTAINER_FORMAT_UNSPECIFIED:
      return "CONTAINER_FORMAT_UNSPECIFIED";
    case IngestAssetRequest_Config_VideoType_ContainerFormat.CONTAINER_FORMAT_MP4:
      return "CONTAINER_FORMAT_MP4";
    case IngestAssetRequest_Config_VideoType_ContainerFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Contains the data and the corresponding time range this data is for. */
export interface IngestAssetRequest_TimeIndexedData {
  /** Data to be ingested. */
  data: Buffer;
  /** Time range of the data. */
  temporalPartition: Partition_TemporalPartition | undefined;
}

/** Response message for IngestAsset API. */
export interface IngestAssetResponse {
  /** Time range of the data that has been successfully ingested. */
  successfullyIngestedPartition: Partition_TemporalPartition | undefined;
}

/** Request message for ClipAsset API. */
export interface ClipAssetRequest {
  /**
   * Required. The resource name of the asset to request clips for.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}`
   */
  name: string;
  /** Required. The time range to request clips for. */
  temporalPartition: Partition_TemporalPartition | undefined;
}

/** Response message for ClipAsset API. */
export interface ClipAssetResponse {
  /**
   * A list of signed uris to download the video clips that cover the requested
   * time range ordered by time.
   */
  timeIndexedUris: ClipAssetResponse_TimeIndexedUri[];
}

/** Signed uri with corresponding time range. */
export interface ClipAssetResponse_TimeIndexedUri {
  /** Time range of the video that the uri is for. */
  temporalPartition:
    | Partition_TemporalPartition
    | undefined;
  /** Signed uri to download the video clip. */
  uri: string;
}

/** Request message for GenerateHlsUri API. */
export interface GenerateHlsUriRequest {
  /**
   * Required. The resource name of the asset to request clips for.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}`
   */
  name: string;
  /**
   * The time range to request clips for. Will be ignored if `get_live_view` is
   * set to True. The total time range requested should be smaller than 24h.
   */
  temporalPartitions: Partition_TemporalPartition[];
  /**
   * Option to exclusively show a livestream of the asset with up to 3 minutes
   * of backlog data.
   */
  liveViewEnabled: boolean;
}

/** Response message for GenerateHlsUri API. */
export interface GenerateHlsUriResponse {
  /**
   * A signed uri to download the HLS manifest corresponding to the requested
   * times.
   */
  uri: string;
  /**
   * A list of temporal partitions of the content returned in the order they
   * appear in the stream.
   */
  temporalPartitions: Partition_TemporalPartition[];
}

/** Request message for SearchAssets. */
export interface SearchAssetsRequest {
  /** Sort by the value under the data schema key. */
  schemaKeySortingStrategy?:
    | SchemaKeySortingStrategy
    | undefined;
  /**
   * Required. The parent corpus to search.
   * Format: `projects/{project_id}/locations/{location_id}/corpora/{corpus_id}'
   */
  corpus: string;
  /**
   * The number of results to be returned in this page. If it's 0, the server
   * will decide the appropriate page_size.
   */
  pageSize: number;
  /**
   * The continuation token to fetch the next page. If empty, it means it is
   * fetching the first page.
   */
  pageToken: string;
  /**
   * Time ranges that matching video content must fall within. If no ranges are
   * provided, there will be no time restriction. This field is treated just
   * like the criteria below, but defined separately for convenience as it is
   * used frequently. Note that if the end_time is in the future, it will be
   * clamped to the time the request was received.
   */
  contentTimeRanges:
    | DateTimeRangeArray
    | undefined;
  /** Criteria applied to search results. */
  criteria: Criteria[];
  /**
   * Stores most recent facet selection state. Only facet groups with user's
   * selection will be presented here. Selection state is either selected or
   * unselected. Only selected facet buckets will be used as search criteria.
   */
  facetSelections: FacetGroup[];
  /**
   * A list of annotation keys to specify the annotations to be retrieved and
   * returned with each search result.
   * Annotation granularity must be GRANULARITY_ASSET_LEVEL and its search
   * strategy must not be NO_SEARCH.
   */
  resultAnnotationKeys: string[];
  /**
   * Global search query. Allows user to search assets without needing to
   * specify which field the value belongs to.
   */
  searchQuery: string;
}

/** Request message for SearchIndexEndpoint. */
export interface SearchIndexEndpointRequest {
  /** An image-only query. */
  imageQuery?:
    | ImageQuery
    | undefined;
  /** A text-only query. */
  textQuery?:
    | string
    | undefined;
  /**
   * Required. The index endpoint to search.
   * Format:
   * `projects/{project_id}/locations/{location_id}/indexEndpoints/{index_endpoint_id}'
   */
  indexEndpoint: string;
  /** Criteria applied to search results. */
  criteria: Criteria[];
  /**
   * Criteria to exclude from search results.
   * Note that `fetch_matched_annotations` will be ignored.
   */
  exclusionCriteria: Criteria[];
  /**
   * Requested page size. API may return fewer results than requested.
   * If negative, INVALID_ARGUMENT error will be returned.
   * If unspecified or 0, API will pick a default size, which is 10.
   * If the requested page size is larger than the maximum size, API will pick
   * the maximum size, which is 100.
   */
  pageSize: number;
  /**
   * The continuation token to fetch the next page. If empty, it means it is
   * fetching the first page.
   */
  pageToken: string;
}

/** Image query for search endpoint request. */
export interface ImageQuery {
  /** Input image in raw bytes. */
  inputImage?:
    | Buffer
    | undefined;
  /**
   * Resource name of the asset. Only supported in IMAGE corpus type.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}`
   */
  asset?: string | undefined;
}

/** A strategy to specify how to sort by data schema key. */
export interface SchemaKeySortingStrategy {
  /** Options in the front have high priority than those in the back. */
  options: SchemaKeySortingStrategy_Option[];
}

/** Option for one data schema key. */
export interface SchemaKeySortingStrategy_Option {
  /** The data used to sort. */
  dataSchemaKey: string;
  /**
   * Whether to sort in decreasing order or increasing order.
   * By default, results are sorted in incresing order.
   */
  sortDecreasing: boolean;
  /** Aggregate method for the current data schema key. */
  aggregateMethod?: SchemaKeySortingStrategy_Option_AggregateMethod | undefined;
}

/**
 * When one result has multiple values with the same key, specify
 * which value is used to sort. By default, AGGREGATE_METHOD_LARGEST
 * is used when results are sorted in decreasing order,
 * AGGREGATE_METHOD_SMALLEST is used when results are sorted in
 * incresing order.
 */
export enum SchemaKeySortingStrategy_Option_AggregateMethod {
  /**
   * AGGREGATE_METHOD_UNSPECIFIED - The unspecified aggregate method will be overwritten as mentioned
   * above.
   */
  AGGREGATE_METHOD_UNSPECIFIED = 0,
  /** AGGREGATE_METHOD_LARGEST - Take the (lexicographical or numerical) largest value to sort. */
  AGGREGATE_METHOD_LARGEST = 1,
  /** AGGREGATE_METHOD_SMALLEST - Take the (lexicographical or numerical) smallest value to sort. */
  AGGREGATE_METHOD_SMALLEST = 2,
  UNRECOGNIZED = -1,
}

export function schemaKeySortingStrategy_Option_AggregateMethodFromJSON(
  object: any,
): SchemaKeySortingStrategy_Option_AggregateMethod {
  switch (object) {
    case 0:
    case "AGGREGATE_METHOD_UNSPECIFIED":
      return SchemaKeySortingStrategy_Option_AggregateMethod.AGGREGATE_METHOD_UNSPECIFIED;
    case 1:
    case "AGGREGATE_METHOD_LARGEST":
      return SchemaKeySortingStrategy_Option_AggregateMethod.AGGREGATE_METHOD_LARGEST;
    case 2:
    case "AGGREGATE_METHOD_SMALLEST":
      return SchemaKeySortingStrategy_Option_AggregateMethod.AGGREGATE_METHOD_SMALLEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SchemaKeySortingStrategy_Option_AggregateMethod.UNRECOGNIZED;
  }
}

export function schemaKeySortingStrategy_Option_AggregateMethodToJSON(
  object: SchemaKeySortingStrategy_Option_AggregateMethod,
): string {
  switch (object) {
    case SchemaKeySortingStrategy_Option_AggregateMethod.AGGREGATE_METHOD_UNSPECIFIED:
      return "AGGREGATE_METHOD_UNSPECIFIED";
    case SchemaKeySortingStrategy_Option_AggregateMethod.AGGREGATE_METHOD_LARGEST:
      return "AGGREGATE_METHOD_LARGEST";
    case SchemaKeySortingStrategy_Option_AggregateMethod.AGGREGATE_METHOD_SMALLEST:
      return "AGGREGATE_METHOD_SMALLEST";
    case SchemaKeySortingStrategy_Option_AggregateMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The metadata for DeleteAsset API that embeds in
 * [metadata][google.longrunning.Operation.metadata] field.
 */
export interface DeleteAssetMetadata {
}

/** Stores the criteria-annotation matching results for each search result item. */
export interface AnnotationMatchingResult {
  /**
   * The criteria used for matching. It can be an input search criteria or a
   * criteria converted from a facet selection.
   */
  criteria:
    | Criteria
    | undefined;
  /** Matched annotations for the criteria. */
  matchedAnnotations: Annotation[];
  /**
   * Status of the match result. Possible values:
   * FAILED_PRECONDITION - the criteria is not eligible for match.
   * OK - matching is performed.
   */
  status: Status | undefined;
}

/** Search result contains asset name and corresponding time ranges. */
export interface SearchResultItem {
  /**
   * The resource name of the asset.
   * Format:
   * `projects/{project_number}/locations/{location_id}/corpora/{corpus_id}/assets/{asset_id}`
   */
  asset: string;
  /**
   * The matched asset segments.
   * Deprecated: please use singular `segment` field.
   *
   * @deprecated
   */
  segments: Partition_TemporalPartition[];
  /** The matched asset segment. */
  segment:
    | Partition_TemporalPartition
    | undefined;
  /**
   * Available to IMAGE corpus types.
   * Relevance of this `SearchResultItem` to user search query (text query or
   * image query).
   * By default this represents cosine similarity between the query and the
   * retrieved media content. The value is in the range of [-1, 1].
   * Note that search ranking is not only decided by this relevance score,
   * but also other factors such as the match of annotations.
   */
  relevance: number;
  /**
   * Search result annotations specified by result_annotation_keys in search
   * request.
   */
  requestedAnnotations: Annotation[];
  /**
   * Criteria or facet-selection based annotation matching results associated to
   * this search result item. Only contains results for criteria or
   * facet_selections with fetch_matched_annotations=true.
   */
  annotationMatchingResults: AnnotationMatchingResult[];
}

/** Response message for SearchAssets. */
export interface SearchAssetsResponse {
  /** Returned search results. */
  searchResultItems: SearchResultItem[];
  /** The next-page continuation token. */
  nextPageToken: string;
  /**
   * Facet search results of a given query, which contains user's
   * already-selected facet values and updated facet search results.
   */
  facetResults: FacetGroup[];
}

/** Response message for SearchIndexEndpoint. */
export interface SearchIndexEndpointResponse {
  /** Returned search results. */
  searchResultItems: SearchResultItem[];
  /**
   * The next-page continuation token.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Integer range type. */
export interface IntRange {
  /** Start of the int range. */
  start?:
    | Long
    | undefined;
  /** End of the int range. */
  end?: Long | undefined;
}

/** Float range type. */
export interface FloatRange {
  /** Start of the float range. */
  start?:
    | number
    | undefined;
  /** End of the float range. */
  end?: number | undefined;
}

/** A list of string-type values. */
export interface StringArray {
  /** String type values. */
  txtValues: string[];
}

/** A list of integer range values. */
export interface IntRangeArray {
  /** Int range values. */
  intRanges: IntRange[];
}

/** A list of float range values. */
export interface FloatRangeArray {
  /** Float range values. */
  floatRanges: FloatRange[];
}

/** Datetime range type. */
export interface DateTimeRange {
  /** Start date time. */
  start:
    | DateTime
    | undefined;
  /** End data time. */
  end: DateTime | undefined;
}

/** A list of datetime range values. */
export interface DateTimeRangeArray {
  /** Date time ranges. */
  dateTimeRanges: DateTimeRange[];
}

/** Representation of a circle area. */
export interface CircleArea {
  /** Latitude of circle area's center. Degrees [-90 .. 90] */
  latitude: number;
  /** Longitude of circle area's center. Degrees [-180 .. 180] */
  longitude: number;
  /** Radius of the circle area in meters. */
  radiusMeter: number;
}

/** A list of locations. */
export interface GeoLocationArray {
  /** A list of circle areas. */
  circleAreas: CircleArea[];
}

export interface BoolValue {
  value: boolean;
}

/** Filter criteria applied to current search results. */
export interface Criteria {
  /** The text values associated with the field. */
  textArray?:
    | StringArray
    | undefined;
  /** The integer ranges associated with the field. */
  intRangeArray?:
    | IntRangeArray
    | undefined;
  /** The float ranges associated with the field. */
  floatRangeArray?:
    | FloatRangeArray
    | undefined;
  /** The datetime ranges associated with the field. */
  dateTimeRangeArray?:
    | DateTimeRangeArray
    | undefined;
  /** Geo Location array. */
  geoLocationArray?:
    | GeoLocationArray
    | undefined;
  /** A Boolean value. */
  boolValue?:
    | BoolValue
    | undefined;
  /** The UGA field or ML field to apply filtering criteria. */
  field: string;
  /**
   * If true, return query matched annotations for this criteria.
   * This option is only applicable for inclusion criteria, i.e., not exclusion
   * criteria, with partition level annotations.  It supports the following data
   * types:
   *  - INTEGER
   *  - FLOAT
   *  - STRING (DataSchema.SearchStrategy.EXACT_SEARCH only)
   *  - BOOLEAN
   */
  fetchMatchedAnnotations: boolean;
}

/**
 * Partition to specify the partition in time and space for sub-asset level
 * annotation.
 */
export interface Partition {
  /** Partition of asset in time. */
  temporalPartition:
    | Partition_TemporalPartition
    | undefined;
  /** Partition of asset in space. */
  spatialPartition:
    | Partition_SpatialPartition
    | undefined;
  /** Partition of asset in time. */
  relativeTemporalPartition: Partition_RelativeTemporalPartition | undefined;
}

/**
 * Partition of asset in UTC Epoch time. Supported by STREAM_VIDEO corpus
 * type.
 */
export interface Partition_TemporalPartition {
  /** Start time of the partition. */
  startTime:
    | Date
    | undefined;
  /** End time of the partition. */
  endTime: Date | undefined;
}

/** Partition of asset in space. */
export interface Partition_SpatialPartition {
  /** The minimum x coordinate value. */
  xMin?:
    | Long
    | undefined;
  /** The minimum y coordinate value. */
  yMin?:
    | Long
    | undefined;
  /** The maximum x coordinate value. */
  xMax?:
    | Long
    | undefined;
  /** The maximum y coordinate value. */
  yMax?: Long | undefined;
}

/**
 * Partition of asset in relative time. Supported by VIDEO_ON_DEMAND corpus
 * type.
 */
export interface Partition_RelativeTemporalPartition {
  /** Start time offset of the partition. */
  startOffset:
    | Duration
    | undefined;
  /** End time offset of the partition. */
  endOffset: Duration | undefined;
}

function createBaseCreateAssetRequest(): CreateAssetRequest {
  return { parent: "", asset: undefined, assetId: undefined };
}

export const CreateAssetRequest: MessageFns<CreateAssetRequest> = {
  encode(message: CreateAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(18).fork()).join();
    }
    if (message.assetId !== undefined) {
      writer.uint32(26).string(message.assetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.assetId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAssetRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : undefined,
    };
  },

  toJSON(message: CreateAssetRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.assetId !== undefined) {
      obj.assetId = message.assetId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAssetRequest>): CreateAssetRequest {
    return CreateAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAssetRequest>): CreateAssetRequest {
    const message = createBaseCreateAssetRequest();
    message.parent = object.parent ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.assetId = object.assetId ?? undefined;
    return message;
  },
};

function createBaseGetAssetRequest(): GetAssetRequest {
  return { name: "" };
}

export const GetAssetRequest: MessageFns<GetAssetRequest> = {
  encode(message: GetAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetRequest>): GetAssetRequest {
    return GetAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetRequest>): GetAssetRequest {
    const message = createBaseGetAssetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListAssetsRequest(): ListAssetsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListAssetsRequest: MessageFns<ListAssetsRequest> = {
  encode(message: ListAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListAssetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAssetsRequest>): ListAssetsRequest {
    return ListAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAssetsRequest>): ListAssetsRequest {
    const message = createBaseListAssetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListAssetsResponse(): ListAssetsResponse {
  return { assets: [], nextPageToken: "" };
}

export const ListAssetsResponse: MessageFns<ListAssetsResponse> = {
  encode(message: ListAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assets) {
      Asset.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assets.push(Asset.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsResponse {
    return {
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => Asset.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAssetsResponse): unknown {
    const obj: any = {};
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => Asset.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAssetsResponse>): ListAssetsResponse {
    return ListAssetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAssetsResponse>): ListAssetsResponse {
    const message = createBaseListAssetsResponse();
    message.assets = object.assets?.map((e) => Asset.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateAssetRequest(): UpdateAssetRequest {
  return { asset: undefined, updateMask: undefined };
}

export const UpdateAssetRequest: MessageFns<UpdateAssetRequest> = {
  encode(message: UpdateAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAssetRequest {
    return {
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateAssetRequest): unknown {
    const obj: any = {};
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAssetRequest>): UpdateAssetRequest {
    return UpdateAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAssetRequest>): UpdateAssetRequest {
    const message = createBaseUpdateAssetRequest();
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteAssetRequest(): DeleteAssetRequest {
  return { name: "" };
}

export const DeleteAssetRequest: MessageFns<DeleteAssetRequest> = {
  encode(message: DeleteAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAssetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAssetRequest>): DeleteAssetRequest {
    return DeleteAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAssetRequest>): DeleteAssetRequest {
    const message = createBaseDeleteAssetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAssetSource(): AssetSource {
  return { assetGcsSource: undefined, assetContentData: undefined };
}

export const AssetSource: MessageFns<AssetSource> = {
  encode(message: AssetSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetGcsSource !== undefined) {
      AssetSource_AssetGcsSource.encode(message.assetGcsSource, writer.uint32(10).fork()).join();
    }
    if (message.assetContentData !== undefined) {
      AssetSource_AssetContentData.encode(message.assetContentData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetGcsSource = AssetSource_AssetGcsSource.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assetContentData = AssetSource_AssetContentData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetSource {
    return {
      assetGcsSource: isSet(object.assetGcsSource)
        ? AssetSource_AssetGcsSource.fromJSON(object.assetGcsSource)
        : undefined,
      assetContentData: isSet(object.assetContentData)
        ? AssetSource_AssetContentData.fromJSON(object.assetContentData)
        : undefined,
    };
  },

  toJSON(message: AssetSource): unknown {
    const obj: any = {};
    if (message.assetGcsSource !== undefined) {
      obj.assetGcsSource = AssetSource_AssetGcsSource.toJSON(message.assetGcsSource);
    }
    if (message.assetContentData !== undefined) {
      obj.assetContentData = AssetSource_AssetContentData.toJSON(message.assetContentData);
    }
    return obj;
  },

  create(base?: DeepPartial<AssetSource>): AssetSource {
    return AssetSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetSource>): AssetSource {
    const message = createBaseAssetSource();
    message.assetGcsSource = (object.assetGcsSource !== undefined && object.assetGcsSource !== null)
      ? AssetSource_AssetGcsSource.fromPartial(object.assetGcsSource)
      : undefined;
    message.assetContentData = (object.assetContentData !== undefined && object.assetContentData !== null)
      ? AssetSource_AssetContentData.fromPartial(object.assetContentData)
      : undefined;
    return message;
  },
};

function createBaseAssetSource_AssetGcsSource(): AssetSource_AssetGcsSource {
  return { gcsUri: "" };
}

export const AssetSource_AssetGcsSource: MessageFns<AssetSource_AssetGcsSource> = {
  encode(message: AssetSource_AssetGcsSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsUri !== "") {
      writer.uint32(10).string(message.gcsUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetSource_AssetGcsSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetSource_AssetGcsSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetSource_AssetGcsSource {
    return { gcsUri: isSet(object.gcsUri) ? globalThis.String(object.gcsUri) : "" };
  },

  toJSON(message: AssetSource_AssetGcsSource): unknown {
    const obj: any = {};
    if (message.gcsUri !== "") {
      obj.gcsUri = message.gcsUri;
    }
    return obj;
  },

  create(base?: DeepPartial<AssetSource_AssetGcsSource>): AssetSource_AssetGcsSource {
    return AssetSource_AssetGcsSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetSource_AssetGcsSource>): AssetSource_AssetGcsSource {
    const message = createBaseAssetSource_AssetGcsSource();
    message.gcsUri = object.gcsUri ?? "";
    return message;
  },
};

function createBaseAssetSource_AssetContentData(): AssetSource_AssetContentData {
  return { assetContentData: Buffer.alloc(0) };
}

export const AssetSource_AssetContentData: MessageFns<AssetSource_AssetContentData> = {
  encode(message: AssetSource_AssetContentData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetContentData.length !== 0) {
      writer.uint32(10).bytes(message.assetContentData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetSource_AssetContentData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetSource_AssetContentData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetContentData = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetSource_AssetContentData {
    return {
      assetContentData: isSet(object.assetContentData)
        ? Buffer.from(bytesFromBase64(object.assetContentData))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: AssetSource_AssetContentData): unknown {
    const obj: any = {};
    if (message.assetContentData.length !== 0) {
      obj.assetContentData = base64FromBytes(message.assetContentData);
    }
    return obj;
  },

  create(base?: DeepPartial<AssetSource_AssetContentData>): AssetSource_AssetContentData {
    return AssetSource_AssetContentData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetSource_AssetContentData>): AssetSource_AssetContentData {
    const message = createBaseAssetSource_AssetContentData();
    message.assetContentData = object.assetContentData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseUploadAssetRequest(): UploadAssetRequest {
  return { name: "", assetSource: undefined };
}

export const UploadAssetRequest: MessageFns<UploadAssetRequest> = {
  encode(message: UploadAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.assetSource !== undefined) {
      AssetSource.encode(message.assetSource, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assetSource = AssetSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadAssetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      assetSource: isSet(object.assetSource) ? AssetSource.fromJSON(object.assetSource) : undefined,
    };
  },

  toJSON(message: UploadAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.assetSource !== undefined) {
      obj.assetSource = AssetSource.toJSON(message.assetSource);
    }
    return obj;
  },

  create(base?: DeepPartial<UploadAssetRequest>): UploadAssetRequest {
    return UploadAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadAssetRequest>): UploadAssetRequest {
    const message = createBaseUploadAssetRequest();
    message.name = object.name ?? "";
    message.assetSource = (object.assetSource !== undefined && object.assetSource !== null)
      ? AssetSource.fromPartial(object.assetSource)
      : undefined;
    return message;
  },
};

function createBaseUploadAssetResponse(): UploadAssetResponse {
  return {};
}

export const UploadAssetResponse: MessageFns<UploadAssetResponse> = {
  encode(_: UploadAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UploadAssetResponse {
    return {};
  },

  toJSON(_: UploadAssetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UploadAssetResponse>): UploadAssetResponse {
    return UploadAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UploadAssetResponse>): UploadAssetResponse {
    const message = createBaseUploadAssetResponse();
    return message;
  },
};

function createBaseUploadAssetMetadata(): UploadAssetMetadata {
  return { startTime: undefined, updateTime: undefined };
}

export const UploadAssetMetadata: MessageFns<UploadAssetMetadata> = {
  encode(message: UploadAssetMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadAssetMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadAssetMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadAssetMetadata {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: UploadAssetMetadata): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<UploadAssetMetadata>): UploadAssetMetadata {
    return UploadAssetMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadAssetMetadata>): UploadAssetMetadata {
    const message = createBaseUploadAssetMetadata();
    message.startTime = object.startTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseGenerateRetrievalUrlRequest(): GenerateRetrievalUrlRequest {
  return { name: "" };
}

export const GenerateRetrievalUrlRequest: MessageFns<GenerateRetrievalUrlRequest> = {
  encode(message: GenerateRetrievalUrlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateRetrievalUrlRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateRetrievalUrlRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateRetrievalUrlRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GenerateRetrievalUrlRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateRetrievalUrlRequest>): GenerateRetrievalUrlRequest {
    return GenerateRetrievalUrlRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateRetrievalUrlRequest>): GenerateRetrievalUrlRequest {
    const message = createBaseGenerateRetrievalUrlRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGenerateRetrievalUrlResponse(): GenerateRetrievalUrlResponse {
  return { signedUri: "" };
}

export const GenerateRetrievalUrlResponse: MessageFns<GenerateRetrievalUrlResponse> = {
  encode(message: GenerateRetrievalUrlResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signedUri !== "") {
      writer.uint32(10).string(message.signedUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateRetrievalUrlResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateRetrievalUrlResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signedUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateRetrievalUrlResponse {
    return { signedUri: isSet(object.signedUri) ? globalThis.String(object.signedUri) : "" };
  },

  toJSON(message: GenerateRetrievalUrlResponse): unknown {
    const obj: any = {};
    if (message.signedUri !== "") {
      obj.signedUri = message.signedUri;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateRetrievalUrlResponse>): GenerateRetrievalUrlResponse {
    return GenerateRetrievalUrlResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateRetrievalUrlResponse>): GenerateRetrievalUrlResponse {
    const message = createBaseGenerateRetrievalUrlResponse();
    message.signedUri = object.signedUri ?? "";
    return message;
  },
};

function createBaseAsset(): Asset {
  return { name: "", ttl: undefined, assetGcsSource: undefined };
}

export const Asset: MessageFns<Asset> = {
  encode(message: Asset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(18).fork()).join();
    }
    if (message.assetGcsSource !== undefined) {
      AssetSource_AssetGcsSource.encode(message.assetGcsSource, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.assetGcsSource = AssetSource_AssetGcsSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
      assetGcsSource: isSet(object.assetGcsSource)
        ? AssetSource_AssetGcsSource.fromJSON(object.assetGcsSource)
        : undefined,
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    if (message.assetGcsSource !== undefined) {
      obj.assetGcsSource = AssetSource_AssetGcsSource.toJSON(message.assetGcsSource);
    }
    return obj;
  },

  create(base?: DeepPartial<Asset>): Asset {
    return Asset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset>): Asset {
    const message = createBaseAsset();
    message.name = object.name ?? "";
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    message.assetGcsSource = (object.assetGcsSource !== undefined && object.assetGcsSource !== null)
      ? AssetSource_AssetGcsSource.fromPartial(object.assetGcsSource)
      : undefined;
    return message;
  },
};

function createBaseAnalyzeAssetRequest(): AnalyzeAssetRequest {
  return { name: "" };
}

export const AnalyzeAssetRequest: MessageFns<AnalyzeAssetRequest> = {
  encode(message: AnalyzeAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeAssetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: AnalyzeAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzeAssetRequest>): AnalyzeAssetRequest {
    return AnalyzeAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzeAssetRequest>): AnalyzeAssetRequest {
    const message = createBaseAnalyzeAssetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAnalyzeAssetMetadata(): AnalyzeAssetMetadata {
  return { analysisStatus: [], startTime: undefined, updateTime: undefined };
}

export const AnalyzeAssetMetadata: MessageFns<AnalyzeAssetMetadata> = {
  encode(message: AnalyzeAssetMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.analysisStatus) {
      AnalyzeAssetMetadata_AnalysisStatus.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeAssetMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeAssetMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.analysisStatus.push(AnalyzeAssetMetadata_AnalysisStatus.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeAssetMetadata {
    return {
      analysisStatus: globalThis.Array.isArray(object?.analysisStatus)
        ? object.analysisStatus.map((e: any) => AnalyzeAssetMetadata_AnalysisStatus.fromJSON(e))
        : [],
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: AnalyzeAssetMetadata): unknown {
    const obj: any = {};
    if (message.analysisStatus?.length) {
      obj.analysisStatus = message.analysisStatus.map((e) => AnalyzeAssetMetadata_AnalysisStatus.toJSON(e));
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzeAssetMetadata>): AnalyzeAssetMetadata {
    return AnalyzeAssetMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzeAssetMetadata>): AnalyzeAssetMetadata {
    const message = createBaseAnalyzeAssetMetadata();
    message.analysisStatus = object.analysisStatus?.map((e) => AnalyzeAssetMetadata_AnalysisStatus.fromPartial(e)) ||
      [];
    message.startTime = object.startTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseAnalyzeAssetMetadata_AnalysisStatus(): AnalyzeAssetMetadata_AnalysisStatus {
  return { state: 0, statusMessage: "", searchCapability: undefined };
}

export const AnalyzeAssetMetadata_AnalysisStatus: MessageFns<AnalyzeAssetMetadata_AnalysisStatus> = {
  encode(message: AnalyzeAssetMetadata_AnalysisStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.statusMessage !== "") {
      writer.uint32(26).string(message.statusMessage);
    }
    if (message.searchCapability !== undefined) {
      SearchCapability.encode(message.searchCapability, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeAssetMetadata_AnalysisStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeAssetMetadata_AnalysisStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.searchCapability = SearchCapability.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeAssetMetadata_AnalysisStatus {
    return {
      state: isSet(object.state) ? analyzeAssetMetadata_AnalysisStatus_StateFromJSON(object.state) : 0,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      searchCapability: isSet(object.searchCapability) ? SearchCapability.fromJSON(object.searchCapability) : undefined,
    };
  },

  toJSON(message: AnalyzeAssetMetadata_AnalysisStatus): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = analyzeAssetMetadata_AnalysisStatus_StateToJSON(message.state);
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.searchCapability !== undefined) {
      obj.searchCapability = SearchCapability.toJSON(message.searchCapability);
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzeAssetMetadata_AnalysisStatus>): AnalyzeAssetMetadata_AnalysisStatus {
    return AnalyzeAssetMetadata_AnalysisStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzeAssetMetadata_AnalysisStatus>): AnalyzeAssetMetadata_AnalysisStatus {
    const message = createBaseAnalyzeAssetMetadata_AnalysisStatus();
    message.state = object.state ?? 0;
    message.statusMessage = object.statusMessage ?? "";
    message.searchCapability = (object.searchCapability !== undefined && object.searchCapability !== null)
      ? SearchCapability.fromPartial(object.searchCapability)
      : undefined;
    return message;
  },
};

function createBaseAnalyzeAssetResponse(): AnalyzeAssetResponse {
  return {};
}

export const AnalyzeAssetResponse: MessageFns<AnalyzeAssetResponse> = {
  encode(_: AnalyzeAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AnalyzeAssetResponse {
    return {};
  },

  toJSON(_: AnalyzeAssetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AnalyzeAssetResponse>): AnalyzeAssetResponse {
    return AnalyzeAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AnalyzeAssetResponse>): AnalyzeAssetResponse {
    const message = createBaseAnalyzeAssetResponse();
    return message;
  },
};

function createBaseIndexingStatus(): IndexingStatus {
  return { state: 0, statusMessage: "" };
}

export const IndexingStatus: MessageFns<IndexingStatus> = {
  encode(message: IndexingStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.statusMessage !== "") {
      writer.uint32(26).string(message.statusMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexingStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexingStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexingStatus {
    return {
      state: isSet(object.state) ? indexingStatus_StateFromJSON(object.state) : 0,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
    };
  },

  toJSON(message: IndexingStatus): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = indexingStatus_StateToJSON(message.state);
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<IndexingStatus>): IndexingStatus {
    return IndexingStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexingStatus>): IndexingStatus {
    const message = createBaseIndexingStatus();
    message.state = object.state ?? 0;
    message.statusMessage = object.statusMessage ?? "";
    return message;
  },
};

function createBaseIndexAssetRequest(): IndexAssetRequest {
  return { name: "", index: "" };
}

export const IndexAssetRequest: MessageFns<IndexAssetRequest> = {
  encode(message: IndexAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.index !== "") {
      writer.uint32(18).string(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.index = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexAssetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      index: isSet(object.index) ? globalThis.String(object.index) : "",
    };
  },

  toJSON(message: IndexAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.index !== "") {
      obj.index = message.index;
    }
    return obj;
  },

  create(base?: DeepPartial<IndexAssetRequest>): IndexAssetRequest {
    return IndexAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexAssetRequest>): IndexAssetRequest {
    const message = createBaseIndexAssetRequest();
    message.name = object.name ?? "";
    message.index = object.index ?? "";
    return message;
  },
};

function createBaseIndexAssetMetadata(): IndexAssetMetadata {
  return { status: undefined, startTime: undefined, updateTime: undefined };
}

export const IndexAssetMetadata: MessageFns<IndexAssetMetadata> = {
  encode(message: IndexAssetMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      IndexingStatus.encode(message.status, writer.uint32(34).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexAssetMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexAssetMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.status = IndexingStatus.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexAssetMetadata {
    return {
      status: isSet(object.status) ? IndexingStatus.fromJSON(object.status) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: IndexAssetMetadata): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = IndexingStatus.toJSON(message.status);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<IndexAssetMetadata>): IndexAssetMetadata {
    return IndexAssetMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexAssetMetadata>): IndexAssetMetadata {
    const message = createBaseIndexAssetMetadata();
    message.status = (object.status !== undefined && object.status !== null)
      ? IndexingStatus.fromPartial(object.status)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseIndexAssetResponse(): IndexAssetResponse {
  return {};
}

export const IndexAssetResponse: MessageFns<IndexAssetResponse> = {
  encode(_: IndexAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IndexAssetResponse {
    return {};
  },

  toJSON(_: IndexAssetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<IndexAssetResponse>): IndexAssetResponse {
    return IndexAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<IndexAssetResponse>): IndexAssetResponse {
    const message = createBaseIndexAssetResponse();
    return message;
  },
};

function createBaseRemoveIndexAssetRequest(): RemoveIndexAssetRequest {
  return { name: "", index: "" };
}

export const RemoveIndexAssetRequest: MessageFns<RemoveIndexAssetRequest> = {
  encode(message: RemoveIndexAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.index !== "") {
      writer.uint32(18).string(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveIndexAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveIndexAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.index = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveIndexAssetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      index: isSet(object.index) ? globalThis.String(object.index) : "",
    };
  },

  toJSON(message: RemoveIndexAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.index !== "") {
      obj.index = message.index;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveIndexAssetRequest>): RemoveIndexAssetRequest {
    return RemoveIndexAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveIndexAssetRequest>): RemoveIndexAssetRequest {
    const message = createBaseRemoveIndexAssetRequest();
    message.name = object.name ?? "";
    message.index = object.index ?? "";
    return message;
  },
};

function createBaseRemoveIndexAssetMetadata(): RemoveIndexAssetMetadata {
  return { indexingStatus: undefined, startTime: undefined, updateTime: undefined };
}

export const RemoveIndexAssetMetadata: MessageFns<RemoveIndexAssetMetadata> = {
  encode(message: RemoveIndexAssetMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexingStatus !== undefined) {
      IndexingStatus.encode(message.indexingStatus, writer.uint32(10).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveIndexAssetMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveIndexAssetMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.indexingStatus = IndexingStatus.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveIndexAssetMetadata {
    return {
      indexingStatus: isSet(object.indexingStatus) ? IndexingStatus.fromJSON(object.indexingStatus) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: RemoveIndexAssetMetadata): unknown {
    const obj: any = {};
    if (message.indexingStatus !== undefined) {
      obj.indexingStatus = IndexingStatus.toJSON(message.indexingStatus);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveIndexAssetMetadata>): RemoveIndexAssetMetadata {
    return RemoveIndexAssetMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveIndexAssetMetadata>): RemoveIndexAssetMetadata {
    const message = createBaseRemoveIndexAssetMetadata();
    message.indexingStatus = (object.indexingStatus !== undefined && object.indexingStatus !== null)
      ? IndexingStatus.fromPartial(object.indexingStatus)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseRemoveIndexAssetResponse(): RemoveIndexAssetResponse {
  return {};
}

export const RemoveIndexAssetResponse: MessageFns<RemoveIndexAssetResponse> = {
  encode(_: RemoveIndexAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveIndexAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveIndexAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveIndexAssetResponse {
    return {};
  },

  toJSON(_: RemoveIndexAssetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RemoveIndexAssetResponse>): RemoveIndexAssetResponse {
    return RemoveIndexAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RemoveIndexAssetResponse>): RemoveIndexAssetResponse {
    const message = createBaseRemoveIndexAssetResponse();
    return message;
  },
};

function createBaseIndexedAsset(): IndexedAsset {
  return { index: "", asset: "", createTime: undefined, updateTime: undefined };
}

export const IndexedAsset: MessageFns<IndexedAsset> = {
  encode(message: IndexedAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== "") {
      writer.uint32(10).string(message.index);
    }
    if (message.asset !== "") {
      writer.uint32(18).string(message.asset);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexedAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexedAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.index = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexedAsset {
    return {
      index: isSet(object.index) ? globalThis.String(object.index) : "",
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: IndexedAsset): unknown {
    const obj: any = {};
    if (message.index !== "") {
      obj.index = message.index;
    }
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<IndexedAsset>): IndexedAsset {
    return IndexedAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexedAsset>): IndexedAsset {
    const message = createBaseIndexedAsset();
    message.index = object.index ?? "";
    message.asset = object.asset ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseViewIndexedAssetsRequest(): ViewIndexedAssetsRequest {
  return { index: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ViewIndexedAssetsRequest: MessageFns<ViewIndexedAssetsRequest> = {
  encode(message: ViewIndexedAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== "") {
      writer.uint32(10).string(message.index);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewIndexedAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewIndexedAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.index = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewIndexedAssetsRequest {
    return {
      index: isSet(object.index) ? globalThis.String(object.index) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ViewIndexedAssetsRequest): unknown {
    const obj: any = {};
    if (message.index !== "") {
      obj.index = message.index;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ViewIndexedAssetsRequest>): ViewIndexedAssetsRequest {
    return ViewIndexedAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ViewIndexedAssetsRequest>): ViewIndexedAssetsRequest {
    const message = createBaseViewIndexedAssetsRequest();
    message.index = object.index ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseViewIndexedAssetsResponse(): ViewIndexedAssetsResponse {
  return { indexedAssets: [], nextPageToken: "" };
}

export const ViewIndexedAssetsResponse: MessageFns<ViewIndexedAssetsResponse> = {
  encode(message: ViewIndexedAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.indexedAssets) {
      IndexedAsset.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewIndexedAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewIndexedAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.indexedAssets.push(IndexedAsset.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewIndexedAssetsResponse {
    return {
      indexedAssets: globalThis.Array.isArray(object?.indexedAssets)
        ? object.indexedAssets.map((e: any) => IndexedAsset.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ViewIndexedAssetsResponse): unknown {
    const obj: any = {};
    if (message.indexedAssets?.length) {
      obj.indexedAssets = message.indexedAssets.map((e) => IndexedAsset.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ViewIndexedAssetsResponse>): ViewIndexedAssetsResponse {
    return ViewIndexedAssetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ViewIndexedAssetsResponse>): ViewIndexedAssetsResponse {
    const message = createBaseViewIndexedAssetsResponse();
    message.indexedAssets = object.indexedAssets?.map((e) => IndexedAsset.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateCorpusRequest(): CreateCorpusRequest {
  return { parent: "", corpus: undefined };
}

export const CreateCorpusRequest: MessageFns<CreateCorpusRequest> = {
  encode(message: CreateCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.corpus !== undefined) {
      Corpus.encode(message.corpus, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.corpus = Corpus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCorpusRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      corpus: isSet(object.corpus) ? Corpus.fromJSON(object.corpus) : undefined,
    };
  },

  toJSON(message: CreateCorpusRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.corpus !== undefined) {
      obj.corpus = Corpus.toJSON(message.corpus);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCorpusRequest>): CreateCorpusRequest {
    return CreateCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCorpusRequest>): CreateCorpusRequest {
    const message = createBaseCreateCorpusRequest();
    message.parent = object.parent ?? "";
    message.corpus = (object.corpus !== undefined && object.corpus !== null)
      ? Corpus.fromPartial(object.corpus)
      : undefined;
    return message;
  },
};

function createBaseCreateCorpusMetadata(): CreateCorpusMetadata {
  return { createTime: undefined, updateTime: undefined };
}

export const CreateCorpusMetadata: MessageFns<CreateCorpusMetadata> = {
  encode(message: CreateCorpusMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCorpusMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCorpusMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCorpusMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: CreateCorpusMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCorpusMetadata>): CreateCorpusMetadata {
    return CreateCorpusMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCorpusMetadata>): CreateCorpusMetadata {
    const message = createBaseCreateCorpusMetadata();
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseSearchCapability(): SearchCapability {
  return { type: 0 };
}

export const SearchCapability: MessageFns<SearchCapability> = {
  encode(message: SearchCapability, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchCapability {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchCapability();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchCapability {
    return { type: isSet(object.type) ? searchCapability_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: SearchCapability): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = searchCapability_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchCapability>): SearchCapability {
    return SearchCapability.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchCapability>): SearchCapability {
    const message = createBaseSearchCapability();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseSearchCapabilitySetting(): SearchCapabilitySetting {
  return { searchCapabilities: [] };
}

export const SearchCapabilitySetting: MessageFns<SearchCapabilitySetting> = {
  encode(message: SearchCapabilitySetting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.searchCapabilities) {
      SearchCapability.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchCapabilitySetting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchCapabilitySetting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchCapabilities.push(SearchCapability.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchCapabilitySetting {
    return {
      searchCapabilities: globalThis.Array.isArray(object?.searchCapabilities)
        ? object.searchCapabilities.map((e: any) => SearchCapability.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchCapabilitySetting): unknown {
    const obj: any = {};
    if (message.searchCapabilities?.length) {
      obj.searchCapabilities = message.searchCapabilities.map((e) => SearchCapability.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchCapabilitySetting>): SearchCapabilitySetting {
    return SearchCapabilitySetting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchCapabilitySetting>): SearchCapabilitySetting {
    const message = createBaseSearchCapabilitySetting();
    message.searchCapabilities = object.searchCapabilities?.map((e) => SearchCapability.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateCollectionMetadata(): CreateCollectionMetadata {
  return { operationMetadata: undefined };
}

export const CreateCollectionMetadata: MessageFns<CreateCollectionMetadata> = {
  encode(message: CreateCollectionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationMetadata !== undefined) {
      OperationMetadata.encode(message.operationMetadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCollectionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCollectionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operationMetadata = OperationMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCollectionMetadata {
    return {
      operationMetadata: isSet(object.operationMetadata)
        ? OperationMetadata.fromJSON(object.operationMetadata)
        : undefined,
    };
  },

  toJSON(message: CreateCollectionMetadata): unknown {
    const obj: any = {};
    if (message.operationMetadata !== undefined) {
      obj.operationMetadata = OperationMetadata.toJSON(message.operationMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCollectionMetadata>): CreateCollectionMetadata {
    return CreateCollectionMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCollectionMetadata>): CreateCollectionMetadata {
    const message = createBaseCreateCollectionMetadata();
    message.operationMetadata = (object.operationMetadata !== undefined && object.operationMetadata !== null)
      ? OperationMetadata.fromPartial(object.operationMetadata)
      : undefined;
    return message;
  },
};

function createBaseCreateCollectionRequest(): CreateCollectionRequest {
  return { parent: "", collection: undefined, collectionId: undefined };
}

export const CreateCollectionRequest: MessageFns<CreateCollectionRequest> = {
  encode(message: CreateCollectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.collection !== undefined) {
      Collection.encode(message.collection, writer.uint32(18).fork()).join();
    }
    if (message.collectionId !== undefined) {
      writer.uint32(26).string(message.collectionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCollectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.collection = Collection.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.collectionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCollectionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      collection: isSet(object.collection) ? Collection.fromJSON(object.collection) : undefined,
      collectionId: isSet(object.collectionId) ? globalThis.String(object.collectionId) : undefined,
    };
  },

  toJSON(message: CreateCollectionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.collection !== undefined) {
      obj.collection = Collection.toJSON(message.collection);
    }
    if (message.collectionId !== undefined) {
      obj.collectionId = message.collectionId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCollectionRequest>): CreateCollectionRequest {
    return CreateCollectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCollectionRequest>): CreateCollectionRequest {
    const message = createBaseCreateCollectionRequest();
    message.parent = object.parent ?? "";
    message.collection = (object.collection !== undefined && object.collection !== null)
      ? Collection.fromPartial(object.collection)
      : undefined;
    message.collectionId = object.collectionId ?? undefined;
    return message;
  },
};

function createBaseDeleteCollectionMetadata(): DeleteCollectionMetadata {
  return { operationMetadata: undefined };
}

export const DeleteCollectionMetadata: MessageFns<DeleteCollectionMetadata> = {
  encode(message: DeleteCollectionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationMetadata !== undefined) {
      OperationMetadata.encode(message.operationMetadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCollectionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCollectionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operationMetadata = OperationMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCollectionMetadata {
    return {
      operationMetadata: isSet(object.operationMetadata)
        ? OperationMetadata.fromJSON(object.operationMetadata)
        : undefined,
    };
  },

  toJSON(message: DeleteCollectionMetadata): unknown {
    const obj: any = {};
    if (message.operationMetadata !== undefined) {
      obj.operationMetadata = OperationMetadata.toJSON(message.operationMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCollectionMetadata>): DeleteCollectionMetadata {
    return DeleteCollectionMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCollectionMetadata>): DeleteCollectionMetadata {
    const message = createBaseDeleteCollectionMetadata();
    message.operationMetadata = (object.operationMetadata !== undefined && object.operationMetadata !== null)
      ? OperationMetadata.fromPartial(object.operationMetadata)
      : undefined;
    return message;
  },
};

function createBaseDeleteCollectionRequest(): DeleteCollectionRequest {
  return { name: "" };
}

export const DeleteCollectionRequest: MessageFns<DeleteCollectionRequest> = {
  encode(message: DeleteCollectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCollectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCollectionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteCollectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCollectionRequest>): DeleteCollectionRequest {
    return DeleteCollectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCollectionRequest>): DeleteCollectionRequest {
    const message = createBaseDeleteCollectionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetCollectionRequest(): GetCollectionRequest {
  return { name: "" };
}

export const GetCollectionRequest: MessageFns<GetCollectionRequest> = {
  encode(message: GetCollectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCollectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCollectionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCollectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCollectionRequest>): GetCollectionRequest {
    return GetCollectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCollectionRequest>): GetCollectionRequest {
    const message = createBaseGetCollectionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateCollectionRequest(): UpdateCollectionRequest {
  return { collection: undefined, updateMask: undefined };
}

export const UpdateCollectionRequest: MessageFns<UpdateCollectionRequest> = {
  encode(message: UpdateCollectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== undefined) {
      Collection.encode(message.collection, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCollectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.collection = Collection.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCollectionRequest {
    return {
      collection: isSet(object.collection) ? Collection.fromJSON(object.collection) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateCollectionRequest): unknown {
    const obj: any = {};
    if (message.collection !== undefined) {
      obj.collection = Collection.toJSON(message.collection);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCollectionRequest>): UpdateCollectionRequest {
    return UpdateCollectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCollectionRequest>): UpdateCollectionRequest {
    const message = createBaseUpdateCollectionRequest();
    message.collection = (object.collection !== undefined && object.collection !== null)
      ? Collection.fromPartial(object.collection)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseListCollectionsRequest(): ListCollectionsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListCollectionsRequest: MessageFns<ListCollectionsRequest> = {
  encode(message: ListCollectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCollectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCollectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCollectionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListCollectionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCollectionsRequest>): ListCollectionsRequest {
    return ListCollectionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCollectionsRequest>): ListCollectionsRequest {
    const message = createBaseListCollectionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListCollectionsResponse(): ListCollectionsResponse {
  return { collections: [], nextPageToken: "" };
}

export const ListCollectionsResponse: MessageFns<ListCollectionsResponse> = {
  encode(message: ListCollectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.collections) {
      Collection.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCollectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCollectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.collections.push(Collection.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCollectionsResponse {
    return {
      collections: globalThis.Array.isArray(object?.collections)
        ? object.collections.map((e: any) => Collection.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListCollectionsResponse): unknown {
    const obj: any = {};
    if (message.collections?.length) {
      obj.collections = message.collections.map((e) => Collection.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCollectionsResponse>): ListCollectionsResponse {
    return ListCollectionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCollectionsResponse>): ListCollectionsResponse {
    const message = createBaseListCollectionsResponse();
    message.collections = object.collections?.map((e) => Collection.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseAddCollectionItemRequest(): AddCollectionItemRequest {
  return { item: undefined };
}

export const AddCollectionItemRequest: MessageFns<AddCollectionItemRequest> = {
  encode(message: AddCollectionItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.item !== undefined) {
      CollectionItem.encode(message.item, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddCollectionItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddCollectionItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.item = CollectionItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddCollectionItemRequest {
    return { item: isSet(object.item) ? CollectionItem.fromJSON(object.item) : undefined };
  },

  toJSON(message: AddCollectionItemRequest): unknown {
    const obj: any = {};
    if (message.item !== undefined) {
      obj.item = CollectionItem.toJSON(message.item);
    }
    return obj;
  },

  create(base?: DeepPartial<AddCollectionItemRequest>): AddCollectionItemRequest {
    return AddCollectionItemRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddCollectionItemRequest>): AddCollectionItemRequest {
    const message = createBaseAddCollectionItemRequest();
    message.item = (object.item !== undefined && object.item !== null)
      ? CollectionItem.fromPartial(object.item)
      : undefined;
    return message;
  },
};

function createBaseAddCollectionItemResponse(): AddCollectionItemResponse {
  return { item: undefined };
}

export const AddCollectionItemResponse: MessageFns<AddCollectionItemResponse> = {
  encode(message: AddCollectionItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.item !== undefined) {
      CollectionItem.encode(message.item, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddCollectionItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddCollectionItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.item = CollectionItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddCollectionItemResponse {
    return { item: isSet(object.item) ? CollectionItem.fromJSON(object.item) : undefined };
  },

  toJSON(message: AddCollectionItemResponse): unknown {
    const obj: any = {};
    if (message.item !== undefined) {
      obj.item = CollectionItem.toJSON(message.item);
    }
    return obj;
  },

  create(base?: DeepPartial<AddCollectionItemResponse>): AddCollectionItemResponse {
    return AddCollectionItemResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddCollectionItemResponse>): AddCollectionItemResponse {
    const message = createBaseAddCollectionItemResponse();
    message.item = (object.item !== undefined && object.item !== null)
      ? CollectionItem.fromPartial(object.item)
      : undefined;
    return message;
  },
};

function createBaseRemoveCollectionItemRequest(): RemoveCollectionItemRequest {
  return { item: undefined };
}

export const RemoveCollectionItemRequest: MessageFns<RemoveCollectionItemRequest> = {
  encode(message: RemoveCollectionItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.item !== undefined) {
      CollectionItem.encode(message.item, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveCollectionItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveCollectionItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.item = CollectionItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveCollectionItemRequest {
    return { item: isSet(object.item) ? CollectionItem.fromJSON(object.item) : undefined };
  },

  toJSON(message: RemoveCollectionItemRequest): unknown {
    const obj: any = {};
    if (message.item !== undefined) {
      obj.item = CollectionItem.toJSON(message.item);
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveCollectionItemRequest>): RemoveCollectionItemRequest {
    return RemoveCollectionItemRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveCollectionItemRequest>): RemoveCollectionItemRequest {
    const message = createBaseRemoveCollectionItemRequest();
    message.item = (object.item !== undefined && object.item !== null)
      ? CollectionItem.fromPartial(object.item)
      : undefined;
    return message;
  },
};

function createBaseRemoveCollectionItemResponse(): RemoveCollectionItemResponse {
  return { item: undefined };
}

export const RemoveCollectionItemResponse: MessageFns<RemoveCollectionItemResponse> = {
  encode(message: RemoveCollectionItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.item !== undefined) {
      CollectionItem.encode(message.item, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveCollectionItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveCollectionItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.item = CollectionItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveCollectionItemResponse {
    return { item: isSet(object.item) ? CollectionItem.fromJSON(object.item) : undefined };
  },

  toJSON(message: RemoveCollectionItemResponse): unknown {
    const obj: any = {};
    if (message.item !== undefined) {
      obj.item = CollectionItem.toJSON(message.item);
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveCollectionItemResponse>): RemoveCollectionItemResponse {
    return RemoveCollectionItemResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveCollectionItemResponse>): RemoveCollectionItemResponse {
    const message = createBaseRemoveCollectionItemResponse();
    message.item = (object.item !== undefined && object.item !== null)
      ? CollectionItem.fromPartial(object.item)
      : undefined;
    return message;
  },
};

function createBaseViewCollectionItemsRequest(): ViewCollectionItemsRequest {
  return { collection: "", pageSize: 0, pageToken: "" };
}

export const ViewCollectionItemsRequest: MessageFns<ViewCollectionItemsRequest> = {
  encode(message: ViewCollectionItemsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewCollectionItemsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewCollectionItemsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewCollectionItemsRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ViewCollectionItemsRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ViewCollectionItemsRequest>): ViewCollectionItemsRequest {
    return ViewCollectionItemsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ViewCollectionItemsRequest>): ViewCollectionItemsRequest {
    const message = createBaseViewCollectionItemsRequest();
    message.collection = object.collection ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseViewCollectionItemsResponse(): ViewCollectionItemsResponse {
  return { items: [], nextPageToken: "" };
}

export const ViewCollectionItemsResponse: MessageFns<ViewCollectionItemsResponse> = {
  encode(message: ViewCollectionItemsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      CollectionItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewCollectionItemsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewCollectionItemsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(CollectionItem.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewCollectionItemsResponse {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => CollectionItem.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ViewCollectionItemsResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => CollectionItem.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ViewCollectionItemsResponse>): ViewCollectionItemsResponse {
    return ViewCollectionItemsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ViewCollectionItemsResponse>): ViewCollectionItemsResponse {
    const message = createBaseViewCollectionItemsResponse();
    message.items = object.items?.map((e) => CollectionItem.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCollection(): Collection {
  return { name: "", displayName: "", description: "" };
}

export const Collection: MessageFns<Collection> = {
  encode(message: Collection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Collection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Collection {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Collection): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<Collection>): Collection {
    return Collection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Collection>): Collection {
    const message = createBaseCollection();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseCollectionItem(): CollectionItem {
  return { collection: "", type: 0, itemResource: "" };
}

export const CollectionItem: MessageFns<CollectionItem> = {
  encode(message: CollectionItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.itemResource !== "") {
      writer.uint32(26).string(message.itemResource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectionItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectionItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.itemResource = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectionItem {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      type: isSet(object.type) ? collectionItem_TypeFromJSON(object.type) : 0,
      itemResource: isSet(object.itemResource) ? globalThis.String(object.itemResource) : "",
    };
  },

  toJSON(message: CollectionItem): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.type !== 0) {
      obj.type = collectionItem_TypeToJSON(message.type);
    }
    if (message.itemResource !== "") {
      obj.itemResource = message.itemResource;
    }
    return obj;
  },

  create(base?: DeepPartial<CollectionItem>): CollectionItem {
    return CollectionItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CollectionItem>): CollectionItem {
    const message = createBaseCollectionItem();
    message.collection = object.collection ?? "";
    message.type = object.type ?? 0;
    message.itemResource = object.itemResource ?? "";
    return message;
  },
};

function createBaseCreateIndexRequest(): CreateIndexRequest {
  return { parent: "", indexId: "", index: undefined };
}

export const CreateIndexRequest: MessageFns<CreateIndexRequest> = {
  encode(message: CreateIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.indexId !== "") {
      writer.uint32(18).string(message.indexId);
    }
    if (message.index !== undefined) {
      Index.encode(message.index, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.indexId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.index = Index.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIndexRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      indexId: isSet(object.indexId) ? globalThis.String(object.indexId) : "",
      index: isSet(object.index) ? Index.fromJSON(object.index) : undefined,
    };
  },

  toJSON(message: CreateIndexRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.indexId !== "") {
      obj.indexId = message.indexId;
    }
    if (message.index !== undefined) {
      obj.index = Index.toJSON(message.index);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateIndexRequest>): CreateIndexRequest {
    return CreateIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateIndexRequest>): CreateIndexRequest {
    const message = createBaseCreateIndexRequest();
    message.parent = object.parent ?? "";
    message.indexId = object.indexId ?? "";
    message.index = (object.index !== undefined && object.index !== null) ? Index.fromPartial(object.index) : undefined;
    return message;
  },
};

function createBaseCreateIndexMetadata(): CreateIndexMetadata {
  return { operationMetadata: undefined };
}

export const CreateIndexMetadata: MessageFns<CreateIndexMetadata> = {
  encode(message: CreateIndexMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationMetadata !== undefined) {
      OperationMetadata.encode(message.operationMetadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateIndexMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIndexMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operationMetadata = OperationMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIndexMetadata {
    return {
      operationMetadata: isSet(object.operationMetadata)
        ? OperationMetadata.fromJSON(object.operationMetadata)
        : undefined,
    };
  },

  toJSON(message: CreateIndexMetadata): unknown {
    const obj: any = {};
    if (message.operationMetadata !== undefined) {
      obj.operationMetadata = OperationMetadata.toJSON(message.operationMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateIndexMetadata>): CreateIndexMetadata {
    return CreateIndexMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateIndexMetadata>): CreateIndexMetadata {
    const message = createBaseCreateIndexMetadata();
    message.operationMetadata = (object.operationMetadata !== undefined && object.operationMetadata !== null)
      ? OperationMetadata.fromPartial(object.operationMetadata)
      : undefined;
    return message;
  },
};

function createBaseUpdateIndexRequest(): UpdateIndexRequest {
  return { index: undefined, updateMask: undefined };
}

export const UpdateIndexRequest: MessageFns<UpdateIndexRequest> = {
  encode(message: UpdateIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== undefined) {
      Index.encode(message.index, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.index = Index.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateIndexRequest {
    return {
      index: isSet(object.index) ? Index.fromJSON(object.index) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateIndexRequest): unknown {
    const obj: any = {};
    if (message.index !== undefined) {
      obj.index = Index.toJSON(message.index);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateIndexRequest>): UpdateIndexRequest {
    return UpdateIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateIndexRequest>): UpdateIndexRequest {
    const message = createBaseUpdateIndexRequest();
    message.index = (object.index !== undefined && object.index !== null) ? Index.fromPartial(object.index) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUpdateIndexMetadata(): UpdateIndexMetadata {
  return { operationMetadata: undefined };
}

export const UpdateIndexMetadata: MessageFns<UpdateIndexMetadata> = {
  encode(message: UpdateIndexMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationMetadata !== undefined) {
      OperationMetadata.encode(message.operationMetadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateIndexMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateIndexMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operationMetadata = OperationMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateIndexMetadata {
    return {
      operationMetadata: isSet(object.operationMetadata)
        ? OperationMetadata.fromJSON(object.operationMetadata)
        : undefined,
    };
  },

  toJSON(message: UpdateIndexMetadata): unknown {
    const obj: any = {};
    if (message.operationMetadata !== undefined) {
      obj.operationMetadata = OperationMetadata.toJSON(message.operationMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateIndexMetadata>): UpdateIndexMetadata {
    return UpdateIndexMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateIndexMetadata>): UpdateIndexMetadata {
    const message = createBaseUpdateIndexMetadata();
    message.operationMetadata = (object.operationMetadata !== undefined && object.operationMetadata !== null)
      ? OperationMetadata.fromPartial(object.operationMetadata)
      : undefined;
    return message;
  },
};

function createBaseGetIndexRequest(): GetIndexRequest {
  return { name: "" };
}

export const GetIndexRequest: MessageFns<GetIndexRequest> = {
  encode(message: GetIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIndexRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetIndexRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetIndexRequest>): GetIndexRequest {
    return GetIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetIndexRequest>): GetIndexRequest {
    const message = createBaseGetIndexRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListIndexesRequest(): ListIndexesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListIndexesRequest: MessageFns<ListIndexesRequest> = {
  encode(message: ListIndexesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIndexesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIndexesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIndexesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListIndexesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIndexesRequest>): ListIndexesRequest {
    return ListIndexesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIndexesRequest>): ListIndexesRequest {
    const message = createBaseListIndexesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListIndexesResponse(): ListIndexesResponse {
  return { indexes: [], nextPageToken: "" };
}

export const ListIndexesResponse: MessageFns<ListIndexesResponse> = {
  encode(message: ListIndexesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.indexes) {
      Index.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIndexesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIndexesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.indexes.push(Index.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIndexesResponse {
    return {
      indexes: globalThis.Array.isArray(object?.indexes) ? object.indexes.map((e: any) => Index.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListIndexesResponse): unknown {
    const obj: any = {};
    if (message.indexes?.length) {
      obj.indexes = message.indexes.map((e) => Index.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIndexesResponse>): ListIndexesResponse {
    return ListIndexesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIndexesResponse>): ListIndexesResponse {
    const message = createBaseListIndexesResponse();
    message.indexes = object.indexes?.map((e) => Index.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteIndexRequest(): DeleteIndexRequest {
  return { name: "" };
}

export const DeleteIndexRequest: MessageFns<DeleteIndexRequest> = {
  encode(message: DeleteIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteIndexRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteIndexRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteIndexRequest>): DeleteIndexRequest {
    return DeleteIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteIndexRequest>): DeleteIndexRequest {
    const message = createBaseDeleteIndexRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteIndexMetadata(): DeleteIndexMetadata {
  return {};
}

export const DeleteIndexMetadata: MessageFns<DeleteIndexMetadata> = {
  encode(_: DeleteIndexMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteIndexMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIndexMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteIndexMetadata {
    return {};
  },

  toJSON(_: DeleteIndexMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DeleteIndexMetadata>): DeleteIndexMetadata {
    return DeleteIndexMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeleteIndexMetadata>): DeleteIndexMetadata {
    const message = createBaseDeleteIndexMetadata();
    return message;
  },
};

function createBaseIndex(): Index {
  return {
    entireCorpus: undefined,
    name: "",
    displayName: "",
    description: "",
    state: 0,
    createTime: undefined,
    updateTime: undefined,
    deployedIndexes: [],
    satisfiesPzs: undefined,
    satisfiesPzi: undefined,
  };
}

export const Index: MessageFns<Index> = {
  encode(message: Index, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entireCorpus !== undefined) {
      writer.uint32(72).bool(message.entireCorpus);
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    for (const v of message.deployedIndexes) {
      DeployedIndexReference.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.satisfiesPzs !== undefined) {
      writer.uint32(88).bool(message.satisfiesPzs);
    }
    if (message.satisfiesPzi !== undefined) {
      writer.uint32(96).bool(message.satisfiesPzi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Index {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 9:
          if (tag !== 72) {
            break;
          }

          message.entireCorpus = reader.bool();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.deployedIndexes.push(DeployedIndexReference.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.satisfiesPzs = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Index {
    return {
      entireCorpus: isSet(object.entireCorpus) ? globalThis.Boolean(object.entireCorpus) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? index_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deployedIndexes: globalThis.Array.isArray(object?.deployedIndexes)
        ? object.deployedIndexes.map((e: any) => DeployedIndexReference.fromJSON(e))
        : [],
      satisfiesPzs: isSet(object.satisfiesPzs) ? globalThis.Boolean(object.satisfiesPzs) : undefined,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : undefined,
    };
  },

  toJSON(message: Index): unknown {
    const obj: any = {};
    if (message.entireCorpus !== undefined) {
      obj.entireCorpus = message.entireCorpus;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== 0) {
      obj.state = index_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deployedIndexes?.length) {
      obj.deployedIndexes = message.deployedIndexes.map((e) => DeployedIndexReference.toJSON(e));
    }
    if (message.satisfiesPzs !== undefined) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== undefined) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    return obj;
  },

  create(base?: DeepPartial<Index>): Index {
    return Index.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Index>): Index {
    const message = createBaseIndex();
    message.entireCorpus = object.entireCorpus ?? undefined;
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deployedIndexes = object.deployedIndexes?.map((e) => DeployedIndexReference.fromPartial(e)) || [];
    message.satisfiesPzs = object.satisfiesPzs ?? undefined;
    message.satisfiesPzi = object.satisfiesPzi ?? undefined;
    return message;
  },
};

function createBaseDeployedIndexReference(): DeployedIndexReference {
  return { indexEndpoint: "" };
}

export const DeployedIndexReference: MessageFns<DeployedIndexReference> = {
  encode(message: DeployedIndexReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexEndpoint !== "") {
      writer.uint32(10).string(message.indexEndpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployedIndexReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployedIndexReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.indexEndpoint = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployedIndexReference {
    return { indexEndpoint: isSet(object.indexEndpoint) ? globalThis.String(object.indexEndpoint) : "" };
  },

  toJSON(message: DeployedIndexReference): unknown {
    const obj: any = {};
    if (message.indexEndpoint !== "") {
      obj.indexEndpoint = message.indexEndpoint;
    }
    return obj;
  },

  create(base?: DeepPartial<DeployedIndexReference>): DeployedIndexReference {
    return DeployedIndexReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployedIndexReference>): DeployedIndexReference {
    const message = createBaseDeployedIndexReference();
    message.indexEndpoint = object.indexEndpoint ?? "";
    return message;
  },
};

function createBaseCorpus(): Corpus {
  return {
    name: "",
    displayName: "",
    description: "",
    defaultTtl: undefined,
    type: 0,
    searchCapabilitySetting: undefined,
    satisfiesPzs: undefined,
    satisfiesPzi: undefined,
  };
}

export const Corpus: MessageFns<Corpus> = {
  encode(message: Corpus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.defaultTtl !== undefined) {
      Duration.encode(message.defaultTtl, writer.uint32(42).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    if (message.searchCapabilitySetting !== undefined) {
      SearchCapabilitySetting.encode(message.searchCapabilitySetting, writer.uint32(66).fork()).join();
    }
    if (message.satisfiesPzs !== undefined) {
      writer.uint32(88).bool(message.satisfiesPzs);
    }
    if (message.satisfiesPzi !== undefined) {
      writer.uint32(96).bool(message.satisfiesPzi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Corpus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCorpus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.defaultTtl = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.searchCapabilitySetting = SearchCapabilitySetting.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.satisfiesPzs = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Corpus {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      defaultTtl: isSet(object.defaultTtl) ? Duration.fromJSON(object.defaultTtl) : undefined,
      type: isSet(object.type) ? corpus_TypeFromJSON(object.type) : 0,
      searchCapabilitySetting: isSet(object.searchCapabilitySetting)
        ? SearchCapabilitySetting.fromJSON(object.searchCapabilitySetting)
        : undefined,
      satisfiesPzs: isSet(object.satisfiesPzs) ? globalThis.Boolean(object.satisfiesPzs) : undefined,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : undefined,
    };
  },

  toJSON(message: Corpus): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.defaultTtl !== undefined) {
      obj.defaultTtl = Duration.toJSON(message.defaultTtl);
    }
    if (message.type !== 0) {
      obj.type = corpus_TypeToJSON(message.type);
    }
    if (message.searchCapabilitySetting !== undefined) {
      obj.searchCapabilitySetting = SearchCapabilitySetting.toJSON(message.searchCapabilitySetting);
    }
    if (message.satisfiesPzs !== undefined) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== undefined) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    return obj;
  },

  create(base?: DeepPartial<Corpus>): Corpus {
    return Corpus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Corpus>): Corpus {
    const message = createBaseCorpus();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.defaultTtl = (object.defaultTtl !== undefined && object.defaultTtl !== null)
      ? Duration.fromPartial(object.defaultTtl)
      : undefined;
    message.type = object.type ?? 0;
    message.searchCapabilitySetting =
      (object.searchCapabilitySetting !== undefined && object.searchCapabilitySetting !== null)
        ? SearchCapabilitySetting.fromPartial(object.searchCapabilitySetting)
        : undefined;
    message.satisfiesPzs = object.satisfiesPzs ?? undefined;
    message.satisfiesPzi = object.satisfiesPzi ?? undefined;
    return message;
  },
};

function createBaseGetCorpusRequest(): GetCorpusRequest {
  return { name: "" };
}

export const GetCorpusRequest: MessageFns<GetCorpusRequest> = {
  encode(message: GetCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCorpusRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCorpusRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCorpusRequest>): GetCorpusRequest {
    return GetCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCorpusRequest>): GetCorpusRequest {
    const message = createBaseGetCorpusRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateCorpusRequest(): UpdateCorpusRequest {
  return { corpus: undefined, updateMask: undefined };
}

export const UpdateCorpusRequest: MessageFns<UpdateCorpusRequest> = {
  encode(message: UpdateCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.corpus !== undefined) {
      Corpus.encode(message.corpus, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.corpus = Corpus.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCorpusRequest {
    return {
      corpus: isSet(object.corpus) ? Corpus.fromJSON(object.corpus) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateCorpusRequest): unknown {
    const obj: any = {};
    if (message.corpus !== undefined) {
      obj.corpus = Corpus.toJSON(message.corpus);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCorpusRequest>): UpdateCorpusRequest {
    return UpdateCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCorpusRequest>): UpdateCorpusRequest {
    const message = createBaseUpdateCorpusRequest();
    message.corpus = (object.corpus !== undefined && object.corpus !== null)
      ? Corpus.fromPartial(object.corpus)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseListCorporaRequest(): ListCorporaRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListCorporaRequest: MessageFns<ListCorporaRequest> = {
  encode(message: ListCorporaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCorporaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCorporaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCorporaRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListCorporaRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCorporaRequest>): ListCorporaRequest {
    return ListCorporaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCorporaRequest>): ListCorporaRequest {
    const message = createBaseListCorporaRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListCorporaResponse(): ListCorporaResponse {
  return { corpora: [], nextPageToken: "" };
}

export const ListCorporaResponse: MessageFns<ListCorporaResponse> = {
  encode(message: ListCorporaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.corpora) {
      Corpus.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCorporaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCorporaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.corpora.push(Corpus.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCorporaResponse {
    return {
      corpora: globalThis.Array.isArray(object?.corpora) ? object.corpora.map((e: any) => Corpus.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListCorporaResponse): unknown {
    const obj: any = {};
    if (message.corpora?.length) {
      obj.corpora = message.corpora.map((e) => Corpus.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCorporaResponse>): ListCorporaResponse {
    return ListCorporaResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCorporaResponse>): ListCorporaResponse {
    const message = createBaseListCorporaResponse();
    message.corpora = object.corpora?.map((e) => Corpus.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteCorpusRequest(): DeleteCorpusRequest {
  return { name: "" };
}

export const DeleteCorpusRequest: MessageFns<DeleteCorpusRequest> = {
  encode(message: DeleteCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCorpusRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteCorpusRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCorpusRequest>): DeleteCorpusRequest {
    return DeleteCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCorpusRequest>): DeleteCorpusRequest {
    const message = createBaseDeleteCorpusRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAnalyzeCorpusRequest(): AnalyzeCorpusRequest {
  return { name: "" };
}

export const AnalyzeCorpusRequest: MessageFns<AnalyzeCorpusRequest> = {
  encode(message: AnalyzeCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeCorpusRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: AnalyzeCorpusRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzeCorpusRequest>): AnalyzeCorpusRequest {
    return AnalyzeCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzeCorpusRequest>): AnalyzeCorpusRequest {
    const message = createBaseAnalyzeCorpusRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAnalyzeCorpusMetadata(): AnalyzeCorpusMetadata {
  return { metadata: undefined };
}

export const AnalyzeCorpusMetadata: MessageFns<AnalyzeCorpusMetadata> = {
  encode(message: AnalyzeCorpusMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      OperationMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeCorpusMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeCorpusMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = OperationMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeCorpusMetadata {
    return { metadata: isSet(object.metadata) ? OperationMetadata.fromJSON(object.metadata) : undefined };
  },

  toJSON(message: AnalyzeCorpusMetadata): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = OperationMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzeCorpusMetadata>): AnalyzeCorpusMetadata {
    return AnalyzeCorpusMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzeCorpusMetadata>): AnalyzeCorpusMetadata {
    const message = createBaseAnalyzeCorpusMetadata();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? OperationMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseAnalyzeCorpusResponse(): AnalyzeCorpusResponse {
  return {};
}

export const AnalyzeCorpusResponse: MessageFns<AnalyzeCorpusResponse> = {
  encode(_: AnalyzeCorpusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeCorpusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeCorpusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AnalyzeCorpusResponse {
    return {};
  },

  toJSON(_: AnalyzeCorpusResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AnalyzeCorpusResponse>): AnalyzeCorpusResponse {
    return AnalyzeCorpusResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AnalyzeCorpusResponse>): AnalyzeCorpusResponse {
    const message = createBaseAnalyzeCorpusResponse();
    return message;
  },
};

function createBaseCreateDataSchemaRequest(): CreateDataSchemaRequest {
  return { parent: "", dataSchema: undefined };
}

export const CreateDataSchemaRequest: MessageFns<CreateDataSchemaRequest> = {
  encode(message: CreateDataSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.dataSchema !== undefined) {
      DataSchema.encode(message.dataSchema, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDataSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDataSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataSchema = DataSchema.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDataSchemaRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      dataSchema: isSet(object.dataSchema) ? DataSchema.fromJSON(object.dataSchema) : undefined,
    };
  },

  toJSON(message: CreateDataSchemaRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.dataSchema !== undefined) {
      obj.dataSchema = DataSchema.toJSON(message.dataSchema);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDataSchemaRequest>): CreateDataSchemaRequest {
    return CreateDataSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDataSchemaRequest>): CreateDataSchemaRequest {
    const message = createBaseCreateDataSchemaRequest();
    message.parent = object.parent ?? "";
    message.dataSchema = (object.dataSchema !== undefined && object.dataSchema !== null)
      ? DataSchema.fromPartial(object.dataSchema)
      : undefined;
    return message;
  },
};

function createBaseDataSchema(): DataSchema {
  return { name: "", key: "", schemaDetails: undefined };
}

export const DataSchema: MessageFns<DataSchema> = {
  encode(message: DataSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.schemaDetails !== undefined) {
      DataSchemaDetails.encode(message.schemaDetails, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.schemaDetails = DataSchemaDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSchema {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      schemaDetails: isSet(object.schemaDetails) ? DataSchemaDetails.fromJSON(object.schemaDetails) : undefined,
    };
  },

  toJSON(message: DataSchema): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.schemaDetails !== undefined) {
      obj.schemaDetails = DataSchemaDetails.toJSON(message.schemaDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<DataSchema>): DataSchema {
    return DataSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSchema>): DataSchema {
    const message = createBaseDataSchema();
    message.name = object.name ?? "";
    message.key = object.key ?? "";
    message.schemaDetails = (object.schemaDetails !== undefined && object.schemaDetails !== null)
      ? DataSchemaDetails.fromPartial(object.schemaDetails)
      : undefined;
    return message;
  },
};

function createBaseDataSchemaDetails(): DataSchemaDetails {
  return {
    type: undefined,
    protoAnyConfig: undefined,
    listConfig: undefined,
    customizedStructConfig: undefined,
    granularity: undefined,
    searchStrategy: undefined,
  };
}

export const DataSchemaDetails: MessageFns<DataSchemaDetails> = {
  encode(message: DataSchemaDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined) {
      writer.uint32(8).int32(message.type);
    }
    if (message.protoAnyConfig !== undefined) {
      DataSchemaDetails_ProtoAnyConfig.encode(message.protoAnyConfig, writer.uint32(50).fork()).join();
    }
    if (message.listConfig !== undefined) {
      DataSchemaDetails_ListConfig.encode(message.listConfig, writer.uint32(66).fork()).join();
    }
    if (message.customizedStructConfig !== undefined) {
      DataSchemaDetails_CustomizedStructConfig.encode(message.customizedStructConfig, writer.uint32(74).fork()).join();
    }
    if (message.granularity !== undefined) {
      writer.uint32(40).int32(message.granularity);
    }
    if (message.searchStrategy !== undefined) {
      DataSchemaDetails_SearchStrategy.encode(message.searchStrategy, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSchemaDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSchemaDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.protoAnyConfig = DataSchemaDetails_ProtoAnyConfig.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.listConfig = DataSchemaDetails_ListConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.customizedStructConfig = DataSchemaDetails_CustomizedStructConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.granularity = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.searchStrategy = DataSchemaDetails_SearchStrategy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSchemaDetails {
    return {
      type: isSet(object.type) ? dataSchemaDetails_DataTypeFromJSON(object.type) : undefined,
      protoAnyConfig: isSet(object.protoAnyConfig)
        ? DataSchemaDetails_ProtoAnyConfig.fromJSON(object.protoAnyConfig)
        : undefined,
      listConfig: isSet(object.listConfig) ? DataSchemaDetails_ListConfig.fromJSON(object.listConfig) : undefined,
      customizedStructConfig: isSet(object.customizedStructConfig)
        ? DataSchemaDetails_CustomizedStructConfig.fromJSON(object.customizedStructConfig)
        : undefined,
      granularity: isSet(object.granularity) ? dataSchemaDetails_GranularityFromJSON(object.granularity) : undefined,
      searchStrategy: isSet(object.searchStrategy)
        ? DataSchemaDetails_SearchStrategy.fromJSON(object.searchStrategy)
        : undefined,
    };
  },

  toJSON(message: DataSchemaDetails): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = dataSchemaDetails_DataTypeToJSON(message.type);
    }
    if (message.protoAnyConfig !== undefined) {
      obj.protoAnyConfig = DataSchemaDetails_ProtoAnyConfig.toJSON(message.protoAnyConfig);
    }
    if (message.listConfig !== undefined) {
      obj.listConfig = DataSchemaDetails_ListConfig.toJSON(message.listConfig);
    }
    if (message.customizedStructConfig !== undefined) {
      obj.customizedStructConfig = DataSchemaDetails_CustomizedStructConfig.toJSON(message.customizedStructConfig);
    }
    if (message.granularity !== undefined) {
      obj.granularity = dataSchemaDetails_GranularityToJSON(message.granularity);
    }
    if (message.searchStrategy !== undefined) {
      obj.searchStrategy = DataSchemaDetails_SearchStrategy.toJSON(message.searchStrategy);
    }
    return obj;
  },

  create(base?: DeepPartial<DataSchemaDetails>): DataSchemaDetails {
    return DataSchemaDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSchemaDetails>): DataSchemaDetails {
    const message = createBaseDataSchemaDetails();
    message.type = object.type ?? undefined;
    message.protoAnyConfig = (object.protoAnyConfig !== undefined && object.protoAnyConfig !== null)
      ? DataSchemaDetails_ProtoAnyConfig.fromPartial(object.protoAnyConfig)
      : undefined;
    message.listConfig = (object.listConfig !== undefined && object.listConfig !== null)
      ? DataSchemaDetails_ListConfig.fromPartial(object.listConfig)
      : undefined;
    message.customizedStructConfig =
      (object.customizedStructConfig !== undefined && object.customizedStructConfig !== null)
        ? DataSchemaDetails_CustomizedStructConfig.fromPartial(object.customizedStructConfig)
        : undefined;
    message.granularity = object.granularity ?? undefined;
    message.searchStrategy = (object.searchStrategy !== undefined && object.searchStrategy !== null)
      ? DataSchemaDetails_SearchStrategy.fromPartial(object.searchStrategy)
      : undefined;
    return message;
  },
};

function createBaseDataSchemaDetails_ProtoAnyConfig(): DataSchemaDetails_ProtoAnyConfig {
  return { typeUri: "" };
}

export const DataSchemaDetails_ProtoAnyConfig: MessageFns<DataSchemaDetails_ProtoAnyConfig> = {
  encode(message: DataSchemaDetails_ProtoAnyConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typeUri !== "") {
      writer.uint32(10).string(message.typeUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSchemaDetails_ProtoAnyConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSchemaDetails_ProtoAnyConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.typeUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSchemaDetails_ProtoAnyConfig {
    return { typeUri: isSet(object.typeUri) ? globalThis.String(object.typeUri) : "" };
  },

  toJSON(message: DataSchemaDetails_ProtoAnyConfig): unknown {
    const obj: any = {};
    if (message.typeUri !== "") {
      obj.typeUri = message.typeUri;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSchemaDetails_ProtoAnyConfig>): DataSchemaDetails_ProtoAnyConfig {
    return DataSchemaDetails_ProtoAnyConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSchemaDetails_ProtoAnyConfig>): DataSchemaDetails_ProtoAnyConfig {
    const message = createBaseDataSchemaDetails_ProtoAnyConfig();
    message.typeUri = object.typeUri ?? "";
    return message;
  },
};

function createBaseDataSchemaDetails_ListConfig(): DataSchemaDetails_ListConfig {
  return { valueSchema: undefined };
}

export const DataSchemaDetails_ListConfig: MessageFns<DataSchemaDetails_ListConfig> = {
  encode(message: DataSchemaDetails_ListConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valueSchema !== undefined) {
      DataSchemaDetails.encode(message.valueSchema, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSchemaDetails_ListConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSchemaDetails_ListConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.valueSchema = DataSchemaDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSchemaDetails_ListConfig {
    return { valueSchema: isSet(object.valueSchema) ? DataSchemaDetails.fromJSON(object.valueSchema) : undefined };
  },

  toJSON(message: DataSchemaDetails_ListConfig): unknown {
    const obj: any = {};
    if (message.valueSchema !== undefined) {
      obj.valueSchema = DataSchemaDetails.toJSON(message.valueSchema);
    }
    return obj;
  },

  create(base?: DeepPartial<DataSchemaDetails_ListConfig>): DataSchemaDetails_ListConfig {
    return DataSchemaDetails_ListConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSchemaDetails_ListConfig>): DataSchemaDetails_ListConfig {
    const message = createBaseDataSchemaDetails_ListConfig();
    message.valueSchema = (object.valueSchema !== undefined && object.valueSchema !== null)
      ? DataSchemaDetails.fromPartial(object.valueSchema)
      : undefined;
    return message;
  },
};

function createBaseDataSchemaDetails_CustomizedStructConfig(): DataSchemaDetails_CustomizedStructConfig {
  return { fieldSchemas: {} };
}

export const DataSchemaDetails_CustomizedStructConfig: MessageFns<DataSchemaDetails_CustomizedStructConfig> = {
  encode(message: DataSchemaDetails_CustomizedStructConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.fieldSchemas).forEach(([key, value]) => {
      DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSchemaDetails_CustomizedStructConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSchemaDetails_CustomizedStructConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.fieldSchemas[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSchemaDetails_CustomizedStructConfig {
    return {
      fieldSchemas: isObject(object.fieldSchemas)
        ? Object.entries(object.fieldSchemas).reduce<{ [key: string]: DataSchemaDetails }>((acc, [key, value]) => {
          acc[key] = DataSchemaDetails.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DataSchemaDetails_CustomizedStructConfig): unknown {
    const obj: any = {};
    if (message.fieldSchemas) {
      const entries = Object.entries(message.fieldSchemas);
      if (entries.length > 0) {
        obj.fieldSchemas = {};
        entries.forEach(([k, v]) => {
          obj.fieldSchemas[k] = DataSchemaDetails.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<DataSchemaDetails_CustomizedStructConfig>): DataSchemaDetails_CustomizedStructConfig {
    return DataSchemaDetails_CustomizedStructConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSchemaDetails_CustomizedStructConfig>): DataSchemaDetails_CustomizedStructConfig {
    const message = createBaseDataSchemaDetails_CustomizedStructConfig();
    message.fieldSchemas = Object.entries(object.fieldSchemas ?? {}).reduce<{ [key: string]: DataSchemaDetails }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = DataSchemaDetails.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry(): DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry {
  return { key: "", value: undefined };
}

export const DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry: MessageFns<
  DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry
> = {
  encode(
    message: DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DataSchemaDetails.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = DataSchemaDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DataSchemaDetails.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DataSchemaDetails.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry>,
  ): DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry {
    return DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry>,
  ): DataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry {
    const message = createBaseDataSchemaDetails_CustomizedStructConfig_FieldSchemasEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DataSchemaDetails.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDataSchemaDetails_SearchStrategy(): DataSchemaDetails_SearchStrategy {
  return { searchStrategyType: undefined, confidenceScoreIndexConfig: undefined };
}

export const DataSchemaDetails_SearchStrategy: MessageFns<DataSchemaDetails_SearchStrategy> = {
  encode(message: DataSchemaDetails_SearchStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchStrategyType !== undefined) {
      writer.uint32(8).int32(message.searchStrategyType);
    }
    if (message.confidenceScoreIndexConfig !== undefined) {
      DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig.encode(
        message.confidenceScoreIndexConfig,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSchemaDetails_SearchStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSchemaDetails_SearchStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.searchStrategyType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.confidenceScoreIndexConfig = DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSchemaDetails_SearchStrategy {
    return {
      searchStrategyType: isSet(object.searchStrategyType)
        ? dataSchemaDetails_SearchStrategy_SearchStrategyTypeFromJSON(object.searchStrategyType)
        : undefined,
      confidenceScoreIndexConfig: isSet(object.confidenceScoreIndexConfig)
        ? DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig.fromJSON(object.confidenceScoreIndexConfig)
        : undefined,
    };
  },

  toJSON(message: DataSchemaDetails_SearchStrategy): unknown {
    const obj: any = {};
    if (message.searchStrategyType !== undefined) {
      obj.searchStrategyType = dataSchemaDetails_SearchStrategy_SearchStrategyTypeToJSON(message.searchStrategyType);
    }
    if (message.confidenceScoreIndexConfig !== undefined) {
      obj.confidenceScoreIndexConfig = DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig.toJSON(
        message.confidenceScoreIndexConfig,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<DataSchemaDetails_SearchStrategy>): DataSchemaDetails_SearchStrategy {
    return DataSchemaDetails_SearchStrategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSchemaDetails_SearchStrategy>): DataSchemaDetails_SearchStrategy {
    const message = createBaseDataSchemaDetails_SearchStrategy();
    message.searchStrategyType = object.searchStrategyType ?? undefined;
    message.confidenceScoreIndexConfig =
      (object.confidenceScoreIndexConfig !== undefined && object.confidenceScoreIndexConfig !== null)
        ? DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig.fromPartial(object.confidenceScoreIndexConfig)
        : undefined;
    return message;
  },
};

function createBaseDataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig(): DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig {
  return { fieldPath: "", threshold: 0 };
}

export const DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig: MessageFns<
  DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig
> = {
  encode(
    message: DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.fieldPath !== "") {
      writer.uint32(10).string(message.fieldPath);
    }
    if (message.threshold !== 0) {
      writer.uint32(21).float(message.threshold);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldPath = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.threshold = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig {
    return {
      fieldPath: isSet(object.fieldPath) ? globalThis.String(object.fieldPath) : "",
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
    };
  },

  toJSON(message: DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig): unknown {
    const obj: any = {};
    if (message.fieldPath !== "") {
      obj.fieldPath = message.fieldPath;
    }
    if (message.threshold !== 0) {
      obj.threshold = message.threshold;
    }
    return obj;
  },

  create(
    base?: DeepPartial<DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig>,
  ): DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig {
    return DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig>,
  ): DataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig {
    const message = createBaseDataSchemaDetails_SearchStrategy_ConfidenceScoreIndexConfig();
    message.fieldPath = object.fieldPath ?? "";
    message.threshold = object.threshold ?? 0;
    return message;
  },
};

function createBaseUpdateDataSchemaRequest(): UpdateDataSchemaRequest {
  return { dataSchema: undefined, updateMask: undefined };
}

export const UpdateDataSchemaRequest: MessageFns<UpdateDataSchemaRequest> = {
  encode(message: UpdateDataSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataSchema !== undefined) {
      DataSchema.encode(message.dataSchema, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDataSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDataSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSchema = DataSchema.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDataSchemaRequest {
    return {
      dataSchema: isSet(object.dataSchema) ? DataSchema.fromJSON(object.dataSchema) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateDataSchemaRequest): unknown {
    const obj: any = {};
    if (message.dataSchema !== undefined) {
      obj.dataSchema = DataSchema.toJSON(message.dataSchema);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDataSchemaRequest>): UpdateDataSchemaRequest {
    return UpdateDataSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDataSchemaRequest>): UpdateDataSchemaRequest {
    const message = createBaseUpdateDataSchemaRequest();
    message.dataSchema = (object.dataSchema !== undefined && object.dataSchema !== null)
      ? DataSchema.fromPartial(object.dataSchema)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetDataSchemaRequest(): GetDataSchemaRequest {
  return { name: "" };
}

export const GetDataSchemaRequest: MessageFns<GetDataSchemaRequest> = {
  encode(message: GetDataSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDataSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDataSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDataSchemaRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDataSchemaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDataSchemaRequest>): GetDataSchemaRequest {
    return GetDataSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDataSchemaRequest>): GetDataSchemaRequest {
    const message = createBaseGetDataSchemaRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteDataSchemaRequest(): DeleteDataSchemaRequest {
  return { name: "" };
}

export const DeleteDataSchemaRequest: MessageFns<DeleteDataSchemaRequest> = {
  encode(message: DeleteDataSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDataSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDataSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDataSchemaRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteDataSchemaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDataSchemaRequest>): DeleteDataSchemaRequest {
    return DeleteDataSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDataSchemaRequest>): DeleteDataSchemaRequest {
    const message = createBaseDeleteDataSchemaRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListDataSchemasRequest(): ListDataSchemasRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListDataSchemasRequest: MessageFns<ListDataSchemasRequest> = {
  encode(message: ListDataSchemasRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDataSchemasRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDataSchemasRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDataSchemasRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListDataSchemasRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDataSchemasRequest>): ListDataSchemasRequest {
    return ListDataSchemasRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDataSchemasRequest>): ListDataSchemasRequest {
    const message = createBaseListDataSchemasRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListDataSchemasResponse(): ListDataSchemasResponse {
  return { dataSchemas: [], nextPageToken: "" };
}

export const ListDataSchemasResponse: MessageFns<ListDataSchemasResponse> = {
  encode(message: ListDataSchemasResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dataSchemas) {
      DataSchema.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDataSchemasResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDataSchemasResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSchemas.push(DataSchema.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDataSchemasResponse {
    return {
      dataSchemas: globalThis.Array.isArray(object?.dataSchemas)
        ? object.dataSchemas.map((e: any) => DataSchema.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDataSchemasResponse): unknown {
    const obj: any = {};
    if (message.dataSchemas?.length) {
      obj.dataSchemas = message.dataSchemas.map((e) => DataSchema.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDataSchemasResponse>): ListDataSchemasResponse {
    return ListDataSchemasResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDataSchemasResponse>): ListDataSchemasResponse {
    const message = createBaseListDataSchemasResponse();
    message.dataSchemas = object.dataSchemas?.map((e) => DataSchema.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateAnnotationRequest(): CreateAnnotationRequest {
  return { parent: "", annotation: undefined, annotationId: undefined };
}

export const CreateAnnotationRequest: MessageFns<CreateAnnotationRequest> = {
  encode(message: CreateAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.annotation !== undefined) {
      Annotation.encode(message.annotation, writer.uint32(18).fork()).join();
    }
    if (message.annotationId !== undefined) {
      writer.uint32(26).string(message.annotationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotation = Annotation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.annotationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAnnotationRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      annotation: isSet(object.annotation) ? Annotation.fromJSON(object.annotation) : undefined,
      annotationId: isSet(object.annotationId) ? globalThis.String(object.annotationId) : undefined,
    };
  },

  toJSON(message: CreateAnnotationRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.annotation !== undefined) {
      obj.annotation = Annotation.toJSON(message.annotation);
    }
    if (message.annotationId !== undefined) {
      obj.annotationId = message.annotationId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAnnotationRequest>): CreateAnnotationRequest {
    return CreateAnnotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAnnotationRequest>): CreateAnnotationRequest {
    const message = createBaseCreateAnnotationRequest();
    message.parent = object.parent ?? "";
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Annotation.fromPartial(object.annotation)
      : undefined;
    message.annotationId = object.annotationId ?? undefined;
    return message;
  },
};

function createBaseAnnotation(): Annotation {
  return { name: "", userSpecifiedAnnotation: undefined };
}

export const Annotation: MessageFns<Annotation> = {
  encode(message: Annotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.userSpecifiedAnnotation !== undefined) {
      UserSpecifiedAnnotation.encode(message.userSpecifiedAnnotation, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Annotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userSpecifiedAnnotation = UserSpecifiedAnnotation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Annotation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      userSpecifiedAnnotation: isSet(object.userSpecifiedAnnotation)
        ? UserSpecifiedAnnotation.fromJSON(object.userSpecifiedAnnotation)
        : undefined,
    };
  },

  toJSON(message: Annotation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.userSpecifiedAnnotation !== undefined) {
      obj.userSpecifiedAnnotation = UserSpecifiedAnnotation.toJSON(message.userSpecifiedAnnotation);
    }
    return obj;
  },

  create(base?: DeepPartial<Annotation>): Annotation {
    return Annotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Annotation>): Annotation {
    const message = createBaseAnnotation();
    message.name = object.name ?? "";
    message.userSpecifiedAnnotation =
      (object.userSpecifiedAnnotation !== undefined && object.userSpecifiedAnnotation !== null)
        ? UserSpecifiedAnnotation.fromPartial(object.userSpecifiedAnnotation)
        : undefined;
    return message;
  },
};

function createBaseUserSpecifiedAnnotation(): UserSpecifiedAnnotation {
  return { key: "", value: undefined, partition: undefined };
}

export const UserSpecifiedAnnotation: MessageFns<UserSpecifiedAnnotation> = {
  encode(message: UserSpecifiedAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AnnotationValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    if (message.partition !== undefined) {
      Partition.encode(message.partition, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSpecifiedAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSpecifiedAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AnnotationValue.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.partition = Partition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSpecifiedAnnotation {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AnnotationValue.fromJSON(object.value) : undefined,
      partition: isSet(object.partition) ? Partition.fromJSON(object.partition) : undefined,
    };
  },

  toJSON(message: UserSpecifiedAnnotation): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AnnotationValue.toJSON(message.value);
    }
    if (message.partition !== undefined) {
      obj.partition = Partition.toJSON(message.partition);
    }
    return obj;
  },

  create(base?: DeepPartial<UserSpecifiedAnnotation>): UserSpecifiedAnnotation {
    return UserSpecifiedAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSpecifiedAnnotation>): UserSpecifiedAnnotation {
    const message = createBaseUserSpecifiedAnnotation();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AnnotationValue.fromPartial(object.value)
      : undefined;
    message.partition = (object.partition !== undefined && object.partition !== null)
      ? Partition.fromPartial(object.partition)
      : undefined;
    return message;
  },
};

function createBaseGeoCoordinate(): GeoCoordinate {
  return { latitude: 0, longitude: 0 };
}

export const GeoCoordinate: MessageFns<GeoCoordinate> = {
  encode(message: GeoCoordinate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latitude !== 0) {
      writer.uint32(9).double(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(17).double(message.longitude);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoCoordinate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoCoordinate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.latitude = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.longitude = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoCoordinate {
    return {
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
    };
  },

  toJSON(message: GeoCoordinate): unknown {
    const obj: any = {};
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    return obj;
  },

  create(base?: DeepPartial<GeoCoordinate>): GeoCoordinate {
    return GeoCoordinate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeoCoordinate>): GeoCoordinate {
    const message = createBaseGeoCoordinate();
    message.latitude = object.latitude ?? 0;
    message.longitude = object.longitude ?? 0;
    return message;
  },
};

function createBaseAnnotationValue(): AnnotationValue {
  return {
    intValue: undefined,
    floatValue: undefined,
    strValue: undefined,
    datetimeValue: undefined,
    geoCoordinate: undefined,
    protoAnyValue: undefined,
    boolValue: undefined,
    customizedStructDataValue: undefined,
    listValue: undefined,
    customizedStructValue: undefined,
  };
}

export const AnnotationValue: MessageFns<AnnotationValue> = {
  encode(message: AnnotationValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intValue !== undefined) {
      writer.uint32(8).int64(message.intValue.toString());
    }
    if (message.floatValue !== undefined) {
      writer.uint32(21).float(message.floatValue);
    }
    if (message.strValue !== undefined) {
      writer.uint32(26).string(message.strValue);
    }
    if (message.datetimeValue !== undefined) {
      writer.uint32(42).string(message.datetimeValue);
    }
    if (message.geoCoordinate !== undefined) {
      GeoCoordinate.encode(message.geoCoordinate, writer.uint32(58).fork()).join();
    }
    if (message.protoAnyValue !== undefined) {
      Any.encode(message.protoAnyValue, writer.uint32(66).fork()).join();
    }
    if (message.boolValue !== undefined) {
      writer.uint32(72).bool(message.boolValue);
    }
    if (message.customizedStructDataValue !== undefined) {
      Struct.encode(Struct.wrap(message.customizedStructDataValue), writer.uint32(82).fork()).join();
    }
    if (message.listValue !== undefined) {
      AnnotationList.encode(message.listValue, writer.uint32(90).fork()).join();
    }
    if (message.customizedStructValue !== undefined) {
      AnnotationCustomizedStruct.encode(message.customizedStructValue, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.intValue = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.floatValue = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.strValue = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.datetimeValue = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.geoCoordinate = GeoCoordinate.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.protoAnyValue = Any.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.customizedStructDataValue = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.listValue = AnnotationList.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.customizedStructValue = AnnotationCustomizedStruct.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationValue {
    return {
      intValue: isSet(object.intValue) ? Long.fromValue(object.intValue) : undefined,
      floatValue: isSet(object.floatValue) ? globalThis.Number(object.floatValue) : undefined,
      strValue: isSet(object.strValue) ? globalThis.String(object.strValue) : undefined,
      datetimeValue: isSet(object.datetimeValue) ? globalThis.String(object.datetimeValue) : undefined,
      geoCoordinate: isSet(object.geoCoordinate) ? GeoCoordinate.fromJSON(object.geoCoordinate) : undefined,
      protoAnyValue: isSet(object.protoAnyValue) ? Any.fromJSON(object.protoAnyValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      customizedStructDataValue: isObject(object.customizedStructDataValue)
        ? object.customizedStructDataValue
        : undefined,
      listValue: isSet(object.listValue) ? AnnotationList.fromJSON(object.listValue) : undefined,
      customizedStructValue: isSet(object.customizedStructValue)
        ? AnnotationCustomizedStruct.fromJSON(object.customizedStructValue)
        : undefined,
    };
  },

  toJSON(message: AnnotationValue): unknown {
    const obj: any = {};
    if (message.intValue !== undefined) {
      obj.intValue = (message.intValue || Long.ZERO).toString();
    }
    if (message.floatValue !== undefined) {
      obj.floatValue = message.floatValue;
    }
    if (message.strValue !== undefined) {
      obj.strValue = message.strValue;
    }
    if (message.datetimeValue !== undefined) {
      obj.datetimeValue = message.datetimeValue;
    }
    if (message.geoCoordinate !== undefined) {
      obj.geoCoordinate = GeoCoordinate.toJSON(message.geoCoordinate);
    }
    if (message.protoAnyValue !== undefined) {
      obj.protoAnyValue = Any.toJSON(message.protoAnyValue);
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.customizedStructDataValue !== undefined) {
      obj.customizedStructDataValue = message.customizedStructDataValue;
    }
    if (message.listValue !== undefined) {
      obj.listValue = AnnotationList.toJSON(message.listValue);
    }
    if (message.customizedStructValue !== undefined) {
      obj.customizedStructValue = AnnotationCustomizedStruct.toJSON(message.customizedStructValue);
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotationValue>): AnnotationValue {
    return AnnotationValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotationValue>): AnnotationValue {
    const message = createBaseAnnotationValue();
    message.intValue = (object.intValue !== undefined && object.intValue !== null)
      ? Long.fromValue(object.intValue)
      : undefined;
    message.floatValue = object.floatValue ?? undefined;
    message.strValue = object.strValue ?? undefined;
    message.datetimeValue = object.datetimeValue ?? undefined;
    message.geoCoordinate = (object.geoCoordinate !== undefined && object.geoCoordinate !== null)
      ? GeoCoordinate.fromPartial(object.geoCoordinate)
      : undefined;
    message.protoAnyValue = (object.protoAnyValue !== undefined && object.protoAnyValue !== null)
      ? Any.fromPartial(object.protoAnyValue)
      : undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.customizedStructDataValue = object.customizedStructDataValue ?? undefined;
    message.listValue = (object.listValue !== undefined && object.listValue !== null)
      ? AnnotationList.fromPartial(object.listValue)
      : undefined;
    message.customizedStructValue =
      (object.customizedStructValue !== undefined && object.customizedStructValue !== null)
        ? AnnotationCustomizedStruct.fromPartial(object.customizedStructValue)
        : undefined;
    return message;
  },
};

function createBaseAnnotationList(): AnnotationList {
  return { values: [] };
}

export const AnnotationList: MessageFns<AnnotationList> = {
  encode(message: AnnotationList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      AnnotationValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(AnnotationValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationList {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => AnnotationValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AnnotationList): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => AnnotationValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotationList>): AnnotationList {
    return AnnotationList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotationList>): AnnotationList {
    const message = createBaseAnnotationList();
    message.values = object.values?.map((e) => AnnotationValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAnnotationCustomizedStruct(): AnnotationCustomizedStruct {
  return { elements: {} };
}

export const AnnotationCustomizedStruct: MessageFns<AnnotationCustomizedStruct> = {
  encode(message: AnnotationCustomizedStruct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.elements).forEach(([key, value]) => {
      AnnotationCustomizedStruct_ElementsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationCustomizedStruct {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationCustomizedStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = AnnotationCustomizedStruct_ElementsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.elements[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationCustomizedStruct {
    return {
      elements: isObject(object.elements)
        ? Object.entries(object.elements).reduce<{ [key: string]: AnnotationValue }>((acc, [key, value]) => {
          acc[key] = AnnotationValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AnnotationCustomizedStruct): unknown {
    const obj: any = {};
    if (message.elements) {
      const entries = Object.entries(message.elements);
      if (entries.length > 0) {
        obj.elements = {};
        entries.forEach(([k, v]) => {
          obj.elements[k] = AnnotationValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotationCustomizedStruct>): AnnotationCustomizedStruct {
    return AnnotationCustomizedStruct.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotationCustomizedStruct>): AnnotationCustomizedStruct {
    const message = createBaseAnnotationCustomizedStruct();
    message.elements = Object.entries(object.elements ?? {}).reduce<{ [key: string]: AnnotationValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AnnotationValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAnnotationCustomizedStruct_ElementsEntry(): AnnotationCustomizedStruct_ElementsEntry {
  return { key: "", value: undefined };
}

export const AnnotationCustomizedStruct_ElementsEntry: MessageFns<AnnotationCustomizedStruct_ElementsEntry> = {
  encode(message: AnnotationCustomizedStruct_ElementsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AnnotationValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationCustomizedStruct_ElementsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationCustomizedStruct_ElementsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AnnotationValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationCustomizedStruct_ElementsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AnnotationValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AnnotationCustomizedStruct_ElementsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AnnotationValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotationCustomizedStruct_ElementsEntry>): AnnotationCustomizedStruct_ElementsEntry {
    return AnnotationCustomizedStruct_ElementsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotationCustomizedStruct_ElementsEntry>): AnnotationCustomizedStruct_ElementsEntry {
    const message = createBaseAnnotationCustomizedStruct_ElementsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AnnotationValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseListAnnotationsRequest(): ListAnnotationsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListAnnotationsRequest: MessageFns<ListAnnotationsRequest> = {
  encode(message: ListAnnotationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAnnotationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAnnotationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAnnotationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListAnnotationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAnnotationsRequest>): ListAnnotationsRequest {
    return ListAnnotationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAnnotationsRequest>): ListAnnotationsRequest {
    const message = createBaseListAnnotationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListAnnotationsResponse(): ListAnnotationsResponse {
  return { annotations: [], nextPageToken: "" };
}

export const ListAnnotationsResponse: MessageFns<ListAnnotationsResponse> = {
  encode(message: ListAnnotationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAnnotationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAnnotationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAnnotationsResponse {
    return {
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAnnotationsResponse): unknown {
    const obj: any = {};
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => Annotation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAnnotationsResponse>): ListAnnotationsResponse {
    return ListAnnotationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAnnotationsResponse>): ListAnnotationsResponse {
    const message = createBaseListAnnotationsResponse();
    message.annotations = object.annotations?.map((e) => Annotation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetAnnotationRequest(): GetAnnotationRequest {
  return { name: "" };
}

export const GetAnnotationRequest: MessageFns<GetAnnotationRequest> = {
  encode(message: GetAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAnnotationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAnnotationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAnnotationRequest>): GetAnnotationRequest {
    return GetAnnotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAnnotationRequest>): GetAnnotationRequest {
    const message = createBaseGetAnnotationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateAnnotationRequest(): UpdateAnnotationRequest {
  return { annotation: undefined, updateMask: undefined };
}

export const UpdateAnnotationRequest: MessageFns<UpdateAnnotationRequest> = {
  encode(message: UpdateAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotation !== undefined) {
      Annotation.encode(message.annotation, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotation = Annotation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAnnotationRequest {
    return {
      annotation: isSet(object.annotation) ? Annotation.fromJSON(object.annotation) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateAnnotationRequest): unknown {
    const obj: any = {};
    if (message.annotation !== undefined) {
      obj.annotation = Annotation.toJSON(message.annotation);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAnnotationRequest>): UpdateAnnotationRequest {
    return UpdateAnnotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAnnotationRequest>): UpdateAnnotationRequest {
    const message = createBaseUpdateAnnotationRequest();
    message.annotation = (object.annotation !== undefined && object.annotation !== null)
      ? Annotation.fromPartial(object.annotation)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteAnnotationRequest(): DeleteAnnotationRequest {
  return { name: "" };
}

export const DeleteAnnotationRequest: MessageFns<DeleteAnnotationRequest> = {
  encode(message: DeleteAnnotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAnnotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAnnotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAnnotationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteAnnotationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAnnotationRequest>): DeleteAnnotationRequest {
    return DeleteAnnotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAnnotationRequest>): DeleteAnnotationRequest {
    const message = createBaseDeleteAnnotationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseImportAssetsRequest(): ImportAssetsRequest {
  return { assetsGcsUri: undefined, parent: "" };
}

export const ImportAssetsRequest: MessageFns<ImportAssetsRequest> = {
  encode(message: ImportAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetsGcsUri !== undefined) {
      writer.uint32(18).string(message.assetsGcsUri);
    }
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assetsGcsUri = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportAssetsRequest {
    return {
      assetsGcsUri: isSet(object.assetsGcsUri) ? globalThis.String(object.assetsGcsUri) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: ImportAssetsRequest): unknown {
    const obj: any = {};
    if (message.assetsGcsUri !== undefined) {
      obj.assetsGcsUri = message.assetsGcsUri;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<ImportAssetsRequest>): ImportAssetsRequest {
    return ImportAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportAssetsRequest>): ImportAssetsRequest {
    const message = createBaseImportAssetsRequest();
    message.assetsGcsUri = object.assetsGcsUri ?? undefined;
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseImportAssetsMetadata(): ImportAssetsMetadata {
  return { metadata: undefined, status: undefined };
}

export const ImportAssetsMetadata: MessageFns<ImportAssetsMetadata> = {
  encode(message: ImportAssetsMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      OperationMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.status !== undefined) {
      BatchOperationStatus.encode(message.status, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportAssetsMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportAssetsMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = OperationMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = BatchOperationStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportAssetsMetadata {
    return {
      metadata: isSet(object.metadata) ? OperationMetadata.fromJSON(object.metadata) : undefined,
      status: isSet(object.status) ? BatchOperationStatus.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: ImportAssetsMetadata): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = OperationMetadata.toJSON(message.metadata);
    }
    if (message.status !== undefined) {
      obj.status = BatchOperationStatus.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportAssetsMetadata>): ImportAssetsMetadata {
    return ImportAssetsMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportAssetsMetadata>): ImportAssetsMetadata {
    const message = createBaseImportAssetsMetadata();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? OperationMetadata.fromPartial(object.metadata)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? BatchOperationStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseBatchOperationStatus(): BatchOperationStatus {
  return { successCount: 0, failureCount: 0 };
}

export const BatchOperationStatus: MessageFns<BatchOperationStatus> = {
  encode(message: BatchOperationStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.successCount !== 0) {
      writer.uint32(8).int32(message.successCount);
    }
    if (message.failureCount !== 0) {
      writer.uint32(16).int32(message.failureCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchOperationStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchOperationStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.failureCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchOperationStatus {
    return {
      successCount: isSet(object.successCount) ? globalThis.Number(object.successCount) : 0,
      failureCount: isSet(object.failureCount) ? globalThis.Number(object.failureCount) : 0,
    };
  },

  toJSON(message: BatchOperationStatus): unknown {
    const obj: any = {};
    if (message.successCount !== 0) {
      obj.successCount = Math.round(message.successCount);
    }
    if (message.failureCount !== 0) {
      obj.failureCount = Math.round(message.failureCount);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchOperationStatus>): BatchOperationStatus {
    return BatchOperationStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchOperationStatus>): BatchOperationStatus {
    const message = createBaseBatchOperationStatus();
    message.successCount = object.successCount ?? 0;
    message.failureCount = object.failureCount ?? 0;
    return message;
  },
};

function createBaseImportAssetsResponse(): ImportAssetsResponse {
  return {};
}

export const ImportAssetsResponse: MessageFns<ImportAssetsResponse> = {
  encode(_: ImportAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ImportAssetsResponse {
    return {};
  },

  toJSON(_: ImportAssetsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ImportAssetsResponse>): ImportAssetsResponse {
    return ImportAssetsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ImportAssetsResponse>): ImportAssetsResponse {
    const message = createBaseImportAssetsResponse();
    return message;
  },
};

function createBaseCreateSearchConfigRequest(): CreateSearchConfigRequest {
  return { parent: "", searchConfig: undefined, searchConfigId: "" };
}

export const CreateSearchConfigRequest: MessageFns<CreateSearchConfigRequest> = {
  encode(message: CreateSearchConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.searchConfig !== undefined) {
      SearchConfig.encode(message.searchConfig, writer.uint32(18).fork()).join();
    }
    if (message.searchConfigId !== "") {
      writer.uint32(26).string(message.searchConfigId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSearchConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSearchConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.searchConfig = SearchConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.searchConfigId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSearchConfigRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      searchConfig: isSet(object.searchConfig) ? SearchConfig.fromJSON(object.searchConfig) : undefined,
      searchConfigId: isSet(object.searchConfigId) ? globalThis.String(object.searchConfigId) : "",
    };
  },

  toJSON(message: CreateSearchConfigRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.searchConfig !== undefined) {
      obj.searchConfig = SearchConfig.toJSON(message.searchConfig);
    }
    if (message.searchConfigId !== "") {
      obj.searchConfigId = message.searchConfigId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSearchConfigRequest>): CreateSearchConfigRequest {
    return CreateSearchConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSearchConfigRequest>): CreateSearchConfigRequest {
    const message = createBaseCreateSearchConfigRequest();
    message.parent = object.parent ?? "";
    message.searchConfig = (object.searchConfig !== undefined && object.searchConfig !== null)
      ? SearchConfig.fromPartial(object.searchConfig)
      : undefined;
    message.searchConfigId = object.searchConfigId ?? "";
    return message;
  },
};

function createBaseUpdateSearchConfigRequest(): UpdateSearchConfigRequest {
  return { searchConfig: undefined, updateMask: undefined };
}

export const UpdateSearchConfigRequest: MessageFns<UpdateSearchConfigRequest> = {
  encode(message: UpdateSearchConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchConfig !== undefined) {
      SearchConfig.encode(message.searchConfig, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSearchConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSearchConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchConfig = SearchConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSearchConfigRequest {
    return {
      searchConfig: isSet(object.searchConfig) ? SearchConfig.fromJSON(object.searchConfig) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateSearchConfigRequest): unknown {
    const obj: any = {};
    if (message.searchConfig !== undefined) {
      obj.searchConfig = SearchConfig.toJSON(message.searchConfig);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSearchConfigRequest>): UpdateSearchConfigRequest {
    return UpdateSearchConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSearchConfigRequest>): UpdateSearchConfigRequest {
    const message = createBaseUpdateSearchConfigRequest();
    message.searchConfig = (object.searchConfig !== undefined && object.searchConfig !== null)
      ? SearchConfig.fromPartial(object.searchConfig)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetSearchConfigRequest(): GetSearchConfigRequest {
  return { name: "" };
}

export const GetSearchConfigRequest: MessageFns<GetSearchConfigRequest> = {
  encode(message: GetSearchConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSearchConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSearchConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSearchConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSearchConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSearchConfigRequest>): GetSearchConfigRequest {
    return GetSearchConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSearchConfigRequest>): GetSearchConfigRequest {
    const message = createBaseGetSearchConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteSearchConfigRequest(): DeleteSearchConfigRequest {
  return { name: "" };
}

export const DeleteSearchConfigRequest: MessageFns<DeleteSearchConfigRequest> = {
  encode(message: DeleteSearchConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSearchConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSearchConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSearchConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteSearchConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSearchConfigRequest>): DeleteSearchConfigRequest {
    return DeleteSearchConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSearchConfigRequest>): DeleteSearchConfigRequest {
    const message = createBaseDeleteSearchConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListSearchConfigsRequest(): ListSearchConfigsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListSearchConfigsRequest: MessageFns<ListSearchConfigsRequest> = {
  encode(message: ListSearchConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSearchConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSearchConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSearchConfigsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSearchConfigsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSearchConfigsRequest>): ListSearchConfigsRequest {
    return ListSearchConfigsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSearchConfigsRequest>): ListSearchConfigsRequest {
    const message = createBaseListSearchConfigsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSearchConfigsResponse(): ListSearchConfigsResponse {
  return { searchConfigs: [], nextPageToken: "" };
}

export const ListSearchConfigsResponse: MessageFns<ListSearchConfigsResponse> = {
  encode(message: ListSearchConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.searchConfigs) {
      SearchConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSearchConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSearchConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchConfigs.push(SearchConfig.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSearchConfigsResponse {
    return {
      searchConfigs: globalThis.Array.isArray(object?.searchConfigs)
        ? object.searchConfigs.map((e: any) => SearchConfig.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSearchConfigsResponse): unknown {
    const obj: any = {};
    if (message.searchConfigs?.length) {
      obj.searchConfigs = message.searchConfigs.map((e) => SearchConfig.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSearchConfigsResponse>): ListSearchConfigsResponse {
    return ListSearchConfigsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSearchConfigsResponse>): ListSearchConfigsResponse {
    const message = createBaseListSearchConfigsResponse();
    message.searchConfigs = object.searchConfigs?.map((e) => SearchConfig.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSearchConfig(): SearchConfig {
  return { name: "", facetProperty: undefined, searchCriteriaProperty: undefined };
}

export const SearchConfig: MessageFns<SearchConfig> = {
  encode(message: SearchConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.facetProperty !== undefined) {
      FacetProperty.encode(message.facetProperty, writer.uint32(18).fork()).join();
    }
    if (message.searchCriteriaProperty !== undefined) {
      SearchCriteriaProperty.encode(message.searchCriteriaProperty, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.facetProperty = FacetProperty.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.searchCriteriaProperty = SearchCriteriaProperty.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      facetProperty: isSet(object.facetProperty) ? FacetProperty.fromJSON(object.facetProperty) : undefined,
      searchCriteriaProperty: isSet(object.searchCriteriaProperty)
        ? SearchCriteriaProperty.fromJSON(object.searchCriteriaProperty)
        : undefined,
    };
  },

  toJSON(message: SearchConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.facetProperty !== undefined) {
      obj.facetProperty = FacetProperty.toJSON(message.facetProperty);
    }
    if (message.searchCriteriaProperty !== undefined) {
      obj.searchCriteriaProperty = SearchCriteriaProperty.toJSON(message.searchCriteriaProperty);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchConfig>): SearchConfig {
    return SearchConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchConfig>): SearchConfig {
    const message = createBaseSearchConfig();
    message.name = object.name ?? "";
    message.facetProperty = (object.facetProperty !== undefined && object.facetProperty !== null)
      ? FacetProperty.fromPartial(object.facetProperty)
      : undefined;
    message.searchCriteriaProperty =
      (object.searchCriteriaProperty !== undefined && object.searchCriteriaProperty !== null)
        ? SearchCriteriaProperty.fromPartial(object.searchCriteriaProperty)
        : undefined;
    return message;
  },
};

function createBaseIndexEndpoint(): IndexEndpoint {
  return {
    name: "",
    displayName: "",
    description: "",
    deployedIndex: undefined,
    state: 0,
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    satisfiesPzs: undefined,
    satisfiesPzi: undefined,
  };
}

export const IndexEndpoint: MessageFns<IndexEndpoint> = {
  encode(message: IndexEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.deployedIndex !== undefined) {
      DeployedIndex.encode(message.deployedIndex, writer.uint32(74).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      IndexEndpoint_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    if (message.satisfiesPzs !== undefined) {
      writer.uint32(80).bool(message.satisfiesPzs);
    }
    if (message.satisfiesPzi !== undefined) {
      writer.uint32(88).bool(message.satisfiesPzi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.deployedIndex = DeployedIndex.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = IndexEndpoint_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.satisfiesPzs = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexEndpoint {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      deployedIndex: isSet(object.deployedIndex) ? DeployedIndex.fromJSON(object.deployedIndex) : undefined,
      state: isSet(object.state) ? indexEndpoint_StateFromJSON(object.state) : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      satisfiesPzs: isSet(object.satisfiesPzs) ? globalThis.Boolean(object.satisfiesPzs) : undefined,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : undefined,
    };
  },

  toJSON(message: IndexEndpoint): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.deployedIndex !== undefined) {
      obj.deployedIndex = DeployedIndex.toJSON(message.deployedIndex);
    }
    if (message.state !== 0) {
      obj.state = indexEndpoint_StateToJSON(message.state);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.satisfiesPzs !== undefined) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== undefined) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    return obj;
  },

  create(base?: DeepPartial<IndexEndpoint>): IndexEndpoint {
    return IndexEndpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexEndpoint>): IndexEndpoint {
    const message = createBaseIndexEndpoint();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.deployedIndex = (object.deployedIndex !== undefined && object.deployedIndex !== null)
      ? DeployedIndex.fromPartial(object.deployedIndex)
      : undefined;
    message.state = object.state ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.satisfiesPzs = object.satisfiesPzs ?? undefined;
    message.satisfiesPzi = object.satisfiesPzi ?? undefined;
    return message;
  },
};

function createBaseIndexEndpoint_LabelsEntry(): IndexEndpoint_LabelsEntry {
  return { key: "", value: "" };
}

export const IndexEndpoint_LabelsEntry: MessageFns<IndexEndpoint_LabelsEntry> = {
  encode(message: IndexEndpoint_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexEndpoint_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexEndpoint_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexEndpoint_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: IndexEndpoint_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<IndexEndpoint_LabelsEntry>): IndexEndpoint_LabelsEntry {
    return IndexEndpoint_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexEndpoint_LabelsEntry>): IndexEndpoint_LabelsEntry {
    const message = createBaseIndexEndpoint_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateIndexEndpointRequest(): CreateIndexEndpointRequest {
  return { parent: "", indexEndpointId: "", indexEndpoint: undefined };
}

export const CreateIndexEndpointRequest: MessageFns<CreateIndexEndpointRequest> = {
  encode(message: CreateIndexEndpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.indexEndpointId !== "") {
      writer.uint32(18).string(message.indexEndpointId);
    }
    if (message.indexEndpoint !== undefined) {
      IndexEndpoint.encode(message.indexEndpoint, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateIndexEndpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIndexEndpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.indexEndpointId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.indexEndpoint = IndexEndpoint.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIndexEndpointRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      indexEndpointId: isSet(object.indexEndpointId) ? globalThis.String(object.indexEndpointId) : "",
      indexEndpoint: isSet(object.indexEndpoint) ? IndexEndpoint.fromJSON(object.indexEndpoint) : undefined,
    };
  },

  toJSON(message: CreateIndexEndpointRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.indexEndpointId !== "") {
      obj.indexEndpointId = message.indexEndpointId;
    }
    if (message.indexEndpoint !== undefined) {
      obj.indexEndpoint = IndexEndpoint.toJSON(message.indexEndpoint);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateIndexEndpointRequest>): CreateIndexEndpointRequest {
    return CreateIndexEndpointRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateIndexEndpointRequest>): CreateIndexEndpointRequest {
    const message = createBaseCreateIndexEndpointRequest();
    message.parent = object.parent ?? "";
    message.indexEndpointId = object.indexEndpointId ?? "";
    message.indexEndpoint = (object.indexEndpoint !== undefined && object.indexEndpoint !== null)
      ? IndexEndpoint.fromPartial(object.indexEndpoint)
      : undefined;
    return message;
  },
};

function createBaseCreateIndexEndpointMetadata(): CreateIndexEndpointMetadata {
  return { operationMetadata: undefined };
}

export const CreateIndexEndpointMetadata: MessageFns<CreateIndexEndpointMetadata> = {
  encode(message: CreateIndexEndpointMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationMetadata !== undefined) {
      OperationMetadata.encode(message.operationMetadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateIndexEndpointMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIndexEndpointMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operationMetadata = OperationMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIndexEndpointMetadata {
    return {
      operationMetadata: isSet(object.operationMetadata)
        ? OperationMetadata.fromJSON(object.operationMetadata)
        : undefined,
    };
  },

  toJSON(message: CreateIndexEndpointMetadata): unknown {
    const obj: any = {};
    if (message.operationMetadata !== undefined) {
      obj.operationMetadata = OperationMetadata.toJSON(message.operationMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateIndexEndpointMetadata>): CreateIndexEndpointMetadata {
    return CreateIndexEndpointMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateIndexEndpointMetadata>): CreateIndexEndpointMetadata {
    const message = createBaseCreateIndexEndpointMetadata();
    message.operationMetadata = (object.operationMetadata !== undefined && object.operationMetadata !== null)
      ? OperationMetadata.fromPartial(object.operationMetadata)
      : undefined;
    return message;
  },
};

function createBaseGetIndexEndpointRequest(): GetIndexEndpointRequest {
  return { name: "" };
}

export const GetIndexEndpointRequest: MessageFns<GetIndexEndpointRequest> = {
  encode(message: GetIndexEndpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIndexEndpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIndexEndpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIndexEndpointRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetIndexEndpointRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetIndexEndpointRequest>): GetIndexEndpointRequest {
    return GetIndexEndpointRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetIndexEndpointRequest>): GetIndexEndpointRequest {
    const message = createBaseGetIndexEndpointRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListIndexEndpointsRequest(): ListIndexEndpointsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListIndexEndpointsRequest: MessageFns<ListIndexEndpointsRequest> = {
  encode(message: ListIndexEndpointsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIndexEndpointsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIndexEndpointsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIndexEndpointsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListIndexEndpointsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIndexEndpointsRequest>): ListIndexEndpointsRequest {
    return ListIndexEndpointsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIndexEndpointsRequest>): ListIndexEndpointsRequest {
    const message = createBaseListIndexEndpointsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListIndexEndpointsResponse(): ListIndexEndpointsResponse {
  return { indexEndpoints: [], nextPageToken: "" };
}

export const ListIndexEndpointsResponse: MessageFns<ListIndexEndpointsResponse> = {
  encode(message: ListIndexEndpointsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.indexEndpoints) {
      IndexEndpoint.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIndexEndpointsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIndexEndpointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.indexEndpoints.push(IndexEndpoint.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIndexEndpointsResponse {
    return {
      indexEndpoints: globalThis.Array.isArray(object?.indexEndpoints)
        ? object.indexEndpoints.map((e: any) => IndexEndpoint.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListIndexEndpointsResponse): unknown {
    const obj: any = {};
    if (message.indexEndpoints?.length) {
      obj.indexEndpoints = message.indexEndpoints.map((e) => IndexEndpoint.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIndexEndpointsResponse>): ListIndexEndpointsResponse {
    return ListIndexEndpointsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIndexEndpointsResponse>): ListIndexEndpointsResponse {
    const message = createBaseListIndexEndpointsResponse();
    message.indexEndpoints = object.indexEndpoints?.map((e) => IndexEndpoint.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateIndexEndpointRequest(): UpdateIndexEndpointRequest {
  return { indexEndpoint: undefined, updateMask: undefined };
}

export const UpdateIndexEndpointRequest: MessageFns<UpdateIndexEndpointRequest> = {
  encode(message: UpdateIndexEndpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexEndpoint !== undefined) {
      IndexEndpoint.encode(message.indexEndpoint, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateIndexEndpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateIndexEndpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.indexEndpoint = IndexEndpoint.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateIndexEndpointRequest {
    return {
      indexEndpoint: isSet(object.indexEndpoint) ? IndexEndpoint.fromJSON(object.indexEndpoint) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateIndexEndpointRequest): unknown {
    const obj: any = {};
    if (message.indexEndpoint !== undefined) {
      obj.indexEndpoint = IndexEndpoint.toJSON(message.indexEndpoint);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateIndexEndpointRequest>): UpdateIndexEndpointRequest {
    return UpdateIndexEndpointRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateIndexEndpointRequest>): UpdateIndexEndpointRequest {
    const message = createBaseUpdateIndexEndpointRequest();
    message.indexEndpoint = (object.indexEndpoint !== undefined && object.indexEndpoint !== null)
      ? IndexEndpoint.fromPartial(object.indexEndpoint)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUpdateIndexEndpointMetadata(): UpdateIndexEndpointMetadata {
  return { operationMetadata: undefined };
}

export const UpdateIndexEndpointMetadata: MessageFns<UpdateIndexEndpointMetadata> = {
  encode(message: UpdateIndexEndpointMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationMetadata !== undefined) {
      OperationMetadata.encode(message.operationMetadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateIndexEndpointMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateIndexEndpointMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operationMetadata = OperationMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateIndexEndpointMetadata {
    return {
      operationMetadata: isSet(object.operationMetadata)
        ? OperationMetadata.fromJSON(object.operationMetadata)
        : undefined,
    };
  },

  toJSON(message: UpdateIndexEndpointMetadata): unknown {
    const obj: any = {};
    if (message.operationMetadata !== undefined) {
      obj.operationMetadata = OperationMetadata.toJSON(message.operationMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateIndexEndpointMetadata>): UpdateIndexEndpointMetadata {
    return UpdateIndexEndpointMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateIndexEndpointMetadata>): UpdateIndexEndpointMetadata {
    const message = createBaseUpdateIndexEndpointMetadata();
    message.operationMetadata = (object.operationMetadata !== undefined && object.operationMetadata !== null)
      ? OperationMetadata.fromPartial(object.operationMetadata)
      : undefined;
    return message;
  },
};

function createBaseDeleteIndexEndpointRequest(): DeleteIndexEndpointRequest {
  return { name: "" };
}

export const DeleteIndexEndpointRequest: MessageFns<DeleteIndexEndpointRequest> = {
  encode(message: DeleteIndexEndpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteIndexEndpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIndexEndpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteIndexEndpointRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteIndexEndpointRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteIndexEndpointRequest>): DeleteIndexEndpointRequest {
    return DeleteIndexEndpointRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteIndexEndpointRequest>): DeleteIndexEndpointRequest {
    const message = createBaseDeleteIndexEndpointRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteIndexEndpointMetadata(): DeleteIndexEndpointMetadata {
  return { operationMetadata: undefined };
}

export const DeleteIndexEndpointMetadata: MessageFns<DeleteIndexEndpointMetadata> = {
  encode(message: DeleteIndexEndpointMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationMetadata !== undefined) {
      OperationMetadata.encode(message.operationMetadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteIndexEndpointMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIndexEndpointMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operationMetadata = OperationMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteIndexEndpointMetadata {
    return {
      operationMetadata: isSet(object.operationMetadata)
        ? OperationMetadata.fromJSON(object.operationMetadata)
        : undefined,
    };
  },

  toJSON(message: DeleteIndexEndpointMetadata): unknown {
    const obj: any = {};
    if (message.operationMetadata !== undefined) {
      obj.operationMetadata = OperationMetadata.toJSON(message.operationMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteIndexEndpointMetadata>): DeleteIndexEndpointMetadata {
    return DeleteIndexEndpointMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteIndexEndpointMetadata>): DeleteIndexEndpointMetadata {
    const message = createBaseDeleteIndexEndpointMetadata();
    message.operationMetadata = (object.operationMetadata !== undefined && object.operationMetadata !== null)
      ? OperationMetadata.fromPartial(object.operationMetadata)
      : undefined;
    return message;
  },
};

function createBaseDeployIndexRequest(): DeployIndexRequest {
  return { indexEndpoint: "", deployedIndex: undefined };
}

export const DeployIndexRequest: MessageFns<DeployIndexRequest> = {
  encode(message: DeployIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexEndpoint !== "") {
      writer.uint32(10).string(message.indexEndpoint);
    }
    if (message.deployedIndex !== undefined) {
      DeployedIndex.encode(message.deployedIndex, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.indexEndpoint = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deployedIndex = DeployedIndex.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployIndexRequest {
    return {
      indexEndpoint: isSet(object.indexEndpoint) ? globalThis.String(object.indexEndpoint) : "",
      deployedIndex: isSet(object.deployedIndex) ? DeployedIndex.fromJSON(object.deployedIndex) : undefined,
    };
  },

  toJSON(message: DeployIndexRequest): unknown {
    const obj: any = {};
    if (message.indexEndpoint !== "") {
      obj.indexEndpoint = message.indexEndpoint;
    }
    if (message.deployedIndex !== undefined) {
      obj.deployedIndex = DeployedIndex.toJSON(message.deployedIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployIndexRequest>): DeployIndexRequest {
    return DeployIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployIndexRequest>): DeployIndexRequest {
    const message = createBaseDeployIndexRequest();
    message.indexEndpoint = object.indexEndpoint ?? "";
    message.deployedIndex = (object.deployedIndex !== undefined && object.deployedIndex !== null)
      ? DeployedIndex.fromPartial(object.deployedIndex)
      : undefined;
    return message;
  },
};

function createBaseDeployIndexResponse(): DeployIndexResponse {
  return {};
}

export const DeployIndexResponse: MessageFns<DeployIndexResponse> = {
  encode(_: DeployIndexResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployIndexResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployIndexResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeployIndexResponse {
    return {};
  },

  toJSON(_: DeployIndexResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DeployIndexResponse>): DeployIndexResponse {
    return DeployIndexResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeployIndexResponse>): DeployIndexResponse {
    const message = createBaseDeployIndexResponse();
    return message;
  },
};

function createBaseDeployIndexMetadata(): DeployIndexMetadata {
  return { operationMetadata: undefined, deployedIndex: "" };
}

export const DeployIndexMetadata: MessageFns<DeployIndexMetadata> = {
  encode(message: DeployIndexMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationMetadata !== undefined) {
      OperationMetadata.encode(message.operationMetadata, writer.uint32(10).fork()).join();
    }
    if (message.deployedIndex !== "") {
      writer.uint32(18).string(message.deployedIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployIndexMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployIndexMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operationMetadata = OperationMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deployedIndex = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployIndexMetadata {
    return {
      operationMetadata: isSet(object.operationMetadata)
        ? OperationMetadata.fromJSON(object.operationMetadata)
        : undefined,
      deployedIndex: isSet(object.deployedIndex) ? globalThis.String(object.deployedIndex) : "",
    };
  },

  toJSON(message: DeployIndexMetadata): unknown {
    const obj: any = {};
    if (message.operationMetadata !== undefined) {
      obj.operationMetadata = OperationMetadata.toJSON(message.operationMetadata);
    }
    if (message.deployedIndex !== "") {
      obj.deployedIndex = message.deployedIndex;
    }
    return obj;
  },

  create(base?: DeepPartial<DeployIndexMetadata>): DeployIndexMetadata {
    return DeployIndexMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployIndexMetadata>): DeployIndexMetadata {
    const message = createBaseDeployIndexMetadata();
    message.operationMetadata = (object.operationMetadata !== undefined && object.operationMetadata !== null)
      ? OperationMetadata.fromPartial(object.operationMetadata)
      : undefined;
    message.deployedIndex = object.deployedIndex ?? "";
    return message;
  },
};

function createBaseUndeployIndexMetadata(): UndeployIndexMetadata {
  return { operationMetadata: undefined, deployedIndex: "" };
}

export const UndeployIndexMetadata: MessageFns<UndeployIndexMetadata> = {
  encode(message: UndeployIndexMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationMetadata !== undefined) {
      OperationMetadata.encode(message.operationMetadata, writer.uint32(10).fork()).join();
    }
    if (message.deployedIndex !== "") {
      writer.uint32(18).string(message.deployedIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeployIndexMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeployIndexMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operationMetadata = OperationMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deployedIndex = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeployIndexMetadata {
    return {
      operationMetadata: isSet(object.operationMetadata)
        ? OperationMetadata.fromJSON(object.operationMetadata)
        : undefined,
      deployedIndex: isSet(object.deployedIndex) ? globalThis.String(object.deployedIndex) : "",
    };
  },

  toJSON(message: UndeployIndexMetadata): unknown {
    const obj: any = {};
    if (message.operationMetadata !== undefined) {
      obj.operationMetadata = OperationMetadata.toJSON(message.operationMetadata);
    }
    if (message.deployedIndex !== "") {
      obj.deployedIndex = message.deployedIndex;
    }
    return obj;
  },

  create(base?: DeepPartial<UndeployIndexMetadata>): UndeployIndexMetadata {
    return UndeployIndexMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndeployIndexMetadata>): UndeployIndexMetadata {
    const message = createBaseUndeployIndexMetadata();
    message.operationMetadata = (object.operationMetadata !== undefined && object.operationMetadata !== null)
      ? OperationMetadata.fromPartial(object.operationMetadata)
      : undefined;
    message.deployedIndex = object.deployedIndex ?? "";
    return message;
  },
};

function createBaseUndeployIndexRequest(): UndeployIndexRequest {
  return { indexEndpoint: "" };
}

export const UndeployIndexRequest: MessageFns<UndeployIndexRequest> = {
  encode(message: UndeployIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indexEndpoint !== "") {
      writer.uint32(10).string(message.indexEndpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeployIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeployIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.indexEndpoint = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeployIndexRequest {
    return { indexEndpoint: isSet(object.indexEndpoint) ? globalThis.String(object.indexEndpoint) : "" };
  },

  toJSON(message: UndeployIndexRequest): unknown {
    const obj: any = {};
    if (message.indexEndpoint !== "") {
      obj.indexEndpoint = message.indexEndpoint;
    }
    return obj;
  },

  create(base?: DeepPartial<UndeployIndexRequest>): UndeployIndexRequest {
    return UndeployIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndeployIndexRequest>): UndeployIndexRequest {
    const message = createBaseUndeployIndexRequest();
    message.indexEndpoint = object.indexEndpoint ?? "";
    return message;
  },
};

function createBaseUndeployIndexResponse(): UndeployIndexResponse {
  return {};
}

export const UndeployIndexResponse: MessageFns<UndeployIndexResponse> = {
  encode(_: UndeployIndexResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeployIndexResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeployIndexResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UndeployIndexResponse {
    return {};
  },

  toJSON(_: UndeployIndexResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UndeployIndexResponse>): UndeployIndexResponse {
    return UndeployIndexResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UndeployIndexResponse>): UndeployIndexResponse {
    const message = createBaseUndeployIndexResponse();
    return message;
  },
};

function createBaseDeployedIndex(): DeployedIndex {
  return { index: "" };
}

export const DeployedIndex: MessageFns<DeployedIndex> = {
  encode(message: DeployedIndex, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== "") {
      writer.uint32(10).string(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployedIndex {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployedIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.index = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployedIndex {
    return { index: isSet(object.index) ? globalThis.String(object.index) : "" };
  },

  toJSON(message: DeployedIndex): unknown {
    const obj: any = {};
    if (message.index !== "") {
      obj.index = message.index;
    }
    return obj;
  },

  create(base?: DeepPartial<DeployedIndex>): DeployedIndex {
    return DeployedIndex.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployedIndex>): DeployedIndex {
    const message = createBaseDeployedIndex();
    message.index = object.index ?? "";
    return message;
  },
};

function createBaseFacetProperty(): FacetProperty {
  return {
    fixedRangeBucketSpec: undefined,
    customRangeBucketSpec: undefined,
    datetimeBucketSpec: undefined,
    mappedFields: [],
    displayName: "",
    resultSize: Long.ZERO,
    bucketType: 0,
  };
}

export const FacetProperty: MessageFns<FacetProperty> = {
  encode(message: FacetProperty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fixedRangeBucketSpec !== undefined) {
      FacetProperty_FixedRangeBucketSpec.encode(message.fixedRangeBucketSpec, writer.uint32(42).fork()).join();
    }
    if (message.customRangeBucketSpec !== undefined) {
      FacetProperty_CustomRangeBucketSpec.encode(message.customRangeBucketSpec, writer.uint32(50).fork()).join();
    }
    if (message.datetimeBucketSpec !== undefined) {
      FacetProperty_DateTimeBucketSpec.encode(message.datetimeBucketSpec, writer.uint32(58).fork()).join();
    }
    for (const v of message.mappedFields) {
      writer.uint32(10).string(v!);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (!message.resultSize.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.resultSize.toString());
    }
    if (message.bucketType !== 0) {
      writer.uint32(32).int32(message.bucketType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetProperty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.fixedRangeBucketSpec = FacetProperty_FixedRangeBucketSpec.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.customRangeBucketSpec = FacetProperty_CustomRangeBucketSpec.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.datetimeBucketSpec = FacetProperty_DateTimeBucketSpec.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mappedFields.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.resultSize = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bucketType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetProperty {
    return {
      fixedRangeBucketSpec: isSet(object.fixedRangeBucketSpec)
        ? FacetProperty_FixedRangeBucketSpec.fromJSON(object.fixedRangeBucketSpec)
        : undefined,
      customRangeBucketSpec: isSet(object.customRangeBucketSpec)
        ? FacetProperty_CustomRangeBucketSpec.fromJSON(object.customRangeBucketSpec)
        : undefined,
      datetimeBucketSpec: isSet(object.datetimeBucketSpec)
        ? FacetProperty_DateTimeBucketSpec.fromJSON(object.datetimeBucketSpec)
        : undefined,
      mappedFields: globalThis.Array.isArray(object?.mappedFields)
        ? object.mappedFields.map((e: any) => globalThis.String(e))
        : [],
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      resultSize: isSet(object.resultSize) ? Long.fromValue(object.resultSize) : Long.ZERO,
      bucketType: isSet(object.bucketType) ? facetBucketTypeFromJSON(object.bucketType) : 0,
    };
  },

  toJSON(message: FacetProperty): unknown {
    const obj: any = {};
    if (message.fixedRangeBucketSpec !== undefined) {
      obj.fixedRangeBucketSpec = FacetProperty_FixedRangeBucketSpec.toJSON(message.fixedRangeBucketSpec);
    }
    if (message.customRangeBucketSpec !== undefined) {
      obj.customRangeBucketSpec = FacetProperty_CustomRangeBucketSpec.toJSON(message.customRangeBucketSpec);
    }
    if (message.datetimeBucketSpec !== undefined) {
      obj.datetimeBucketSpec = FacetProperty_DateTimeBucketSpec.toJSON(message.datetimeBucketSpec);
    }
    if (message.mappedFields?.length) {
      obj.mappedFields = message.mappedFields;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (!message.resultSize.equals(Long.ZERO)) {
      obj.resultSize = (message.resultSize || Long.ZERO).toString();
    }
    if (message.bucketType !== 0) {
      obj.bucketType = facetBucketTypeToJSON(message.bucketType);
    }
    return obj;
  },

  create(base?: DeepPartial<FacetProperty>): FacetProperty {
    return FacetProperty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetProperty>): FacetProperty {
    const message = createBaseFacetProperty();
    message.fixedRangeBucketSpec = (object.fixedRangeBucketSpec !== undefined && object.fixedRangeBucketSpec !== null)
      ? FacetProperty_FixedRangeBucketSpec.fromPartial(object.fixedRangeBucketSpec)
      : undefined;
    message.customRangeBucketSpec =
      (object.customRangeBucketSpec !== undefined && object.customRangeBucketSpec !== null)
        ? FacetProperty_CustomRangeBucketSpec.fromPartial(object.customRangeBucketSpec)
        : undefined;
    message.datetimeBucketSpec = (object.datetimeBucketSpec !== undefined && object.datetimeBucketSpec !== null)
      ? FacetProperty_DateTimeBucketSpec.fromPartial(object.datetimeBucketSpec)
      : undefined;
    message.mappedFields = object.mappedFields?.map((e) => e) || [];
    message.displayName = object.displayName ?? "";
    message.resultSize = (object.resultSize !== undefined && object.resultSize !== null)
      ? Long.fromValue(object.resultSize)
      : Long.ZERO;
    message.bucketType = object.bucketType ?? 0;
    return message;
  },
};

function createBaseFacetProperty_FixedRangeBucketSpec(): FacetProperty_FixedRangeBucketSpec {
  return { bucketStart: undefined, bucketGranularity: undefined, bucketCount: 0 };
}

export const FacetProperty_FixedRangeBucketSpec: MessageFns<FacetProperty_FixedRangeBucketSpec> = {
  encode(message: FacetProperty_FixedRangeBucketSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketStart !== undefined) {
      FacetValue.encode(message.bucketStart, writer.uint32(10).fork()).join();
    }
    if (message.bucketGranularity !== undefined) {
      FacetValue.encode(message.bucketGranularity, writer.uint32(18).fork()).join();
    }
    if (message.bucketCount !== 0) {
      writer.uint32(24).int32(message.bucketCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetProperty_FixedRangeBucketSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetProperty_FixedRangeBucketSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bucketStart = FacetValue.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bucketGranularity = FacetValue.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.bucketCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetProperty_FixedRangeBucketSpec {
    return {
      bucketStart: isSet(object.bucketStart) ? FacetValue.fromJSON(object.bucketStart) : undefined,
      bucketGranularity: isSet(object.bucketGranularity) ? FacetValue.fromJSON(object.bucketGranularity) : undefined,
      bucketCount: isSet(object.bucketCount) ? globalThis.Number(object.bucketCount) : 0,
    };
  },

  toJSON(message: FacetProperty_FixedRangeBucketSpec): unknown {
    const obj: any = {};
    if (message.bucketStart !== undefined) {
      obj.bucketStart = FacetValue.toJSON(message.bucketStart);
    }
    if (message.bucketGranularity !== undefined) {
      obj.bucketGranularity = FacetValue.toJSON(message.bucketGranularity);
    }
    if (message.bucketCount !== 0) {
      obj.bucketCount = Math.round(message.bucketCount);
    }
    return obj;
  },

  create(base?: DeepPartial<FacetProperty_FixedRangeBucketSpec>): FacetProperty_FixedRangeBucketSpec {
    return FacetProperty_FixedRangeBucketSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetProperty_FixedRangeBucketSpec>): FacetProperty_FixedRangeBucketSpec {
    const message = createBaseFacetProperty_FixedRangeBucketSpec();
    message.bucketStart = (object.bucketStart !== undefined && object.bucketStart !== null)
      ? FacetValue.fromPartial(object.bucketStart)
      : undefined;
    message.bucketGranularity = (object.bucketGranularity !== undefined && object.bucketGranularity !== null)
      ? FacetValue.fromPartial(object.bucketGranularity)
      : undefined;
    message.bucketCount = object.bucketCount ?? 0;
    return message;
  },
};

function createBaseFacetProperty_CustomRangeBucketSpec(): FacetProperty_CustomRangeBucketSpec {
  return { endpoints: [] };
}

export const FacetProperty_CustomRangeBucketSpec: MessageFns<FacetProperty_CustomRangeBucketSpec> = {
  encode(message: FacetProperty_CustomRangeBucketSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.endpoints) {
      FacetValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetProperty_CustomRangeBucketSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetProperty_CustomRangeBucketSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.endpoints.push(FacetValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetProperty_CustomRangeBucketSpec {
    return {
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => FacetValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FacetProperty_CustomRangeBucketSpec): unknown {
    const obj: any = {};
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints.map((e) => FacetValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FacetProperty_CustomRangeBucketSpec>): FacetProperty_CustomRangeBucketSpec {
    return FacetProperty_CustomRangeBucketSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetProperty_CustomRangeBucketSpec>): FacetProperty_CustomRangeBucketSpec {
    const message = createBaseFacetProperty_CustomRangeBucketSpec();
    message.endpoints = object.endpoints?.map((e) => FacetValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFacetProperty_DateTimeBucketSpec(): FacetProperty_DateTimeBucketSpec {
  return { granularity: 0 };
}

export const FacetProperty_DateTimeBucketSpec: MessageFns<FacetProperty_DateTimeBucketSpec> = {
  encode(message: FacetProperty_DateTimeBucketSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.granularity !== 0) {
      writer.uint32(8).int32(message.granularity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetProperty_DateTimeBucketSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetProperty_DateTimeBucketSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.granularity = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetProperty_DateTimeBucketSpec {
    return {
      granularity: isSet(object.granularity)
        ? facetProperty_DateTimeBucketSpec_GranularityFromJSON(object.granularity)
        : 0,
    };
  },

  toJSON(message: FacetProperty_DateTimeBucketSpec): unknown {
    const obj: any = {};
    if (message.granularity !== 0) {
      obj.granularity = facetProperty_DateTimeBucketSpec_GranularityToJSON(message.granularity);
    }
    return obj;
  },

  create(base?: DeepPartial<FacetProperty_DateTimeBucketSpec>): FacetProperty_DateTimeBucketSpec {
    return FacetProperty_DateTimeBucketSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetProperty_DateTimeBucketSpec>): FacetProperty_DateTimeBucketSpec {
    const message = createBaseFacetProperty_DateTimeBucketSpec();
    message.granularity = object.granularity ?? 0;
    return message;
  },
};

function createBaseSearchHypernym(): SearchHypernym {
  return { name: "", hypernym: "", hyponyms: [] };
}

export const SearchHypernym: MessageFns<SearchHypernym> = {
  encode(message: SearchHypernym, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.hypernym !== "") {
      writer.uint32(18).string(message.hypernym);
    }
    for (const v of message.hyponyms) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchHypernym {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchHypernym();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hypernym = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hyponyms.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchHypernym {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      hypernym: isSet(object.hypernym) ? globalThis.String(object.hypernym) : "",
      hyponyms: globalThis.Array.isArray(object?.hyponyms) ? object.hyponyms.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: SearchHypernym): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.hypernym !== "") {
      obj.hypernym = message.hypernym;
    }
    if (message.hyponyms?.length) {
      obj.hyponyms = message.hyponyms;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchHypernym>): SearchHypernym {
    return SearchHypernym.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchHypernym>): SearchHypernym {
    const message = createBaseSearchHypernym();
    message.name = object.name ?? "";
    message.hypernym = object.hypernym ?? "";
    message.hyponyms = object.hyponyms?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateSearchHypernymRequest(): CreateSearchHypernymRequest {
  return { parent: "", searchHypernym: undefined, searchHypernymId: undefined };
}

export const CreateSearchHypernymRequest: MessageFns<CreateSearchHypernymRequest> = {
  encode(message: CreateSearchHypernymRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.searchHypernym !== undefined) {
      SearchHypernym.encode(message.searchHypernym, writer.uint32(18).fork()).join();
    }
    if (message.searchHypernymId !== undefined) {
      writer.uint32(26).string(message.searchHypernymId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSearchHypernymRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSearchHypernymRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.searchHypernym = SearchHypernym.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.searchHypernymId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSearchHypernymRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      searchHypernym: isSet(object.searchHypernym) ? SearchHypernym.fromJSON(object.searchHypernym) : undefined,
      searchHypernymId: isSet(object.searchHypernymId) ? globalThis.String(object.searchHypernymId) : undefined,
    };
  },

  toJSON(message: CreateSearchHypernymRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.searchHypernym !== undefined) {
      obj.searchHypernym = SearchHypernym.toJSON(message.searchHypernym);
    }
    if (message.searchHypernymId !== undefined) {
      obj.searchHypernymId = message.searchHypernymId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSearchHypernymRequest>): CreateSearchHypernymRequest {
    return CreateSearchHypernymRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSearchHypernymRequest>): CreateSearchHypernymRequest {
    const message = createBaseCreateSearchHypernymRequest();
    message.parent = object.parent ?? "";
    message.searchHypernym = (object.searchHypernym !== undefined && object.searchHypernym !== null)
      ? SearchHypernym.fromPartial(object.searchHypernym)
      : undefined;
    message.searchHypernymId = object.searchHypernymId ?? undefined;
    return message;
  },
};

function createBaseUpdateSearchHypernymRequest(): UpdateSearchHypernymRequest {
  return { searchHypernym: undefined, updateMask: undefined };
}

export const UpdateSearchHypernymRequest: MessageFns<UpdateSearchHypernymRequest> = {
  encode(message: UpdateSearchHypernymRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchHypernym !== undefined) {
      SearchHypernym.encode(message.searchHypernym, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSearchHypernymRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSearchHypernymRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchHypernym = SearchHypernym.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSearchHypernymRequest {
    return {
      searchHypernym: isSet(object.searchHypernym) ? SearchHypernym.fromJSON(object.searchHypernym) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateSearchHypernymRequest): unknown {
    const obj: any = {};
    if (message.searchHypernym !== undefined) {
      obj.searchHypernym = SearchHypernym.toJSON(message.searchHypernym);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSearchHypernymRequest>): UpdateSearchHypernymRequest {
    return UpdateSearchHypernymRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSearchHypernymRequest>): UpdateSearchHypernymRequest {
    const message = createBaseUpdateSearchHypernymRequest();
    message.searchHypernym = (object.searchHypernym !== undefined && object.searchHypernym !== null)
      ? SearchHypernym.fromPartial(object.searchHypernym)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetSearchHypernymRequest(): GetSearchHypernymRequest {
  return { name: "" };
}

export const GetSearchHypernymRequest: MessageFns<GetSearchHypernymRequest> = {
  encode(message: GetSearchHypernymRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSearchHypernymRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSearchHypernymRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSearchHypernymRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSearchHypernymRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSearchHypernymRequest>): GetSearchHypernymRequest {
    return GetSearchHypernymRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSearchHypernymRequest>): GetSearchHypernymRequest {
    const message = createBaseGetSearchHypernymRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteSearchHypernymRequest(): DeleteSearchHypernymRequest {
  return { name: "" };
}

export const DeleteSearchHypernymRequest: MessageFns<DeleteSearchHypernymRequest> = {
  encode(message: DeleteSearchHypernymRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSearchHypernymRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSearchHypernymRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSearchHypernymRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteSearchHypernymRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSearchHypernymRequest>): DeleteSearchHypernymRequest {
    return DeleteSearchHypernymRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSearchHypernymRequest>): DeleteSearchHypernymRequest {
    const message = createBaseDeleteSearchHypernymRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListSearchHypernymsRequest(): ListSearchHypernymsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListSearchHypernymsRequest: MessageFns<ListSearchHypernymsRequest> = {
  encode(message: ListSearchHypernymsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSearchHypernymsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSearchHypernymsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSearchHypernymsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSearchHypernymsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSearchHypernymsRequest>): ListSearchHypernymsRequest {
    return ListSearchHypernymsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSearchHypernymsRequest>): ListSearchHypernymsRequest {
    const message = createBaseListSearchHypernymsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSearchHypernymsResponse(): ListSearchHypernymsResponse {
  return { searchHypernyms: [], nextPageToken: "" };
}

export const ListSearchHypernymsResponse: MessageFns<ListSearchHypernymsResponse> = {
  encode(message: ListSearchHypernymsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.searchHypernyms) {
      SearchHypernym.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSearchHypernymsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSearchHypernymsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchHypernyms.push(SearchHypernym.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSearchHypernymsResponse {
    return {
      searchHypernyms: globalThis.Array.isArray(object?.searchHypernyms)
        ? object.searchHypernyms.map((e: any) => SearchHypernym.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSearchHypernymsResponse): unknown {
    const obj: any = {};
    if (message.searchHypernyms?.length) {
      obj.searchHypernyms = message.searchHypernyms.map((e) => SearchHypernym.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSearchHypernymsResponse>): ListSearchHypernymsResponse {
    return ListSearchHypernymsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSearchHypernymsResponse>): ListSearchHypernymsResponse {
    const message = createBaseListSearchHypernymsResponse();
    message.searchHypernyms = object.searchHypernyms?.map((e) => SearchHypernym.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSearchCriteriaProperty(): SearchCriteriaProperty {
  return { mappedFields: [] };
}

export const SearchCriteriaProperty: MessageFns<SearchCriteriaProperty> = {
  encode(message: SearchCriteriaProperty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mappedFields) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchCriteriaProperty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchCriteriaProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mappedFields.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchCriteriaProperty {
    return {
      mappedFields: globalThis.Array.isArray(object?.mappedFields)
        ? object.mappedFields.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SearchCriteriaProperty): unknown {
    const obj: any = {};
    if (message.mappedFields?.length) {
      obj.mappedFields = message.mappedFields;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchCriteriaProperty>): SearchCriteriaProperty {
    return SearchCriteriaProperty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchCriteriaProperty>): SearchCriteriaProperty {
    const message = createBaseSearchCriteriaProperty();
    message.mappedFields = object.mappedFields?.map((e) => e) || [];
    return message;
  },
};

function createBaseFacetValue(): FacetValue {
  return { stringValue: undefined, integerValue: undefined, datetimeValue: undefined };
}

export const FacetValue: MessageFns<FacetValue> = {
  encode(message: FacetValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== undefined) {
      writer.uint32(10).string(message.stringValue);
    }
    if (message.integerValue !== undefined) {
      writer.uint32(16).int64(message.integerValue.toString());
    }
    if (message.datetimeValue !== undefined) {
      DateTime.encode(message.datetimeValue, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.integerValue = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.datetimeValue = DateTime.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetValue {
    return {
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      integerValue: isSet(object.integerValue) ? Long.fromValue(object.integerValue) : undefined,
      datetimeValue: isSet(object.datetimeValue) ? DateTime.fromJSON(object.datetimeValue) : undefined,
    };
  },

  toJSON(message: FacetValue): unknown {
    const obj: any = {};
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.integerValue !== undefined) {
      obj.integerValue = (message.integerValue || Long.ZERO).toString();
    }
    if (message.datetimeValue !== undefined) {
      obj.datetimeValue = DateTime.toJSON(message.datetimeValue);
    }
    return obj;
  },

  create(base?: DeepPartial<FacetValue>): FacetValue {
    return FacetValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetValue>): FacetValue {
    const message = createBaseFacetValue();
    message.stringValue = object.stringValue ?? undefined;
    message.integerValue = (object.integerValue !== undefined && object.integerValue !== null)
      ? Long.fromValue(object.integerValue)
      : undefined;
    message.datetimeValue = (object.datetimeValue !== undefined && object.datetimeValue !== null)
      ? DateTime.fromPartial(object.datetimeValue)
      : undefined;
    return message;
  },
};

function createBaseFacetBucket(): FacetBucket {
  return { value: undefined, range: undefined, selected: false };
}

export const FacetBucket: MessageFns<FacetBucket> = {
  encode(message: FacetBucket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      FacetValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    if (message.range !== undefined) {
      FacetBucket_Range.encode(message.range, writer.uint32(34).fork()).join();
    }
    if (message.selected !== false) {
      writer.uint32(24).bool(message.selected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetBucket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetBucket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = FacetValue.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.range = FacetBucket_Range.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.selected = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetBucket {
    return {
      value: isSet(object.value) ? FacetValue.fromJSON(object.value) : undefined,
      range: isSet(object.range) ? FacetBucket_Range.fromJSON(object.range) : undefined,
      selected: isSet(object.selected) ? globalThis.Boolean(object.selected) : false,
    };
  },

  toJSON(message: FacetBucket): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = FacetValue.toJSON(message.value);
    }
    if (message.range !== undefined) {
      obj.range = FacetBucket_Range.toJSON(message.range);
    }
    if (message.selected !== false) {
      obj.selected = message.selected;
    }
    return obj;
  },

  create(base?: DeepPartial<FacetBucket>): FacetBucket {
    return FacetBucket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetBucket>): FacetBucket {
    const message = createBaseFacetBucket();
    message.value = (object.value !== undefined && object.value !== null)
      ? FacetValue.fromPartial(object.value)
      : undefined;
    message.range = (object.range !== undefined && object.range !== null)
      ? FacetBucket_Range.fromPartial(object.range)
      : undefined;
    message.selected = object.selected ?? false;
    return message;
  },
};

function createBaseFacetBucket_Range(): FacetBucket_Range {
  return { start: undefined, end: undefined };
}

export const FacetBucket_Range: MessageFns<FacetBucket_Range> = {
  encode(message: FacetBucket_Range, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      FacetValue.encode(message.start, writer.uint32(10).fork()).join();
    }
    if (message.end !== undefined) {
      FacetValue.encode(message.end, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetBucket_Range {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetBucket_Range();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.start = FacetValue.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.end = FacetValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetBucket_Range {
    return {
      start: isSet(object.start) ? FacetValue.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? FacetValue.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: FacetBucket_Range): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = FacetValue.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = FacetValue.toJSON(message.end);
    }
    return obj;
  },

  create(base?: DeepPartial<FacetBucket_Range>): FacetBucket_Range {
    return FacetBucket_Range.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetBucket_Range>): FacetBucket_Range {
    const message = createBaseFacetBucket_Range();
    message.start = (object.start !== undefined && object.start !== null)
      ? FacetValue.fromPartial(object.start)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? FacetValue.fromPartial(object.end) : undefined;
    return message;
  },
};

function createBaseFacetGroup(): FacetGroup {
  return { facetId: "", displayName: "", buckets: [], bucketType: 0, fetchMatchedAnnotations: false };
}

export const FacetGroup: MessageFns<FacetGroup> = {
  encode(message: FacetGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.facetId !== "") {
      writer.uint32(10).string(message.facetId);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.buckets) {
      FacetBucket.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.bucketType !== 0) {
      writer.uint32(32).int32(message.bucketType);
    }
    if (message.fetchMatchedAnnotations !== false) {
      writer.uint32(40).bool(message.fetchMatchedAnnotations);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacetGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacetGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.facetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.buckets.push(FacetBucket.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bucketType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.fetchMatchedAnnotations = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FacetGroup {
    return {
      facetId: isSet(object.facetId) ? globalThis.String(object.facetId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      buckets: globalThis.Array.isArray(object?.buckets) ? object.buckets.map((e: any) => FacetBucket.fromJSON(e)) : [],
      bucketType: isSet(object.bucketType) ? facetBucketTypeFromJSON(object.bucketType) : 0,
      fetchMatchedAnnotations: isSet(object.fetchMatchedAnnotations)
        ? globalThis.Boolean(object.fetchMatchedAnnotations)
        : false,
    };
  },

  toJSON(message: FacetGroup): unknown {
    const obj: any = {};
    if (message.facetId !== "") {
      obj.facetId = message.facetId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.buckets?.length) {
      obj.buckets = message.buckets.map((e) => FacetBucket.toJSON(e));
    }
    if (message.bucketType !== 0) {
      obj.bucketType = facetBucketTypeToJSON(message.bucketType);
    }
    if (message.fetchMatchedAnnotations !== false) {
      obj.fetchMatchedAnnotations = message.fetchMatchedAnnotations;
    }
    return obj;
  },

  create(base?: DeepPartial<FacetGroup>): FacetGroup {
    return FacetGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FacetGroup>): FacetGroup {
    const message = createBaseFacetGroup();
    message.facetId = object.facetId ?? "";
    message.displayName = object.displayName ?? "";
    message.buckets = object.buckets?.map((e) => FacetBucket.fromPartial(e)) || [];
    message.bucketType = object.bucketType ?? 0;
    message.fetchMatchedAnnotations = object.fetchMatchedAnnotations ?? false;
    return message;
  },
};

function createBaseIngestAssetRequest(): IngestAssetRequest {
  return { config: undefined, timeIndexedData: undefined };
}

export const IngestAssetRequest: MessageFns<IngestAssetRequest> = {
  encode(message: IngestAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      IngestAssetRequest_Config.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.timeIndexedData !== undefined) {
      IngestAssetRequest_TimeIndexedData.encode(message.timeIndexedData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngestAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngestAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.config = IngestAssetRequest_Config.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeIndexedData = IngestAssetRequest_TimeIndexedData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngestAssetRequest {
    return {
      config: isSet(object.config) ? IngestAssetRequest_Config.fromJSON(object.config) : undefined,
      timeIndexedData: isSet(object.timeIndexedData)
        ? IngestAssetRequest_TimeIndexedData.fromJSON(object.timeIndexedData)
        : undefined,
    };
  },

  toJSON(message: IngestAssetRequest): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = IngestAssetRequest_Config.toJSON(message.config);
    }
    if (message.timeIndexedData !== undefined) {
      obj.timeIndexedData = IngestAssetRequest_TimeIndexedData.toJSON(message.timeIndexedData);
    }
    return obj;
  },

  create(base?: DeepPartial<IngestAssetRequest>): IngestAssetRequest {
    return IngestAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IngestAssetRequest>): IngestAssetRequest {
    const message = createBaseIngestAssetRequest();
    message.config = (object.config !== undefined && object.config !== null)
      ? IngestAssetRequest_Config.fromPartial(object.config)
      : undefined;
    message.timeIndexedData = (object.timeIndexedData !== undefined && object.timeIndexedData !== null)
      ? IngestAssetRequest_TimeIndexedData.fromPartial(object.timeIndexedData)
      : undefined;
    return message;
  },
};

function createBaseIngestAssetRequest_Config(): IngestAssetRequest_Config {
  return { videoType: undefined, asset: "" };
}

export const IngestAssetRequest_Config: MessageFns<IngestAssetRequest_Config> = {
  encode(message: IngestAssetRequest_Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoType !== undefined) {
      IngestAssetRequest_Config_VideoType.encode(message.videoType, writer.uint32(18).fork()).join();
    }
    if (message.asset !== "") {
      writer.uint32(10).string(message.asset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngestAssetRequest_Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngestAssetRequest_Config();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.videoType = IngestAssetRequest_Config_VideoType.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngestAssetRequest_Config {
    return {
      videoType: isSet(object.videoType) ? IngestAssetRequest_Config_VideoType.fromJSON(object.videoType) : undefined,
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
    };
  },

  toJSON(message: IngestAssetRequest_Config): unknown {
    const obj: any = {};
    if (message.videoType !== undefined) {
      obj.videoType = IngestAssetRequest_Config_VideoType.toJSON(message.videoType);
    }
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    return obj;
  },

  create(base?: DeepPartial<IngestAssetRequest_Config>): IngestAssetRequest_Config {
    return IngestAssetRequest_Config.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IngestAssetRequest_Config>): IngestAssetRequest_Config {
    const message = createBaseIngestAssetRequest_Config();
    message.videoType = (object.videoType !== undefined && object.videoType !== null)
      ? IngestAssetRequest_Config_VideoType.fromPartial(object.videoType)
      : undefined;
    message.asset = object.asset ?? "";
    return message;
  },
};

function createBaseIngestAssetRequest_Config_VideoType(): IngestAssetRequest_Config_VideoType {
  return { containerFormat: 0 };
}

export const IngestAssetRequest_Config_VideoType: MessageFns<IngestAssetRequest_Config_VideoType> = {
  encode(message: IngestAssetRequest_Config_VideoType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containerFormat !== 0) {
      writer.uint32(8).int32(message.containerFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngestAssetRequest_Config_VideoType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngestAssetRequest_Config_VideoType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.containerFormat = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngestAssetRequest_Config_VideoType {
    return {
      containerFormat: isSet(object.containerFormat)
        ? ingestAssetRequest_Config_VideoType_ContainerFormatFromJSON(object.containerFormat)
        : 0,
    };
  },

  toJSON(message: IngestAssetRequest_Config_VideoType): unknown {
    const obj: any = {};
    if (message.containerFormat !== 0) {
      obj.containerFormat = ingestAssetRequest_Config_VideoType_ContainerFormatToJSON(message.containerFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<IngestAssetRequest_Config_VideoType>): IngestAssetRequest_Config_VideoType {
    return IngestAssetRequest_Config_VideoType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IngestAssetRequest_Config_VideoType>): IngestAssetRequest_Config_VideoType {
    const message = createBaseIngestAssetRequest_Config_VideoType();
    message.containerFormat = object.containerFormat ?? 0;
    return message;
  },
};

function createBaseIngestAssetRequest_TimeIndexedData(): IngestAssetRequest_TimeIndexedData {
  return { data: Buffer.alloc(0), temporalPartition: undefined };
}

export const IngestAssetRequest_TimeIndexedData: MessageFns<IngestAssetRequest_TimeIndexedData> = {
  encode(message: IngestAssetRequest_TimeIndexedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.temporalPartition !== undefined) {
      Partition_TemporalPartition.encode(message.temporalPartition, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngestAssetRequest_TimeIndexedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngestAssetRequest_TimeIndexedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.temporalPartition = Partition_TemporalPartition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngestAssetRequest_TimeIndexedData {
    return {
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      temporalPartition: isSet(object.temporalPartition)
        ? Partition_TemporalPartition.fromJSON(object.temporalPartition)
        : undefined,
    };
  },

  toJSON(message: IngestAssetRequest_TimeIndexedData): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.temporalPartition !== undefined) {
      obj.temporalPartition = Partition_TemporalPartition.toJSON(message.temporalPartition);
    }
    return obj;
  },

  create(base?: DeepPartial<IngestAssetRequest_TimeIndexedData>): IngestAssetRequest_TimeIndexedData {
    return IngestAssetRequest_TimeIndexedData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IngestAssetRequest_TimeIndexedData>): IngestAssetRequest_TimeIndexedData {
    const message = createBaseIngestAssetRequest_TimeIndexedData();
    message.data = object.data ?? Buffer.alloc(0);
    message.temporalPartition = (object.temporalPartition !== undefined && object.temporalPartition !== null)
      ? Partition_TemporalPartition.fromPartial(object.temporalPartition)
      : undefined;
    return message;
  },
};

function createBaseIngestAssetResponse(): IngestAssetResponse {
  return { successfullyIngestedPartition: undefined };
}

export const IngestAssetResponse: MessageFns<IngestAssetResponse> = {
  encode(message: IngestAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.successfullyIngestedPartition !== undefined) {
      Partition_TemporalPartition.encode(message.successfullyIngestedPartition, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngestAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngestAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.successfullyIngestedPartition = Partition_TemporalPartition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngestAssetResponse {
    return {
      successfullyIngestedPartition: isSet(object.successfullyIngestedPartition)
        ? Partition_TemporalPartition.fromJSON(object.successfullyIngestedPartition)
        : undefined,
    };
  },

  toJSON(message: IngestAssetResponse): unknown {
    const obj: any = {};
    if (message.successfullyIngestedPartition !== undefined) {
      obj.successfullyIngestedPartition = Partition_TemporalPartition.toJSON(message.successfullyIngestedPartition);
    }
    return obj;
  },

  create(base?: DeepPartial<IngestAssetResponse>): IngestAssetResponse {
    return IngestAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IngestAssetResponse>): IngestAssetResponse {
    const message = createBaseIngestAssetResponse();
    message.successfullyIngestedPartition =
      (object.successfullyIngestedPartition !== undefined && object.successfullyIngestedPartition !== null)
        ? Partition_TemporalPartition.fromPartial(object.successfullyIngestedPartition)
        : undefined;
    return message;
  },
};

function createBaseClipAssetRequest(): ClipAssetRequest {
  return { name: "", temporalPartition: undefined };
}

export const ClipAssetRequest: MessageFns<ClipAssetRequest> = {
  encode(message: ClipAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.temporalPartition !== undefined) {
      Partition_TemporalPartition.encode(message.temporalPartition, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClipAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClipAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.temporalPartition = Partition_TemporalPartition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClipAssetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      temporalPartition: isSet(object.temporalPartition)
        ? Partition_TemporalPartition.fromJSON(object.temporalPartition)
        : undefined,
    };
  },

  toJSON(message: ClipAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.temporalPartition !== undefined) {
      obj.temporalPartition = Partition_TemporalPartition.toJSON(message.temporalPartition);
    }
    return obj;
  },

  create(base?: DeepPartial<ClipAssetRequest>): ClipAssetRequest {
    return ClipAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClipAssetRequest>): ClipAssetRequest {
    const message = createBaseClipAssetRequest();
    message.name = object.name ?? "";
    message.temporalPartition = (object.temporalPartition !== undefined && object.temporalPartition !== null)
      ? Partition_TemporalPartition.fromPartial(object.temporalPartition)
      : undefined;
    return message;
  },
};

function createBaseClipAssetResponse(): ClipAssetResponse {
  return { timeIndexedUris: [] };
}

export const ClipAssetResponse: MessageFns<ClipAssetResponse> = {
  encode(message: ClipAssetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.timeIndexedUris) {
      ClipAssetResponse_TimeIndexedUri.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClipAssetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClipAssetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeIndexedUris.push(ClipAssetResponse_TimeIndexedUri.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClipAssetResponse {
    return {
      timeIndexedUris: globalThis.Array.isArray(object?.timeIndexedUris)
        ? object.timeIndexedUris.map((e: any) => ClipAssetResponse_TimeIndexedUri.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClipAssetResponse): unknown {
    const obj: any = {};
    if (message.timeIndexedUris?.length) {
      obj.timeIndexedUris = message.timeIndexedUris.map((e) => ClipAssetResponse_TimeIndexedUri.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ClipAssetResponse>): ClipAssetResponse {
    return ClipAssetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClipAssetResponse>): ClipAssetResponse {
    const message = createBaseClipAssetResponse();
    message.timeIndexedUris = object.timeIndexedUris?.map((e) => ClipAssetResponse_TimeIndexedUri.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClipAssetResponse_TimeIndexedUri(): ClipAssetResponse_TimeIndexedUri {
  return { temporalPartition: undefined, uri: "" };
}

export const ClipAssetResponse_TimeIndexedUri: MessageFns<ClipAssetResponse_TimeIndexedUri> = {
  encode(message: ClipAssetResponse_TimeIndexedUri, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.temporalPartition !== undefined) {
      Partition_TemporalPartition.encode(message.temporalPartition, writer.uint32(10).fork()).join();
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClipAssetResponse_TimeIndexedUri {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClipAssetResponse_TimeIndexedUri();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.temporalPartition = Partition_TemporalPartition.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClipAssetResponse_TimeIndexedUri {
    return {
      temporalPartition: isSet(object.temporalPartition)
        ? Partition_TemporalPartition.fromJSON(object.temporalPartition)
        : undefined,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
    };
  },

  toJSON(message: ClipAssetResponse_TimeIndexedUri): unknown {
    const obj: any = {};
    if (message.temporalPartition !== undefined) {
      obj.temporalPartition = Partition_TemporalPartition.toJSON(message.temporalPartition);
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<ClipAssetResponse_TimeIndexedUri>): ClipAssetResponse_TimeIndexedUri {
    return ClipAssetResponse_TimeIndexedUri.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClipAssetResponse_TimeIndexedUri>): ClipAssetResponse_TimeIndexedUri {
    const message = createBaseClipAssetResponse_TimeIndexedUri();
    message.temporalPartition = (object.temporalPartition !== undefined && object.temporalPartition !== null)
      ? Partition_TemporalPartition.fromPartial(object.temporalPartition)
      : undefined;
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseGenerateHlsUriRequest(): GenerateHlsUriRequest {
  return { name: "", temporalPartitions: [], liveViewEnabled: false };
}

export const GenerateHlsUriRequest: MessageFns<GenerateHlsUriRequest> = {
  encode(message: GenerateHlsUriRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.temporalPartitions) {
      Partition_TemporalPartition.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.liveViewEnabled !== false) {
      writer.uint32(24).bool(message.liveViewEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateHlsUriRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateHlsUriRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.temporalPartitions.push(Partition_TemporalPartition.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.liveViewEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateHlsUriRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      temporalPartitions: globalThis.Array.isArray(object?.temporalPartitions)
        ? object.temporalPartitions.map((e: any) => Partition_TemporalPartition.fromJSON(e))
        : [],
      liveViewEnabled: isSet(object.liveViewEnabled) ? globalThis.Boolean(object.liveViewEnabled) : false,
    };
  },

  toJSON(message: GenerateHlsUriRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.temporalPartitions?.length) {
      obj.temporalPartitions = message.temporalPartitions.map((e) => Partition_TemporalPartition.toJSON(e));
    }
    if (message.liveViewEnabled !== false) {
      obj.liveViewEnabled = message.liveViewEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateHlsUriRequest>): GenerateHlsUriRequest {
    return GenerateHlsUriRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateHlsUriRequest>): GenerateHlsUriRequest {
    const message = createBaseGenerateHlsUriRequest();
    message.name = object.name ?? "";
    message.temporalPartitions = object.temporalPartitions?.map((e) => Partition_TemporalPartition.fromPartial(e)) ||
      [];
    message.liveViewEnabled = object.liveViewEnabled ?? false;
    return message;
  },
};

function createBaseGenerateHlsUriResponse(): GenerateHlsUriResponse {
  return { uri: "", temporalPartitions: [] };
}

export const GenerateHlsUriResponse: MessageFns<GenerateHlsUriResponse> = {
  encode(message: GenerateHlsUriResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    for (const v of message.temporalPartitions) {
      Partition_TemporalPartition.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateHlsUriResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateHlsUriResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.temporalPartitions.push(Partition_TemporalPartition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateHlsUriResponse {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      temporalPartitions: globalThis.Array.isArray(object?.temporalPartitions)
        ? object.temporalPartitions.map((e: any) => Partition_TemporalPartition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateHlsUriResponse): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.temporalPartitions?.length) {
      obj.temporalPartitions = message.temporalPartitions.map((e) => Partition_TemporalPartition.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateHlsUriResponse>): GenerateHlsUriResponse {
    return GenerateHlsUriResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateHlsUriResponse>): GenerateHlsUriResponse {
    const message = createBaseGenerateHlsUriResponse();
    message.uri = object.uri ?? "";
    message.temporalPartitions = object.temporalPartitions?.map((e) => Partition_TemporalPartition.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseSearchAssetsRequest(): SearchAssetsRequest {
  return {
    schemaKeySortingStrategy: undefined,
    corpus: "",
    pageSize: 0,
    pageToken: "",
    contentTimeRanges: undefined,
    criteria: [],
    facetSelections: [],
    resultAnnotationKeys: [],
    searchQuery: "",
  };
}

export const SearchAssetsRequest: MessageFns<SearchAssetsRequest> = {
  encode(message: SearchAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schemaKeySortingStrategy !== undefined) {
      SchemaKeySortingStrategy.encode(message.schemaKeySortingStrategy, writer.uint32(74).fork()).join();
    }
    if (message.corpus !== "") {
      writer.uint32(10).string(message.corpus);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.contentTimeRanges !== undefined) {
      DateTimeRangeArray.encode(message.contentTimeRanges, writer.uint32(42).fork()).join();
    }
    for (const v of message.criteria) {
      Criteria.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.facetSelections) {
      FacetGroup.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.resultAnnotationKeys) {
      writer.uint32(66).string(v!);
    }
    if (message.searchQuery !== "") {
      writer.uint32(82).string(message.searchQuery);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 9:
          if (tag !== 74) {
            break;
          }

          message.schemaKeySortingStrategy = SchemaKeySortingStrategy.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.corpus = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contentTimeRanges = DateTimeRangeArray.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.criteria.push(Criteria.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.facetSelections.push(FacetGroup.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.resultAnnotationKeys.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.searchQuery = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAssetsRequest {
    return {
      schemaKeySortingStrategy: isSet(object.schemaKeySortingStrategy)
        ? SchemaKeySortingStrategy.fromJSON(object.schemaKeySortingStrategy)
        : undefined,
      corpus: isSet(object.corpus) ? globalThis.String(object.corpus) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      contentTimeRanges: isSet(object.contentTimeRanges)
        ? DateTimeRangeArray.fromJSON(object.contentTimeRanges)
        : undefined,
      criteria: globalThis.Array.isArray(object?.criteria) ? object.criteria.map((e: any) => Criteria.fromJSON(e)) : [],
      facetSelections: globalThis.Array.isArray(object?.facetSelections)
        ? object.facetSelections.map((e: any) => FacetGroup.fromJSON(e))
        : [],
      resultAnnotationKeys: globalThis.Array.isArray(object?.resultAnnotationKeys)
        ? object.resultAnnotationKeys.map((e: any) => globalThis.String(e))
        : [],
      searchQuery: isSet(object.searchQuery) ? globalThis.String(object.searchQuery) : "",
    };
  },

  toJSON(message: SearchAssetsRequest): unknown {
    const obj: any = {};
    if (message.schemaKeySortingStrategy !== undefined) {
      obj.schemaKeySortingStrategy = SchemaKeySortingStrategy.toJSON(message.schemaKeySortingStrategy);
    }
    if (message.corpus !== "") {
      obj.corpus = message.corpus;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.contentTimeRanges !== undefined) {
      obj.contentTimeRanges = DateTimeRangeArray.toJSON(message.contentTimeRanges);
    }
    if (message.criteria?.length) {
      obj.criteria = message.criteria.map((e) => Criteria.toJSON(e));
    }
    if (message.facetSelections?.length) {
      obj.facetSelections = message.facetSelections.map((e) => FacetGroup.toJSON(e));
    }
    if (message.resultAnnotationKeys?.length) {
      obj.resultAnnotationKeys = message.resultAnnotationKeys;
    }
    if (message.searchQuery !== "") {
      obj.searchQuery = message.searchQuery;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAssetsRequest>): SearchAssetsRequest {
    return SearchAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAssetsRequest>): SearchAssetsRequest {
    const message = createBaseSearchAssetsRequest();
    message.schemaKeySortingStrategy =
      (object.schemaKeySortingStrategy !== undefined && object.schemaKeySortingStrategy !== null)
        ? SchemaKeySortingStrategy.fromPartial(object.schemaKeySortingStrategy)
        : undefined;
    message.corpus = object.corpus ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.contentTimeRanges = (object.contentTimeRanges !== undefined && object.contentTimeRanges !== null)
      ? DateTimeRangeArray.fromPartial(object.contentTimeRanges)
      : undefined;
    message.criteria = object.criteria?.map((e) => Criteria.fromPartial(e)) || [];
    message.facetSelections = object.facetSelections?.map((e) => FacetGroup.fromPartial(e)) || [];
    message.resultAnnotationKeys = object.resultAnnotationKeys?.map((e) => e) || [];
    message.searchQuery = object.searchQuery ?? "";
    return message;
  },
};

function createBaseSearchIndexEndpointRequest(): SearchIndexEndpointRequest {
  return {
    imageQuery: undefined,
    textQuery: undefined,
    indexEndpoint: "",
    criteria: [],
    exclusionCriteria: [],
    pageSize: 0,
    pageToken: "",
  };
}

export const SearchIndexEndpointRequest: MessageFns<SearchIndexEndpointRequest> = {
  encode(message: SearchIndexEndpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageQuery !== undefined) {
      ImageQuery.encode(message.imageQuery, writer.uint32(18).fork()).join();
    }
    if (message.textQuery !== undefined) {
      writer.uint32(26).string(message.textQuery);
    }
    if (message.indexEndpoint !== "") {
      writer.uint32(10).string(message.indexEndpoint);
    }
    for (const v of message.criteria) {
      Criteria.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.exclusionCriteria) {
      Criteria.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.pageSize !== 0) {
      writer.uint32(40).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(50).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchIndexEndpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchIndexEndpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imageQuery = ImageQuery.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textQuery = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.indexEndpoint = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.criteria.push(Criteria.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.exclusionCriteria.push(Criteria.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchIndexEndpointRequest {
    return {
      imageQuery: isSet(object.imageQuery) ? ImageQuery.fromJSON(object.imageQuery) : undefined,
      textQuery: isSet(object.textQuery) ? globalThis.String(object.textQuery) : undefined,
      indexEndpoint: isSet(object.indexEndpoint) ? globalThis.String(object.indexEndpoint) : "",
      criteria: globalThis.Array.isArray(object?.criteria) ? object.criteria.map((e: any) => Criteria.fromJSON(e)) : [],
      exclusionCriteria: globalThis.Array.isArray(object?.exclusionCriteria)
        ? object.exclusionCriteria.map((e: any) => Criteria.fromJSON(e))
        : [],
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: SearchIndexEndpointRequest): unknown {
    const obj: any = {};
    if (message.imageQuery !== undefined) {
      obj.imageQuery = ImageQuery.toJSON(message.imageQuery);
    }
    if (message.textQuery !== undefined) {
      obj.textQuery = message.textQuery;
    }
    if (message.indexEndpoint !== "") {
      obj.indexEndpoint = message.indexEndpoint;
    }
    if (message.criteria?.length) {
      obj.criteria = message.criteria.map((e) => Criteria.toJSON(e));
    }
    if (message.exclusionCriteria?.length) {
      obj.exclusionCriteria = message.exclusionCriteria.map((e) => Criteria.toJSON(e));
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchIndexEndpointRequest>): SearchIndexEndpointRequest {
    return SearchIndexEndpointRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchIndexEndpointRequest>): SearchIndexEndpointRequest {
    const message = createBaseSearchIndexEndpointRequest();
    message.imageQuery = (object.imageQuery !== undefined && object.imageQuery !== null)
      ? ImageQuery.fromPartial(object.imageQuery)
      : undefined;
    message.textQuery = object.textQuery ?? undefined;
    message.indexEndpoint = object.indexEndpoint ?? "";
    message.criteria = object.criteria?.map((e) => Criteria.fromPartial(e)) || [];
    message.exclusionCriteria = object.exclusionCriteria?.map((e) => Criteria.fromPartial(e)) || [];
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseImageQuery(): ImageQuery {
  return { inputImage: undefined, asset: undefined };
}

export const ImageQuery: MessageFns<ImageQuery> = {
  encode(message: ImageQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputImage !== undefined) {
      writer.uint32(10).bytes(message.inputImage);
    }
    if (message.asset !== undefined) {
      writer.uint32(18).string(message.asset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputImage = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.asset = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageQuery {
    return {
      inputImage: isSet(object.inputImage) ? Buffer.from(bytesFromBase64(object.inputImage)) : undefined,
      asset: isSet(object.asset) ? globalThis.String(object.asset) : undefined,
    };
  },

  toJSON(message: ImageQuery): unknown {
    const obj: any = {};
    if (message.inputImage !== undefined) {
      obj.inputImage = base64FromBytes(message.inputImage);
    }
    if (message.asset !== undefined) {
      obj.asset = message.asset;
    }
    return obj;
  },

  create(base?: DeepPartial<ImageQuery>): ImageQuery {
    return ImageQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImageQuery>): ImageQuery {
    const message = createBaseImageQuery();
    message.inputImage = object.inputImage ?? undefined;
    message.asset = object.asset ?? undefined;
    return message;
  },
};

function createBaseSchemaKeySortingStrategy(): SchemaKeySortingStrategy {
  return { options: [] };
}

export const SchemaKeySortingStrategy: MessageFns<SchemaKeySortingStrategy> = {
  encode(message: SchemaKeySortingStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.options) {
      SchemaKeySortingStrategy_Option.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchemaKeySortingStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaKeySortingStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.options.push(SchemaKeySortingStrategy_Option.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaKeySortingStrategy {
    return {
      options: globalThis.Array.isArray(object?.options)
        ? object.options.map((e: any) => SchemaKeySortingStrategy_Option.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SchemaKeySortingStrategy): unknown {
    const obj: any = {};
    if (message.options?.length) {
      obj.options = message.options.map((e) => SchemaKeySortingStrategy_Option.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaKeySortingStrategy>): SchemaKeySortingStrategy {
    return SchemaKeySortingStrategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaKeySortingStrategy>): SchemaKeySortingStrategy {
    const message = createBaseSchemaKeySortingStrategy();
    message.options = object.options?.map((e) => SchemaKeySortingStrategy_Option.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSchemaKeySortingStrategy_Option(): SchemaKeySortingStrategy_Option {
  return { dataSchemaKey: "", sortDecreasing: false, aggregateMethod: undefined };
}

export const SchemaKeySortingStrategy_Option: MessageFns<SchemaKeySortingStrategy_Option> = {
  encode(message: SchemaKeySortingStrategy_Option, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataSchemaKey !== "") {
      writer.uint32(10).string(message.dataSchemaKey);
    }
    if (message.sortDecreasing !== false) {
      writer.uint32(16).bool(message.sortDecreasing);
    }
    if (message.aggregateMethod !== undefined) {
      writer.uint32(24).int32(message.aggregateMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchemaKeySortingStrategy_Option {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaKeySortingStrategy_Option();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSchemaKey = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sortDecreasing = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.aggregateMethod = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaKeySortingStrategy_Option {
    return {
      dataSchemaKey: isSet(object.dataSchemaKey) ? globalThis.String(object.dataSchemaKey) : "",
      sortDecreasing: isSet(object.sortDecreasing) ? globalThis.Boolean(object.sortDecreasing) : false,
      aggregateMethod: isSet(object.aggregateMethod)
        ? schemaKeySortingStrategy_Option_AggregateMethodFromJSON(object.aggregateMethod)
        : undefined,
    };
  },

  toJSON(message: SchemaKeySortingStrategy_Option): unknown {
    const obj: any = {};
    if (message.dataSchemaKey !== "") {
      obj.dataSchemaKey = message.dataSchemaKey;
    }
    if (message.sortDecreasing !== false) {
      obj.sortDecreasing = message.sortDecreasing;
    }
    if (message.aggregateMethod !== undefined) {
      obj.aggregateMethod = schemaKeySortingStrategy_Option_AggregateMethodToJSON(message.aggregateMethod);
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaKeySortingStrategy_Option>): SchemaKeySortingStrategy_Option {
    return SchemaKeySortingStrategy_Option.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaKeySortingStrategy_Option>): SchemaKeySortingStrategy_Option {
    const message = createBaseSchemaKeySortingStrategy_Option();
    message.dataSchemaKey = object.dataSchemaKey ?? "";
    message.sortDecreasing = object.sortDecreasing ?? false;
    message.aggregateMethod = object.aggregateMethod ?? undefined;
    return message;
  },
};

function createBaseDeleteAssetMetadata(): DeleteAssetMetadata {
  return {};
}

export const DeleteAssetMetadata: MessageFns<DeleteAssetMetadata> = {
  encode(_: DeleteAssetMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAssetMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAssetMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteAssetMetadata {
    return {};
  },

  toJSON(_: DeleteAssetMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DeleteAssetMetadata>): DeleteAssetMetadata {
    return DeleteAssetMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeleteAssetMetadata>): DeleteAssetMetadata {
    const message = createBaseDeleteAssetMetadata();
    return message;
  },
};

function createBaseAnnotationMatchingResult(): AnnotationMatchingResult {
  return { criteria: undefined, matchedAnnotations: [], status: undefined };
}

export const AnnotationMatchingResult: MessageFns<AnnotationMatchingResult> = {
  encode(message: AnnotationMatchingResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.criteria !== undefined) {
      Criteria.encode(message.criteria, writer.uint32(10).fork()).join();
    }
    for (const v of message.matchedAnnotations) {
      Annotation.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationMatchingResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationMatchingResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.criteria = Criteria.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.matchedAnnotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationMatchingResult {
    return {
      criteria: isSet(object.criteria) ? Criteria.fromJSON(object.criteria) : undefined,
      matchedAnnotations: globalThis.Array.isArray(object?.matchedAnnotations)
        ? object.matchedAnnotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: AnnotationMatchingResult): unknown {
    const obj: any = {};
    if (message.criteria !== undefined) {
      obj.criteria = Criteria.toJSON(message.criteria);
    }
    if (message.matchedAnnotations?.length) {
      obj.matchedAnnotations = message.matchedAnnotations.map((e) => Annotation.toJSON(e));
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotationMatchingResult>): AnnotationMatchingResult {
    return AnnotationMatchingResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotationMatchingResult>): AnnotationMatchingResult {
    const message = createBaseAnnotationMatchingResult();
    message.criteria = (object.criteria !== undefined && object.criteria !== null)
      ? Criteria.fromPartial(object.criteria)
      : undefined;
    message.matchedAnnotations = object.matchedAnnotations?.map((e) => Annotation.fromPartial(e)) || [];
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseSearchResultItem(): SearchResultItem {
  return {
    asset: "",
    segments: [],
    segment: undefined,
    relevance: 0,
    requestedAnnotations: [],
    annotationMatchingResults: [],
  };
}

export const SearchResultItem: MessageFns<SearchResultItem> = {
  encode(message: SearchResultItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asset !== "") {
      writer.uint32(10).string(message.asset);
    }
    for (const v of message.segments) {
      Partition_TemporalPartition.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.segment !== undefined) {
      Partition_TemporalPartition.encode(message.segment, writer.uint32(42).fork()).join();
    }
    if (message.relevance !== 0) {
      writer.uint32(49).double(message.relevance);
    }
    for (const v of message.requestedAnnotations) {
      Annotation.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.annotationMatchingResults) {
      AnnotationMatchingResult.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResultItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResultItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.segments.push(Partition_TemporalPartition.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.segment = Partition_TemporalPartition.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.relevance = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestedAnnotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.annotationMatchingResults.push(AnnotationMatchingResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResultItem {
    return {
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
      segments: globalThis.Array.isArray(object?.segments)
        ? object.segments.map((e: any) => Partition_TemporalPartition.fromJSON(e))
        : [],
      segment: isSet(object.segment) ? Partition_TemporalPartition.fromJSON(object.segment) : undefined,
      relevance: isSet(object.relevance) ? globalThis.Number(object.relevance) : 0,
      requestedAnnotations: globalThis.Array.isArray(object?.requestedAnnotations)
        ? object.requestedAnnotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      annotationMatchingResults: globalThis.Array.isArray(object?.annotationMatchingResults)
        ? object.annotationMatchingResults.map((e: any) => AnnotationMatchingResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResultItem): unknown {
    const obj: any = {};
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.segments?.length) {
      obj.segments = message.segments.map((e) => Partition_TemporalPartition.toJSON(e));
    }
    if (message.segment !== undefined) {
      obj.segment = Partition_TemporalPartition.toJSON(message.segment);
    }
    if (message.relevance !== 0) {
      obj.relevance = message.relevance;
    }
    if (message.requestedAnnotations?.length) {
      obj.requestedAnnotations = message.requestedAnnotations.map((e) => Annotation.toJSON(e));
    }
    if (message.annotationMatchingResults?.length) {
      obj.annotationMatchingResults = message.annotationMatchingResults.map((e) => AnnotationMatchingResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResultItem>): SearchResultItem {
    return SearchResultItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResultItem>): SearchResultItem {
    const message = createBaseSearchResultItem();
    message.asset = object.asset ?? "";
    message.segments = object.segments?.map((e) => Partition_TemporalPartition.fromPartial(e)) || [];
    message.segment = (object.segment !== undefined && object.segment !== null)
      ? Partition_TemporalPartition.fromPartial(object.segment)
      : undefined;
    message.relevance = object.relevance ?? 0;
    message.requestedAnnotations = object.requestedAnnotations?.map((e) => Annotation.fromPartial(e)) || [];
    message.annotationMatchingResults =
      object.annotationMatchingResults?.map((e) => AnnotationMatchingResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchAssetsResponse(): SearchAssetsResponse {
  return { searchResultItems: [], nextPageToken: "", facetResults: [] };
}

export const SearchAssetsResponse: MessageFns<SearchAssetsResponse> = {
  encode(message: SearchAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.searchResultItems) {
      SearchResultItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.facetResults) {
      FacetGroup.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchResultItems.push(SearchResultItem.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.facetResults.push(FacetGroup.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAssetsResponse {
    return {
      searchResultItems: globalThis.Array.isArray(object?.searchResultItems)
        ? object.searchResultItems.map((e: any) => SearchResultItem.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      facetResults: globalThis.Array.isArray(object?.facetResults)
        ? object.facetResults.map((e: any) => FacetGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchAssetsResponse): unknown {
    const obj: any = {};
    if (message.searchResultItems?.length) {
      obj.searchResultItems = message.searchResultItems.map((e) => SearchResultItem.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.facetResults?.length) {
      obj.facetResults = message.facetResults.map((e) => FacetGroup.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAssetsResponse>): SearchAssetsResponse {
    return SearchAssetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAssetsResponse>): SearchAssetsResponse {
    const message = createBaseSearchAssetsResponse();
    message.searchResultItems = object.searchResultItems?.map((e) => SearchResultItem.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.facetResults = object.facetResults?.map((e) => FacetGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchIndexEndpointResponse(): SearchIndexEndpointResponse {
  return { searchResultItems: [], nextPageToken: "" };
}

export const SearchIndexEndpointResponse: MessageFns<SearchIndexEndpointResponse> = {
  encode(message: SearchIndexEndpointResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.searchResultItems) {
      SearchResultItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchIndexEndpointResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchIndexEndpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchResultItems.push(SearchResultItem.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchIndexEndpointResponse {
    return {
      searchResultItems: globalThis.Array.isArray(object?.searchResultItems)
        ? object.searchResultItems.map((e: any) => SearchResultItem.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchIndexEndpointResponse): unknown {
    const obj: any = {};
    if (message.searchResultItems?.length) {
      obj.searchResultItems = message.searchResultItems.map((e) => SearchResultItem.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchIndexEndpointResponse>): SearchIndexEndpointResponse {
    return SearchIndexEndpointResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchIndexEndpointResponse>): SearchIndexEndpointResponse {
    const message = createBaseSearchIndexEndpointResponse();
    message.searchResultItems = object.searchResultItems?.map((e) => SearchResultItem.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseIntRange(): IntRange {
  return { start: undefined, end: undefined };
}

export const IntRange: MessageFns<IntRange> = {
  encode(message: IntRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      writer.uint32(8).int64(message.start.toString());
    }
    if (message.end !== undefined) {
      writer.uint32(16).int64(message.end.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntRange {
    return {
      start: isSet(object.start) ? Long.fromValue(object.start) : undefined,
      end: isSet(object.end) ? Long.fromValue(object.end) : undefined,
    };
  },

  toJSON(message: IntRange): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = (message.start || Long.ZERO).toString();
    }
    if (message.end !== undefined) {
      obj.end = (message.end || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<IntRange>): IntRange {
    return IntRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntRange>): IntRange {
    const message = createBaseIntRange();
    message.start = (object.start !== undefined && object.start !== null) ? Long.fromValue(object.start) : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? Long.fromValue(object.end) : undefined;
    return message;
  },
};

function createBaseFloatRange(): FloatRange {
  return { start: undefined, end: undefined };
}

export const FloatRange: MessageFns<FloatRange> = {
  encode(message: FloatRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      writer.uint32(13).float(message.start);
    }
    if (message.end !== undefined) {
      writer.uint32(21).float(message.end);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.start = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.end = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatRange {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : undefined,
      end: isSet(object.end) ? globalThis.Number(object.end) : undefined,
    };
  },

  toJSON(message: FloatRange): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = message.start;
    }
    if (message.end !== undefined) {
      obj.end = message.end;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatRange>): FloatRange {
    return FloatRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatRange>): FloatRange {
    const message = createBaseFloatRange();
    message.start = object.start ?? undefined;
    message.end = object.end ?? undefined;
    return message;
  },
};

function createBaseStringArray(): StringArray {
  return { txtValues: [] };
}

export const StringArray: MessageFns<StringArray> = {
  encode(message: StringArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.txtValues) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txtValues.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringArray {
    return {
      txtValues: globalThis.Array.isArray(object?.txtValues)
        ? object.txtValues.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StringArray): unknown {
    const obj: any = {};
    if (message.txtValues?.length) {
      obj.txtValues = message.txtValues;
    }
    return obj;
  },

  create(base?: DeepPartial<StringArray>): StringArray {
    return StringArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringArray>): StringArray {
    const message = createBaseStringArray();
    message.txtValues = object.txtValues?.map((e) => e) || [];
    return message;
  },
};

function createBaseIntRangeArray(): IntRangeArray {
  return { intRanges: [] };
}

export const IntRangeArray: MessageFns<IntRangeArray> = {
  encode(message: IntRangeArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.intRanges) {
      IntRange.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntRangeArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntRangeArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intRanges.push(IntRange.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntRangeArray {
    return {
      intRanges: globalThis.Array.isArray(object?.intRanges)
        ? object.intRanges.map((e: any) => IntRange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IntRangeArray): unknown {
    const obj: any = {};
    if (message.intRanges?.length) {
      obj.intRanges = message.intRanges.map((e) => IntRange.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<IntRangeArray>): IntRangeArray {
    return IntRangeArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntRangeArray>): IntRangeArray {
    const message = createBaseIntRangeArray();
    message.intRanges = object.intRanges?.map((e) => IntRange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFloatRangeArray(): FloatRangeArray {
  return { floatRanges: [] };
}

export const FloatRangeArray: MessageFns<FloatRangeArray> = {
  encode(message: FloatRangeArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.floatRanges) {
      FloatRange.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatRangeArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatRangeArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.floatRanges.push(FloatRange.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatRangeArray {
    return {
      floatRanges: globalThis.Array.isArray(object?.floatRanges)
        ? object.floatRanges.map((e: any) => FloatRange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FloatRangeArray): unknown {
    const obj: any = {};
    if (message.floatRanges?.length) {
      obj.floatRanges = message.floatRanges.map((e) => FloatRange.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FloatRangeArray>): FloatRangeArray {
    return FloatRangeArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatRangeArray>): FloatRangeArray {
    const message = createBaseFloatRangeArray();
    message.floatRanges = object.floatRanges?.map((e) => FloatRange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDateTimeRange(): DateTimeRange {
  return { start: undefined, end: undefined };
}

export const DateTimeRange: MessageFns<DateTimeRange> = {
  encode(message: DateTimeRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      DateTime.encode(message.start, writer.uint32(10).fork()).join();
    }
    if (message.end !== undefined) {
      DateTime.encode(message.end, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateTimeRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateTimeRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.start = DateTime.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.end = DateTime.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateTimeRange {
    return {
      start: isSet(object.start) ? DateTime.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? DateTime.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: DateTimeRange): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = DateTime.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = DateTime.toJSON(message.end);
    }
    return obj;
  },

  create(base?: DeepPartial<DateTimeRange>): DateTimeRange {
    return DateTimeRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DateTimeRange>): DateTimeRange {
    const message = createBaseDateTimeRange();
    message.start = (object.start !== undefined && object.start !== null)
      ? DateTime.fromPartial(object.start)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? DateTime.fromPartial(object.end) : undefined;
    return message;
  },
};

function createBaseDateTimeRangeArray(): DateTimeRangeArray {
  return { dateTimeRanges: [] };
}

export const DateTimeRangeArray: MessageFns<DateTimeRangeArray> = {
  encode(message: DateTimeRangeArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dateTimeRanges) {
      DateTimeRange.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateTimeRangeArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateTimeRangeArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dateTimeRanges.push(DateTimeRange.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateTimeRangeArray {
    return {
      dateTimeRanges: globalThis.Array.isArray(object?.dateTimeRanges)
        ? object.dateTimeRanges.map((e: any) => DateTimeRange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DateTimeRangeArray): unknown {
    const obj: any = {};
    if (message.dateTimeRanges?.length) {
      obj.dateTimeRanges = message.dateTimeRanges.map((e) => DateTimeRange.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DateTimeRangeArray>): DateTimeRangeArray {
    return DateTimeRangeArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DateTimeRangeArray>): DateTimeRangeArray {
    const message = createBaseDateTimeRangeArray();
    message.dateTimeRanges = object.dateTimeRanges?.map((e) => DateTimeRange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCircleArea(): CircleArea {
  return { latitude: 0, longitude: 0, radiusMeter: 0 };
}

export const CircleArea: MessageFns<CircleArea> = {
  encode(message: CircleArea, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latitude !== 0) {
      writer.uint32(9).double(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(17).double(message.longitude);
    }
    if (message.radiusMeter !== 0) {
      writer.uint32(25).double(message.radiusMeter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CircleArea {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCircleArea();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.latitude = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.longitude = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.radiusMeter = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CircleArea {
    return {
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
      radiusMeter: isSet(object.radiusMeter) ? globalThis.Number(object.radiusMeter) : 0,
    };
  },

  toJSON(message: CircleArea): unknown {
    const obj: any = {};
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    if (message.radiusMeter !== 0) {
      obj.radiusMeter = message.radiusMeter;
    }
    return obj;
  },

  create(base?: DeepPartial<CircleArea>): CircleArea {
    return CircleArea.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CircleArea>): CircleArea {
    const message = createBaseCircleArea();
    message.latitude = object.latitude ?? 0;
    message.longitude = object.longitude ?? 0;
    message.radiusMeter = object.radiusMeter ?? 0;
    return message;
  },
};

function createBaseGeoLocationArray(): GeoLocationArray {
  return { circleAreas: [] };
}

export const GeoLocationArray: MessageFns<GeoLocationArray> = {
  encode(message: GeoLocationArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.circleAreas) {
      CircleArea.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoLocationArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoLocationArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.circleAreas.push(CircleArea.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoLocationArray {
    return {
      circleAreas: globalThis.Array.isArray(object?.circleAreas)
        ? object.circleAreas.map((e: any) => CircleArea.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GeoLocationArray): unknown {
    const obj: any = {};
    if (message.circleAreas?.length) {
      obj.circleAreas = message.circleAreas.map((e) => CircleArea.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GeoLocationArray>): GeoLocationArray {
    return GeoLocationArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeoLocationArray>): GeoLocationArray {
    const message = createBaseGeoLocationArray();
    message.circleAreas = object.circleAreas?.map((e) => CircleArea.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBoolValue(): BoolValue {
  return { value: false };
}

export const BoolValue: MessageFns<BoolValue> = {
  encode(message: BoolValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== false) {
      writer.uint32(8).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoolValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoolValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoolValue {
    return { value: isSet(object.value) ? globalThis.Boolean(object.value) : false };
  },

  toJSON(message: BoolValue): unknown {
    const obj: any = {};
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BoolValue>): BoolValue {
    return BoolValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BoolValue>): BoolValue {
    const message = createBaseBoolValue();
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseCriteria(): Criteria {
  return {
    textArray: undefined,
    intRangeArray: undefined,
    floatRangeArray: undefined,
    dateTimeRangeArray: undefined,
    geoLocationArray: undefined,
    boolValue: undefined,
    field: "",
    fetchMatchedAnnotations: false,
  };
}

export const Criteria: MessageFns<Criteria> = {
  encode(message: Criteria, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textArray !== undefined) {
      StringArray.encode(message.textArray, writer.uint32(18).fork()).join();
    }
    if (message.intRangeArray !== undefined) {
      IntRangeArray.encode(message.intRangeArray, writer.uint32(26).fork()).join();
    }
    if (message.floatRangeArray !== undefined) {
      FloatRangeArray.encode(message.floatRangeArray, writer.uint32(34).fork()).join();
    }
    if (message.dateTimeRangeArray !== undefined) {
      DateTimeRangeArray.encode(message.dateTimeRangeArray, writer.uint32(42).fork()).join();
    }
    if (message.geoLocationArray !== undefined) {
      GeoLocationArray.encode(message.geoLocationArray, writer.uint32(50).fork()).join();
    }
    if (message.boolValue !== undefined) {
      BoolValue.encode(message.boolValue, writer.uint32(58).fork()).join();
    }
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.fetchMatchedAnnotations !== false) {
      writer.uint32(64).bool(message.fetchMatchedAnnotations);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Criteria {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCriteria();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textArray = StringArray.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.intRangeArray = IntRangeArray.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.floatRangeArray = FloatRangeArray.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dateTimeRangeArray = DateTimeRangeArray.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.geoLocationArray = GeoLocationArray.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.boolValue = BoolValue.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.fetchMatchedAnnotations = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Criteria {
    return {
      textArray: isSet(object.textArray) ? StringArray.fromJSON(object.textArray) : undefined,
      intRangeArray: isSet(object.intRangeArray) ? IntRangeArray.fromJSON(object.intRangeArray) : undefined,
      floatRangeArray: isSet(object.floatRangeArray) ? FloatRangeArray.fromJSON(object.floatRangeArray) : undefined,
      dateTimeRangeArray: isSet(object.dateTimeRangeArray)
        ? DateTimeRangeArray.fromJSON(object.dateTimeRangeArray)
        : undefined,
      geoLocationArray: isSet(object.geoLocationArray) ? GeoLocationArray.fromJSON(object.geoLocationArray) : undefined,
      boolValue: isSet(object.boolValue) ? BoolValue.fromJSON(object.boolValue) : undefined,
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      fetchMatchedAnnotations: isSet(object.fetchMatchedAnnotations)
        ? globalThis.Boolean(object.fetchMatchedAnnotations)
        : false,
    };
  },

  toJSON(message: Criteria): unknown {
    const obj: any = {};
    if (message.textArray !== undefined) {
      obj.textArray = StringArray.toJSON(message.textArray);
    }
    if (message.intRangeArray !== undefined) {
      obj.intRangeArray = IntRangeArray.toJSON(message.intRangeArray);
    }
    if (message.floatRangeArray !== undefined) {
      obj.floatRangeArray = FloatRangeArray.toJSON(message.floatRangeArray);
    }
    if (message.dateTimeRangeArray !== undefined) {
      obj.dateTimeRangeArray = DateTimeRangeArray.toJSON(message.dateTimeRangeArray);
    }
    if (message.geoLocationArray !== undefined) {
      obj.geoLocationArray = GeoLocationArray.toJSON(message.geoLocationArray);
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = BoolValue.toJSON(message.boolValue);
    }
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.fetchMatchedAnnotations !== false) {
      obj.fetchMatchedAnnotations = message.fetchMatchedAnnotations;
    }
    return obj;
  },

  create(base?: DeepPartial<Criteria>): Criteria {
    return Criteria.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Criteria>): Criteria {
    const message = createBaseCriteria();
    message.textArray = (object.textArray !== undefined && object.textArray !== null)
      ? StringArray.fromPartial(object.textArray)
      : undefined;
    message.intRangeArray = (object.intRangeArray !== undefined && object.intRangeArray !== null)
      ? IntRangeArray.fromPartial(object.intRangeArray)
      : undefined;
    message.floatRangeArray = (object.floatRangeArray !== undefined && object.floatRangeArray !== null)
      ? FloatRangeArray.fromPartial(object.floatRangeArray)
      : undefined;
    message.dateTimeRangeArray = (object.dateTimeRangeArray !== undefined && object.dateTimeRangeArray !== null)
      ? DateTimeRangeArray.fromPartial(object.dateTimeRangeArray)
      : undefined;
    message.geoLocationArray = (object.geoLocationArray !== undefined && object.geoLocationArray !== null)
      ? GeoLocationArray.fromPartial(object.geoLocationArray)
      : undefined;
    message.boolValue = (object.boolValue !== undefined && object.boolValue !== null)
      ? BoolValue.fromPartial(object.boolValue)
      : undefined;
    message.field = object.field ?? "";
    message.fetchMatchedAnnotations = object.fetchMatchedAnnotations ?? false;
    return message;
  },
};

function createBasePartition(): Partition {
  return { temporalPartition: undefined, spatialPartition: undefined, relativeTemporalPartition: undefined };
}

export const Partition: MessageFns<Partition> = {
  encode(message: Partition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.temporalPartition !== undefined) {
      Partition_TemporalPartition.encode(message.temporalPartition, writer.uint32(10).fork()).join();
    }
    if (message.spatialPartition !== undefined) {
      Partition_SpatialPartition.encode(message.spatialPartition, writer.uint32(18).fork()).join();
    }
    if (message.relativeTemporalPartition !== undefined) {
      Partition_RelativeTemporalPartition.encode(message.relativeTemporalPartition, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Partition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.temporalPartition = Partition_TemporalPartition.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spatialPartition = Partition_SpatialPartition.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.relativeTemporalPartition = Partition_RelativeTemporalPartition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Partition {
    return {
      temporalPartition: isSet(object.temporalPartition)
        ? Partition_TemporalPartition.fromJSON(object.temporalPartition)
        : undefined,
      spatialPartition: isSet(object.spatialPartition)
        ? Partition_SpatialPartition.fromJSON(object.spatialPartition)
        : undefined,
      relativeTemporalPartition: isSet(object.relativeTemporalPartition)
        ? Partition_RelativeTemporalPartition.fromJSON(object.relativeTemporalPartition)
        : undefined,
    };
  },

  toJSON(message: Partition): unknown {
    const obj: any = {};
    if (message.temporalPartition !== undefined) {
      obj.temporalPartition = Partition_TemporalPartition.toJSON(message.temporalPartition);
    }
    if (message.spatialPartition !== undefined) {
      obj.spatialPartition = Partition_SpatialPartition.toJSON(message.spatialPartition);
    }
    if (message.relativeTemporalPartition !== undefined) {
      obj.relativeTemporalPartition = Partition_RelativeTemporalPartition.toJSON(message.relativeTemporalPartition);
    }
    return obj;
  },

  create(base?: DeepPartial<Partition>): Partition {
    return Partition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Partition>): Partition {
    const message = createBasePartition();
    message.temporalPartition = (object.temporalPartition !== undefined && object.temporalPartition !== null)
      ? Partition_TemporalPartition.fromPartial(object.temporalPartition)
      : undefined;
    message.spatialPartition = (object.spatialPartition !== undefined && object.spatialPartition !== null)
      ? Partition_SpatialPartition.fromPartial(object.spatialPartition)
      : undefined;
    message.relativeTemporalPartition =
      (object.relativeTemporalPartition !== undefined && object.relativeTemporalPartition !== null)
        ? Partition_RelativeTemporalPartition.fromPartial(object.relativeTemporalPartition)
        : undefined;
    return message;
  },
};

function createBasePartition_TemporalPartition(): Partition_TemporalPartition {
  return { startTime: undefined, endTime: undefined };
}

export const Partition_TemporalPartition: MessageFns<Partition_TemporalPartition> = {
  encode(message: Partition_TemporalPartition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Partition_TemporalPartition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartition_TemporalPartition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Partition_TemporalPartition {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: Partition_TemporalPartition): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Partition_TemporalPartition>): Partition_TemporalPartition {
    return Partition_TemporalPartition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Partition_TemporalPartition>): Partition_TemporalPartition {
    const message = createBasePartition_TemporalPartition();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBasePartition_SpatialPartition(): Partition_SpatialPartition {
  return { xMin: undefined, yMin: undefined, xMax: undefined, yMax: undefined };
}

export const Partition_SpatialPartition: MessageFns<Partition_SpatialPartition> = {
  encode(message: Partition_SpatialPartition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.xMin !== undefined) {
      writer.uint32(8).int64(message.xMin.toString());
    }
    if (message.yMin !== undefined) {
      writer.uint32(16).int64(message.yMin.toString());
    }
    if (message.xMax !== undefined) {
      writer.uint32(24).int64(message.xMax.toString());
    }
    if (message.yMax !== undefined) {
      writer.uint32(32).int64(message.yMax.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Partition_SpatialPartition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartition_SpatialPartition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.xMin = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.yMin = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.xMax = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.yMax = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Partition_SpatialPartition {
    return {
      xMin: isSet(object.xMin) ? Long.fromValue(object.xMin) : undefined,
      yMin: isSet(object.yMin) ? Long.fromValue(object.yMin) : undefined,
      xMax: isSet(object.xMax) ? Long.fromValue(object.xMax) : undefined,
      yMax: isSet(object.yMax) ? Long.fromValue(object.yMax) : undefined,
    };
  },

  toJSON(message: Partition_SpatialPartition): unknown {
    const obj: any = {};
    if (message.xMin !== undefined) {
      obj.xMin = (message.xMin || Long.ZERO).toString();
    }
    if (message.yMin !== undefined) {
      obj.yMin = (message.yMin || Long.ZERO).toString();
    }
    if (message.xMax !== undefined) {
      obj.xMax = (message.xMax || Long.ZERO).toString();
    }
    if (message.yMax !== undefined) {
      obj.yMax = (message.yMax || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Partition_SpatialPartition>): Partition_SpatialPartition {
    return Partition_SpatialPartition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Partition_SpatialPartition>): Partition_SpatialPartition {
    const message = createBasePartition_SpatialPartition();
    message.xMin = (object.xMin !== undefined && object.xMin !== null) ? Long.fromValue(object.xMin) : undefined;
    message.yMin = (object.yMin !== undefined && object.yMin !== null) ? Long.fromValue(object.yMin) : undefined;
    message.xMax = (object.xMax !== undefined && object.xMax !== null) ? Long.fromValue(object.xMax) : undefined;
    message.yMax = (object.yMax !== undefined && object.yMax !== null) ? Long.fromValue(object.yMax) : undefined;
    return message;
  },
};

function createBasePartition_RelativeTemporalPartition(): Partition_RelativeTemporalPartition {
  return { startOffset: undefined, endOffset: undefined };
}

export const Partition_RelativeTemporalPartition: MessageFns<Partition_RelativeTemporalPartition> = {
  encode(message: Partition_RelativeTemporalPartition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startOffset !== undefined) {
      Duration.encode(message.startOffset, writer.uint32(10).fork()).join();
    }
    if (message.endOffset !== undefined) {
      Duration.encode(message.endOffset, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Partition_RelativeTemporalPartition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartition_RelativeTemporalPartition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startOffset = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endOffset = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Partition_RelativeTemporalPartition {
    return {
      startOffset: isSet(object.startOffset) ? Duration.fromJSON(object.startOffset) : undefined,
      endOffset: isSet(object.endOffset) ? Duration.fromJSON(object.endOffset) : undefined,
    };
  },

  toJSON(message: Partition_RelativeTemporalPartition): unknown {
    const obj: any = {};
    if (message.startOffset !== undefined) {
      obj.startOffset = Duration.toJSON(message.startOffset);
    }
    if (message.endOffset !== undefined) {
      obj.endOffset = Duration.toJSON(message.endOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<Partition_RelativeTemporalPartition>): Partition_RelativeTemporalPartition {
    return Partition_RelativeTemporalPartition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Partition_RelativeTemporalPartition>): Partition_RelativeTemporalPartition {
    const message = createBasePartition_RelativeTemporalPartition();
    message.startOffset = (object.startOffset !== undefined && object.startOffset !== null)
      ? Duration.fromPartial(object.startOffset)
      : undefined;
    message.endOffset = (object.endOffset !== undefined && object.endOffset !== null)
      ? Duration.fromPartial(object.endOffset)
      : undefined;
    return message;
  },
};

/** Service that manages media content + metadata for streaming. */
export type WarehouseDefinition = typeof WarehouseDefinition;
export const WarehouseDefinition = {
  name: "Warehouse",
  fullName: "google.cloud.visionai.v1.Warehouse",
  methods: {
    /** Creates an asset inside corpus. */
    createAsset: {
      name: "CreateAsset",
      requestType: CreateAssetRequest,
      requestStream: false,
      responseType: Asset,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              97,
              115,
              115,
              101,
              116,
              44,
              97,
              115,
              115,
              101,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              61,
              58,
              5,
              97,
              115,
              115,
              101,
              116,
              34,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates an asset inside corpus. */
    updateAsset: {
      name: "UpdateAsset",
      requestType: UpdateAssetRequest,
      requestStream: false,
      responseType: Asset,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([17, 97, 115, 115, 101, 116, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              67,
              58,
              5,
              97,
              115,
              115,
              101,
              116,
              50,
              58,
              47,
              118,
              49,
              47,
              123,
              97,
              115,
              115,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Reads an asset inside corpus. */
    getAsset: {
      name: "GetAsset",
      requestType: GetAssetRequest,
      requestStream: false,
      responseType: Asset,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists an list of assets inside corpus. */
    listAssets: {
      name: "ListAssets",
      requestType: ListAssetsRequest,
      requestStream: false,
      responseType: ListAssetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes asset inside corpus. */
    deleteAsset: {
      name: "DeleteAsset",
      requestType: DeleteAssetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              44,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              19,
              68,
              101,
              108,
              101,
              116,
              101,
              65,
              115,
              115,
              101,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              42,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Upload asset by specifing the asset Cloud Storage uri.
     * For video warehouse, it requires users who call this API have read access
     * to the cloud storage file. Once it is uploaded, it can be retrieved by
     * GenerateRetrievalUrl API which by default, only can retrieve cloud storage
     * files from the same project of the warehouse. To allow retrieval cloud
     * storage files that are in a separate project, it requires to find the
     * vision ai service account (Go to IAM, check checkbox to show "Include
     * Google-provided role grants", search for "Cloud Vision AI Service Agent")
     * and grant the read access of the cloud storage files to that service
     * account.
     */
    uploadAsset: {
      name: "UploadAsset",
      requestType: UploadAssetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              19,
              85,
              112,
              108,
              111,
              97,
              100,
              65,
              115,
              115,
              101,
              116,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              19,
              85,
              112,
              108,
              111,
              97,
              100,
              65,
              115,
              115,
              101,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              64,
              58,
              1,
              42,
              34,
              59,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              117,
              112,
              108,
              111,
              97,
              100,
            ]),
          ],
        },
      },
    },
    /**
     * Generates a signed url for downloading the asset.
     * For video warehouse, please see comment of UploadAsset about how to allow
     * retrieval of cloud storage files in a different project.
     */
    generateRetrievalUrl: {
      name: "GenerateRetrievalUrl",
      requestType: GenerateRetrievalUrlRequest,
      requestStream: false,
      responseType: GenerateRetrievalUrlResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              78,
              58,
              1,
              42,
              34,
              73,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              82,
              101,
              116,
              114,
              105,
              101,
              118,
              97,
              108,
              85,
              114,
              108,
            ]),
          ],
        },
      },
    },
    /** Analyze asset to power search capability. */
    analyzeAsset: {
      name: "AnalyzeAsset",
      requestType: AnalyzeAssetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              44,
              10,
              20,
              65,
              110,
              97,
              108,
              121,
              122,
              101,
              65,
              115,
              115,
              101,
              116,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              20,
              65,
              110,
              97,
              108,
              121,
              122,
              101,
              65,
              115,
              115,
              101,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              65,
              58,
              1,
              42,
              34,
              60,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              110,
              97,
              108,
              121,
              122,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Index one asset for search.
     * Supported corpus type: Corpus.Type.VIDEO_ON_DEMAND
     */
    indexAsset: {
      name: "IndexAsset",
      requestType: IndexAssetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              40,
              10,
              18,
              73,
              110,
              100,
              101,
              120,
              65,
              115,
              115,
              101,
              116,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              18,
              73,
              110,
              100,
              101,
              120,
              65,
              115,
              115,
              101,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              63,
              58,
              1,
              42,
              34,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              105,
              110,
              100,
              101,
              120,
            ]),
          ],
        },
      },
    },
    /**
     * Remove one asset's index data for search.
     * Supported corpus type: Corpus.Type.VIDEO_ON_DEMAND
     */
    removeIndexAsset: {
      name: "RemoveIndexAsset",
      requestType: RemoveIndexAssetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              52,
              10,
              24,
              82,
              101,
              109,
              111,
              118,
              101,
              73,
              110,
              100,
              101,
              120,
              65,
              115,
              115,
              101,
              116,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              24,
              82,
              101,
              109,
              111,
              118,
              101,
              73,
              110,
              100,
              101,
              120,
              65,
              115,
              115,
              101,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              109,
              111,
              118,
              101,
              73,
              110,
              100,
              101,
              120,
            ]),
          ],
        },
      },
    },
    /** Lists assets inside an index. */
    viewIndexedAssets: {
      name: "ViewIndexedAssets",
      requestType: ViewIndexedAssetsRequest,
      requestStream: false,
      responseType: ViewIndexedAssetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([5, 105, 110, 100, 101, 120])],
          578365826: [
            Buffer.from([
              67,
              18,
              65,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              100,
              101,
              120,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
              47,
              42,
              125,
              58,
              118,
              105,
              101,
              119,
              65,
              115,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates an Index under the corpus. */
    createIndex: {
      name: "CreateIndex",
      requestType: CreateIndexRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              5,
              73,
              110,
              100,
              101,
              120,
              18,
              19,
              67,
              114,
              101,
              97,
              116,
              101,
              73,
              110,
              100,
              101,
              120,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              21,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              105,
              110,
              100,
              101,
              120,
              44,
              105,
              110,
              100,
              101,
              120,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              62,
              58,
              5,
              105,
              110,
              100,
              101,
              120,
              34,
              53,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates an Index under the corpus.
     * Users can perform a metadata-only update or trigger a full index rebuild
     * with different update_mask values.
     */
    updateIndex: {
      name: "UpdateIndex",
      requestType: UpdateIndexRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              5,
              73,
              110,
              100,
              101,
              120,
              18,
              19,
              85,
              112,
              100,
              97,
              116,
              101,
              73,
              110,
              100,
              101,
              120,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([17, 105, 110, 100, 101, 120, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              68,
              58,
              5,
              105,
              110,
              100,
              101,
              120,
              50,
              59,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              100,
              101,
              120,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a single Index under a Corpus. */
    getIndex: {
      name: "GetIndex",
      requestType: GetIndexRequest,
      requestStream: false,
      responseType: Index,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** List all Indexes in a given Corpus. */
    listIndexes: {
      name: "ListIndexes",
      requestType: ListIndexesRequest,
      requestStream: false,
      responseType: ListIndexesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Delete a single Index. In order to delete an index, the caller must
     * make sure that it is not deployed to any index endpoint.
     */
    deleteIndex: {
      name: "DeleteIndex",
      requestType: DeleteIndexRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              44,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              19,
              68,
              101,
              108,
              101,
              116,
              101,
              73,
              110,
              100,
              101,
              120,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              42,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a corpus inside a project. */
    createCorpus: {
      name: "CreateCorpus",
      requestType: CreateCorpusRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              30,
              10,
              6,
              67,
              111,
              114,
              112,
              117,
              115,
              18,
              20,
              67,
              114,
              101,
              97,
              116,
              101,
              67,
              111,
              114,
              112,
              117,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([13, 112, 97, 114, 101, 110, 116, 44, 99, 111, 114, 112, 117, 115])],
          578365826: [
            Buffer.from([
              53,
              58,
              6,
              99,
              111,
              114,
              112,
              117,
              115,
              34,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
            ]),
          ],
        },
      },
    },
    /** Gets corpus details inside a project. */
    getCorpus: {
      name: "GetCorpus",
      requestType: GetCorpusRequest,
      requestStream: false,
      responseType: Corpus,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates a corpus in a project. */
    updateCorpus: {
      name: "UpdateCorpus",
      requestType: UpdateCorpusRequest,
      requestStream: false,
      responseType: Corpus,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 99, 111, 114, 112, 117, 115, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              60,
              58,
              6,
              99,
              111,
              114,
              112,
              117,
              115,
              50,
              50,
              47,
              118,
              49,
              47,
              123,
              99,
              111,
              114,
              112,
              117,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all corpora in a project. */
    listCorpora: {
      name: "ListCorpora",
      requestType: ListCorporaRequest,
      requestStream: false,
      responseType: ListCorporaResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a corpus only if its empty.
     * Returns empty response.
     */
    deleteCorpus: {
      name: "DeleteCorpus",
      requestType: DeleteCorpusRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              42,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Analyzes a corpus. */
    analyzeCorpus: {
      name: "AnalyzeCorpus",
      requestType: AnalyzeCorpusRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              46,
              10,
              21,
              65,
              110,
              97,
              108,
              121,
              122,
              101,
              67,
              111,
              114,
              112,
              117,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              21,
              65,
              110,
              97,
              108,
              121,
              122,
              101,
              67,
              111,
              114,
              112,
              117,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              56,
              58,
              1,
              42,
              34,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              58,
              97,
              110,
              97,
              108,
              121,
              122,
              101,
            ]),
          ],
        },
      },
    },
    /** Creates data schema inside corpus. */
    createDataSchema: {
      name: "CreateDataSchema",
      requestType: CreateDataSchemaRequest,
      requestStream: false,
      responseType: DataSchema,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([18, 112, 97, 114, 101, 110, 116, 44, 100, 97, 116, 97, 95, 115, 99, 104, 101, 109, 97])],
          578365826: [
            Buffer.from([
              72,
              58,
              11,
              100,
              97,
              116,
              97,
              95,
              115,
              99,
              104,
              101,
              109,
              97,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              83,
              99,
              104,
              101,
              109,
              97,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates data schema inside corpus. */
    updateDataSchema: {
      name: "UpdateDataSchema",
      requestType: UpdateDataSchemaRequest,
      requestStream: false,
      responseType: DataSchema,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              100,
              97,
              116,
              97,
              95,
              115,
              99,
              104,
              101,
              109,
              97,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              84,
              58,
              11,
              100,
              97,
              116,
              97,
              95,
              115,
              99,
              104,
              101,
              109,
              97,
              50,
              69,
              47,
              118,
              49,
              47,
              123,
              100,
              97,
              116,
              97,
              95,
              115,
              99,
              104,
              101,
              109,
              97,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              99,
              104,
              101,
              109,
              97,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets data schema inside corpus. */
    getDataSchema: {
      name: "GetDataSchema",
      requestType: GetDataSchemaRequest,
      requestStream: false,
      responseType: DataSchema,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              99,
              104,
              101,
              109,
              97,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes data schema inside corpus. */
    deleteDataSchema: {
      name: "DeleteDataSchema",
      requestType: DeleteDataSchemaRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              42,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              99,
              104,
              101,
              109,
              97,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists a list of data schemas inside corpus. */
    listDataSchemas: {
      name: "ListDataSchemas",
      requestType: ListDataSchemasRequest,
      requestStream: false,
      responseType: ListDataSchemasResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              83,
              99,
              104,
              101,
              109,
              97,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates annotation inside asset. */
    createAnnotation: {
      name: "CreateAnnotation",
      requestType: CreateAnnotationRequest,
      requestStream: false,
      responseType: Annotation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              44,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              80,
              58,
              10,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              34,
              66,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Reads annotation inside asset. */
    getAnnotation: {
      name: "GetAnnotation",
      requestType: GetAnnotationRequest,
      requestStream: false,
      responseType: Annotation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              68,
              18,
              66,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists a list of annotations inside asset. */
    listAnnotations: {
      name: "ListAnnotations",
      requestType: ListAnnotationsRequest,
      requestStream: false,
      responseType: ListAnnotationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              68,
              18,
              66,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates annotation inside asset. */
    updateAnnotation: {
      name: "UpdateAnnotation",
      requestType: UpdateAnnotationRequest,
      requestStream: false,
      responseType: Annotation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              91,
              58,
              10,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              50,
              77,
              47,
              118,
              49,
              47,
              123,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes annotation inside asset. */
    deleteAnnotation: {
      name: "DeleteAnnotation",
      requestType: DeleteAnnotationRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              68,
              42,
              66,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              47,
              97,
              110,
              110,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Ingests data for the asset. It is not allowed to ingest a data chunk which
     * is already expired according to TTL.
     * This method is only available via the gRPC API (not HTTP since
     * bi-directional streaming is not supported via HTTP).
     */
    ingestAsset: {
      name: "IngestAsset",
      requestType: IngestAssetRequest,
      requestStream: true,
      responseType: IngestAssetResponse,
      responseStream: true,
      options: {},
    },
    /**
     * Supported by STREAM_VIDEO corpus type.
     * Generates clips for downloading. The api takes in a time range, and
     * generates a clip of the first content available after start_time and
     * before end_time, which may overflow beyond these bounds.
     * Returned clips are truncated if the total size of the clips are larger
     * than 100MB.
     */
    clipAsset: {
      name: "ClipAsset",
      requestType: ClipAssetRequest,
      requestStream: false,
      responseType: ClipAssetResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              62,
              58,
              1,
              42,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              99,
              108,
              105,
              112,
            ]),
          ],
        },
      },
    },
    /**
     * Generates a uri for an HLS manifest. The api takes in a collection of time
     * ranges, and generates a URI for an HLS manifest that covers all the
     * requested time ranges.
     */
    generateHlsUri: {
      name: "GenerateHlsUri",
      requestType: GenerateHlsUriRequest,
      requestStream: false,
      responseType: GenerateHlsUriResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              72,
              58,
              1,
              42,
              34,
              67,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              72,
              108,
              115,
              85,
              114,
              105,
            ]),
          ],
        },
      },
    },
    /**
     * Imports assets (images plus annotations) from a meta file on cloud storage.
     * Each row in the meta file is corresponding to an image (specified by a
     * cloud storage uri) and its annotations.
     */
    importAssets: {
      name: "ImportAssets",
      requestType: ImportAssetsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              44,
              10,
              20,
              73,
              109,
              112,
              111,
              114,
              116,
              65,
              115,
              115,
              101,
              116,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              20,
              73,
              109,
              112,
              111,
              114,
              116,
              65,
              115,
              115,
              101,
              116,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              64,
              58,
              1,
              42,
              34,
              59,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              58,
              105,
              109,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a search configuration inside a corpus.
     *
     * Please follow the rules below to create a valid CreateSearchConfigRequest.
     * --- General Rules ---
     * 1. Request.search_config_id must not be associated with an existing
     *    SearchConfig.
     * 2. Request must contain at least one non-empty search_criteria_property or
     *    facet_property.
     * 3. mapped_fields must not be empty, and must map to existing UGA keys.
     * 4. All mapped_fields must be of the same type.
     * 5. All mapped_fields must share the same granularity.
     * 6. All mapped_fields must share the same semantic SearchConfig match
     *    options.
     * For property-specific rules, please reference the comments for
     * FacetProperty and SearchCriteriaProperty.
     */
    createSearchConfig: {
      name: "CreateSearchConfig",
      requestType: CreateSearchConfigRequest,
      requestStream: false,
      responseType: SearchConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              37,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              76,
              58,
              13,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              34,
              59,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a search configuration inside a corpus.
     *
     * Please follow the rules below to create a valid UpdateSearchConfigRequest.
     * --- General Rules ---
     * 1. Request.search_configuration.name must already exist.
     * 2. Request must contain at least one non-empty search_criteria_property or
     * facet_property.
     * 3. mapped_fields must not be empty, and must map to existing UGA keys.
     * 4. All mapped_fields must be of the same type.
     * 5. All mapped_fields must share the same granularity.
     * 6. All mapped_fields must share the same semantic SearchConfig match
     *    options.
     * For property-specific rules, please reference the comments for
     * FacetProperty and SearchCriteriaProperty.
     */
    updateSearchConfig: {
      name: "UpdateSearchConfig",
      requestType: UpdateSearchConfigRequest,
      requestStream: false,
      responseType: SearchConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              25,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              90,
              58,
              13,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              50,
              73,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets a search configuration inside a corpus. */
    getSearchConfig: {
      name: "GetSearchConfig",
      requestType: GetSearchConfigRequest,
      requestStream: false,
      responseType: SearchConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a search configuration inside a corpus.
     *
     * For a DeleteSearchConfigRequest to be valid,
     * Request.search_configuration.name must already exist.
     */
    deleteSearchConfig: {
      name: "DeleteSearchConfig",
      requestType: DeleteSearchConfigRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              61,
              42,
              59,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all search configurations inside a corpus. */
    listSearchConfigs: {
      name: "ListSearchConfigs",
      requestType: ListSearchConfigsRequest,
      requestStream: false,
      responseType: ListSearchConfigsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates a SearchHypernym inside a corpus. */
    createSearchHypernym: {
      name: "CreateSearchHypernym",
      requestType: CreateSearchHypernymRequest,
      requestStream: false,
      responseType: SearchHypernym,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              41,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              104,
              121,
              112,
              101,
              114,
              110,
              121,
              109,
              44,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              104,
              121,
              112,
              101,
              114,
              110,
              121,
              109,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              80,
              58,
              15,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              104,
              121,
              112,
              101,
              114,
              110,
              121,
              109,
              34,
              61,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              72,
              121,
              112,
              101,
              114,
              110,
              121,
              109,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a SearchHypernym inside a corpus. */
    updateSearchHypernym: {
      name: "UpdateSearchHypernym",
      requestType: UpdateSearchHypernymRequest,
      requestStream: false,
      responseType: SearchHypernym,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              27,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              104,
              121,
              112,
              101,
              114,
              110,
              121,
              109,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              96,
              58,
              15,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              104,
              121,
              112,
              101,
              114,
              110,
              121,
              109,
              50,
              77,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              97,
              114,
              99,
              104,
              95,
              104,
              121,
              112,
              101,
              114,
              110,
              121,
              109,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              72,
              121,
              112,
              101,
              114,
              110,
              121,
              109,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets a SearchHypernym inside a corpus. */
    getSearchHypernym: {
      name: "GetSearchHypernym",
      requestType: GetSearchHypernymRequest,
      requestStream: false,
      responseType: SearchHypernym,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              63,
              18,
              61,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              72,
              121,
              112,
              101,
              114,
              110,
              121,
              109,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a SearchHypernym inside a corpus. */
    deleteSearchHypernym: {
      name: "DeleteSearchHypernym",
      requestType: DeleteSearchHypernymRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              63,
              42,
              61,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              72,
              121,
              112,
              101,
              114,
              110,
              121,
              109,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists SearchHypernyms inside a corpus. */
    listSearchHypernyms: {
      name: "ListSearchHypernyms",
      requestType: ListSearchHypernymsRequest,
      requestStream: false,
      responseType: ListSearchHypernymsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              63,
              18,
              61,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              115,
              101,
              97,
              114,
              99,
              104,
              72,
              121,
              112,
              101,
              114,
              110,
              121,
              109,
              115,
            ]),
          ],
        },
      },
    },
    /** Search media asset. */
    searchAssets: {
      name: "SearchAssets",
      requestType: SearchAssetsRequest,
      requestStream: false,
      responseType: SearchAssetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              63,
              58,
              1,
              42,
              34,
              58,
              47,
              118,
              49,
              47,
              123,
              99,
              111,
              114,
              112,
              117,
              115,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              65,
              115,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Search a deployed index endpoint (IMAGE corpus type only). */
    searchIndexEndpoint: {
      name: "SearchIndexEndpoint",
      requestType: SearchIndexEndpointRequest,
      requestStream: false,
      responseType: SearchIndexEndpointResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              85,
              58,
              1,
              42,
              34,
              80,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              100,
              101,
              120,
              95,
              101,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              73,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
            ]),
          ],
        },
      },
    },
    /** Creates an IndexEndpoint. */
    createIndexEndpoint: {
      name: "CreateIndexEndpoint",
      requestType: CreateIndexEndpointRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              44,
              10,
              13,
              73,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              18,
              27,
              67,
              114,
              101,
              97,
              116,
              101,
              73,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              39,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              105,
              110,
              100,
              101,
              120,
              95,
              101,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              44,
              105,
              110,
              100,
              101,
              120,
              95,
              101,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              14,
              105,
              110,
              100,
              101,
              120,
              95,
              101,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              34,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets an IndexEndpoint. */
    getIndexEndpoint: {
      name: "GetIndexEndpoint",
      requestType: GetIndexEndpointRequest,
      requestStream: false,
      responseType: IndexEndpoint,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all IndexEndpoints in a project. */
    listIndexEndpoints: {
      name: "ListIndexEndpoints",
      requestType: ListIndexEndpointsRequest,
      requestStream: false,
      responseType: ListIndexEndpointsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates an IndexEndpoint. */
    updateIndexEndpoint: {
      name: "UpdateIndexEndpoint",
      requestType: UpdateIndexEndpointRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              44,
              10,
              13,
              73,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              18,
              27,
              85,
              112,
              100,
              97,
              116,
              101,
              73,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              26,
              105,
              110,
              100,
              101,
              120,
              95,
              101,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              83,
              58,
              14,
              105,
              110,
              100,
              101,
              120,
              95,
              101,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              50,
              65,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              100,
              101,
              120,
              95,
              101,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes an IndexEndpoint. */
    deleteIndexEndpoint: {
      name: "DeleteIndexEndpoint",
      requestType: DeleteIndexEndpointRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              52,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              27,
              68,
              101,
              108,
              101,
              116,
              101,
              73,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              42,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deploys an Index to IndexEndpoint. */
    deployIndex: {
      name: "DeployIndex",
      requestType: DeployIndexRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              19,
              68,
              101,
              112,
              108,
              111,
              121,
              73,
              110,
              100,
              101,
              120,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              19,
              68,
              101,
              112,
              108,
              111,
              121,
              73,
              110,
              100,
              101,
              120,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              77,
              58,
              1,
              42,
              34,
              72,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              100,
              101,
              120,
              95,
              101,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              100,
              101,
              112,
              108,
              111,
              121,
              73,
              110,
              100,
              101,
              120,
            ]),
          ],
        },
      },
    },
    /** Undeploys an Index from IndexEndpoint. */
    undeployIndex: {
      name: "UndeployIndex",
      requestType: UndeployIndexRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              46,
              10,
              21,
              85,
              110,
              100,
              101,
              112,
              108,
              111,
              121,
              73,
              110,
              100,
              101,
              120,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              21,
              85,
              110,
              100,
              101,
              112,
              108,
              111,
              121,
              73,
              110,
              100,
              101,
              120,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              79,
              58,
              1,
              42,
              34,
              74,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              100,
              101,
              120,
              95,
              101,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              69,
              110,
              100,
              112,
              111,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              117,
              110,
              100,
              101,
              112,
              108,
              111,
              121,
              73,
              110,
              100,
              101,
              120,
            ]),
          ],
        },
      },
    },
    /** Creates a collection. */
    createCollection: {
      name: "CreateCollection",
      requestType: CreateCollectionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              10,
              67,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              18,
              24,
              67,
              114,
              101,
              97,
              116,
              101,
              67,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              44,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              10,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a collection. */
    deleteCollection: {
      name: "DeleteCollection",
      requestType: DeleteCollectionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              49,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              24,
              68,
              101,
              108,
              101,
              116,
              101,
              67,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              42,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets a collection. */
    getCollection: {
      name: "GetCollection",
      requestType: GetCollectionRequest,
      requestStream: false,
      responseType: Collection,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates a collection. */
    updateCollection: {
      name: "UpdateCollection",
      requestType: UpdateCollectionRequest,
      requestStream: false,
      responseType: Collection,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              82,
              58,
              10,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              50,
              68,
              47,
              118,
              49,
              47,
              123,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists collections inside a corpus. */
    listCollections: {
      name: "ListCollections",
      requestType: ListCollectionsRequest,
      requestStream: false,
      responseType: ListCollectionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Adds an item into a Collection. */
    addCollectionItem: {
      name: "AddCollectionItem",
      requestType: AddCollectionItemRequest,
      requestStream: false,
      responseType: AddCollectionItemResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 105, 116, 101, 109])],
          578365826: [
            Buffer.from([
              91,
              58,
              1,
              42,
              34,
              86,
              47,
              118,
              49,
              47,
              123,
              105,
              116,
              101,
              109,
              46,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              97,
              100,
              100,
              67,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              73,
              116,
              101,
              109,
            ]),
          ],
        },
      },
    },
    /** Removes an item from a collection. */
    removeCollectionItem: {
      name: "RemoveCollectionItem",
      requestType: RemoveCollectionItemRequest,
      requestStream: false,
      responseType: RemoveCollectionItemResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 105, 116, 101, 109])],
          578365826: [
            Buffer.from([
              94,
              58,
              1,
              42,
              34,
              89,
              47,
              118,
              49,
              47,
              123,
              105,
              116,
              101,
              109,
              46,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              109,
              111,
              118,
              101,
              67,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              73,
              116,
              101,
              109,
            ]),
          ],
        },
      },
    },
    /** View items inside a collection. */
    viewCollectionItems: {
      name: "ViewCollectionItems",
      requestType: ViewCollectionItemsRequest,
      requestStream: false,
      responseType: ViewCollectionItemsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([10, 99, 111, 108, 108, 101, 99, 116, 105, 111, 110])],
          578365826: [
            Buffer.from([
              85,
              18,
              83,
              47,
              118,
              49,
              47,
              123,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              118,
              105,
              101,
              119,
              67,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              73,
              116,
              101,
              109,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface WarehouseServiceImplementation<CallContextExt = {}> {
  /** Creates an asset inside corpus. */
  createAsset(request: CreateAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Asset>>;
  /** Updates an asset inside corpus. */
  updateAsset(request: UpdateAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Asset>>;
  /** Reads an asset inside corpus. */
  getAsset(request: GetAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Asset>>;
  /** Lists an list of assets inside corpus. */
  listAssets(
    request: ListAssetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAssetsResponse>>;
  /** Deletes asset inside corpus. */
  deleteAsset(request: DeleteAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Upload asset by specifing the asset Cloud Storage uri.
   * For video warehouse, it requires users who call this API have read access
   * to the cloud storage file. Once it is uploaded, it can be retrieved by
   * GenerateRetrievalUrl API which by default, only can retrieve cloud storage
   * files from the same project of the warehouse. To allow retrieval cloud
   * storage files that are in a separate project, it requires to find the
   * vision ai service account (Go to IAM, check checkbox to show "Include
   * Google-provided role grants", search for "Cloud Vision AI Service Agent")
   * and grant the read access of the cloud storage files to that service
   * account.
   */
  uploadAsset(request: UploadAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Generates a signed url for downloading the asset.
   * For video warehouse, please see comment of UploadAsset about how to allow
   * retrieval of cloud storage files in a different project.
   */
  generateRetrievalUrl(
    request: GenerateRetrievalUrlRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateRetrievalUrlResponse>>;
  /** Analyze asset to power search capability. */
  analyzeAsset(request: AnalyzeAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Index one asset for search.
   * Supported corpus type: Corpus.Type.VIDEO_ON_DEMAND
   */
  indexAsset(request: IndexAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Remove one asset's index data for search.
   * Supported corpus type: Corpus.Type.VIDEO_ON_DEMAND
   */
  removeIndexAsset(
    request: RemoveIndexAssetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists assets inside an index. */
  viewIndexedAssets(
    request: ViewIndexedAssetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ViewIndexedAssetsResponse>>;
  /** Creates an Index under the corpus. */
  createIndex(request: CreateIndexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Updates an Index under the corpus.
   * Users can perform a metadata-only update or trigger a full index rebuild
   * with different update_mask values.
   */
  updateIndex(request: UpdateIndexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Gets the details of a single Index under a Corpus. */
  getIndex(request: GetIndexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Index>>;
  /** List all Indexes in a given Corpus. */
  listIndexes(
    request: ListIndexesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListIndexesResponse>>;
  /**
   * Delete a single Index. In order to delete an index, the caller must
   * make sure that it is not deployed to any index endpoint.
   */
  deleteIndex(request: DeleteIndexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Creates a corpus inside a project. */
  createCorpus(request: CreateCorpusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Gets corpus details inside a project. */
  getCorpus(request: GetCorpusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Corpus>>;
  /** Updates a corpus in a project. */
  updateCorpus(request: UpdateCorpusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Corpus>>;
  /** Lists all corpora in a project. */
  listCorpora(
    request: ListCorporaRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCorporaResponse>>;
  /**
   * Deletes a corpus only if its empty.
   * Returns empty response.
   */
  deleteCorpus(request: DeleteCorpusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Analyzes a corpus. */
  analyzeCorpus(request: AnalyzeCorpusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Creates data schema inside corpus. */
  createDataSchema(
    request: CreateDataSchemaRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DataSchema>>;
  /** Updates data schema inside corpus. */
  updateDataSchema(
    request: UpdateDataSchemaRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DataSchema>>;
  /** Gets data schema inside corpus. */
  getDataSchema(request: GetDataSchemaRequest, context: CallContext & CallContextExt): Promise<DeepPartial<DataSchema>>;
  /** Deletes data schema inside corpus. */
  deleteDataSchema(
    request: DeleteDataSchemaRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Lists a list of data schemas inside corpus. */
  listDataSchemas(
    request: ListDataSchemasRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDataSchemasResponse>>;
  /** Creates annotation inside asset. */
  createAnnotation(
    request: CreateAnnotationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Annotation>>;
  /** Reads annotation inside asset. */
  getAnnotation(request: GetAnnotationRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Annotation>>;
  /** Lists a list of annotations inside asset. */
  listAnnotations(
    request: ListAnnotationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAnnotationsResponse>>;
  /** Updates annotation inside asset. */
  updateAnnotation(
    request: UpdateAnnotationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Annotation>>;
  /** Deletes annotation inside asset. */
  deleteAnnotation(
    request: DeleteAnnotationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Ingests data for the asset. It is not allowed to ingest a data chunk which
   * is already expired according to TTL.
   * This method is only available via the gRPC API (not HTTP since
   * bi-directional streaming is not supported via HTTP).
   */
  ingestAsset(
    request: AsyncIterable<IngestAssetRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<IngestAssetResponse>>;
  /**
   * Supported by STREAM_VIDEO corpus type.
   * Generates clips for downloading. The api takes in a time range, and
   * generates a clip of the first content available after start_time and
   * before end_time, which may overflow beyond these bounds.
   * Returned clips are truncated if the total size of the clips are larger
   * than 100MB.
   */
  clipAsset(request: ClipAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ClipAssetResponse>>;
  /**
   * Generates a uri for an HLS manifest. The api takes in a collection of time
   * ranges, and generates a URI for an HLS manifest that covers all the
   * requested time ranges.
   */
  generateHlsUri(
    request: GenerateHlsUriRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateHlsUriResponse>>;
  /**
   * Imports assets (images plus annotations) from a meta file on cloud storage.
   * Each row in the meta file is corresponding to an image (specified by a
   * cloud storage uri) and its annotations.
   */
  importAssets(request: ImportAssetsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Creates a search configuration inside a corpus.
   *
   * Please follow the rules below to create a valid CreateSearchConfigRequest.
   * --- General Rules ---
   * 1. Request.search_config_id must not be associated with an existing
   *    SearchConfig.
   * 2. Request must contain at least one non-empty search_criteria_property or
   *    facet_property.
   * 3. mapped_fields must not be empty, and must map to existing UGA keys.
   * 4. All mapped_fields must be of the same type.
   * 5. All mapped_fields must share the same granularity.
   * 6. All mapped_fields must share the same semantic SearchConfig match
   *    options.
   * For property-specific rules, please reference the comments for
   * FacetProperty and SearchCriteriaProperty.
   */
  createSearchConfig(
    request: CreateSearchConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchConfig>>;
  /**
   * Updates a search configuration inside a corpus.
   *
   * Please follow the rules below to create a valid UpdateSearchConfigRequest.
   * --- General Rules ---
   * 1. Request.search_configuration.name must already exist.
   * 2. Request must contain at least one non-empty search_criteria_property or
   * facet_property.
   * 3. mapped_fields must not be empty, and must map to existing UGA keys.
   * 4. All mapped_fields must be of the same type.
   * 5. All mapped_fields must share the same granularity.
   * 6. All mapped_fields must share the same semantic SearchConfig match
   *    options.
   * For property-specific rules, please reference the comments for
   * FacetProperty and SearchCriteriaProperty.
   */
  updateSearchConfig(
    request: UpdateSearchConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchConfig>>;
  /** Gets a search configuration inside a corpus. */
  getSearchConfig(
    request: GetSearchConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchConfig>>;
  /**
   * Deletes a search configuration inside a corpus.
   *
   * For a DeleteSearchConfigRequest to be valid,
   * Request.search_configuration.name must already exist.
   */
  deleteSearchConfig(
    request: DeleteSearchConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Lists all search configurations inside a corpus. */
  listSearchConfigs(
    request: ListSearchConfigsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSearchConfigsResponse>>;
  /** Creates a SearchHypernym inside a corpus. */
  createSearchHypernym(
    request: CreateSearchHypernymRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchHypernym>>;
  /** Updates a SearchHypernym inside a corpus. */
  updateSearchHypernym(
    request: UpdateSearchHypernymRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchHypernym>>;
  /** Gets a SearchHypernym inside a corpus. */
  getSearchHypernym(
    request: GetSearchHypernymRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchHypernym>>;
  /** Deletes a SearchHypernym inside a corpus. */
  deleteSearchHypernym(
    request: DeleteSearchHypernymRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Lists SearchHypernyms inside a corpus. */
  listSearchHypernyms(
    request: ListSearchHypernymsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSearchHypernymsResponse>>;
  /** Search media asset. */
  searchAssets(
    request: SearchAssetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchAssetsResponse>>;
  /** Search a deployed index endpoint (IMAGE corpus type only). */
  searchIndexEndpoint(
    request: SearchIndexEndpointRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchIndexEndpointResponse>>;
  /** Creates an IndexEndpoint. */
  createIndexEndpoint(
    request: CreateIndexEndpointRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Gets an IndexEndpoint. */
  getIndexEndpoint(
    request: GetIndexEndpointRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<IndexEndpoint>>;
  /** Lists all IndexEndpoints in a project. */
  listIndexEndpoints(
    request: ListIndexEndpointsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListIndexEndpointsResponse>>;
  /** Updates an IndexEndpoint. */
  updateIndexEndpoint(
    request: UpdateIndexEndpointRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes an IndexEndpoint. */
  deleteIndexEndpoint(
    request: DeleteIndexEndpointRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deploys an Index to IndexEndpoint. */
  deployIndex(request: DeployIndexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Undeploys an Index from IndexEndpoint. */
  undeployIndex(request: UndeployIndexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Creates a collection. */
  createCollection(
    request: CreateCollectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a collection. */
  deleteCollection(
    request: DeleteCollectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Gets a collection. */
  getCollection(request: GetCollectionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Collection>>;
  /** Updates a collection. */
  updateCollection(
    request: UpdateCollectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Collection>>;
  /** Lists collections inside a corpus. */
  listCollections(
    request: ListCollectionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCollectionsResponse>>;
  /** Adds an item into a Collection. */
  addCollectionItem(
    request: AddCollectionItemRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AddCollectionItemResponse>>;
  /** Removes an item from a collection. */
  removeCollectionItem(
    request: RemoveCollectionItemRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RemoveCollectionItemResponse>>;
  /** View items inside a collection. */
  viewCollectionItems(
    request: ViewCollectionItemsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ViewCollectionItemsResponse>>;
}

export interface WarehouseClient<CallOptionsExt = {}> {
  /** Creates an asset inside corpus. */
  createAsset(request: DeepPartial<CreateAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Asset>;
  /** Updates an asset inside corpus. */
  updateAsset(request: DeepPartial<UpdateAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Asset>;
  /** Reads an asset inside corpus. */
  getAsset(request: DeepPartial<GetAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Asset>;
  /** Lists an list of assets inside corpus. */
  listAssets(
    request: DeepPartial<ListAssetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAssetsResponse>;
  /** Deletes asset inside corpus. */
  deleteAsset(request: DeepPartial<DeleteAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Upload asset by specifing the asset Cloud Storage uri.
   * For video warehouse, it requires users who call this API have read access
   * to the cloud storage file. Once it is uploaded, it can be retrieved by
   * GenerateRetrievalUrl API which by default, only can retrieve cloud storage
   * files from the same project of the warehouse. To allow retrieval cloud
   * storage files that are in a separate project, it requires to find the
   * vision ai service account (Go to IAM, check checkbox to show "Include
   * Google-provided role grants", search for "Cloud Vision AI Service Agent")
   * and grant the read access of the cloud storage files to that service
   * account.
   */
  uploadAsset(request: DeepPartial<UploadAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Generates a signed url for downloading the asset.
   * For video warehouse, please see comment of UploadAsset about how to allow
   * retrieval of cloud storage files in a different project.
   */
  generateRetrievalUrl(
    request: DeepPartial<GenerateRetrievalUrlRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateRetrievalUrlResponse>;
  /** Analyze asset to power search capability. */
  analyzeAsset(request: DeepPartial<AnalyzeAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Index one asset for search.
   * Supported corpus type: Corpus.Type.VIDEO_ON_DEMAND
   */
  indexAsset(request: DeepPartial<IndexAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Remove one asset's index data for search.
   * Supported corpus type: Corpus.Type.VIDEO_ON_DEMAND
   */
  removeIndexAsset(
    request: DeepPartial<RemoveIndexAssetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists assets inside an index. */
  viewIndexedAssets(
    request: DeepPartial<ViewIndexedAssetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ViewIndexedAssetsResponse>;
  /** Creates an Index under the corpus. */
  createIndex(request: DeepPartial<CreateIndexRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Updates an Index under the corpus.
   * Users can perform a metadata-only update or trigger a full index rebuild
   * with different update_mask values.
   */
  updateIndex(request: DeepPartial<UpdateIndexRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Gets the details of a single Index under a Corpus. */
  getIndex(request: DeepPartial<GetIndexRequest>, options?: CallOptions & CallOptionsExt): Promise<Index>;
  /** List all Indexes in a given Corpus. */
  listIndexes(
    request: DeepPartial<ListIndexesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListIndexesResponse>;
  /**
   * Delete a single Index. In order to delete an index, the caller must
   * make sure that it is not deployed to any index endpoint.
   */
  deleteIndex(request: DeepPartial<DeleteIndexRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Creates a corpus inside a project. */
  createCorpus(request: DeepPartial<CreateCorpusRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Gets corpus details inside a project. */
  getCorpus(request: DeepPartial<GetCorpusRequest>, options?: CallOptions & CallOptionsExt): Promise<Corpus>;
  /** Updates a corpus in a project. */
  updateCorpus(request: DeepPartial<UpdateCorpusRequest>, options?: CallOptions & CallOptionsExt): Promise<Corpus>;
  /** Lists all corpora in a project. */
  listCorpora(
    request: DeepPartial<ListCorporaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCorporaResponse>;
  /**
   * Deletes a corpus only if its empty.
   * Returns empty response.
   */
  deleteCorpus(request: DeepPartial<DeleteCorpusRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Analyzes a corpus. */
  analyzeCorpus(request: DeepPartial<AnalyzeCorpusRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Creates data schema inside corpus. */
  createDataSchema(
    request: DeepPartial<CreateDataSchemaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DataSchema>;
  /** Updates data schema inside corpus. */
  updateDataSchema(
    request: DeepPartial<UpdateDataSchemaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DataSchema>;
  /** Gets data schema inside corpus. */
  getDataSchema(
    request: DeepPartial<GetDataSchemaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DataSchema>;
  /** Deletes data schema inside corpus. */
  deleteDataSchema(
    request: DeepPartial<DeleteDataSchemaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Lists a list of data schemas inside corpus. */
  listDataSchemas(
    request: DeepPartial<ListDataSchemasRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDataSchemasResponse>;
  /** Creates annotation inside asset. */
  createAnnotation(
    request: DeepPartial<CreateAnnotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Annotation>;
  /** Reads annotation inside asset. */
  getAnnotation(
    request: DeepPartial<GetAnnotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Annotation>;
  /** Lists a list of annotations inside asset. */
  listAnnotations(
    request: DeepPartial<ListAnnotationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAnnotationsResponse>;
  /** Updates annotation inside asset. */
  updateAnnotation(
    request: DeepPartial<UpdateAnnotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Annotation>;
  /** Deletes annotation inside asset. */
  deleteAnnotation(
    request: DeepPartial<DeleteAnnotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Ingests data for the asset. It is not allowed to ingest a data chunk which
   * is already expired according to TTL.
   * This method is only available via the gRPC API (not HTTP since
   * bi-directional streaming is not supported via HTTP).
   */
  ingestAsset(
    request: AsyncIterable<DeepPartial<IngestAssetRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<IngestAssetResponse>;
  /**
   * Supported by STREAM_VIDEO corpus type.
   * Generates clips for downloading. The api takes in a time range, and
   * generates a clip of the first content available after start_time and
   * before end_time, which may overflow beyond these bounds.
   * Returned clips are truncated if the total size of the clips are larger
   * than 100MB.
   */
  clipAsset(request: DeepPartial<ClipAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<ClipAssetResponse>;
  /**
   * Generates a uri for an HLS manifest. The api takes in a collection of time
   * ranges, and generates a URI for an HLS manifest that covers all the
   * requested time ranges.
   */
  generateHlsUri(
    request: DeepPartial<GenerateHlsUriRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateHlsUriResponse>;
  /**
   * Imports assets (images plus annotations) from a meta file on cloud storage.
   * Each row in the meta file is corresponding to an image (specified by a
   * cloud storage uri) and its annotations.
   */
  importAssets(request: DeepPartial<ImportAssetsRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Creates a search configuration inside a corpus.
   *
   * Please follow the rules below to create a valid CreateSearchConfigRequest.
   * --- General Rules ---
   * 1. Request.search_config_id must not be associated with an existing
   *    SearchConfig.
   * 2. Request must contain at least one non-empty search_criteria_property or
   *    facet_property.
   * 3. mapped_fields must not be empty, and must map to existing UGA keys.
   * 4. All mapped_fields must be of the same type.
   * 5. All mapped_fields must share the same granularity.
   * 6. All mapped_fields must share the same semantic SearchConfig match
   *    options.
   * For property-specific rules, please reference the comments for
   * FacetProperty and SearchCriteriaProperty.
   */
  createSearchConfig(
    request: DeepPartial<CreateSearchConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchConfig>;
  /**
   * Updates a search configuration inside a corpus.
   *
   * Please follow the rules below to create a valid UpdateSearchConfigRequest.
   * --- General Rules ---
   * 1. Request.search_configuration.name must already exist.
   * 2. Request must contain at least one non-empty search_criteria_property or
   * facet_property.
   * 3. mapped_fields must not be empty, and must map to existing UGA keys.
   * 4. All mapped_fields must be of the same type.
   * 5. All mapped_fields must share the same granularity.
   * 6. All mapped_fields must share the same semantic SearchConfig match
   *    options.
   * For property-specific rules, please reference the comments for
   * FacetProperty and SearchCriteriaProperty.
   */
  updateSearchConfig(
    request: DeepPartial<UpdateSearchConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchConfig>;
  /** Gets a search configuration inside a corpus. */
  getSearchConfig(
    request: DeepPartial<GetSearchConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchConfig>;
  /**
   * Deletes a search configuration inside a corpus.
   *
   * For a DeleteSearchConfigRequest to be valid,
   * Request.search_configuration.name must already exist.
   */
  deleteSearchConfig(
    request: DeepPartial<DeleteSearchConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Lists all search configurations inside a corpus. */
  listSearchConfigs(
    request: DeepPartial<ListSearchConfigsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSearchConfigsResponse>;
  /** Creates a SearchHypernym inside a corpus. */
  createSearchHypernym(
    request: DeepPartial<CreateSearchHypernymRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchHypernym>;
  /** Updates a SearchHypernym inside a corpus. */
  updateSearchHypernym(
    request: DeepPartial<UpdateSearchHypernymRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchHypernym>;
  /** Gets a SearchHypernym inside a corpus. */
  getSearchHypernym(
    request: DeepPartial<GetSearchHypernymRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchHypernym>;
  /** Deletes a SearchHypernym inside a corpus. */
  deleteSearchHypernym(
    request: DeepPartial<DeleteSearchHypernymRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Lists SearchHypernyms inside a corpus. */
  listSearchHypernyms(
    request: DeepPartial<ListSearchHypernymsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSearchHypernymsResponse>;
  /** Search media asset. */
  searchAssets(
    request: DeepPartial<SearchAssetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchAssetsResponse>;
  /** Search a deployed index endpoint (IMAGE corpus type only). */
  searchIndexEndpoint(
    request: DeepPartial<SearchIndexEndpointRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchIndexEndpointResponse>;
  /** Creates an IndexEndpoint. */
  createIndexEndpoint(
    request: DeepPartial<CreateIndexEndpointRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Gets an IndexEndpoint. */
  getIndexEndpoint(
    request: DeepPartial<GetIndexEndpointRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<IndexEndpoint>;
  /** Lists all IndexEndpoints in a project. */
  listIndexEndpoints(
    request: DeepPartial<ListIndexEndpointsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListIndexEndpointsResponse>;
  /** Updates an IndexEndpoint. */
  updateIndexEndpoint(
    request: DeepPartial<UpdateIndexEndpointRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes an IndexEndpoint. */
  deleteIndexEndpoint(
    request: DeepPartial<DeleteIndexEndpointRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deploys an Index to IndexEndpoint. */
  deployIndex(request: DeepPartial<DeployIndexRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Undeploys an Index from IndexEndpoint. */
  undeployIndex(request: DeepPartial<UndeployIndexRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Creates a collection. */
  createCollection(
    request: DeepPartial<CreateCollectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a collection. */
  deleteCollection(
    request: DeepPartial<DeleteCollectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Gets a collection. */
  getCollection(
    request: DeepPartial<GetCollectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Collection>;
  /** Updates a collection. */
  updateCollection(
    request: DeepPartial<UpdateCollectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Collection>;
  /** Lists collections inside a corpus. */
  listCollections(
    request: DeepPartial<ListCollectionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCollectionsResponse>;
  /** Adds an item into a Collection. */
  addCollectionItem(
    request: DeepPartial<AddCollectionItemRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AddCollectionItemResponse>;
  /** Removes an item from a collection. */
  removeCollectionItem(
    request: DeepPartial<RemoveCollectionItemRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RemoveCollectionItemResponse>;
  /** View items inside a collection. */
  viewCollectionItems(
    request: DeepPartial<ViewCollectionItemsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ViewCollectionItemsResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
