// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/visionai/v1/lva.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.visionai.v1";

/** RunMode represents the mode to launch the Process on. */
export enum RunMode {
  /** RUN_MODE_UNSPECIFIED - Mode is unspecified. */
  RUN_MODE_UNSPECIFIED = 0,
  /**
   * LIVE - Live mode. Meaning the Process is launched to handle live video
   * source, and possible packet drops are expected.
   */
  LIVE = 1,
  /**
   * SUBMISSION - Submission mode. Meaning the Process is launched to handle bounded video
   * files, with no packet drop. Completion status is tracked.
   */
  SUBMISSION = 2,
  UNRECOGNIZED = -1,
}

export function runModeFromJSON(object: any): RunMode {
  switch (object) {
    case 0:
    case "RUN_MODE_UNSPECIFIED":
      return RunMode.RUN_MODE_UNSPECIFIED;
    case 1:
    case "LIVE":
      return RunMode.LIVE;
    case 2:
    case "SUBMISSION":
      return RunMode.SUBMISSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RunMode.UNRECOGNIZED;
  }
}

export function runModeToJSON(object: RunMode): string {
  switch (object) {
    case RunMode.RUN_MODE_UNSPECIFIED:
      return "RUN_MODE_UNSPECIFIED";
    case RunMode.LIVE:
      return "LIVE";
    case RunMode.SUBMISSION:
      return "SUBMISSION";
    case RunMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Defines the interface of an Operator.
 *
 * Arguments to an operator are input/output streams that are getting
 * processesed/returned while attributes are fixed configuration parameters.
 */
export interface OperatorDefinition {
  /**
   * The name of this operator.
   *
   * Tentatively [A-Z][a-zA-Z0-9]*, e.g., BboxCounter, PetDetector,
   * PetDetector1.
   */
  operator: string;
  /** Declares input arguments. */
  inputArgs: OperatorDefinition_ArgumentDefinition[];
  /** Declares output arguments. */
  outputArgs: OperatorDefinition_ArgumentDefinition[];
  /** Declares the attributes. */
  attributes: OperatorDefinition_AttributeDefinition[];
  /** The resources for running the operator. */
  resources:
    | ResourceSpecification
    | undefined;
  /** Short description of the operator. */
  shortDescription: string;
  /** Full description of the operator. */
  description: string;
}

/**
 * Defines an argument to an operator.
 *
 * Used for both inputs and outputs.
 */
export interface OperatorDefinition_ArgumentDefinition {
  /**
   * The name of the argument.
   *
   * Tentatively [a-z]([_a-z0-9]*[a-z0-9])?, e.g., video, audio,
   * high_fps_frame.
   */
  argument: string;
  /**
   * The data type of the argument.
   *
   * This should match the textual representation of a stream/Packet type.
   */
  type: string;
}

/** Defines an attribute of an operator. */
export interface OperatorDefinition_AttributeDefinition {
  /**
   * The name of the attribute.
   *
   * Tentatively [a-z]([_a-z0-9]*[a-z0-9])?, e.g., max_frames_per_video,
   * resize_height.
   */
  attribute: string;
  /**
   * The type of this attribute.
   *
   * See attribute_value.proto for possibilities.
   */
  type: string;
  /** The default value for the attribute. */
  defaultValue: AttributeValue | undefined;
}

/**
 * ResourceSpec collects a set of resources that can
 * be used to specify requests and requirements.
 *
 * Note: Highly experimental as this can be runtime dependent.
 * Can use the "extras" field to experiment first before trying
 * to abstract it.
 */
export interface ResourceSpecification {
  /**
   * CPU specification.
   *
   * Examples:
   * "100m", "0.5", "1", "2", ... correspond to
   * 0.1, half, 1, or 2 cpus.
   *
   * Leave empty to let the system decide.
   *
   * Note that this does *not* determine the cpu vender/make,
   * or its underlying clock speed and specific SIMD features.
   * It is only the amount time it requires in timeslicing.
   */
  cpu: string;
  /**
   * CPU limit.
   *
   * Examples:
   * "100m", "0.5", "1", "2", ... correspond to
   * 0.1, half, 1, or 2 cpus.
   *
   * Leave empty to indicate no limit.
   */
  cpuLimits: string;
  /**
   * Memory specification (in bytes).
   *
   * Examples:
   * "128974848", "129e6", "129M", "123Mi", ... correspond to
   * 128974848 bytes, 129000000 bytes, 129 mebibytes, 123 megabytes.
   *
   * Leave empty to let the system decide.
   */
  memory: string;
  /**
   * Memory usage limits.
   *
   * Examples:
   * "128974848", "129e6", "129M", "123Mi", ... correspond to
   * 128974848 bytes, 129000000 bytes, 129 mebibytes, 123 megabytes.
   *
   * Leave empty to indicate no limit.
   */
  memoryLimits: string;
  /** Number of gpus. */
  gpus: number;
  /**
   * The maximum latency that this operator may use to process an element.
   *
   * If non positive, then a system default will be used.
   * Operator developers should arrange for the system compute resources to be
   * aligned with this latency budget; e.g. if you want a ML model to produce
   * results within 500ms, then you should make sure you request enough
   * cpu/gpu/memory to achieve that.
   */
  latencyBudgetMs: number;
}

/** Represents an actual value of an operator attribute. */
export interface AttributeValue {
  /** int. */
  i?:
    | Long
    | undefined;
  /** float. */
  f?:
    | number
    | undefined;
  /** bool. */
  b?:
    | boolean
    | undefined;
  /** string. */
  s?: Buffer | undefined;
}

/**
 * Defines an Analyzer.
 *
 * An analyzer processes data from its input streams using the logic defined in
 * the Operator that it represents. Of course, it produces data for the output
 * streams declared in the Operator.
 */
export interface AnalyzerDefinition {
  /**
   * The name of this analyzer.
   *
   * Tentatively [a-z][a-z0-9]*(_[a-z0-9]+)*.
   */
  analyzer: string;
  /**
   * The name of the operator that this analyzer runs.
   *
   * Must match the name of a supported operator.
   */
  operator: string;
  /** Input streams. */
  inputs: AnalyzerDefinition_StreamInput[];
  /**
   * The attribute values that this analyzer applies to the operator.
   *
   * Supply a mapping between the attribute names and the actual value you wish
   * to apply. If an attribute name is omitted, then it will take a
   * preconfigured default value.
   */
  attrs: { [key: string]: AttributeValue };
  /** Debug options. */
  debugOptions:
    | AnalyzerDefinition_DebugOptions
    | undefined;
  /** Operator option. */
  operatorOption: AnalyzerDefinition_OperatorOption | undefined;
}

/**
 * The inputs to this analyzer.
 *
 * We accept input name references of the following form:
 * <analyzer-name>:<output-argument-name>
 *
 * Example:
 *
 * Suppose you had an operator named "SomeOp" that has 2 output
 * arguments, the first of which is named "foo" and the second of which is
 * named "bar", and an operator named "MyOp" that accepts 2 inputs.
 *
 * Also suppose that there is an analyzer named "some-analyzer" that is
 * running "SomeOp" and another analyzer named "my-analyzer" running "MyOp".
 *
 * To indicate that "my-analyzer" is to consume "some-analyzer"'s "foo"
 * output as its first input and "some-analyzer"'s "bar" output as its
 * second input, you can set this field to the following:
 * input = ["some-analyzer:foo", "some-analyzer:bar"]
 */
export interface AnalyzerDefinition_StreamInput {
  /** The name of the stream input (as discussed above). */
  input: string;
}

/** Options available for debugging purposes only. */
export interface AnalyzerDefinition_DebugOptions {
  /** Environment variables. */
  environmentVariables: { [key: string]: string };
}

export interface AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
  key: string;
  value: string;
}

/** Option related to the operator. */
export interface AnalyzerDefinition_OperatorOption {
  /** Tag of the operator. */
  tag: string;
  /** Registry of the operator. e.g. public, dev. */
  registry: string;
}

export interface AnalyzerDefinition_AttrsEntry {
  key: string;
  value: AttributeValue | undefined;
}

/**
 * Defines a full analysis.
 *
 * This is a description of the overall live analytics pipeline.
 * You may think of this as an edge list representation of a multigraph.
 *
 * This may be directly authored by a human in protobuf textformat, or it may be
 * generated by a programming API (perhaps Python or JavaScript depending on
 * context).
 */
export interface AnalysisDefinition {
  /** Analyzer definitions. */
  analyzers: AnalyzerDefinition[];
}

/** Message describing the status of the Process. */
export interface RunStatus {
  /** The state of the Process. */
  state: RunStatus_State;
  /** The reason of becoming the state. */
  reason: string;
}

/** State represents the running status of the Process. */
export enum RunStatus_State {
  /** STATE_UNSPECIFIED - State is unspecified. */
  STATE_UNSPECIFIED = 0,
  /**
   * INITIALIZING - INITIALIZING means the Process is scheduled but yet ready to handle
   * real traffic.
   */
  INITIALIZING = 1,
  /** RUNNING - RUNNING means the Process is up running and handling traffic. */
  RUNNING = 2,
  /**
   * COMPLETED - COMPLETED means the Process has completed the processing, especially
   * for non-streaming use case.
   */
  COMPLETED = 3,
  /** FAILED - FAILED means the Process failed to complete the processing. */
  FAILED = 4,
  /** PENDING - PENDING means the Process is created but yet to be scheduled. */
  PENDING = 5,
  UNRECOGNIZED = -1,
}

export function runStatus_StateFromJSON(object: any): RunStatus_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return RunStatus_State.STATE_UNSPECIFIED;
    case 1:
    case "INITIALIZING":
      return RunStatus_State.INITIALIZING;
    case 2:
    case "RUNNING":
      return RunStatus_State.RUNNING;
    case 3:
    case "COMPLETED":
      return RunStatus_State.COMPLETED;
    case 4:
    case "FAILED":
      return RunStatus_State.FAILED;
    case 5:
    case "PENDING":
      return RunStatus_State.PENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RunStatus_State.UNRECOGNIZED;
  }
}

export function runStatus_StateToJSON(object: RunStatus_State): string {
  switch (object) {
    case RunStatus_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case RunStatus_State.INITIALIZING:
      return "INITIALIZING";
    case RunStatus_State.RUNNING:
      return "RUNNING";
    case RunStatus_State.COMPLETED:
      return "COMPLETED";
    case RunStatus_State.FAILED:
      return "FAILED";
    case RunStatus_State.PENDING:
      return "PENDING";
    case RunStatus_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseOperatorDefinition(): OperatorDefinition {
  return {
    operator: "",
    inputArgs: [],
    outputArgs: [],
    attributes: [],
    resources: undefined,
    shortDescription: "",
    description: "",
  };
}

export const OperatorDefinition: MessageFns<OperatorDefinition> = {
  encode(message: OperatorDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== "") {
      writer.uint32(10).string(message.operator);
    }
    for (const v of message.inputArgs) {
      OperatorDefinition_ArgumentDefinition.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.outputArgs) {
      OperatorDefinition_ArgumentDefinition.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.attributes) {
      OperatorDefinition_AttributeDefinition.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.resources !== undefined) {
      ResourceSpecification.encode(message.resources, writer.uint32(42).fork()).join();
    }
    if (message.shortDescription !== "") {
      writer.uint32(50).string(message.shortDescription);
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperatorDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperatorDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operator = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputArgs.push(OperatorDefinition_ArgumentDefinition.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outputArgs.push(OperatorDefinition_ArgumentDefinition.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.attributes.push(OperatorDefinition_AttributeDefinition.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.resources = ResourceSpecification.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.shortDescription = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperatorDefinition {
    return {
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      inputArgs: globalThis.Array.isArray(object?.inputArgs)
        ? object.inputArgs.map((e: any) => OperatorDefinition_ArgumentDefinition.fromJSON(e))
        : [],
      outputArgs: globalThis.Array.isArray(object?.outputArgs)
        ? object.outputArgs.map((e: any) => OperatorDefinition_ArgumentDefinition.fromJSON(e))
        : [],
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => OperatorDefinition_AttributeDefinition.fromJSON(e))
        : [],
      resources: isSet(object.resources) ? ResourceSpecification.fromJSON(object.resources) : undefined,
      shortDescription: isSet(object.shortDescription) ? globalThis.String(object.shortDescription) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: OperatorDefinition): unknown {
    const obj: any = {};
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.inputArgs?.length) {
      obj.inputArgs = message.inputArgs.map((e) => OperatorDefinition_ArgumentDefinition.toJSON(e));
    }
    if (message.outputArgs?.length) {
      obj.outputArgs = message.outputArgs.map((e) => OperatorDefinition_ArgumentDefinition.toJSON(e));
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => OperatorDefinition_AttributeDefinition.toJSON(e));
    }
    if (message.resources !== undefined) {
      obj.resources = ResourceSpecification.toJSON(message.resources);
    }
    if (message.shortDescription !== "") {
      obj.shortDescription = message.shortDescription;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<OperatorDefinition>): OperatorDefinition {
    return OperatorDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperatorDefinition>): OperatorDefinition {
    const message = createBaseOperatorDefinition();
    message.operator = object.operator ?? "";
    message.inputArgs = object.inputArgs?.map((e) => OperatorDefinition_ArgumentDefinition.fromPartial(e)) || [];
    message.outputArgs = object.outputArgs?.map((e) => OperatorDefinition_ArgumentDefinition.fromPartial(e)) || [];
    message.attributes = object.attributes?.map((e) => OperatorDefinition_AttributeDefinition.fromPartial(e)) || [];
    message.resources = (object.resources !== undefined && object.resources !== null)
      ? ResourceSpecification.fromPartial(object.resources)
      : undefined;
    message.shortDescription = object.shortDescription ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseOperatorDefinition_ArgumentDefinition(): OperatorDefinition_ArgumentDefinition {
  return { argument: "", type: "" };
}

export const OperatorDefinition_ArgumentDefinition: MessageFns<OperatorDefinition_ArgumentDefinition> = {
  encode(message: OperatorDefinition_ArgumentDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.argument !== "") {
      writer.uint32(10).string(message.argument);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperatorDefinition_ArgumentDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperatorDefinition_ArgumentDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.argument = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperatorDefinition_ArgumentDefinition {
    return {
      argument: isSet(object.argument) ? globalThis.String(object.argument) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: OperatorDefinition_ArgumentDefinition): unknown {
    const obj: any = {};
    if (message.argument !== "") {
      obj.argument = message.argument;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<OperatorDefinition_ArgumentDefinition>): OperatorDefinition_ArgumentDefinition {
    return OperatorDefinition_ArgumentDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperatorDefinition_ArgumentDefinition>): OperatorDefinition_ArgumentDefinition {
    const message = createBaseOperatorDefinition_ArgumentDefinition();
    message.argument = object.argument ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseOperatorDefinition_AttributeDefinition(): OperatorDefinition_AttributeDefinition {
  return { attribute: "", type: "", defaultValue: undefined };
}

export const OperatorDefinition_AttributeDefinition: MessageFns<OperatorDefinition_AttributeDefinition> = {
  encode(message: OperatorDefinition_AttributeDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attribute !== "") {
      writer.uint32(10).string(message.attribute);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.defaultValue !== undefined) {
      AttributeValue.encode(message.defaultValue, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperatorDefinition_AttributeDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperatorDefinition_AttributeDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attribute = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.defaultValue = AttributeValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperatorDefinition_AttributeDefinition {
    return {
      attribute: isSet(object.attribute) ? globalThis.String(object.attribute) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      defaultValue: isSet(object.defaultValue) ? AttributeValue.fromJSON(object.defaultValue) : undefined,
    };
  },

  toJSON(message: OperatorDefinition_AttributeDefinition): unknown {
    const obj: any = {};
    if (message.attribute !== "") {
      obj.attribute = message.attribute;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = AttributeValue.toJSON(message.defaultValue);
    }
    return obj;
  },

  create(base?: DeepPartial<OperatorDefinition_AttributeDefinition>): OperatorDefinition_AttributeDefinition {
    return OperatorDefinition_AttributeDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperatorDefinition_AttributeDefinition>): OperatorDefinition_AttributeDefinition {
    const message = createBaseOperatorDefinition_AttributeDefinition();
    message.attribute = object.attribute ?? "";
    message.type = object.type ?? "";
    message.defaultValue = (object.defaultValue !== undefined && object.defaultValue !== null)
      ? AttributeValue.fromPartial(object.defaultValue)
      : undefined;
    return message;
  },
};

function createBaseResourceSpecification(): ResourceSpecification {
  return { cpu: "", cpuLimits: "", memory: "", memoryLimits: "", gpus: 0, latencyBudgetMs: 0 };
}

export const ResourceSpecification: MessageFns<ResourceSpecification> = {
  encode(message: ResourceSpecification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpu !== "") {
      writer.uint32(10).string(message.cpu);
    }
    if (message.cpuLimits !== "") {
      writer.uint32(42).string(message.cpuLimits);
    }
    if (message.memory !== "") {
      writer.uint32(18).string(message.memory);
    }
    if (message.memoryLimits !== "") {
      writer.uint32(50).string(message.memoryLimits);
    }
    if (message.gpus !== 0) {
      writer.uint32(24).int32(message.gpus);
    }
    if (message.latencyBudgetMs !== 0) {
      writer.uint32(32).int32(message.latencyBudgetMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceSpecification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceSpecification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cpu = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cpuLimits = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.memory = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.memoryLimits = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gpus = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.latencyBudgetMs = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceSpecification {
    return {
      cpu: isSet(object.cpu) ? globalThis.String(object.cpu) : "",
      cpuLimits: isSet(object.cpuLimits) ? globalThis.String(object.cpuLimits) : "",
      memory: isSet(object.memory) ? globalThis.String(object.memory) : "",
      memoryLimits: isSet(object.memoryLimits) ? globalThis.String(object.memoryLimits) : "",
      gpus: isSet(object.gpus) ? globalThis.Number(object.gpus) : 0,
      latencyBudgetMs: isSet(object.latencyBudgetMs) ? globalThis.Number(object.latencyBudgetMs) : 0,
    };
  },

  toJSON(message: ResourceSpecification): unknown {
    const obj: any = {};
    if (message.cpu !== "") {
      obj.cpu = message.cpu;
    }
    if (message.cpuLimits !== "") {
      obj.cpuLimits = message.cpuLimits;
    }
    if (message.memory !== "") {
      obj.memory = message.memory;
    }
    if (message.memoryLimits !== "") {
      obj.memoryLimits = message.memoryLimits;
    }
    if (message.gpus !== 0) {
      obj.gpus = Math.round(message.gpus);
    }
    if (message.latencyBudgetMs !== 0) {
      obj.latencyBudgetMs = Math.round(message.latencyBudgetMs);
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceSpecification>): ResourceSpecification {
    return ResourceSpecification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceSpecification>): ResourceSpecification {
    const message = createBaseResourceSpecification();
    message.cpu = object.cpu ?? "";
    message.cpuLimits = object.cpuLimits ?? "";
    message.memory = object.memory ?? "";
    message.memoryLimits = object.memoryLimits ?? "";
    message.gpus = object.gpus ?? 0;
    message.latencyBudgetMs = object.latencyBudgetMs ?? 0;
    return message;
  },
};

function createBaseAttributeValue(): AttributeValue {
  return { i: undefined, f: undefined, b: undefined, s: undefined };
}

export const AttributeValue: MessageFns<AttributeValue> = {
  encode(message: AttributeValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.i !== undefined) {
      writer.uint32(8).int64(message.i.toString());
    }
    if (message.f !== undefined) {
      writer.uint32(21).float(message.f);
    }
    if (message.b !== undefined) {
      writer.uint32(24).bool(message.b);
    }
    if (message.s !== undefined) {
      writer.uint32(34).bytes(message.s);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.i = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.f = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.b = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.s = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeValue {
    return {
      i: isSet(object.i) ? Long.fromValue(object.i) : undefined,
      f: isSet(object.f) ? globalThis.Number(object.f) : undefined,
      b: isSet(object.b) ? globalThis.Boolean(object.b) : undefined,
      s: isSet(object.s) ? Buffer.from(bytesFromBase64(object.s)) : undefined,
    };
  },

  toJSON(message: AttributeValue): unknown {
    const obj: any = {};
    if (message.i !== undefined) {
      obj.i = (message.i || Long.ZERO).toString();
    }
    if (message.f !== undefined) {
      obj.f = message.f;
    }
    if (message.b !== undefined) {
      obj.b = message.b;
    }
    if (message.s !== undefined) {
      obj.s = base64FromBytes(message.s);
    }
    return obj;
  },

  create(base?: DeepPartial<AttributeValue>): AttributeValue {
    return AttributeValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttributeValue>): AttributeValue {
    const message = createBaseAttributeValue();
    message.i = (object.i !== undefined && object.i !== null) ? Long.fromValue(object.i) : undefined;
    message.f = object.f ?? undefined;
    message.b = object.b ?? undefined;
    message.s = object.s ?? undefined;
    return message;
  },
};

function createBaseAnalyzerDefinition(): AnalyzerDefinition {
  return { analyzer: "", operator: "", inputs: [], attrs: {}, debugOptions: undefined, operatorOption: undefined };
}

export const AnalyzerDefinition: MessageFns<AnalyzerDefinition> = {
  encode(message: AnalyzerDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.analyzer !== "") {
      writer.uint32(10).string(message.analyzer);
    }
    if (message.operator !== "") {
      writer.uint32(18).string(message.operator);
    }
    for (const v of message.inputs) {
      AnalyzerDefinition_StreamInput.encode(v!, writer.uint32(26).fork()).join();
    }
    Object.entries(message.attrs).forEach(([key, value]) => {
      AnalyzerDefinition_AttrsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.debugOptions !== undefined) {
      AnalyzerDefinition_DebugOptions.encode(message.debugOptions, writer.uint32(42).fork()).join();
    }
    if (message.operatorOption !== undefined) {
      AnalyzerDefinition_OperatorOption.encode(message.operatorOption, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.analyzer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operator = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inputs.push(AnalyzerDefinition_StreamInput.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = AnalyzerDefinition_AttrsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.attrs[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.debugOptions = AnalyzerDefinition_DebugOptions.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.operatorOption = AnalyzerDefinition_OperatorOption.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition {
    return {
      analyzer: isSet(object.analyzer) ? globalThis.String(object.analyzer) : "",
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      inputs: globalThis.Array.isArray(object?.inputs)
        ? object.inputs.map((e: any) => AnalyzerDefinition_StreamInput.fromJSON(e))
        : [],
      attrs: isObject(object.attrs)
        ? Object.entries(object.attrs).reduce<{ [key: string]: AttributeValue }>((acc, [key, value]) => {
          acc[key] = AttributeValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      debugOptions: isSet(object.debugOptions)
        ? AnalyzerDefinition_DebugOptions.fromJSON(object.debugOptions)
        : undefined,
      operatorOption: isSet(object.operatorOption)
        ? AnalyzerDefinition_OperatorOption.fromJSON(object.operatorOption)
        : undefined,
    };
  },

  toJSON(message: AnalyzerDefinition): unknown {
    const obj: any = {};
    if (message.analyzer !== "") {
      obj.analyzer = message.analyzer;
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => AnalyzerDefinition_StreamInput.toJSON(e));
    }
    if (message.attrs) {
      const entries = Object.entries(message.attrs);
      if (entries.length > 0) {
        obj.attrs = {};
        entries.forEach(([k, v]) => {
          obj.attrs[k] = AttributeValue.toJSON(v);
        });
      }
    }
    if (message.debugOptions !== undefined) {
      obj.debugOptions = AnalyzerDefinition_DebugOptions.toJSON(message.debugOptions);
    }
    if (message.operatorOption !== undefined) {
      obj.operatorOption = AnalyzerDefinition_OperatorOption.toJSON(message.operatorOption);
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzerDefinition>): AnalyzerDefinition {
    return AnalyzerDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzerDefinition>): AnalyzerDefinition {
    const message = createBaseAnalyzerDefinition();
    message.analyzer = object.analyzer ?? "";
    message.operator = object.operator ?? "";
    message.inputs = object.inputs?.map((e) => AnalyzerDefinition_StreamInput.fromPartial(e)) || [];
    message.attrs = Object.entries(object.attrs ?? {}).reduce<{ [key: string]: AttributeValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.debugOptions = (object.debugOptions !== undefined && object.debugOptions !== null)
      ? AnalyzerDefinition_DebugOptions.fromPartial(object.debugOptions)
      : undefined;
    message.operatorOption = (object.operatorOption !== undefined && object.operatorOption !== null)
      ? AnalyzerDefinition_OperatorOption.fromPartial(object.operatorOption)
      : undefined;
    return message;
  },
};

function createBaseAnalyzerDefinition_StreamInput(): AnalyzerDefinition_StreamInput {
  return { input: "" };
}

export const AnalyzerDefinition_StreamInput: MessageFns<AnalyzerDefinition_StreamInput> = {
  encode(message: AnalyzerDefinition_StreamInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== "") {
      writer.uint32(10).string(message.input);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition_StreamInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition_StreamInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.input = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition_StreamInput {
    return { input: isSet(object.input) ? globalThis.String(object.input) : "" };
  },

  toJSON(message: AnalyzerDefinition_StreamInput): unknown {
    const obj: any = {};
    if (message.input !== "") {
      obj.input = message.input;
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzerDefinition_StreamInput>): AnalyzerDefinition_StreamInput {
    return AnalyzerDefinition_StreamInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzerDefinition_StreamInput>): AnalyzerDefinition_StreamInput {
    const message = createBaseAnalyzerDefinition_StreamInput();
    message.input = object.input ?? "";
    return message;
  },
};

function createBaseAnalyzerDefinition_DebugOptions(): AnalyzerDefinition_DebugOptions {
  return { environmentVariables: {} };
}

export const AnalyzerDefinition_DebugOptions: MessageFns<AnalyzerDefinition_DebugOptions> = {
  encode(message: AnalyzerDefinition_DebugOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.environmentVariables).forEach(([key, value]) => {
      AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition_DebugOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition_DebugOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.environmentVariables[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition_DebugOptions {
    return {
      environmentVariables: isObject(object.environmentVariables)
        ? Object.entries(object.environmentVariables).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AnalyzerDefinition_DebugOptions): unknown {
    const obj: any = {};
    if (message.environmentVariables) {
      const entries = Object.entries(message.environmentVariables);
      if (entries.length > 0) {
        obj.environmentVariables = {};
        entries.forEach(([k, v]) => {
          obj.environmentVariables[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzerDefinition_DebugOptions>): AnalyzerDefinition_DebugOptions {
    return AnalyzerDefinition_DebugOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzerDefinition_DebugOptions>): AnalyzerDefinition_DebugOptions {
    const message = createBaseAnalyzerDefinition_DebugOptions();
    message.environmentVariables = Object.entries(object.environmentVariables ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry(): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
  return { key: "", value: "" };
}

export const AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry: MessageFns<
  AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry
> = {
  encode(
    message: AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry>,
  ): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
    return AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry>,
  ): AnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry {
    const message = createBaseAnalyzerDefinition_DebugOptions_EnvironmentVariablesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAnalyzerDefinition_OperatorOption(): AnalyzerDefinition_OperatorOption {
  return { tag: "", registry: "" };
}

export const AnalyzerDefinition_OperatorOption: MessageFns<AnalyzerDefinition_OperatorOption> = {
  encode(message: AnalyzerDefinition_OperatorOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    if (message.registry !== "") {
      writer.uint32(18).string(message.registry);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition_OperatorOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition_OperatorOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.registry = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition_OperatorOption {
    return {
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      registry: isSet(object.registry) ? globalThis.String(object.registry) : "",
    };
  },

  toJSON(message: AnalyzerDefinition_OperatorOption): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.registry !== "") {
      obj.registry = message.registry;
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzerDefinition_OperatorOption>): AnalyzerDefinition_OperatorOption {
    return AnalyzerDefinition_OperatorOption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzerDefinition_OperatorOption>): AnalyzerDefinition_OperatorOption {
    const message = createBaseAnalyzerDefinition_OperatorOption();
    message.tag = object.tag ?? "";
    message.registry = object.registry ?? "";
    return message;
  },
};

function createBaseAnalyzerDefinition_AttrsEntry(): AnalyzerDefinition_AttrsEntry {
  return { key: "", value: undefined };
}

export const AnalyzerDefinition_AttrsEntry: MessageFns<AnalyzerDefinition_AttrsEntry> = {
  encode(message: AnalyzerDefinition_AttrsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzerDefinition_AttrsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzerDefinition_AttrsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzerDefinition_AttrsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AnalyzerDefinition_AttrsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzerDefinition_AttrsEntry>): AnalyzerDefinition_AttrsEntry {
    return AnalyzerDefinition_AttrsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzerDefinition_AttrsEntry>): AnalyzerDefinition_AttrsEntry {
    const message = createBaseAnalyzerDefinition_AttrsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAnalysisDefinition(): AnalysisDefinition {
  return { analyzers: [] };
}

export const AnalysisDefinition: MessageFns<AnalysisDefinition> = {
  encode(message: AnalysisDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.analyzers) {
      AnalyzerDefinition.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalysisDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysisDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.analyzers.push(AnalyzerDefinition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalysisDefinition {
    return {
      analyzers: globalThis.Array.isArray(object?.analyzers)
        ? object.analyzers.map((e: any) => AnalyzerDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AnalysisDefinition): unknown {
    const obj: any = {};
    if (message.analyzers?.length) {
      obj.analyzers = message.analyzers.map((e) => AnalyzerDefinition.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AnalysisDefinition>): AnalysisDefinition {
    return AnalysisDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalysisDefinition>): AnalysisDefinition {
    const message = createBaseAnalysisDefinition();
    message.analyzers = object.analyzers?.map((e) => AnalyzerDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunStatus(): RunStatus {
  return { state: 0, reason: "" };
}

export const RunStatus: MessageFns<RunStatus> = {
  encode(message: RunStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunStatus {
    return {
      state: isSet(object.state) ? runStatus_StateFromJSON(object.state) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: RunStatus): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = runStatus_StateToJSON(message.state);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<RunStatus>): RunStatus {
    return RunStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunStatus>): RunStatus {
    const message = createBaseRunStatus();
    message.state = object.state ?? 0;
    message.reason = object.reason ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
