// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/workstations/v1beta/workstations.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Duration } from "../../../protobuf/duration.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";

export const protobufPackage = "google.cloud.workstations.v1beta";

/**
 * A workstation cluster resource in the Cloud Workstations API.
 *
 * Defines a group of workstations in a particular region and the
 * VPC network they're attached to.
 */
export interface WorkstationCluster {
  /** Full name of this workstation cluster. */
  name: string;
  /** Optional. Human-readable name for this workstation cluster. */
  displayName: string;
  /**
   * Output only. A system-assigned unique identifier for this workstation
   * cluster.
   */
  uid: string;
  /**
   * Output only. Indicates whether this workstation cluster is currently being
   * updated to match its intended state.
   */
  reconciling: boolean;
  /** Optional. Client-specified annotations. */
  annotations: { [key: string]: string };
  /**
   * Optional.
   * [Labels](https://cloud.google.com/workstations/docs/label-resources) that
   * are applied to the workstation cluster and that are also propagated to the
   * underlying Compute Engine resources.
   */
  labels: { [key: string]: string };
  /** Output only. Time when this workstation cluster was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time when this workstation cluster was most recently updated. */
  updateTime:
    | Date
    | undefined;
  /** Output only. Time when this workstation cluster was soft-deleted. */
  deleteTime:
    | Date
    | undefined;
  /**
   * Optional. Checksum computed by the server. May be sent on update and delete
   * requests to make sure that the client has an up-to-date value before
   * proceeding.
   */
  etag: string;
  /**
   * Immutable. Name of the Compute Engine network in which instances associated
   * with this workstation cluster will be created.
   */
  network: string;
  /**
   * Immutable. Name of the Compute Engine subnetwork in which instances
   * associated with this workstation cluster will be created. Must be part of
   * the subnetwork specified for this workstation cluster.
   */
  subnetwork: string;
  /**
   * Output only. The private IP address of the control plane for this
   * workstation cluster. Workstation VMs need access to this IP address to work
   * with the service, so make sure that your firewall rules allow egress from
   * the workstation VMs to this address.
   */
  controlPlaneIp: string;
  /** Optional. Configuration for private workstation cluster. */
  privateClusterConfig:
    | WorkstationCluster_PrivateClusterConfig
    | undefined;
  /**
   * Output only. Whether this workstation cluster is in degraded mode, in which
   * case it may require user action to restore full functionality. Details can
   * be found in
   * [conditions][google.cloud.workstations.v1beta.WorkstationCluster.conditions].
   */
  degraded: boolean;
  /**
   * Output only. Status conditions describing the workstation cluster's current
   * state.
   */
  conditions: Status[];
}

/** Configuration options for private workstation clusters. */
export interface WorkstationCluster_PrivateClusterConfig {
  /** Immutable. Whether Workstations endpoint is private. */
  enablePrivateEndpoint: boolean;
  /**
   * Output only. Hostname for the workstation cluster. This field will be
   * populated only when private endpoint is enabled. To access workstations
   * in the workstation cluster, create a new DNS zone mapping this domain
   * name to an internal IP address and a forwarding rule mapping that address
   * to the service attachment.
   */
  clusterHostname: string;
  /**
   * Output only. Service attachment URI for the workstation cluster. The
   * service attachemnt is created when private endpoint is enabled. To access
   * workstations in the workstation cluster, configure access to the managed
   * service using [Private Service
   * Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-services).
   */
  serviceAttachmentUri: string;
  /**
   * Optional. Additional projects that are allowed to attach to the
   * workstation cluster's service attachment. By default, the workstation
   * cluster's project and the VPC host project (if different) are allowed.
   */
  allowedProjects: string[];
}

export interface WorkstationCluster_AnnotationsEntry {
  key: string;
  value: string;
}

export interface WorkstationCluster_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A workstation configuration resource in the Cloud Workstations API.
 *
 * Workstation configurations act as templates for workstations. The workstation
 * configuration defines details such as the workstation virtual machine (VM)
 * instance type, persistent storage, container image defining environment,
 * which IDE or Code Editor to use, and more. Administrators and platform teams
 * can also use [Identity and Access Management
 * (IAM)](https://cloud.google.com/iam/docs/overview) rules to grant access to
 * teams or to individual developers.
 */
export interface WorkstationConfig {
  /** Full name of this workstation configuration. */
  name: string;
  /** Optional. Human-readable name for this workstation configuration. */
  displayName: string;
  /**
   * Output only. A system-assigned unique identifier for this workstation
   * configuration.
   */
  uid: string;
  /**
   * Output only. Indicates whether this workstation configuration is currently
   * being updated to match its intended state.
   */
  reconciling: boolean;
  /** Optional. Client-specified annotations. */
  annotations: { [key: string]: string };
  /**
   * Optional.
   * [Labels](https://cloud.google.com/workstations/docs/label-resources) that
   * are applied to the workstation configuration and that are also propagated
   * to the underlying Compute Engine resources.
   */
  labels: { [key: string]: string };
  /** Output only. Time when this workstation configuration was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. Time when this workstation configuration was most recently
   * updated.
   */
  updateTime:
    | Date
    | undefined;
  /** Output only. Time when this workstation configuration was soft-deleted. */
  deleteTime:
    | Date
    | undefined;
  /**
   * Optional. Checksum computed by the server. May be sent on update and delete
   * requests to make sure that the client has an up-to-date value before
   * proceeding.
   */
  etag: string;
  /**
   * Optional. Number of seconds to wait before automatically stopping a
   * workstation after it last received user traffic.
   *
   * A value of `"0s"` indicates that Cloud Workstations VMs created with this
   * configuration should never time out due to idleness.
   * Provide
   * [duration](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration)
   * terminated by `s` for seconds—for example, `"7200s"` (2 hours).
   * The default is `"1200s"` (20 minutes).
   */
  idleTimeout:
    | Duration
    | undefined;
  /**
   * Optional. Number of seconds that a workstation can run until it is
   * automatically shut down. We recommend that workstations be shut down daily
   * to reduce costs and so that security updates can be applied upon restart.
   * The
   * [idle_timeout][google.cloud.workstations.v1beta.WorkstationConfig.idle_timeout]
   * and
   * [running_timeout][google.cloud.workstations.v1beta.WorkstationConfig.running_timeout]
   * fields are independent of each other. Note that the
   * [running_timeout][google.cloud.workstations.v1beta.WorkstationConfig.running_timeout]
   * field shuts down VMs after the specified time, regardless of whether or not
   * the VMs are idle.
   *
   * Provide duration terminated by `s` for seconds—for example, `"54000s"`
   * (15 hours). Defaults to `"43200s"` (12 hours). A value of `"0s"` indicates
   * that workstations using this configuration should never time out. If
   * [encryption_key][google.cloud.workstations.v1beta.WorkstationConfig.encryption_key]
   * is set, it must be greater than `"0s"` and less than
   * `"86400s"` (24 hours).
   *
   * Warning: A value of `"0s"` indicates that Cloud Workstations VMs created
   * with this configuration have no maximum running time. This is strongly
   * discouraged because you incur costs and will not pick up security updates.
   */
  runningTimeout:
    | Duration
    | undefined;
  /** Optional. Runtime host for the workstation. */
  host:
    | WorkstationConfig_Host
    | undefined;
  /** Optional. Directories to persist across workstation sessions. */
  persistentDirectories: WorkstationConfig_PersistentDirectory[];
  /**
   * Optional. Ephemeral directories which won't persist across workstation
   * sessions.
   */
  ephemeralDirectories: WorkstationConfig_EphemeralDirectory[];
  /**
   * Optional. Container that runs upon startup for each workstation using this
   * workstation configuration.
   */
  container:
    | WorkstationConfig_Container
    | undefined;
  /**
   * Immutable. Encrypts resources of this workstation configuration using a
   * customer-managed encryption key (CMEK).
   *
   * If specified, the boot disk of the Compute Engine instance and the
   * persistent disk are encrypted using this encryption key. If
   * this field is not set, the disks are encrypted using a generated
   * key. Customer-managed encryption keys do not protect disk metadata.
   *
   * If the customer-managed encryption key is rotated, when the workstation
   * instance is stopped, the system attempts to recreate the
   * persistent disk with the new version of the key. Be sure to keep
   * older versions of the key until the persistent disk is recreated.
   * Otherwise, data on the persistent disk might be lost.
   *
   * If the encryption key is revoked, the workstation session automatically
   * stops within 7 hours.
   *
   * Immutable after the workstation configuration is created.
   */
  encryptionKey:
    | WorkstationConfig_CustomerEncryptionKey
    | undefined;
  /**
   * Optional. Readiness checks to perform when starting a workstation using
   * this workstation configuration. Mark a workstation as running only after
   * all specified readiness checks return 200 status codes.
   */
  readinessChecks: WorkstationConfig_ReadinessCheck[];
  /**
   * Optional. Immutable. Specifies the zones used to replicate the VM and disk
   * resources within the region. If set, exactly two zones within the
   * workstation cluster's region must be specified—for example,
   * `['us-central1-a', 'us-central1-f']`. If this field is empty, two default
   * zones within the region are used.
   *
   * Immutable after the workstation configuration is created.
   */
  replicaZones: string[];
  /**
   * Output only. Whether this resource is degraded, in which case it may
   * require user action to restore full functionality. See also the
   * [conditions][google.cloud.workstations.v1beta.WorkstationConfig.conditions]
   * field.
   */
  degraded: boolean;
  /** Output only. Status conditions describing the current resource state. */
  conditions: Status[];
  /**
   * Optional. Whether to enable Linux `auditd` logging on the workstation. When
   * enabled, a service account must also be specified that has
   * `logging.buckets.write` permission on the project. Operating system audit
   * logging is distinct from [Cloud Audit
   * Logs](https://cloud.google.com/workstations/docs/audit-logging).
   */
  enableAuditAgent: boolean;
}

/** Runtime host for a workstation. */
export interface WorkstationConfig_Host {
  /** Specifies a Compute Engine instance as the host. */
  gceInstance?: WorkstationConfig_Host_GceInstance | undefined;
}

/** A runtime using a Compute Engine instance. */
export interface WorkstationConfig_Host_GceInstance {
  /**
   * Optional. The type of machine to use for VM instances—for example,
   * `"e2-standard-4"`. For more information about machine types that
   * Cloud Workstations supports, see the list of
   * [available machine
   * types](https://cloud.google.com/workstations/docs/available-machine-types).
   */
  machineType: string;
  /**
   * Optional. The email address of the service account for Cloud
   * Workstations VMs created with this configuration. When specified, be
   * sure that the service account has `logginglogEntries.create` permission
   * on the project so it can write logs out to Cloud Logging. If using a
   * custom container image, the service account must have permissions to
   * pull the specified image.
   *
   * If you as the administrator want to be able to `ssh` into the
   * underlying VM, you need to set this value to a service account
   * for which you have the `iam.serviceAccounts.actAs` permission.
   * Conversely, if you don't want anyone to be able to `ssh` into the
   * underlying VM, use a service account where no one has that
   * permission.
   *
   * If not set, VMs run with a service account provided by the
   * Cloud Workstations service, and the image must be publicly
   * accessible.
   */
  serviceAccount: string;
  /**
   * Optional. Scopes to grant to the
   * [service_account][google.cloud.workstations.v1beta.WorkstationConfig.Host.GceInstance.service_account].
   * Various scopes are automatically added based on feature usage. When
   * specified, users of workstations under this configuration must have
   * `iam.serviceAccounts.actAs` on the service account.
   */
  serviceAccountScopes: string[];
  /**
   * Optional. Network tags to add to the Compute Engine VMs backing the
   * workstations. This option applies
   * [network
   * tags](https://cloud.google.com/vpc/docs/add-remove-network-tags) to VMs
   * created with this configuration. These network tags enable the creation
   * of [firewall
   * rules](https://cloud.google.com/workstations/docs/configure-firewall-rules).
   */
  tags: string[];
  /**
   * Optional. The number of VMs that the system should keep idle so that
   * new workstations can be started quickly for new users. Defaults to `0`
   * in the API.
   */
  poolSize: number;
  /**
   * Output only. Number of instances currently available in the pool for
   * faster workstation startup.
   */
  pooledInstances: number;
  /**
   * Optional. When set to true, disables public IP addresses for VMs. If
   * you disable public IP addresses, you must set up Private Google Access
   * or Cloud NAT on your network. If you use Private Google Access and you
   * use `private.googleapis.com` or `restricted.googleapis.com` for
   * Container Registry and Artifact Registry, make sure that you set
   * up DNS records for domains `*.gcr.io` and `*.pkg.dev`.
   * Defaults to false (VMs have public IP addresses).
   */
  disablePublicIpAddresses: boolean;
  /**
   * Optional. Whether to enable nested virtualization on Cloud Workstations
   * VMs created under this workstation configuration.
   *
   * Nested virtualization lets you run virtual machine (VM) instances
   * inside your workstation. Before enabling nested virtualization,
   * consider the following important considerations. Cloud Workstations
   * instances are subject to the [same restrictions as Compute Engine
   * instances](https://cloud.google.com/compute/docs/instances/nested-virtualization/overview#restrictions):
   *
   * * **Organization policy**: projects, folders, or
   * organizations may be restricted from creating nested VMs if the
   * **Disable VM nested virtualization** constraint is enforced in
   * the organization policy. For more information, see the
   * Compute Engine section,
   * [Checking whether nested virtualization is
   * allowed](https://cloud.google.com/compute/docs/instances/nested-virtualization/managing-constraint#checking_whether_nested_virtualization_is_allowed).
   * * **Performance**: nested VMs might experience a 10% or greater
   * decrease in performance for workloads that are CPU-bound and
   * possibly greater than a 10% decrease for workloads that are
   * input/output bound.
   * * **Machine Type**: nested virtualization can only be enabled on
   * workstation configurations that specify a
   * [machine_type][google.cloud.workstations.v1beta.WorkstationConfig.Host.GceInstance.machine_type]
   * in the N1 or N2 machine series.
   * * **GPUs**: nested virtualization may not be enabled on workstation
   * configurations with accelerators.
   * * **Operating System**: Because
   * [Container-Optimized
   * OS](https://cloud.google.com/compute/docs/images/os-details#container-optimized_os_cos)
   * does not support nested virtualization, when nested virtualization is
   * enabled, the underlying Compute Engine VM instances boot from an
   * [Ubuntu
   * LTS](https://cloud.google.com/compute/docs/images/os-details#ubuntu_lts)
   * image.
   */
  enableNestedVirtualization: boolean;
  /** Optional. A set of Compute Engine Shielded instance options. */
  shieldedInstanceConfig:
    | WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig
    | undefined;
  /** Optional. A set of Compute Engine Confidential VM instance options. */
  confidentialInstanceConfig:
    | WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig
    | undefined;
  /**
   * Optional. The size of the boot disk for the VM in gigabytes (GB).
   * The minimum boot disk size is `30` GB. Defaults to `50` GB.
   */
  bootDiskSizeGb: number;
  /**
   * Optional. A list of the type and count of accelerator cards attached to
   * the instance.
   */
  accelerators: WorkstationConfig_Host_GceInstance_Accelerator[];
}

/** A set of Compute Engine Shielded instance options. */
export interface WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig {
  /** Optional. Whether the instance has Secure Boot enabled. */
  enableSecureBoot: boolean;
  /** Optional. Whether the instance has the vTPM enabled. */
  enableVtpm: boolean;
  /** Optional. Whether the instance has integrity monitoring enabled. */
  enableIntegrityMonitoring: boolean;
}

/** A set of Compute Engine Confidential VM instance options. */
export interface WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig {
  /** Optional. Whether the instance has confidential compute enabled. */
  enableConfidentialCompute: boolean;
}

/** An accelerator card attached to the instance. */
export interface WorkstationConfig_Host_GceInstance_Accelerator {
  /**
   * Optional. Type of accelerator resource to attach to the instance, for
   * example,
   * `"nvidia-tesla-p100"`.
   */
  type: string;
  /** Optional. Number of accelerator cards exposed to the instance. */
  count: number;
}

/** A directory to persist across workstation sessions. */
export interface WorkstationConfig_PersistentDirectory {
  /** A PersistentDirectory backed by a Compute Engine persistent disk. */
  gcePd?:
    | WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk
    | undefined;
  /** Optional. Location of this directory in the running workstation. */
  mountPath: string;
}

/**
 * A PersistentDirectory backed by a Compute Engine regional persistent
 * disk. The
 * [persistent_directories][google.cloud.workstations.v1beta.WorkstationConfig.persistent_directories]
 * field is repeated, but it may contain only one entry. It creates a
 * [persistent
 * disk](https://cloud.google.com/compute/docs/disks/persistent-disks) that
 * mounts to the workstation VM at `/home` when the session starts and
 * detaches when the session ends. If this field is empty, workstations
 * created with this configuration do not have a persistent home
 * directory.
 */
export interface WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk {
  /**
   * Optional. The GB capacity of a persistent home directory for each
   * workstation created with this configuration. Must be empty if
   * [source_snapshot][google.cloud.workstations.v1beta.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.source_snapshot]
   * is set.
   *
   * Valid values are `10`, `50`, `100`, `200`, `500`, or `1000`.
   * Defaults to `200`. If less than `200` GB, the
   * [disk_type][google.cloud.workstations.v1beta.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.disk_type]
   * must be
   * `"pd-balanced"` or `"pd-ssd"`.
   */
  sizeGb: number;
  /**
   * Optional. Type of file system that the disk should be formatted with.
   * The workstation image must support this file system type. Must be empty
   * if
   * [source_snapshot][google.cloud.workstations.v1beta.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.source_snapshot]
   * is set. Defaults to `"ext4"`.
   */
  fsType: string;
  /**
   * Optional. The [type of the persistent
   * disk](https://cloud.google.com/compute/docs/disks#disk-types) for the
   * home directory. Defaults to `"pd-standard"`.
   */
  diskType: string;
  /**
   * Optional. Name of the snapshot to use as the source for the disk. If
   * set,
   * [size_gb][google.cloud.workstations.v1beta.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.size_gb]
   * and
   * [fs_type][google.cloud.workstations.v1beta.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.fs_type]
   * must be empty.
   */
  sourceSnapshot: string;
  /**
   * Optional. Whether the persistent disk should be deleted when the
   * workstation is deleted. Valid values are `DELETE` and `RETAIN`.
   * Defaults to `DELETE`.
   */
  reclaimPolicy: WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicy;
}

/**
 * Value representing what should happen to the disk after the workstation
 * is deleted.
 */
export enum WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicy {
  /** RECLAIM_POLICY_UNSPECIFIED - Do not use. */
  RECLAIM_POLICY_UNSPECIFIED = 0,
  /** DELETE - Delete the persistent disk when deleting the workstation. */
  DELETE = 1,
  /**
   * RETAIN - Keep the persistent disk when deleting the workstation.
   * An administrator must manually delete the disk.
   */
  RETAIN = 2,
  UNRECOGNIZED = -1,
}

export function workstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicyFromJSON(
  object: any,
): WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicy {
  switch (object) {
    case 0:
    case "RECLAIM_POLICY_UNSPECIFIED":
      return WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicy.RECLAIM_POLICY_UNSPECIFIED;
    case 1:
    case "DELETE":
      return WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicy.DELETE;
    case 2:
    case "RETAIN":
      return WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicy.RETAIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicy.UNRECOGNIZED;
  }
}

export function workstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicyToJSON(
  object: WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicy,
): string {
  switch (object) {
    case WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicy.RECLAIM_POLICY_UNSPECIFIED:
      return "RECLAIM_POLICY_UNSPECIFIED";
    case WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicy.DELETE:
      return "DELETE";
    case WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicy.RETAIN:
      return "RETAIN";
    case WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An ephemeral directory which won't persist across workstation sessions. It
 * is freshly created on every workstation start operation.
 */
export interface WorkstationConfig_EphemeralDirectory {
  /** An EphemeralDirectory backed by a Compute Engine persistent disk. */
  gcePd?:
    | WorkstationConfig_EphemeralDirectory_GcePersistentDisk
    | undefined;
  /** Required. Location of this directory in the running workstation. */
  mountPath: string;
}

/** An EphemeralDirectory is backed by a Compute Engine persistent disk. */
export interface WorkstationConfig_EphemeralDirectory_GcePersistentDisk {
  /** Optional. Type of the disk to use. Defaults to `"pd-standard"`. */
  diskType: string;
  /**
   * Optional. Name of the snapshot to use as the source for the disk. Must
   * be empty if
   * [source_image][google.cloud.workstations.v1beta.WorkstationConfig.EphemeralDirectory.GcePersistentDisk.source_image]
   * is set. Updating
   * [source_snapshot][google.cloud.workstations.v1beta.WorkstationConfig.EphemeralDirectory.GcePersistentDisk.source_snapshot]
   * will update content in the ephemeral directory after the workstation is
   * restarted. This field is mutable.
   */
  sourceSnapshot: string;
  /**
   * Optional. Name of the disk image to use as the source for the disk.
   * Must be empty if
   * [source_snapshot][google.cloud.workstations.v1beta.WorkstationConfig.EphemeralDirectory.GcePersistentDisk.source_snapshot]
   * is set. Updating
   * [source_image][google.cloud.workstations.v1beta.WorkstationConfig.EphemeralDirectory.GcePersistentDisk.source_image]
   * will update content in the ephemeral directory after the workstation is
   * restarted. This field is mutable.
   */
  sourceImage: string;
  /**
   * Optional. Whether the disk is read only. If true, the disk may be
   * shared by multiple VMs and
   * [source_snapshot][google.cloud.workstations.v1beta.WorkstationConfig.EphemeralDirectory.GcePersistentDisk.source_snapshot]
   * must be set.
   */
  readOnly: boolean;
}

/** A Docker container. */
export interface WorkstationConfig_Container {
  /**
   * Optional. A Docker container image that defines a custom environment.
   *
   * Cloud Workstations provides a number of
   * [preconfigured
   * images](https://cloud.google.com/workstations/docs/preconfigured-base-images),
   * but you can create your own
   * [custom container
   * images](https://cloud.google.com/workstations/docs/custom-container-images).
   * If using a private image, the `host.gceInstance.serviceAccount` field
   * must be specified in the workstation configuration and must have
   * permission to pull the specified image. Otherwise, the image must be
   * publicly accessible.
   */
  image: string;
  /**
   * Optional. If set, overrides the default ENTRYPOINT specified by the
   * image.
   */
  command: string[];
  /** Optional. Arguments passed to the entrypoint. */
  args: string[];
  /** Optional. Environment variables passed to the container's entrypoint. */
  env: { [key: string]: string };
  /** Optional. If set, overrides the default DIR specified by the image. */
  workingDir: string;
  /**
   * Optional. If set, overrides the USER specified in the image with the
   * given uid.
   */
  runAsUser: number;
}

export interface WorkstationConfig_Container_EnvEntry {
  key: string;
  value: string;
}

/**
 * A customer-managed encryption key (CMEK) for the Compute Engine
 * resources of the associated workstation configuration. Specify the name of
 * your Cloud KMS encryption key and the default service account.
 * We recommend that you use a separate service account and follow
 * [Cloud KMS best
 * practices](https://cloud.google.com/kms/docs/separation-of-duties).
 */
export interface WorkstationConfig_CustomerEncryptionKey {
  /**
   * Immutable. The name of the Google Cloud KMS encryption key. For example,
   * `"projects/PROJECT_ID/locations/REGION/keyRings/KEY_RING/cryptoKeys/KEY_NAME"`.
   * The key must be in the same region as the workstation configuration.
   */
  kmsKey: string;
  /**
   * Immutable. The service account to use with the specified
   * KMS key. We recommend that you use a separate service account
   * and follow KMS best practices. For more information, see
   * [Separation of
   * duties](https://cloud.google.com/kms/docs/separation-of-duties) and
   * `gcloud kms keys add-iam-policy-binding`
   * [`--member`](https://cloud.google.com/sdk/gcloud/reference/kms/keys/add-iam-policy-binding#--member).
   */
  kmsKeyServiceAccount: string;
}

/** A readiness check to be performed on a workstation. */
export interface WorkstationConfig_ReadinessCheck {
  /** Optional. Path to which the request should be sent. */
  path: string;
  /** Optional. Port to which the request should be sent. */
  port: number;
}

export interface WorkstationConfig_AnnotationsEntry {
  key: string;
  value: string;
}

export interface WorkstationConfig_LabelsEntry {
  key: string;
  value: string;
}

/** A single instance of a developer workstation with its own persistent storage. */
export interface Workstation {
  /** Full name of this workstation. */
  name: string;
  /** Optional. Human-readable name for this workstation. */
  displayName: string;
  /** Output only. A system-assigned unique identifier for this workstation. */
  uid: string;
  /**
   * Output only. Indicates whether this workstation is currently being updated
   * to match its intended state.
   */
  reconciling: boolean;
  /** Optional. Client-specified annotations. */
  annotations: { [key: string]: string };
  /**
   * Optional.
   * [Labels](https://cloud.google.com/workstations/docs/label-resources) that
   * are applied to the workstation and that are also propagated to the
   * underlying Compute Engine resources.
   */
  labels: { [key: string]: string };
  /** Output only. Time when this workstation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time when this workstation was most recently updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. Time when this workstation was most recently successfully
   * started, regardless of the workstation's initial state.
   */
  startTime:
    | Date
    | undefined;
  /** Output only. Time when this workstation was soft-deleted. */
  deleteTime:
    | Date
    | undefined;
  /**
   * Optional. Checksum computed by the server. May be sent on update and delete
   * requests to make sure that the client has an up-to-date value before
   * proceeding.
   */
  etag: string;
  /** Output only. Current state of the workstation. */
  state: Workstation_State;
  /**
   * Output only. Host to which clients can send HTTPS traffic that will be
   * received by the workstation. Authorized traffic will be received to the
   * workstation as HTTP on port 80. To send traffic to a different port,
   * clients may prefix the host with the destination port in the format
   * `{port}-{host}`.
   */
  host: string;
  /**
   * Optional. Environment variables passed to the workstation container's
   * entrypoint.
   */
  env: { [key: string]: string };
}

/** Whether a workstation is running and ready to receive user requests. */
export enum Workstation_State {
  /** STATE_UNSPECIFIED - Do not use. */
  STATE_UNSPECIFIED = 0,
  /**
   * STATE_STARTING - The workstation is not yet ready to accept requests from users but will
   * be soon.
   */
  STATE_STARTING = 1,
  /** STATE_RUNNING - The workstation is ready to accept requests from users. */
  STATE_RUNNING = 2,
  /** STATE_STOPPING - The workstation is being stopped. */
  STATE_STOPPING = 3,
  /**
   * STATE_STOPPED - The workstation is stopped and will not be able to receive requests until
   * it is started.
   */
  STATE_STOPPED = 4,
  UNRECOGNIZED = -1,
}

export function workstation_StateFromJSON(object: any): Workstation_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Workstation_State.STATE_UNSPECIFIED;
    case 1:
    case "STATE_STARTING":
      return Workstation_State.STATE_STARTING;
    case 2:
    case "STATE_RUNNING":
      return Workstation_State.STATE_RUNNING;
    case 3:
    case "STATE_STOPPING":
      return Workstation_State.STATE_STOPPING;
    case 4:
    case "STATE_STOPPED":
      return Workstation_State.STATE_STOPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Workstation_State.UNRECOGNIZED;
  }
}

export function workstation_StateToJSON(object: Workstation_State): string {
  switch (object) {
    case Workstation_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Workstation_State.STATE_STARTING:
      return "STATE_STARTING";
    case Workstation_State.STATE_RUNNING:
      return "STATE_RUNNING";
    case Workstation_State.STATE_STOPPING:
      return "STATE_STOPPING";
    case Workstation_State.STATE_STOPPED:
      return "STATE_STOPPED";
    case Workstation_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Workstation_AnnotationsEntry {
  key: string;
  value: string;
}

export interface Workstation_LabelsEntry {
  key: string;
  value: string;
}

export interface Workstation_EnvEntry {
  key: string;
  value: string;
}

/** Request message for GetWorkstationCluster. */
export interface GetWorkstationClusterRequest {
  /** Required. Name of the requested resource. */
  name: string;
}

/** Request message for ListWorkstationClusters. */
export interface ListWorkstationClustersRequest {
  /** Required. Parent resource name. */
  parent: string;
  /** Optional. Maximum number of items to return. */
  pageSize: number;
  /**
   * Optional. next_page_token value returned from a previous List request, if
   * any.
   */
  pageToken: string;
}

/** Response message for ListWorkstationClusters. */
export interface ListWorkstationClustersResponse {
  /** The requested workstation clusters. */
  workstationClusters: WorkstationCluster[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
  /** Unreachable resources. */
  unreachable: string[];
}

/** Message for creating a CreateWorkstationCluster. */
export interface CreateWorkstationClusterRequest {
  /** Required. Parent resource name. */
  parent: string;
  /** Required. ID to use for the workstation cluster. */
  workstationClusterId: string;
  /** Required. Workstation cluster to create. */
  workstationCluster:
    | WorkstationCluster
    | undefined;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * actually apply it.
   */
  validateOnly: boolean;
}

/** Request message for UpdateWorkstationCluster. */
export interface UpdateWorkstationClusterRequest {
  /** Required. Workstation cluster to update. */
  workstationCluster:
    | WorkstationCluster
    | undefined;
  /**
   * Required. Mask that specifies which fields in the workstation cluster
   * should be updated.
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * actually apply it.
   */
  validateOnly: boolean;
  /**
   * Optional. If set, and the workstation cluster is not found, a new
   * workstation cluster will be created. In this situation, update_mask is
   * ignored.
   */
  allowMissing: boolean;
}

/** Message for deleting a workstation cluster. */
export interface DeleteWorkstationClusterRequest {
  /** Required. Name of the workstation cluster to delete. */
  name: string;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * apply it.
   */
  validateOnly: boolean;
  /**
   * Optional. If set, the request will be rejected if the latest version of the
   * workstation cluster on the server does not have this ETag.
   */
  etag: string;
  /**
   * Optional. If set, any workstation configurations and workstations in the
   * workstation cluster are also deleted. Otherwise, the request only
   * works if the workstation cluster has no configurations or workstations.
   */
  force: boolean;
}

/** Request message for GetWorkstationConfig. */
export interface GetWorkstationConfigRequest {
  /** Required. Name of the requested resource. */
  name: string;
}

/** Request message for ListWorkstationConfigs. */
export interface ListWorkstationConfigsRequest {
  /** Required. Parent resource name. */
  parent: string;
  /** Optional. Maximum number of items to return. */
  pageSize: number;
  /**
   * Optional. next_page_token value returned from a previous List request, if
   * any.
   */
  pageToken: string;
}

/** Response message for ListWorkstationConfigs. */
export interface ListWorkstationConfigsResponse {
  /** The requested configs. */
  workstationConfigs: WorkstationConfig[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
  /** Unreachable resources. */
  unreachable: string[];
}

/** Request message for ListUsableWorkstationConfigs. */
export interface ListUsableWorkstationConfigsRequest {
  /** Required. Parent resource name. */
  parent: string;
  /** Optional. Maximum number of items to return. */
  pageSize: number;
  /**
   * Optional. next_page_token value returned from a previous List request, if
   * any.
   */
  pageToken: string;
}

/** Response message for ListUsableWorkstationConfigs. */
export interface ListUsableWorkstationConfigsResponse {
  /** The requested configs. */
  workstationConfigs: WorkstationConfig[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
  /** Unreachable resources. */
  unreachable: string[];
}

/** Message for creating a CreateWorkstationConfig. */
export interface CreateWorkstationConfigRequest {
  /** Required. Parent resource name. */
  parent: string;
  /** Required. ID to use for the workstation configuration. */
  workstationConfigId: string;
  /** Required. Config to create. */
  workstationConfig:
    | WorkstationConfig
    | undefined;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * actually apply it.
   */
  validateOnly: boolean;
}

/** Request message for UpdateWorkstationConfig. */
export interface UpdateWorkstationConfigRequest {
  /** Required. Config to update. */
  workstationConfig:
    | WorkstationConfig
    | undefined;
  /**
   * Required. Mask specifying which fields in the workstation configuration
   * should be updated.
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * actually apply it.
   */
  validateOnly: boolean;
  /**
   * Optional. If set and the workstation configuration is not found, a new
   * workstation configuration will be created. In this situation,
   * update_mask is ignored.
   */
  allowMissing: boolean;
}

/** Message for deleting a workstation configuration. */
export interface DeleteWorkstationConfigRequest {
  /** Required. Name of the workstation configuration to delete. */
  name: string;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * actually apply it.
   */
  validateOnly: boolean;
  /**
   * Optional. If set, the request is rejected if the latest version of the
   * workstation configuration on the server does not have this ETag.
   */
  etag: string;
  /**
   * Optional. If set, any workstations in the workstation configuration are
   * also deleted. Otherwise, the request works only if the workstation
   * configuration has no workstations.
   */
  force: boolean;
}

/** Request message for GetWorkstation. */
export interface GetWorkstationRequest {
  /** Required. Name of the requested resource. */
  name: string;
}

/** Request message for ListWorkstations. */
export interface ListWorkstationsRequest {
  /** Required. Parent resource name. */
  parent: string;
  /** Optional. Maximum number of items to return. */
  pageSize: number;
  /**
   * Optional. next_page_token value returned from a previous List request, if
   * any.
   */
  pageToken: string;
}

/** Response message for ListWorkstations. */
export interface ListWorkstationsResponse {
  /** The requested workstations. */
  workstations: Workstation[];
  /**
   * Optional. Token to retrieve the next page of results, or empty if there are
   * no more results in the list.
   */
  nextPageToken: string;
  /** Optional. Unreachable resources. */
  unreachable: string[];
}

/** Request message for ListUsableWorkstations. */
export interface ListUsableWorkstationsRequest {
  /** Required. Parent resource name. */
  parent: string;
  /** Optional. Maximum number of items to return. */
  pageSize: number;
  /**
   * Optional. next_page_token value returned from a previous List request, if
   * any.
   */
  pageToken: string;
}

/** Response message for ListUsableWorkstations. */
export interface ListUsableWorkstationsResponse {
  /** The requested workstations. */
  workstations: Workstation[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
  /** Unreachable resources. */
  unreachable: string[];
}

/** Message for creating a CreateWorkstation. */
export interface CreateWorkstationRequest {
  /** Required. Parent resource name. */
  parent: string;
  /** Required. ID to use for the workstation. */
  workstationId: string;
  /** Required. Workstation to create. */
  workstation:
    | Workstation
    | undefined;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * actually apply it.
   */
  validateOnly: boolean;
}

/** Request message for UpdateWorkstation. */
export interface UpdateWorkstationRequest {
  /** Required. Workstation to update. */
  workstation:
    | Workstation
    | undefined;
  /**
   * Required. Mask specifying which fields in the workstation configuration
   * should be updated.
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * actually apply it.
   */
  validateOnly: boolean;
  /**
   * Optional. If set and the workstation configuration is not found, a new
   * workstation configuration is created. In this situation, update_mask
   * is ignored.
   */
  allowMissing: boolean;
}

/** Request message for DeleteWorkstation. */
export interface DeleteWorkstationRequest {
  /** Required. Name of the workstation to delete. */
  name: string;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * actually apply it.
   */
  validateOnly: boolean;
  /**
   * Optional. If set, the request will be rejected if the latest version of the
   * workstation on the server does not have this ETag.
   */
  etag: string;
}

/** Request message for StartWorkstation. */
export interface StartWorkstationRequest {
  /** Required. Name of the workstation to start. */
  name: string;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * actually apply it.
   */
  validateOnly: boolean;
  /**
   * Optional. If set, the request will be rejected if the latest version of the
   * workstation on the server does not have this ETag.
   */
  etag: string;
}

/** Request message for StopWorkstation. */
export interface StopWorkstationRequest {
  /** Required. Name of the workstation to stop. */
  name: string;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * actually apply it.
   */
  validateOnly: boolean;
  /**
   * Optional. If set, the request will be rejected if the latest version of the
   * workstation on the server does not have this ETag.
   */
  etag: string;
}

/** Request message for GenerateAccessToken. */
export interface GenerateAccessTokenRequest {
  /**
   * Desired expiration time of the access token. This value must
   * be at most 24 hours in the future. If a value is not specified, the
   * token's expiration time will be set to a default value of 1 hour in the
   * future.
   */
  expireTime?:
    | Date
    | undefined;
  /**
   * Desired lifetime duration of the access token. This value must
   * be at most 24 hours. If a value is not specified, the token's lifetime
   * will be set to a default value of 1 hour.
   */
  ttl?:
    | Duration
    | undefined;
  /**
   * Required. Name of the workstation for which the access token should be
   * generated.
   */
  workstation: string;
}

/** Response message for GenerateAccessToken. */
export interface GenerateAccessTokenResponse {
  /**
   * The generated bearer access token. To use this token, include it in an
   * Authorization header of an HTTP request sent to the associated
   * workstation's hostname—for example, `Authorization: Bearer
   * <access_token>`.
   */
  accessToken: string;
  /** Time at which the generated token will expire. */
  expireTime: Date | undefined;
}

/** Metadata for long-running operations. */
export interface OperationMetadata {
  /** Output only. Time that the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time that the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /** Output only. Human-readable status of the operation, if any. */
  statusMessage: string;
  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation.
   */
  requestedCancellation: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

function createBaseWorkstationCluster(): WorkstationCluster {
  return {
    name: "",
    displayName: "",
    uid: "",
    reconciling: false,
    annotations: {},
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    deleteTime: undefined,
    etag: "",
    network: "",
    subnetwork: "",
    controlPlaneIp: "",
    privateClusterConfig: undefined,
    degraded: false,
    conditions: [],
  };
}

export const WorkstationCluster: MessageFns<WorkstationCluster> = {
  encode(message: WorkstationCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.uid !== "") {
      writer.uint32(26).string(message.uid);
    }
    if (message.reconciling !== false) {
      writer.uint32(32).bool(message.reconciling);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      WorkstationCluster_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      WorkstationCluster_LabelsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(66).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(74).string(message.etag);
    }
    if (message.network !== "") {
      writer.uint32(82).string(message.network);
    }
    if (message.subnetwork !== "") {
      writer.uint32(90).string(message.subnetwork);
    }
    if (message.controlPlaneIp !== "") {
      writer.uint32(130).string(message.controlPlaneIp);
    }
    if (message.privateClusterConfig !== undefined) {
      WorkstationCluster_PrivateClusterConfig.encode(message.privateClusterConfig, writer.uint32(98).fork()).join();
    }
    if (message.degraded !== false) {
      writer.uint32(104).bool(message.degraded);
    }
    for (const v of message.conditions) {
      Status.encode(v!, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.reconciling = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = WorkstationCluster_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.annotations[entry5.key] = entry5.value;
          }
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = WorkstationCluster_LabelsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.labels[entry15.key] = entry15.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.network = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.controlPlaneIp = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.privateClusterConfig = WorkstationCluster_PrivateClusterConfig.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.degraded = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.conditions.push(Status.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationCluster {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      reconciling: isSet(object.reconciling) ? globalThis.Boolean(object.reconciling) : false,
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
      controlPlaneIp: isSet(object.controlPlaneIp) ? globalThis.String(object.controlPlaneIp) : "",
      privateClusterConfig: isSet(object.privateClusterConfig)
        ? WorkstationCluster_PrivateClusterConfig.fromJSON(object.privateClusterConfig)
        : undefined,
      degraded: isSet(object.degraded) ? globalThis.Boolean(object.degraded) : false,
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => Status.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WorkstationCluster): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.reconciling !== false) {
      obj.reconciling = message.reconciling;
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    if (message.controlPlaneIp !== "") {
      obj.controlPlaneIp = message.controlPlaneIp;
    }
    if (message.privateClusterConfig !== undefined) {
      obj.privateClusterConfig = WorkstationCluster_PrivateClusterConfig.toJSON(message.privateClusterConfig);
    }
    if (message.degraded !== false) {
      obj.degraded = message.degraded;
    }
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => Status.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationCluster>): WorkstationCluster {
    return WorkstationCluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationCluster>): WorkstationCluster {
    const message = createBaseWorkstationCluster();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.uid = object.uid ?? "";
    message.reconciling = object.reconciling ?? false;
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.etag = object.etag ?? "";
    message.network = object.network ?? "";
    message.subnetwork = object.subnetwork ?? "";
    message.controlPlaneIp = object.controlPlaneIp ?? "";
    message.privateClusterConfig = (object.privateClusterConfig !== undefined && object.privateClusterConfig !== null)
      ? WorkstationCluster_PrivateClusterConfig.fromPartial(object.privateClusterConfig)
      : undefined;
    message.degraded = object.degraded ?? false;
    message.conditions = object.conditions?.map((e) => Status.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorkstationCluster_PrivateClusterConfig(): WorkstationCluster_PrivateClusterConfig {
  return { enablePrivateEndpoint: false, clusterHostname: "", serviceAttachmentUri: "", allowedProjects: [] };
}

export const WorkstationCluster_PrivateClusterConfig: MessageFns<WorkstationCluster_PrivateClusterConfig> = {
  encode(message: WorkstationCluster_PrivateClusterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enablePrivateEndpoint !== false) {
      writer.uint32(8).bool(message.enablePrivateEndpoint);
    }
    if (message.clusterHostname !== "") {
      writer.uint32(18).string(message.clusterHostname);
    }
    if (message.serviceAttachmentUri !== "") {
      writer.uint32(26).string(message.serviceAttachmentUri);
    }
    for (const v of message.allowedProjects) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationCluster_PrivateClusterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationCluster_PrivateClusterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enablePrivateEndpoint = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clusterHostname = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceAttachmentUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.allowedProjects.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationCluster_PrivateClusterConfig {
    return {
      enablePrivateEndpoint: isSet(object.enablePrivateEndpoint)
        ? globalThis.Boolean(object.enablePrivateEndpoint)
        : false,
      clusterHostname: isSet(object.clusterHostname) ? globalThis.String(object.clusterHostname) : "",
      serviceAttachmentUri: isSet(object.serviceAttachmentUri) ? globalThis.String(object.serviceAttachmentUri) : "",
      allowedProjects: globalThis.Array.isArray(object?.allowedProjects)
        ? object.allowedProjects.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: WorkstationCluster_PrivateClusterConfig): unknown {
    const obj: any = {};
    if (message.enablePrivateEndpoint !== false) {
      obj.enablePrivateEndpoint = message.enablePrivateEndpoint;
    }
    if (message.clusterHostname !== "") {
      obj.clusterHostname = message.clusterHostname;
    }
    if (message.serviceAttachmentUri !== "") {
      obj.serviceAttachmentUri = message.serviceAttachmentUri;
    }
    if (message.allowedProjects?.length) {
      obj.allowedProjects = message.allowedProjects;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationCluster_PrivateClusterConfig>): WorkstationCluster_PrivateClusterConfig {
    return WorkstationCluster_PrivateClusterConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationCluster_PrivateClusterConfig>): WorkstationCluster_PrivateClusterConfig {
    const message = createBaseWorkstationCluster_PrivateClusterConfig();
    message.enablePrivateEndpoint = object.enablePrivateEndpoint ?? false;
    message.clusterHostname = object.clusterHostname ?? "";
    message.serviceAttachmentUri = object.serviceAttachmentUri ?? "";
    message.allowedProjects = object.allowedProjects?.map((e) => e) || [];
    return message;
  },
};

function createBaseWorkstationCluster_AnnotationsEntry(): WorkstationCluster_AnnotationsEntry {
  return { key: "", value: "" };
}

export const WorkstationCluster_AnnotationsEntry: MessageFns<WorkstationCluster_AnnotationsEntry> = {
  encode(message: WorkstationCluster_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationCluster_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationCluster_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationCluster_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WorkstationCluster_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationCluster_AnnotationsEntry>): WorkstationCluster_AnnotationsEntry {
    return WorkstationCluster_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationCluster_AnnotationsEntry>): WorkstationCluster_AnnotationsEntry {
    const message = createBaseWorkstationCluster_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWorkstationCluster_LabelsEntry(): WorkstationCluster_LabelsEntry {
  return { key: "", value: "" };
}

export const WorkstationCluster_LabelsEntry: MessageFns<WorkstationCluster_LabelsEntry> = {
  encode(message: WorkstationCluster_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationCluster_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationCluster_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationCluster_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WorkstationCluster_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationCluster_LabelsEntry>): WorkstationCluster_LabelsEntry {
    return WorkstationCluster_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationCluster_LabelsEntry>): WorkstationCluster_LabelsEntry {
    const message = createBaseWorkstationCluster_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWorkstationConfig(): WorkstationConfig {
  return {
    name: "",
    displayName: "",
    uid: "",
    reconciling: false,
    annotations: {},
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    deleteTime: undefined,
    etag: "",
    idleTimeout: undefined,
    runningTimeout: undefined,
    host: undefined,
    persistentDirectories: [],
    ephemeralDirectories: [],
    container: undefined,
    encryptionKey: undefined,
    readinessChecks: [],
    replicaZones: [],
    degraded: false,
    conditions: [],
    enableAuditAgent: false,
  };
}

export const WorkstationConfig: MessageFns<WorkstationConfig> = {
  encode(message: WorkstationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.uid !== "") {
      writer.uint32(26).string(message.uid);
    }
    if (message.reconciling !== false) {
      writer.uint32(32).bool(message.reconciling);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      WorkstationConfig_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      WorkstationConfig_LabelsEntry.encode({ key: key as any, value }, writer.uint32(146).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(66).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(74).string(message.etag);
    }
    if (message.idleTimeout !== undefined) {
      Duration.encode(message.idleTimeout, writer.uint32(82).fork()).join();
    }
    if (message.runningTimeout !== undefined) {
      Duration.encode(message.runningTimeout, writer.uint32(90).fork()).join();
    }
    if (message.host !== undefined) {
      WorkstationConfig_Host.encode(message.host, writer.uint32(98).fork()).join();
    }
    for (const v of message.persistentDirectories) {
      WorkstationConfig_PersistentDirectory.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.ephemeralDirectories) {
      WorkstationConfig_EphemeralDirectory.encode(v!, writer.uint32(178).fork()).join();
    }
    if (message.container !== undefined) {
      WorkstationConfig_Container.encode(message.container, writer.uint32(114).fork()).join();
    }
    if (message.encryptionKey !== undefined) {
      WorkstationConfig_CustomerEncryptionKey.encode(message.encryptionKey, writer.uint32(138).fork()).join();
    }
    for (const v of message.readinessChecks) {
      WorkstationConfig_ReadinessCheck.encode(v!, writer.uint32(154).fork()).join();
    }
    for (const v of message.replicaZones) {
      writer.uint32(186).string(v!);
    }
    if (message.degraded !== false) {
      writer.uint32(120).bool(message.degraded);
    }
    for (const v of message.conditions) {
      Status.encode(v!, writer.uint32(130).fork()).join();
    }
    if (message.enableAuditAgent !== false) {
      writer.uint32(160).bool(message.enableAuditAgent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.reconciling = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = WorkstationConfig_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.annotations[entry5.key] = entry5.value;
          }
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          const entry18 = WorkstationConfig_LabelsEntry.decode(reader, reader.uint32());
          if (entry18.value !== undefined) {
            message.labels[entry18.key] = entry18.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.idleTimeout = Duration.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.runningTimeout = Duration.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.host = WorkstationConfig_Host.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.persistentDirectories.push(WorkstationConfig_PersistentDirectory.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.ephemeralDirectories.push(WorkstationConfig_EphemeralDirectory.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.container = WorkstationConfig_Container.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.encryptionKey = WorkstationConfig_CustomerEncryptionKey.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.readinessChecks.push(WorkstationConfig_ReadinessCheck.decode(reader, reader.uint32()));
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.replicaZones.push(reader.string());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.degraded = reader.bool();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.conditions.push(Status.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.enableAuditAgent = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      reconciling: isSet(object.reconciling) ? globalThis.Boolean(object.reconciling) : false,
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      idleTimeout: isSet(object.idleTimeout) ? Duration.fromJSON(object.idleTimeout) : undefined,
      runningTimeout: isSet(object.runningTimeout) ? Duration.fromJSON(object.runningTimeout) : undefined,
      host: isSet(object.host) ? WorkstationConfig_Host.fromJSON(object.host) : undefined,
      persistentDirectories: globalThis.Array.isArray(object?.persistentDirectories)
        ? object.persistentDirectories.map((e: any) => WorkstationConfig_PersistentDirectory.fromJSON(e))
        : [],
      ephemeralDirectories: globalThis.Array.isArray(object?.ephemeralDirectories)
        ? object.ephemeralDirectories.map((e: any) => WorkstationConfig_EphemeralDirectory.fromJSON(e))
        : [],
      container: isSet(object.container) ? WorkstationConfig_Container.fromJSON(object.container) : undefined,
      encryptionKey: isSet(object.encryptionKey)
        ? WorkstationConfig_CustomerEncryptionKey.fromJSON(object.encryptionKey)
        : undefined,
      readinessChecks: globalThis.Array.isArray(object?.readinessChecks)
        ? object.readinessChecks.map((e: any) => WorkstationConfig_ReadinessCheck.fromJSON(e))
        : [],
      replicaZones: globalThis.Array.isArray(object?.replicaZones)
        ? object.replicaZones.map((e: any) => globalThis.String(e))
        : [],
      degraded: isSet(object.degraded) ? globalThis.Boolean(object.degraded) : false,
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => Status.fromJSON(e))
        : [],
      enableAuditAgent: isSet(object.enableAuditAgent) ? globalThis.Boolean(object.enableAuditAgent) : false,
    };
  },

  toJSON(message: WorkstationConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.reconciling !== false) {
      obj.reconciling = message.reconciling;
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.idleTimeout !== undefined) {
      obj.idleTimeout = Duration.toJSON(message.idleTimeout);
    }
    if (message.runningTimeout !== undefined) {
      obj.runningTimeout = Duration.toJSON(message.runningTimeout);
    }
    if (message.host !== undefined) {
      obj.host = WorkstationConfig_Host.toJSON(message.host);
    }
    if (message.persistentDirectories?.length) {
      obj.persistentDirectories = message.persistentDirectories.map((e) =>
        WorkstationConfig_PersistentDirectory.toJSON(e)
      );
    }
    if (message.ephemeralDirectories?.length) {
      obj.ephemeralDirectories = message.ephemeralDirectories.map((e) =>
        WorkstationConfig_EphemeralDirectory.toJSON(e)
      );
    }
    if (message.container !== undefined) {
      obj.container = WorkstationConfig_Container.toJSON(message.container);
    }
    if (message.encryptionKey !== undefined) {
      obj.encryptionKey = WorkstationConfig_CustomerEncryptionKey.toJSON(message.encryptionKey);
    }
    if (message.readinessChecks?.length) {
      obj.readinessChecks = message.readinessChecks.map((e) => WorkstationConfig_ReadinessCheck.toJSON(e));
    }
    if (message.replicaZones?.length) {
      obj.replicaZones = message.replicaZones;
    }
    if (message.degraded !== false) {
      obj.degraded = message.degraded;
    }
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => Status.toJSON(e));
    }
    if (message.enableAuditAgent !== false) {
      obj.enableAuditAgent = message.enableAuditAgent;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationConfig>): WorkstationConfig {
    return WorkstationConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationConfig>): WorkstationConfig {
    const message = createBaseWorkstationConfig();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.uid = object.uid ?? "";
    message.reconciling = object.reconciling ?? false;
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.etag = object.etag ?? "";
    message.idleTimeout = (object.idleTimeout !== undefined && object.idleTimeout !== null)
      ? Duration.fromPartial(object.idleTimeout)
      : undefined;
    message.runningTimeout = (object.runningTimeout !== undefined && object.runningTimeout !== null)
      ? Duration.fromPartial(object.runningTimeout)
      : undefined;
    message.host = (object.host !== undefined && object.host !== null)
      ? WorkstationConfig_Host.fromPartial(object.host)
      : undefined;
    message.persistentDirectories =
      object.persistentDirectories?.map((e) => WorkstationConfig_PersistentDirectory.fromPartial(e)) || [];
    message.ephemeralDirectories =
      object.ephemeralDirectories?.map((e) => WorkstationConfig_EphemeralDirectory.fromPartial(e)) || [];
    message.container = (object.container !== undefined && object.container !== null)
      ? WorkstationConfig_Container.fromPartial(object.container)
      : undefined;
    message.encryptionKey = (object.encryptionKey !== undefined && object.encryptionKey !== null)
      ? WorkstationConfig_CustomerEncryptionKey.fromPartial(object.encryptionKey)
      : undefined;
    message.readinessChecks = object.readinessChecks?.map((e) => WorkstationConfig_ReadinessCheck.fromPartial(e)) || [];
    message.replicaZones = object.replicaZones?.map((e) => e) || [];
    message.degraded = object.degraded ?? false;
    message.conditions = object.conditions?.map((e) => Status.fromPartial(e)) || [];
    message.enableAuditAgent = object.enableAuditAgent ?? false;
    return message;
  },
};

function createBaseWorkstationConfig_Host(): WorkstationConfig_Host {
  return { gceInstance: undefined };
}

export const WorkstationConfig_Host: MessageFns<WorkstationConfig_Host> = {
  encode(message: WorkstationConfig_Host, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gceInstance !== undefined) {
      WorkstationConfig_Host_GceInstance.encode(message.gceInstance, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationConfig_Host {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_Host();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gceInstance = WorkstationConfig_Host_GceInstance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_Host {
    return {
      gceInstance: isSet(object.gceInstance)
        ? WorkstationConfig_Host_GceInstance.fromJSON(object.gceInstance)
        : undefined,
    };
  },

  toJSON(message: WorkstationConfig_Host): unknown {
    const obj: any = {};
    if (message.gceInstance !== undefined) {
      obj.gceInstance = WorkstationConfig_Host_GceInstance.toJSON(message.gceInstance);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationConfig_Host>): WorkstationConfig_Host {
    return WorkstationConfig_Host.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationConfig_Host>): WorkstationConfig_Host {
    const message = createBaseWorkstationConfig_Host();
    message.gceInstance = (object.gceInstance !== undefined && object.gceInstance !== null)
      ? WorkstationConfig_Host_GceInstance.fromPartial(object.gceInstance)
      : undefined;
    return message;
  },
};

function createBaseWorkstationConfig_Host_GceInstance(): WorkstationConfig_Host_GceInstance {
  return {
    machineType: "",
    serviceAccount: "",
    serviceAccountScopes: [],
    tags: [],
    poolSize: 0,
    pooledInstances: 0,
    disablePublicIpAddresses: false,
    enableNestedVirtualization: false,
    shieldedInstanceConfig: undefined,
    confidentialInstanceConfig: undefined,
    bootDiskSizeGb: 0,
    accelerators: [],
  };
}

export const WorkstationConfig_Host_GceInstance: MessageFns<WorkstationConfig_Host_GceInstance> = {
  encode(message: WorkstationConfig_Host_GceInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineType !== "") {
      writer.uint32(10).string(message.machineType);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(18).string(message.serviceAccount);
    }
    for (const v of message.serviceAccountScopes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    if (message.poolSize !== 0) {
      writer.uint32(40).int32(message.poolSize);
    }
    if (message.pooledInstances !== 0) {
      writer.uint32(96).int32(message.pooledInstances);
    }
    if (message.disablePublicIpAddresses !== false) {
      writer.uint32(48).bool(message.disablePublicIpAddresses);
    }
    if (message.enableNestedVirtualization !== false) {
      writer.uint32(56).bool(message.enableNestedVirtualization);
    }
    if (message.shieldedInstanceConfig !== undefined) {
      WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig.encode(
        message.shieldedInstanceConfig,
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.confidentialInstanceConfig !== undefined) {
      WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig.encode(
        message.confidentialInstanceConfig,
        writer.uint32(82).fork(),
      ).join();
    }
    if (message.bootDiskSizeGb !== 0) {
      writer.uint32(72).int32(message.bootDiskSizeGb);
    }
    for (const v of message.accelerators) {
      WorkstationConfig_Host_GceInstance_Accelerator.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationConfig_Host_GceInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_Host_GceInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceAccountScopes.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.poolSize = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.pooledInstances = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.disablePublicIpAddresses = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.enableNestedVirtualization = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.shieldedInstanceConfig = WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.confidentialInstanceConfig = WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.bootDiskSizeGb = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.accelerators.push(WorkstationConfig_Host_GceInstance_Accelerator.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_Host_GceInstance {
    return {
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      serviceAccountScopes: globalThis.Array.isArray(object?.serviceAccountScopes)
        ? object.serviceAccountScopes.map((e: any) => globalThis.String(e))
        : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      poolSize: isSet(object.poolSize) ? globalThis.Number(object.poolSize) : 0,
      pooledInstances: isSet(object.pooledInstances) ? globalThis.Number(object.pooledInstances) : 0,
      disablePublicIpAddresses: isSet(object.disablePublicIpAddresses)
        ? globalThis.Boolean(object.disablePublicIpAddresses)
        : false,
      enableNestedVirtualization: isSet(object.enableNestedVirtualization)
        ? globalThis.Boolean(object.enableNestedVirtualization)
        : false,
      shieldedInstanceConfig: isSet(object.shieldedInstanceConfig)
        ? WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig.fromJSON(object.shieldedInstanceConfig)
        : undefined,
      confidentialInstanceConfig: isSet(object.confidentialInstanceConfig)
        ? WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig.fromJSON(object.confidentialInstanceConfig)
        : undefined,
      bootDiskSizeGb: isSet(object.bootDiskSizeGb) ? globalThis.Number(object.bootDiskSizeGb) : 0,
      accelerators: globalThis.Array.isArray(object?.accelerators)
        ? object.accelerators.map((e: any) => WorkstationConfig_Host_GceInstance_Accelerator.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WorkstationConfig_Host_GceInstance): unknown {
    const obj: any = {};
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.serviceAccountScopes?.length) {
      obj.serviceAccountScopes = message.serviceAccountScopes;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.poolSize !== 0) {
      obj.poolSize = Math.round(message.poolSize);
    }
    if (message.pooledInstances !== 0) {
      obj.pooledInstances = Math.round(message.pooledInstances);
    }
    if (message.disablePublicIpAddresses !== false) {
      obj.disablePublicIpAddresses = message.disablePublicIpAddresses;
    }
    if (message.enableNestedVirtualization !== false) {
      obj.enableNestedVirtualization = message.enableNestedVirtualization;
    }
    if (message.shieldedInstanceConfig !== undefined) {
      obj.shieldedInstanceConfig = WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig.toJSON(
        message.shieldedInstanceConfig,
      );
    }
    if (message.confidentialInstanceConfig !== undefined) {
      obj.confidentialInstanceConfig = WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig.toJSON(
        message.confidentialInstanceConfig,
      );
    }
    if (message.bootDiskSizeGb !== 0) {
      obj.bootDiskSizeGb = Math.round(message.bootDiskSizeGb);
    }
    if (message.accelerators?.length) {
      obj.accelerators = message.accelerators.map((e) => WorkstationConfig_Host_GceInstance_Accelerator.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationConfig_Host_GceInstance>): WorkstationConfig_Host_GceInstance {
    return WorkstationConfig_Host_GceInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationConfig_Host_GceInstance>): WorkstationConfig_Host_GceInstance {
    const message = createBaseWorkstationConfig_Host_GceInstance();
    message.machineType = object.machineType ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    message.serviceAccountScopes = object.serviceAccountScopes?.map((e) => e) || [];
    message.tags = object.tags?.map((e) => e) || [];
    message.poolSize = object.poolSize ?? 0;
    message.pooledInstances = object.pooledInstances ?? 0;
    message.disablePublicIpAddresses = object.disablePublicIpAddresses ?? false;
    message.enableNestedVirtualization = object.enableNestedVirtualization ?? false;
    message.shieldedInstanceConfig =
      (object.shieldedInstanceConfig !== undefined && object.shieldedInstanceConfig !== null)
        ? WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig.fromPartial(object.shieldedInstanceConfig)
        : undefined;
    message.confidentialInstanceConfig =
      (object.confidentialInstanceConfig !== undefined && object.confidentialInstanceConfig !== null)
        ? WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig.fromPartial(
          object.confidentialInstanceConfig,
        )
        : undefined;
    message.bootDiskSizeGb = object.bootDiskSizeGb ?? 0;
    message.accelerators =
      object.accelerators?.map((e) => WorkstationConfig_Host_GceInstance_Accelerator.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig(): WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig {
  return { enableSecureBoot: false, enableVtpm: false, enableIntegrityMonitoring: false };
}

export const WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig: MessageFns<
  WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig
> = {
  encode(
    message: WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.enableSecureBoot !== false) {
      writer.uint32(8).bool(message.enableSecureBoot);
    }
    if (message.enableVtpm !== false) {
      writer.uint32(16).bool(message.enableVtpm);
    }
    if (message.enableIntegrityMonitoring !== false) {
      writer.uint32(24).bool(message.enableIntegrityMonitoring);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableSecureBoot = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableVtpm = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enableIntegrityMonitoring = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig {
    return {
      enableSecureBoot: isSet(object.enableSecureBoot) ? globalThis.Boolean(object.enableSecureBoot) : false,
      enableVtpm: isSet(object.enableVtpm) ? globalThis.Boolean(object.enableVtpm) : false,
      enableIntegrityMonitoring: isSet(object.enableIntegrityMonitoring)
        ? globalThis.Boolean(object.enableIntegrityMonitoring)
        : false,
    };
  },

  toJSON(message: WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig): unknown {
    const obj: any = {};
    if (message.enableSecureBoot !== false) {
      obj.enableSecureBoot = message.enableSecureBoot;
    }
    if (message.enableVtpm !== false) {
      obj.enableVtpm = message.enableVtpm;
    }
    if (message.enableIntegrityMonitoring !== false) {
      obj.enableIntegrityMonitoring = message.enableIntegrityMonitoring;
    }
    return obj;
  },

  create(
    base?: DeepPartial<WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig>,
  ): WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig {
    return WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig>,
  ): WorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig {
    const message = createBaseWorkstationConfig_Host_GceInstance_GceShieldedInstanceConfig();
    message.enableSecureBoot = object.enableSecureBoot ?? false;
    message.enableVtpm = object.enableVtpm ?? false;
    message.enableIntegrityMonitoring = object.enableIntegrityMonitoring ?? false;
    return message;
  },
};

function createBaseWorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig(): WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig {
  return { enableConfidentialCompute: false };
}

export const WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig: MessageFns<
  WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig
> = {
  encode(
    message: WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.enableConfidentialCompute !== false) {
      writer.uint32(8).bool(message.enableConfidentialCompute);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableConfidentialCompute = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig {
    return {
      enableConfidentialCompute: isSet(object.enableConfidentialCompute)
        ? globalThis.Boolean(object.enableConfidentialCompute)
        : false,
    };
  },

  toJSON(message: WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig): unknown {
    const obj: any = {};
    if (message.enableConfidentialCompute !== false) {
      obj.enableConfidentialCompute = message.enableConfidentialCompute;
    }
    return obj;
  },

  create(
    base?: DeepPartial<WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig>,
  ): WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig {
    return WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig>,
  ): WorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig {
    const message = createBaseWorkstationConfig_Host_GceInstance_GceConfidentialInstanceConfig();
    message.enableConfidentialCompute = object.enableConfidentialCompute ?? false;
    return message;
  },
};

function createBaseWorkstationConfig_Host_GceInstance_Accelerator(): WorkstationConfig_Host_GceInstance_Accelerator {
  return { type: "", count: 0 };
}

export const WorkstationConfig_Host_GceInstance_Accelerator: MessageFns<
  WorkstationConfig_Host_GceInstance_Accelerator
> = {
  encode(
    message: WorkstationConfig_Host_GceInstance_Accelerator,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationConfig_Host_GceInstance_Accelerator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_Host_GceInstance_Accelerator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_Host_GceInstance_Accelerator {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: WorkstationConfig_Host_GceInstance_Accelerator): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(
    base?: DeepPartial<WorkstationConfig_Host_GceInstance_Accelerator>,
  ): WorkstationConfig_Host_GceInstance_Accelerator {
    return WorkstationConfig_Host_GceInstance_Accelerator.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WorkstationConfig_Host_GceInstance_Accelerator>,
  ): WorkstationConfig_Host_GceInstance_Accelerator {
    const message = createBaseWorkstationConfig_Host_GceInstance_Accelerator();
    message.type = object.type ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseWorkstationConfig_PersistentDirectory(): WorkstationConfig_PersistentDirectory {
  return { gcePd: undefined, mountPath: "" };
}

export const WorkstationConfig_PersistentDirectory: MessageFns<WorkstationConfig_PersistentDirectory> = {
  encode(message: WorkstationConfig_PersistentDirectory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcePd !== undefined) {
      WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk.encode(message.gcePd, writer.uint32(18).fork())
        .join();
    }
    if (message.mountPath !== "") {
      writer.uint32(10).string(message.mountPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationConfig_PersistentDirectory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_PersistentDirectory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcePd = WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mountPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_PersistentDirectory {
    return {
      gcePd: isSet(object.gcePd)
        ? WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk.fromJSON(object.gcePd)
        : undefined,
      mountPath: isSet(object.mountPath) ? globalThis.String(object.mountPath) : "",
    };
  },

  toJSON(message: WorkstationConfig_PersistentDirectory): unknown {
    const obj: any = {};
    if (message.gcePd !== undefined) {
      obj.gcePd = WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk.toJSON(message.gcePd);
    }
    if (message.mountPath !== "") {
      obj.mountPath = message.mountPath;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationConfig_PersistentDirectory>): WorkstationConfig_PersistentDirectory {
    return WorkstationConfig_PersistentDirectory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationConfig_PersistentDirectory>): WorkstationConfig_PersistentDirectory {
    const message = createBaseWorkstationConfig_PersistentDirectory();
    message.gcePd = (object.gcePd !== undefined && object.gcePd !== null)
      ? WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk.fromPartial(object.gcePd)
      : undefined;
    message.mountPath = object.mountPath ?? "";
    return message;
  },
};

function createBaseWorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk(): WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk {
  return { sizeGb: 0, fsType: "", diskType: "", sourceSnapshot: "", reclaimPolicy: 0 };
}

export const WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk: MessageFns<
  WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk
> = {
  encode(
    message: WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sizeGb !== 0) {
      writer.uint32(8).int32(message.sizeGb);
    }
    if (message.fsType !== "") {
      writer.uint32(18).string(message.fsType);
    }
    if (message.diskType !== "") {
      writer.uint32(26).string(message.diskType);
    }
    if (message.sourceSnapshot !== "") {
      writer.uint32(42).string(message.sourceSnapshot);
    }
    if (message.reclaimPolicy !== 0) {
      writer.uint32(32).int32(message.reclaimPolicy);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sizeGb = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fsType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.diskType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sourceSnapshot = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.reclaimPolicy = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk {
    return {
      sizeGb: isSet(object.sizeGb) ? globalThis.Number(object.sizeGb) : 0,
      fsType: isSet(object.fsType) ? globalThis.String(object.fsType) : "",
      diskType: isSet(object.diskType) ? globalThis.String(object.diskType) : "",
      sourceSnapshot: isSet(object.sourceSnapshot) ? globalThis.String(object.sourceSnapshot) : "",
      reclaimPolicy: isSet(object.reclaimPolicy)
        ? workstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicyFromJSON(object.reclaimPolicy)
        : 0,
    };
  },

  toJSON(message: WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk): unknown {
    const obj: any = {};
    if (message.sizeGb !== 0) {
      obj.sizeGb = Math.round(message.sizeGb);
    }
    if (message.fsType !== "") {
      obj.fsType = message.fsType;
    }
    if (message.diskType !== "") {
      obj.diskType = message.diskType;
    }
    if (message.sourceSnapshot !== "") {
      obj.sourceSnapshot = message.sourceSnapshot;
    }
    if (message.reclaimPolicy !== 0) {
      obj.reclaimPolicy = workstationConfig_PersistentDirectory_GceRegionalPersistentDisk_ReclaimPolicyToJSON(
        message.reclaimPolicy,
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk>,
  ): WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk {
    return WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk>,
  ): WorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk {
    const message = createBaseWorkstationConfig_PersistentDirectory_GceRegionalPersistentDisk();
    message.sizeGb = object.sizeGb ?? 0;
    message.fsType = object.fsType ?? "";
    message.diskType = object.diskType ?? "";
    message.sourceSnapshot = object.sourceSnapshot ?? "";
    message.reclaimPolicy = object.reclaimPolicy ?? 0;
    return message;
  },
};

function createBaseWorkstationConfig_EphemeralDirectory(): WorkstationConfig_EphemeralDirectory {
  return { gcePd: undefined, mountPath: "" };
}

export const WorkstationConfig_EphemeralDirectory: MessageFns<WorkstationConfig_EphemeralDirectory> = {
  encode(message: WorkstationConfig_EphemeralDirectory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcePd !== undefined) {
      WorkstationConfig_EphemeralDirectory_GcePersistentDisk.encode(message.gcePd, writer.uint32(26).fork()).join();
    }
    if (message.mountPath !== "") {
      writer.uint32(10).string(message.mountPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationConfig_EphemeralDirectory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_EphemeralDirectory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gcePd = WorkstationConfig_EphemeralDirectory_GcePersistentDisk.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mountPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_EphemeralDirectory {
    return {
      gcePd: isSet(object.gcePd)
        ? WorkstationConfig_EphemeralDirectory_GcePersistentDisk.fromJSON(object.gcePd)
        : undefined,
      mountPath: isSet(object.mountPath) ? globalThis.String(object.mountPath) : "",
    };
  },

  toJSON(message: WorkstationConfig_EphemeralDirectory): unknown {
    const obj: any = {};
    if (message.gcePd !== undefined) {
      obj.gcePd = WorkstationConfig_EphemeralDirectory_GcePersistentDisk.toJSON(message.gcePd);
    }
    if (message.mountPath !== "") {
      obj.mountPath = message.mountPath;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationConfig_EphemeralDirectory>): WorkstationConfig_EphemeralDirectory {
    return WorkstationConfig_EphemeralDirectory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationConfig_EphemeralDirectory>): WorkstationConfig_EphemeralDirectory {
    const message = createBaseWorkstationConfig_EphemeralDirectory();
    message.gcePd = (object.gcePd !== undefined && object.gcePd !== null)
      ? WorkstationConfig_EphemeralDirectory_GcePersistentDisk.fromPartial(object.gcePd)
      : undefined;
    message.mountPath = object.mountPath ?? "";
    return message;
  },
};

function createBaseWorkstationConfig_EphemeralDirectory_GcePersistentDisk(): WorkstationConfig_EphemeralDirectory_GcePersistentDisk {
  return { diskType: "", sourceSnapshot: "", sourceImage: "", readOnly: false };
}

export const WorkstationConfig_EphemeralDirectory_GcePersistentDisk: MessageFns<
  WorkstationConfig_EphemeralDirectory_GcePersistentDisk
> = {
  encode(
    message: WorkstationConfig_EphemeralDirectory_GcePersistentDisk,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.diskType !== "") {
      writer.uint32(10).string(message.diskType);
    }
    if (message.sourceSnapshot !== "") {
      writer.uint32(18).string(message.sourceSnapshot);
    }
    if (message.sourceImage !== "") {
      writer.uint32(26).string(message.sourceImage);
    }
    if (message.readOnly !== false) {
      writer.uint32(32).bool(message.readOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationConfig_EphemeralDirectory_GcePersistentDisk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_EphemeralDirectory_GcePersistentDisk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.diskType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceSnapshot = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceImage = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.readOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_EphemeralDirectory_GcePersistentDisk {
    return {
      diskType: isSet(object.diskType) ? globalThis.String(object.diskType) : "",
      sourceSnapshot: isSet(object.sourceSnapshot) ? globalThis.String(object.sourceSnapshot) : "",
      sourceImage: isSet(object.sourceImage) ? globalThis.String(object.sourceImage) : "",
      readOnly: isSet(object.readOnly) ? globalThis.Boolean(object.readOnly) : false,
    };
  },

  toJSON(message: WorkstationConfig_EphemeralDirectory_GcePersistentDisk): unknown {
    const obj: any = {};
    if (message.diskType !== "") {
      obj.diskType = message.diskType;
    }
    if (message.sourceSnapshot !== "") {
      obj.sourceSnapshot = message.sourceSnapshot;
    }
    if (message.sourceImage !== "") {
      obj.sourceImage = message.sourceImage;
    }
    if (message.readOnly !== false) {
      obj.readOnly = message.readOnly;
    }
    return obj;
  },

  create(
    base?: DeepPartial<WorkstationConfig_EphemeralDirectory_GcePersistentDisk>,
  ): WorkstationConfig_EphemeralDirectory_GcePersistentDisk {
    return WorkstationConfig_EphemeralDirectory_GcePersistentDisk.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WorkstationConfig_EphemeralDirectory_GcePersistentDisk>,
  ): WorkstationConfig_EphemeralDirectory_GcePersistentDisk {
    const message = createBaseWorkstationConfig_EphemeralDirectory_GcePersistentDisk();
    message.diskType = object.diskType ?? "";
    message.sourceSnapshot = object.sourceSnapshot ?? "";
    message.sourceImage = object.sourceImage ?? "";
    message.readOnly = object.readOnly ?? false;
    return message;
  },
};

function createBaseWorkstationConfig_Container(): WorkstationConfig_Container {
  return { image: "", command: [], args: [], env: {}, workingDir: "", runAsUser: 0 };
}

export const WorkstationConfig_Container: MessageFns<WorkstationConfig_Container> = {
  encode(message: WorkstationConfig_Container, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== "") {
      writer.uint32(10).string(message.image);
    }
    for (const v of message.command) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.args) {
      writer.uint32(26).string(v!);
    }
    Object.entries(message.env).forEach(([key, value]) => {
      WorkstationConfig_Container_EnvEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.workingDir !== "") {
      writer.uint32(42).string(message.workingDir);
    }
    if (message.runAsUser !== 0) {
      writer.uint32(48).int32(message.runAsUser);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationConfig_Container {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_Container();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.image = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.command.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.args.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = WorkstationConfig_Container_EnvEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.env[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.workingDir = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.runAsUser = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_Container {
    return {
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      command: globalThis.Array.isArray(object?.command) ? object.command.map((e: any) => globalThis.String(e)) : [],
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      env: isObject(object.env)
        ? Object.entries(object.env).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      workingDir: isSet(object.workingDir) ? globalThis.String(object.workingDir) : "",
      runAsUser: isSet(object.runAsUser) ? globalThis.Number(object.runAsUser) : 0,
    };
  },

  toJSON(message: WorkstationConfig_Container): unknown {
    const obj: any = {};
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.command?.length) {
      obj.command = message.command;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.env) {
      const entries = Object.entries(message.env);
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    if (message.workingDir !== "") {
      obj.workingDir = message.workingDir;
    }
    if (message.runAsUser !== 0) {
      obj.runAsUser = Math.round(message.runAsUser);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationConfig_Container>): WorkstationConfig_Container {
    return WorkstationConfig_Container.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationConfig_Container>): WorkstationConfig_Container {
    const message = createBaseWorkstationConfig_Container();
    message.image = object.image ?? "";
    message.command = object.command?.map((e) => e) || [];
    message.args = object.args?.map((e) => e) || [];
    message.env = Object.entries(object.env ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.workingDir = object.workingDir ?? "";
    message.runAsUser = object.runAsUser ?? 0;
    return message;
  },
};

function createBaseWorkstationConfig_Container_EnvEntry(): WorkstationConfig_Container_EnvEntry {
  return { key: "", value: "" };
}

export const WorkstationConfig_Container_EnvEntry: MessageFns<WorkstationConfig_Container_EnvEntry> = {
  encode(message: WorkstationConfig_Container_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationConfig_Container_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_Container_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_Container_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WorkstationConfig_Container_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationConfig_Container_EnvEntry>): WorkstationConfig_Container_EnvEntry {
    return WorkstationConfig_Container_EnvEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationConfig_Container_EnvEntry>): WorkstationConfig_Container_EnvEntry {
    const message = createBaseWorkstationConfig_Container_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWorkstationConfig_CustomerEncryptionKey(): WorkstationConfig_CustomerEncryptionKey {
  return { kmsKey: "", kmsKeyServiceAccount: "" };
}

export const WorkstationConfig_CustomerEncryptionKey: MessageFns<WorkstationConfig_CustomerEncryptionKey> = {
  encode(message: WorkstationConfig_CustomerEncryptionKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kmsKey !== "") {
      writer.uint32(10).string(message.kmsKey);
    }
    if (message.kmsKeyServiceAccount !== "") {
      writer.uint32(18).string(message.kmsKeyServiceAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationConfig_CustomerEncryptionKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_CustomerEncryptionKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kmsKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.kmsKeyServiceAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_CustomerEncryptionKey {
    return {
      kmsKey: isSet(object.kmsKey) ? globalThis.String(object.kmsKey) : "",
      kmsKeyServiceAccount: isSet(object.kmsKeyServiceAccount) ? globalThis.String(object.kmsKeyServiceAccount) : "",
    };
  },

  toJSON(message: WorkstationConfig_CustomerEncryptionKey): unknown {
    const obj: any = {};
    if (message.kmsKey !== "") {
      obj.kmsKey = message.kmsKey;
    }
    if (message.kmsKeyServiceAccount !== "") {
      obj.kmsKeyServiceAccount = message.kmsKeyServiceAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationConfig_CustomerEncryptionKey>): WorkstationConfig_CustomerEncryptionKey {
    return WorkstationConfig_CustomerEncryptionKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationConfig_CustomerEncryptionKey>): WorkstationConfig_CustomerEncryptionKey {
    const message = createBaseWorkstationConfig_CustomerEncryptionKey();
    message.kmsKey = object.kmsKey ?? "";
    message.kmsKeyServiceAccount = object.kmsKeyServiceAccount ?? "";
    return message;
  },
};

function createBaseWorkstationConfig_ReadinessCheck(): WorkstationConfig_ReadinessCheck {
  return { path: "", port: 0 };
}

export const WorkstationConfig_ReadinessCheck: MessageFns<WorkstationConfig_ReadinessCheck> = {
  encode(message: WorkstationConfig_ReadinessCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationConfig_ReadinessCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_ReadinessCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_ReadinessCheck {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
    };
  },

  toJSON(message: WorkstationConfig_ReadinessCheck): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationConfig_ReadinessCheck>): WorkstationConfig_ReadinessCheck {
    return WorkstationConfig_ReadinessCheck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationConfig_ReadinessCheck>): WorkstationConfig_ReadinessCheck {
    const message = createBaseWorkstationConfig_ReadinessCheck();
    message.path = object.path ?? "";
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseWorkstationConfig_AnnotationsEntry(): WorkstationConfig_AnnotationsEntry {
  return { key: "", value: "" };
}

export const WorkstationConfig_AnnotationsEntry: MessageFns<WorkstationConfig_AnnotationsEntry> = {
  encode(message: WorkstationConfig_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationConfig_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WorkstationConfig_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationConfig_AnnotationsEntry>): WorkstationConfig_AnnotationsEntry {
    return WorkstationConfig_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationConfig_AnnotationsEntry>): WorkstationConfig_AnnotationsEntry {
    const message = createBaseWorkstationConfig_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWorkstationConfig_LabelsEntry(): WorkstationConfig_LabelsEntry {
  return { key: "", value: "" };
}

export const WorkstationConfig_LabelsEntry: MessageFns<WorkstationConfig_LabelsEntry> = {
  encode(message: WorkstationConfig_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkstationConfig_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstationConfig_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkstationConfig_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WorkstationConfig_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkstationConfig_LabelsEntry>): WorkstationConfig_LabelsEntry {
    return WorkstationConfig_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkstationConfig_LabelsEntry>): WorkstationConfig_LabelsEntry {
    const message = createBaseWorkstationConfig_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWorkstation(): Workstation {
  return {
    name: "",
    displayName: "",
    uid: "",
    reconciling: false,
    annotations: {},
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    startTime: undefined,
    deleteTime: undefined,
    etag: "",
    state: 0,
    host: "",
    env: {},
  };
}

export const Workstation: MessageFns<Workstation> = {
  encode(message: Workstation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.uid !== "") {
      writer.uint32(26).string(message.uid);
    }
    if (message.reconciling !== false) {
      writer.uint32(32).bool(message.reconciling);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      Workstation_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      Workstation_LabelsEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(114).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(66).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(74).string(message.etag);
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    if (message.host !== "") {
      writer.uint32(90).string(message.host);
    }
    Object.entries(message.env).forEach(([key, value]) => {
      Workstation_EnvEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workstation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.reconciling = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Workstation_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.annotations[entry5.key] = entry5.value;
          }
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          const entry13 = Workstation_LabelsEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.labels[entry13.key] = entry13.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.host = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = Workstation_EnvEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.env[entry12.key] = entry12.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workstation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      reconciling: isSet(object.reconciling) ? globalThis.Boolean(object.reconciling) : false,
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      state: isSet(object.state) ? workstation_StateFromJSON(object.state) : 0,
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      env: isObject(object.env)
        ? Object.entries(object.env).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Workstation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.reconciling !== false) {
      obj.reconciling = message.reconciling;
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.state !== 0) {
      obj.state = workstation_StateToJSON(message.state);
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.env) {
      const entries = Object.entries(message.env);
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Workstation>): Workstation {
    return Workstation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Workstation>): Workstation {
    const message = createBaseWorkstation();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.uid = object.uid ?? "";
    message.reconciling = object.reconciling ?? false;
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.etag = object.etag ?? "";
    message.state = object.state ?? 0;
    message.host = object.host ?? "";
    message.env = Object.entries(object.env ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseWorkstation_AnnotationsEntry(): Workstation_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Workstation_AnnotationsEntry: MessageFns<Workstation_AnnotationsEntry> = {
  encode(message: Workstation_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workstation_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstation_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workstation_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Workstation_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Workstation_AnnotationsEntry>): Workstation_AnnotationsEntry {
    return Workstation_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Workstation_AnnotationsEntry>): Workstation_AnnotationsEntry {
    const message = createBaseWorkstation_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWorkstation_LabelsEntry(): Workstation_LabelsEntry {
  return { key: "", value: "" };
}

export const Workstation_LabelsEntry: MessageFns<Workstation_LabelsEntry> = {
  encode(message: Workstation_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workstation_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstation_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workstation_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Workstation_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Workstation_LabelsEntry>): Workstation_LabelsEntry {
    return Workstation_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Workstation_LabelsEntry>): Workstation_LabelsEntry {
    const message = createBaseWorkstation_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWorkstation_EnvEntry(): Workstation_EnvEntry {
  return { key: "", value: "" };
}

export const Workstation_EnvEntry: MessageFns<Workstation_EnvEntry> = {
  encode(message: Workstation_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workstation_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkstation_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workstation_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Workstation_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Workstation_EnvEntry>): Workstation_EnvEntry {
    return Workstation_EnvEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Workstation_EnvEntry>): Workstation_EnvEntry {
    const message = createBaseWorkstation_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetWorkstationClusterRequest(): GetWorkstationClusterRequest {
  return { name: "" };
}

export const GetWorkstationClusterRequest: MessageFns<GetWorkstationClusterRequest> = {
  encode(message: GetWorkstationClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkstationClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkstationClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkstationClusterRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetWorkstationClusterRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkstationClusterRequest>): GetWorkstationClusterRequest {
    return GetWorkstationClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkstationClusterRequest>): GetWorkstationClusterRequest {
    const message = createBaseGetWorkstationClusterRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListWorkstationClustersRequest(): ListWorkstationClustersRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListWorkstationClustersRequest: MessageFns<ListWorkstationClustersRequest> = {
  encode(message: ListWorkstationClustersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkstationClustersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkstationClustersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkstationClustersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListWorkstationClustersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkstationClustersRequest>): ListWorkstationClustersRequest {
    return ListWorkstationClustersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkstationClustersRequest>): ListWorkstationClustersRequest {
    const message = createBaseListWorkstationClustersRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListWorkstationClustersResponse(): ListWorkstationClustersResponse {
  return { workstationClusters: [], nextPageToken: "", unreachable: [] };
}

export const ListWorkstationClustersResponse: MessageFns<ListWorkstationClustersResponse> = {
  encode(message: ListWorkstationClustersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workstationClusters) {
      WorkstationCluster.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkstationClustersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkstationClustersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workstationClusters.push(WorkstationCluster.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkstationClustersResponse {
    return {
      workstationClusters: globalThis.Array.isArray(object?.workstationClusters)
        ? object.workstationClusters.map((e: any) => WorkstationCluster.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListWorkstationClustersResponse): unknown {
    const obj: any = {};
    if (message.workstationClusters?.length) {
      obj.workstationClusters = message.workstationClusters.map((e) => WorkstationCluster.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkstationClustersResponse>): ListWorkstationClustersResponse {
    return ListWorkstationClustersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkstationClustersResponse>): ListWorkstationClustersResponse {
    const message = createBaseListWorkstationClustersResponse();
    message.workstationClusters = object.workstationClusters?.map((e) => WorkstationCluster.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateWorkstationClusterRequest(): CreateWorkstationClusterRequest {
  return { parent: "", workstationClusterId: "", workstationCluster: undefined, validateOnly: false };
}

export const CreateWorkstationClusterRequest: MessageFns<CreateWorkstationClusterRequest> = {
  encode(message: CreateWorkstationClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.workstationClusterId !== "") {
      writer.uint32(18).string(message.workstationClusterId);
    }
    if (message.workstationCluster !== undefined) {
      WorkstationCluster.encode(message.workstationCluster, writer.uint32(26).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateWorkstationClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWorkstationClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workstationClusterId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.workstationCluster = WorkstationCluster.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWorkstationClusterRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      workstationClusterId: isSet(object.workstationClusterId) ? globalThis.String(object.workstationClusterId) : "",
      workstationCluster: isSet(object.workstationCluster)
        ? WorkstationCluster.fromJSON(object.workstationCluster)
        : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateWorkstationClusterRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.workstationClusterId !== "") {
      obj.workstationClusterId = message.workstationClusterId;
    }
    if (message.workstationCluster !== undefined) {
      obj.workstationCluster = WorkstationCluster.toJSON(message.workstationCluster);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWorkstationClusterRequest>): CreateWorkstationClusterRequest {
    return CreateWorkstationClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWorkstationClusterRequest>): CreateWorkstationClusterRequest {
    const message = createBaseCreateWorkstationClusterRequest();
    message.parent = object.parent ?? "";
    message.workstationClusterId = object.workstationClusterId ?? "";
    message.workstationCluster = (object.workstationCluster !== undefined && object.workstationCluster !== null)
      ? WorkstationCluster.fromPartial(object.workstationCluster)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateWorkstationClusterRequest(): UpdateWorkstationClusterRequest {
  return { workstationCluster: undefined, updateMask: undefined, validateOnly: false, allowMissing: false };
}

export const UpdateWorkstationClusterRequest: MessageFns<UpdateWorkstationClusterRequest> = {
  encode(message: UpdateWorkstationClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workstationCluster !== undefined) {
      WorkstationCluster.encode(message.workstationCluster, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateWorkstationClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWorkstationClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workstationCluster = WorkstationCluster.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWorkstationClusterRequest {
    return {
      workstationCluster: isSet(object.workstationCluster)
        ? WorkstationCluster.fromJSON(object.workstationCluster)
        : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: UpdateWorkstationClusterRequest): unknown {
    const obj: any = {};
    if (message.workstationCluster !== undefined) {
      obj.workstationCluster = WorkstationCluster.toJSON(message.workstationCluster);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateWorkstationClusterRequest>): UpdateWorkstationClusterRequest {
    return UpdateWorkstationClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateWorkstationClusterRequest>): UpdateWorkstationClusterRequest {
    const message = createBaseUpdateWorkstationClusterRequest();
    message.workstationCluster = (object.workstationCluster !== undefined && object.workstationCluster !== null)
      ? WorkstationCluster.fromPartial(object.workstationCluster)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.validateOnly = object.validateOnly ?? false;
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseDeleteWorkstationClusterRequest(): DeleteWorkstationClusterRequest {
  return { name: "", validateOnly: false, etag: "", force: false };
}

export const DeleteWorkstationClusterRequest: MessageFns<DeleteWorkstationClusterRequest> = {
  encode(message: DeleteWorkstationClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.validateOnly !== false) {
      writer.uint32(16).bool(message.validateOnly);
    }
    if (message.etag !== "") {
      writer.uint32(26).string(message.etag);
    }
    if (message.force !== false) {
      writer.uint32(32).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteWorkstationClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWorkstationClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWorkstationClusterRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteWorkstationClusterRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteWorkstationClusterRequest>): DeleteWorkstationClusterRequest {
    return DeleteWorkstationClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWorkstationClusterRequest>): DeleteWorkstationClusterRequest {
    const message = createBaseDeleteWorkstationClusterRequest();
    message.name = object.name ?? "";
    message.validateOnly = object.validateOnly ?? false;
    message.etag = object.etag ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseGetWorkstationConfigRequest(): GetWorkstationConfigRequest {
  return { name: "" };
}

export const GetWorkstationConfigRequest: MessageFns<GetWorkstationConfigRequest> = {
  encode(message: GetWorkstationConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkstationConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkstationConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkstationConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetWorkstationConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkstationConfigRequest>): GetWorkstationConfigRequest {
    return GetWorkstationConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkstationConfigRequest>): GetWorkstationConfigRequest {
    const message = createBaseGetWorkstationConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListWorkstationConfigsRequest(): ListWorkstationConfigsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListWorkstationConfigsRequest: MessageFns<ListWorkstationConfigsRequest> = {
  encode(message: ListWorkstationConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkstationConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkstationConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkstationConfigsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListWorkstationConfigsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkstationConfigsRequest>): ListWorkstationConfigsRequest {
    return ListWorkstationConfigsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkstationConfigsRequest>): ListWorkstationConfigsRequest {
    const message = createBaseListWorkstationConfigsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListWorkstationConfigsResponse(): ListWorkstationConfigsResponse {
  return { workstationConfigs: [], nextPageToken: "", unreachable: [] };
}

export const ListWorkstationConfigsResponse: MessageFns<ListWorkstationConfigsResponse> = {
  encode(message: ListWorkstationConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workstationConfigs) {
      WorkstationConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkstationConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkstationConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workstationConfigs.push(WorkstationConfig.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkstationConfigsResponse {
    return {
      workstationConfigs: globalThis.Array.isArray(object?.workstationConfigs)
        ? object.workstationConfigs.map((e: any) => WorkstationConfig.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListWorkstationConfigsResponse): unknown {
    const obj: any = {};
    if (message.workstationConfigs?.length) {
      obj.workstationConfigs = message.workstationConfigs.map((e) => WorkstationConfig.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkstationConfigsResponse>): ListWorkstationConfigsResponse {
    return ListWorkstationConfigsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkstationConfigsResponse>): ListWorkstationConfigsResponse {
    const message = createBaseListWorkstationConfigsResponse();
    message.workstationConfigs = object.workstationConfigs?.map((e) => WorkstationConfig.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseListUsableWorkstationConfigsRequest(): ListUsableWorkstationConfigsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListUsableWorkstationConfigsRequest: MessageFns<ListUsableWorkstationConfigsRequest> = {
  encode(message: ListUsableWorkstationConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsableWorkstationConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsableWorkstationConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsableWorkstationConfigsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListUsableWorkstationConfigsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUsableWorkstationConfigsRequest>): ListUsableWorkstationConfigsRequest {
    return ListUsableWorkstationConfigsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUsableWorkstationConfigsRequest>): ListUsableWorkstationConfigsRequest {
    const message = createBaseListUsableWorkstationConfigsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListUsableWorkstationConfigsResponse(): ListUsableWorkstationConfigsResponse {
  return { workstationConfigs: [], nextPageToken: "", unreachable: [] };
}

export const ListUsableWorkstationConfigsResponse: MessageFns<ListUsableWorkstationConfigsResponse> = {
  encode(message: ListUsableWorkstationConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workstationConfigs) {
      WorkstationConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsableWorkstationConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsableWorkstationConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workstationConfigs.push(WorkstationConfig.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsableWorkstationConfigsResponse {
    return {
      workstationConfigs: globalThis.Array.isArray(object?.workstationConfigs)
        ? object.workstationConfigs.map((e: any) => WorkstationConfig.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListUsableWorkstationConfigsResponse): unknown {
    const obj: any = {};
    if (message.workstationConfigs?.length) {
      obj.workstationConfigs = message.workstationConfigs.map((e) => WorkstationConfig.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUsableWorkstationConfigsResponse>): ListUsableWorkstationConfigsResponse {
    return ListUsableWorkstationConfigsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUsableWorkstationConfigsResponse>): ListUsableWorkstationConfigsResponse {
    const message = createBaseListUsableWorkstationConfigsResponse();
    message.workstationConfigs = object.workstationConfigs?.map((e) => WorkstationConfig.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateWorkstationConfigRequest(): CreateWorkstationConfigRequest {
  return { parent: "", workstationConfigId: "", workstationConfig: undefined, validateOnly: false };
}

export const CreateWorkstationConfigRequest: MessageFns<CreateWorkstationConfigRequest> = {
  encode(message: CreateWorkstationConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.workstationConfigId !== "") {
      writer.uint32(18).string(message.workstationConfigId);
    }
    if (message.workstationConfig !== undefined) {
      WorkstationConfig.encode(message.workstationConfig, writer.uint32(26).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateWorkstationConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWorkstationConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workstationConfigId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.workstationConfig = WorkstationConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWorkstationConfigRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      workstationConfigId: isSet(object.workstationConfigId) ? globalThis.String(object.workstationConfigId) : "",
      workstationConfig: isSet(object.workstationConfig)
        ? WorkstationConfig.fromJSON(object.workstationConfig)
        : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateWorkstationConfigRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.workstationConfigId !== "") {
      obj.workstationConfigId = message.workstationConfigId;
    }
    if (message.workstationConfig !== undefined) {
      obj.workstationConfig = WorkstationConfig.toJSON(message.workstationConfig);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWorkstationConfigRequest>): CreateWorkstationConfigRequest {
    return CreateWorkstationConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWorkstationConfigRequest>): CreateWorkstationConfigRequest {
    const message = createBaseCreateWorkstationConfigRequest();
    message.parent = object.parent ?? "";
    message.workstationConfigId = object.workstationConfigId ?? "";
    message.workstationConfig = (object.workstationConfig !== undefined && object.workstationConfig !== null)
      ? WorkstationConfig.fromPartial(object.workstationConfig)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateWorkstationConfigRequest(): UpdateWorkstationConfigRequest {
  return { workstationConfig: undefined, updateMask: undefined, validateOnly: false, allowMissing: false };
}

export const UpdateWorkstationConfigRequest: MessageFns<UpdateWorkstationConfigRequest> = {
  encode(message: UpdateWorkstationConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workstationConfig !== undefined) {
      WorkstationConfig.encode(message.workstationConfig, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateWorkstationConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWorkstationConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workstationConfig = WorkstationConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWorkstationConfigRequest {
    return {
      workstationConfig: isSet(object.workstationConfig)
        ? WorkstationConfig.fromJSON(object.workstationConfig)
        : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: UpdateWorkstationConfigRequest): unknown {
    const obj: any = {};
    if (message.workstationConfig !== undefined) {
      obj.workstationConfig = WorkstationConfig.toJSON(message.workstationConfig);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateWorkstationConfigRequest>): UpdateWorkstationConfigRequest {
    return UpdateWorkstationConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateWorkstationConfigRequest>): UpdateWorkstationConfigRequest {
    const message = createBaseUpdateWorkstationConfigRequest();
    message.workstationConfig = (object.workstationConfig !== undefined && object.workstationConfig !== null)
      ? WorkstationConfig.fromPartial(object.workstationConfig)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.validateOnly = object.validateOnly ?? false;
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseDeleteWorkstationConfigRequest(): DeleteWorkstationConfigRequest {
  return { name: "", validateOnly: false, etag: "", force: false };
}

export const DeleteWorkstationConfigRequest: MessageFns<DeleteWorkstationConfigRequest> = {
  encode(message: DeleteWorkstationConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.validateOnly !== false) {
      writer.uint32(16).bool(message.validateOnly);
    }
    if (message.etag !== "") {
      writer.uint32(26).string(message.etag);
    }
    if (message.force !== false) {
      writer.uint32(32).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteWorkstationConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWorkstationConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWorkstationConfigRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteWorkstationConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteWorkstationConfigRequest>): DeleteWorkstationConfigRequest {
    return DeleteWorkstationConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWorkstationConfigRequest>): DeleteWorkstationConfigRequest {
    const message = createBaseDeleteWorkstationConfigRequest();
    message.name = object.name ?? "";
    message.validateOnly = object.validateOnly ?? false;
    message.etag = object.etag ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseGetWorkstationRequest(): GetWorkstationRequest {
  return { name: "" };
}

export const GetWorkstationRequest: MessageFns<GetWorkstationRequest> = {
  encode(message: GetWorkstationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkstationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkstationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkstationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetWorkstationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkstationRequest>): GetWorkstationRequest {
    return GetWorkstationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkstationRequest>): GetWorkstationRequest {
    const message = createBaseGetWorkstationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListWorkstationsRequest(): ListWorkstationsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListWorkstationsRequest: MessageFns<ListWorkstationsRequest> = {
  encode(message: ListWorkstationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkstationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkstationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkstationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListWorkstationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkstationsRequest>): ListWorkstationsRequest {
    return ListWorkstationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkstationsRequest>): ListWorkstationsRequest {
    const message = createBaseListWorkstationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListWorkstationsResponse(): ListWorkstationsResponse {
  return { workstations: [], nextPageToken: "", unreachable: [] };
}

export const ListWorkstationsResponse: MessageFns<ListWorkstationsResponse> = {
  encode(message: ListWorkstationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workstations) {
      Workstation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkstationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkstationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workstations.push(Workstation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkstationsResponse {
    return {
      workstations: globalThis.Array.isArray(object?.workstations)
        ? object.workstations.map((e: any) => Workstation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListWorkstationsResponse): unknown {
    const obj: any = {};
    if (message.workstations?.length) {
      obj.workstations = message.workstations.map((e) => Workstation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkstationsResponse>): ListWorkstationsResponse {
    return ListWorkstationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkstationsResponse>): ListWorkstationsResponse {
    const message = createBaseListWorkstationsResponse();
    message.workstations = object.workstations?.map((e) => Workstation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseListUsableWorkstationsRequest(): ListUsableWorkstationsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListUsableWorkstationsRequest: MessageFns<ListUsableWorkstationsRequest> = {
  encode(message: ListUsableWorkstationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsableWorkstationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsableWorkstationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsableWorkstationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListUsableWorkstationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUsableWorkstationsRequest>): ListUsableWorkstationsRequest {
    return ListUsableWorkstationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUsableWorkstationsRequest>): ListUsableWorkstationsRequest {
    const message = createBaseListUsableWorkstationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListUsableWorkstationsResponse(): ListUsableWorkstationsResponse {
  return { workstations: [], nextPageToken: "", unreachable: [] };
}

export const ListUsableWorkstationsResponse: MessageFns<ListUsableWorkstationsResponse> = {
  encode(message: ListUsableWorkstationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workstations) {
      Workstation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsableWorkstationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsableWorkstationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workstations.push(Workstation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsableWorkstationsResponse {
    return {
      workstations: globalThis.Array.isArray(object?.workstations)
        ? object.workstations.map((e: any) => Workstation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListUsableWorkstationsResponse): unknown {
    const obj: any = {};
    if (message.workstations?.length) {
      obj.workstations = message.workstations.map((e) => Workstation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUsableWorkstationsResponse>): ListUsableWorkstationsResponse {
    return ListUsableWorkstationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUsableWorkstationsResponse>): ListUsableWorkstationsResponse {
    const message = createBaseListUsableWorkstationsResponse();
    message.workstations = object.workstations?.map((e) => Workstation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateWorkstationRequest(): CreateWorkstationRequest {
  return { parent: "", workstationId: "", workstation: undefined, validateOnly: false };
}

export const CreateWorkstationRequest: MessageFns<CreateWorkstationRequest> = {
  encode(message: CreateWorkstationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.workstationId !== "") {
      writer.uint32(18).string(message.workstationId);
    }
    if (message.workstation !== undefined) {
      Workstation.encode(message.workstation, writer.uint32(26).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateWorkstationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWorkstationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workstationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.workstation = Workstation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWorkstationRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      workstationId: isSet(object.workstationId) ? globalThis.String(object.workstationId) : "",
      workstation: isSet(object.workstation) ? Workstation.fromJSON(object.workstation) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateWorkstationRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.workstationId !== "") {
      obj.workstationId = message.workstationId;
    }
    if (message.workstation !== undefined) {
      obj.workstation = Workstation.toJSON(message.workstation);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWorkstationRequest>): CreateWorkstationRequest {
    return CreateWorkstationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWorkstationRequest>): CreateWorkstationRequest {
    const message = createBaseCreateWorkstationRequest();
    message.parent = object.parent ?? "";
    message.workstationId = object.workstationId ?? "";
    message.workstation = (object.workstation !== undefined && object.workstation !== null)
      ? Workstation.fromPartial(object.workstation)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateWorkstationRequest(): UpdateWorkstationRequest {
  return { workstation: undefined, updateMask: undefined, validateOnly: false, allowMissing: false };
}

export const UpdateWorkstationRequest: MessageFns<UpdateWorkstationRequest> = {
  encode(message: UpdateWorkstationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workstation !== undefined) {
      Workstation.encode(message.workstation, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateWorkstationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWorkstationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workstation = Workstation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWorkstationRequest {
    return {
      workstation: isSet(object.workstation) ? Workstation.fromJSON(object.workstation) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: UpdateWorkstationRequest): unknown {
    const obj: any = {};
    if (message.workstation !== undefined) {
      obj.workstation = Workstation.toJSON(message.workstation);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateWorkstationRequest>): UpdateWorkstationRequest {
    return UpdateWorkstationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateWorkstationRequest>): UpdateWorkstationRequest {
    const message = createBaseUpdateWorkstationRequest();
    message.workstation = (object.workstation !== undefined && object.workstation !== null)
      ? Workstation.fromPartial(object.workstation)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.validateOnly = object.validateOnly ?? false;
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseDeleteWorkstationRequest(): DeleteWorkstationRequest {
  return { name: "", validateOnly: false, etag: "" };
}

export const DeleteWorkstationRequest: MessageFns<DeleteWorkstationRequest> = {
  encode(message: DeleteWorkstationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.validateOnly !== false) {
      writer.uint32(16).bool(message.validateOnly);
    }
    if (message.etag !== "") {
      writer.uint32(26).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteWorkstationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWorkstationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWorkstationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteWorkstationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteWorkstationRequest>): DeleteWorkstationRequest {
    return DeleteWorkstationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWorkstationRequest>): DeleteWorkstationRequest {
    const message = createBaseDeleteWorkstationRequest();
    message.name = object.name ?? "";
    message.validateOnly = object.validateOnly ?? false;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseStartWorkstationRequest(): StartWorkstationRequest {
  return { name: "", validateOnly: false, etag: "" };
}

export const StartWorkstationRequest: MessageFns<StartWorkstationRequest> = {
  encode(message: StartWorkstationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.validateOnly !== false) {
      writer.uint32(16).bool(message.validateOnly);
    }
    if (message.etag !== "") {
      writer.uint32(26).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartWorkstationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartWorkstationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartWorkstationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: StartWorkstationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<StartWorkstationRequest>): StartWorkstationRequest {
    return StartWorkstationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartWorkstationRequest>): StartWorkstationRequest {
    const message = createBaseStartWorkstationRequest();
    message.name = object.name ?? "";
    message.validateOnly = object.validateOnly ?? false;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseStopWorkstationRequest(): StopWorkstationRequest {
  return { name: "", validateOnly: false, etag: "" };
}

export const StopWorkstationRequest: MessageFns<StopWorkstationRequest> = {
  encode(message: StopWorkstationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.validateOnly !== false) {
      writer.uint32(16).bool(message.validateOnly);
    }
    if (message.etag !== "") {
      writer.uint32(26).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopWorkstationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopWorkstationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopWorkstationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: StopWorkstationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<StopWorkstationRequest>): StopWorkstationRequest {
    return StopWorkstationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopWorkstationRequest>): StopWorkstationRequest {
    const message = createBaseStopWorkstationRequest();
    message.name = object.name ?? "";
    message.validateOnly = object.validateOnly ?? false;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseGenerateAccessTokenRequest(): GenerateAccessTokenRequest {
  return { expireTime: undefined, ttl: undefined, workstation: "" };
}

export const GenerateAccessTokenRequest: MessageFns<GenerateAccessTokenRequest> = {
  encode(message: GenerateAccessTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(18).fork()).join();
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(26).fork()).join();
    }
    if (message.workstation !== "") {
      writer.uint32(10).string(message.workstation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateAccessTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateAccessTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workstation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateAccessTokenRequest {
    return {
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
      workstation: isSet(object.workstation) ? globalThis.String(object.workstation) : "",
    };
  },

  toJSON(message: GenerateAccessTokenRequest): unknown {
    const obj: any = {};
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    if (message.workstation !== "") {
      obj.workstation = message.workstation;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateAccessTokenRequest>): GenerateAccessTokenRequest {
    return GenerateAccessTokenRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateAccessTokenRequest>): GenerateAccessTokenRequest {
    const message = createBaseGenerateAccessTokenRequest();
    message.expireTime = object.expireTime ?? undefined;
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    message.workstation = object.workstation ?? "";
    return message;
  },
};

function createBaseGenerateAccessTokenResponse(): GenerateAccessTokenResponse {
  return { accessToken: "", expireTime: undefined };
}

export const GenerateAccessTokenResponse: MessageFns<GenerateAccessTokenResponse> = {
  encode(message: GenerateAccessTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateAccessTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateAccessTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateAccessTokenResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
    };
  },

  toJSON(message: GenerateAccessTokenResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateAccessTokenResponse>): GenerateAccessTokenResponse {
    return GenerateAccessTokenResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateAccessTokenResponse>): GenerateAccessTokenResponse {
    const message = createBaseGenerateAccessTokenResponse();
    message.accessToken = object.accessToken ?? "";
    message.expireTime = object.expireTime ?? undefined;
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusMessage: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(48).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

/** Service for interacting with Cloud Workstations. */
export type WorkstationsDefinition = typeof WorkstationsDefinition;
export const WorkstationsDefinition = {
  name: "Workstations",
  fullName: "google.cloud.workstations.v1beta.Workstations",
  methods: {
    /** Returns the requested workstation cluster. */
    getWorkstationCluster: {
      name: "GetWorkstationCluster",
      requestType: GetWorkstationClusterRequest,
      requestStream: false,
      responseType: WorkstationCluster,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns all workstation clusters in the specified location. */
    listWorkstationClusters: {
      name: "ListWorkstationClusters",
      requestType: ListWorkstationClustersRequest,
      requestStream: false,
      responseType: ListWorkstationClustersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates a new workstation cluster. */
    createWorkstationCluster: {
      name: "CreateWorkstationCluster",
      requestType: CreateWorkstationClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              39,
              10,
              18,
              87,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              49,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              44,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              82,
              58,
              19,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              34,
              59,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates an existing workstation cluster. */
    updateWorkstationCluster: {
      name: "UpdateWorkstationCluster",
      requestType: UpdateWorkstationClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              39,
              10,
              18,
              87,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              31,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              102,
              58,
              19,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              50,
              79,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified workstation cluster. */
    deleteWorkstationCluster: {
      name: "DeleteWorkstationCluster",
      requestType: DeleteWorkstationClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              39,
              10,
              18,
              87,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              61,
              42,
              59,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns the requested workstation configuration. */
    getWorkstationConfig: {
      name: "GetWorkstationConfig",
      requestType: GetWorkstationConfigRequest,
      requestStream: false,
      responseType: WorkstationConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              82,
              18,
              80,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns all workstation configurations in the specified cluster. */
    listWorkstationConfigs: {
      name: "ListWorkstationConfigs",
      requestType: ListWorkstationConfigsRequest,
      requestStream: false,
      responseType: ListWorkstationConfigsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              82,
              18,
              80,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns all workstation configurations in the specified cluster on which
     * the caller has the "workstations.workstation.create" permission.
     */
    listUsableWorkstationConfigs: {
      name: "ListUsableWorkstationConfigs",
      requestType: ListUsableWorkstationConfigsRequest,
      requestStream: false,
      responseType: ListUsableWorkstationConfigsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              93,
              18,
              91,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              58,
              108,
              105,
              115,
              116,
              85,
              115,
              97,
              98,
              108,
              101,
            ]),
          ],
        },
      },
    },
    /** Creates a new workstation configuration. */
    createWorkstationConfig: {
      name: "CreateWorkstationConfig",
      requestType: CreateWorkstationConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              17,
              87,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              47,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              102,
              58,
              18,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              34,
              80,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates an existing workstation configuration. */
    updateWorkstationConfig: {
      name: "UpdateWorkstationConfig",
      requestType: UpdateWorkstationConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              17,
              87,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              30,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              121,
              58,
              18,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              50,
              99,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified workstation configuration. */
    deleteWorkstationConfig: {
      name: "DeleteWorkstationConfig",
      requestType: DeleteWorkstationConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              17,
              87,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              82,
              42,
              80,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns the requested workstation. */
    getWorkstation: {
      name: "GetWorkstation",
      requestType: GetWorkstationRequest,
      requestStream: false,
      responseType: Workstation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              97,
              18,
              95,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns all Workstations using the specified workstation configuration. */
    listWorkstations: {
      name: "ListWorkstations",
      requestType: ListWorkstationsRequest,
      requestStream: false,
      responseType: ListWorkstationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              97,
              18,
              95,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns all workstations using the specified workstation configuration
     * on which the caller has the "workstations.workstations.use" permission.
     */
    listUsableWorkstations: {
      name: "ListUsableWorkstations",
      requestType: ListUsableWorkstationsRequest,
      requestStream: false,
      responseType: ListUsableWorkstationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              108,
              18,
              106,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              58,
              108,
              105,
              115,
              116,
              85,
              115,
              97,
              98,
              108,
              101,
            ]),
          ],
        },
      },
    },
    /** Creates a new workstation. */
    createWorkstation: {
      name: "CreateWorkstation",
      requestType: CreateWorkstationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              87,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              33,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              44,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              110,
              58,
              11,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              34,
              95,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates an existing workstation. */
    updateWorkstation: {
      name: "UpdateWorkstation",
      requestType: UpdateWorkstationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              87,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              122,
              58,
              11,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              50,
              107,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified workstation. */
    deleteWorkstation: {
      name: "DeleteWorkstation",
      requestType: DeleteWorkstationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              87,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              97,
              42,
              95,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Starts running a workstation so that users can connect to it. */
    startWorkstation: {
      name: "StartWorkstation",
      requestType: StartWorkstationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              87,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              106,
              58,
              1,
              42,
              34,
              101,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              97,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /** Stops running a workstation, reducing costs. */
    stopWorkstation: {
      name: "StopWorkstation",
      requestType: StopWorkstationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              87,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              105,
              58,
              1,
              42,
              34,
              100,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              111,
              112,
            ]),
          ],
        },
      },
    },
    /**
     * Returns a short-lived credential that can be used to send authenticated and
     * authorized traffic to a workstation.
     */
    generateAccessToken: {
      name: "GenerateAccessToken",
      requestType: GenerateAccessTokenRequest,
      requestStream: false,
      responseType: GenerateAccessTokenResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([11, 119, 111, 114, 107, 115, 116, 97, 116, 105, 111, 110])],
          578365826: [
            Buffer.from([
              127,
              58,
              1,
              42,
              34,
              122,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              115,
              116,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              65,
              99,
              99,
              101,
              115,
              115,
              84,
              111,
              107,
              101,
              110,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface WorkstationsServiceImplementation<CallContextExt = {}> {
  /** Returns the requested workstation cluster. */
  getWorkstationCluster(
    request: GetWorkstationClusterRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<WorkstationCluster>>;
  /** Returns all workstation clusters in the specified location. */
  listWorkstationClusters(
    request: ListWorkstationClustersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListWorkstationClustersResponse>>;
  /** Creates a new workstation cluster. */
  createWorkstationCluster(
    request: CreateWorkstationClusterRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates an existing workstation cluster. */
  updateWorkstationCluster(
    request: UpdateWorkstationClusterRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes the specified workstation cluster. */
  deleteWorkstationCluster(
    request: DeleteWorkstationClusterRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Returns the requested workstation configuration. */
  getWorkstationConfig(
    request: GetWorkstationConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<WorkstationConfig>>;
  /** Returns all workstation configurations in the specified cluster. */
  listWorkstationConfigs(
    request: ListWorkstationConfigsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListWorkstationConfigsResponse>>;
  /**
   * Returns all workstation configurations in the specified cluster on which
   * the caller has the "workstations.workstation.create" permission.
   */
  listUsableWorkstationConfigs(
    request: ListUsableWorkstationConfigsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListUsableWorkstationConfigsResponse>>;
  /** Creates a new workstation configuration. */
  createWorkstationConfig(
    request: CreateWorkstationConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates an existing workstation configuration. */
  updateWorkstationConfig(
    request: UpdateWorkstationConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes the specified workstation configuration. */
  deleteWorkstationConfig(
    request: DeleteWorkstationConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Returns the requested workstation. */
  getWorkstation(
    request: GetWorkstationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Workstation>>;
  /** Returns all Workstations using the specified workstation configuration. */
  listWorkstations(
    request: ListWorkstationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListWorkstationsResponse>>;
  /**
   * Returns all workstations using the specified workstation configuration
   * on which the caller has the "workstations.workstations.use" permission.
   */
  listUsableWorkstations(
    request: ListUsableWorkstationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListUsableWorkstationsResponse>>;
  /** Creates a new workstation. */
  createWorkstation(
    request: CreateWorkstationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates an existing workstation. */
  updateWorkstation(
    request: UpdateWorkstationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes the specified workstation. */
  deleteWorkstation(
    request: DeleteWorkstationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Starts running a workstation so that users can connect to it. */
  startWorkstation(
    request: StartWorkstationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Stops running a workstation, reducing costs. */
  stopWorkstation(
    request: StopWorkstationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Returns a short-lived credential that can be used to send authenticated and
   * authorized traffic to a workstation.
   */
  generateAccessToken(
    request: GenerateAccessTokenRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateAccessTokenResponse>>;
}

export interface WorkstationsClient<CallOptionsExt = {}> {
  /** Returns the requested workstation cluster. */
  getWorkstationCluster(
    request: DeepPartial<GetWorkstationClusterRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WorkstationCluster>;
  /** Returns all workstation clusters in the specified location. */
  listWorkstationClusters(
    request: DeepPartial<ListWorkstationClustersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListWorkstationClustersResponse>;
  /** Creates a new workstation cluster. */
  createWorkstationCluster(
    request: DeepPartial<CreateWorkstationClusterRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates an existing workstation cluster. */
  updateWorkstationCluster(
    request: DeepPartial<UpdateWorkstationClusterRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes the specified workstation cluster. */
  deleteWorkstationCluster(
    request: DeepPartial<DeleteWorkstationClusterRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Returns the requested workstation configuration. */
  getWorkstationConfig(
    request: DeepPartial<GetWorkstationConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WorkstationConfig>;
  /** Returns all workstation configurations in the specified cluster. */
  listWorkstationConfigs(
    request: DeepPartial<ListWorkstationConfigsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListWorkstationConfigsResponse>;
  /**
   * Returns all workstation configurations in the specified cluster on which
   * the caller has the "workstations.workstation.create" permission.
   */
  listUsableWorkstationConfigs(
    request: DeepPartial<ListUsableWorkstationConfigsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListUsableWorkstationConfigsResponse>;
  /** Creates a new workstation configuration. */
  createWorkstationConfig(
    request: DeepPartial<CreateWorkstationConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates an existing workstation configuration. */
  updateWorkstationConfig(
    request: DeepPartial<UpdateWorkstationConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes the specified workstation configuration. */
  deleteWorkstationConfig(
    request: DeepPartial<DeleteWorkstationConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Returns the requested workstation. */
  getWorkstation(
    request: DeepPartial<GetWorkstationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Workstation>;
  /** Returns all Workstations using the specified workstation configuration. */
  listWorkstations(
    request: DeepPartial<ListWorkstationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListWorkstationsResponse>;
  /**
   * Returns all workstations using the specified workstation configuration
   * on which the caller has the "workstations.workstations.use" permission.
   */
  listUsableWorkstations(
    request: DeepPartial<ListUsableWorkstationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListUsableWorkstationsResponse>;
  /** Creates a new workstation. */
  createWorkstation(
    request: DeepPartial<CreateWorkstationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates an existing workstation. */
  updateWorkstation(
    request: DeepPartial<UpdateWorkstationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes the specified workstation. */
  deleteWorkstation(
    request: DeepPartial<DeleteWorkstationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Starts running a workstation so that users can connect to it. */
  startWorkstation(
    request: DeepPartial<StartWorkstationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Stops running a workstation, reducing costs. */
  stopWorkstation(
    request: DeepPartial<StopWorkstationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Returns a short-lived credential that can be used to send authenticated and
   * authorized traffic to a workstation.
   */
  generateAccessToken(
    request: DeepPartial<GenerateAccessTokenRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateAccessTokenResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
