// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/securitycenter/v2/kubernetes.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Container } from "./container.js";
import { Label } from "./label.js";

export const protobufPackage = "google.cloud.securitycenter.v2";

/** Kubernetes-related attributes. */
export interface Kubernetes {
  /**
   * Kubernetes
   * [Pods](https://cloud.google.com/kubernetes-engine/docs/concepts/pod)
   * associated with the finding. This field contains Pod records for each
   * container that is owned by a Pod.
   */
  pods: Kubernetes_Pod[];
  /**
   * Provides Kubernetes
   * [node](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture#nodes)
   * information.
   */
  nodes: Kubernetes_Node[];
  /**
   * GKE [node
   * pools](https://cloud.google.com/kubernetes-engine/docs/concepts/node-pools)
   * associated with the finding. This field contains node pool information for
   * each node, when it is available.
   */
  nodePools: Kubernetes_NodePool[];
  /**
   * Provides Kubernetes role information for findings that involve [Roles or
   * ClusterRoles](https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control).
   */
  roles: Kubernetes_Role[];
  /**
   * Provides Kubernetes role binding information for findings that involve
   * [RoleBindings or
   * ClusterRoleBindings](https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control).
   */
  bindings: Kubernetes_Binding[];
  /**
   * Provides information on any Kubernetes access reviews (privilege checks)
   * relevant to the finding.
   */
  accessReviews: Kubernetes_AccessReview[];
  /** Kubernetes objects related to the finding. */
  objects: Kubernetes_Object[];
}

/** A Kubernetes Pod. */
export interface Kubernetes_Pod {
  /** Kubernetes Pod namespace. */
  ns: string;
  /** Kubernetes Pod name. */
  name: string;
  /**
   * Pod labels.  For Kubernetes containers, these are applied to the
   * container.
   */
  labels: Label[];
  /** Pod containers associated with this finding, if any. */
  containers: Container[];
}

/** Kubernetes nodes associated with the finding. */
export interface Kubernetes_Node {
  /**
   * [Full resource name](https://google.aip.dev/122#full-resource-names) of
   * the Compute Engine VM running the cluster node.
   */
  name: string;
}

/** Provides GKE node pool information. */
export interface Kubernetes_NodePool {
  /** Kubernetes node pool name. */
  name: string;
  /** Nodes associated with the finding. */
  nodes: Kubernetes_Node[];
}

/** Kubernetes Role or ClusterRole. */
export interface Kubernetes_Role {
  /** Role type. */
  kind: Kubernetes_Role_Kind;
  /** Role namespace. */
  ns: string;
  /** Role name. */
  name: string;
}

/** Types of Kubernetes roles. */
export enum Kubernetes_Role_Kind {
  /** KIND_UNSPECIFIED - Role type is not specified. */
  KIND_UNSPECIFIED = 0,
  /** ROLE - Kubernetes Role. */
  ROLE = 1,
  /** CLUSTER_ROLE - Kubernetes ClusterRole. */
  CLUSTER_ROLE = 2,
  UNRECOGNIZED = -1,
}

export function kubernetes_Role_KindFromJSON(object: any): Kubernetes_Role_Kind {
  switch (object) {
    case 0:
    case "KIND_UNSPECIFIED":
      return Kubernetes_Role_Kind.KIND_UNSPECIFIED;
    case 1:
    case "ROLE":
      return Kubernetes_Role_Kind.ROLE;
    case 2:
    case "CLUSTER_ROLE":
      return Kubernetes_Role_Kind.CLUSTER_ROLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Kubernetes_Role_Kind.UNRECOGNIZED;
  }
}

export function kubernetes_Role_KindToJSON(object: Kubernetes_Role_Kind): string {
  switch (object) {
    case Kubernetes_Role_Kind.KIND_UNSPECIFIED:
      return "KIND_UNSPECIFIED";
    case Kubernetes_Role_Kind.ROLE:
      return "ROLE";
    case Kubernetes_Role_Kind.CLUSTER_ROLE:
      return "CLUSTER_ROLE";
    case Kubernetes_Role_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents a Kubernetes RoleBinding or ClusterRoleBinding. */
export interface Kubernetes_Binding {
  /** Namespace for the binding. */
  ns: string;
  /** Name for the binding. */
  name: string;
  /** The Role or ClusterRole referenced by the binding. */
  role:
    | Kubernetes_Role
    | undefined;
  /**
   * Represents one or more subjects that are bound to the role. Not always
   * available for PATCH requests.
   */
  subjects: Kubernetes_Subject[];
}

/** Represents a Kubernetes subject. */
export interface Kubernetes_Subject {
  /** Authentication type for the subject. */
  kind: Kubernetes_Subject_AuthType;
  /** Namespace for the subject. */
  ns: string;
  /** Name for the subject. */
  name: string;
}

/** Auth types that can be used for the subject's kind field. */
export enum Kubernetes_Subject_AuthType {
  /** AUTH_TYPE_UNSPECIFIED - Authentication is not specified. */
  AUTH_TYPE_UNSPECIFIED = 0,
  /** USER - User with valid certificate. */
  USER = 1,
  /** SERVICEACCOUNT - Users managed by Kubernetes API with credentials stored as secrets. */
  SERVICEACCOUNT = 2,
  /** GROUP - Collection of users. */
  GROUP = 3,
  UNRECOGNIZED = -1,
}

export function kubernetes_Subject_AuthTypeFromJSON(object: any): Kubernetes_Subject_AuthType {
  switch (object) {
    case 0:
    case "AUTH_TYPE_UNSPECIFIED":
      return Kubernetes_Subject_AuthType.AUTH_TYPE_UNSPECIFIED;
    case 1:
    case "USER":
      return Kubernetes_Subject_AuthType.USER;
    case 2:
    case "SERVICEACCOUNT":
      return Kubernetes_Subject_AuthType.SERVICEACCOUNT;
    case 3:
    case "GROUP":
      return Kubernetes_Subject_AuthType.GROUP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Kubernetes_Subject_AuthType.UNRECOGNIZED;
  }
}

export function kubernetes_Subject_AuthTypeToJSON(object: Kubernetes_Subject_AuthType): string {
  switch (object) {
    case Kubernetes_Subject_AuthType.AUTH_TYPE_UNSPECIFIED:
      return "AUTH_TYPE_UNSPECIFIED";
    case Kubernetes_Subject_AuthType.USER:
      return "USER";
    case Kubernetes_Subject_AuthType.SERVICEACCOUNT:
      return "SERVICEACCOUNT";
    case Kubernetes_Subject_AuthType.GROUP:
      return "GROUP";
    case Kubernetes_Subject_AuthType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Conveys information about a Kubernetes access review (such as one returned
 * by a [`kubectl auth
 * can-i`](https://kubernetes.io/docs/reference/access-authn-authz/authorization/#checking-api-access)
 * command) that was involved in a finding.
 */
export interface Kubernetes_AccessReview {
  /** The API group of the resource. "*" means all. */
  group: string;
  /**
   * Namespace of the action being requested. Currently, there is no
   * distinction between no namespace and all namespaces.  Both
   * are represented by "" (empty).
   */
  ns: string;
  /** The name of the resource being requested. Empty means all. */
  name: string;
  /** The optional resource type requested. "*" means all. */
  resource: string;
  /** The optional subresource type. */
  subresource: string;
  /**
   * A Kubernetes resource API verb, like get, list, watch, create, update,
   * delete, proxy. "*" means all.
   */
  verb: string;
  /** The API version of the resource. "*" means all. */
  version: string;
}

/**
 * Kubernetes object related to the finding, uniquely identified by GKNN.
 * Used if the object Kind is not one of Pod, Node, NodePool, Binding, or
 * AccessReview.
 */
export interface Kubernetes_Object {
  /** Kubernetes object group, such as "policy.k8s.io/v1". */
  group: string;
  /** Kubernetes object kind, such as "Namespace". */
  kind: string;
  /**
   * Kubernetes object namespace. Must be a valid DNS label. Named
   * "ns" to avoid collision with C++ namespace keyword. For details see
   * https://kubernetes.io/docs/tasks/administer-cluster/namespaces/.
   */
  ns: string;
  /**
   * Kubernetes object name. For details see
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/.
   */
  name: string;
  /** Pod containers associated with this finding, if any. */
  containers: Container[];
}

function createBaseKubernetes(): Kubernetes {
  return { pods: [], nodes: [], nodePools: [], roles: [], bindings: [], accessReviews: [], objects: [] };
}

export const Kubernetes: MessageFns<Kubernetes> = {
  encode(message: Kubernetes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pods) {
      Kubernetes_Pod.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.nodes) {
      Kubernetes_Node.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.nodePools) {
      Kubernetes_NodePool.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.roles) {
      Kubernetes_Role.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.bindings) {
      Kubernetes_Binding.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.accessReviews) {
      Kubernetes_AccessReview.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.objects) {
      Kubernetes_Object.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Kubernetes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pods.push(Kubernetes_Pod.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodes.push(Kubernetes_Node.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodePools.push(Kubernetes_NodePool.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.roles.push(Kubernetes_Role.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bindings.push(Kubernetes_Binding.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.accessReviews.push(Kubernetes_AccessReview.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.objects.push(Kubernetes_Object.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Kubernetes {
    return {
      pods: globalThis.Array.isArray(object?.pods) ? object.pods.map((e: any) => Kubernetes_Pod.fromJSON(e)) : [],
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Kubernetes_Node.fromJSON(e)) : [],
      nodePools: globalThis.Array.isArray(object?.nodePools)
        ? object.nodePools.map((e: any) => Kubernetes_NodePool.fromJSON(e))
        : [],
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => Kubernetes_Role.fromJSON(e)) : [],
      bindings: globalThis.Array.isArray(object?.bindings)
        ? object.bindings.map((e: any) => Kubernetes_Binding.fromJSON(e))
        : [],
      accessReviews: globalThis.Array.isArray(object?.accessReviews)
        ? object.accessReviews.map((e: any) => Kubernetes_AccessReview.fromJSON(e))
        : [],
      objects: globalThis.Array.isArray(object?.objects)
        ? object.objects.map((e: any) => Kubernetes_Object.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Kubernetes): unknown {
    const obj: any = {};
    if (message.pods?.length) {
      obj.pods = message.pods.map((e) => Kubernetes_Pod.toJSON(e));
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Kubernetes_Node.toJSON(e));
    }
    if (message.nodePools?.length) {
      obj.nodePools = message.nodePools.map((e) => Kubernetes_NodePool.toJSON(e));
    }
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => Kubernetes_Role.toJSON(e));
    }
    if (message.bindings?.length) {
      obj.bindings = message.bindings.map((e) => Kubernetes_Binding.toJSON(e));
    }
    if (message.accessReviews?.length) {
      obj.accessReviews = message.accessReviews.map((e) => Kubernetes_AccessReview.toJSON(e));
    }
    if (message.objects?.length) {
      obj.objects = message.objects.map((e) => Kubernetes_Object.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Kubernetes>): Kubernetes {
    return Kubernetes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Kubernetes>): Kubernetes {
    const message = createBaseKubernetes();
    message.pods = object.pods?.map((e) => Kubernetes_Pod.fromPartial(e)) || [];
    message.nodes = object.nodes?.map((e) => Kubernetes_Node.fromPartial(e)) || [];
    message.nodePools = object.nodePools?.map((e) => Kubernetes_NodePool.fromPartial(e)) || [];
    message.roles = object.roles?.map((e) => Kubernetes_Role.fromPartial(e)) || [];
    message.bindings = object.bindings?.map((e) => Kubernetes_Binding.fromPartial(e)) || [];
    message.accessReviews = object.accessReviews?.map((e) => Kubernetes_AccessReview.fromPartial(e)) || [];
    message.objects = object.objects?.map((e) => Kubernetes_Object.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKubernetes_Pod(): Kubernetes_Pod {
  return { ns: "", name: "", labels: [], containers: [] };
}

export const Kubernetes_Pod: MessageFns<Kubernetes_Pod> = {
  encode(message: Kubernetes_Pod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ns !== "") {
      writer.uint32(10).string(message.ns);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.labels) {
      Label.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.containers) {
      Container.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Kubernetes_Pod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetes_Pod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ns = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.labels.push(Label.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.containers.push(Container.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Kubernetes_Pod {
    return {
      ns: isSet(object.ns) ? globalThis.String(object.ns) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => Label.fromJSON(e)) : [],
      containers: globalThis.Array.isArray(object?.containers)
        ? object.containers.map((e: any) => Container.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Kubernetes_Pod): unknown {
    const obj: any = {};
    if (message.ns !== "") {
      obj.ns = message.ns;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.labels?.length) {
      obj.labels = message.labels.map((e) => Label.toJSON(e));
    }
    if (message.containers?.length) {
      obj.containers = message.containers.map((e) => Container.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Kubernetes_Pod>): Kubernetes_Pod {
    return Kubernetes_Pod.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Kubernetes_Pod>): Kubernetes_Pod {
    const message = createBaseKubernetes_Pod();
    message.ns = object.ns ?? "";
    message.name = object.name ?? "";
    message.labels = object.labels?.map((e) => Label.fromPartial(e)) || [];
    message.containers = object.containers?.map((e) => Container.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKubernetes_Node(): Kubernetes_Node {
  return { name: "" };
}

export const Kubernetes_Node: MessageFns<Kubernetes_Node> = {
  encode(message: Kubernetes_Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Kubernetes_Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetes_Node();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Kubernetes_Node {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: Kubernetes_Node): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<Kubernetes_Node>): Kubernetes_Node {
    return Kubernetes_Node.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Kubernetes_Node>): Kubernetes_Node {
    const message = createBaseKubernetes_Node();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseKubernetes_NodePool(): Kubernetes_NodePool {
  return { name: "", nodes: [] };
}

export const Kubernetes_NodePool: MessageFns<Kubernetes_NodePool> = {
  encode(message: Kubernetes_NodePool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.nodes) {
      Kubernetes_Node.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Kubernetes_NodePool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetes_NodePool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodes.push(Kubernetes_Node.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Kubernetes_NodePool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Kubernetes_Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: Kubernetes_NodePool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Kubernetes_Node.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Kubernetes_NodePool>): Kubernetes_NodePool {
    return Kubernetes_NodePool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Kubernetes_NodePool>): Kubernetes_NodePool {
    const message = createBaseKubernetes_NodePool();
    message.name = object.name ?? "";
    message.nodes = object.nodes?.map((e) => Kubernetes_Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKubernetes_Role(): Kubernetes_Role {
  return { kind: 0, ns: "", name: "" };
}

export const Kubernetes_Role: MessageFns<Kubernetes_Role> = {
  encode(message: Kubernetes_Role, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== 0) {
      writer.uint32(8).int32(message.kind);
    }
    if (message.ns !== "") {
      writer.uint32(18).string(message.ns);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Kubernetes_Role {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetes_Role();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ns = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Kubernetes_Role {
    return {
      kind: isSet(object.kind) ? kubernetes_Role_KindFromJSON(object.kind) : 0,
      ns: isSet(object.ns) ? globalThis.String(object.ns) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: Kubernetes_Role): unknown {
    const obj: any = {};
    if (message.kind !== 0) {
      obj.kind = kubernetes_Role_KindToJSON(message.kind);
    }
    if (message.ns !== "") {
      obj.ns = message.ns;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<Kubernetes_Role>): Kubernetes_Role {
    return Kubernetes_Role.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Kubernetes_Role>): Kubernetes_Role {
    const message = createBaseKubernetes_Role();
    message.kind = object.kind ?? 0;
    message.ns = object.ns ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseKubernetes_Binding(): Kubernetes_Binding {
  return { ns: "", name: "", role: undefined, subjects: [] };
}

export const Kubernetes_Binding: MessageFns<Kubernetes_Binding> = {
  encode(message: Kubernetes_Binding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ns !== "") {
      writer.uint32(10).string(message.ns);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.role !== undefined) {
      Kubernetes_Role.encode(message.role, writer.uint32(26).fork()).join();
    }
    for (const v of message.subjects) {
      Kubernetes_Subject.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Kubernetes_Binding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetes_Binding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ns = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.role = Kubernetes_Role.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subjects.push(Kubernetes_Subject.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Kubernetes_Binding {
    return {
      ns: isSet(object.ns) ? globalThis.String(object.ns) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      role: isSet(object.role) ? Kubernetes_Role.fromJSON(object.role) : undefined,
      subjects: globalThis.Array.isArray(object?.subjects)
        ? object.subjects.map((e: any) => Kubernetes_Subject.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Kubernetes_Binding): unknown {
    const obj: any = {};
    if (message.ns !== "") {
      obj.ns = message.ns;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.role !== undefined) {
      obj.role = Kubernetes_Role.toJSON(message.role);
    }
    if (message.subjects?.length) {
      obj.subjects = message.subjects.map((e) => Kubernetes_Subject.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Kubernetes_Binding>): Kubernetes_Binding {
    return Kubernetes_Binding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Kubernetes_Binding>): Kubernetes_Binding {
    const message = createBaseKubernetes_Binding();
    message.ns = object.ns ?? "";
    message.name = object.name ?? "";
    message.role = (object.role !== undefined && object.role !== null)
      ? Kubernetes_Role.fromPartial(object.role)
      : undefined;
    message.subjects = object.subjects?.map((e) => Kubernetes_Subject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKubernetes_Subject(): Kubernetes_Subject {
  return { kind: 0, ns: "", name: "" };
}

export const Kubernetes_Subject: MessageFns<Kubernetes_Subject> = {
  encode(message: Kubernetes_Subject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== 0) {
      writer.uint32(8).int32(message.kind);
    }
    if (message.ns !== "") {
      writer.uint32(18).string(message.ns);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Kubernetes_Subject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetes_Subject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ns = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Kubernetes_Subject {
    return {
      kind: isSet(object.kind) ? kubernetes_Subject_AuthTypeFromJSON(object.kind) : 0,
      ns: isSet(object.ns) ? globalThis.String(object.ns) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: Kubernetes_Subject): unknown {
    const obj: any = {};
    if (message.kind !== 0) {
      obj.kind = kubernetes_Subject_AuthTypeToJSON(message.kind);
    }
    if (message.ns !== "") {
      obj.ns = message.ns;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<Kubernetes_Subject>): Kubernetes_Subject {
    return Kubernetes_Subject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Kubernetes_Subject>): Kubernetes_Subject {
    const message = createBaseKubernetes_Subject();
    message.kind = object.kind ?? 0;
    message.ns = object.ns ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseKubernetes_AccessReview(): Kubernetes_AccessReview {
  return { group: "", ns: "", name: "", resource: "", subresource: "", verb: "", version: "" };
}

export const Kubernetes_AccessReview: MessageFns<Kubernetes_AccessReview> = {
  encode(message: Kubernetes_AccessReview, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== "") {
      writer.uint32(10).string(message.group);
    }
    if (message.ns !== "") {
      writer.uint32(18).string(message.ns);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.resource !== "") {
      writer.uint32(34).string(message.resource);
    }
    if (message.subresource !== "") {
      writer.uint32(42).string(message.subresource);
    }
    if (message.verb !== "") {
      writer.uint32(50).string(message.verb);
    }
    if (message.version !== "") {
      writer.uint32(58).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Kubernetes_AccessReview {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetes_AccessReview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ns = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.subresource = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Kubernetes_AccessReview {
    return {
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      ns: isSet(object.ns) ? globalThis.String(object.ns) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      subresource: isSet(object.subresource) ? globalThis.String(object.subresource) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: Kubernetes_AccessReview): unknown {
    const obj: any = {};
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.ns !== "") {
      obj.ns = message.ns;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.subresource !== "") {
      obj.subresource = message.subresource;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<Kubernetes_AccessReview>): Kubernetes_AccessReview {
    return Kubernetes_AccessReview.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Kubernetes_AccessReview>): Kubernetes_AccessReview {
    const message = createBaseKubernetes_AccessReview();
    message.group = object.group ?? "";
    message.ns = object.ns ?? "";
    message.name = object.name ?? "";
    message.resource = object.resource ?? "";
    message.subresource = object.subresource ?? "";
    message.verb = object.verb ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseKubernetes_Object(): Kubernetes_Object {
  return { group: "", kind: "", ns: "", name: "", containers: [] };
}

export const Kubernetes_Object: MessageFns<Kubernetes_Object> = {
  encode(message: Kubernetes_Object, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== "") {
      writer.uint32(10).string(message.group);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.ns !== "") {
      writer.uint32(26).string(message.ns);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    for (const v of message.containers) {
      Container.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Kubernetes_Object {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetes_Object();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ns = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.containers.push(Container.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Kubernetes_Object {
    return {
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      ns: isSet(object.ns) ? globalThis.String(object.ns) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      containers: globalThis.Array.isArray(object?.containers)
        ? object.containers.map((e: any) => Container.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Kubernetes_Object): unknown {
    const obj: any = {};
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.ns !== "") {
      obj.ns = message.ns;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.containers?.length) {
      obj.containers = message.containers.map((e) => Container.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Kubernetes_Object>): Kubernetes_Object {
    return Kubernetes_Object.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Kubernetes_Object>): Kubernetes_Object {
    const message = createBaseKubernetes_Object();
    message.group = object.group ?? "";
    message.kind = object.kind ?? "";
    message.ns = object.ns ?? "";
    message.name = object.name ?? "";
    message.containers = object.containers?.map((e) => Container.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
