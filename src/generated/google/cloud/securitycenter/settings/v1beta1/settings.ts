// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/securitycenter/settings/v1beta1/settings.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { BillingSettings } from "./billing_settings.js";
import {
  ComponentEnablementState,
  componentEnablementStateFromJSON,
  componentEnablementStateToJSON,
  ComponentSettings,
} from "./component_settings.js";
import { SinkSettings } from "./sink_settings.js";

export const protobufPackage = "google.cloud.securitycenter.settings.v1beta1";

/** Common configuration settings for all of Security Center. */
export interface Settings {
  /**
   * The relative resource name of the settings resource.
   * Formats:
   *  * `organizations/{organization}/settings`
   *  * `folders/{folder}/settings`
   *  * `projects/{project}/settings`
   *  * `projects/{project}/locations/{location}/clusters/{cluster}/settings`
   *  * `projects/{project}/regions/{region}/clusters/{cluster}/settings`
   *  * `projects/{project}/zones/{zone}/clusters/{cluster}/settings`
   */
  name: string;
  /** Billing settings */
  billingSettings:
    | BillingSettings
    | undefined;
  /** An enum representing the current on boarding state of SCC. */
  state: Settings_OnboardingState;
  /**
   * Output only. The organization-level service account to be used for security center
   * components. The component must have permission to "act as" the service
   * account.
   */
  orgServiceAccount: string;
  /** Sink settings. */
  sinkSettings:
    | SinkSettings
    | undefined;
  /** The settings for detectors and/or scanners. */
  componentSettings: { [key: string]: ComponentSettings };
  /**
   * Detector group settings for all Security Center components.
   * The key is the name of the detector group and the value is the settings for
   * that group.
   */
  detectorGroupSettings: { [key: string]: Settings_DetectorGroupSettings };
  /**
   * A fingerprint used for optimistic concurrency. If none is provided
   * on updates then the existing metadata will be blindly overwritten.
   */
  etag: string;
  /** Output only. The time these settings were last updated. */
  updateTime: Date | undefined;
}

/**
 * Defines the onboarding states for SCC
 *
 * Potentially is just an indicator that a user has reviewed some subset of
 * our configuration surface, even if it's still currently set to its
 * API-default state.
 */
export enum Settings_OnboardingState {
  /**
   * ONBOARDING_STATE_UNSPECIFIED - No onboarding state has been set. Should not be seen in practice, but
   * should be functionally equivalent to DISABLED.
   */
  ONBOARDING_STATE_UNSPECIFIED = 0,
  /** ENABLED - SCC is fully on boarded */
  ENABLED = 1,
  /** DISABLED - SCC has been disabled after being on boarded */
  DISABLED = 2,
  /** BILLING_SELECTED - SCC's onboarding tier has been explicitly set */
  BILLING_SELECTED = 3,
  /** PROVIDERS_SELECTED - SCC's CTD FindingsProviders have been chosen */
  PROVIDERS_SELECTED = 4,
  /** RESOURCES_SELECTED - SCC's Service-Resource mappings have been set */
  RESOURCES_SELECTED = 5,
  /** ORG_SERVICE_ACCOUNT_CREATED - SCC's core Service Account was created */
  ORG_SERVICE_ACCOUNT_CREATED = 6,
  UNRECOGNIZED = -1,
}

export function settings_OnboardingStateFromJSON(object: any): Settings_OnboardingState {
  switch (object) {
    case 0:
    case "ONBOARDING_STATE_UNSPECIFIED":
      return Settings_OnboardingState.ONBOARDING_STATE_UNSPECIFIED;
    case 1:
    case "ENABLED":
      return Settings_OnboardingState.ENABLED;
    case 2:
    case "DISABLED":
      return Settings_OnboardingState.DISABLED;
    case 3:
    case "BILLING_SELECTED":
      return Settings_OnboardingState.BILLING_SELECTED;
    case 4:
    case "PROVIDERS_SELECTED":
      return Settings_OnboardingState.PROVIDERS_SELECTED;
    case 5:
    case "RESOURCES_SELECTED":
      return Settings_OnboardingState.RESOURCES_SELECTED;
    case 6:
    case "ORG_SERVICE_ACCOUNT_CREATED":
      return Settings_OnboardingState.ORG_SERVICE_ACCOUNT_CREATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Settings_OnboardingState.UNRECOGNIZED;
  }
}

export function settings_OnboardingStateToJSON(object: Settings_OnboardingState): string {
  switch (object) {
    case Settings_OnboardingState.ONBOARDING_STATE_UNSPECIFIED:
      return "ONBOARDING_STATE_UNSPECIFIED";
    case Settings_OnboardingState.ENABLED:
      return "ENABLED";
    case Settings_OnboardingState.DISABLED:
      return "DISABLED";
    case Settings_OnboardingState.BILLING_SELECTED:
      return "BILLING_SELECTED";
    case Settings_OnboardingState.PROVIDERS_SELECTED:
      return "PROVIDERS_SELECTED";
    case Settings_OnboardingState.RESOURCES_SELECTED:
      return "RESOURCES_SELECTED";
    case Settings_OnboardingState.ORG_SERVICE_ACCOUNT_CREATED:
      return "ORG_SERVICE_ACCOUNT_CREATED";
    case Settings_OnboardingState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The DetectorGroupSettings define the configuration for a detector group. */
export interface Settings_DetectorGroupSettings {
  /** The state determines if the group is enabled or not. */
  state: ComponentEnablementState;
}

export interface Settings_ComponentSettingsEntry {
  key: string;
  value: ComponentSettings | undefined;
}

export interface Settings_DetectorGroupSettingsEntry {
  key: string;
  value: Settings_DetectorGroupSettings | undefined;
}

function createBaseSettings(): Settings {
  return {
    name: "",
    billingSettings: undefined,
    state: 0,
    orgServiceAccount: "",
    sinkSettings: undefined,
    componentSettings: {},
    detectorGroupSettings: {},
    etag: "",
    updateTime: undefined,
  };
}

export const Settings: MessageFns<Settings> = {
  encode(message: Settings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.billingSettings !== undefined) {
      BillingSettings.encode(message.billingSettings, writer.uint32(18).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.orgServiceAccount !== "") {
      writer.uint32(42).string(message.orgServiceAccount);
    }
    if (message.sinkSettings !== undefined) {
      SinkSettings.encode(message.sinkSettings, writer.uint32(50).fork()).join();
    }
    Object.entries(message.componentSettings).forEach(([key, value]) => {
      Settings_ComponentSettingsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    Object.entries(message.detectorGroupSettings).forEach(([key, value]) => {
      Settings_DetectorGroupSettingsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(74).string(message.etag);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.billingSettings = BillingSettings.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orgServiceAccount = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sinkSettings = SinkSettings.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Settings_ComponentSettingsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.componentSettings[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = Settings_DetectorGroupSettingsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.detectorGroupSettings[entry8.key] = entry8.value;
          }
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      billingSettings: isSet(object.billingSettings) ? BillingSettings.fromJSON(object.billingSettings) : undefined,
      state: isSet(object.state) ? settings_OnboardingStateFromJSON(object.state) : 0,
      orgServiceAccount: isSet(object.orgServiceAccount) ? globalThis.String(object.orgServiceAccount) : "",
      sinkSettings: isSet(object.sinkSettings) ? SinkSettings.fromJSON(object.sinkSettings) : undefined,
      componentSettings: isObject(object.componentSettings)
        ? Object.entries(object.componentSettings).reduce<{ [key: string]: ComponentSettings }>((acc, [key, value]) => {
          acc[key] = ComponentSettings.fromJSON(value);
          return acc;
        }, {})
        : {},
      detectorGroupSettings: isObject(object.detectorGroupSettings)
        ? Object.entries(object.detectorGroupSettings).reduce<{ [key: string]: Settings_DetectorGroupSettings }>(
          (acc, [key, value]) => {
            acc[key] = Settings_DetectorGroupSettings.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: Settings): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.billingSettings !== undefined) {
      obj.billingSettings = BillingSettings.toJSON(message.billingSettings);
    }
    if (message.state !== 0) {
      obj.state = settings_OnboardingStateToJSON(message.state);
    }
    if (message.orgServiceAccount !== "") {
      obj.orgServiceAccount = message.orgServiceAccount;
    }
    if (message.sinkSettings !== undefined) {
      obj.sinkSettings = SinkSettings.toJSON(message.sinkSettings);
    }
    if (message.componentSettings) {
      const entries = Object.entries(message.componentSettings);
      if (entries.length > 0) {
        obj.componentSettings = {};
        entries.forEach(([k, v]) => {
          obj.componentSettings[k] = ComponentSettings.toJSON(v);
        });
      }
    }
    if (message.detectorGroupSettings) {
      const entries = Object.entries(message.detectorGroupSettings);
      if (entries.length > 0) {
        obj.detectorGroupSettings = {};
        entries.forEach(([k, v]) => {
          obj.detectorGroupSettings[k] = Settings_DetectorGroupSettings.toJSON(v);
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Settings>): Settings {
    return Settings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings>): Settings {
    const message = createBaseSettings();
    message.name = object.name ?? "";
    message.billingSettings = (object.billingSettings !== undefined && object.billingSettings !== null)
      ? BillingSettings.fromPartial(object.billingSettings)
      : undefined;
    message.state = object.state ?? 0;
    message.orgServiceAccount = object.orgServiceAccount ?? "";
    message.sinkSettings = (object.sinkSettings !== undefined && object.sinkSettings !== null)
      ? SinkSettings.fromPartial(object.sinkSettings)
      : undefined;
    message.componentSettings = Object.entries(object.componentSettings ?? {}).reduce<
      { [key: string]: ComponentSettings }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = ComponentSettings.fromPartial(value);
      }
      return acc;
    }, {});
    message.detectorGroupSettings = Object.entries(object.detectorGroupSettings ?? {}).reduce<
      { [key: string]: Settings_DetectorGroupSettings }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Settings_DetectorGroupSettings.fromPartial(value);
      }
      return acc;
    }, {});
    message.etag = object.etag ?? "";
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseSettings_DetectorGroupSettings(): Settings_DetectorGroupSettings {
  return { state: 0 };
}

export const Settings_DetectorGroupSettings: MessageFns<Settings_DetectorGroupSettings> = {
  encode(message: Settings_DetectorGroupSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings_DetectorGroupSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings_DetectorGroupSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings_DetectorGroupSettings {
    return { state: isSet(object.state) ? componentEnablementStateFromJSON(object.state) : 0 };
  },

  toJSON(message: Settings_DetectorGroupSettings): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = componentEnablementStateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<Settings_DetectorGroupSettings>): Settings_DetectorGroupSettings {
    return Settings_DetectorGroupSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings_DetectorGroupSettings>): Settings_DetectorGroupSettings {
    const message = createBaseSettings_DetectorGroupSettings();
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseSettings_ComponentSettingsEntry(): Settings_ComponentSettingsEntry {
  return { key: "", value: undefined };
}

export const Settings_ComponentSettingsEntry: MessageFns<Settings_ComponentSettingsEntry> = {
  encode(message: Settings_ComponentSettingsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ComponentSettings.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings_ComponentSettingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings_ComponentSettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ComponentSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings_ComponentSettingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ComponentSettings.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Settings_ComponentSettingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ComponentSettings.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Settings_ComponentSettingsEntry>): Settings_ComponentSettingsEntry {
    return Settings_ComponentSettingsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings_ComponentSettingsEntry>): Settings_ComponentSettingsEntry {
    const message = createBaseSettings_ComponentSettingsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ComponentSettings.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSettings_DetectorGroupSettingsEntry(): Settings_DetectorGroupSettingsEntry {
  return { key: "", value: undefined };
}

export const Settings_DetectorGroupSettingsEntry: MessageFns<Settings_DetectorGroupSettingsEntry> = {
  encode(message: Settings_DetectorGroupSettingsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Settings_DetectorGroupSettings.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings_DetectorGroupSettingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings_DetectorGroupSettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Settings_DetectorGroupSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings_DetectorGroupSettingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Settings_DetectorGroupSettings.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Settings_DetectorGroupSettingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Settings_DetectorGroupSettings.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Settings_DetectorGroupSettingsEntry>): Settings_DetectorGroupSettingsEntry {
    return Settings_DetectorGroupSettingsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings_DetectorGroupSettingsEntry>): Settings_DetectorGroupSettingsEntry {
    const message = createBaseSettings_DetectorGroupSettingsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Settings_DetectorGroupSettings.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
