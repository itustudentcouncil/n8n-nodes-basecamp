// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/securitycenter/v1beta1/securitycenter_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  GetIamPolicyRequest,
  SetIamPolicyRequest,
  TestIamPermissionsRequest,
  TestIamPermissionsResponse,
} from "../../../iam/v1/iam_policy.js";
import { Policy } from "../../../iam/v1/policy.js";
import { Operation } from "../../../longrunning/operations.js";
import { Duration } from "../../../protobuf/duration.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Value } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Asset } from "./asset.js";
import { Finding, Finding_State, finding_StateFromJSON, finding_StateToJSON } from "./finding.js";
import { OrganizationSettings } from "./organization_settings.js";
import { SecurityMarks } from "./security_marks.js";
import { Source } from "./source.js";

export const protobufPackage = "google.cloud.securitycenter.v1beta1";

/** Request message for creating a finding. */
export interface CreateFindingRequest {
  /**
   * Required. Resource name of the new finding's parent. Its format should be
   * "organizations/[organization_id]/sources/[source_id]".
   */
  parent: string;
  /**
   * Required. Unique identifier provided by the client within the parent scope.
   * It must be alphanumeric and less than or equal to 32 characters and
   * greater than 0 characters in length.
   */
  findingId: string;
  /**
   * Required. The Finding being created. The name and security_marks will be ignored as
   * they are both output only fields on this resource.
   */
  finding: Finding | undefined;
}

/** Request message for creating a source. */
export interface CreateSourceRequest {
  /**
   * Required. Resource name of the new source's parent. Its format should be
   * "organizations/[organization_id]".
   */
  parent: string;
  /**
   * Required. The Source being created, only the display_name and description will be
   * used. All other fields will be ignored.
   */
  source: Source | undefined;
}

/** Request message for getting organization settings. */
export interface GetOrganizationSettingsRequest {
  /**
   * Required. Name of the organization to get organization settings for. Its format is
   * "organizations/[organization_id]/organizationSettings".
   */
  name: string;
}

/** Request message for getting a source. */
export interface GetSourceRequest {
  /**
   * Required. Relative resource name of the source. Its format is
   * "organizations/[organization_id]/source/[source_id]".
   */
  name: string;
}

/** Request message for grouping by assets. */
export interface GroupAssetsRequest {
  /**
   * Required. Name of the organization to groupBy. Its format is
   * "organizations/[organization_id]".
   */
  parent: string;
  /**
   * Expression that defines the filter to apply across assets.
   * The expression is a list of zero or more restrictions combined via logical
   * operators `AND` and `OR`.
   * Parentheses are not supported, and `OR` has higher precedence than `AND`.
   *
   * Restrictions have the form `<field> <operator> <value>` and may have a `-`
   * character in front of them to indicate negation. The fields map to those
   * defined in the Asset resource. Examples include:
   *
   * * name
   * * security_center_properties.resource_name
   * * resource_properties.a_property
   * * security_marks.marks.marka
   *
   * The supported operators are:
   *
   * * `=` for all value types.
   * * `>`, `<`, `>=`, `<=` for integer values.
   * * `:`, meaning substring matching, for strings.
   *
   * The supported value types are:
   *
   * * string literals in quotes.
   * * integer literals without quotes.
   * * boolean literals `true` and `false` without quotes.
   *
   * For example, `resource_properties.size = 100` is a valid filter string.
   */
  filter: string;
  /**
   * Required. Expression that defines what assets fields to use for grouping. The string
   * value should follow SQL syntax: comma separated list of fields. For
   * example:
   * "security_center_properties.resource_project,security_center_properties.project".
   *
   * The following fields are supported when compare_duration is not set:
   *
   * * security_center_properties.resource_project
   * * security_center_properties.resource_type
   * * security_center_properties.resource_parent
   *
   * The following fields are supported when compare_duration is set:
   *
   * * security_center_properties.resource_type
   */
  groupBy: string;
  /**
   * When compare_duration is set, the Asset's "state" property is updated to
   * indicate whether the asset was added, removed, or remained present during
   * the compare_duration period of time that precedes the read_time. This is
   * the time between (read_time - compare_duration) and read_time.
   *
   * The state value is derived based on the presence of the asset at the two
   * points in time. Intermediate state changes between the two times don't
   * affect the result. For example, the results aren't affected if the asset is
   * removed and re-created again.
   *
   * Possible "state" values when compare_duration is specified:
   *
   * * "ADDED": indicates that the asset was not present before
   *              compare_duration, but present at reference_time.
   * * "REMOVED": indicates that the asset was present at the start of
   *              compare_duration, but not present at reference_time.
   * * "ACTIVE": indicates that the asset was present at both the
   *              start and the end of the time period defined by
   *              compare_duration and reference_time.
   *
   * This field is ignored if `state` is not a field in `group_by`.
   */
  compareDuration:
    | Duration
    | undefined;
  /**
   * Time used as a reference point when filtering assets. The filter is limited
   * to assets existing at the supplied time and their values are those at that
   * specific time. Absence of this field will default to the API's version of
   * NOW.
   */
  readTime:
    | Date
    | undefined;
  /**
   * The value returned by the last `GroupAssetsResponse`; indicates
   * that this is a continuation of a prior `GroupAssets` call, and that the
   * system should return the next page of data.
   */
  pageToken: string;
  /**
   * The maximum number of results to return in a single response. Default is
   * 10, minimum is 1, maximum is 1000.
   */
  pageSize: number;
}

/** Response message for grouping by assets. */
export interface GroupAssetsResponse {
  /**
   * Group results. There exists an element for each existing unique
   * combination of property/values. The element contains a count for the number
   * of times those specific property/values appear.
   */
  groupByResults: GroupResult[];
  /** Time used for executing the groupBy request. */
  readTime:
    | Date
    | undefined;
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results.
   */
  nextPageToken: string;
}

/** Request message for grouping by findings. */
export interface GroupFindingsRequest {
  /**
   * Required. Name of the source to groupBy. Its format is
   * "organizations/[organization_id]/sources/[source_id]". To groupBy across
   * all sources provide a source_id of `-`. For example:
   * organizations/{organization_id}/sources/-
   */
  parent: string;
  /**
   * Expression that defines the filter to apply across findings.
   * The expression is a list of one or more restrictions combined via logical
   * operators `AND` and `OR`.
   * Parentheses are not supported, and `OR` has higher precedence than `AND`.
   *
   * Restrictions have the form `<field> <operator> <value>` and may have a `-`
   * character in front of them to indicate negation. Examples include:
   *
   *  * name
   *  * source_properties.a_property
   *  * security_marks.marks.marka
   *
   * The supported operators are:
   *
   * * `=` for all value types.
   * * `>`, `<`, `>=`, `<=` for integer values.
   * * `:`, meaning substring matching, for strings.
   *
   * The supported value types are:
   *
   * * string literals in quotes.
   * * integer literals without quotes.
   * * boolean literals `true` and `false` without quotes.
   *
   * For example, `source_properties.size = 100` is a valid filter string.
   */
  filter: string;
  /**
   * Required. Expression that defines what assets fields to use for grouping (including
   * `state`). The string value should follow SQL syntax: comma separated list
   * of fields. For example:
   * "parent,resource_name".
   *
   * The following fields are supported:
   *
   * * resource_name
   * * category
   * * state
   * * parent
   */
  groupBy: string;
  /**
   * Time used as a reference point when filtering findings. The filter is
   * limited to findings existing at the supplied time and their values are
   * those at that specific time. Absence of this field will default to the
   * API's version of NOW.
   */
  readTime:
    | Date
    | undefined;
  /**
   * The value returned by the last `GroupFindingsResponse`; indicates
   * that this is a continuation of a prior `GroupFindings` call, and
   * that the system should return the next page of data.
   */
  pageToken: string;
  /**
   * The maximum number of results to return in a single response. Default is
   * 10, minimum is 1, maximum is 1000.
   */
  pageSize: number;
}

/** Response message for group by findings. */
export interface GroupFindingsResponse {
  /**
   * Group results. There exists an element for each existing unique
   * combination of property/values. The element contains a count for the number
   * of times those specific property/values appear.
   */
  groupByResults: GroupResult[];
  /** Time used for executing the groupBy request. */
  readTime:
    | Date
    | undefined;
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results.
   */
  nextPageToken: string;
}

/** Result containing the properties and count of a groupBy request. */
export interface GroupResult {
  /** Properties matching the groupBy fields in the request. */
  properties: { [key: string]: any | undefined };
  /** Total count of resources for the given properties. */
  count: Long;
}

export interface GroupResult_PropertiesEntry {
  key: string;
  value: any | undefined;
}

/** Request message for listing sources. */
export interface ListSourcesRequest {
  /**
   * Required. Resource name of the parent of sources to list. Its format should be
   * "organizations/[organization_id]".
   */
  parent: string;
  /**
   * The value returned by the last `ListSourcesResponse`; indicates
   * that this is a continuation of a prior `ListSources` call, and
   * that the system should return the next page of data.
   */
  pageToken: string;
  /**
   * The maximum number of results to return in a single response. Default is
   * 10, minimum is 1, maximum is 1000.
   */
  pageSize: number;
}

/** Response message for listing sources. */
export interface ListSourcesResponse {
  /** Sources belonging to the requested parent. */
  sources: Source[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results.
   */
  nextPageToken: string;
}

/** Request message for listing assets. */
export interface ListAssetsRequest {
  /**
   * Required. Name of the organization assets should belong to. Its format is
   * "organizations/[organization_id]".
   */
  parent: string;
  /**
   * Expression that defines the filter to apply across assets.
   * The expression is a list of zero or more restrictions combined via logical
   * operators `AND` and `OR`.
   * Parentheses are not supported, and `OR` has higher precedence than `AND`.
   *
   * Restrictions have the form `<field> <operator> <value>` and may have a `-`
   * character in front of them to indicate negation. The fields map to those
   * defined in the Asset resource. Examples include:
   *
   * * name
   * * security_center_properties.resource_name
   * * resource_properties.a_property
   * * security_marks.marks.marka
   *
   * The supported operators are:
   *
   * * `=` for all value types.
   * * `>`, `<`, `>=`, `<=` for integer values.
   * * `:`, meaning substring matching, for strings.
   *
   * The supported value types are:
   *
   * * string literals in quotes.
   * * integer literals without quotes.
   * * boolean literals `true` and `false` without quotes.
   *
   * For example, `resource_properties.size = 100` is a valid filter string.
   */
  filter: string;
  /**
   * Expression that defines what fields and order to use for sorting. The
   * string value should follow SQL syntax: comma separated list of fields. For
   * example: "name,resource_properties.a_property". The default sorting order
   * is ascending. To specify descending order for a field, a suffix " desc"
   * should be appended to the field name. For example: "name
   * desc,resource_properties.a_property". Redundant space characters in the
   * syntax are insignificant. "name desc,resource_properties.a_property" and "
   * name     desc  ,   resource_properties.a_property  " are equivalent.
   */
  orderBy: string;
  /**
   * Time used as a reference point when filtering assets. The filter is limited
   * to assets existing at the supplied time and their values are those at that
   * specific time. Absence of this field will default to the API's version of
   * NOW.
   */
  readTime:
    | Date
    | undefined;
  /**
   * When compare_duration is set, the ListAssetResult's "state" attribute is
   * updated to indicate whether the asset was added, removed, or remained
   * present during the compare_duration period of time that precedes the
   * read_time. This is the time between (read_time -
   * compare_duration) and read_time.
   *
   * The state value is derived based on the presence of the asset at the two
   * points in time. Intermediate state changes between the two times don't
   * affect the result. For example, the results aren't affected if the asset is
   * removed and re-created again.
   *
   * Possible "state" values when compare_duration is specified:
   *
   * * "ADDED": indicates that the asset was not present before
   *              compare_duration, but present at read_time.
   * * "REMOVED": indicates that the asset was present at the start of
   *              compare_duration, but not present at read_time.
   * * "ACTIVE": indicates that the asset was present at both the
   *              start and the end of the time period defined by
   *              compare_duration and read_time.
   *
   * If compare_duration is not specified, then the only possible state is
   * "UNUSED", which indicates that the asset is present at read_time.
   */
  compareDuration:
    | Duration
    | undefined;
  /**
   * Optional. A field mask to specify the ListAssetsResult fields to be listed in the
   * response.
   * An empty field mask will list all fields.
   */
  fieldMask:
    | string[]
    | undefined;
  /**
   * The value returned by the last `ListAssetsResponse`; indicates
   * that this is a continuation of a prior `ListAssets` call, and
   * that the system should return the next page of data.
   */
  pageToken: string;
  /**
   * The maximum number of results to return in a single response. Default is
   * 10, minimum is 1, maximum is 1000.
   */
  pageSize: number;
}

/** Response message for listing assets. */
export interface ListAssetsResponse {
  /** Assets matching the list request. */
  listAssetsResults: ListAssetsResponse_ListAssetsResult[];
  /** Time used for executing the list request. */
  readTime:
    | Date
    | undefined;
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results.
   */
  nextPageToken: string;
  /** The total number of assets matching the query. */
  totalSize: number;
}

/** Result containing the Asset and its State. */
export interface ListAssetsResponse_ListAssetsResult {
  /** Asset matching the search request. */
  asset:
    | Asset
    | undefined;
  /** State of the asset. */
  state: ListAssetsResponse_ListAssetsResult_State;
}

/**
 * State of the asset.
 *
 * When querying across two points in time this describes
 * the change between the two points: ADDED, REMOVED, or ACTIVE.
 * If there was no compare_duration supplied in the request the state should
 * be: UNUSED
 */
export enum ListAssetsResponse_ListAssetsResult_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** UNUSED - Request did not specify use of this field in the result. */
  UNUSED = 1,
  /** ADDED - Asset was added between the points in time. */
  ADDED = 2,
  /** REMOVED - Asset was removed between the points in time. */
  REMOVED = 3,
  /** ACTIVE - Asset was active at both point(s) in time. */
  ACTIVE = 4,
  UNRECOGNIZED = -1,
}

export function listAssetsResponse_ListAssetsResult_StateFromJSON(
  object: any,
): ListAssetsResponse_ListAssetsResult_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ListAssetsResponse_ListAssetsResult_State.STATE_UNSPECIFIED;
    case 1:
    case "UNUSED":
      return ListAssetsResponse_ListAssetsResult_State.UNUSED;
    case 2:
    case "ADDED":
      return ListAssetsResponse_ListAssetsResult_State.ADDED;
    case 3:
    case "REMOVED":
      return ListAssetsResponse_ListAssetsResult_State.REMOVED;
    case 4:
    case "ACTIVE":
      return ListAssetsResponse_ListAssetsResult_State.ACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ListAssetsResponse_ListAssetsResult_State.UNRECOGNIZED;
  }
}

export function listAssetsResponse_ListAssetsResult_StateToJSON(
  object: ListAssetsResponse_ListAssetsResult_State,
): string {
  switch (object) {
    case ListAssetsResponse_ListAssetsResult_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ListAssetsResponse_ListAssetsResult_State.UNUSED:
      return "UNUSED";
    case ListAssetsResponse_ListAssetsResult_State.ADDED:
      return "ADDED";
    case ListAssetsResponse_ListAssetsResult_State.REMOVED:
      return "REMOVED";
    case ListAssetsResponse_ListAssetsResult_State.ACTIVE:
      return "ACTIVE";
    case ListAssetsResponse_ListAssetsResult_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for listing findings. */
export interface ListFindingsRequest {
  /**
   * Required. Name of the source the findings belong to. Its format is
   * "organizations/[organization_id]/sources/[source_id]". To list across all
   * sources provide a source_id of `-`. For example:
   * organizations/{organization_id}/sources/-
   */
  parent: string;
  /**
   * Expression that defines the filter to apply across findings.
   * The expression is a list of one or more restrictions combined via logical
   * operators `AND` and `OR`.
   * Parentheses are not supported, and `OR` has higher precedence than `AND`.
   *
   * Restrictions have the form `<field> <operator> <value>` and may have a `-`
   * character in front of them to indicate negation. Examples include:
   *
   *  * name
   *  * source_properties.a_property
   *  * security_marks.marks.marka
   *
   * The supported operators are:
   *
   * * `=` for all value types.
   * * `>`, `<`, `>=`, `<=` for integer values.
   * * `:`, meaning substring matching, for strings.
   *
   * The supported value types are:
   *
   * * string literals in quotes.
   * * integer literals without quotes.
   * * boolean literals `true` and `false` without quotes.
   *
   * For example, `source_properties.size = 100` is a valid filter string.
   */
  filter: string;
  /**
   * Expression that defines what fields and order to use for sorting. The
   * string value should follow SQL syntax: comma separated list of fields. For
   * example: "name,resource_properties.a_property". The default sorting order
   * is ascending. To specify descending order for a field, a suffix " desc"
   * should be appended to the field name. For example: "name
   * desc,source_properties.a_property". Redundant space characters in the
   * syntax are insignificant. "name desc,source_properties.a_property" and "
   * name     desc  ,   source_properties.a_property  " are equivalent.
   */
  orderBy: string;
  /**
   * Time used as a reference point when filtering findings. The filter is
   * limited to findings existing at the supplied time and their values are
   * those at that specific time. Absence of this field will default to the
   * API's version of NOW.
   */
  readTime:
    | Date
    | undefined;
  /**
   * Optional. A field mask to specify the Finding fields to be listed in the response.
   * An empty field mask will list all fields.
   */
  fieldMask:
    | string[]
    | undefined;
  /**
   * The value returned by the last `ListFindingsResponse`; indicates
   * that this is a continuation of a prior `ListFindings` call, and
   * that the system should return the next page of data.
   */
  pageToken: string;
  /**
   * The maximum number of results to return in a single response. Default is
   * 10, minimum is 1, maximum is 1000.
   */
  pageSize: number;
}

/** Response message for listing findings. */
export interface ListFindingsResponse {
  /** Findings matching the list request. */
  findings: Finding[];
  /** Time used for executing the list request. */
  readTime:
    | Date
    | undefined;
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results.
   */
  nextPageToken: string;
  /** The total number of findings matching the query. */
  totalSize: number;
}

/** Request message for updating a finding's state. */
export interface SetFindingStateRequest {
  /**
   * Required. The relative resource name of the finding. See:
   * https://cloud.google.com/apis/design/resource_names#relative_resource_name
   * Example:
   * "organizations/{organization_id}/sources/{source_id}/finding/{finding_id}".
   */
  name: string;
  /** Required. The desired State of the finding. */
  state: Finding_State;
  /** Required. The time at which the updated state takes effect. */
  startTime: Date | undefined;
}

/** Request message for running asset discovery for an organization. */
export interface RunAssetDiscoveryRequest {
  /**
   * Required. Name of the organization to run asset discovery for. Its format is
   * "organizations/[organization_id]".
   */
  parent: string;
}

/** Request message for updating or creating a finding. */
export interface UpdateFindingRequest {
  /**
   * Required. The finding resource to update or create if it does not already exist.
   * parent, security_marks, and update_time will be ignored.
   *
   * In the case of creation, the finding id portion of the name must
   * alphanumeric and less than or equal to 32 characters and greater than 0
   * characters in length.
   */
  finding:
    | Finding
    | undefined;
  /**
   * The FieldMask to use when updating the finding resource. This field should
   * not be specified when creating a finding.
   */
  updateMask: string[] | undefined;
}

/** Request message for updating an organization's settings. */
export interface UpdateOrganizationSettingsRequest {
  /** Required. The organization settings resource to update. */
  organizationSettings:
    | OrganizationSettings
    | undefined;
  /** The FieldMask to use when updating the settings resource. */
  updateMask: string[] | undefined;
}

/** Request message for updating a source. */
export interface UpdateSourceRequest {
  /** Required. The source resource to update. */
  source:
    | Source
    | undefined;
  /** The FieldMask to use when updating the source resource. */
  updateMask: string[] | undefined;
}

/** Request message for updating a SecurityMarks resource. */
export interface UpdateSecurityMarksRequest {
  /** Required. The security marks resource to update. */
  securityMarks:
    | SecurityMarks
    | undefined;
  /** The FieldMask to use when updating the security marks resource. */
  updateMask:
    | string[]
    | undefined;
  /** The time at which the updated SecurityMarks take effect. */
  startTime: Date | undefined;
}

function createBaseCreateFindingRequest(): CreateFindingRequest {
  return { parent: "", findingId: "", finding: undefined };
}

export const CreateFindingRequest: MessageFns<CreateFindingRequest> = {
  encode(message: CreateFindingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.findingId !== "") {
      writer.uint32(18).string(message.findingId);
    }
    if (message.finding !== undefined) {
      Finding.encode(message.finding, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFindingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFindingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.findingId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.finding = Finding.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFindingRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      findingId: isSet(object.findingId) ? globalThis.String(object.findingId) : "",
      finding: isSet(object.finding) ? Finding.fromJSON(object.finding) : undefined,
    };
  },

  toJSON(message: CreateFindingRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.findingId !== "") {
      obj.findingId = message.findingId;
    }
    if (message.finding !== undefined) {
      obj.finding = Finding.toJSON(message.finding);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateFindingRequest>): CreateFindingRequest {
    return CreateFindingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateFindingRequest>): CreateFindingRequest {
    const message = createBaseCreateFindingRequest();
    message.parent = object.parent ?? "";
    message.findingId = object.findingId ?? "";
    message.finding = (object.finding !== undefined && object.finding !== null)
      ? Finding.fromPartial(object.finding)
      : undefined;
    return message;
  },
};

function createBaseCreateSourceRequest(): CreateSourceRequest {
  return { parent: "", source: undefined };
}

export const CreateSourceRequest: MessageFns<CreateSourceRequest> = {
  encode(message: CreateSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSourceRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      source: isSet(object.source) ? Source.fromJSON(object.source) : undefined,
    };
  },

  toJSON(message: CreateSourceRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.source !== undefined) {
      obj.source = Source.toJSON(message.source);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSourceRequest>): CreateSourceRequest {
    return CreateSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSourceRequest>): CreateSourceRequest {
    const message = createBaseCreateSourceRequest();
    message.parent = object.parent ?? "";
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    return message;
  },
};

function createBaseGetOrganizationSettingsRequest(): GetOrganizationSettingsRequest {
  return { name: "" };
}

export const GetOrganizationSettingsRequest: MessageFns<GetOrganizationSettingsRequest> = {
  encode(message: GetOrganizationSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrganizationSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationSettingsRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetOrganizationSettingsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOrganizationSettingsRequest>): GetOrganizationSettingsRequest {
    return GetOrganizationSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOrganizationSettingsRequest>): GetOrganizationSettingsRequest {
    const message = createBaseGetOrganizationSettingsRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetSourceRequest(): GetSourceRequest {
  return { name: "" };
}

export const GetSourceRequest: MessageFns<GetSourceRequest> = {
  encode(message: GetSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSourceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSourceRequest>): GetSourceRequest {
    return GetSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSourceRequest>): GetSourceRequest {
    const message = createBaseGetSourceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGroupAssetsRequest(): GroupAssetsRequest {
  return {
    parent: "",
    filter: "",
    groupBy: "",
    compareDuration: undefined,
    readTime: undefined,
    pageToken: "",
    pageSize: 0,
  };
}

export const GroupAssetsRequest: MessageFns<GroupAssetsRequest> = {
  encode(message: GroupAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.groupBy !== "") {
      writer.uint32(26).string(message.groupBy);
    }
    if (message.compareDuration !== undefined) {
      Duration.encode(message.compareDuration, writer.uint32(34).fork()).join();
    }
    if (message.readTime !== undefined) {
      Timestamp.encode(toTimestamp(message.readTime), writer.uint32(42).fork()).join();
    }
    if (message.pageToken !== "") {
      writer.uint32(58).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(64).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.groupBy = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.compareDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.readTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupAssetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      groupBy: isSet(object.groupBy) ? globalThis.String(object.groupBy) : "",
      compareDuration: isSet(object.compareDuration) ? Duration.fromJSON(object.compareDuration) : undefined,
      readTime: isSet(object.readTime) ? fromJsonTimestamp(object.readTime) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: GroupAssetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.groupBy !== "") {
      obj.groupBy = message.groupBy;
    }
    if (message.compareDuration !== undefined) {
      obj.compareDuration = Duration.toJSON(message.compareDuration);
    }
    if (message.readTime !== undefined) {
      obj.readTime = message.readTime.toISOString();
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<GroupAssetsRequest>): GroupAssetsRequest {
    return GroupAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroupAssetsRequest>): GroupAssetsRequest {
    const message = createBaseGroupAssetsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.groupBy = object.groupBy ?? "";
    message.compareDuration = (object.compareDuration !== undefined && object.compareDuration !== null)
      ? Duration.fromPartial(object.compareDuration)
      : undefined;
    message.readTime = object.readTime ?? undefined;
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseGroupAssetsResponse(): GroupAssetsResponse {
  return { groupByResults: [], readTime: undefined, nextPageToken: "" };
}

export const GroupAssetsResponse: MessageFns<GroupAssetsResponse> = {
  encode(message: GroupAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groupByResults) {
      GroupResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.readTime !== undefined) {
      Timestamp.encode(toTimestamp(message.readTime), writer.uint32(18).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.groupByResults.push(GroupResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.readTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupAssetsResponse {
    return {
      groupByResults: globalThis.Array.isArray(object?.groupByResults)
        ? object.groupByResults.map((e: any) => GroupResult.fromJSON(e))
        : [],
      readTime: isSet(object.readTime) ? fromJsonTimestamp(object.readTime) : undefined,
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: GroupAssetsResponse): unknown {
    const obj: any = {};
    if (message.groupByResults?.length) {
      obj.groupByResults = message.groupByResults.map((e) => GroupResult.toJSON(e));
    }
    if (message.readTime !== undefined) {
      obj.readTime = message.readTime.toISOString();
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<GroupAssetsResponse>): GroupAssetsResponse {
    return GroupAssetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroupAssetsResponse>): GroupAssetsResponse {
    const message = createBaseGroupAssetsResponse();
    message.groupByResults = object.groupByResults?.map((e) => GroupResult.fromPartial(e)) || [];
    message.readTime = object.readTime ?? undefined;
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGroupFindingsRequest(): GroupFindingsRequest {
  return { parent: "", filter: "", groupBy: "", readTime: undefined, pageToken: "", pageSize: 0 };
}

export const GroupFindingsRequest: MessageFns<GroupFindingsRequest> = {
  encode(message: GroupFindingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.groupBy !== "") {
      writer.uint32(26).string(message.groupBy);
    }
    if (message.readTime !== undefined) {
      Timestamp.encode(toTimestamp(message.readTime), writer.uint32(34).fork()).join();
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(48).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupFindingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupFindingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.groupBy = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.readTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupFindingsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      groupBy: isSet(object.groupBy) ? globalThis.String(object.groupBy) : "",
      readTime: isSet(object.readTime) ? fromJsonTimestamp(object.readTime) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: GroupFindingsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.groupBy !== "") {
      obj.groupBy = message.groupBy;
    }
    if (message.readTime !== undefined) {
      obj.readTime = message.readTime.toISOString();
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<GroupFindingsRequest>): GroupFindingsRequest {
    return GroupFindingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroupFindingsRequest>): GroupFindingsRequest {
    const message = createBaseGroupFindingsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.groupBy = object.groupBy ?? "";
    message.readTime = object.readTime ?? undefined;
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseGroupFindingsResponse(): GroupFindingsResponse {
  return { groupByResults: [], readTime: undefined, nextPageToken: "" };
}

export const GroupFindingsResponse: MessageFns<GroupFindingsResponse> = {
  encode(message: GroupFindingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groupByResults) {
      GroupResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.readTime !== undefined) {
      Timestamp.encode(toTimestamp(message.readTime), writer.uint32(18).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupFindingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupFindingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.groupByResults.push(GroupResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.readTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupFindingsResponse {
    return {
      groupByResults: globalThis.Array.isArray(object?.groupByResults)
        ? object.groupByResults.map((e: any) => GroupResult.fromJSON(e))
        : [],
      readTime: isSet(object.readTime) ? fromJsonTimestamp(object.readTime) : undefined,
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: GroupFindingsResponse): unknown {
    const obj: any = {};
    if (message.groupByResults?.length) {
      obj.groupByResults = message.groupByResults.map((e) => GroupResult.toJSON(e));
    }
    if (message.readTime !== undefined) {
      obj.readTime = message.readTime.toISOString();
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<GroupFindingsResponse>): GroupFindingsResponse {
    return GroupFindingsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroupFindingsResponse>): GroupFindingsResponse {
    const message = createBaseGroupFindingsResponse();
    message.groupByResults = object.groupByResults?.map((e) => GroupResult.fromPartial(e)) || [];
    message.readTime = object.readTime ?? undefined;
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGroupResult(): GroupResult {
  return { properties: {}, count: Long.ZERO };
}

export const GroupResult: MessageFns<GroupResult> = {
  encode(message: GroupResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.properties).forEach(([key, value]) => {
      if (value !== undefined) {
        GroupResult_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
      }
    });
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.count.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = GroupResult_PropertiesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.properties[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupResult {
    return {
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
    };
  },

  toJSON(message: GroupResult): unknown {
    const obj: any = {};
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = v;
        });
      }
    }
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<GroupResult>): GroupResult {
    return GroupResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroupResult>): GroupResult {
    const message = createBaseGroupResult();
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: any | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    return message;
  },
};

function createBaseGroupResult_PropertiesEntry(): GroupResult_PropertiesEntry {
  return { key: "", value: undefined };
}

export const GroupResult_PropertiesEntry: MessageFns<GroupResult_PropertiesEntry> = {
  encode(message: GroupResult_PropertiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupResult_PropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupResult_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupResult_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: GroupResult_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GroupResult_PropertiesEntry>): GroupResult_PropertiesEntry {
    return GroupResult_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroupResult_PropertiesEntry>): GroupResult_PropertiesEntry {
    const message = createBaseGroupResult_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseListSourcesRequest(): ListSourcesRequest {
  return { parent: "", pageToken: "", pageSize: 0 };
}

export const ListSourcesRequest: MessageFns<ListSourcesRequest> = {
  encode(message: ListSourcesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(56).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSourcesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSourcesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListSourcesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListSourcesRequest>): ListSourcesRequest {
    return ListSourcesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSourcesRequest>): ListSourcesRequest {
    const message = createBaseListSourcesRequest();
    message.parent = object.parent ?? "";
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListSourcesResponse(): ListSourcesResponse {
  return { sources: [], nextPageToken: "" };
}

export const ListSourcesResponse: MessageFns<ListSourcesResponse> = {
  encode(message: ListSourcesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sources) {
      Source.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSourcesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sources.push(Source.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSourcesResponse {
    return {
      sources: globalThis.Array.isArray(object?.sources) ? object.sources.map((e: any) => Source.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSourcesResponse): unknown {
    const obj: any = {};
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => Source.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSourcesResponse>): ListSourcesResponse {
    return ListSourcesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSourcesResponse>): ListSourcesResponse {
    const message = createBaseListSourcesResponse();
    message.sources = object.sources?.map((e) => Source.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListAssetsRequest(): ListAssetsRequest {
  return {
    parent: "",
    filter: "",
    orderBy: "",
    readTime: undefined,
    compareDuration: undefined,
    fieldMask: undefined,
    pageToken: "",
    pageSize: 0,
  };
}

export const ListAssetsRequest: MessageFns<ListAssetsRequest> = {
  encode(message: ListAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(26).string(message.orderBy);
    }
    if (message.readTime !== undefined) {
      Timestamp.encode(toTimestamp(message.readTime), writer.uint32(34).fork()).join();
    }
    if (message.compareDuration !== undefined) {
      Duration.encode(message.compareDuration, writer.uint32(42).fork()).join();
    }
    if (message.fieldMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.fieldMask), writer.uint32(58).fork()).join();
    }
    if (message.pageToken !== "") {
      writer.uint32(66).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(72).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.readTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.compareDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.fieldMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      readTime: isSet(object.readTime) ? fromJsonTimestamp(object.readTime) : undefined,
      compareDuration: isSet(object.compareDuration) ? Duration.fromJSON(object.compareDuration) : undefined,
      fieldMask: isSet(object.fieldMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.fieldMask)) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListAssetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.readTime !== undefined) {
      obj.readTime = message.readTime.toISOString();
    }
    if (message.compareDuration !== undefined) {
      obj.compareDuration = Duration.toJSON(message.compareDuration);
    }
    if (message.fieldMask !== undefined) {
      obj.fieldMask = FieldMask.toJSON(FieldMask.wrap(message.fieldMask));
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListAssetsRequest>): ListAssetsRequest {
    return ListAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAssetsRequest>): ListAssetsRequest {
    const message = createBaseListAssetsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.readTime = object.readTime ?? undefined;
    message.compareDuration = (object.compareDuration !== undefined && object.compareDuration !== null)
      ? Duration.fromPartial(object.compareDuration)
      : undefined;
    message.fieldMask = object.fieldMask ?? undefined;
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListAssetsResponse(): ListAssetsResponse {
  return { listAssetsResults: [], readTime: undefined, nextPageToken: "", totalSize: 0 };
}

export const ListAssetsResponse: MessageFns<ListAssetsResponse> = {
  encode(message: ListAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.listAssetsResults) {
      ListAssetsResponse_ListAssetsResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.readTime !== undefined) {
      Timestamp.encode(toTimestamp(message.readTime), writer.uint32(18).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(32).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.listAssetsResults.push(ListAssetsResponse_ListAssetsResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.readTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsResponse {
    return {
      listAssetsResults: globalThis.Array.isArray(object?.listAssetsResults)
        ? object.listAssetsResults.map((e: any) => ListAssetsResponse_ListAssetsResult.fromJSON(e))
        : [],
      readTime: isSet(object.readTime) ? fromJsonTimestamp(object.readTime) : undefined,
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListAssetsResponse): unknown {
    const obj: any = {};
    if (message.listAssetsResults?.length) {
      obj.listAssetsResults = message.listAssetsResults.map((e) => ListAssetsResponse_ListAssetsResult.toJSON(e));
    }
    if (message.readTime !== undefined) {
      obj.readTime = message.readTime.toISOString();
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListAssetsResponse>): ListAssetsResponse {
    return ListAssetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAssetsResponse>): ListAssetsResponse {
    const message = createBaseListAssetsResponse();
    message.listAssetsResults =
      object.listAssetsResults?.map((e) => ListAssetsResponse_ListAssetsResult.fromPartial(e)) || [];
    message.readTime = object.readTime ?? undefined;
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseListAssetsResponse_ListAssetsResult(): ListAssetsResponse_ListAssetsResult {
  return { asset: undefined, state: 0 };
}

export const ListAssetsResponse_ListAssetsResult: MessageFns<ListAssetsResponse_ListAssetsResult> = {
  encode(message: ListAssetsResponse_ListAssetsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(10).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsResponse_ListAssetsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsResponse_ListAssetsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsResponse_ListAssetsResult {
    return {
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      state: isSet(object.state) ? listAssetsResponse_ListAssetsResult_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: ListAssetsResponse_ListAssetsResult): unknown {
    const obj: any = {};
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.state !== 0) {
      obj.state = listAssetsResponse_ListAssetsResult_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<ListAssetsResponse_ListAssetsResult>): ListAssetsResponse_ListAssetsResult {
    return ListAssetsResponse_ListAssetsResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAssetsResponse_ListAssetsResult>): ListAssetsResponse_ListAssetsResult {
    const message = createBaseListAssetsResponse_ListAssetsResult();
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseListFindingsRequest(): ListFindingsRequest {
  return { parent: "", filter: "", orderBy: "", readTime: undefined, fieldMask: undefined, pageToken: "", pageSize: 0 };
}

export const ListFindingsRequest: MessageFns<ListFindingsRequest> = {
  encode(message: ListFindingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(26).string(message.orderBy);
    }
    if (message.readTime !== undefined) {
      Timestamp.encode(toTimestamp(message.readTime), writer.uint32(34).fork()).join();
    }
    if (message.fieldMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.fieldMask), writer.uint32(42).fork()).join();
    }
    if (message.pageToken !== "") {
      writer.uint32(50).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(56).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFindingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFindingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.readTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.fieldMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFindingsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      readTime: isSet(object.readTime) ? fromJsonTimestamp(object.readTime) : undefined,
      fieldMask: isSet(object.fieldMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.fieldMask)) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListFindingsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.readTime !== undefined) {
      obj.readTime = message.readTime.toISOString();
    }
    if (message.fieldMask !== undefined) {
      obj.fieldMask = FieldMask.toJSON(FieldMask.wrap(message.fieldMask));
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListFindingsRequest>): ListFindingsRequest {
    return ListFindingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFindingsRequest>): ListFindingsRequest {
    const message = createBaseListFindingsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.readTime = object.readTime ?? undefined;
    message.fieldMask = object.fieldMask ?? undefined;
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListFindingsResponse(): ListFindingsResponse {
  return { findings: [], readTime: undefined, nextPageToken: "", totalSize: 0 };
}

export const ListFindingsResponse: MessageFns<ListFindingsResponse> = {
  encode(message: ListFindingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.findings) {
      Finding.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.readTime !== undefined) {
      Timestamp.encode(toTimestamp(message.readTime), writer.uint32(18).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(32).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFindingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFindingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.findings.push(Finding.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.readTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFindingsResponse {
    return {
      findings: globalThis.Array.isArray(object?.findings) ? object.findings.map((e: any) => Finding.fromJSON(e)) : [],
      readTime: isSet(object.readTime) ? fromJsonTimestamp(object.readTime) : undefined,
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListFindingsResponse): unknown {
    const obj: any = {};
    if (message.findings?.length) {
      obj.findings = message.findings.map((e) => Finding.toJSON(e));
    }
    if (message.readTime !== undefined) {
      obj.readTime = message.readTime.toISOString();
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListFindingsResponse>): ListFindingsResponse {
    return ListFindingsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFindingsResponse>): ListFindingsResponse {
    const message = createBaseListFindingsResponse();
    message.findings = object.findings?.map((e) => Finding.fromPartial(e)) || [];
    message.readTime = object.readTime ?? undefined;
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseSetFindingStateRequest(): SetFindingStateRequest {
  return { name: "", state: 0, startTime: undefined };
}

export const SetFindingStateRequest: MessageFns<SetFindingStateRequest> = {
  encode(message: SetFindingStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetFindingStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetFindingStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetFindingStateRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? finding_StateFromJSON(object.state) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
    };
  },

  toJSON(message: SetFindingStateRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = finding_StateToJSON(message.state);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<SetFindingStateRequest>): SetFindingStateRequest {
    return SetFindingStateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetFindingStateRequest>): SetFindingStateRequest {
    const message = createBaseSetFindingStateRequest();
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.startTime = object.startTime ?? undefined;
    return message;
  },
};

function createBaseRunAssetDiscoveryRequest(): RunAssetDiscoveryRequest {
  return { parent: "" };
}

export const RunAssetDiscoveryRequest: MessageFns<RunAssetDiscoveryRequest> = {
  encode(message: RunAssetDiscoveryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunAssetDiscoveryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunAssetDiscoveryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunAssetDiscoveryRequest {
    return { parent: isSet(object.parent) ? globalThis.String(object.parent) : "" };
  },

  toJSON(message: RunAssetDiscoveryRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<RunAssetDiscoveryRequest>): RunAssetDiscoveryRequest {
    return RunAssetDiscoveryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunAssetDiscoveryRequest>): RunAssetDiscoveryRequest {
    const message = createBaseRunAssetDiscoveryRequest();
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseUpdateFindingRequest(): UpdateFindingRequest {
  return { finding: undefined, updateMask: undefined };
}

export const UpdateFindingRequest: MessageFns<UpdateFindingRequest> = {
  encode(message: UpdateFindingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finding !== undefined) {
      Finding.encode(message.finding, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFindingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFindingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.finding = Finding.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFindingRequest {
    return {
      finding: isSet(object.finding) ? Finding.fromJSON(object.finding) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateFindingRequest): unknown {
    const obj: any = {};
    if (message.finding !== undefined) {
      obj.finding = Finding.toJSON(message.finding);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateFindingRequest>): UpdateFindingRequest {
    return UpdateFindingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateFindingRequest>): UpdateFindingRequest {
    const message = createBaseUpdateFindingRequest();
    message.finding = (object.finding !== undefined && object.finding !== null)
      ? Finding.fromPartial(object.finding)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUpdateOrganizationSettingsRequest(): UpdateOrganizationSettingsRequest {
  return { organizationSettings: undefined, updateMask: undefined };
}

export const UpdateOrganizationSettingsRequest: MessageFns<UpdateOrganizationSettingsRequest> = {
  encode(message: UpdateOrganizationSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organizationSettings !== undefined) {
      OrganizationSettings.encode(message.organizationSettings, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOrganizationSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrganizationSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organizationSettings = OrganizationSettings.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOrganizationSettingsRequest {
    return {
      organizationSettings: isSet(object.organizationSettings)
        ? OrganizationSettings.fromJSON(object.organizationSettings)
        : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateOrganizationSettingsRequest): unknown {
    const obj: any = {};
    if (message.organizationSettings !== undefined) {
      obj.organizationSettings = OrganizationSettings.toJSON(message.organizationSettings);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateOrganizationSettingsRequest>): UpdateOrganizationSettingsRequest {
    return UpdateOrganizationSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateOrganizationSettingsRequest>): UpdateOrganizationSettingsRequest {
    const message = createBaseUpdateOrganizationSettingsRequest();
    message.organizationSettings = (object.organizationSettings !== undefined && object.organizationSettings !== null)
      ? OrganizationSettings.fromPartial(object.organizationSettings)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUpdateSourceRequest(): UpdateSourceRequest {
  return { source: undefined, updateMask: undefined };
}

export const UpdateSourceRequest: MessageFns<UpdateSourceRequest> = {
  encode(message: UpdateSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSourceRequest {
    return {
      source: isSet(object.source) ? Source.fromJSON(object.source) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateSourceRequest): unknown {
    const obj: any = {};
    if (message.source !== undefined) {
      obj.source = Source.toJSON(message.source);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSourceRequest>): UpdateSourceRequest {
    return UpdateSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSourceRequest>): UpdateSourceRequest {
    const message = createBaseUpdateSourceRequest();
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUpdateSecurityMarksRequest(): UpdateSecurityMarksRequest {
  return { securityMarks: undefined, updateMask: undefined, startTime: undefined };
}

export const UpdateSecurityMarksRequest: MessageFns<UpdateSecurityMarksRequest> = {
  encode(message: UpdateSecurityMarksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.securityMarks !== undefined) {
      SecurityMarks.encode(message.securityMarks, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSecurityMarksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSecurityMarksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.securityMarks = SecurityMarks.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSecurityMarksRequest {
    return {
      securityMarks: isSet(object.securityMarks) ? SecurityMarks.fromJSON(object.securityMarks) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
    };
  },

  toJSON(message: UpdateSecurityMarksRequest): unknown {
    const obj: any = {};
    if (message.securityMarks !== undefined) {
      obj.securityMarks = SecurityMarks.toJSON(message.securityMarks);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSecurityMarksRequest>): UpdateSecurityMarksRequest {
    return UpdateSecurityMarksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSecurityMarksRequest>): UpdateSecurityMarksRequest {
    const message = createBaseUpdateSecurityMarksRequest();
    message.securityMarks = (object.securityMarks !== undefined && object.securityMarks !== null)
      ? SecurityMarks.fromPartial(object.securityMarks)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.startTime = object.startTime ?? undefined;
    return message;
  },
};

/** V1 Beta APIs for Security Center service. */
export type SecurityCenterDefinition = typeof SecurityCenterDefinition;
export const SecurityCenterDefinition = {
  name: "SecurityCenter",
  fullName: "google.cloud.securitycenter.v1beta1.SecurityCenter",
  methods: {
    /** Creates a source. */
    createSource: {
      name: "CreateSource",
      requestType: CreateSourceRequest,
      requestStream: false,
      responseType: Source,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([13, 112, 97, 114, 101, 110, 116, 44, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              51,
              58,
              6,
              115,
              111,
              117,
              114,
              99,
              101,
              34,
              41,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a finding. The corresponding source must exist for finding creation
     * to succeed.
     */
    createFinding: {
      name: "CreateFinding",
      requestType: CreateFindingRequest,
      requestStream: false,
      responseType: Finding,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              25,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              102,
              105,
              110,
              100,
              105,
              110,
              103,
              95,
              105,
              100,
              44,
              102,
              105,
              110,
              100,
              105,
              110,
              103,
            ]),
          ],
          578365826: [
            Buffer.from([
              63,
              58,
              7,
              102,
              105,
              110,
              100,
              105,
              110,
              103,
              34,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              102,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the access control policy on the specified Source. */
    getIamPolicy: {
      name: "GetIamPolicy",
      requestType: GetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([8, 114, 101, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              63,
              58,
              1,
              42,
              34,
              58,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /** Gets the settings for an organization. */
    getOrganizationSettings: {
      name: "GetOrganizationSettings",
      requestType: GetOrganizationSettingsRequest,
      requestStream: false,
      responseType: OrganizationSettings,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets a source. */
    getSource: {
      name: "GetSource",
      requestType: GetSourceRequest,
      requestStream: false,
      responseType: Source,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              43,
              18,
              41,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Filters an organization's assets and  groups them by their specified
     * properties.
     */
    groupAssets: {
      name: "GroupAssets",
      requestType: GroupAssetsRequest,
      requestStream: false,
      responseType: GroupAssetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              51,
              58,
              1,
              42,
              34,
              46,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              58,
              103,
              114,
              111,
              117,
              112,
            ]),
          ],
        },
      },
    },
    /**
     * Filters an organization or source's findings and  groups them by their
     * specified properties.
     *
     * To group across all sources provide a `-` as the source id.
     * Example: /v1beta1/organizations/{organization_id}/sources/-/findings
     */
    groupFindings: {
      name: "GroupFindings",
      requestType: GroupFindingsRequest,
      requestStream: false,
      responseType: GroupFindingsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 112, 97, 114, 101, 110, 116, 44, 103, 114, 111, 117, 112, 95, 98, 121])],
          578365826: [
            Buffer.from([
              63,
              58,
              1,
              42,
              34,
              58,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              102,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
              58,
              103,
              114,
              111,
              117,
              112,
            ]),
          ],
        },
      },
    },
    /** Lists an organization's assets. */
    listAssets: {
      name: "ListAssets",
      requestType: ListAssetsRequest,
      requestStream: false,
      responseType: ListAssetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              42,
              18,
              40,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists an organization or source's findings.
     *
     * To list across all sources provide a `-` as the source id.
     * Example: /v1beta1/organizations/{organization_id}/sources/-/findings
     */
    listFindings: {
      name: "ListFindings",
      requestType: ListFindingsRequest,
      requestStream: false,
      responseType: ListFindingsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              102,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists all sources belonging to an organization. */
    listSources: {
      name: "ListSources",
      requestType: ListSourcesRequest,
      requestStream: false,
      responseType: ListSourcesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              43,
              18,
              41,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Runs asset discovery. The discovery is tracked with a long-running
     * operation.
     *
     * This API can only be called with limited frequency for an organization. If
     * it is called too frequently the caller will receive a TOO_MANY_REQUESTS
     * error.
     */
    runAssetDiscovery: {
      name: "RunAssetDiscovery",
      requestType: RunAssetDiscoveryRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              46,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
            ]),
          ],
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              58,
              58,
              1,
              42,
              34,
              53,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              58,
              114,
              117,
              110,
              68,
              105,
              115,
              99,
              111,
              118,
              101,
              114,
              121,
            ]),
          ],
        },
      },
    },
    /** Updates the state of a finding. */
    setFindingState: {
      name: "SetFindingState",
      requestType: SetFindingStateRequest,
      requestStream: false,
      responseType: Finding,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              110,
              97,
              109,
              101,
              44,
              115,
              116,
              97,
              116,
              101,
              44,
              115,
              116,
              97,
              114,
              116,
              95,
              116,
              105,
              109,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              102,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              83,
              116,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Sets the access control policy on the specified Source. */
    setIamPolicy: {
      name: "SetIamPolicy",
      requestType: SetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 114, 101, 115, 111, 117, 114, 99, 101, 44, 112, 111, 108, 105, 99, 121])],
          578365826: [
            Buffer.from([
              63,
              58,
              1,
              42,
              34,
              58,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /** Returns the permissions that a caller has on the specified source. */
    testIamPermissions: {
      name: "TestIamPermissions",
      requestType: TestIamPermissionsRequest,
      requestStream: false,
      responseType: TestIamPermissionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              112,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              116,
              101,
              115,
              116,
              73,
              97,
              109,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Creates or updates a finding. The corresponding source must exist for a
     * finding creation to succeed.
     */
    updateFinding: {
      name: "UpdateFinding",
      requestType: UpdateFindingRequest,
      requestStream: false,
      responseType: Finding,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([7, 102, 105, 110, 100, 105, 110, 103])],
          578365826: [
            Buffer.from([
              71,
              58,
              7,
              102,
              105,
              110,
              100,
              105,
              110,
              103,
              50,
              60,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              102,
              105,
              110,
              100,
              105,
              110,
              103,
              46,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              102,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates an organization's settings. */
    updateOrganizationSettings: {
      name: "UpdateOrganizationSettings",
      requestType: UpdateOrganizationSettingsRequest,
      requestStream: false,
      responseType: OrganizationSettings,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              99,
              58,
              21,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              50,
              74,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates a source. */
    updateSource: {
      name: "UpdateSource",
      requestType: UpdateSourceRequest,
      requestStream: false,
      responseType: Source,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              58,
              58,
              6,
              115,
              111,
              117,
              114,
              99,
              101,
              50,
              48,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              115,
              111,
              117,
              114,
              99,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates security marks. */
    updateSecurityMarks: {
      name: "UpdateSecurityMarks",
      requestType: UpdateSecurityMarksRequest,
      requestStream: false,
      responseType: SecurityMarks,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([14, 115, 101, 99, 117, 114, 105, 116, 121, 95, 109, 97, 114, 107, 115])],
          578365826: [
            Buffer.from([
              188,
              1,
              58,
              14,
              115,
              101,
              99,
              117,
              114,
              105,
              116,
              121,
              95,
              109,
              97,
              114,
              107,
              115,
              90,
              99,
              58,
              14,
              115,
              101,
              99,
              117,
              114,
              105,
              116,
              121,
              95,
              109,
              97,
              114,
              107,
              115,
              50,
              81,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              115,
              101,
              99,
              117,
              114,
              105,
              116,
              121,
              95,
              109,
              97,
              114,
              107,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              102,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
              47,
              42,
              47,
              115,
              101,
              99,
              117,
              114,
              105,
              116,
              121,
              77,
              97,
              114,
              107,
              115,
              125,
              50,
              69,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              115,
              101,
              99,
              117,
              114,
              105,
              116,
              121,
              95,
              109,
              97,
              114,
              107,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              99,
              117,
              114,
              105,
              116,
              121,
              77,
              97,
              114,
              107,
              115,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface SecurityCenterServiceImplementation<CallContextExt = {}> {
  /** Creates a source. */
  createSource(request: CreateSourceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Source>>;
  /**
   * Creates a finding. The corresponding source must exist for finding creation
   * to succeed.
   */
  createFinding(request: CreateFindingRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Finding>>;
  /** Gets the access control policy on the specified Source. */
  getIamPolicy(request: GetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /** Gets the settings for an organization. */
  getOrganizationSettings(
    request: GetOrganizationSettingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<OrganizationSettings>>;
  /** Gets a source. */
  getSource(request: GetSourceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Source>>;
  /**
   * Filters an organization's assets and  groups them by their specified
   * properties.
   */
  groupAssets(
    request: GroupAssetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GroupAssetsResponse>>;
  /**
   * Filters an organization or source's findings and  groups them by their
   * specified properties.
   *
   * To group across all sources provide a `-` as the source id.
   * Example: /v1beta1/organizations/{organization_id}/sources/-/findings
   */
  groupFindings(
    request: GroupFindingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GroupFindingsResponse>>;
  /** Lists an organization's assets. */
  listAssets(
    request: ListAssetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAssetsResponse>>;
  /**
   * Lists an organization or source's findings.
   *
   * To list across all sources provide a `-` as the source id.
   * Example: /v1beta1/organizations/{organization_id}/sources/-/findings
   */
  listFindings(
    request: ListFindingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListFindingsResponse>>;
  /** Lists all sources belonging to an organization. */
  listSources(
    request: ListSourcesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSourcesResponse>>;
  /**
   * Runs asset discovery. The discovery is tracked with a long-running
   * operation.
   *
   * This API can only be called with limited frequency for an organization. If
   * it is called too frequently the caller will receive a TOO_MANY_REQUESTS
   * error.
   */
  runAssetDiscovery(
    request: RunAssetDiscoveryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates the state of a finding. */
  setFindingState(
    request: SetFindingStateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Finding>>;
  /** Sets the access control policy on the specified Source. */
  setIamPolicy(request: SetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /** Returns the permissions that a caller has on the specified source. */
  testIamPermissions(
    request: TestIamPermissionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestIamPermissionsResponse>>;
  /**
   * Creates or updates a finding. The corresponding source must exist for a
   * finding creation to succeed.
   */
  updateFinding(request: UpdateFindingRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Finding>>;
  /** Updates an organization's settings. */
  updateOrganizationSettings(
    request: UpdateOrganizationSettingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<OrganizationSettings>>;
  /** Updates a source. */
  updateSource(request: UpdateSourceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Source>>;
  /** Updates security marks. */
  updateSecurityMarks(
    request: UpdateSecurityMarksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SecurityMarks>>;
}

export interface SecurityCenterClient<CallOptionsExt = {}> {
  /** Creates a source. */
  createSource(request: DeepPartial<CreateSourceRequest>, options?: CallOptions & CallOptionsExt): Promise<Source>;
  /**
   * Creates a finding. The corresponding source must exist for finding creation
   * to succeed.
   */
  createFinding(request: DeepPartial<CreateFindingRequest>, options?: CallOptions & CallOptionsExt): Promise<Finding>;
  /** Gets the access control policy on the specified Source. */
  getIamPolicy(request: DeepPartial<GetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /** Gets the settings for an organization. */
  getOrganizationSettings(
    request: DeepPartial<GetOrganizationSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<OrganizationSettings>;
  /** Gets a source. */
  getSource(request: DeepPartial<GetSourceRequest>, options?: CallOptions & CallOptionsExt): Promise<Source>;
  /**
   * Filters an organization's assets and  groups them by their specified
   * properties.
   */
  groupAssets(
    request: DeepPartial<GroupAssetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GroupAssetsResponse>;
  /**
   * Filters an organization or source's findings and  groups them by their
   * specified properties.
   *
   * To group across all sources provide a `-` as the source id.
   * Example: /v1beta1/organizations/{organization_id}/sources/-/findings
   */
  groupFindings(
    request: DeepPartial<GroupFindingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GroupFindingsResponse>;
  /** Lists an organization's assets. */
  listAssets(
    request: DeepPartial<ListAssetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAssetsResponse>;
  /**
   * Lists an organization or source's findings.
   *
   * To list across all sources provide a `-` as the source id.
   * Example: /v1beta1/organizations/{organization_id}/sources/-/findings
   */
  listFindings(
    request: DeepPartial<ListFindingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListFindingsResponse>;
  /** Lists all sources belonging to an organization. */
  listSources(
    request: DeepPartial<ListSourcesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSourcesResponse>;
  /**
   * Runs asset discovery. The discovery is tracked with a long-running
   * operation.
   *
   * This API can only be called with limited frequency for an organization. If
   * it is called too frequently the caller will receive a TOO_MANY_REQUESTS
   * error.
   */
  runAssetDiscovery(
    request: DeepPartial<RunAssetDiscoveryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates the state of a finding. */
  setFindingState(
    request: DeepPartial<SetFindingStateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Finding>;
  /** Sets the access control policy on the specified Source. */
  setIamPolicy(request: DeepPartial<SetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /** Returns the permissions that a caller has on the specified source. */
  testIamPermissions(
    request: DeepPartial<TestIamPermissionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestIamPermissionsResponse>;
  /**
   * Creates or updates a finding. The corresponding source must exist for a
   * finding creation to succeed.
   */
  updateFinding(request: DeepPartial<UpdateFindingRequest>, options?: CallOptions & CallOptionsExt): Promise<Finding>;
  /** Updates an organization's settings. */
  updateOrganizationSettings(
    request: DeepPartial<UpdateOrganizationSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<OrganizationSettings>;
  /** Updates a source. */
  updateSource(request: DeepPartial<UpdateSourceRequest>, options?: CallOptions & CallOptionsExt): Promise<Source>;
  /** Updates security marks. */
  updateSecurityMarks(
    request: DeepPartial<UpdateSecurityMarksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SecurityMarks>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
