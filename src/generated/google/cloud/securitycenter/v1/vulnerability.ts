// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/securitycenter/v1/vulnerability.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.securitycenter.v1";

/** Refers to common vulnerability fields e.g. cve, cvss, cwe etc. */
export interface Vulnerability {
  /**
   * CVE stands for Common Vulnerabilities and Exposures
   * (https://cve.mitre.org/about/)
   */
  cve:
    | Cve
    | undefined;
  /** The offending package is relevant to the finding. */
  offendingPackage:
    | Package
    | undefined;
  /** The fixed package is relevant to the finding. */
  fixedPackage:
    | Package
    | undefined;
  /** The security bulletin is relevant to this finding. */
  securityBulletin: SecurityBulletin | undefined;
}

/**
 * CVE stands for Common Vulnerabilities and Exposures.
 * Information from the [CVE
 * record](https://www.cve.org/ResourcesSupport/Glossary) that describes this
 * vulnerability.
 */
export interface Cve {
  /** The unique identifier for the vulnerability. e.g. CVE-2021-34527 */
  id: string;
  /**
   * Additional information about the CVE.
   * e.g. https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-34527
   */
  references: Reference[];
  /**
   * Describe Common Vulnerability Scoring System specified at
   * https://www.first.org/cvss/v3.1/specification-document
   */
  cvssv3:
    | Cvssv3
    | undefined;
  /** Whether upstream fix is available for the CVE. */
  upstreamFixAvailable: boolean;
  /** The potential impact of the vulnerability if it was to be exploited. */
  impact: Cve_RiskRating;
  /** The exploitation activity of the vulnerability in the wild. */
  exploitationActivity: Cve_ExploitationActivity;
  /** Whether or not the vulnerability has been observed in the wild. */
  observedInTheWild: boolean;
  /**
   * Whether or not the vulnerability was zero day when the finding was
   * published.
   */
  zeroDay: boolean;
  /** Date the first publicly available exploit or PoC was released. */
  exploitReleaseDate: Date | undefined;
}

/**
 * The possible values of impact of the vulnerability if it was to be
 * exploited.
 */
export enum Cve_RiskRating {
  /** RISK_RATING_UNSPECIFIED - Invalid or empty value. */
  RISK_RATING_UNSPECIFIED = 0,
  /** LOW - Exploitation would have little to no security impact. */
  LOW = 1,
  /**
   * MEDIUM - Exploitation would enable attackers to perform activities, or could allow
   * attackers to have a direct impact, but would require additional steps.
   */
  MEDIUM = 2,
  /**
   * HIGH - Exploitation would enable attackers to have a notable direct impact
   * without needing to overcome any major mitigating factors.
   */
  HIGH = 3,
  /**
   * CRITICAL - Exploitation would fundamentally undermine the security of affected
   * systems, enable actors to perform significant attacks with minimal
   * effort, with little to no mitigating factors to overcome.
   */
  CRITICAL = 4,
  UNRECOGNIZED = -1,
}

export function cve_RiskRatingFromJSON(object: any): Cve_RiskRating {
  switch (object) {
    case 0:
    case "RISK_RATING_UNSPECIFIED":
      return Cve_RiskRating.RISK_RATING_UNSPECIFIED;
    case 1:
    case "LOW":
      return Cve_RiskRating.LOW;
    case 2:
    case "MEDIUM":
      return Cve_RiskRating.MEDIUM;
    case 3:
    case "HIGH":
      return Cve_RiskRating.HIGH;
    case 4:
    case "CRITICAL":
      return Cve_RiskRating.CRITICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cve_RiskRating.UNRECOGNIZED;
  }
}

export function cve_RiskRatingToJSON(object: Cve_RiskRating): string {
  switch (object) {
    case Cve_RiskRating.RISK_RATING_UNSPECIFIED:
      return "RISK_RATING_UNSPECIFIED";
    case Cve_RiskRating.LOW:
      return "LOW";
    case Cve_RiskRating.MEDIUM:
      return "MEDIUM";
    case Cve_RiskRating.HIGH:
      return "HIGH";
    case Cve_RiskRating.CRITICAL:
      return "CRITICAL";
    case Cve_RiskRating.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The possible values of exploitation activity of the vulnerability in the
 * wild.
 */
export enum Cve_ExploitationActivity {
  /** EXPLOITATION_ACTIVITY_UNSPECIFIED - Invalid or empty value. */
  EXPLOITATION_ACTIVITY_UNSPECIFIED = 0,
  /** WIDE - Exploitation has been reported or confirmed to widely occur. */
  WIDE = 1,
  /** CONFIRMED - Limited reported or confirmed exploitation activities. */
  CONFIRMED = 2,
  /** AVAILABLE - Exploit is publicly available. */
  AVAILABLE = 3,
  /**
   * ANTICIPATED - No known exploitation activity, but has a high potential for
   * exploitation.
   */
  ANTICIPATED = 4,
  /** NO_KNOWN - No known exploitation activity. */
  NO_KNOWN = 5,
  UNRECOGNIZED = -1,
}

export function cve_ExploitationActivityFromJSON(object: any): Cve_ExploitationActivity {
  switch (object) {
    case 0:
    case "EXPLOITATION_ACTIVITY_UNSPECIFIED":
      return Cve_ExploitationActivity.EXPLOITATION_ACTIVITY_UNSPECIFIED;
    case 1:
    case "WIDE":
      return Cve_ExploitationActivity.WIDE;
    case 2:
    case "CONFIRMED":
      return Cve_ExploitationActivity.CONFIRMED;
    case 3:
    case "AVAILABLE":
      return Cve_ExploitationActivity.AVAILABLE;
    case 4:
    case "ANTICIPATED":
      return Cve_ExploitationActivity.ANTICIPATED;
    case 5:
    case "NO_KNOWN":
      return Cve_ExploitationActivity.NO_KNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cve_ExploitationActivity.UNRECOGNIZED;
  }
}

export function cve_ExploitationActivityToJSON(object: Cve_ExploitationActivity): string {
  switch (object) {
    case Cve_ExploitationActivity.EXPLOITATION_ACTIVITY_UNSPECIFIED:
      return "EXPLOITATION_ACTIVITY_UNSPECIFIED";
    case Cve_ExploitationActivity.WIDE:
      return "WIDE";
    case Cve_ExploitationActivity.CONFIRMED:
      return "CONFIRMED";
    case Cve_ExploitationActivity.AVAILABLE:
      return "AVAILABLE";
    case Cve_ExploitationActivity.ANTICIPATED:
      return "ANTICIPATED";
    case Cve_ExploitationActivity.NO_KNOWN:
      return "NO_KNOWN";
    case Cve_ExploitationActivity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Additional Links */
export interface Reference {
  /** Source of the reference e.g. NVD */
  source: string;
  /**
   * Uri for the mentioned source e.g.
   * https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-34527.
   */
  uri: string;
}

/** Common Vulnerability Scoring System version 3. */
export interface Cvssv3 {
  /** The base score is a function of the base metric scores. */
  baseScore: number;
  /**
   * Base Metrics
   * Represents the intrinsic characteristics of a vulnerability that are
   * constant over time and across user environments.
   * This metric reflects the context by which vulnerability exploitation is
   * possible.
   */
  attackVector: Cvssv3_AttackVector;
  /**
   * This metric describes the conditions beyond the attacker's control that
   * must exist in order to exploit the vulnerability.
   */
  attackComplexity: Cvssv3_AttackComplexity;
  /**
   * This metric describes the level of privileges an attacker must possess
   * before successfully exploiting the vulnerability.
   */
  privilegesRequired: Cvssv3_PrivilegesRequired;
  /**
   * This metric captures the requirement for a human user, other than the
   * attacker, to participate in the successful compromise of the vulnerable
   * component.
   */
  userInteraction: Cvssv3_UserInteraction;
  /**
   * The Scope metric captures whether a vulnerability in one vulnerable
   * component impacts resources in components beyond its security scope.
   */
  scope: Cvssv3_Scope;
  /**
   * This metric measures the impact to the confidentiality of the information
   * resources managed by a software component due to a successfully exploited
   * vulnerability.
   */
  confidentialityImpact: Cvssv3_Impact;
  /**
   * This metric measures the impact to integrity of a successfully exploited
   * vulnerability.
   */
  integrityImpact: Cvssv3_Impact;
  /**
   * This metric measures the impact to the availability of the impacted
   * component resulting from a successfully exploited vulnerability.
   */
  availabilityImpact: Cvssv3_Impact;
}

/**
 * This metric reflects the context by which vulnerability exploitation is
 * possible.
 */
export enum Cvssv3_AttackVector {
  /** ATTACK_VECTOR_UNSPECIFIED - Invalid value. */
  ATTACK_VECTOR_UNSPECIFIED = 0,
  /**
   * ATTACK_VECTOR_NETWORK - The vulnerable component is bound to the network stack and the set of
   * possible attackers extends beyond the other options listed below, up to
   * and including the entire Internet.
   */
  ATTACK_VECTOR_NETWORK = 1,
  /**
   * ATTACK_VECTOR_ADJACENT - The vulnerable component is bound to the network stack, but the attack is
   * limited at the protocol level to a logically adjacent topology.
   */
  ATTACK_VECTOR_ADJACENT = 2,
  /**
   * ATTACK_VECTOR_LOCAL - The vulnerable component is not bound to the network stack and the
   * attacker's path is via read/write/execute capabilities.
   */
  ATTACK_VECTOR_LOCAL = 3,
  /**
   * ATTACK_VECTOR_PHYSICAL - The attack requires the attacker to physically touch or manipulate the
   * vulnerable component.
   */
  ATTACK_VECTOR_PHYSICAL = 4,
  UNRECOGNIZED = -1,
}

export function cvssv3_AttackVectorFromJSON(object: any): Cvssv3_AttackVector {
  switch (object) {
    case 0:
    case "ATTACK_VECTOR_UNSPECIFIED":
      return Cvssv3_AttackVector.ATTACK_VECTOR_UNSPECIFIED;
    case 1:
    case "ATTACK_VECTOR_NETWORK":
      return Cvssv3_AttackVector.ATTACK_VECTOR_NETWORK;
    case 2:
    case "ATTACK_VECTOR_ADJACENT":
      return Cvssv3_AttackVector.ATTACK_VECTOR_ADJACENT;
    case 3:
    case "ATTACK_VECTOR_LOCAL":
      return Cvssv3_AttackVector.ATTACK_VECTOR_LOCAL;
    case 4:
    case "ATTACK_VECTOR_PHYSICAL":
      return Cvssv3_AttackVector.ATTACK_VECTOR_PHYSICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cvssv3_AttackVector.UNRECOGNIZED;
  }
}

export function cvssv3_AttackVectorToJSON(object: Cvssv3_AttackVector): string {
  switch (object) {
    case Cvssv3_AttackVector.ATTACK_VECTOR_UNSPECIFIED:
      return "ATTACK_VECTOR_UNSPECIFIED";
    case Cvssv3_AttackVector.ATTACK_VECTOR_NETWORK:
      return "ATTACK_VECTOR_NETWORK";
    case Cvssv3_AttackVector.ATTACK_VECTOR_ADJACENT:
      return "ATTACK_VECTOR_ADJACENT";
    case Cvssv3_AttackVector.ATTACK_VECTOR_LOCAL:
      return "ATTACK_VECTOR_LOCAL";
    case Cvssv3_AttackVector.ATTACK_VECTOR_PHYSICAL:
      return "ATTACK_VECTOR_PHYSICAL";
    case Cvssv3_AttackVector.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * This metric describes the conditions beyond the attacker's control that
 * must exist in order to exploit the vulnerability.
 */
export enum Cvssv3_AttackComplexity {
  /** ATTACK_COMPLEXITY_UNSPECIFIED - Invalid value. */
  ATTACK_COMPLEXITY_UNSPECIFIED = 0,
  /**
   * ATTACK_COMPLEXITY_LOW - Specialized access conditions or extenuating circumstances do not exist.
   * An attacker can expect repeatable success when attacking the vulnerable
   * component.
   */
  ATTACK_COMPLEXITY_LOW = 1,
  /**
   * ATTACK_COMPLEXITY_HIGH - A successful attack depends on conditions beyond the attacker's control.
   * That is, a successful attack cannot be accomplished at will, but requires
   * the attacker to invest in some measurable amount of effort in preparation
   * or execution against the vulnerable component before a successful attack
   * can be expected.
   */
  ATTACK_COMPLEXITY_HIGH = 2,
  UNRECOGNIZED = -1,
}

export function cvssv3_AttackComplexityFromJSON(object: any): Cvssv3_AttackComplexity {
  switch (object) {
    case 0:
    case "ATTACK_COMPLEXITY_UNSPECIFIED":
      return Cvssv3_AttackComplexity.ATTACK_COMPLEXITY_UNSPECIFIED;
    case 1:
    case "ATTACK_COMPLEXITY_LOW":
      return Cvssv3_AttackComplexity.ATTACK_COMPLEXITY_LOW;
    case 2:
    case "ATTACK_COMPLEXITY_HIGH":
      return Cvssv3_AttackComplexity.ATTACK_COMPLEXITY_HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cvssv3_AttackComplexity.UNRECOGNIZED;
  }
}

export function cvssv3_AttackComplexityToJSON(object: Cvssv3_AttackComplexity): string {
  switch (object) {
    case Cvssv3_AttackComplexity.ATTACK_COMPLEXITY_UNSPECIFIED:
      return "ATTACK_COMPLEXITY_UNSPECIFIED";
    case Cvssv3_AttackComplexity.ATTACK_COMPLEXITY_LOW:
      return "ATTACK_COMPLEXITY_LOW";
    case Cvssv3_AttackComplexity.ATTACK_COMPLEXITY_HIGH:
      return "ATTACK_COMPLEXITY_HIGH";
    case Cvssv3_AttackComplexity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * This metric describes the level of privileges an attacker must possess
 * before successfully exploiting the vulnerability.
 */
export enum Cvssv3_PrivilegesRequired {
  /** PRIVILEGES_REQUIRED_UNSPECIFIED - Invalid value. */
  PRIVILEGES_REQUIRED_UNSPECIFIED = 0,
  /**
   * PRIVILEGES_REQUIRED_NONE - The attacker is unauthorized prior to attack, and therefore does not
   * require any access to settings or files of the vulnerable system to
   * carry out an attack.
   */
  PRIVILEGES_REQUIRED_NONE = 1,
  /**
   * PRIVILEGES_REQUIRED_LOW - The attacker requires privileges that provide basic user capabilities
   * that could normally affect only settings and files owned by a user.
   * Alternatively, an attacker with Low privileges has the ability to access
   * only non-sensitive resources.
   */
  PRIVILEGES_REQUIRED_LOW = 2,
  /**
   * PRIVILEGES_REQUIRED_HIGH - The attacker requires privileges that provide significant (e.g.,
   * administrative) control over the vulnerable component allowing access to
   * component-wide settings and files.
   */
  PRIVILEGES_REQUIRED_HIGH = 3,
  UNRECOGNIZED = -1,
}

export function cvssv3_PrivilegesRequiredFromJSON(object: any): Cvssv3_PrivilegesRequired {
  switch (object) {
    case 0:
    case "PRIVILEGES_REQUIRED_UNSPECIFIED":
      return Cvssv3_PrivilegesRequired.PRIVILEGES_REQUIRED_UNSPECIFIED;
    case 1:
    case "PRIVILEGES_REQUIRED_NONE":
      return Cvssv3_PrivilegesRequired.PRIVILEGES_REQUIRED_NONE;
    case 2:
    case "PRIVILEGES_REQUIRED_LOW":
      return Cvssv3_PrivilegesRequired.PRIVILEGES_REQUIRED_LOW;
    case 3:
    case "PRIVILEGES_REQUIRED_HIGH":
      return Cvssv3_PrivilegesRequired.PRIVILEGES_REQUIRED_HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cvssv3_PrivilegesRequired.UNRECOGNIZED;
  }
}

export function cvssv3_PrivilegesRequiredToJSON(object: Cvssv3_PrivilegesRequired): string {
  switch (object) {
    case Cvssv3_PrivilegesRequired.PRIVILEGES_REQUIRED_UNSPECIFIED:
      return "PRIVILEGES_REQUIRED_UNSPECIFIED";
    case Cvssv3_PrivilegesRequired.PRIVILEGES_REQUIRED_NONE:
      return "PRIVILEGES_REQUIRED_NONE";
    case Cvssv3_PrivilegesRequired.PRIVILEGES_REQUIRED_LOW:
      return "PRIVILEGES_REQUIRED_LOW";
    case Cvssv3_PrivilegesRequired.PRIVILEGES_REQUIRED_HIGH:
      return "PRIVILEGES_REQUIRED_HIGH";
    case Cvssv3_PrivilegesRequired.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * This metric captures the requirement for a human user, other than the
 * attacker, to participate in the successful compromise of the vulnerable
 * component.
 */
export enum Cvssv3_UserInteraction {
  /** USER_INTERACTION_UNSPECIFIED - Invalid value. */
  USER_INTERACTION_UNSPECIFIED = 0,
  /** USER_INTERACTION_NONE - The vulnerable system can be exploited without interaction from any user. */
  USER_INTERACTION_NONE = 1,
  /**
   * USER_INTERACTION_REQUIRED - Successful exploitation of this vulnerability requires a user to take
   * some action before the vulnerability can be exploited.
   */
  USER_INTERACTION_REQUIRED = 2,
  UNRECOGNIZED = -1,
}

export function cvssv3_UserInteractionFromJSON(object: any): Cvssv3_UserInteraction {
  switch (object) {
    case 0:
    case "USER_INTERACTION_UNSPECIFIED":
      return Cvssv3_UserInteraction.USER_INTERACTION_UNSPECIFIED;
    case 1:
    case "USER_INTERACTION_NONE":
      return Cvssv3_UserInteraction.USER_INTERACTION_NONE;
    case 2:
    case "USER_INTERACTION_REQUIRED":
      return Cvssv3_UserInteraction.USER_INTERACTION_REQUIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cvssv3_UserInteraction.UNRECOGNIZED;
  }
}

export function cvssv3_UserInteractionToJSON(object: Cvssv3_UserInteraction): string {
  switch (object) {
    case Cvssv3_UserInteraction.USER_INTERACTION_UNSPECIFIED:
      return "USER_INTERACTION_UNSPECIFIED";
    case Cvssv3_UserInteraction.USER_INTERACTION_NONE:
      return "USER_INTERACTION_NONE";
    case Cvssv3_UserInteraction.USER_INTERACTION_REQUIRED:
      return "USER_INTERACTION_REQUIRED";
    case Cvssv3_UserInteraction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The Scope metric captures whether a vulnerability in one vulnerable
 * component impacts resources in components beyond its security scope.
 */
export enum Cvssv3_Scope {
  /** SCOPE_UNSPECIFIED - Invalid value. */
  SCOPE_UNSPECIFIED = 0,
  /**
   * SCOPE_UNCHANGED - An exploited vulnerability can only affect resources managed by the same
   * security authority.
   */
  SCOPE_UNCHANGED = 1,
  /**
   * SCOPE_CHANGED - An exploited vulnerability can affect resources beyond the security scope
   * managed by the security authority of the vulnerable component.
   */
  SCOPE_CHANGED = 2,
  UNRECOGNIZED = -1,
}

export function cvssv3_ScopeFromJSON(object: any): Cvssv3_Scope {
  switch (object) {
    case 0:
    case "SCOPE_UNSPECIFIED":
      return Cvssv3_Scope.SCOPE_UNSPECIFIED;
    case 1:
    case "SCOPE_UNCHANGED":
      return Cvssv3_Scope.SCOPE_UNCHANGED;
    case 2:
    case "SCOPE_CHANGED":
      return Cvssv3_Scope.SCOPE_CHANGED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cvssv3_Scope.UNRECOGNIZED;
  }
}

export function cvssv3_ScopeToJSON(object: Cvssv3_Scope): string {
  switch (object) {
    case Cvssv3_Scope.SCOPE_UNSPECIFIED:
      return "SCOPE_UNSPECIFIED";
    case Cvssv3_Scope.SCOPE_UNCHANGED:
      return "SCOPE_UNCHANGED";
    case Cvssv3_Scope.SCOPE_CHANGED:
      return "SCOPE_CHANGED";
    case Cvssv3_Scope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The Impact metrics capture the effects of a successfully exploited
 * vulnerability on the component that suffers the worst outcome that is most
 * directly and predictably associated with the attack.
 */
export enum Cvssv3_Impact {
  /** IMPACT_UNSPECIFIED - Invalid value. */
  IMPACT_UNSPECIFIED = 0,
  /** IMPACT_HIGH - High impact. */
  IMPACT_HIGH = 1,
  /** IMPACT_LOW - Low impact. */
  IMPACT_LOW = 2,
  /** IMPACT_NONE - No impact. */
  IMPACT_NONE = 3,
  UNRECOGNIZED = -1,
}

export function cvssv3_ImpactFromJSON(object: any): Cvssv3_Impact {
  switch (object) {
    case 0:
    case "IMPACT_UNSPECIFIED":
      return Cvssv3_Impact.IMPACT_UNSPECIFIED;
    case 1:
    case "IMPACT_HIGH":
      return Cvssv3_Impact.IMPACT_HIGH;
    case 2:
    case "IMPACT_LOW":
      return Cvssv3_Impact.IMPACT_LOW;
    case 3:
    case "IMPACT_NONE":
      return Cvssv3_Impact.IMPACT_NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cvssv3_Impact.UNRECOGNIZED;
  }
}

export function cvssv3_ImpactToJSON(object: Cvssv3_Impact): string {
  switch (object) {
    case Cvssv3_Impact.IMPACT_UNSPECIFIED:
      return "IMPACT_UNSPECIFIED";
    case Cvssv3_Impact.IMPACT_HIGH:
      return "IMPACT_HIGH";
    case Cvssv3_Impact.IMPACT_LOW:
      return "IMPACT_LOW";
    case Cvssv3_Impact.IMPACT_NONE:
      return "IMPACT_NONE";
    case Cvssv3_Impact.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Package is a generic definition of a package. */
export interface Package {
  /** The name of the package where the vulnerability was detected. */
  packageName: string;
  /** The CPE URI where the vulnerability was detected. */
  cpeUri: string;
  /** Type of package, for example, os, maven, or go. */
  packageType: string;
  /** The version of the package. */
  packageVersion: string;
}

/** SecurityBulletin are notifications of vulnerabilities of Google products. */
export interface SecurityBulletin {
  /** ID of the bulletin corresponding to the vulnerability. */
  bulletinId: string;
  /** Submission time of this Security Bulletin. */
  submissionTime:
    | Date
    | undefined;
  /**
   * This represents a version that the cluster receiving this notification
   * should be upgraded to, based on its current version. For example, 1.15.0
   */
  suggestedUpgradeVersion: string;
}

function createBaseVulnerability(): Vulnerability {
  return { cve: undefined, offendingPackage: undefined, fixedPackage: undefined, securityBulletin: undefined };
}

export const Vulnerability: MessageFns<Vulnerability> = {
  encode(message: Vulnerability, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cve !== undefined) {
      Cve.encode(message.cve, writer.uint32(10).fork()).join();
    }
    if (message.offendingPackage !== undefined) {
      Package.encode(message.offendingPackage, writer.uint32(18).fork()).join();
    }
    if (message.fixedPackage !== undefined) {
      Package.encode(message.fixedPackage, writer.uint32(26).fork()).join();
    }
    if (message.securityBulletin !== undefined) {
      SecurityBulletin.encode(message.securityBulletin, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vulnerability {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerability();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cve = Cve.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.offendingPackage = Package.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fixedPackage = Package.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.securityBulletin = SecurityBulletin.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vulnerability {
    return {
      cve: isSet(object.cve) ? Cve.fromJSON(object.cve) : undefined,
      offendingPackage: isSet(object.offendingPackage) ? Package.fromJSON(object.offendingPackage) : undefined,
      fixedPackage: isSet(object.fixedPackage) ? Package.fromJSON(object.fixedPackage) : undefined,
      securityBulletin: isSet(object.securityBulletin) ? SecurityBulletin.fromJSON(object.securityBulletin) : undefined,
    };
  },

  toJSON(message: Vulnerability): unknown {
    const obj: any = {};
    if (message.cve !== undefined) {
      obj.cve = Cve.toJSON(message.cve);
    }
    if (message.offendingPackage !== undefined) {
      obj.offendingPackage = Package.toJSON(message.offendingPackage);
    }
    if (message.fixedPackage !== undefined) {
      obj.fixedPackage = Package.toJSON(message.fixedPackage);
    }
    if (message.securityBulletin !== undefined) {
      obj.securityBulletin = SecurityBulletin.toJSON(message.securityBulletin);
    }
    return obj;
  },

  create(base?: DeepPartial<Vulnerability>): Vulnerability {
    return Vulnerability.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Vulnerability>): Vulnerability {
    const message = createBaseVulnerability();
    message.cve = (object.cve !== undefined && object.cve !== null) ? Cve.fromPartial(object.cve) : undefined;
    message.offendingPackage = (object.offendingPackage !== undefined && object.offendingPackage !== null)
      ? Package.fromPartial(object.offendingPackage)
      : undefined;
    message.fixedPackage = (object.fixedPackage !== undefined && object.fixedPackage !== null)
      ? Package.fromPartial(object.fixedPackage)
      : undefined;
    message.securityBulletin = (object.securityBulletin !== undefined && object.securityBulletin !== null)
      ? SecurityBulletin.fromPartial(object.securityBulletin)
      : undefined;
    return message;
  },
};

function createBaseCve(): Cve {
  return {
    id: "",
    references: [],
    cvssv3: undefined,
    upstreamFixAvailable: false,
    impact: 0,
    exploitationActivity: 0,
    observedInTheWild: false,
    zeroDay: false,
    exploitReleaseDate: undefined,
  };
}

export const Cve: MessageFns<Cve> = {
  encode(message: Cve, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.references) {
      Reference.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.cvssv3 !== undefined) {
      Cvssv3.encode(message.cvssv3, writer.uint32(26).fork()).join();
    }
    if (message.upstreamFixAvailable !== false) {
      writer.uint32(32).bool(message.upstreamFixAvailable);
    }
    if (message.impact !== 0) {
      writer.uint32(40).int32(message.impact);
    }
    if (message.exploitationActivity !== 0) {
      writer.uint32(48).int32(message.exploitationActivity);
    }
    if (message.observedInTheWild !== false) {
      writer.uint32(56).bool(message.observedInTheWild);
    }
    if (message.zeroDay !== false) {
      writer.uint32(64).bool(message.zeroDay);
    }
    if (message.exploitReleaseDate !== undefined) {
      Timestamp.encode(toTimestamp(message.exploitReleaseDate), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cve {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCve();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.references.push(Reference.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cvssv3 = Cvssv3.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.upstreamFixAvailable = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.impact = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.exploitationActivity = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.observedInTheWild = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.zeroDay = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.exploitReleaseDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cve {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      references: globalThis.Array.isArray(object?.references)
        ? object.references.map((e: any) => Reference.fromJSON(e))
        : [],
      cvssv3: isSet(object.cvssv3) ? Cvssv3.fromJSON(object.cvssv3) : undefined,
      upstreamFixAvailable: isSet(object.upstreamFixAvailable)
        ? globalThis.Boolean(object.upstreamFixAvailable)
        : false,
      impact: isSet(object.impact) ? cve_RiskRatingFromJSON(object.impact) : 0,
      exploitationActivity: isSet(object.exploitationActivity)
        ? cve_ExploitationActivityFromJSON(object.exploitationActivity)
        : 0,
      observedInTheWild: isSet(object.observedInTheWild) ? globalThis.Boolean(object.observedInTheWild) : false,
      zeroDay: isSet(object.zeroDay) ? globalThis.Boolean(object.zeroDay) : false,
      exploitReleaseDate: isSet(object.exploitReleaseDate) ? fromJsonTimestamp(object.exploitReleaseDate) : undefined,
    };
  },

  toJSON(message: Cve): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.references?.length) {
      obj.references = message.references.map((e) => Reference.toJSON(e));
    }
    if (message.cvssv3 !== undefined) {
      obj.cvssv3 = Cvssv3.toJSON(message.cvssv3);
    }
    if (message.upstreamFixAvailable !== false) {
      obj.upstreamFixAvailable = message.upstreamFixAvailable;
    }
    if (message.impact !== 0) {
      obj.impact = cve_RiskRatingToJSON(message.impact);
    }
    if (message.exploitationActivity !== 0) {
      obj.exploitationActivity = cve_ExploitationActivityToJSON(message.exploitationActivity);
    }
    if (message.observedInTheWild !== false) {
      obj.observedInTheWild = message.observedInTheWild;
    }
    if (message.zeroDay !== false) {
      obj.zeroDay = message.zeroDay;
    }
    if (message.exploitReleaseDate !== undefined) {
      obj.exploitReleaseDate = message.exploitReleaseDate.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Cve>): Cve {
    return Cve.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cve>): Cve {
    const message = createBaseCve();
    message.id = object.id ?? "";
    message.references = object.references?.map((e) => Reference.fromPartial(e)) || [];
    message.cvssv3 = (object.cvssv3 !== undefined && object.cvssv3 !== null)
      ? Cvssv3.fromPartial(object.cvssv3)
      : undefined;
    message.upstreamFixAvailable = object.upstreamFixAvailable ?? false;
    message.impact = object.impact ?? 0;
    message.exploitationActivity = object.exploitationActivity ?? 0;
    message.observedInTheWild = object.observedInTheWild ?? false;
    message.zeroDay = object.zeroDay ?? false;
    message.exploitReleaseDate = object.exploitReleaseDate ?? undefined;
    return message;
  },
};

function createBaseReference(): Reference {
  return { source: "", uri: "" };
}

export const Reference: MessageFns<Reference> = {
  encode(message: Reference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reference {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
    };
  },

  toJSON(message: Reference): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<Reference>): Reference {
    return Reference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Reference>): Reference {
    const message = createBaseReference();
    message.source = object.source ?? "";
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseCvssv3(): Cvssv3 {
  return {
    baseScore: 0,
    attackVector: 0,
    attackComplexity: 0,
    privilegesRequired: 0,
    userInteraction: 0,
    scope: 0,
    confidentialityImpact: 0,
    integrityImpact: 0,
    availabilityImpact: 0,
  };
}

export const Cvssv3: MessageFns<Cvssv3> = {
  encode(message: Cvssv3, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseScore !== 0) {
      writer.uint32(9).double(message.baseScore);
    }
    if (message.attackVector !== 0) {
      writer.uint32(40).int32(message.attackVector);
    }
    if (message.attackComplexity !== 0) {
      writer.uint32(48).int32(message.attackComplexity);
    }
    if (message.privilegesRequired !== 0) {
      writer.uint32(56).int32(message.privilegesRequired);
    }
    if (message.userInteraction !== 0) {
      writer.uint32(64).int32(message.userInteraction);
    }
    if (message.scope !== 0) {
      writer.uint32(72).int32(message.scope);
    }
    if (message.confidentialityImpact !== 0) {
      writer.uint32(80).int32(message.confidentialityImpact);
    }
    if (message.integrityImpact !== 0) {
      writer.uint32(88).int32(message.integrityImpact);
    }
    if (message.availabilityImpact !== 0) {
      writer.uint32(96).int32(message.availabilityImpact);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cvssv3 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCvssv3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.baseScore = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.attackVector = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.attackComplexity = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.privilegesRequired = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.userInteraction = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.confidentialityImpact = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.integrityImpact = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.availabilityImpact = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cvssv3 {
    return {
      baseScore: isSet(object.baseScore) ? globalThis.Number(object.baseScore) : 0,
      attackVector: isSet(object.attackVector) ? cvssv3_AttackVectorFromJSON(object.attackVector) : 0,
      attackComplexity: isSet(object.attackComplexity) ? cvssv3_AttackComplexityFromJSON(object.attackComplexity) : 0,
      privilegesRequired: isSet(object.privilegesRequired)
        ? cvssv3_PrivilegesRequiredFromJSON(object.privilegesRequired)
        : 0,
      userInteraction: isSet(object.userInteraction) ? cvssv3_UserInteractionFromJSON(object.userInteraction) : 0,
      scope: isSet(object.scope) ? cvssv3_ScopeFromJSON(object.scope) : 0,
      confidentialityImpact: isSet(object.confidentialityImpact)
        ? cvssv3_ImpactFromJSON(object.confidentialityImpact)
        : 0,
      integrityImpact: isSet(object.integrityImpact) ? cvssv3_ImpactFromJSON(object.integrityImpact) : 0,
      availabilityImpact: isSet(object.availabilityImpact) ? cvssv3_ImpactFromJSON(object.availabilityImpact) : 0,
    };
  },

  toJSON(message: Cvssv3): unknown {
    const obj: any = {};
    if (message.baseScore !== 0) {
      obj.baseScore = message.baseScore;
    }
    if (message.attackVector !== 0) {
      obj.attackVector = cvssv3_AttackVectorToJSON(message.attackVector);
    }
    if (message.attackComplexity !== 0) {
      obj.attackComplexity = cvssv3_AttackComplexityToJSON(message.attackComplexity);
    }
    if (message.privilegesRequired !== 0) {
      obj.privilegesRequired = cvssv3_PrivilegesRequiredToJSON(message.privilegesRequired);
    }
    if (message.userInteraction !== 0) {
      obj.userInteraction = cvssv3_UserInteractionToJSON(message.userInteraction);
    }
    if (message.scope !== 0) {
      obj.scope = cvssv3_ScopeToJSON(message.scope);
    }
    if (message.confidentialityImpact !== 0) {
      obj.confidentialityImpact = cvssv3_ImpactToJSON(message.confidentialityImpact);
    }
    if (message.integrityImpact !== 0) {
      obj.integrityImpact = cvssv3_ImpactToJSON(message.integrityImpact);
    }
    if (message.availabilityImpact !== 0) {
      obj.availabilityImpact = cvssv3_ImpactToJSON(message.availabilityImpact);
    }
    return obj;
  },

  create(base?: DeepPartial<Cvssv3>): Cvssv3 {
    return Cvssv3.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cvssv3>): Cvssv3 {
    const message = createBaseCvssv3();
    message.baseScore = object.baseScore ?? 0;
    message.attackVector = object.attackVector ?? 0;
    message.attackComplexity = object.attackComplexity ?? 0;
    message.privilegesRequired = object.privilegesRequired ?? 0;
    message.userInteraction = object.userInteraction ?? 0;
    message.scope = object.scope ?? 0;
    message.confidentialityImpact = object.confidentialityImpact ?? 0;
    message.integrityImpact = object.integrityImpact ?? 0;
    message.availabilityImpact = object.availabilityImpact ?? 0;
    return message;
  },
};

function createBasePackage(): Package {
  return { packageName: "", cpeUri: "", packageType: "", packageVersion: "" };
}

export const Package: MessageFns<Package> = {
  encode(message: Package, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packageName !== "") {
      writer.uint32(10).string(message.packageName);
    }
    if (message.cpeUri !== "") {
      writer.uint32(18).string(message.cpeUri);
    }
    if (message.packageType !== "") {
      writer.uint32(26).string(message.packageType);
    }
    if (message.packageVersion !== "") {
      writer.uint32(34).string(message.packageVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Package {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePackage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.packageName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cpeUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.packageType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.packageVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Package {
    return {
      packageName: isSet(object.packageName) ? globalThis.String(object.packageName) : "",
      cpeUri: isSet(object.cpeUri) ? globalThis.String(object.cpeUri) : "",
      packageType: isSet(object.packageType) ? globalThis.String(object.packageType) : "",
      packageVersion: isSet(object.packageVersion) ? globalThis.String(object.packageVersion) : "",
    };
  },

  toJSON(message: Package): unknown {
    const obj: any = {};
    if (message.packageName !== "") {
      obj.packageName = message.packageName;
    }
    if (message.cpeUri !== "") {
      obj.cpeUri = message.cpeUri;
    }
    if (message.packageType !== "") {
      obj.packageType = message.packageType;
    }
    if (message.packageVersion !== "") {
      obj.packageVersion = message.packageVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<Package>): Package {
    return Package.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Package>): Package {
    const message = createBasePackage();
    message.packageName = object.packageName ?? "";
    message.cpeUri = object.cpeUri ?? "";
    message.packageType = object.packageType ?? "";
    message.packageVersion = object.packageVersion ?? "";
    return message;
  },
};

function createBaseSecurityBulletin(): SecurityBulletin {
  return { bulletinId: "", submissionTime: undefined, suggestedUpgradeVersion: "" };
}

export const SecurityBulletin: MessageFns<SecurityBulletin> = {
  encode(message: SecurityBulletin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bulletinId !== "") {
      writer.uint32(10).string(message.bulletinId);
    }
    if (message.submissionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.submissionTime), writer.uint32(18).fork()).join();
    }
    if (message.suggestedUpgradeVersion !== "") {
      writer.uint32(26).string(message.suggestedUpgradeVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecurityBulletin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityBulletin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bulletinId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.submissionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.suggestedUpgradeVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecurityBulletin {
    return {
      bulletinId: isSet(object.bulletinId) ? globalThis.String(object.bulletinId) : "",
      submissionTime: isSet(object.submissionTime) ? fromJsonTimestamp(object.submissionTime) : undefined,
      suggestedUpgradeVersion: isSet(object.suggestedUpgradeVersion)
        ? globalThis.String(object.suggestedUpgradeVersion)
        : "",
    };
  },

  toJSON(message: SecurityBulletin): unknown {
    const obj: any = {};
    if (message.bulletinId !== "") {
      obj.bulletinId = message.bulletinId;
    }
    if (message.submissionTime !== undefined) {
      obj.submissionTime = message.submissionTime.toISOString();
    }
    if (message.suggestedUpgradeVersion !== "") {
      obj.suggestedUpgradeVersion = message.suggestedUpgradeVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<SecurityBulletin>): SecurityBulletin {
    return SecurityBulletin.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecurityBulletin>): SecurityBulletin {
    const message = createBaseSecurityBulletin();
    message.bulletinId = object.bulletinId ?? "";
    message.submissionTime = object.submissionTime ?? undefined;
    message.suggestedUpgradeVersion = object.suggestedUpgradeVersion ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
