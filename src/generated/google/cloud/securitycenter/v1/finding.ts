// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/securitycenter/v1/finding.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Value } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Access } from "./access.js";
import { Application } from "./application.js";
import { AttackExposure } from "./attack_exposure.js";
import { BackupDisasterRecovery } from "./backup_disaster_recovery.js";
import { CloudArmor } from "./cloud_armor.js";
import { CloudDlpDataProfile } from "./cloud_dlp_data_profile.js";
import { CloudDlpInspection } from "./cloud_dlp_inspection.js";
import { Compliance } from "./compliance.js";
import { Connection } from "./connection.js";
import { ContactDetails } from "./contact_details.js";
import { Container } from "./container.js";
import { Database } from "./database.js";
import { Exfiltration } from "./exfiltration.js";
import { ExternalSystem } from "./external_system.js";
import { File } from "./file.js";
import { GroupMembership } from "./group_membership.js";
import { IamBinding } from "./iam_binding.js";
import { Indicator } from "./indicator.js";
import { KernelRootkit } from "./kernel_rootkit.js";
import { Kubernetes } from "./kubernetes.js";
import { LoadBalancer } from "./load_balancer.js";
import { LogEntry } from "./log_entry.js";
import { MitreAttack } from "./mitre_attack.js";
import { Notebook } from "./notebook.js";
import { OrgPolicy } from "./org_policy.js";
import { Process } from "./process.js";
import { SecurityMarks } from "./security_marks.js";
import { SecurityPosture } from "./security_posture.js";
import { ToxicCombination } from "./toxic_combination.js";
import { Vulnerability } from "./vulnerability.js";

export const protobufPackage = "google.cloud.securitycenter.v1";

/**
 * Security Command Center finding.
 *
 * A finding is a record of assessment data like security, risk, health, or
 * privacy, that is ingested into Security Command Center for presentation,
 * notification, analysis, policy testing, and enforcement. For example, a
 * cross-site scripting (XSS) vulnerability in an App Engine application is a
 * finding.
 */
export interface Finding {
  /**
   * The [relative resource
   * name](https://cloud.google.com/apis/design/resource_names#relative_resource_name)
   * of the finding. Example:
   * "organizations/{organization_id}/sources/{source_id}/findings/{finding_id}",
   * "folders/{folder_id}/sources/{source_id}/findings/{finding_id}",
   * "projects/{project_id}/sources/{source_id}/findings/{finding_id}".
   */
  name: string;
  /**
   * The relative resource name of the source the finding belongs to. See:
   * https://cloud.google.com/apis/design/resource_names#relative_resource_name
   * This field is immutable after creation time.
   * For example:
   * "organizations/{organization_id}/sources/{source_id}"
   */
  parent: string;
  /**
   * For findings on Google Cloud resources, the full resource
   * name of the Google Cloud resource this finding is for. See:
   * https://cloud.google.com/apis/design/resource_names#full_resource_name
   * When the finding is for a non-Google Cloud resource, the resourceName can
   * be a customer or partner defined string. This field is immutable after
   * creation time.
   */
  resourceName: string;
  /** The state of the finding. */
  state: Finding_State;
  /**
   * The additional taxonomy group within findings from a given source.
   * This field is immutable after creation time.
   * Example: "XSS_FLASH_INJECTION"
   */
  category: string;
  /**
   * The URI that, if available, points to a web page outside of Security
   * Command Center where additional information about the finding can be found.
   * This field is guaranteed to be either empty or a well formed URL.
   */
  externalUri: string;
  /**
   * Source specific properties. These properties are managed by the source
   * that writes the finding. The key names in the source_properties map must be
   * between 1 and 255 characters, and must start with a letter and contain
   * alphanumeric characters or underscores only.
   */
  sourceProperties: { [key: string]: any | undefined };
  /**
   * Output only. User specified security marks. These marks are entirely
   * managed by the user and come from the SecurityMarks resource that belongs
   * to the finding.
   */
  securityMarks:
    | SecurityMarks
    | undefined;
  /**
   * The time the finding was first detected. If an existing finding is updated,
   * then this is the time the update occurred.
   * For example, if the finding represents an open firewall, this property
   * captures the time the detector believes the firewall became open. The
   * accuracy is determined by the detector. If the finding is later resolved,
   * then this time reflects when the finding was resolved. This must not
   * be set to a value greater than the current timestamp.
   */
  eventTime:
    | Date
    | undefined;
  /** The time at which the finding was created in Security Command Center. */
  createTime:
    | Date
    | undefined;
  /**
   * The severity of the finding. This field is managed by the source that
   * writes the finding.
   */
  severity: Finding_Severity;
  /**
   * The canonical name of the finding. It's either
   * "organizations/{organization_id}/sources/{source_id}/findings/{finding_id}",
   * "folders/{folder_id}/sources/{source_id}/findings/{finding_id}" or
   * "projects/{project_number}/sources/{source_id}/findings/{finding_id}",
   * depending on the closest CRM ancestor of the resource associated with the
   * finding.
   */
  canonicalName: string;
  /**
   * Indicates the mute state of a finding (either muted, unmuted
   * or undefined). Unlike other attributes of a finding, a finding provider
   * shouldn't set the value of mute.
   */
  mute: Finding_Mute;
  /** The class of the finding. */
  findingClass: Finding_FindingClass;
  /**
   * Represents what's commonly known as an *indicator of compromise* (IoC) in
   * computer forensics. This is an artifact observed on a network or in an
   * operating system that, with high confidence, indicates a computer
   * intrusion. For more information, see [Indicator of
   * compromise](https://en.wikipedia.org/wiki/Indicator_of_compromise).
   */
  indicator:
    | Indicator
    | undefined;
  /**
   * Represents vulnerability-specific fields like CVE and CVSS scores.
   * CVE stands for Common Vulnerabilities and Exposures
   * (https://cve.mitre.org/about/)
   */
  vulnerability:
    | Vulnerability
    | undefined;
  /** Output only. The most recent time this finding was muted or unmuted. */
  muteUpdateTime:
    | Date
    | undefined;
  /**
   * Output only. Third party SIEM/SOAR fields within SCC, contains external
   * system information and external system finding fields.
   */
  externalSystems: { [key: string]: ExternalSystem };
  /**
   * MITRE ATT&CK tactics and techniques related to this finding.
   * See: https://attack.mitre.org
   */
  mitreAttack:
    | MitreAttack
    | undefined;
  /**
   * Access details associated with the finding, such as more information on the
   * caller, which method was accessed, and from where.
   */
  access:
    | Access
    | undefined;
  /** Contains information about the IP connection associated with the finding. */
  connections: Connection[];
  /**
   * Records additional information about the mute operation, for example, the
   * [mute configuration](/security-command-center/docs/how-to-mute-findings)
   * that muted the finding and the user who muted the finding.
   */
  muteInitiator: string;
  /** Output only. The mute information regarding this finding. */
  muteInfo:
    | Finding_MuteInfo
    | undefined;
  /** Represents operating system processes associated with the Finding. */
  processes: Process[];
  /**
   * Output only. Map containing the points of contact for the given finding.
   * The key represents the type of contact, while the value contains a list of
   * all the contacts that pertain. Please refer to:
   * https://cloud.google.com/resource-manager/docs/managing-notification-contacts#notification-categories
   *
   *     {
   *       "security": {
   *         "contacts": [
   *           {
   *             "email": "person1@company.com"
   *           },
   *           {
   *             "email": "person2@company.com"
   *           }
   *         ]
   *       }
   *     }
   */
  contacts: { [key: string]: ContactDetails };
  /**
   * Contains compliance information for security standards associated to the
   * finding.
   */
  compliances: Compliance[];
  /**
   * Output only. The human readable display name of the finding source such as
   * "Event Threat Detection" or "Security Health Analytics".
   */
  parentDisplayName: string;
  /** Contains more details about the finding. */
  description: string;
  /** Represents exfiltrations associated with the finding. */
  exfiltration:
    | Exfiltration
    | undefined;
  /** Represents IAM bindings associated with the finding. */
  iamBindings: IamBinding[];
  /** Steps to address the finding. */
  nextSteps: string;
  /**
   * Unique identifier of the module which generated the finding.
   * Example:
   * folders/598186756061/securityHealthAnalyticsSettings/customModules/56799441161885
   */
  moduleName: string;
  /**
   * Containers associated with the finding. This field provides information for
   * both Kubernetes and non-Kubernetes containers.
   */
  containers: Container[];
  /** Kubernetes resources associated with the finding. */
  kubernetes:
    | Kubernetes
    | undefined;
  /** Database associated with the finding. */
  database:
    | Database
    | undefined;
  /** The results of an attack path simulation relevant to this finding. */
  attackExposure:
    | AttackExposure
    | undefined;
  /** File associated with the finding. */
  files: File[];
  /**
   * Cloud Data Loss Prevention (Cloud DLP) inspection results that are
   * associated with the finding.
   */
  cloudDlpInspection:
    | CloudDlpInspection
    | undefined;
  /** Cloud DLP data profile that is associated with the finding. */
  cloudDlpDataProfile:
    | CloudDlpDataProfile
    | undefined;
  /** Signature of the kernel rootkit. */
  kernelRootkit:
    | KernelRootkit
    | undefined;
  /** Contains information about the org policies associated with the finding. */
  orgPolicies: OrgPolicy[];
  /** Represents an application associated with the finding. */
  application:
    | Application
    | undefined;
  /** Fields related to Backup and DR findings. */
  backupDisasterRecovery:
    | BackupDisasterRecovery
    | undefined;
  /** The security posture associated with the finding. */
  securityPosture:
    | SecurityPosture
    | undefined;
  /** Log entries that are relevant to the finding. */
  logEntries: LogEntry[];
  /** The load balancers associated with the finding. */
  loadBalancers: LoadBalancer[];
  /** Fields related to Cloud Armor findings. */
  cloudArmor:
    | CloudArmor
    | undefined;
  /** Notebook associated with the finding. */
  notebook:
    | Notebook
    | undefined;
  /**
   * Contains details about a group of security issues that, when the issues
   * occur together, represent a greater risk than when the issues occur
   * independently. A group of such issues is referred to as a toxic
   * combination.
   * This field cannot be updated. Its value is ignored in all update requests.
   */
  toxicCombination:
    | ToxicCombination
    | undefined;
  /**
   * Contains details about groups of which this finding is a member. A group is
   * a collection of findings that are related in some way.
   * This field cannot be updated. Its value is ignored in all update requests.
   */
  groupMemberships: GroupMembership[];
}

/** The state of the finding. */
export enum Finding_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The finding requires attention and has not been addressed yet. */
  ACTIVE = 1,
  /**
   * INACTIVE - The finding has been fixed, triaged as a non-issue or otherwise addressed
   * and is no longer active.
   */
  INACTIVE = 2,
  UNRECOGNIZED = -1,
}

export function finding_StateFromJSON(object: any): Finding_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Finding_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Finding_State.ACTIVE;
    case 2:
    case "INACTIVE":
      return Finding_State.INACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Finding_State.UNRECOGNIZED;
  }
}

export function finding_StateToJSON(object: Finding_State): string {
  switch (object) {
    case Finding_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Finding_State.ACTIVE:
      return "ACTIVE";
    case Finding_State.INACTIVE:
      return "INACTIVE";
    case Finding_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The severity of the finding. */
export enum Finding_Severity {
  /**
   * SEVERITY_UNSPECIFIED - This value is used for findings when a source doesn't write a severity
   * value.
   */
  SEVERITY_UNSPECIFIED = 0,
  /**
   * CRITICAL - Vulnerability:
   * A critical vulnerability is easily discoverable by an external actor,
   * exploitable, and results in the direct ability to execute arbitrary code,
   * exfiltrate data, and otherwise gain additional access and privileges to
   * cloud resources and workloads. Examples include publicly accessible
   * unprotected user data and public SSH access with weak or no
   * passwords.
   *
   * Threat:
   * Indicates a threat that is able to access, modify, or delete data or
   * execute unauthorized code within existing resources.
   */
  CRITICAL = 1,
  /**
   * HIGH - Vulnerability:
   * A high risk vulnerability can be easily discovered and exploited in
   * combination with other vulnerabilities in order to gain direct access and
   * the ability to execute arbitrary code, exfiltrate data, and otherwise
   * gain additional access and privileges to cloud resources and workloads.
   * An example is a database with weak or no passwords that is only
   * accessible internally. This database could easily be compromised by an
   * actor that had access to the internal network.
   *
   * Threat:
   * Indicates a threat that is able to create new computational resources in
   * an environment but not able to access data or execute code in existing
   * resources.
   */
  HIGH = 2,
  /**
   * MEDIUM - Vulnerability:
   * A medium risk vulnerability could be used by an actor to gain access to
   * resources or privileges that enable them to eventually (through multiple
   * steps or a complex exploit) gain access and the ability to execute
   * arbitrary code or exfiltrate data. An example is a service account with
   * access to more projects than it should have. If an actor gains access to
   * the service account, they could potentially use that access to manipulate
   * a project the service account was not intended to.
   *
   * Threat:
   * Indicates a threat that is able to cause operational impact but may not
   * access data or execute unauthorized code.
   */
  MEDIUM = 3,
  /**
   * LOW - Vulnerability:
   * A low risk vulnerability hampers a security organization's ability to
   * detect vulnerabilities or active threats in their deployment, or prevents
   * the root cause investigation of security issues. An example is monitoring
   * and logs being disabled for resource configurations and access.
   *
   * Threat:
   * Indicates a threat that has obtained minimal access to an environment but
   * is not able to access data, execute code, or create resources.
   */
  LOW = 4,
  UNRECOGNIZED = -1,
}

export function finding_SeverityFromJSON(object: any): Finding_Severity {
  switch (object) {
    case 0:
    case "SEVERITY_UNSPECIFIED":
      return Finding_Severity.SEVERITY_UNSPECIFIED;
    case 1:
    case "CRITICAL":
      return Finding_Severity.CRITICAL;
    case 2:
    case "HIGH":
      return Finding_Severity.HIGH;
    case 3:
    case "MEDIUM":
      return Finding_Severity.MEDIUM;
    case 4:
    case "LOW":
      return Finding_Severity.LOW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Finding_Severity.UNRECOGNIZED;
  }
}

export function finding_SeverityToJSON(object: Finding_Severity): string {
  switch (object) {
    case Finding_Severity.SEVERITY_UNSPECIFIED:
      return "SEVERITY_UNSPECIFIED";
    case Finding_Severity.CRITICAL:
      return "CRITICAL";
    case Finding_Severity.HIGH:
      return "HIGH";
    case Finding_Severity.MEDIUM:
      return "MEDIUM";
    case Finding_Severity.LOW:
      return "LOW";
    case Finding_Severity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Mute state a finding can be in. */
export enum Finding_Mute {
  /** MUTE_UNSPECIFIED - Unspecified. */
  MUTE_UNSPECIFIED = 0,
  /** MUTED - Finding has been muted. */
  MUTED = 1,
  /** UNMUTED - Finding has been unmuted. */
  UNMUTED = 2,
  /** UNDEFINED - Finding has never been muted/unmuted. */
  UNDEFINED = 4,
  UNRECOGNIZED = -1,
}

export function finding_MuteFromJSON(object: any): Finding_Mute {
  switch (object) {
    case 0:
    case "MUTE_UNSPECIFIED":
      return Finding_Mute.MUTE_UNSPECIFIED;
    case 1:
    case "MUTED":
      return Finding_Mute.MUTED;
    case 2:
    case "UNMUTED":
      return Finding_Mute.UNMUTED;
    case 4:
    case "UNDEFINED":
      return Finding_Mute.UNDEFINED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Finding_Mute.UNRECOGNIZED;
  }
}

export function finding_MuteToJSON(object: Finding_Mute): string {
  switch (object) {
    case Finding_Mute.MUTE_UNSPECIFIED:
      return "MUTE_UNSPECIFIED";
    case Finding_Mute.MUTED:
      return "MUTED";
    case Finding_Mute.UNMUTED:
      return "UNMUTED";
    case Finding_Mute.UNDEFINED:
      return "UNDEFINED";
    case Finding_Mute.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents what kind of Finding it is. */
export enum Finding_FindingClass {
  /** FINDING_CLASS_UNSPECIFIED - Unspecified finding class. */
  FINDING_CLASS_UNSPECIFIED = 0,
  /** THREAT - Describes unwanted or malicious activity. */
  THREAT = 1,
  /**
   * VULNERABILITY - Describes a potential weakness in software that increases risk to
   * Confidentiality & Integrity & Availability.
   */
  VULNERABILITY = 2,
  /**
   * MISCONFIGURATION - Describes a potential weakness in cloud resource/asset configuration that
   * increases risk.
   */
  MISCONFIGURATION = 3,
  /** OBSERVATION - Describes a security observation that is for informational purposes. */
  OBSERVATION = 4,
  /** SCC_ERROR - Describes an error that prevents some SCC functionality. */
  SCC_ERROR = 5,
  /**
   * POSTURE_VIOLATION - Describes a potential security risk due to a change in the security
   * posture.
   */
  POSTURE_VIOLATION = 6,
  /**
   * TOXIC_COMBINATION - Describes a group of security issues that, when the issues
   * occur together, represent a greater risk than when the issues occur
   * independently. A group of such issues is referred to as a toxic
   * combination.
   */
  TOXIC_COMBINATION = 7,
  UNRECOGNIZED = -1,
}

export function finding_FindingClassFromJSON(object: any): Finding_FindingClass {
  switch (object) {
    case 0:
    case "FINDING_CLASS_UNSPECIFIED":
      return Finding_FindingClass.FINDING_CLASS_UNSPECIFIED;
    case 1:
    case "THREAT":
      return Finding_FindingClass.THREAT;
    case 2:
    case "VULNERABILITY":
      return Finding_FindingClass.VULNERABILITY;
    case 3:
    case "MISCONFIGURATION":
      return Finding_FindingClass.MISCONFIGURATION;
    case 4:
    case "OBSERVATION":
      return Finding_FindingClass.OBSERVATION;
    case 5:
    case "SCC_ERROR":
      return Finding_FindingClass.SCC_ERROR;
    case 6:
    case "POSTURE_VIOLATION":
      return Finding_FindingClass.POSTURE_VIOLATION;
    case 7:
    case "TOXIC_COMBINATION":
      return Finding_FindingClass.TOXIC_COMBINATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Finding_FindingClass.UNRECOGNIZED;
  }
}

export function finding_FindingClassToJSON(object: Finding_FindingClass): string {
  switch (object) {
    case Finding_FindingClass.FINDING_CLASS_UNSPECIFIED:
      return "FINDING_CLASS_UNSPECIFIED";
    case Finding_FindingClass.THREAT:
      return "THREAT";
    case Finding_FindingClass.VULNERABILITY:
      return "VULNERABILITY";
    case Finding_FindingClass.MISCONFIGURATION:
      return "MISCONFIGURATION";
    case Finding_FindingClass.OBSERVATION:
      return "OBSERVATION";
    case Finding_FindingClass.SCC_ERROR:
      return "SCC_ERROR";
    case Finding_FindingClass.POSTURE_VIOLATION:
      return "POSTURE_VIOLATION";
    case Finding_FindingClass.TOXIC_COMBINATION:
      return "TOXIC_COMBINATION";
    case Finding_FindingClass.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Mute information about the finding, including whether the finding has a
 * static mute or any matching dynamic mute rules.
 */
export interface Finding_MuteInfo {
  /**
   * If set, the static mute applied to this finding. Static mutes override
   * dynamic mutes. If unset, there is no static mute.
   */
  staticMute:
    | Finding_MuteInfo_StaticMute
    | undefined;
  /** The list of dynamic mute rules that currently match the finding. */
  dynamicMuteRecords: Finding_MuteInfo_DynamicMuteRecord[];
}

/**
 * Information about the static mute state. A static mute state overrides
 * any dynamic mute rules that apply to this finding. The static mute state
 * can be set by a static mute rule or by muting the finding directly.
 */
export interface Finding_MuteInfo_StaticMute {
  /**
   * The static mute state. If the value is `MUTED` or `UNMUTED`, then the
   * finding's overall mute state will have the same value.
   */
  state: Finding_Mute;
  /** When the static mute was applied. */
  applyTime: Date | undefined;
}

/** The record of a dynamic mute rule that matches the finding. */
export interface Finding_MuteInfo_DynamicMuteRecord {
  /**
   * The relative resource name of the mute rule, represented by a mute
   * config, that created this record, for example
   * `organizations/123/muteConfigs/mymuteconfig` or
   * `organizations/123/locations/global/muteConfigs/mymuteconfig`.
   */
  muteConfig: string;
  /** When the dynamic mute rule first matched the finding. */
  matchTime: Date | undefined;
}

export interface Finding_SourcePropertiesEntry {
  key: string;
  value: any | undefined;
}

export interface Finding_ExternalSystemsEntry {
  key: string;
  value: ExternalSystem | undefined;
}

export interface Finding_ContactsEntry {
  key: string;
  value: ContactDetails | undefined;
}

function createBaseFinding(): Finding {
  return {
    name: "",
    parent: "",
    resourceName: "",
    state: 0,
    category: "",
    externalUri: "",
    sourceProperties: {},
    securityMarks: undefined,
    eventTime: undefined,
    createTime: undefined,
    severity: 0,
    canonicalName: "",
    mute: 0,
    findingClass: 0,
    indicator: undefined,
    vulnerability: undefined,
    muteUpdateTime: undefined,
    externalSystems: {},
    mitreAttack: undefined,
    access: undefined,
    connections: [],
    muteInitiator: "",
    muteInfo: undefined,
    processes: [],
    contacts: {},
    compliances: [],
    parentDisplayName: "",
    description: "",
    exfiltration: undefined,
    iamBindings: [],
    nextSteps: "",
    moduleName: "",
    containers: [],
    kubernetes: undefined,
    database: undefined,
    attackExposure: undefined,
    files: [],
    cloudDlpInspection: undefined,
    cloudDlpDataProfile: undefined,
    kernelRootkit: undefined,
    orgPolicies: [],
    application: undefined,
    backupDisasterRecovery: undefined,
    securityPosture: undefined,
    logEntries: [],
    loadBalancers: [],
    cloudArmor: undefined,
    notebook: undefined,
    toxicCombination: undefined,
    groupMemberships: [],
  };
}

export const Finding: MessageFns<Finding> = {
  encode(message: Finding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    if (message.resourceName !== "") {
      writer.uint32(26).string(message.resourceName);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.category !== "") {
      writer.uint32(42).string(message.category);
    }
    if (message.externalUri !== "") {
      writer.uint32(50).string(message.externalUri);
    }
    Object.entries(message.sourceProperties).forEach(([key, value]) => {
      if (value !== undefined) {
        Finding_SourcePropertiesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
      }
    });
    if (message.securityMarks !== undefined) {
      SecurityMarks.encode(message.securityMarks, writer.uint32(66).fork()).join();
    }
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(74).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(82).fork()).join();
    }
    if (message.severity !== 0) {
      writer.uint32(96).int32(message.severity);
    }
    if (message.canonicalName !== "") {
      writer.uint32(114).string(message.canonicalName);
    }
    if (message.mute !== 0) {
      writer.uint32(120).int32(message.mute);
    }
    if (message.findingClass !== 0) {
      writer.uint32(136).int32(message.findingClass);
    }
    if (message.indicator !== undefined) {
      Indicator.encode(message.indicator, writer.uint32(146).fork()).join();
    }
    if (message.vulnerability !== undefined) {
      Vulnerability.encode(message.vulnerability, writer.uint32(162).fork()).join();
    }
    if (message.muteUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.muteUpdateTime), writer.uint32(170).fork()).join();
    }
    Object.entries(message.externalSystems).forEach(([key, value]) => {
      Finding_ExternalSystemsEntry.encode({ key: key as any, value }, writer.uint32(178).fork()).join();
    });
    if (message.mitreAttack !== undefined) {
      MitreAttack.encode(message.mitreAttack, writer.uint32(202).fork()).join();
    }
    if (message.access !== undefined) {
      Access.encode(message.access, writer.uint32(210).fork()).join();
    }
    for (const v of message.connections) {
      Connection.encode(v!, writer.uint32(250).fork()).join();
    }
    if (message.muteInitiator !== "") {
      writer.uint32(226).string(message.muteInitiator);
    }
    if (message.muteInfo !== undefined) {
      Finding_MuteInfo.encode(message.muteInfo, writer.uint32(490).fork()).join();
    }
    for (const v of message.processes) {
      Process.encode(v!, writer.uint32(242).fork()).join();
    }
    Object.entries(message.contacts).forEach(([key, value]) => {
      Finding_ContactsEntry.encode({ key: key as any, value }, writer.uint32(266).fork()).join();
    });
    for (const v of message.compliances) {
      Compliance.encode(v!, writer.uint32(274).fork()).join();
    }
    if (message.parentDisplayName !== "") {
      writer.uint32(290).string(message.parentDisplayName);
    }
    if (message.description !== "") {
      writer.uint32(298).string(message.description);
    }
    if (message.exfiltration !== undefined) {
      Exfiltration.encode(message.exfiltration, writer.uint32(306).fork()).join();
    }
    for (const v of message.iamBindings) {
      IamBinding.encode(v!, writer.uint32(314).fork()).join();
    }
    if (message.nextSteps !== "") {
      writer.uint32(322).string(message.nextSteps);
    }
    if (message.moduleName !== "") {
      writer.uint32(330).string(message.moduleName);
    }
    for (const v of message.containers) {
      Container.encode(v!, writer.uint32(338).fork()).join();
    }
    if (message.kubernetes !== undefined) {
      Kubernetes.encode(message.kubernetes, writer.uint32(346).fork()).join();
    }
    if (message.database !== undefined) {
      Database.encode(message.database, writer.uint32(354).fork()).join();
    }
    if (message.attackExposure !== undefined) {
      AttackExposure.encode(message.attackExposure, writer.uint32(362).fork()).join();
    }
    for (const v of message.files) {
      File.encode(v!, writer.uint32(370).fork()).join();
    }
    if (message.cloudDlpInspection !== undefined) {
      CloudDlpInspection.encode(message.cloudDlpInspection, writer.uint32(386).fork()).join();
    }
    if (message.cloudDlpDataProfile !== undefined) {
      CloudDlpDataProfile.encode(message.cloudDlpDataProfile, writer.uint32(394).fork()).join();
    }
    if (message.kernelRootkit !== undefined) {
      KernelRootkit.encode(message.kernelRootkit, writer.uint32(402).fork()).join();
    }
    for (const v of message.orgPolicies) {
      OrgPolicy.encode(v!, writer.uint32(410).fork()).join();
    }
    if (message.application !== undefined) {
      Application.encode(message.application, writer.uint32(426).fork()).join();
    }
    if (message.backupDisasterRecovery !== undefined) {
      BackupDisasterRecovery.encode(message.backupDisasterRecovery, writer.uint32(442).fork()).join();
    }
    if (message.securityPosture !== undefined) {
      SecurityPosture.encode(message.securityPosture, writer.uint32(450).fork()).join();
    }
    for (const v of message.logEntries) {
      LogEntry.encode(v!, writer.uint32(458).fork()).join();
    }
    for (const v of message.loadBalancers) {
      LoadBalancer.encode(v!, writer.uint32(466).fork()).join();
    }
    if (message.cloudArmor !== undefined) {
      CloudArmor.encode(message.cloudArmor, writer.uint32(474).fork()).join();
    }
    if (message.notebook !== undefined) {
      Notebook.encode(message.notebook, writer.uint32(506).fork()).join();
    }
    if (message.toxicCombination !== undefined) {
      ToxicCombination.encode(message.toxicCombination, writer.uint32(514).fork()).join();
    }
    for (const v of message.groupMemberships) {
      GroupMembership.encode(v!, writer.uint32(522).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Finding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.category = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalUri = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Finding_SourcePropertiesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.sourceProperties[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.securityMarks = SecurityMarks.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.canonicalName = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.mute = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.findingClass = reader.int32() as any;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.indicator = Indicator.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.vulnerability = Vulnerability.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.muteUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          const entry22 = Finding_ExternalSystemsEntry.decode(reader, reader.uint32());
          if (entry22.value !== undefined) {
            message.externalSystems[entry22.key] = entry22.value;
          }
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.mitreAttack = MitreAttack.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.access = Access.decode(reader, reader.uint32());
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.connections.push(Connection.decode(reader, reader.uint32()));
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.muteInitiator = reader.string();
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }

          message.muteInfo = Finding_MuteInfo.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.processes.push(Process.decode(reader, reader.uint32()));
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          const entry33 = Finding_ContactsEntry.decode(reader, reader.uint32());
          if (entry33.value !== undefined) {
            message.contacts[entry33.key] = entry33.value;
          }
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.compliances.push(Compliance.decode(reader, reader.uint32()));
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.parentDisplayName = reader.string();
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.description = reader.string();
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }

          message.exfiltration = Exfiltration.decode(reader, reader.uint32());
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.iamBindings.push(IamBinding.decode(reader, reader.uint32()));
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.nextSteps = reader.string();
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.moduleName = reader.string();
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.containers.push(Container.decode(reader, reader.uint32()));
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.kubernetes = Kubernetes.decode(reader, reader.uint32());
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }

          message.database = Database.decode(reader, reader.uint32());
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }

          message.attackExposure = AttackExposure.decode(reader, reader.uint32());
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }

          message.files.push(File.decode(reader, reader.uint32()));
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }

          message.cloudDlpInspection = CloudDlpInspection.decode(reader, reader.uint32());
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }

          message.cloudDlpDataProfile = CloudDlpDataProfile.decode(reader, reader.uint32());
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.kernelRootkit = KernelRootkit.decode(reader, reader.uint32());
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.orgPolicies.push(OrgPolicy.decode(reader, reader.uint32()));
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }

          message.application = Application.decode(reader, reader.uint32());
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }

          message.backupDisasterRecovery = BackupDisasterRecovery.decode(reader, reader.uint32());
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }

          message.securityPosture = SecurityPosture.decode(reader, reader.uint32());
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }

          message.logEntries.push(LogEntry.decode(reader, reader.uint32()));
          continue;
        case 58:
          if (tag !== 466) {
            break;
          }

          message.loadBalancers.push(LoadBalancer.decode(reader, reader.uint32()));
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }

          message.cloudArmor = CloudArmor.decode(reader, reader.uint32());
          continue;
        case 63:
          if (tag !== 506) {
            break;
          }

          message.notebook = Notebook.decode(reader, reader.uint32());
          continue;
        case 64:
          if (tag !== 514) {
            break;
          }

          message.toxicCombination = ToxicCombination.decode(reader, reader.uint32());
          continue;
        case 65:
          if (tag !== 522) {
            break;
          }

          message.groupMemberships.push(GroupMembership.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Finding {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      state: isSet(object.state) ? finding_StateFromJSON(object.state) : 0,
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      externalUri: isSet(object.externalUri) ? globalThis.String(object.externalUri) : "",
      sourceProperties: isObject(object.sourceProperties)
        ? Object.entries(object.sourceProperties).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      securityMarks: isSet(object.securityMarks) ? SecurityMarks.fromJSON(object.securityMarks) : undefined,
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      severity: isSet(object.severity) ? finding_SeverityFromJSON(object.severity) : 0,
      canonicalName: isSet(object.canonicalName) ? globalThis.String(object.canonicalName) : "",
      mute: isSet(object.mute) ? finding_MuteFromJSON(object.mute) : 0,
      findingClass: isSet(object.findingClass) ? finding_FindingClassFromJSON(object.findingClass) : 0,
      indicator: isSet(object.indicator) ? Indicator.fromJSON(object.indicator) : undefined,
      vulnerability: isSet(object.vulnerability) ? Vulnerability.fromJSON(object.vulnerability) : undefined,
      muteUpdateTime: isSet(object.muteUpdateTime) ? fromJsonTimestamp(object.muteUpdateTime) : undefined,
      externalSystems: isObject(object.externalSystems)
        ? Object.entries(object.externalSystems).reduce<{ [key: string]: ExternalSystem }>((acc, [key, value]) => {
          acc[key] = ExternalSystem.fromJSON(value);
          return acc;
        }, {})
        : {},
      mitreAttack: isSet(object.mitreAttack) ? MitreAttack.fromJSON(object.mitreAttack) : undefined,
      access: isSet(object.access) ? Access.fromJSON(object.access) : undefined,
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => Connection.fromJSON(e))
        : [],
      muteInitiator: isSet(object.muteInitiator) ? globalThis.String(object.muteInitiator) : "",
      muteInfo: isSet(object.muteInfo) ? Finding_MuteInfo.fromJSON(object.muteInfo) : undefined,
      processes: globalThis.Array.isArray(object?.processes)
        ? object.processes.map((e: any) => Process.fromJSON(e))
        : [],
      contacts: isObject(object.contacts)
        ? Object.entries(object.contacts).reduce<{ [key: string]: ContactDetails }>((acc, [key, value]) => {
          acc[key] = ContactDetails.fromJSON(value);
          return acc;
        }, {})
        : {},
      compliances: globalThis.Array.isArray(object?.compliances)
        ? object.compliances.map((e: any) => Compliance.fromJSON(e))
        : [],
      parentDisplayName: isSet(object.parentDisplayName) ? globalThis.String(object.parentDisplayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      exfiltration: isSet(object.exfiltration) ? Exfiltration.fromJSON(object.exfiltration) : undefined,
      iamBindings: globalThis.Array.isArray(object?.iamBindings)
        ? object.iamBindings.map((e: any) => IamBinding.fromJSON(e))
        : [],
      nextSteps: isSet(object.nextSteps) ? globalThis.String(object.nextSteps) : "",
      moduleName: isSet(object.moduleName) ? globalThis.String(object.moduleName) : "",
      containers: globalThis.Array.isArray(object?.containers)
        ? object.containers.map((e: any) => Container.fromJSON(e))
        : [],
      kubernetes: isSet(object.kubernetes) ? Kubernetes.fromJSON(object.kubernetes) : undefined,
      database: isSet(object.database) ? Database.fromJSON(object.database) : undefined,
      attackExposure: isSet(object.attackExposure) ? AttackExposure.fromJSON(object.attackExposure) : undefined,
      files: globalThis.Array.isArray(object?.files)
        ? object.files.map((e: any) => File.fromJSON(e))
        : [],
      cloudDlpInspection: isSet(object.cloudDlpInspection)
        ? CloudDlpInspection.fromJSON(object.cloudDlpInspection)
        : undefined,
      cloudDlpDataProfile: isSet(object.cloudDlpDataProfile)
        ? CloudDlpDataProfile.fromJSON(object.cloudDlpDataProfile)
        : undefined,
      kernelRootkit: isSet(object.kernelRootkit) ? KernelRootkit.fromJSON(object.kernelRootkit) : undefined,
      orgPolicies: globalThis.Array.isArray(object?.orgPolicies)
        ? object.orgPolicies.map((e: any) => OrgPolicy.fromJSON(e))
        : [],
      application: isSet(object.application) ? Application.fromJSON(object.application) : undefined,
      backupDisasterRecovery: isSet(object.backupDisasterRecovery)
        ? BackupDisasterRecovery.fromJSON(object.backupDisasterRecovery)
        : undefined,
      securityPosture: isSet(object.securityPosture) ? SecurityPosture.fromJSON(object.securityPosture) : undefined,
      logEntries: globalThis.Array.isArray(object?.logEntries)
        ? object.logEntries.map((e: any) => LogEntry.fromJSON(e))
        : [],
      loadBalancers: globalThis.Array.isArray(object?.loadBalancers)
        ? object.loadBalancers.map((e: any) => LoadBalancer.fromJSON(e))
        : [],
      cloudArmor: isSet(object.cloudArmor) ? CloudArmor.fromJSON(object.cloudArmor) : undefined,
      notebook: isSet(object.notebook) ? Notebook.fromJSON(object.notebook) : undefined,
      toxicCombination: isSet(object.toxicCombination) ? ToxicCombination.fromJSON(object.toxicCombination) : undefined,
      groupMemberships: globalThis.Array.isArray(object?.groupMemberships)
        ? object.groupMemberships.map((e: any) => GroupMembership.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Finding): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.state !== 0) {
      obj.state = finding_StateToJSON(message.state);
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.externalUri !== "") {
      obj.externalUri = message.externalUri;
    }
    if (message.sourceProperties) {
      const entries = Object.entries(message.sourceProperties);
      if (entries.length > 0) {
        obj.sourceProperties = {};
        entries.forEach(([k, v]) => {
          obj.sourceProperties[k] = v;
        });
      }
    }
    if (message.securityMarks !== undefined) {
      obj.securityMarks = SecurityMarks.toJSON(message.securityMarks);
    }
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.severity !== 0) {
      obj.severity = finding_SeverityToJSON(message.severity);
    }
    if (message.canonicalName !== "") {
      obj.canonicalName = message.canonicalName;
    }
    if (message.mute !== 0) {
      obj.mute = finding_MuteToJSON(message.mute);
    }
    if (message.findingClass !== 0) {
      obj.findingClass = finding_FindingClassToJSON(message.findingClass);
    }
    if (message.indicator !== undefined) {
      obj.indicator = Indicator.toJSON(message.indicator);
    }
    if (message.vulnerability !== undefined) {
      obj.vulnerability = Vulnerability.toJSON(message.vulnerability);
    }
    if (message.muteUpdateTime !== undefined) {
      obj.muteUpdateTime = message.muteUpdateTime.toISOString();
    }
    if (message.externalSystems) {
      const entries = Object.entries(message.externalSystems);
      if (entries.length > 0) {
        obj.externalSystems = {};
        entries.forEach(([k, v]) => {
          obj.externalSystems[k] = ExternalSystem.toJSON(v);
        });
      }
    }
    if (message.mitreAttack !== undefined) {
      obj.mitreAttack = MitreAttack.toJSON(message.mitreAttack);
    }
    if (message.access !== undefined) {
      obj.access = Access.toJSON(message.access);
    }
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => Connection.toJSON(e));
    }
    if (message.muteInitiator !== "") {
      obj.muteInitiator = message.muteInitiator;
    }
    if (message.muteInfo !== undefined) {
      obj.muteInfo = Finding_MuteInfo.toJSON(message.muteInfo);
    }
    if (message.processes?.length) {
      obj.processes = message.processes.map((e) => Process.toJSON(e));
    }
    if (message.contacts) {
      const entries = Object.entries(message.contacts);
      if (entries.length > 0) {
        obj.contacts = {};
        entries.forEach(([k, v]) => {
          obj.contacts[k] = ContactDetails.toJSON(v);
        });
      }
    }
    if (message.compliances?.length) {
      obj.compliances = message.compliances.map((e) => Compliance.toJSON(e));
    }
    if (message.parentDisplayName !== "") {
      obj.parentDisplayName = message.parentDisplayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.exfiltration !== undefined) {
      obj.exfiltration = Exfiltration.toJSON(message.exfiltration);
    }
    if (message.iamBindings?.length) {
      obj.iamBindings = message.iamBindings.map((e) => IamBinding.toJSON(e));
    }
    if (message.nextSteps !== "") {
      obj.nextSteps = message.nextSteps;
    }
    if (message.moduleName !== "") {
      obj.moduleName = message.moduleName;
    }
    if (message.containers?.length) {
      obj.containers = message.containers.map((e) => Container.toJSON(e));
    }
    if (message.kubernetes !== undefined) {
      obj.kubernetes = Kubernetes.toJSON(message.kubernetes);
    }
    if (message.database !== undefined) {
      obj.database = Database.toJSON(message.database);
    }
    if (message.attackExposure !== undefined) {
      obj.attackExposure = AttackExposure.toJSON(message.attackExposure);
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => File.toJSON(e));
    }
    if (message.cloudDlpInspection !== undefined) {
      obj.cloudDlpInspection = CloudDlpInspection.toJSON(message.cloudDlpInspection);
    }
    if (message.cloudDlpDataProfile !== undefined) {
      obj.cloudDlpDataProfile = CloudDlpDataProfile.toJSON(message.cloudDlpDataProfile);
    }
    if (message.kernelRootkit !== undefined) {
      obj.kernelRootkit = KernelRootkit.toJSON(message.kernelRootkit);
    }
    if (message.orgPolicies?.length) {
      obj.orgPolicies = message.orgPolicies.map((e) => OrgPolicy.toJSON(e));
    }
    if (message.application !== undefined) {
      obj.application = Application.toJSON(message.application);
    }
    if (message.backupDisasterRecovery !== undefined) {
      obj.backupDisasterRecovery = BackupDisasterRecovery.toJSON(message.backupDisasterRecovery);
    }
    if (message.securityPosture !== undefined) {
      obj.securityPosture = SecurityPosture.toJSON(message.securityPosture);
    }
    if (message.logEntries?.length) {
      obj.logEntries = message.logEntries.map((e) => LogEntry.toJSON(e));
    }
    if (message.loadBalancers?.length) {
      obj.loadBalancers = message.loadBalancers.map((e) => LoadBalancer.toJSON(e));
    }
    if (message.cloudArmor !== undefined) {
      obj.cloudArmor = CloudArmor.toJSON(message.cloudArmor);
    }
    if (message.notebook !== undefined) {
      obj.notebook = Notebook.toJSON(message.notebook);
    }
    if (message.toxicCombination !== undefined) {
      obj.toxicCombination = ToxicCombination.toJSON(message.toxicCombination);
    }
    if (message.groupMemberships?.length) {
      obj.groupMemberships = message.groupMemberships.map((e) => GroupMembership.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Finding>): Finding {
    return Finding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Finding>): Finding {
    const message = createBaseFinding();
    message.name = object.name ?? "";
    message.parent = object.parent ?? "";
    message.resourceName = object.resourceName ?? "";
    message.state = object.state ?? 0;
    message.category = object.category ?? "";
    message.externalUri = object.externalUri ?? "";
    message.sourceProperties = Object.entries(object.sourceProperties ?? {}).reduce<{ [key: string]: any | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.securityMarks = (object.securityMarks !== undefined && object.securityMarks !== null)
      ? SecurityMarks.fromPartial(object.securityMarks)
      : undefined;
    message.eventTime = object.eventTime ?? undefined;
    message.createTime = object.createTime ?? undefined;
    message.severity = object.severity ?? 0;
    message.canonicalName = object.canonicalName ?? "";
    message.mute = object.mute ?? 0;
    message.findingClass = object.findingClass ?? 0;
    message.indicator = (object.indicator !== undefined && object.indicator !== null)
      ? Indicator.fromPartial(object.indicator)
      : undefined;
    message.vulnerability = (object.vulnerability !== undefined && object.vulnerability !== null)
      ? Vulnerability.fromPartial(object.vulnerability)
      : undefined;
    message.muteUpdateTime = object.muteUpdateTime ?? undefined;
    message.externalSystems = Object.entries(object.externalSystems ?? {}).reduce<{ [key: string]: ExternalSystem }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ExternalSystem.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.mitreAttack = (object.mitreAttack !== undefined && object.mitreAttack !== null)
      ? MitreAttack.fromPartial(object.mitreAttack)
      : undefined;
    message.access = (object.access !== undefined && object.access !== null)
      ? Access.fromPartial(object.access)
      : undefined;
    message.connections = object.connections?.map((e) => Connection.fromPartial(e)) || [];
    message.muteInitiator = object.muteInitiator ?? "";
    message.muteInfo = (object.muteInfo !== undefined && object.muteInfo !== null)
      ? Finding_MuteInfo.fromPartial(object.muteInfo)
      : undefined;
    message.processes = object.processes?.map((e) => Process.fromPartial(e)) || [];
    message.contacts = Object.entries(object.contacts ?? {}).reduce<{ [key: string]: ContactDetails }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ContactDetails.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.compliances = object.compliances?.map((e) => Compliance.fromPartial(e)) || [];
    message.parentDisplayName = object.parentDisplayName ?? "";
    message.description = object.description ?? "";
    message.exfiltration = (object.exfiltration !== undefined && object.exfiltration !== null)
      ? Exfiltration.fromPartial(object.exfiltration)
      : undefined;
    message.iamBindings = object.iamBindings?.map((e) => IamBinding.fromPartial(e)) || [];
    message.nextSteps = object.nextSteps ?? "";
    message.moduleName = object.moduleName ?? "";
    message.containers = object.containers?.map((e) => Container.fromPartial(e)) || [];
    message.kubernetes = (object.kubernetes !== undefined && object.kubernetes !== null)
      ? Kubernetes.fromPartial(object.kubernetes)
      : undefined;
    message.database = (object.database !== undefined && object.database !== null)
      ? Database.fromPartial(object.database)
      : undefined;
    message.attackExposure = (object.attackExposure !== undefined && object.attackExposure !== null)
      ? AttackExposure.fromPartial(object.attackExposure)
      : undefined;
    message.files = object.files?.map((e) => File.fromPartial(e)) || [];
    message.cloudDlpInspection = (object.cloudDlpInspection !== undefined && object.cloudDlpInspection !== null)
      ? CloudDlpInspection.fromPartial(object.cloudDlpInspection)
      : undefined;
    message.cloudDlpDataProfile = (object.cloudDlpDataProfile !== undefined && object.cloudDlpDataProfile !== null)
      ? CloudDlpDataProfile.fromPartial(object.cloudDlpDataProfile)
      : undefined;
    message.kernelRootkit = (object.kernelRootkit !== undefined && object.kernelRootkit !== null)
      ? KernelRootkit.fromPartial(object.kernelRootkit)
      : undefined;
    message.orgPolicies = object.orgPolicies?.map((e) => OrgPolicy.fromPartial(e)) || [];
    message.application = (object.application !== undefined && object.application !== null)
      ? Application.fromPartial(object.application)
      : undefined;
    message.backupDisasterRecovery =
      (object.backupDisasterRecovery !== undefined && object.backupDisasterRecovery !== null)
        ? BackupDisasterRecovery.fromPartial(object.backupDisasterRecovery)
        : undefined;
    message.securityPosture = (object.securityPosture !== undefined && object.securityPosture !== null)
      ? SecurityPosture.fromPartial(object.securityPosture)
      : undefined;
    message.logEntries = object.logEntries?.map((e) => LogEntry.fromPartial(e)) || [];
    message.loadBalancers = object.loadBalancers?.map((e) => LoadBalancer.fromPartial(e)) || [];
    message.cloudArmor = (object.cloudArmor !== undefined && object.cloudArmor !== null)
      ? CloudArmor.fromPartial(object.cloudArmor)
      : undefined;
    message.notebook = (object.notebook !== undefined && object.notebook !== null)
      ? Notebook.fromPartial(object.notebook)
      : undefined;
    message.toxicCombination = (object.toxicCombination !== undefined && object.toxicCombination !== null)
      ? ToxicCombination.fromPartial(object.toxicCombination)
      : undefined;
    message.groupMemberships = object.groupMemberships?.map((e) => GroupMembership.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinding_MuteInfo(): Finding_MuteInfo {
  return { staticMute: undefined, dynamicMuteRecords: [] };
}

export const Finding_MuteInfo: MessageFns<Finding_MuteInfo> = {
  encode(message: Finding_MuteInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.staticMute !== undefined) {
      Finding_MuteInfo_StaticMute.encode(message.staticMute, writer.uint32(10).fork()).join();
    }
    for (const v of message.dynamicMuteRecords) {
      Finding_MuteInfo_DynamicMuteRecord.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Finding_MuteInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinding_MuteInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.staticMute = Finding_MuteInfo_StaticMute.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dynamicMuteRecords.push(Finding_MuteInfo_DynamicMuteRecord.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Finding_MuteInfo {
    return {
      staticMute: isSet(object.staticMute) ? Finding_MuteInfo_StaticMute.fromJSON(object.staticMute) : undefined,
      dynamicMuteRecords: globalThis.Array.isArray(object?.dynamicMuteRecords)
        ? object.dynamicMuteRecords.map((e: any) => Finding_MuteInfo_DynamicMuteRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Finding_MuteInfo): unknown {
    const obj: any = {};
    if (message.staticMute !== undefined) {
      obj.staticMute = Finding_MuteInfo_StaticMute.toJSON(message.staticMute);
    }
    if (message.dynamicMuteRecords?.length) {
      obj.dynamicMuteRecords = message.dynamicMuteRecords.map((e) => Finding_MuteInfo_DynamicMuteRecord.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Finding_MuteInfo>): Finding_MuteInfo {
    return Finding_MuteInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Finding_MuteInfo>): Finding_MuteInfo {
    const message = createBaseFinding_MuteInfo();
    message.staticMute = (object.staticMute !== undefined && object.staticMute !== null)
      ? Finding_MuteInfo_StaticMute.fromPartial(object.staticMute)
      : undefined;
    message.dynamicMuteRecords =
      object.dynamicMuteRecords?.map((e) => Finding_MuteInfo_DynamicMuteRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinding_MuteInfo_StaticMute(): Finding_MuteInfo_StaticMute {
  return { state: 0, applyTime: undefined };
}

export const Finding_MuteInfo_StaticMute: MessageFns<Finding_MuteInfo_StaticMute> = {
  encode(message: Finding_MuteInfo_StaticMute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.applyTime !== undefined) {
      Timestamp.encode(toTimestamp(message.applyTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Finding_MuteInfo_StaticMute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinding_MuteInfo_StaticMute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.applyTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Finding_MuteInfo_StaticMute {
    return {
      state: isSet(object.state) ? finding_MuteFromJSON(object.state) : 0,
      applyTime: isSet(object.applyTime) ? fromJsonTimestamp(object.applyTime) : undefined,
    };
  },

  toJSON(message: Finding_MuteInfo_StaticMute): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = finding_MuteToJSON(message.state);
    }
    if (message.applyTime !== undefined) {
      obj.applyTime = message.applyTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Finding_MuteInfo_StaticMute>): Finding_MuteInfo_StaticMute {
    return Finding_MuteInfo_StaticMute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Finding_MuteInfo_StaticMute>): Finding_MuteInfo_StaticMute {
    const message = createBaseFinding_MuteInfo_StaticMute();
    message.state = object.state ?? 0;
    message.applyTime = object.applyTime ?? undefined;
    return message;
  },
};

function createBaseFinding_MuteInfo_DynamicMuteRecord(): Finding_MuteInfo_DynamicMuteRecord {
  return { muteConfig: "", matchTime: undefined };
}

export const Finding_MuteInfo_DynamicMuteRecord: MessageFns<Finding_MuteInfo_DynamicMuteRecord> = {
  encode(message: Finding_MuteInfo_DynamicMuteRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.muteConfig !== "") {
      writer.uint32(10).string(message.muteConfig);
    }
    if (message.matchTime !== undefined) {
      Timestamp.encode(toTimestamp(message.matchTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Finding_MuteInfo_DynamicMuteRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinding_MuteInfo_DynamicMuteRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.muteConfig = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.matchTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Finding_MuteInfo_DynamicMuteRecord {
    return {
      muteConfig: isSet(object.muteConfig) ? globalThis.String(object.muteConfig) : "",
      matchTime: isSet(object.matchTime) ? fromJsonTimestamp(object.matchTime) : undefined,
    };
  },

  toJSON(message: Finding_MuteInfo_DynamicMuteRecord): unknown {
    const obj: any = {};
    if (message.muteConfig !== "") {
      obj.muteConfig = message.muteConfig;
    }
    if (message.matchTime !== undefined) {
      obj.matchTime = message.matchTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Finding_MuteInfo_DynamicMuteRecord>): Finding_MuteInfo_DynamicMuteRecord {
    return Finding_MuteInfo_DynamicMuteRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Finding_MuteInfo_DynamicMuteRecord>): Finding_MuteInfo_DynamicMuteRecord {
    const message = createBaseFinding_MuteInfo_DynamicMuteRecord();
    message.muteConfig = object.muteConfig ?? "";
    message.matchTime = object.matchTime ?? undefined;
    return message;
  },
};

function createBaseFinding_SourcePropertiesEntry(): Finding_SourcePropertiesEntry {
  return { key: "", value: undefined };
}

export const Finding_SourcePropertiesEntry: MessageFns<Finding_SourcePropertiesEntry> = {
  encode(message: Finding_SourcePropertiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Finding_SourcePropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinding_SourcePropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Finding_SourcePropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: Finding_SourcePropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Finding_SourcePropertiesEntry>): Finding_SourcePropertiesEntry {
    return Finding_SourcePropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Finding_SourcePropertiesEntry>): Finding_SourcePropertiesEntry {
    const message = createBaseFinding_SourcePropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseFinding_ExternalSystemsEntry(): Finding_ExternalSystemsEntry {
  return { key: "", value: undefined };
}

export const Finding_ExternalSystemsEntry: MessageFns<Finding_ExternalSystemsEntry> = {
  encode(message: Finding_ExternalSystemsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ExternalSystem.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Finding_ExternalSystemsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinding_ExternalSystemsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ExternalSystem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Finding_ExternalSystemsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ExternalSystem.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Finding_ExternalSystemsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ExternalSystem.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Finding_ExternalSystemsEntry>): Finding_ExternalSystemsEntry {
    return Finding_ExternalSystemsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Finding_ExternalSystemsEntry>): Finding_ExternalSystemsEntry {
    const message = createBaseFinding_ExternalSystemsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ExternalSystem.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseFinding_ContactsEntry(): Finding_ContactsEntry {
  return { key: "", value: undefined };
}

export const Finding_ContactsEntry: MessageFns<Finding_ContactsEntry> = {
  encode(message: Finding_ContactsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ContactDetails.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Finding_ContactsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinding_ContactsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ContactDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Finding_ContactsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ContactDetails.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Finding_ContactsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ContactDetails.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Finding_ContactsEntry>): Finding_ContactsEntry {
    return Finding_ContactsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Finding_ContactsEntry>): Finding_ContactsEntry {
    const message = createBaseFinding_ContactsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ContactDetails.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
