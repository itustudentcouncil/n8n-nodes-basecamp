// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/iot/v1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";

export const protobufPackage = "google.cloud.iot.v1";

/**
 * Indicates whether an MQTT connection is enabled or disabled. See the field
 * description for details.
 */
export enum MqttState {
  /** MQTT_STATE_UNSPECIFIED - No MQTT state specified. If not specified, MQTT will be enabled by default. */
  MQTT_STATE_UNSPECIFIED = 0,
  /** MQTT_ENABLED - Enables a MQTT connection. */
  MQTT_ENABLED = 1,
  /** MQTT_DISABLED - Disables a MQTT connection. */
  MQTT_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function mqttStateFromJSON(object: any): MqttState {
  switch (object) {
    case 0:
    case "MQTT_STATE_UNSPECIFIED":
      return MqttState.MQTT_STATE_UNSPECIFIED;
    case 1:
    case "MQTT_ENABLED":
      return MqttState.MQTT_ENABLED;
    case 2:
    case "MQTT_DISABLED":
      return MqttState.MQTT_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MqttState.UNRECOGNIZED;
  }
}

export function mqttStateToJSON(object: MqttState): string {
  switch (object) {
    case MqttState.MQTT_STATE_UNSPECIFIED:
      return "MQTT_STATE_UNSPECIFIED";
    case MqttState.MQTT_ENABLED:
      return "MQTT_ENABLED";
    case MqttState.MQTT_DISABLED:
      return "MQTT_DISABLED";
    case MqttState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Indicates whether DeviceService (HTTP) is enabled or disabled for the
 * registry. See the field description for details.
 */
export enum HttpState {
  /**
   * HTTP_STATE_UNSPECIFIED - No HTTP state specified. If not specified, DeviceService will be
   * enabled by default.
   */
  HTTP_STATE_UNSPECIFIED = 0,
  /** HTTP_ENABLED - Enables DeviceService (HTTP) service for the registry. */
  HTTP_ENABLED = 1,
  /** HTTP_DISABLED - Disables DeviceService (HTTP) service for the registry. */
  HTTP_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function httpStateFromJSON(object: any): HttpState {
  switch (object) {
    case 0:
    case "HTTP_STATE_UNSPECIFIED":
      return HttpState.HTTP_STATE_UNSPECIFIED;
    case 1:
    case "HTTP_ENABLED":
      return HttpState.HTTP_ENABLED;
    case 2:
    case "HTTP_DISABLED":
      return HttpState.HTTP_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HttpState.UNRECOGNIZED;
  }
}

export function httpStateToJSON(object: HttpState): string {
  switch (object) {
    case HttpState.HTTP_STATE_UNSPECIFIED:
      return "HTTP_STATE_UNSPECIFIED";
    case HttpState.HTTP_ENABLED:
      return "HTTP_ENABLED";
    case HttpState.HTTP_DISABLED:
      return "HTTP_DISABLED";
    case HttpState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * *Beta Feature**
 *
 * The logging verbosity for device activity. Specifies which events should be
 * written to logs. For example, if the LogLevel is ERROR, only events that
 * terminate in errors will be logged. LogLevel is inclusive; enabling INFO
 * logging will also enable ERROR logging.
 */
export enum LogLevel {
  /** LOG_LEVEL_UNSPECIFIED - No logging specified. If not specified, logging will be disabled. */
  LOG_LEVEL_UNSPECIFIED = 0,
  /** NONE - Disables logging. */
  NONE = 10,
  /** ERROR - Error events will be logged. */
  ERROR = 20,
  /**
   * INFO - Informational events will be logged, such as connections and
   * disconnections.
   */
  INFO = 30,
  /** DEBUG - All events will be logged. */
  DEBUG = 40,
  UNRECOGNIZED = -1,
}

export function logLevelFromJSON(object: any): LogLevel {
  switch (object) {
    case 0:
    case "LOG_LEVEL_UNSPECIFIED":
      return LogLevel.LOG_LEVEL_UNSPECIFIED;
    case 10:
    case "NONE":
      return LogLevel.NONE;
    case 20:
    case "ERROR":
      return LogLevel.ERROR;
    case 30:
    case "INFO":
      return LogLevel.INFO;
    case 40:
    case "DEBUG":
      return LogLevel.DEBUG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LogLevel.UNRECOGNIZED;
  }
}

export function logLevelToJSON(object: LogLevel): string {
  switch (object) {
    case LogLevel.LOG_LEVEL_UNSPECIFIED:
      return "LOG_LEVEL_UNSPECIFIED";
    case LogLevel.NONE:
      return "NONE";
    case LogLevel.ERROR:
      return "ERROR";
    case LogLevel.INFO:
      return "INFO";
    case LogLevel.DEBUG:
      return "DEBUG";
    case LogLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Gateway type. */
export enum GatewayType {
  /** GATEWAY_TYPE_UNSPECIFIED - If unspecified, the device is considered a non-gateway device. */
  GATEWAY_TYPE_UNSPECIFIED = 0,
  /** GATEWAY - The device is a gateway. */
  GATEWAY = 1,
  /** NON_GATEWAY - The device is not a gateway. */
  NON_GATEWAY = 2,
  UNRECOGNIZED = -1,
}

export function gatewayTypeFromJSON(object: any): GatewayType {
  switch (object) {
    case 0:
    case "GATEWAY_TYPE_UNSPECIFIED":
      return GatewayType.GATEWAY_TYPE_UNSPECIFIED;
    case 1:
    case "GATEWAY":
      return GatewayType.GATEWAY;
    case 2:
    case "NON_GATEWAY":
      return GatewayType.NON_GATEWAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GatewayType.UNRECOGNIZED;
  }
}

export function gatewayTypeToJSON(object: GatewayType): string {
  switch (object) {
    case GatewayType.GATEWAY_TYPE_UNSPECIFIED:
      return "GATEWAY_TYPE_UNSPECIFIED";
    case GatewayType.GATEWAY:
      return "GATEWAY";
    case GatewayType.NON_GATEWAY:
      return "NON_GATEWAY";
    case GatewayType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The gateway authorization/authentication method. This setting determines how
 * Cloud IoT Core authorizes/authenticate devices to access the gateway.
 */
export enum GatewayAuthMethod {
  /**
   * GATEWAY_AUTH_METHOD_UNSPECIFIED - No authentication/authorization method specified. No devices are allowed to
   * access the gateway.
   */
  GATEWAY_AUTH_METHOD_UNSPECIFIED = 0,
  /**
   * ASSOCIATION_ONLY - The device is authenticated through the gateway association only. Device
   * credentials are ignored even if provided.
   */
  ASSOCIATION_ONLY = 1,
  /**
   * DEVICE_AUTH_TOKEN_ONLY - The device is authenticated through its own credentials. Gateway
   * association is not checked.
   */
  DEVICE_AUTH_TOKEN_ONLY = 2,
  /**
   * ASSOCIATION_AND_DEVICE_AUTH_TOKEN - The device is authenticated through both device credentials and gateway
   * association. The device must be bound to the gateway and must provide its
   * own credentials.
   */
  ASSOCIATION_AND_DEVICE_AUTH_TOKEN = 3,
  UNRECOGNIZED = -1,
}

export function gatewayAuthMethodFromJSON(object: any): GatewayAuthMethod {
  switch (object) {
    case 0:
    case "GATEWAY_AUTH_METHOD_UNSPECIFIED":
      return GatewayAuthMethod.GATEWAY_AUTH_METHOD_UNSPECIFIED;
    case 1:
    case "ASSOCIATION_ONLY":
      return GatewayAuthMethod.ASSOCIATION_ONLY;
    case 2:
    case "DEVICE_AUTH_TOKEN_ONLY":
      return GatewayAuthMethod.DEVICE_AUTH_TOKEN_ONLY;
    case 3:
    case "ASSOCIATION_AND_DEVICE_AUTH_TOKEN":
      return GatewayAuthMethod.ASSOCIATION_AND_DEVICE_AUTH_TOKEN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GatewayAuthMethod.UNRECOGNIZED;
  }
}

export function gatewayAuthMethodToJSON(object: GatewayAuthMethod): string {
  switch (object) {
    case GatewayAuthMethod.GATEWAY_AUTH_METHOD_UNSPECIFIED:
      return "GATEWAY_AUTH_METHOD_UNSPECIFIED";
    case GatewayAuthMethod.ASSOCIATION_ONLY:
      return "ASSOCIATION_ONLY";
    case GatewayAuthMethod.DEVICE_AUTH_TOKEN_ONLY:
      return "DEVICE_AUTH_TOKEN_ONLY";
    case GatewayAuthMethod.ASSOCIATION_AND_DEVICE_AUTH_TOKEN:
      return "ASSOCIATION_AND_DEVICE_AUTH_TOKEN";
    case GatewayAuthMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The supported formats for the public key. */
export enum PublicKeyCertificateFormat {
  /**
   * UNSPECIFIED_PUBLIC_KEY_CERTIFICATE_FORMAT - The format has not been specified. This is an invalid default value and
   * must not be used.
   */
  UNSPECIFIED_PUBLIC_KEY_CERTIFICATE_FORMAT = 0,
  /**
   * X509_CERTIFICATE_PEM - An X.509v3 certificate ([RFC5280](https://www.ietf.org/rfc/rfc5280.txt)),
   * encoded in base64, and wrapped by `-----BEGIN CERTIFICATE-----` and
   * `-----END CERTIFICATE-----`.
   */
  X509_CERTIFICATE_PEM = 1,
  UNRECOGNIZED = -1,
}

export function publicKeyCertificateFormatFromJSON(object: any): PublicKeyCertificateFormat {
  switch (object) {
    case 0:
    case "UNSPECIFIED_PUBLIC_KEY_CERTIFICATE_FORMAT":
      return PublicKeyCertificateFormat.UNSPECIFIED_PUBLIC_KEY_CERTIFICATE_FORMAT;
    case 1:
    case "X509_CERTIFICATE_PEM":
      return PublicKeyCertificateFormat.X509_CERTIFICATE_PEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PublicKeyCertificateFormat.UNRECOGNIZED;
  }
}

export function publicKeyCertificateFormatToJSON(object: PublicKeyCertificateFormat): string {
  switch (object) {
    case PublicKeyCertificateFormat.UNSPECIFIED_PUBLIC_KEY_CERTIFICATE_FORMAT:
      return "UNSPECIFIED_PUBLIC_KEY_CERTIFICATE_FORMAT";
    case PublicKeyCertificateFormat.X509_CERTIFICATE_PEM:
      return "X509_CERTIFICATE_PEM";
    case PublicKeyCertificateFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The supported formats for the public key. */
export enum PublicKeyFormat {
  /**
   * UNSPECIFIED_PUBLIC_KEY_FORMAT - The format has not been specified. This is an invalid default value and
   * must not be used.
   */
  UNSPECIFIED_PUBLIC_KEY_FORMAT = 0,
  /**
   * RSA_PEM - An RSA public key encoded in base64, and wrapped by
   * `-----BEGIN PUBLIC KEY-----` and `-----END PUBLIC KEY-----`. This can be
   * used to verify `RS256` signatures in JWT tokens ([RFC7518](
   * https://www.ietf.org/rfc/rfc7518.txt)).
   */
  RSA_PEM = 3,
  /**
   * RSA_X509_PEM - As RSA_PEM, but wrapped in an X.509v3 certificate ([RFC5280](
   * https://www.ietf.org/rfc/rfc5280.txt)), encoded in base64, and wrapped by
   * `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----`.
   */
  RSA_X509_PEM = 1,
  /**
   * ES256_PEM - Public key for the ECDSA algorithm using P-256 and SHA-256, encoded in
   * base64, and wrapped by `-----BEGIN PUBLIC KEY-----` and `-----END
   * PUBLIC KEY-----`. This can be used to verify JWT tokens with the `ES256`
   * algorithm ([RFC7518](https://www.ietf.org/rfc/rfc7518.txt)). This curve is
   * defined in [OpenSSL](https://www.openssl.org/) as the `prime256v1` curve.
   */
  ES256_PEM = 2,
  /**
   * ES256_X509_PEM - As ES256_PEM, but wrapped in an X.509v3 certificate ([RFC5280](
   * https://www.ietf.org/rfc/rfc5280.txt)), encoded in base64, and wrapped by
   * `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----`.
   */
  ES256_X509_PEM = 4,
  UNRECOGNIZED = -1,
}

export function publicKeyFormatFromJSON(object: any): PublicKeyFormat {
  switch (object) {
    case 0:
    case "UNSPECIFIED_PUBLIC_KEY_FORMAT":
      return PublicKeyFormat.UNSPECIFIED_PUBLIC_KEY_FORMAT;
    case 3:
    case "RSA_PEM":
      return PublicKeyFormat.RSA_PEM;
    case 1:
    case "RSA_X509_PEM":
      return PublicKeyFormat.RSA_X509_PEM;
    case 2:
    case "ES256_PEM":
      return PublicKeyFormat.ES256_PEM;
    case 4:
    case "ES256_X509_PEM":
      return PublicKeyFormat.ES256_X509_PEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PublicKeyFormat.UNRECOGNIZED;
  }
}

export function publicKeyFormatToJSON(object: PublicKeyFormat): string {
  switch (object) {
    case PublicKeyFormat.UNSPECIFIED_PUBLIC_KEY_FORMAT:
      return "UNSPECIFIED_PUBLIC_KEY_FORMAT";
    case PublicKeyFormat.RSA_PEM:
      return "RSA_PEM";
    case PublicKeyFormat.RSA_X509_PEM:
      return "RSA_X509_PEM";
    case PublicKeyFormat.ES256_PEM:
      return "ES256_PEM";
    case PublicKeyFormat.ES256_X509_PEM:
      return "ES256_X509_PEM";
    case PublicKeyFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The device resource. */
export interface Device {
  /**
   * The user-defined device identifier. The device ID must be unique
   * within a device registry.
   */
  id: string;
  /**
   * The resource path name. For example,
   * `projects/p1/locations/us-central1/registries/registry0/devices/dev0` or
   * `projects/p1/locations/us-central1/registries/registry0/devices/{num_id}`.
   * When `name` is populated as a response from the service, it always ends
   * in the device numeric ID.
   */
  name: string;
  /**
   * [Output only] A server-defined unique numeric ID for the device. This is a
   * more compact way to identify devices, and it is globally unique.
   */
  numId: Long;
  /**
   * The credentials used to authenticate this device. To allow credential
   * rotation without interruption, multiple device credentials can be bound to
   * this device. No more than 3 credentials can be bound to a single device at
   * a time. When new credentials are added to a device, they are verified
   * against the registry credentials. For details, see the description of the
   * `DeviceRegistry.credentials` field.
   */
  credentials: DeviceCredential[];
  /**
   * [Output only] The last time an MQTT `PINGREQ` was received. This field
   * applies only to devices connecting through MQTT. MQTT clients usually only
   * send `PINGREQ` messages if the connection is idle, and no other messages
   * have been sent. Timestamps are periodically collected and written to
   * storage; they may be stale by a few minutes.
   */
  lastHeartbeatTime:
    | Date
    | undefined;
  /**
   * [Output only] The last time a telemetry event was received. Timestamps are
   * periodically collected and written to storage; they may be stale by a few
   * minutes.
   */
  lastEventTime:
    | Date
    | undefined;
  /**
   * [Output only] The last time a state event was received. Timestamps are
   * periodically collected and written to storage; they may be stale by a few
   * minutes.
   */
  lastStateTime:
    | Date
    | undefined;
  /**
   * [Output only] The last time a cloud-to-device config version acknowledgment
   * was received from the device. This field is only for configurations
   * sent through MQTT.
   */
  lastConfigAckTime:
    | Date
    | undefined;
  /**
   * [Output only] The last time a cloud-to-device config version was sent to
   * the device.
   */
  lastConfigSendTime:
    | Date
    | undefined;
  /**
   * If a device is blocked, connections or requests from this device will fail.
   * Can be used to temporarily prevent the device from connecting if, for
   * example, the sensor is generating bad data and needs maintenance.
   */
  blocked: boolean;
  /**
   * [Output only] The time the most recent error occurred, such as a failure to
   * publish to Cloud Pub/Sub. This field is the timestamp of
   * 'last_error_status'.
   */
  lastErrorTime:
    | Date
    | undefined;
  /**
   * [Output only] The error message of the most recent error, such as a failure
   * to publish to Cloud Pub/Sub. 'last_error_time' is the timestamp of this
   * field. If no errors have occurred, this field has an empty message
   * and the status code 0 == OK. Otherwise, this field is expected to have a
   * status code other than OK.
   */
  lastErrorStatus:
    | Status
    | undefined;
  /**
   * The most recent device configuration, which is eventually sent from
   * Cloud IoT Core to the device. If not present on creation, the
   * configuration will be initialized with an empty payload and version value
   * of `1`. To update this field after creation, use the
   * `DeviceManager.ModifyCloudToDeviceConfig` method.
   */
  config:
    | DeviceConfig
    | undefined;
  /**
   * [Output only] The state most recently received from the device. If no state
   * has been reported, this field is not present.
   */
  state:
    | DeviceState
    | undefined;
  /**
   * *Beta Feature**
   *
   * The logging verbosity for device activity. If unspecified,
   * DeviceRegistry.log_level will be used.
   */
  logLevel: LogLevel;
  /**
   * The metadata key-value pairs assigned to the device. This metadata is not
   * interpreted or indexed by Cloud IoT Core. It can be used to add contextual
   * information for the device.
   *
   * Keys must conform to the regular expression [a-zA-Z][a-zA-Z0-9-_.+~%]+ and
   * be less than 128 bytes in length.
   *
   * Values are free-form strings. Each value must be less than or equal to 32
   * KB in size.
   *
   * The total size of all keys and values must be less than 256 KB, and the
   * maximum number of key-value pairs is 500.
   */
  metadata: { [key: string]: string };
  /** Gateway-related configuration and state. */
  gatewayConfig: GatewayConfig | undefined;
}

export interface Device_MetadataEntry {
  key: string;
  value: string;
}

/** Gateway-related configuration and state. */
export interface GatewayConfig {
  /** Indicates whether the device is a gateway. */
  gatewayType: GatewayType;
  /**
   * Indicates how to authorize and/or authenticate devices to access the
   * gateway.
   */
  gatewayAuthMethod: GatewayAuthMethod;
  /** [Output only] The ID of the gateway the device accessed most recently. */
  lastAccessedGatewayId: string;
  /**
   * [Output only] The most recent time at which the device accessed the gateway
   * specified in `last_accessed_gateway`.
   */
  lastAccessedGatewayTime: Date | undefined;
}

/** A container for a group of devices. */
export interface DeviceRegistry {
  /** The identifier of this device registry. For example, `myRegistry`. */
  id: string;
  /**
   * The resource path name. For example,
   * `projects/example-project/locations/us-central1/registries/my-registry`.
   */
  name: string;
  /**
   * The configuration for notification of telemetry events received from the
   * device. All telemetry events that were successfully published by the
   * device and acknowledged by Cloud IoT Core are guaranteed to be
   * delivered to Cloud Pub/Sub. If multiple configurations match a message,
   * only the first matching configuration is used. If you try to publish a
   * device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
   * for the device's registry, the connection closes automatically. If you try
   * to do so using an HTTP connection, an error is returned. Up to 10
   * configurations may be provided.
   */
  eventNotificationConfigs: EventNotificationConfig[];
  /**
   * The configuration for notification of new states received from the device.
   * State updates are guaranteed to be stored in the state history, but
   * notifications to Cloud Pub/Sub are not guaranteed. For example, if
   * permissions are misconfigured or the specified topic doesn't exist, no
   * notification will be published but the state will still be stored in Cloud
   * IoT Core.
   */
  stateNotificationConfig:
    | StateNotificationConfig
    | undefined;
  /** The MQTT configuration for this device registry. */
  mqttConfig:
    | MqttConfig
    | undefined;
  /** The DeviceService (HTTP) configuration for this device registry. */
  httpConfig:
    | HttpConfig
    | undefined;
  /**
   * *Beta Feature**
   *
   * The default logging verbosity for activity from devices in this registry.
   * The verbosity level can be overridden by Device.log_level.
   */
  logLevel: LogLevel;
  /**
   * The credentials used to verify the device credentials. No more than 10
   * credentials can be bound to a single registry at a time. The verification
   * process occurs at the time of device creation or update. If this field is
   * empty, no verification is performed. Otherwise, the credentials of a newly
   * created device or added credentials of an updated device should be signed
   * with one of these registry credentials.
   *
   * Note, however, that existing devices will never be affected by
   * modifications to this list of credentials: after a device has been
   * successfully created in a registry, it should be able to connect even if
   * its registry credentials are revoked, deleted, or modified.
   */
  credentials: RegistryCredential[];
}

/** The configuration of MQTT for a device registry. */
export interface MqttConfig {
  /**
   * If enabled, allows connections using the MQTT protocol. Otherwise, MQTT
   * connections to this registry will fail.
   */
  mqttEnabledState: MqttState;
}

/** The configuration of the HTTP bridge for a device registry. */
export interface HttpConfig {
  /**
   * If enabled, allows devices to use DeviceService via the HTTP protocol.
   * Otherwise, any requests to DeviceService will fail for this registry.
   */
  httpEnabledState: HttpState;
}

/** The configuration for forwarding telemetry events. */
export interface EventNotificationConfig {
  /**
   * If the subfolder name matches this string exactly, this configuration will
   * be used. The string must not include the leading '/' character. If empty,
   * all strings are matched. This field is used only for telemetry events;
   * subfolders are not supported for state changes.
   */
  subfolderMatches: string;
  /**
   * A Cloud Pub/Sub topic name. For example,
   * `projects/myProject/topics/deviceEvents`.
   */
  pubsubTopicName: string;
}

/** The configuration for notification of new states received from the device. */
export interface StateNotificationConfig {
  /**
   * A Cloud Pub/Sub topic name. For example,
   * `projects/myProject/topics/deviceEvents`.
   */
  pubsubTopicName: string;
}

/** A server-stored registry credential used to validate device credentials. */
export interface RegistryCredential {
  /** A public key certificate used to verify the device credentials. */
  publicKeyCertificate?: PublicKeyCertificate | undefined;
}

/** Details of an X.509 certificate. For informational purposes only. */
export interface X509CertificateDetails {
  /** The entity that signed the certificate. */
  issuer: string;
  /** The entity the certificate and public key belong to. */
  subject: string;
  /** The time the certificate becomes valid. */
  startTime:
    | Date
    | undefined;
  /** The time the certificate becomes invalid. */
  expiryTime:
    | Date
    | undefined;
  /** The algorithm used to sign the certificate. */
  signatureAlgorithm: string;
  /** The type of public key in the certificate. */
  publicKeyType: string;
}

/** A public key certificate format and data. */
export interface PublicKeyCertificate {
  /** The certificate format. */
  format: PublicKeyCertificateFormat;
  /** The certificate data. */
  certificate: string;
  /** [Output only] The certificate details. Used only for X.509 certificates. */
  x509Details: X509CertificateDetails | undefined;
}

/** A server-stored device credential used for authentication. */
export interface DeviceCredential {
  /**
   * A public key used to verify the signature of JSON Web Tokens (JWTs).
   * When adding a new device credential, either via device creation or via
   * modifications, this public key credential may be required to be signed by
   * one of the registry level certificates. More specifically, if the
   * registry contains at least one certificate, any new device credential
   * must be signed by one of the registry certificates. As a result,
   * when the registry contains certificates, only X.509 certificates are
   * accepted as device credentials. However, if the registry does
   * not contain a certificate, self-signed certificates and public keys will
   * be accepted. New device credentials must be different from every
   * registry-level certificate.
   */
  publicKey?:
    | PublicKeyCredential
    | undefined;
  /**
   * [Optional] The time at which this credential becomes invalid. This
   * credential will be ignored for new client authentication requests after
   * this timestamp; however, it will not be automatically deleted.
   */
  expirationTime: Date | undefined;
}

/** A public key format and data. */
export interface PublicKeyCredential {
  /** The format of the key. */
  format: PublicKeyFormat;
  /** The key data. */
  key: string;
}

/** The device configuration. Eventually delivered to devices. */
export interface DeviceConfig {
  /**
   * [Output only] The version of this update. The version number is assigned by
   * the server, and is always greater than 0 after device creation. The
   * version must be 0 on the `CreateDevice` request if a `config` is
   * specified; the response of `CreateDevice` will always have a value of 1.
   */
  version: Long;
  /**
   * [Output only] The time at which this configuration version was updated in
   * Cloud IoT Core. This timestamp is set by the server.
   */
  cloudUpdateTime:
    | Date
    | undefined;
  /**
   * [Output only] The time at which Cloud IoT Core received the
   * acknowledgment from the device, indicating that the device has received
   * this configuration version. If this field is not present, the device has
   * not yet acknowledged that it received this version. Note that when
   * the config was sent to the device, many config versions may have been
   * available in Cloud IoT Core while the device was disconnected, and on
   * connection, only the latest version is sent to the device. Some
   * versions may never be sent to the device, and therefore are never
   * acknowledged. This timestamp is set by Cloud IoT Core.
   */
  deviceAckTime:
    | Date
    | undefined;
  /** The device configuration data. */
  binaryData: Buffer;
}

/** The device state, as reported by the device. */
export interface DeviceState {
  /**
   * [Output only] The time at which this state version was updated in Cloud
   * IoT Core.
   */
  updateTime:
    | Date
    | undefined;
  /** The device state data. */
  binaryData: Buffer;
}

function createBaseDevice(): Device {
  return {
    id: "",
    name: "",
    numId: Long.UZERO,
    credentials: [],
    lastHeartbeatTime: undefined,
    lastEventTime: undefined,
    lastStateTime: undefined,
    lastConfigAckTime: undefined,
    lastConfigSendTime: undefined,
    blocked: false,
    lastErrorTime: undefined,
    lastErrorStatus: undefined,
    config: undefined,
    state: undefined,
    logLevel: 0,
    metadata: {},
    gatewayConfig: undefined,
  };
}

export const Device: MessageFns<Device> = {
  encode(message: Device, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (!message.numId.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.numId.toString());
    }
    for (const v of message.credentials) {
      DeviceCredential.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.lastHeartbeatTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastHeartbeatTime), writer.uint32(58).fork()).join();
    }
    if (message.lastEventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastEventTime), writer.uint32(66).fork()).join();
    }
    if (message.lastStateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastStateTime), writer.uint32(162).fork()).join();
    }
    if (message.lastConfigAckTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastConfigAckTime), writer.uint32(114).fork()).join();
    }
    if (message.lastConfigSendTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastConfigSendTime), writer.uint32(146).fork()).join();
    }
    if (message.blocked !== false) {
      writer.uint32(152).bool(message.blocked);
    }
    if (message.lastErrorTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastErrorTime), writer.uint32(82).fork()).join();
    }
    if (message.lastErrorStatus !== undefined) {
      Status.encode(message.lastErrorStatus, writer.uint32(90).fork()).join();
    }
    if (message.config !== undefined) {
      DeviceConfig.encode(message.config, writer.uint32(106).fork()).join();
    }
    if (message.state !== undefined) {
      DeviceState.encode(message.state, writer.uint32(130).fork()).join();
    }
    if (message.logLevel !== 0) {
      writer.uint32(168).int32(message.logLevel);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Device_MetadataEntry.encode({ key: key as any, value }, writer.uint32(138).fork()).join();
    });
    if (message.gatewayConfig !== undefined) {
      GatewayConfig.encode(message.gatewayConfig, writer.uint32(194).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Device {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.numId = Long.fromString(reader.uint64().toString(), true);
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.credentials.push(DeviceCredential.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lastHeartbeatTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.lastEventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.lastStateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.lastConfigAckTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.lastConfigSendTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.blocked = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.lastErrorTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.lastErrorStatus = Status.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.config = DeviceConfig.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.state = DeviceState.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.logLevel = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          const entry17 = Device_MetadataEntry.decode(reader, reader.uint32());
          if (entry17.value !== undefined) {
            message.metadata[entry17.key] = entry17.value;
          }
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.gatewayConfig = GatewayConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Device {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      numId: isSet(object.numId) ? Long.fromValue(object.numId) : Long.UZERO,
      credentials: globalThis.Array.isArray(object?.credentials)
        ? object.credentials.map((e: any) => DeviceCredential.fromJSON(e))
        : [],
      lastHeartbeatTime: isSet(object.lastHeartbeatTime) ? fromJsonTimestamp(object.lastHeartbeatTime) : undefined,
      lastEventTime: isSet(object.lastEventTime) ? fromJsonTimestamp(object.lastEventTime) : undefined,
      lastStateTime: isSet(object.lastStateTime) ? fromJsonTimestamp(object.lastStateTime) : undefined,
      lastConfigAckTime: isSet(object.lastConfigAckTime) ? fromJsonTimestamp(object.lastConfigAckTime) : undefined,
      lastConfigSendTime: isSet(object.lastConfigSendTime) ? fromJsonTimestamp(object.lastConfigSendTime) : undefined,
      blocked: isSet(object.blocked) ? globalThis.Boolean(object.blocked) : false,
      lastErrorTime: isSet(object.lastErrorTime) ? fromJsonTimestamp(object.lastErrorTime) : undefined,
      lastErrorStatus: isSet(object.lastErrorStatus) ? Status.fromJSON(object.lastErrorStatus) : undefined,
      config: isSet(object.config) ? DeviceConfig.fromJSON(object.config) : undefined,
      state: isSet(object.state) ? DeviceState.fromJSON(object.state) : undefined,
      logLevel: isSet(object.logLevel) ? logLevelFromJSON(object.logLevel) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      gatewayConfig: isSet(object.gatewayConfig) ? GatewayConfig.fromJSON(object.gatewayConfig) : undefined,
    };
  },

  toJSON(message: Device): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.numId.equals(Long.UZERO)) {
      obj.numId = (message.numId || Long.UZERO).toString();
    }
    if (message.credentials?.length) {
      obj.credentials = message.credentials.map((e) => DeviceCredential.toJSON(e));
    }
    if (message.lastHeartbeatTime !== undefined) {
      obj.lastHeartbeatTime = message.lastHeartbeatTime.toISOString();
    }
    if (message.lastEventTime !== undefined) {
      obj.lastEventTime = message.lastEventTime.toISOString();
    }
    if (message.lastStateTime !== undefined) {
      obj.lastStateTime = message.lastStateTime.toISOString();
    }
    if (message.lastConfigAckTime !== undefined) {
      obj.lastConfigAckTime = message.lastConfigAckTime.toISOString();
    }
    if (message.lastConfigSendTime !== undefined) {
      obj.lastConfigSendTime = message.lastConfigSendTime.toISOString();
    }
    if (message.blocked !== false) {
      obj.blocked = message.blocked;
    }
    if (message.lastErrorTime !== undefined) {
      obj.lastErrorTime = message.lastErrorTime.toISOString();
    }
    if (message.lastErrorStatus !== undefined) {
      obj.lastErrorStatus = Status.toJSON(message.lastErrorStatus);
    }
    if (message.config !== undefined) {
      obj.config = DeviceConfig.toJSON(message.config);
    }
    if (message.state !== undefined) {
      obj.state = DeviceState.toJSON(message.state);
    }
    if (message.logLevel !== 0) {
      obj.logLevel = logLevelToJSON(message.logLevel);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.gatewayConfig !== undefined) {
      obj.gatewayConfig = GatewayConfig.toJSON(message.gatewayConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Device>): Device {
    return Device.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Device>): Device {
    const message = createBaseDevice();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.numId = (object.numId !== undefined && object.numId !== null) ? Long.fromValue(object.numId) : Long.UZERO;
    message.credentials = object.credentials?.map((e) => DeviceCredential.fromPartial(e)) || [];
    message.lastHeartbeatTime = object.lastHeartbeatTime ?? undefined;
    message.lastEventTime = object.lastEventTime ?? undefined;
    message.lastStateTime = object.lastStateTime ?? undefined;
    message.lastConfigAckTime = object.lastConfigAckTime ?? undefined;
    message.lastConfigSendTime = object.lastConfigSendTime ?? undefined;
    message.blocked = object.blocked ?? false;
    message.lastErrorTime = object.lastErrorTime ?? undefined;
    message.lastErrorStatus = (object.lastErrorStatus !== undefined && object.lastErrorStatus !== null)
      ? Status.fromPartial(object.lastErrorStatus)
      : undefined;
    message.config = (object.config !== undefined && object.config !== null)
      ? DeviceConfig.fromPartial(object.config)
      : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? DeviceState.fromPartial(object.state)
      : undefined;
    message.logLevel = object.logLevel ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.gatewayConfig = (object.gatewayConfig !== undefined && object.gatewayConfig !== null)
      ? GatewayConfig.fromPartial(object.gatewayConfig)
      : undefined;
    return message;
  },
};

function createBaseDevice_MetadataEntry(): Device_MetadataEntry {
  return { key: "", value: "" };
}

export const Device_MetadataEntry: MessageFns<Device_MetadataEntry> = {
  encode(message: Device_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Device_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDevice_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Device_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Device_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Device_MetadataEntry>): Device_MetadataEntry {
    return Device_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Device_MetadataEntry>): Device_MetadataEntry {
    const message = createBaseDevice_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGatewayConfig(): GatewayConfig {
  return { gatewayType: 0, gatewayAuthMethod: 0, lastAccessedGatewayId: "", lastAccessedGatewayTime: undefined };
}

export const GatewayConfig: MessageFns<GatewayConfig> = {
  encode(message: GatewayConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gatewayType !== 0) {
      writer.uint32(8).int32(message.gatewayType);
    }
    if (message.gatewayAuthMethod !== 0) {
      writer.uint32(16).int32(message.gatewayAuthMethod);
    }
    if (message.lastAccessedGatewayId !== "") {
      writer.uint32(26).string(message.lastAccessedGatewayId);
    }
    if (message.lastAccessedGatewayTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastAccessedGatewayTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GatewayConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGatewayConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.gatewayType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gatewayAuthMethod = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lastAccessedGatewayId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastAccessedGatewayTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GatewayConfig {
    return {
      gatewayType: isSet(object.gatewayType) ? gatewayTypeFromJSON(object.gatewayType) : 0,
      gatewayAuthMethod: isSet(object.gatewayAuthMethod) ? gatewayAuthMethodFromJSON(object.gatewayAuthMethod) : 0,
      lastAccessedGatewayId: isSet(object.lastAccessedGatewayId) ? globalThis.String(object.lastAccessedGatewayId) : "",
      lastAccessedGatewayTime: isSet(object.lastAccessedGatewayTime)
        ? fromJsonTimestamp(object.lastAccessedGatewayTime)
        : undefined,
    };
  },

  toJSON(message: GatewayConfig): unknown {
    const obj: any = {};
    if (message.gatewayType !== 0) {
      obj.gatewayType = gatewayTypeToJSON(message.gatewayType);
    }
    if (message.gatewayAuthMethod !== 0) {
      obj.gatewayAuthMethod = gatewayAuthMethodToJSON(message.gatewayAuthMethod);
    }
    if (message.lastAccessedGatewayId !== "") {
      obj.lastAccessedGatewayId = message.lastAccessedGatewayId;
    }
    if (message.lastAccessedGatewayTime !== undefined) {
      obj.lastAccessedGatewayTime = message.lastAccessedGatewayTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<GatewayConfig>): GatewayConfig {
    return GatewayConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GatewayConfig>): GatewayConfig {
    const message = createBaseGatewayConfig();
    message.gatewayType = object.gatewayType ?? 0;
    message.gatewayAuthMethod = object.gatewayAuthMethod ?? 0;
    message.lastAccessedGatewayId = object.lastAccessedGatewayId ?? "";
    message.lastAccessedGatewayTime = object.lastAccessedGatewayTime ?? undefined;
    return message;
  },
};

function createBaseDeviceRegistry(): DeviceRegistry {
  return {
    id: "",
    name: "",
    eventNotificationConfigs: [],
    stateNotificationConfig: undefined,
    mqttConfig: undefined,
    httpConfig: undefined,
    logLevel: 0,
    credentials: [],
  };
}

export const DeviceRegistry: MessageFns<DeviceRegistry> = {
  encode(message: DeviceRegistry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.eventNotificationConfigs) {
      EventNotificationConfig.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.stateNotificationConfig !== undefined) {
      StateNotificationConfig.encode(message.stateNotificationConfig, writer.uint32(58).fork()).join();
    }
    if (message.mqttConfig !== undefined) {
      MqttConfig.encode(message.mqttConfig, writer.uint32(34).fork()).join();
    }
    if (message.httpConfig !== undefined) {
      HttpConfig.encode(message.httpConfig, writer.uint32(74).fork()).join();
    }
    if (message.logLevel !== 0) {
      writer.uint32(88).int32(message.logLevel);
    }
    for (const v of message.credentials) {
      RegistryCredential.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceRegistry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceRegistry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.eventNotificationConfigs.push(EventNotificationConfig.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.stateNotificationConfig = StateNotificationConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mqttConfig = MqttConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.httpConfig = HttpConfig.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.logLevel = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.credentials.push(RegistryCredential.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceRegistry {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      eventNotificationConfigs: globalThis.Array.isArray(object?.eventNotificationConfigs)
        ? object.eventNotificationConfigs.map((e: any) => EventNotificationConfig.fromJSON(e))
        : [],
      stateNotificationConfig: isSet(object.stateNotificationConfig)
        ? StateNotificationConfig.fromJSON(object.stateNotificationConfig)
        : undefined,
      mqttConfig: isSet(object.mqttConfig) ? MqttConfig.fromJSON(object.mqttConfig) : undefined,
      httpConfig: isSet(object.httpConfig) ? HttpConfig.fromJSON(object.httpConfig) : undefined,
      logLevel: isSet(object.logLevel) ? logLevelFromJSON(object.logLevel) : 0,
      credentials: globalThis.Array.isArray(object?.credentials)
        ? object.credentials.map((e: any) => RegistryCredential.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DeviceRegistry): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.eventNotificationConfigs?.length) {
      obj.eventNotificationConfigs = message.eventNotificationConfigs.map((e) => EventNotificationConfig.toJSON(e));
    }
    if (message.stateNotificationConfig !== undefined) {
      obj.stateNotificationConfig = StateNotificationConfig.toJSON(message.stateNotificationConfig);
    }
    if (message.mqttConfig !== undefined) {
      obj.mqttConfig = MqttConfig.toJSON(message.mqttConfig);
    }
    if (message.httpConfig !== undefined) {
      obj.httpConfig = HttpConfig.toJSON(message.httpConfig);
    }
    if (message.logLevel !== 0) {
      obj.logLevel = logLevelToJSON(message.logLevel);
    }
    if (message.credentials?.length) {
      obj.credentials = message.credentials.map((e) => RegistryCredential.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceRegistry>): DeviceRegistry {
    return DeviceRegistry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceRegistry>): DeviceRegistry {
    const message = createBaseDeviceRegistry();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.eventNotificationConfigs =
      object.eventNotificationConfigs?.map((e) => EventNotificationConfig.fromPartial(e)) || [];
    message.stateNotificationConfig =
      (object.stateNotificationConfig !== undefined && object.stateNotificationConfig !== null)
        ? StateNotificationConfig.fromPartial(object.stateNotificationConfig)
        : undefined;
    message.mqttConfig = (object.mqttConfig !== undefined && object.mqttConfig !== null)
      ? MqttConfig.fromPartial(object.mqttConfig)
      : undefined;
    message.httpConfig = (object.httpConfig !== undefined && object.httpConfig !== null)
      ? HttpConfig.fromPartial(object.httpConfig)
      : undefined;
    message.logLevel = object.logLevel ?? 0;
    message.credentials = object.credentials?.map((e) => RegistryCredential.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMqttConfig(): MqttConfig {
  return { mqttEnabledState: 0 };
}

export const MqttConfig: MessageFns<MqttConfig> = {
  encode(message: MqttConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mqttEnabledState !== 0) {
      writer.uint32(8).int32(message.mqttEnabledState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MqttConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMqttConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mqttEnabledState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MqttConfig {
    return { mqttEnabledState: isSet(object.mqttEnabledState) ? mqttStateFromJSON(object.mqttEnabledState) : 0 };
  },

  toJSON(message: MqttConfig): unknown {
    const obj: any = {};
    if (message.mqttEnabledState !== 0) {
      obj.mqttEnabledState = mqttStateToJSON(message.mqttEnabledState);
    }
    return obj;
  },

  create(base?: DeepPartial<MqttConfig>): MqttConfig {
    return MqttConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MqttConfig>): MqttConfig {
    const message = createBaseMqttConfig();
    message.mqttEnabledState = object.mqttEnabledState ?? 0;
    return message;
  },
};

function createBaseHttpConfig(): HttpConfig {
  return { httpEnabledState: 0 };
}

export const HttpConfig: MessageFns<HttpConfig> = {
  encode(message: HttpConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpEnabledState !== 0) {
      writer.uint32(8).int32(message.httpEnabledState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.httpEnabledState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpConfig {
    return { httpEnabledState: isSet(object.httpEnabledState) ? httpStateFromJSON(object.httpEnabledState) : 0 };
  },

  toJSON(message: HttpConfig): unknown {
    const obj: any = {};
    if (message.httpEnabledState !== 0) {
      obj.httpEnabledState = httpStateToJSON(message.httpEnabledState);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpConfig>): HttpConfig {
    return HttpConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpConfig>): HttpConfig {
    const message = createBaseHttpConfig();
    message.httpEnabledState = object.httpEnabledState ?? 0;
    return message;
  },
};

function createBaseEventNotificationConfig(): EventNotificationConfig {
  return { subfolderMatches: "", pubsubTopicName: "" };
}

export const EventNotificationConfig: MessageFns<EventNotificationConfig> = {
  encode(message: EventNotificationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subfolderMatches !== "") {
      writer.uint32(18).string(message.subfolderMatches);
    }
    if (message.pubsubTopicName !== "") {
      writer.uint32(10).string(message.pubsubTopicName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventNotificationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventNotificationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subfolderMatches = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubsubTopicName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventNotificationConfig {
    return {
      subfolderMatches: isSet(object.subfolderMatches) ? globalThis.String(object.subfolderMatches) : "",
      pubsubTopicName: isSet(object.pubsubTopicName) ? globalThis.String(object.pubsubTopicName) : "",
    };
  },

  toJSON(message: EventNotificationConfig): unknown {
    const obj: any = {};
    if (message.subfolderMatches !== "") {
      obj.subfolderMatches = message.subfolderMatches;
    }
    if (message.pubsubTopicName !== "") {
      obj.pubsubTopicName = message.pubsubTopicName;
    }
    return obj;
  },

  create(base?: DeepPartial<EventNotificationConfig>): EventNotificationConfig {
    return EventNotificationConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventNotificationConfig>): EventNotificationConfig {
    const message = createBaseEventNotificationConfig();
    message.subfolderMatches = object.subfolderMatches ?? "";
    message.pubsubTopicName = object.pubsubTopicName ?? "";
    return message;
  },
};

function createBaseStateNotificationConfig(): StateNotificationConfig {
  return { pubsubTopicName: "" };
}

export const StateNotificationConfig: MessageFns<StateNotificationConfig> = {
  encode(message: StateNotificationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pubsubTopicName !== "") {
      writer.uint32(10).string(message.pubsubTopicName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateNotificationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateNotificationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubsubTopicName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StateNotificationConfig {
    return { pubsubTopicName: isSet(object.pubsubTopicName) ? globalThis.String(object.pubsubTopicName) : "" };
  },

  toJSON(message: StateNotificationConfig): unknown {
    const obj: any = {};
    if (message.pubsubTopicName !== "") {
      obj.pubsubTopicName = message.pubsubTopicName;
    }
    return obj;
  },

  create(base?: DeepPartial<StateNotificationConfig>): StateNotificationConfig {
    return StateNotificationConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StateNotificationConfig>): StateNotificationConfig {
    const message = createBaseStateNotificationConfig();
    message.pubsubTopicName = object.pubsubTopicName ?? "";
    return message;
  },
};

function createBaseRegistryCredential(): RegistryCredential {
  return { publicKeyCertificate: undefined };
}

export const RegistryCredential: MessageFns<RegistryCredential> = {
  encode(message: RegistryCredential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKeyCertificate !== undefined) {
      PublicKeyCertificate.encode(message.publicKeyCertificate, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegistryCredential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegistryCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.publicKeyCertificate = PublicKeyCertificate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegistryCredential {
    return {
      publicKeyCertificate: isSet(object.publicKeyCertificate)
        ? PublicKeyCertificate.fromJSON(object.publicKeyCertificate)
        : undefined,
    };
  },

  toJSON(message: RegistryCredential): unknown {
    const obj: any = {};
    if (message.publicKeyCertificate !== undefined) {
      obj.publicKeyCertificate = PublicKeyCertificate.toJSON(message.publicKeyCertificate);
    }
    return obj;
  },

  create(base?: DeepPartial<RegistryCredential>): RegistryCredential {
    return RegistryCredential.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegistryCredential>): RegistryCredential {
    const message = createBaseRegistryCredential();
    message.publicKeyCertificate = (object.publicKeyCertificate !== undefined && object.publicKeyCertificate !== null)
      ? PublicKeyCertificate.fromPartial(object.publicKeyCertificate)
      : undefined;
    return message;
  },
};

function createBaseX509CertificateDetails(): X509CertificateDetails {
  return {
    issuer: "",
    subject: "",
    startTime: undefined,
    expiryTime: undefined,
    signatureAlgorithm: "",
    publicKeyType: "",
  };
}

export const X509CertificateDetails: MessageFns<X509CertificateDetails> = {
  encode(message: X509CertificateDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuer !== "") {
      writer.uint32(10).string(message.issuer);
    }
    if (message.subject !== "") {
      writer.uint32(18).string(message.subject);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).join();
    }
    if (message.expiryTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expiryTime), writer.uint32(34).fork()).join();
    }
    if (message.signatureAlgorithm !== "") {
      writer.uint32(42).string(message.signatureAlgorithm);
    }
    if (message.publicKeyType !== "") {
      writer.uint32(50).string(message.publicKeyType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): X509CertificateDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseX509CertificateDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issuer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subject = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.expiryTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.signatureAlgorithm = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.publicKeyType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): X509CertificateDetails {
    return {
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      expiryTime: isSet(object.expiryTime) ? fromJsonTimestamp(object.expiryTime) : undefined,
      signatureAlgorithm: isSet(object.signatureAlgorithm) ? globalThis.String(object.signatureAlgorithm) : "",
      publicKeyType: isSet(object.publicKeyType) ? globalThis.String(object.publicKeyType) : "",
    };
  },

  toJSON(message: X509CertificateDetails): unknown {
    const obj: any = {};
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.expiryTime !== undefined) {
      obj.expiryTime = message.expiryTime.toISOString();
    }
    if (message.signatureAlgorithm !== "") {
      obj.signatureAlgorithm = message.signatureAlgorithm;
    }
    if (message.publicKeyType !== "") {
      obj.publicKeyType = message.publicKeyType;
    }
    return obj;
  },

  create(base?: DeepPartial<X509CertificateDetails>): X509CertificateDetails {
    return X509CertificateDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<X509CertificateDetails>): X509CertificateDetails {
    const message = createBaseX509CertificateDetails();
    message.issuer = object.issuer ?? "";
    message.subject = object.subject ?? "";
    message.startTime = object.startTime ?? undefined;
    message.expiryTime = object.expiryTime ?? undefined;
    message.signatureAlgorithm = object.signatureAlgorithm ?? "";
    message.publicKeyType = object.publicKeyType ?? "";
    return message;
  },
};

function createBasePublicKeyCertificate(): PublicKeyCertificate {
  return { format: 0, certificate: "", x509Details: undefined };
}

export const PublicKeyCertificate: MessageFns<PublicKeyCertificate> = {
  encode(message: PublicKeyCertificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== 0) {
      writer.uint32(8).int32(message.format);
    }
    if (message.certificate !== "") {
      writer.uint32(18).string(message.certificate);
    }
    if (message.x509Details !== undefined) {
      X509CertificateDetails.encode(message.x509Details, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicKeyCertificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicKeyCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.certificate = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.x509Details = X509CertificateDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicKeyCertificate {
    return {
      format: isSet(object.format) ? publicKeyCertificateFormatFromJSON(object.format) : 0,
      certificate: isSet(object.certificate) ? globalThis.String(object.certificate) : "",
      x509Details: isSet(object.x509Details) ? X509CertificateDetails.fromJSON(object.x509Details) : undefined,
    };
  },

  toJSON(message: PublicKeyCertificate): unknown {
    const obj: any = {};
    if (message.format !== 0) {
      obj.format = publicKeyCertificateFormatToJSON(message.format);
    }
    if (message.certificate !== "") {
      obj.certificate = message.certificate;
    }
    if (message.x509Details !== undefined) {
      obj.x509Details = X509CertificateDetails.toJSON(message.x509Details);
    }
    return obj;
  },

  create(base?: DeepPartial<PublicKeyCertificate>): PublicKeyCertificate {
    return PublicKeyCertificate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublicKeyCertificate>): PublicKeyCertificate {
    const message = createBasePublicKeyCertificate();
    message.format = object.format ?? 0;
    message.certificate = object.certificate ?? "";
    message.x509Details = (object.x509Details !== undefined && object.x509Details !== null)
      ? X509CertificateDetails.fromPartial(object.x509Details)
      : undefined;
    return message;
  },
};

function createBaseDeviceCredential(): DeviceCredential {
  return { publicKey: undefined, expirationTime: undefined };
}

export const DeviceCredential: MessageFns<DeviceCredential> = {
  encode(message: DeviceCredential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey !== undefined) {
      PublicKeyCredential.encode(message.publicKey, writer.uint32(18).fork()).join();
    }
    if (message.expirationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expirationTime), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceCredential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.publicKey = PublicKeyCredential.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.expirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceCredential {
    return {
      publicKey: isSet(object.publicKey) ? PublicKeyCredential.fromJSON(object.publicKey) : undefined,
      expirationTime: isSet(object.expirationTime) ? fromJsonTimestamp(object.expirationTime) : undefined,
    };
  },

  toJSON(message: DeviceCredential): unknown {
    const obj: any = {};
    if (message.publicKey !== undefined) {
      obj.publicKey = PublicKeyCredential.toJSON(message.publicKey);
    }
    if (message.expirationTime !== undefined) {
      obj.expirationTime = message.expirationTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceCredential>): DeviceCredential {
    return DeviceCredential.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceCredential>): DeviceCredential {
    const message = createBaseDeviceCredential();
    message.publicKey = (object.publicKey !== undefined && object.publicKey !== null)
      ? PublicKeyCredential.fromPartial(object.publicKey)
      : undefined;
    message.expirationTime = object.expirationTime ?? undefined;
    return message;
  },
};

function createBasePublicKeyCredential(): PublicKeyCredential {
  return { format: 0, key: "" };
}

export const PublicKeyCredential: MessageFns<PublicKeyCredential> = {
  encode(message: PublicKeyCredential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== 0) {
      writer.uint32(8).int32(message.format);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicKeyCredential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicKeyCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicKeyCredential {
    return {
      format: isSet(object.format) ? publicKeyFormatFromJSON(object.format) : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: PublicKeyCredential): unknown {
    const obj: any = {};
    if (message.format !== 0) {
      obj.format = publicKeyFormatToJSON(message.format);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create(base?: DeepPartial<PublicKeyCredential>): PublicKeyCredential {
    return PublicKeyCredential.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublicKeyCredential>): PublicKeyCredential {
    const message = createBasePublicKeyCredential();
    message.format = object.format ?? 0;
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseDeviceConfig(): DeviceConfig {
  return { version: Long.ZERO, cloudUpdateTime: undefined, deviceAckTime: undefined, binaryData: Buffer.alloc(0) };
}

export const DeviceConfig: MessageFns<DeviceConfig> = {
  encode(message: DeviceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.version.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.version.toString());
    }
    if (message.cloudUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.cloudUpdateTime), writer.uint32(18).fork()).join();
    }
    if (message.deviceAckTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deviceAckTime), writer.uint32(26).fork()).join();
    }
    if (message.binaryData.length !== 0) {
      writer.uint32(34).bytes(message.binaryData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cloudUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deviceAckTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.binaryData = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceConfig {
    return {
      version: isSet(object.version) ? Long.fromValue(object.version) : Long.ZERO,
      cloudUpdateTime: isSet(object.cloudUpdateTime) ? fromJsonTimestamp(object.cloudUpdateTime) : undefined,
      deviceAckTime: isSet(object.deviceAckTime) ? fromJsonTimestamp(object.deviceAckTime) : undefined,
      binaryData: isSet(object.binaryData) ? Buffer.from(bytesFromBase64(object.binaryData)) : Buffer.alloc(0),
    };
  },

  toJSON(message: DeviceConfig): unknown {
    const obj: any = {};
    if (!message.version.equals(Long.ZERO)) {
      obj.version = (message.version || Long.ZERO).toString();
    }
    if (message.cloudUpdateTime !== undefined) {
      obj.cloudUpdateTime = message.cloudUpdateTime.toISOString();
    }
    if (message.deviceAckTime !== undefined) {
      obj.deviceAckTime = message.deviceAckTime.toISOString();
    }
    if (message.binaryData.length !== 0) {
      obj.binaryData = base64FromBytes(message.binaryData);
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceConfig>): DeviceConfig {
    return DeviceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceConfig>): DeviceConfig {
    const message = createBaseDeviceConfig();
    message.version = (object.version !== undefined && object.version !== null)
      ? Long.fromValue(object.version)
      : Long.ZERO;
    message.cloudUpdateTime = object.cloudUpdateTime ?? undefined;
    message.deviceAckTime = object.deviceAckTime ?? undefined;
    message.binaryData = object.binaryData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseDeviceState(): DeviceState {
  return { updateTime: undefined, binaryData: Buffer.alloc(0) };
}

export const DeviceState: MessageFns<DeviceState> = {
  encode(message: DeviceState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(10).fork()).join();
    }
    if (message.binaryData.length !== 0) {
      writer.uint32(18).bytes(message.binaryData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.binaryData = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceState {
    return {
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      binaryData: isSet(object.binaryData) ? Buffer.from(bytesFromBase64(object.binaryData)) : Buffer.alloc(0),
    };
  },

  toJSON(message: DeviceState): unknown {
    const obj: any = {};
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.binaryData.length !== 0) {
      obj.binaryData = base64FromBytes(message.binaryData);
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceState>): DeviceState {
    return DeviceState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceState>): DeviceState {
    const message = createBaseDeviceState();
    message.updateTime = object.updateTime ?? undefined;
    message.binaryData = object.binaryData ?? Buffer.alloc(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
