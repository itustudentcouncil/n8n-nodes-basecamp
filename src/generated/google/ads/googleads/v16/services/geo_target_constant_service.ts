// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v16/services/geo_target_constant_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { GeoTargetConstant } from "../resources/geo_target_constant.js";

export const protobufPackage = "google.ads.googleads.v16.services";

/**
 * Request message for
 * [GeoTargetConstantService.SuggestGeoTargetConstants][google.ads.googleads.v16.services.GeoTargetConstantService.SuggestGeoTargetConstants].
 */
export interface SuggestGeoTargetConstantsRequest {
  /**
   * If possible, returned geo targets are translated using this locale. If not,
   * en is used by default. This is also used as a hint for returned geo
   * targets.
   */
  locale?:
    | string
    | undefined;
  /** Returned geo targets are restricted to this country code. */
  countryCode?:
    | string
    | undefined;
  /** The location names to search by. At most 25 names can be set. */
  locationNames?:
    | SuggestGeoTargetConstantsRequest_LocationNames
    | undefined;
  /** The geo target constant resource names to filter by. */
  geoTargets?: SuggestGeoTargetConstantsRequest_GeoTargets | undefined;
}

/** A list of location names. */
export interface SuggestGeoTargetConstantsRequest_LocationNames {
  /** A list of location names. */
  names: string[];
}

/** A list of geo target constant resource names. */
export interface SuggestGeoTargetConstantsRequest_GeoTargets {
  /** A list of geo target constant resource names. */
  geoTargetConstants: string[];
}

/**
 * Response message for
 * [GeoTargetConstantService.SuggestGeoTargetConstants][google.ads.googleads.v16.services.GeoTargetConstantService.SuggestGeoTargetConstants].
 */
export interface SuggestGeoTargetConstantsResponse {
  /** Geo target constant suggestions. */
  geoTargetConstantSuggestions: GeoTargetConstantSuggestion[];
}

/** A geo target constant suggestion. */
export interface GeoTargetConstantSuggestion {
  /**
   * The language this GeoTargetConstantSuggestion is currently translated to.
   * It affects the name of geo target fields. For example, if locale=en, then
   * name=Spain. If locale=es, then name=Espa√±a. The default locale will be
   * returned if no translation exists for the locale in the request.
   */
  locale?:
    | string
    | undefined;
  /**
   * Approximate user population that will be targeted, rounded to the
   * nearest 100.
   */
  reach?:
    | Long
    | undefined;
  /**
   * If the request searched by location name, this is the location name that
   * matched the geo target.
   */
  searchTerm?:
    | string
    | undefined;
  /** The GeoTargetConstant result. */
  geoTargetConstant:
    | GeoTargetConstant
    | undefined;
  /** The list of parents of the geo target constant. */
  geoTargetConstantParents: GeoTargetConstant[];
}

function createBaseSuggestGeoTargetConstantsRequest(): SuggestGeoTargetConstantsRequest {
  return { locale: undefined, countryCode: undefined, locationNames: undefined, geoTargets: undefined };
}

export const SuggestGeoTargetConstantsRequest: MessageFns<SuggestGeoTargetConstantsRequest> = {
  encode(message: SuggestGeoTargetConstantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locale !== undefined) {
      writer.uint32(50).string(message.locale);
    }
    if (message.countryCode !== undefined) {
      writer.uint32(58).string(message.countryCode);
    }
    if (message.locationNames !== undefined) {
      SuggestGeoTargetConstantsRequest_LocationNames.encode(message.locationNames, writer.uint32(10).fork()).join();
    }
    if (message.geoTargets !== undefined) {
      SuggestGeoTargetConstantsRequest_GeoTargets.encode(message.geoTargets, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestGeoTargetConstantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestGeoTargetConstantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.locale = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.locationNames = SuggestGeoTargetConstantsRequest_LocationNames.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.geoTargets = SuggestGeoTargetConstantsRequest_GeoTargets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestGeoTargetConstantsRequest {
    return {
      locale: isSet(object.locale) ? globalThis.String(object.locale) : undefined,
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : undefined,
      locationNames: isSet(object.locationNames)
        ? SuggestGeoTargetConstantsRequest_LocationNames.fromJSON(object.locationNames)
        : undefined,
      geoTargets: isSet(object.geoTargets)
        ? SuggestGeoTargetConstantsRequest_GeoTargets.fromJSON(object.geoTargets)
        : undefined,
    };
  },

  toJSON(message: SuggestGeoTargetConstantsRequest): unknown {
    const obj: any = {};
    if (message.locale !== undefined) {
      obj.locale = message.locale;
    }
    if (message.countryCode !== undefined) {
      obj.countryCode = message.countryCode;
    }
    if (message.locationNames !== undefined) {
      obj.locationNames = SuggestGeoTargetConstantsRequest_LocationNames.toJSON(message.locationNames);
    }
    if (message.geoTargets !== undefined) {
      obj.geoTargets = SuggestGeoTargetConstantsRequest_GeoTargets.toJSON(message.geoTargets);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestGeoTargetConstantsRequest>): SuggestGeoTargetConstantsRequest {
    return SuggestGeoTargetConstantsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestGeoTargetConstantsRequest>): SuggestGeoTargetConstantsRequest {
    const message = createBaseSuggestGeoTargetConstantsRequest();
    message.locale = object.locale ?? undefined;
    message.countryCode = object.countryCode ?? undefined;
    message.locationNames = (object.locationNames !== undefined && object.locationNames !== null)
      ? SuggestGeoTargetConstantsRequest_LocationNames.fromPartial(object.locationNames)
      : undefined;
    message.geoTargets = (object.geoTargets !== undefined && object.geoTargets !== null)
      ? SuggestGeoTargetConstantsRequest_GeoTargets.fromPartial(object.geoTargets)
      : undefined;
    return message;
  },
};

function createBaseSuggestGeoTargetConstantsRequest_LocationNames(): SuggestGeoTargetConstantsRequest_LocationNames {
  return { names: [] };
}

export const SuggestGeoTargetConstantsRequest_LocationNames: MessageFns<
  SuggestGeoTargetConstantsRequest_LocationNames
> = {
  encode(
    message: SuggestGeoTargetConstantsRequest_LocationNames,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.names) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestGeoTargetConstantsRequest_LocationNames {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestGeoTargetConstantsRequest_LocationNames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.names.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestGeoTargetConstantsRequest_LocationNames {
    return { names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: SuggestGeoTargetConstantsRequest_LocationNames): unknown {
    const obj: any = {};
    if (message.names?.length) {
      obj.names = message.names;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SuggestGeoTargetConstantsRequest_LocationNames>,
  ): SuggestGeoTargetConstantsRequest_LocationNames {
    return SuggestGeoTargetConstantsRequest_LocationNames.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SuggestGeoTargetConstantsRequest_LocationNames>,
  ): SuggestGeoTargetConstantsRequest_LocationNames {
    const message = createBaseSuggestGeoTargetConstantsRequest_LocationNames();
    message.names = object.names?.map((e) => e) || [];
    return message;
  },
};

function createBaseSuggestGeoTargetConstantsRequest_GeoTargets(): SuggestGeoTargetConstantsRequest_GeoTargets {
  return { geoTargetConstants: [] };
}

export const SuggestGeoTargetConstantsRequest_GeoTargets: MessageFns<SuggestGeoTargetConstantsRequest_GeoTargets> = {
  encode(
    message: SuggestGeoTargetConstantsRequest_GeoTargets,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.geoTargetConstants) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestGeoTargetConstantsRequest_GeoTargets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestGeoTargetConstantsRequest_GeoTargets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.geoTargetConstants.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestGeoTargetConstantsRequest_GeoTargets {
    return {
      geoTargetConstants: globalThis.Array.isArray(object?.geoTargetConstants)
        ? object.geoTargetConstants.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SuggestGeoTargetConstantsRequest_GeoTargets): unknown {
    const obj: any = {};
    if (message.geoTargetConstants?.length) {
      obj.geoTargetConstants = message.geoTargetConstants;
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestGeoTargetConstantsRequest_GeoTargets>): SuggestGeoTargetConstantsRequest_GeoTargets {
    return SuggestGeoTargetConstantsRequest_GeoTargets.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SuggestGeoTargetConstantsRequest_GeoTargets>,
  ): SuggestGeoTargetConstantsRequest_GeoTargets {
    const message = createBaseSuggestGeoTargetConstantsRequest_GeoTargets();
    message.geoTargetConstants = object.geoTargetConstants?.map((e) => e) || [];
    return message;
  },
};

function createBaseSuggestGeoTargetConstantsResponse(): SuggestGeoTargetConstantsResponse {
  return { geoTargetConstantSuggestions: [] };
}

export const SuggestGeoTargetConstantsResponse: MessageFns<SuggestGeoTargetConstantsResponse> = {
  encode(message: SuggestGeoTargetConstantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.geoTargetConstantSuggestions) {
      GeoTargetConstantSuggestion.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestGeoTargetConstantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestGeoTargetConstantsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.geoTargetConstantSuggestions.push(GeoTargetConstantSuggestion.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestGeoTargetConstantsResponse {
    return {
      geoTargetConstantSuggestions: globalThis.Array.isArray(object?.geoTargetConstantSuggestions)
        ? object.geoTargetConstantSuggestions.map((e: any) => GeoTargetConstantSuggestion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SuggestGeoTargetConstantsResponse): unknown {
    const obj: any = {};
    if (message.geoTargetConstantSuggestions?.length) {
      obj.geoTargetConstantSuggestions = message.geoTargetConstantSuggestions.map((e) =>
        GeoTargetConstantSuggestion.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestGeoTargetConstantsResponse>): SuggestGeoTargetConstantsResponse {
    return SuggestGeoTargetConstantsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestGeoTargetConstantsResponse>): SuggestGeoTargetConstantsResponse {
    const message = createBaseSuggestGeoTargetConstantsResponse();
    message.geoTargetConstantSuggestions =
      object.geoTargetConstantSuggestions?.map((e) => GeoTargetConstantSuggestion.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGeoTargetConstantSuggestion(): GeoTargetConstantSuggestion {
  return {
    locale: undefined,
    reach: undefined,
    searchTerm: undefined,
    geoTargetConstant: undefined,
    geoTargetConstantParents: [],
  };
}

export const GeoTargetConstantSuggestion: MessageFns<GeoTargetConstantSuggestion> = {
  encode(message: GeoTargetConstantSuggestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locale !== undefined) {
      writer.uint32(50).string(message.locale);
    }
    if (message.reach !== undefined) {
      writer.uint32(56).int64(message.reach.toString());
    }
    if (message.searchTerm !== undefined) {
      writer.uint32(66).string(message.searchTerm);
    }
    if (message.geoTargetConstant !== undefined) {
      GeoTargetConstant.encode(message.geoTargetConstant, writer.uint32(34).fork()).join();
    }
    for (const v of message.geoTargetConstantParents) {
      GeoTargetConstant.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoTargetConstantSuggestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoTargetConstantSuggestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.locale = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.reach = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.searchTerm = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.geoTargetConstant = GeoTargetConstant.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.geoTargetConstantParents.push(GeoTargetConstant.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoTargetConstantSuggestion {
    return {
      locale: isSet(object.locale) ? globalThis.String(object.locale) : undefined,
      reach: isSet(object.reach) ? Long.fromValue(object.reach) : undefined,
      searchTerm: isSet(object.searchTerm) ? globalThis.String(object.searchTerm) : undefined,
      geoTargetConstant: isSet(object.geoTargetConstant)
        ? GeoTargetConstant.fromJSON(object.geoTargetConstant)
        : undefined,
      geoTargetConstantParents: globalThis.Array.isArray(object?.geoTargetConstantParents)
        ? object.geoTargetConstantParents.map((e: any) => GeoTargetConstant.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GeoTargetConstantSuggestion): unknown {
    const obj: any = {};
    if (message.locale !== undefined) {
      obj.locale = message.locale;
    }
    if (message.reach !== undefined) {
      obj.reach = (message.reach || Long.ZERO).toString();
    }
    if (message.searchTerm !== undefined) {
      obj.searchTerm = message.searchTerm;
    }
    if (message.geoTargetConstant !== undefined) {
      obj.geoTargetConstant = GeoTargetConstant.toJSON(message.geoTargetConstant);
    }
    if (message.geoTargetConstantParents?.length) {
      obj.geoTargetConstantParents = message.geoTargetConstantParents.map((e) => GeoTargetConstant.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GeoTargetConstantSuggestion>): GeoTargetConstantSuggestion {
    return GeoTargetConstantSuggestion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeoTargetConstantSuggestion>): GeoTargetConstantSuggestion {
    const message = createBaseGeoTargetConstantSuggestion();
    message.locale = object.locale ?? undefined;
    message.reach = (object.reach !== undefined && object.reach !== null) ? Long.fromValue(object.reach) : undefined;
    message.searchTerm = object.searchTerm ?? undefined;
    message.geoTargetConstant = (object.geoTargetConstant !== undefined && object.geoTargetConstant !== null)
      ? GeoTargetConstant.fromPartial(object.geoTargetConstant)
      : undefined;
    message.geoTargetConstantParents = object.geoTargetConstantParents?.map((e) => GeoTargetConstant.fromPartial(e)) ||
      [];
    return message;
  },
};

/** Service to fetch geo target constants. */
export type GeoTargetConstantServiceDefinition = typeof GeoTargetConstantServiceDefinition;
export const GeoTargetConstantServiceDefinition = {
  name: "GeoTargetConstantService",
  fullName: "google.ads.googleads.v16.services.GeoTargetConstantService",
  methods: {
    /**
     * Returns GeoTargetConstant suggestions by location name or by resource name.
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [GeoTargetConstantSuggestionError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [QuotaError]()
     *   [RequestError]()
     */
    suggestGeoTargetConstants: {
      name: "SuggestGeoTargetConstants",
      requestType: SuggestGeoTargetConstantsRequest,
      requestStream: false,
      responseType: SuggestGeoTargetConstantsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              36,
              58,
              1,
              42,
              34,
              31,
              47,
              118,
              49,
              54,
              47,
              103,
              101,
              111,
              84,
              97,
              114,
              103,
              101,
              116,
              67,
              111,
              110,
              115,
              116,
              97,
              110,
              116,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface GeoTargetConstantServiceImplementation<CallContextExt = {}> {
  /**
   * Returns GeoTargetConstant suggestions by location name or by resource name.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [GeoTargetConstantSuggestionError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  suggestGeoTargetConstants(
    request: SuggestGeoTargetConstantsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SuggestGeoTargetConstantsResponse>>;
}

export interface GeoTargetConstantServiceClient<CallOptionsExt = {}> {
  /**
   * Returns GeoTargetConstant suggestions by location name or by resource name.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [GeoTargetConstantSuggestionError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  suggestGeoTargetConstants(
    request: DeepPartial<SuggestGeoTargetConstantsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SuggestGeoTargetConstantsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
