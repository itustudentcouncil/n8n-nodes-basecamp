// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v16/services/conversion_upload_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Status } from "../../../../rpc/status.js";
import { Consent } from "../common/consent.js";
import { UserIdentifier } from "../common/offline_user_data.js";
import {
  ConversionEnvironmentEnum_ConversionEnvironment,
  conversionEnvironmentEnum_ConversionEnvironmentFromJSON,
  conversionEnvironmentEnum_ConversionEnvironmentToJSON,
} from "../enums/conversion_environment_enum.js";

export const protobufPackage = "google.ads.googleads.v16.services";

/**
 * Request message for
 * [ConversionUploadService.UploadClickConversions][google.ads.googleads.v16.services.ConversionUploadService.UploadClickConversions].
 */
export interface UploadClickConversionsRequest {
  /** Required. The ID of the customer performing the upload. */
  customerId: string;
  /** Required. The conversions that are being uploaded. */
  conversions: ClickConversion[];
  /**
   * Required. If true, successful operations will be carried out and invalid
   * operations will return errors. If false, all operations will be carried
   * out in one transaction if and only if they are all valid.
   * This should always be set to true.
   * See
   * https://developers.google.com/google-ads/api/docs/best-practices/partial-failures
   * for more information about partial failure.
   */
  partialFailure: boolean;
  /**
   * If true, the request is validated but not executed. Only errors are
   * returned, not results.
   */
  validateOnly: boolean;
  /**
   * If true, the API will perform all upload checks and return errors if
   * any are found. If false, it will perform only basic input validation,
   * skip subsequent upload checks, and return success even if no click
   * was found for the provided `user_identifiers`.
   *
   * This setting only affects Enhanced conversions for leads uploads that use
   * `user_identifiers` instead of `GCLID`, `GBRAID`, or `WBRAID`. When
   * uploading enhanced conversions for leads, you should upload all conversion
   * events to the API, including those that may not come from Google Ads
   * campaigns. The upload of an event that is not from a Google Ads campaign
   * will result in a `CLICK_NOT_FOUND` error if this field is set to `true`.
   * Since these errors are expected for such events, set this field to `false`
   * so you can confirm your uploads are properly formatted but ignore
   * `CLICK_NOT_FOUND` errors from all of the conversions that are not from a
   * Google Ads campaign. This will allow you to focus only on errors that you
   * can address.
   *
   * Default is false.
   */
  debugEnabled: boolean;
  /**
   * Optional. Optional input to set job ID. Must be a non-negative number that
   * is less than 2^31 if provided. If this field is not provided, the API will
   * generate a job ID in the range [2^31, (2^63)-1]. The API will return the
   * value for this request in the `job_id` field of the
   * `UploadClickConversionsResponse`.
   */
  jobId?: number | undefined;
}

/**
 * Response message for
 * [ConversionUploadService.UploadClickConversions][google.ads.googleads.v16.services.ConversionUploadService.UploadClickConversions].
 */
export interface UploadClickConversionsResponse {
  /**
   * Errors that pertain to conversion failures in the partial failure mode.
   * Returned when all errors occur inside the conversions. If any errors occur
   * outside the conversions (for example, auth errors), we return an RPC level
   * error. See
   * https://developers.google.com/google-ads/api/docs/best-practices/partial-failures
   * for more information about partial failure.
   */
  partialFailureError:
    | Status
    | undefined;
  /**
   * Returned for successfully processed conversions. Proto will be empty for
   * rows that received an error. Results are not returned when validate_only is
   * true.
   */
  results: ClickConversionResult[];
  /** Job ID for the upload batch. */
  jobId: Long;
}

/**
 * Request message for
 * [ConversionUploadService.UploadCallConversions][google.ads.googleads.v16.services.ConversionUploadService.UploadCallConversions].
 */
export interface UploadCallConversionsRequest {
  /** Required. The ID of the customer performing the upload. */
  customerId: string;
  /** Required. The conversions that are being uploaded. */
  conversions: CallConversion[];
  /**
   * Required. If true, successful operations will be carried out and invalid
   * operations will return errors. If false, all operations will be carried
   * out in one transaction if and only if they are all valid.
   * This should always be set to true.
   * See
   * https://developers.google.com/google-ads/api/docs/best-practices/partial-failures
   * for more information about partial failure.
   */
  partialFailure: boolean;
  /**
   * If true, the request is validated but not executed. Only errors are
   * returned, not results.
   */
  validateOnly: boolean;
}

/**
 * Response message for
 * [ConversionUploadService.UploadCallConversions][google.ads.googleads.v16.services.ConversionUploadService.UploadCallConversions].
 */
export interface UploadCallConversionsResponse {
  /**
   * Errors that pertain to conversion failures in the partial failure mode.
   * Returned when all errors occur inside the conversions. If any errors occur
   * outside the conversions (for example, auth errors), we return an RPC level
   * error. See
   * https://developers.google.com/google-ads/api/docs/best-practices/partial-failures
   * for more information about partial failure.
   */
  partialFailureError:
    | Status
    | undefined;
  /**
   * Returned for successfully processed conversions. Proto will be empty for
   * rows that received an error. Results are not returned when validate_only is
   * true.
   */
  results: CallConversionResult[];
}

/** A click conversion. */
export interface ClickConversion {
  /** The Google click ID (gclid) associated with this conversion. */
  gclid?:
    | string
    | undefined;
  /**
   * The click identifier for clicks associated with app conversions and
   * originating from iOS devices starting with iOS14.
   */
  gbraid: string;
  /**
   * The click identifier for clicks associated with web conversions and
   * originating from iOS devices starting with iOS14.
   */
  wbraid: string;
  /**
   * Resource name of the conversion action associated with this conversion.
   * Note: Although this resource name consists of a customer id and a
   * conversion action id, validation will ignore the customer id and use the
   * conversion action id as the sole identifier of the conversion action.
   */
  conversionAction?:
    | string
    | undefined;
  /**
   * The date time at which the conversion occurred. Must be after
   * the click time. The timezone must be specified. The format is
   * "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
   */
  conversionDateTime?:
    | string
    | undefined;
  /** The value of the conversion for the advertiser. */
  conversionValue?:
    | number
    | undefined;
  /**
   * Currency associated with the conversion value. This is the ISO 4217
   * 3-character currency code. For example: USD, EUR.
   */
  currencyCode?:
    | string
    | undefined;
  /**
   * The order ID associated with the conversion. An order id can only be used
   * for one conversion per conversion action.
   */
  orderId?:
    | string
    | undefined;
  /**
   * Additional data about externally attributed conversions. This field
   * is required for conversions with an externally attributed conversion
   * action, but should not be set otherwise.
   */
  externalAttributionData:
    | ExternalAttributionData
    | undefined;
  /** The custom variables associated with this conversion. */
  customVariables: CustomVariable[];
  /** The cart data associated with this conversion. */
  cartData:
    | CartData
    | undefined;
  /**
   * The user identifiers associated with this conversion. Only hashed_email and
   * hashed_phone_number are supported for conversion uploads. The maximum
   * number of user identifiers for each conversion is 5.
   */
  userIdentifiers: UserIdentifier[];
  /** The environment this conversion was recorded on, for example, App or Web. */
  conversionEnvironment: ConversionEnvironmentEnum_ConversionEnvironment;
  /** The consent setting for the event. */
  consent: Consent | undefined;
}

/** A call conversion. */
export interface CallConversion {
  /**
   * The caller id from which this call was placed. Caller id is expected to be
   * in E.164 format with preceding '+' sign, for example, "+16502531234".
   */
  callerId?:
    | string
    | undefined;
  /**
   * The date time at which the call occurred. The timezone must be specified.
   * The format is "yyyy-mm-dd hh:mm:ss+|-hh:mm",
   * for example, "2019-01-01 12:32:45-08:00".
   */
  callStartDateTime?:
    | string
    | undefined;
  /**
   * Resource name of the conversion action associated with this conversion.
   * Note: Although this resource name consists of a customer id and a
   * conversion action id, validation will ignore the customer id and use the
   * conversion action id as the sole identifier of the conversion action.
   */
  conversionAction?:
    | string
    | undefined;
  /**
   * The date time at which the conversion occurred. Must be after the call
   * time. The timezone must be specified. The format is
   * "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
   */
  conversionDateTime?:
    | string
    | undefined;
  /** The value of the conversion for the advertiser. */
  conversionValue?:
    | number
    | undefined;
  /**
   * Currency associated with the conversion value. This is the ISO 4217
   * 3-character currency code. For example: USD, EUR.
   */
  currencyCode?:
    | string
    | undefined;
  /** The custom variables associated with this conversion. */
  customVariables: CustomVariable[];
  /** The consent setting for the event. */
  consent: Consent | undefined;
}

/** Contains additional information about externally attributed conversions. */
export interface ExternalAttributionData {
  /**
   * Represents the fraction of the conversion that is attributed to the
   * Google Ads click.
   */
  externalAttributionCredit?:
    | number
    | undefined;
  /** Specifies the attribution model name. */
  externalAttributionModel?: string | undefined;
}

/** Identifying information for a successfully processed ClickConversion. */
export interface ClickConversionResult {
  /** The Google Click ID (gclid) associated with this conversion. */
  gclid?:
    | string
    | undefined;
  /**
   * The click identifier for clicks associated with app conversions and
   * originating from iOS devices starting with iOS14.
   */
  gbraid: string;
  /**
   * The click identifier for clicks associated with web conversions and
   * originating from iOS devices starting with iOS14.
   */
  wbraid: string;
  /** Resource name of the conversion action associated with this conversion. */
  conversionAction?:
    | string
    | undefined;
  /**
   * The date time at which the conversion occurred. The format is
   * "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
   */
  conversionDateTime?:
    | string
    | undefined;
  /**
   * The user identifiers associated with this conversion. Only hashed_email and
   * hashed_phone_number are supported for conversion uploads. The maximum
   * number of user identifiers for each conversion is 5.
   */
  userIdentifiers: UserIdentifier[];
}

/** Identifying information for a successfully processed CallConversionUpload. */
export interface CallConversionResult {
  /**
   * The caller id from which this call was placed. Caller id is expected to be
   * in E.164 format with preceding '+' sign.
   */
  callerId?:
    | string
    | undefined;
  /**
   * The date time at which the call occurred. The format is
   * "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
   */
  callStartDateTime?:
    | string
    | undefined;
  /** Resource name of the conversion action associated with this conversion. */
  conversionAction?:
    | string
    | undefined;
  /**
   * The date time at which the conversion occurred. The format is
   * "yyyy-mm-dd hh:mm:ss+|-hh:mm", for example, "2019-01-01 12:32:45-08:00".
   */
  conversionDateTime?: string | undefined;
}

/** A custom variable. */
export interface CustomVariable {
  /**
   * Resource name of the custom variable associated with this conversion.
   * Note: Although this resource name consists of a customer id and a
   * conversion custom variable id, validation will ignore the customer id and
   * use the conversion custom variable id as the sole identifier of the
   * conversion custom variable.
   */
  conversionCustomVariable: string;
  /**
   * The value string of this custom variable.
   * The value of the custom variable should not contain private customer data,
   * such as email addresses or phone numbers.
   */
  value: string;
}

/** Contains additional information about cart data. */
export interface CartData {
  /** The Merchant Center ID where the items are uploaded. */
  merchantId: Long;
  /** The country code associated with the feed where the items are uploaded. */
  feedCountryCode: string;
  /** The language code associated with the feed where the items are uploaded. */
  feedLanguageCode: string;
  /**
   * Sum of all transaction level discounts, such as free shipping and
   * coupon discounts for the whole cart. The currency code is the same
   * as that in the ClickConversion message.
   */
  localTransactionCost: number;
  /** Data of the items purchased. */
  items: CartData_Item[];
}

/** Contains data of the items purchased. */
export interface CartData_Item {
  /**
   * The shopping id of the item. Must be equal to the Merchant Center product
   * identifier.
   */
  productId: string;
  /** Number of items sold. */
  quantity: number;
  /**
   * Unit price excluding tax, shipping, and any transaction
   * level discounts. The currency code is the same as that in the
   * ClickConversion message.
   */
  unitPrice: number;
}

function createBaseUploadClickConversionsRequest(): UploadClickConversionsRequest {
  return {
    customerId: "",
    conversions: [],
    partialFailure: false,
    validateOnly: false,
    debugEnabled: false,
    jobId: undefined,
  };
}

export const UploadClickConversionsRequest: MessageFns<UploadClickConversionsRequest> = {
  encode(message: UploadClickConversionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    for (const v of message.conversions) {
      ClickConversion.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.partialFailure !== false) {
      writer.uint32(24).bool(message.partialFailure);
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    if (message.debugEnabled !== false) {
      writer.uint32(40).bool(message.debugEnabled);
    }
    if (message.jobId !== undefined) {
      writer.uint32(48).int32(message.jobId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadClickConversionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadClickConversionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversions.push(ClickConversion.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.partialFailure = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.debugEnabled = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.jobId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadClickConversionsRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      conversions: globalThis.Array.isArray(object?.conversions)
        ? object.conversions.map((e: any) => ClickConversion.fromJSON(e))
        : [],
      partialFailure: isSet(object.partialFailure) ? globalThis.Boolean(object.partialFailure) : false,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      debugEnabled: isSet(object.debugEnabled) ? globalThis.Boolean(object.debugEnabled) : false,
      jobId: isSet(object.jobId) ? globalThis.Number(object.jobId) : undefined,
    };
  },

  toJSON(message: UploadClickConversionsRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.conversions?.length) {
      obj.conversions = message.conversions.map((e) => ClickConversion.toJSON(e));
    }
    if (message.partialFailure !== false) {
      obj.partialFailure = message.partialFailure;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.debugEnabled !== false) {
      obj.debugEnabled = message.debugEnabled;
    }
    if (message.jobId !== undefined) {
      obj.jobId = Math.round(message.jobId);
    }
    return obj;
  },

  create(base?: DeepPartial<UploadClickConversionsRequest>): UploadClickConversionsRequest {
    return UploadClickConversionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadClickConversionsRequest>): UploadClickConversionsRequest {
    const message = createBaseUploadClickConversionsRequest();
    message.customerId = object.customerId ?? "";
    message.conversions = object.conversions?.map((e) => ClickConversion.fromPartial(e)) || [];
    message.partialFailure = object.partialFailure ?? false;
    message.validateOnly = object.validateOnly ?? false;
    message.debugEnabled = object.debugEnabled ?? false;
    message.jobId = object.jobId ?? undefined;
    return message;
  },
};

function createBaseUploadClickConversionsResponse(): UploadClickConversionsResponse {
  return { partialFailureError: undefined, results: [], jobId: Long.ZERO };
}

export const UploadClickConversionsResponse: MessageFns<UploadClickConversionsResponse> = {
  encode(message: UploadClickConversionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.partialFailureError !== undefined) {
      Status.encode(message.partialFailureError, writer.uint32(10).fork()).join();
    }
    for (const v of message.results) {
      ClickConversionResult.encode(v!, writer.uint32(18).fork()).join();
    }
    if (!message.jobId.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.jobId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadClickConversionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadClickConversionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.partialFailureError = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(ClickConversionResult.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.jobId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadClickConversionsResponse {
    return {
      partialFailureError: isSet(object.partialFailureError) ? Status.fromJSON(object.partialFailureError) : undefined,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ClickConversionResult.fromJSON(e))
        : [],
      jobId: isSet(object.jobId) ? Long.fromValue(object.jobId) : Long.ZERO,
    };
  },

  toJSON(message: UploadClickConversionsResponse): unknown {
    const obj: any = {};
    if (message.partialFailureError !== undefined) {
      obj.partialFailureError = Status.toJSON(message.partialFailureError);
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => ClickConversionResult.toJSON(e));
    }
    if (!message.jobId.equals(Long.ZERO)) {
      obj.jobId = (message.jobId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UploadClickConversionsResponse>): UploadClickConversionsResponse {
    return UploadClickConversionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadClickConversionsResponse>): UploadClickConversionsResponse {
    const message = createBaseUploadClickConversionsResponse();
    message.partialFailureError = (object.partialFailureError !== undefined && object.partialFailureError !== null)
      ? Status.fromPartial(object.partialFailureError)
      : undefined;
    message.results = object.results?.map((e) => ClickConversionResult.fromPartial(e)) || [];
    message.jobId = (object.jobId !== undefined && object.jobId !== null) ? Long.fromValue(object.jobId) : Long.ZERO;
    return message;
  },
};

function createBaseUploadCallConversionsRequest(): UploadCallConversionsRequest {
  return { customerId: "", conversions: [], partialFailure: false, validateOnly: false };
}

export const UploadCallConversionsRequest: MessageFns<UploadCallConversionsRequest> = {
  encode(message: UploadCallConversionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    for (const v of message.conversions) {
      CallConversion.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.partialFailure !== false) {
      writer.uint32(24).bool(message.partialFailure);
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadCallConversionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadCallConversionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversions.push(CallConversion.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.partialFailure = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadCallConversionsRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      conversions: globalThis.Array.isArray(object?.conversions)
        ? object.conversions.map((e: any) => CallConversion.fromJSON(e))
        : [],
      partialFailure: isSet(object.partialFailure) ? globalThis.Boolean(object.partialFailure) : false,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: UploadCallConversionsRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.conversions?.length) {
      obj.conversions = message.conversions.map((e) => CallConversion.toJSON(e));
    }
    if (message.partialFailure !== false) {
      obj.partialFailure = message.partialFailure;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<UploadCallConversionsRequest>): UploadCallConversionsRequest {
    return UploadCallConversionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadCallConversionsRequest>): UploadCallConversionsRequest {
    const message = createBaseUploadCallConversionsRequest();
    message.customerId = object.customerId ?? "";
    message.conversions = object.conversions?.map((e) => CallConversion.fromPartial(e)) || [];
    message.partialFailure = object.partialFailure ?? false;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUploadCallConversionsResponse(): UploadCallConversionsResponse {
  return { partialFailureError: undefined, results: [] };
}

export const UploadCallConversionsResponse: MessageFns<UploadCallConversionsResponse> = {
  encode(message: UploadCallConversionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.partialFailureError !== undefined) {
      Status.encode(message.partialFailureError, writer.uint32(10).fork()).join();
    }
    for (const v of message.results) {
      CallConversionResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadCallConversionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadCallConversionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.partialFailureError = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(CallConversionResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadCallConversionsResponse {
    return {
      partialFailureError: isSet(object.partialFailureError) ? Status.fromJSON(object.partialFailureError) : undefined,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => CallConversionResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UploadCallConversionsResponse): unknown {
    const obj: any = {};
    if (message.partialFailureError !== undefined) {
      obj.partialFailureError = Status.toJSON(message.partialFailureError);
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => CallConversionResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UploadCallConversionsResponse>): UploadCallConversionsResponse {
    return UploadCallConversionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadCallConversionsResponse>): UploadCallConversionsResponse {
    const message = createBaseUploadCallConversionsResponse();
    message.partialFailureError = (object.partialFailureError !== undefined && object.partialFailureError !== null)
      ? Status.fromPartial(object.partialFailureError)
      : undefined;
    message.results = object.results?.map((e) => CallConversionResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClickConversion(): ClickConversion {
  return {
    gclid: undefined,
    gbraid: "",
    wbraid: "",
    conversionAction: undefined,
    conversionDateTime: undefined,
    conversionValue: undefined,
    currencyCode: undefined,
    orderId: undefined,
    externalAttributionData: undefined,
    customVariables: [],
    cartData: undefined,
    userIdentifiers: [],
    conversionEnvironment: 0,
    consent: undefined,
  };
}

export const ClickConversion: MessageFns<ClickConversion> = {
  encode(message: ClickConversion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gclid !== undefined) {
      writer.uint32(74).string(message.gclid);
    }
    if (message.gbraid !== "") {
      writer.uint32(146).string(message.gbraid);
    }
    if (message.wbraid !== "") {
      writer.uint32(154).string(message.wbraid);
    }
    if (message.conversionAction !== undefined) {
      writer.uint32(82).string(message.conversionAction);
    }
    if (message.conversionDateTime !== undefined) {
      writer.uint32(90).string(message.conversionDateTime);
    }
    if (message.conversionValue !== undefined) {
      writer.uint32(97).double(message.conversionValue);
    }
    if (message.currencyCode !== undefined) {
      writer.uint32(106).string(message.currencyCode);
    }
    if (message.orderId !== undefined) {
      writer.uint32(114).string(message.orderId);
    }
    if (message.externalAttributionData !== undefined) {
      ExternalAttributionData.encode(message.externalAttributionData, writer.uint32(58).fork()).join();
    }
    for (const v of message.customVariables) {
      CustomVariable.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.cartData !== undefined) {
      CartData.encode(message.cartData, writer.uint32(130).fork()).join();
    }
    for (const v of message.userIdentifiers) {
      UserIdentifier.encode(v!, writer.uint32(138).fork()).join();
    }
    if (message.conversionEnvironment !== 0) {
      writer.uint32(160).int32(message.conversionEnvironment);
    }
    if (message.consent !== undefined) {
      Consent.encode(message.consent, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClickConversion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClickConversion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 9:
          if (tag !== 74) {
            break;
          }

          message.gclid = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.gbraid = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.wbraid = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.conversionAction = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.conversionDateTime = reader.string();
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.conversionValue = reader.double();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.orderId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalAttributionData = ExternalAttributionData.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.customVariables.push(CustomVariable.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.cartData = CartData.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.userIdentifiers.push(UserIdentifier.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.conversionEnvironment = reader.int32() as any;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.consent = Consent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClickConversion {
    return {
      gclid: isSet(object.gclid) ? globalThis.String(object.gclid) : undefined,
      gbraid: isSet(object.gbraid) ? globalThis.String(object.gbraid) : "",
      wbraid: isSet(object.wbraid) ? globalThis.String(object.wbraid) : "",
      conversionAction: isSet(object.conversionAction) ? globalThis.String(object.conversionAction) : undefined,
      conversionDateTime: isSet(object.conversionDateTime) ? globalThis.String(object.conversionDateTime) : undefined,
      conversionValue: isSet(object.conversionValue) ? globalThis.Number(object.conversionValue) : undefined,
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : undefined,
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : undefined,
      externalAttributionData: isSet(object.externalAttributionData)
        ? ExternalAttributionData.fromJSON(object.externalAttributionData)
        : undefined,
      customVariables: globalThis.Array.isArray(object?.customVariables)
        ? object.customVariables.map((e: any) => CustomVariable.fromJSON(e))
        : [],
      cartData: isSet(object.cartData) ? CartData.fromJSON(object.cartData) : undefined,
      userIdentifiers: globalThis.Array.isArray(object?.userIdentifiers)
        ? object.userIdentifiers.map((e: any) => UserIdentifier.fromJSON(e))
        : [],
      conversionEnvironment: isSet(object.conversionEnvironment)
        ? conversionEnvironmentEnum_ConversionEnvironmentFromJSON(object.conversionEnvironment)
        : 0,
      consent: isSet(object.consent) ? Consent.fromJSON(object.consent) : undefined,
    };
  },

  toJSON(message: ClickConversion): unknown {
    const obj: any = {};
    if (message.gclid !== undefined) {
      obj.gclid = message.gclid;
    }
    if (message.gbraid !== "") {
      obj.gbraid = message.gbraid;
    }
    if (message.wbraid !== "") {
      obj.wbraid = message.wbraid;
    }
    if (message.conversionAction !== undefined) {
      obj.conversionAction = message.conversionAction;
    }
    if (message.conversionDateTime !== undefined) {
      obj.conversionDateTime = message.conversionDateTime;
    }
    if (message.conversionValue !== undefined) {
      obj.conversionValue = message.conversionValue;
    }
    if (message.currencyCode !== undefined) {
      obj.currencyCode = message.currencyCode;
    }
    if (message.orderId !== undefined) {
      obj.orderId = message.orderId;
    }
    if (message.externalAttributionData !== undefined) {
      obj.externalAttributionData = ExternalAttributionData.toJSON(message.externalAttributionData);
    }
    if (message.customVariables?.length) {
      obj.customVariables = message.customVariables.map((e) => CustomVariable.toJSON(e));
    }
    if (message.cartData !== undefined) {
      obj.cartData = CartData.toJSON(message.cartData);
    }
    if (message.userIdentifiers?.length) {
      obj.userIdentifiers = message.userIdentifiers.map((e) => UserIdentifier.toJSON(e));
    }
    if (message.conversionEnvironment !== 0) {
      obj.conversionEnvironment = conversionEnvironmentEnum_ConversionEnvironmentToJSON(message.conversionEnvironment);
    }
    if (message.consent !== undefined) {
      obj.consent = Consent.toJSON(message.consent);
    }
    return obj;
  },

  create(base?: DeepPartial<ClickConversion>): ClickConversion {
    return ClickConversion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClickConversion>): ClickConversion {
    const message = createBaseClickConversion();
    message.gclid = object.gclid ?? undefined;
    message.gbraid = object.gbraid ?? "";
    message.wbraid = object.wbraid ?? "";
    message.conversionAction = object.conversionAction ?? undefined;
    message.conversionDateTime = object.conversionDateTime ?? undefined;
    message.conversionValue = object.conversionValue ?? undefined;
    message.currencyCode = object.currencyCode ?? undefined;
    message.orderId = object.orderId ?? undefined;
    message.externalAttributionData =
      (object.externalAttributionData !== undefined && object.externalAttributionData !== null)
        ? ExternalAttributionData.fromPartial(object.externalAttributionData)
        : undefined;
    message.customVariables = object.customVariables?.map((e) => CustomVariable.fromPartial(e)) || [];
    message.cartData = (object.cartData !== undefined && object.cartData !== null)
      ? CartData.fromPartial(object.cartData)
      : undefined;
    message.userIdentifiers = object.userIdentifiers?.map((e) => UserIdentifier.fromPartial(e)) || [];
    message.conversionEnvironment = object.conversionEnvironment ?? 0;
    message.consent = (object.consent !== undefined && object.consent !== null)
      ? Consent.fromPartial(object.consent)
      : undefined;
    return message;
  },
};

function createBaseCallConversion(): CallConversion {
  return {
    callerId: undefined,
    callStartDateTime: undefined,
    conversionAction: undefined,
    conversionDateTime: undefined,
    conversionValue: undefined,
    currencyCode: undefined,
    customVariables: [],
    consent: undefined,
  };
}

export const CallConversion: MessageFns<CallConversion> = {
  encode(message: CallConversion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callerId !== undefined) {
      writer.uint32(58).string(message.callerId);
    }
    if (message.callStartDateTime !== undefined) {
      writer.uint32(66).string(message.callStartDateTime);
    }
    if (message.conversionAction !== undefined) {
      writer.uint32(74).string(message.conversionAction);
    }
    if (message.conversionDateTime !== undefined) {
      writer.uint32(82).string(message.conversionDateTime);
    }
    if (message.conversionValue !== undefined) {
      writer.uint32(89).double(message.conversionValue);
    }
    if (message.currencyCode !== undefined) {
      writer.uint32(98).string(message.currencyCode);
    }
    for (const v of message.customVariables) {
      CustomVariable.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.consent !== undefined) {
      Consent.encode(message.consent, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallConversion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallConversion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.callerId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.callStartDateTime = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.conversionAction = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.conversionDateTime = reader.string();
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.conversionValue = reader.double();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.customVariables.push(CustomVariable.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.consent = Consent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallConversion {
    return {
      callerId: isSet(object.callerId) ? globalThis.String(object.callerId) : undefined,
      callStartDateTime: isSet(object.callStartDateTime) ? globalThis.String(object.callStartDateTime) : undefined,
      conversionAction: isSet(object.conversionAction) ? globalThis.String(object.conversionAction) : undefined,
      conversionDateTime: isSet(object.conversionDateTime) ? globalThis.String(object.conversionDateTime) : undefined,
      conversionValue: isSet(object.conversionValue) ? globalThis.Number(object.conversionValue) : undefined,
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : undefined,
      customVariables: globalThis.Array.isArray(object?.customVariables)
        ? object.customVariables.map((e: any) => CustomVariable.fromJSON(e))
        : [],
      consent: isSet(object.consent) ? Consent.fromJSON(object.consent) : undefined,
    };
  },

  toJSON(message: CallConversion): unknown {
    const obj: any = {};
    if (message.callerId !== undefined) {
      obj.callerId = message.callerId;
    }
    if (message.callStartDateTime !== undefined) {
      obj.callStartDateTime = message.callStartDateTime;
    }
    if (message.conversionAction !== undefined) {
      obj.conversionAction = message.conversionAction;
    }
    if (message.conversionDateTime !== undefined) {
      obj.conversionDateTime = message.conversionDateTime;
    }
    if (message.conversionValue !== undefined) {
      obj.conversionValue = message.conversionValue;
    }
    if (message.currencyCode !== undefined) {
      obj.currencyCode = message.currencyCode;
    }
    if (message.customVariables?.length) {
      obj.customVariables = message.customVariables.map((e) => CustomVariable.toJSON(e));
    }
    if (message.consent !== undefined) {
      obj.consent = Consent.toJSON(message.consent);
    }
    return obj;
  },

  create(base?: DeepPartial<CallConversion>): CallConversion {
    return CallConversion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CallConversion>): CallConversion {
    const message = createBaseCallConversion();
    message.callerId = object.callerId ?? undefined;
    message.callStartDateTime = object.callStartDateTime ?? undefined;
    message.conversionAction = object.conversionAction ?? undefined;
    message.conversionDateTime = object.conversionDateTime ?? undefined;
    message.conversionValue = object.conversionValue ?? undefined;
    message.currencyCode = object.currencyCode ?? undefined;
    message.customVariables = object.customVariables?.map((e) => CustomVariable.fromPartial(e)) || [];
    message.consent = (object.consent !== undefined && object.consent !== null)
      ? Consent.fromPartial(object.consent)
      : undefined;
    return message;
  },
};

function createBaseExternalAttributionData(): ExternalAttributionData {
  return { externalAttributionCredit: undefined, externalAttributionModel: undefined };
}

export const ExternalAttributionData: MessageFns<ExternalAttributionData> = {
  encode(message: ExternalAttributionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.externalAttributionCredit !== undefined) {
      writer.uint32(25).double(message.externalAttributionCredit);
    }
    if (message.externalAttributionModel !== undefined) {
      writer.uint32(34).string(message.externalAttributionModel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalAttributionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalAttributionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 25) {
            break;
          }

          message.externalAttributionCredit = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.externalAttributionModel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalAttributionData {
    return {
      externalAttributionCredit: isSet(object.externalAttributionCredit)
        ? globalThis.Number(object.externalAttributionCredit)
        : undefined,
      externalAttributionModel: isSet(object.externalAttributionModel)
        ? globalThis.String(object.externalAttributionModel)
        : undefined,
    };
  },

  toJSON(message: ExternalAttributionData): unknown {
    const obj: any = {};
    if (message.externalAttributionCredit !== undefined) {
      obj.externalAttributionCredit = message.externalAttributionCredit;
    }
    if (message.externalAttributionModel !== undefined) {
      obj.externalAttributionModel = message.externalAttributionModel;
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalAttributionData>): ExternalAttributionData {
    return ExternalAttributionData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalAttributionData>): ExternalAttributionData {
    const message = createBaseExternalAttributionData();
    message.externalAttributionCredit = object.externalAttributionCredit ?? undefined;
    message.externalAttributionModel = object.externalAttributionModel ?? undefined;
    return message;
  },
};

function createBaseClickConversionResult(): ClickConversionResult {
  return {
    gclid: undefined,
    gbraid: "",
    wbraid: "",
    conversionAction: undefined,
    conversionDateTime: undefined,
    userIdentifiers: [],
  };
}

export const ClickConversionResult: MessageFns<ClickConversionResult> = {
  encode(message: ClickConversionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gclid !== undefined) {
      writer.uint32(34).string(message.gclid);
    }
    if (message.gbraid !== "") {
      writer.uint32(66).string(message.gbraid);
    }
    if (message.wbraid !== "") {
      writer.uint32(74).string(message.wbraid);
    }
    if (message.conversionAction !== undefined) {
      writer.uint32(42).string(message.conversionAction);
    }
    if (message.conversionDateTime !== undefined) {
      writer.uint32(50).string(message.conversionDateTime);
    }
    for (const v of message.userIdentifiers) {
      UserIdentifier.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClickConversionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClickConversionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gclid = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.gbraid = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.wbraid = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.conversionAction = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.conversionDateTime = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.userIdentifiers.push(UserIdentifier.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClickConversionResult {
    return {
      gclid: isSet(object.gclid) ? globalThis.String(object.gclid) : undefined,
      gbraid: isSet(object.gbraid) ? globalThis.String(object.gbraid) : "",
      wbraid: isSet(object.wbraid) ? globalThis.String(object.wbraid) : "",
      conversionAction: isSet(object.conversionAction) ? globalThis.String(object.conversionAction) : undefined,
      conversionDateTime: isSet(object.conversionDateTime) ? globalThis.String(object.conversionDateTime) : undefined,
      userIdentifiers: globalThis.Array.isArray(object?.userIdentifiers)
        ? object.userIdentifiers.map((e: any) => UserIdentifier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClickConversionResult): unknown {
    const obj: any = {};
    if (message.gclid !== undefined) {
      obj.gclid = message.gclid;
    }
    if (message.gbraid !== "") {
      obj.gbraid = message.gbraid;
    }
    if (message.wbraid !== "") {
      obj.wbraid = message.wbraid;
    }
    if (message.conversionAction !== undefined) {
      obj.conversionAction = message.conversionAction;
    }
    if (message.conversionDateTime !== undefined) {
      obj.conversionDateTime = message.conversionDateTime;
    }
    if (message.userIdentifiers?.length) {
      obj.userIdentifiers = message.userIdentifiers.map((e) => UserIdentifier.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ClickConversionResult>): ClickConversionResult {
    return ClickConversionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClickConversionResult>): ClickConversionResult {
    const message = createBaseClickConversionResult();
    message.gclid = object.gclid ?? undefined;
    message.gbraid = object.gbraid ?? "";
    message.wbraid = object.wbraid ?? "";
    message.conversionAction = object.conversionAction ?? undefined;
    message.conversionDateTime = object.conversionDateTime ?? undefined;
    message.userIdentifiers = object.userIdentifiers?.map((e) => UserIdentifier.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCallConversionResult(): CallConversionResult {
  return {
    callerId: undefined,
    callStartDateTime: undefined,
    conversionAction: undefined,
    conversionDateTime: undefined,
  };
}

export const CallConversionResult: MessageFns<CallConversionResult> = {
  encode(message: CallConversionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callerId !== undefined) {
      writer.uint32(42).string(message.callerId);
    }
    if (message.callStartDateTime !== undefined) {
      writer.uint32(50).string(message.callStartDateTime);
    }
    if (message.conversionAction !== undefined) {
      writer.uint32(58).string(message.conversionAction);
    }
    if (message.conversionDateTime !== undefined) {
      writer.uint32(66).string(message.conversionDateTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallConversionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallConversionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.callerId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.callStartDateTime = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.conversionAction = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.conversionDateTime = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallConversionResult {
    return {
      callerId: isSet(object.callerId) ? globalThis.String(object.callerId) : undefined,
      callStartDateTime: isSet(object.callStartDateTime) ? globalThis.String(object.callStartDateTime) : undefined,
      conversionAction: isSet(object.conversionAction) ? globalThis.String(object.conversionAction) : undefined,
      conversionDateTime: isSet(object.conversionDateTime) ? globalThis.String(object.conversionDateTime) : undefined,
    };
  },

  toJSON(message: CallConversionResult): unknown {
    const obj: any = {};
    if (message.callerId !== undefined) {
      obj.callerId = message.callerId;
    }
    if (message.callStartDateTime !== undefined) {
      obj.callStartDateTime = message.callStartDateTime;
    }
    if (message.conversionAction !== undefined) {
      obj.conversionAction = message.conversionAction;
    }
    if (message.conversionDateTime !== undefined) {
      obj.conversionDateTime = message.conversionDateTime;
    }
    return obj;
  },

  create(base?: DeepPartial<CallConversionResult>): CallConversionResult {
    return CallConversionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CallConversionResult>): CallConversionResult {
    const message = createBaseCallConversionResult();
    message.callerId = object.callerId ?? undefined;
    message.callStartDateTime = object.callStartDateTime ?? undefined;
    message.conversionAction = object.conversionAction ?? undefined;
    message.conversionDateTime = object.conversionDateTime ?? undefined;
    return message;
  },
};

function createBaseCustomVariable(): CustomVariable {
  return { conversionCustomVariable: "", value: "" };
}

export const CustomVariable: MessageFns<CustomVariable> = {
  encode(message: CustomVariable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversionCustomVariable !== "") {
      writer.uint32(10).string(message.conversionCustomVariable);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomVariable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversionCustomVariable = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomVariable {
    return {
      conversionCustomVariable: isSet(object.conversionCustomVariable)
        ? globalThis.String(object.conversionCustomVariable)
        : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CustomVariable): unknown {
    const obj: any = {};
    if (message.conversionCustomVariable !== "") {
      obj.conversionCustomVariable = message.conversionCustomVariable;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomVariable>): CustomVariable {
    return CustomVariable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomVariable>): CustomVariable {
    const message = createBaseCustomVariable();
    message.conversionCustomVariable = object.conversionCustomVariable ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCartData(): CartData {
  return { merchantId: Long.ZERO, feedCountryCode: "", feedLanguageCode: "", localTransactionCost: 0, items: [] };
}

export const CartData: MessageFns<CartData> = {
  encode(message: CartData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.merchantId.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.merchantId.toString());
    }
    if (message.feedCountryCode !== "") {
      writer.uint32(18).string(message.feedCountryCode);
    }
    if (message.feedLanguageCode !== "") {
      writer.uint32(26).string(message.feedLanguageCode);
    }
    if (message.localTransactionCost !== 0) {
      writer.uint32(33).double(message.localTransactionCost);
    }
    for (const v of message.items) {
      CartData_Item.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CartData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCartData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 48) {
            break;
          }

          message.merchantId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feedCountryCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feedLanguageCode = reader.string();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.localTransactionCost = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.items.push(CartData_Item.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CartData {
    return {
      merchantId: isSet(object.merchantId) ? Long.fromValue(object.merchantId) : Long.ZERO,
      feedCountryCode: isSet(object.feedCountryCode) ? globalThis.String(object.feedCountryCode) : "",
      feedLanguageCode: isSet(object.feedLanguageCode) ? globalThis.String(object.feedLanguageCode) : "",
      localTransactionCost: isSet(object.localTransactionCost) ? globalThis.Number(object.localTransactionCost) : 0,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => CartData_Item.fromJSON(e)) : [],
    };
  },

  toJSON(message: CartData): unknown {
    const obj: any = {};
    if (!message.merchantId.equals(Long.ZERO)) {
      obj.merchantId = (message.merchantId || Long.ZERO).toString();
    }
    if (message.feedCountryCode !== "") {
      obj.feedCountryCode = message.feedCountryCode;
    }
    if (message.feedLanguageCode !== "") {
      obj.feedLanguageCode = message.feedLanguageCode;
    }
    if (message.localTransactionCost !== 0) {
      obj.localTransactionCost = message.localTransactionCost;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CartData_Item.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CartData>): CartData {
    return CartData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CartData>): CartData {
    const message = createBaseCartData();
    message.merchantId = (object.merchantId !== undefined && object.merchantId !== null)
      ? Long.fromValue(object.merchantId)
      : Long.ZERO;
    message.feedCountryCode = object.feedCountryCode ?? "";
    message.feedLanguageCode = object.feedLanguageCode ?? "";
    message.localTransactionCost = object.localTransactionCost ?? 0;
    message.items = object.items?.map((e) => CartData_Item.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCartData_Item(): CartData_Item {
  return { productId: "", quantity: 0, unitPrice: 0 };
}

export const CartData_Item: MessageFns<CartData_Item> = {
  encode(message: CartData_Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int32(message.quantity);
    }
    if (message.unitPrice !== 0) {
      writer.uint32(25).double(message.unitPrice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CartData_Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCartData_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.unitPrice = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CartData_Item {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      unitPrice: isSet(object.unitPrice) ? globalThis.Number(object.unitPrice) : 0,
    };
  },

  toJSON(message: CartData_Item): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.unitPrice !== 0) {
      obj.unitPrice = message.unitPrice;
    }
    return obj;
  },

  create(base?: DeepPartial<CartData_Item>): CartData_Item {
    return CartData_Item.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CartData_Item>): CartData_Item {
    const message = createBaseCartData_Item();
    message.productId = object.productId ?? "";
    message.quantity = object.quantity ?? 0;
    message.unitPrice = object.unitPrice ?? 0;
    return message;
  },
};

/** Service to upload conversions. */
export type ConversionUploadServiceDefinition = typeof ConversionUploadServiceDefinition;
export const ConversionUploadServiceDefinition = {
  name: "ConversionUploadService",
  fullName: "google.ads.googleads.v16.services.ConversionUploadService",
  methods: {
    /**
     * Processes the given click conversions.
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [ConversionUploadError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [PartialFailureError]()
     *   [QuotaError]()
     *   [RequestError]()
     */
    uploadClickConversions: {
      name: "UploadClickConversions",
      requestType: UploadClickConversionsRequest,
      requestStream: false,
      responseType: UploadClickConversionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              39,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              44,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              44,
              112,
              97,
              114,
              116,
              105,
              97,
              108,
              95,
              102,
              97,
              105,
              108,
              117,
              114,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              58,
              58,
              1,
              42,
              34,
              53,
              47,
              118,
              49,
              54,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              61,
              42,
              125,
              58,
              117,
              112,
              108,
              111,
              97,
              100,
              67,
              108,
              105,
              99,
              107,
              67,
              111,
              110,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Processes the given call conversions.
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [PartialFailureError]()
     *   [QuotaError]()
     *   [RequestError]()
     */
    uploadCallConversions: {
      name: "UploadCallConversions",
      requestType: UploadCallConversionsRequest,
      requestStream: false,
      responseType: UploadCallConversionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              39,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              44,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              44,
              112,
              97,
              114,
              116,
              105,
              97,
              108,
              95,
              102,
              97,
              105,
              108,
              117,
              114,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              57,
              58,
              1,
              42,
              34,
              52,
              47,
              118,
              49,
              54,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              61,
              42,
              125,
              58,
              117,
              112,
              108,
              111,
              97,
              100,
              67,
              97,
              108,
              108,
              67,
              111,
              110,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ConversionUploadServiceImplementation<CallContextExt = {}> {
  /**
   * Processes the given click conversions.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [ConversionUploadError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [PartialFailureError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  uploadClickConversions(
    request: UploadClickConversionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UploadClickConversionsResponse>>;
  /**
   * Processes the given call conversions.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [PartialFailureError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  uploadCallConversions(
    request: UploadCallConversionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UploadCallConversionsResponse>>;
}

export interface ConversionUploadServiceClient<CallOptionsExt = {}> {
  /**
   * Processes the given click conversions.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [ConversionUploadError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [PartialFailureError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  uploadClickConversions(
    request: DeepPartial<UploadClickConversionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UploadClickConversionsResponse>;
  /**
   * Processes the given call conversions.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [PartialFailureError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  uploadCallConversions(
    request: DeepPartial<UploadCallConversionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UploadCallConversionsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
