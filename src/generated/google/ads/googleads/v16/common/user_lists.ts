// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v16/common/user_lists.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  CustomerMatchUploadKeyTypeEnum_CustomerMatchUploadKeyType,
  customerMatchUploadKeyTypeEnum_CustomerMatchUploadKeyTypeFromJSON,
  customerMatchUploadKeyTypeEnum_CustomerMatchUploadKeyTypeToJSON,
} from "../enums/customer_match_upload_key_type.js";
import {
  LookalikeExpansionLevelEnum_LookalikeExpansionLevel,
  lookalikeExpansionLevelEnum_LookalikeExpansionLevelFromJSON,
  lookalikeExpansionLevelEnum_LookalikeExpansionLevelToJSON,
} from "../enums/lookalike_expansion_level.js";
import {
  UserListCrmDataSourceTypeEnum_UserListCrmDataSourceType,
  userListCrmDataSourceTypeEnum_UserListCrmDataSourceTypeFromJSON,
  userListCrmDataSourceTypeEnum_UserListCrmDataSourceTypeToJSON,
} from "../enums/user_list_crm_data_source_type.js";
import {
  UserListDateRuleItemOperatorEnum_UserListDateRuleItemOperator,
  userListDateRuleItemOperatorEnum_UserListDateRuleItemOperatorFromJSON,
  userListDateRuleItemOperatorEnum_UserListDateRuleItemOperatorToJSON,
} from "../enums/user_list_date_rule_item_operator.js";
import {
  UserListFlexibleRuleOperatorEnum_UserListFlexibleRuleOperator,
  userListFlexibleRuleOperatorEnum_UserListFlexibleRuleOperatorFromJSON,
  userListFlexibleRuleOperatorEnum_UserListFlexibleRuleOperatorToJSON,
} from "../enums/user_list_flexible_rule_operator.js";
import {
  UserListLogicalRuleOperatorEnum_UserListLogicalRuleOperator,
  userListLogicalRuleOperatorEnum_UserListLogicalRuleOperatorFromJSON,
  userListLogicalRuleOperatorEnum_UserListLogicalRuleOperatorToJSON,
} from "../enums/user_list_logical_rule_operator.js";
import {
  UserListNumberRuleItemOperatorEnum_UserListNumberRuleItemOperator,
  userListNumberRuleItemOperatorEnum_UserListNumberRuleItemOperatorFromJSON,
  userListNumberRuleItemOperatorEnum_UserListNumberRuleItemOperatorToJSON,
} from "../enums/user_list_number_rule_item_operator.js";
import {
  UserListPrepopulationStatusEnum_UserListPrepopulationStatus,
  userListPrepopulationStatusEnum_UserListPrepopulationStatusFromJSON,
  userListPrepopulationStatusEnum_UserListPrepopulationStatusToJSON,
} from "../enums/user_list_prepopulation_status.js";
import {
  UserListRuleTypeEnum_UserListRuleType,
  userListRuleTypeEnum_UserListRuleTypeFromJSON,
  userListRuleTypeEnum_UserListRuleTypeToJSON,
} from "../enums/user_list_rule_type.js";
import {
  UserListStringRuleItemOperatorEnum_UserListStringRuleItemOperator,
  userListStringRuleItemOperatorEnum_UserListStringRuleItemOperatorFromJSON,
  userListStringRuleItemOperatorEnum_UserListStringRuleItemOperatorToJSON,
} from "../enums/user_list_string_rule_item_operator.js";

export const protobufPackage = "google.ads.googleads.v16.common";

/**
 * LookalikeUserlist, composed of users similar to those
 *   of a configurable seed (set of UserLists)
 */
export interface LookalikeUserListInfo {
  /** Seed UserList ID from which this list is derived, provided by user. */
  seedUserListIds: Long[];
  /** Expansion level, reflecting the size of the lookalike audience */
  expansionLevel: LookalikeExpansionLevelEnum_LookalikeExpansionLevel;
  /**
   * Countries targeted by the Lookalike. Two-letter country code as defined by
   * ISO-3166
   */
  countryCodes: string[];
}

/**
 * SimilarUserList is a list of users which are similar to users from another
 * UserList. These lists are read-only and automatically created by Google.
 */
export interface SimilarUserListInfo {
  /** Seed UserList from which this list is derived. */
  seedUserList?: string | undefined;
}

/** UserList of CRM users provided by the advertiser. */
export interface CrmBasedUserListInfo {
  /**
   * A string that uniquely identifies a mobile application from which the data
   * was collected.
   * For iOS, the ID string is the 9 digit string that appears at the end of an
   * App Store URL (for example, "476943146" for "Flood-It! 2" whose App Store
   * link is http://itunes.apple.com/us/app/flood-it!-2/id476943146). For
   * Android, the ID string is the application's package name (for example,
   * "com.labpixies.colordrips" for "Color Drips" given Google Play link
   * https://play.google.com/store/apps/details?id=com.labpixies.colordrips).
   * Required when creating CrmBasedUserList for uploading mobile advertising
   * IDs.
   */
  appId?:
    | string
    | undefined;
  /**
   * Matching key type of the list.
   * Mixed data types are not allowed on the same list.
   * This field is required for an ADD operation.
   */
  uploadKeyType: CustomerMatchUploadKeyTypeEnum_CustomerMatchUploadKeyType;
  /**
   * Data source of the list. Default value is FIRST_PARTY.
   * Only customers on the allow-list can create third-party sourced CRM lists.
   */
  dataSourceType: UserListCrmDataSourceTypeEnum_UserListCrmDataSourceType;
}

/**
 * A client defined rule based on custom parameters sent by web sites or
 * uploaded by the advertiser.
 */
export interface UserListRuleInfo {
  /**
   * Rule type is used to determine how to group rule items.
   *
   * The default is OR of ANDs (disjunctive normal form).
   * That is, rule items will be ANDed together within rule item groups and the
   * groups themselves will be ORed together.
   *
   * OR of ANDs is the only supported type for FlexibleRuleUserList.
   */
  ruleType: UserListRuleTypeEnum_UserListRuleType;
  /**
   * List of rule item groups that defines this rule.
   * Rule item groups are grouped together based on rule_type.
   */
  ruleItemGroups: UserListRuleItemGroupInfo[];
}

/** A group of rule items. */
export interface UserListRuleItemGroupInfo {
  /** Rule items that will be grouped together based on rule_type. */
  ruleItems: UserListRuleItemInfo[];
}

/** An atomic rule item. */
export interface UserListRuleItemInfo {
  /**
   * Rule variable name. It should match the corresponding key name fired
   * by the pixel.
   * A name must begin with US-ascii letters or underscore or UTF8 code that is
   * greater than 127 and consist of US-ascii letters or digits or underscore or
   * UTF8 code that is greater than 127.
   * For websites, there are two built-in variable URL (name = 'url__') and
   * referrer URL (name = 'ref_url__').
   * This field must be populated when creating a new rule item.
   */
  name?:
    | string
    | undefined;
  /** An atomic rule item composed of a number operation. */
  numberRuleItem?:
    | UserListNumberRuleItemInfo
    | undefined;
  /** An atomic rule item composed of a string operation. */
  stringRuleItem?:
    | UserListStringRuleItemInfo
    | undefined;
  /** An atomic rule item composed of a date operation. */
  dateRuleItem?: UserListDateRuleItemInfo | undefined;
}

/** A rule item composed of a date operation. */
export interface UserListDateRuleItemInfo {
  /**
   * Date comparison operator.
   * This field is required and must be populated when creating new date
   * rule item.
   */
  operator: UserListDateRuleItemOperatorEnum_UserListDateRuleItemOperator;
  /**
   * String representing date value to be compared with the rule variable.
   * Supported date format is YYYY-MM-DD.
   * Times are reported in the customer's time zone.
   */
  value?:
    | string
    | undefined;
  /**
   * The relative date value of the right hand side denoted by number of days
   * offset from now. The value field will override this field when both are
   * present.
   */
  offsetInDays?: Long | undefined;
}

/** A rule item composed of a number operation. */
export interface UserListNumberRuleItemInfo {
  /**
   * Number comparison operator.
   * This field is required and must be populated when creating a new number
   * rule item.
   */
  operator: UserListNumberRuleItemOperatorEnum_UserListNumberRuleItemOperator;
  /**
   * Number value to be compared with the variable.
   * This field is required and must be populated when creating a new number
   * rule item.
   */
  value?: number | undefined;
}

/** A rule item composed of a string operation. */
export interface UserListStringRuleItemInfo {
  /**
   * String comparison operator.
   * This field is required and must be populated when creating a new string
   * rule item.
   */
  operator: UserListStringRuleItemOperatorEnum_UserListStringRuleItemOperator;
  /**
   * The right hand side of the string rule item. For URLs or referrer URLs,
   * the value can not contain illegal URL chars such as newlines, quotes,
   * tabs, or parentheses. This field is required and must be populated when
   * creating a new string rule item.
   */
  value?: string | undefined;
}

/** Flexible rule that wraps the common rule and a lookback window. */
export interface FlexibleRuleOperandInfo {
  /**
   * List of rule item groups that defines this rule.
   * Rule item groups are grouped together.
   */
  rule:
    | UserListRuleInfo
    | undefined;
  /** Lookback window for this rule in days. From now until X days ago. */
  lookbackWindowDays?: Long | undefined;
}

/**
 * Flexible rule representation of visitors with one or multiple actions. The
 * flexible user list is defined by two lists of operands – inclusive_operands
 * and exclusive_operands; each operand represents a set of users based on
 * actions they took in a given timeframe. These lists of operands are combined
 * with the AND_NOT operator, so that users represented by the inclusive
 * operands are included in the user list, minus the users represented by the
 * exclusive operands.
 */
export interface FlexibleRuleUserListInfo {
  /** Operator that defines how the inclusive operands are combined. */
  inclusiveRuleOperator: UserListFlexibleRuleOperatorEnum_UserListFlexibleRuleOperator;
  /**
   * Rules representing users that should be included in the user list. These
   * are located on the left side of the AND_NOT operator, and joined together
   * by either AND/OR as specified by the inclusive_rule_operator.
   */
  inclusiveOperands: FlexibleRuleOperandInfo[];
  /**
   * Rules representing users that should be excluded from the user list. These
   * are located on the right side of the AND_NOT operator, and joined together
   * by OR.
   */
  exclusiveOperands: FlexibleRuleOperandInfo[];
}

/** Representation of a userlist that is generated by a rule. */
export interface RuleBasedUserListInfo {
  /**
   * The status of pre-population. The field is default to NONE if not set which
   * means the previous users will not be considered. If set to REQUESTED, past
   * site visitors or app users who match the list definition will be included
   * in the list (works on the Display Network only). This will only
   * add past users from within the last 30 days, depending on the
   * list's membership duration and the date when the remarketing tag is added.
   * The status will be updated to FINISHED once request is processed, or FAILED
   * if the request fails.
   */
  prepopulationStatus: UserListPrepopulationStatusEnum_UserListPrepopulationStatus;
  /**
   * Flexible rule representation of visitors with one or multiple actions. The
   * flexible user list is defined by two lists of operands – inclusive_operands
   * and exclusive_operands; each operand represents a set of users based on
   * actions they took in a given timeframe. These lists of operands are
   * combined with the AND_NOT operator, so that users represented by the
   * inclusive operands are included in the user list, minus the users
   * represented by the exclusive operands.
   */
  flexibleRuleUserList: FlexibleRuleUserListInfo | undefined;
}

/** Represents a user list that is a custom combination of user lists. */
export interface LogicalUserListInfo {
  /**
   * Logical list rules that define this user list. The rules are defined as a
   * logical operator (ALL/ANY/NONE) and a list of user lists. All the rules are
   * ANDed when they are evaluated.
   *
   * Required for creating a logical user list.
   */
  rules: UserListLogicalRuleInfo[];
}

/**
 * A user list logical rule. A rule has a logical operator (and/or/not) and a
 * list of user lists as operands.
 */
export interface UserListLogicalRuleInfo {
  /** The logical operator of the rule. */
  operator: UserListLogicalRuleOperatorEnum_UserListLogicalRuleOperator;
  /** The list of operands of the rule. */
  ruleOperands: LogicalUserListOperandInfo[];
}

/** Operand of logical user list that consists of a user list. */
export interface LogicalUserListOperandInfo {
  /** Resource name of a user list as an operand. */
  userList?: string | undefined;
}

/** User list targeting as a collection of conversions or remarketing actions. */
export interface BasicUserListInfo {
  /** Actions associated with this user list. */
  actions: UserListActionInfo[];
}

/** Represents an action type used for building remarketing user lists. */
export interface UserListActionInfo {
  /** A conversion action that's not generated from remarketing. */
  conversionAction?:
    | string
    | undefined;
  /** A remarketing action. */
  remarketingAction?: string | undefined;
}

function createBaseLookalikeUserListInfo(): LookalikeUserListInfo {
  return { seedUserListIds: [], expansionLevel: 0, countryCodes: [] };
}

export const LookalikeUserListInfo: MessageFns<LookalikeUserListInfo> = {
  encode(message: LookalikeUserListInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.seedUserListIds) {
      writer.int64(v.toString());
    }
    writer.join();
    if (message.expansionLevel !== 0) {
      writer.uint32(16).int32(message.expansionLevel);
    }
    for (const v of message.countryCodes) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookalikeUserListInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookalikeUserListInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.seedUserListIds.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.seedUserListIds.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.expansionLevel = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.countryCodes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookalikeUserListInfo {
    return {
      seedUserListIds: globalThis.Array.isArray(object?.seedUserListIds)
        ? object.seedUserListIds.map((e: any) => Long.fromValue(e))
        : [],
      expansionLevel: isSet(object.expansionLevel)
        ? lookalikeExpansionLevelEnum_LookalikeExpansionLevelFromJSON(object.expansionLevel)
        : 0,
      countryCodes: globalThis.Array.isArray(object?.countryCodes)
        ? object.countryCodes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: LookalikeUserListInfo): unknown {
    const obj: any = {};
    if (message.seedUserListIds?.length) {
      obj.seedUserListIds = message.seedUserListIds.map((e) => (e || Long.ZERO).toString());
    }
    if (message.expansionLevel !== 0) {
      obj.expansionLevel = lookalikeExpansionLevelEnum_LookalikeExpansionLevelToJSON(message.expansionLevel);
    }
    if (message.countryCodes?.length) {
      obj.countryCodes = message.countryCodes;
    }
    return obj;
  },

  create(base?: DeepPartial<LookalikeUserListInfo>): LookalikeUserListInfo {
    return LookalikeUserListInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LookalikeUserListInfo>): LookalikeUserListInfo {
    const message = createBaseLookalikeUserListInfo();
    message.seedUserListIds = object.seedUserListIds?.map((e) => Long.fromValue(e)) || [];
    message.expansionLevel = object.expansionLevel ?? 0;
    message.countryCodes = object.countryCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseSimilarUserListInfo(): SimilarUserListInfo {
  return { seedUserList: undefined };
}

export const SimilarUserListInfo: MessageFns<SimilarUserListInfo> = {
  encode(message: SimilarUserListInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seedUserList !== undefined) {
      writer.uint32(18).string(message.seedUserList);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimilarUserListInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimilarUserListInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.seedUserList = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimilarUserListInfo {
    return { seedUserList: isSet(object.seedUserList) ? globalThis.String(object.seedUserList) : undefined };
  },

  toJSON(message: SimilarUserListInfo): unknown {
    const obj: any = {};
    if (message.seedUserList !== undefined) {
      obj.seedUserList = message.seedUserList;
    }
    return obj;
  },

  create(base?: DeepPartial<SimilarUserListInfo>): SimilarUserListInfo {
    return SimilarUserListInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SimilarUserListInfo>): SimilarUserListInfo {
    const message = createBaseSimilarUserListInfo();
    message.seedUserList = object.seedUserList ?? undefined;
    return message;
  },
};

function createBaseCrmBasedUserListInfo(): CrmBasedUserListInfo {
  return { appId: undefined, uploadKeyType: 0, dataSourceType: 0 };
}

export const CrmBasedUserListInfo: MessageFns<CrmBasedUserListInfo> = {
  encode(message: CrmBasedUserListInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appId !== undefined) {
      writer.uint32(34).string(message.appId);
    }
    if (message.uploadKeyType !== 0) {
      writer.uint32(16).int32(message.uploadKeyType);
    }
    if (message.dataSourceType !== 0) {
      writer.uint32(24).int32(message.dataSourceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CrmBasedUserListInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrmBasedUserListInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.appId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.uploadKeyType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dataSourceType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrmBasedUserListInfo {
    return {
      appId: isSet(object.appId) ? globalThis.String(object.appId) : undefined,
      uploadKeyType: isSet(object.uploadKeyType)
        ? customerMatchUploadKeyTypeEnum_CustomerMatchUploadKeyTypeFromJSON(object.uploadKeyType)
        : 0,
      dataSourceType: isSet(object.dataSourceType)
        ? userListCrmDataSourceTypeEnum_UserListCrmDataSourceTypeFromJSON(object.dataSourceType)
        : 0,
    };
  },

  toJSON(message: CrmBasedUserListInfo): unknown {
    const obj: any = {};
    if (message.appId !== undefined) {
      obj.appId = message.appId;
    }
    if (message.uploadKeyType !== 0) {
      obj.uploadKeyType = customerMatchUploadKeyTypeEnum_CustomerMatchUploadKeyTypeToJSON(message.uploadKeyType);
    }
    if (message.dataSourceType !== 0) {
      obj.dataSourceType = userListCrmDataSourceTypeEnum_UserListCrmDataSourceTypeToJSON(message.dataSourceType);
    }
    return obj;
  },

  create(base?: DeepPartial<CrmBasedUserListInfo>): CrmBasedUserListInfo {
    return CrmBasedUserListInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CrmBasedUserListInfo>): CrmBasedUserListInfo {
    const message = createBaseCrmBasedUserListInfo();
    message.appId = object.appId ?? undefined;
    message.uploadKeyType = object.uploadKeyType ?? 0;
    message.dataSourceType = object.dataSourceType ?? 0;
    return message;
  },
};

function createBaseUserListRuleInfo(): UserListRuleInfo {
  return { ruleType: 0, ruleItemGroups: [] };
}

export const UserListRuleInfo: MessageFns<UserListRuleInfo> = {
  encode(message: UserListRuleInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ruleType !== 0) {
      writer.uint32(8).int32(message.ruleType);
    }
    for (const v of message.ruleItemGroups) {
      UserListRuleItemGroupInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserListRuleInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserListRuleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ruleType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ruleItemGroups.push(UserListRuleItemGroupInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserListRuleInfo {
    return {
      ruleType: isSet(object.ruleType) ? userListRuleTypeEnum_UserListRuleTypeFromJSON(object.ruleType) : 0,
      ruleItemGroups: globalThis.Array.isArray(object?.ruleItemGroups)
        ? object.ruleItemGroups.map((e: any) => UserListRuleItemGroupInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserListRuleInfo): unknown {
    const obj: any = {};
    if (message.ruleType !== 0) {
      obj.ruleType = userListRuleTypeEnum_UserListRuleTypeToJSON(message.ruleType);
    }
    if (message.ruleItemGroups?.length) {
      obj.ruleItemGroups = message.ruleItemGroups.map((e) => UserListRuleItemGroupInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UserListRuleInfo>): UserListRuleInfo {
    return UserListRuleInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserListRuleInfo>): UserListRuleInfo {
    const message = createBaseUserListRuleInfo();
    message.ruleType = object.ruleType ?? 0;
    message.ruleItemGroups = object.ruleItemGroups?.map((e) => UserListRuleItemGroupInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserListRuleItemGroupInfo(): UserListRuleItemGroupInfo {
  return { ruleItems: [] };
}

export const UserListRuleItemGroupInfo: MessageFns<UserListRuleItemGroupInfo> = {
  encode(message: UserListRuleItemGroupInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ruleItems) {
      UserListRuleItemInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserListRuleItemGroupInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserListRuleItemGroupInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ruleItems.push(UserListRuleItemInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserListRuleItemGroupInfo {
    return {
      ruleItems: globalThis.Array.isArray(object?.ruleItems)
        ? object.ruleItems.map((e: any) => UserListRuleItemInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserListRuleItemGroupInfo): unknown {
    const obj: any = {};
    if (message.ruleItems?.length) {
      obj.ruleItems = message.ruleItems.map((e) => UserListRuleItemInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UserListRuleItemGroupInfo>): UserListRuleItemGroupInfo {
    return UserListRuleItemGroupInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserListRuleItemGroupInfo>): UserListRuleItemGroupInfo {
    const message = createBaseUserListRuleItemGroupInfo();
    message.ruleItems = object.ruleItems?.map((e) => UserListRuleItemInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserListRuleItemInfo(): UserListRuleItemInfo {
  return { name: undefined, numberRuleItem: undefined, stringRuleItem: undefined, dateRuleItem: undefined };
}

export const UserListRuleItemInfo: MessageFns<UserListRuleItemInfo> = {
  encode(message: UserListRuleItemInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(42).string(message.name);
    }
    if (message.numberRuleItem !== undefined) {
      UserListNumberRuleItemInfo.encode(message.numberRuleItem, writer.uint32(18).fork()).join();
    }
    if (message.stringRuleItem !== undefined) {
      UserListStringRuleItemInfo.encode(message.stringRuleItem, writer.uint32(26).fork()).join();
    }
    if (message.dateRuleItem !== undefined) {
      UserListDateRuleItemInfo.encode(message.dateRuleItem, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserListRuleItemInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserListRuleItemInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.numberRuleItem = UserListNumberRuleItemInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stringRuleItem = UserListStringRuleItemInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dateRuleItem = UserListDateRuleItemInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserListRuleItemInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      numberRuleItem: isSet(object.numberRuleItem)
        ? UserListNumberRuleItemInfo.fromJSON(object.numberRuleItem)
        : undefined,
      stringRuleItem: isSet(object.stringRuleItem)
        ? UserListStringRuleItemInfo.fromJSON(object.stringRuleItem)
        : undefined,
      dateRuleItem: isSet(object.dateRuleItem) ? UserListDateRuleItemInfo.fromJSON(object.dateRuleItem) : undefined,
    };
  },

  toJSON(message: UserListRuleItemInfo): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.numberRuleItem !== undefined) {
      obj.numberRuleItem = UserListNumberRuleItemInfo.toJSON(message.numberRuleItem);
    }
    if (message.stringRuleItem !== undefined) {
      obj.stringRuleItem = UserListStringRuleItemInfo.toJSON(message.stringRuleItem);
    }
    if (message.dateRuleItem !== undefined) {
      obj.dateRuleItem = UserListDateRuleItemInfo.toJSON(message.dateRuleItem);
    }
    return obj;
  },

  create(base?: DeepPartial<UserListRuleItemInfo>): UserListRuleItemInfo {
    return UserListRuleItemInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserListRuleItemInfo>): UserListRuleItemInfo {
    const message = createBaseUserListRuleItemInfo();
    message.name = object.name ?? undefined;
    message.numberRuleItem = (object.numberRuleItem !== undefined && object.numberRuleItem !== null)
      ? UserListNumberRuleItemInfo.fromPartial(object.numberRuleItem)
      : undefined;
    message.stringRuleItem = (object.stringRuleItem !== undefined && object.stringRuleItem !== null)
      ? UserListStringRuleItemInfo.fromPartial(object.stringRuleItem)
      : undefined;
    message.dateRuleItem = (object.dateRuleItem !== undefined && object.dateRuleItem !== null)
      ? UserListDateRuleItemInfo.fromPartial(object.dateRuleItem)
      : undefined;
    return message;
  },
};

function createBaseUserListDateRuleItemInfo(): UserListDateRuleItemInfo {
  return { operator: 0, value: undefined, offsetInDays: undefined };
}

export const UserListDateRuleItemInfo: MessageFns<UserListDateRuleItemInfo> = {
  encode(message: UserListDateRuleItemInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== 0) {
      writer.uint32(8).int32(message.operator);
    }
    if (message.value !== undefined) {
      writer.uint32(34).string(message.value);
    }
    if (message.offsetInDays !== undefined) {
      writer.uint32(40).int64(message.offsetInDays.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserListDateRuleItemInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserListDateRuleItemInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.offsetInDays = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserListDateRuleItemInfo {
    return {
      operator: isSet(object.operator)
        ? userListDateRuleItemOperatorEnum_UserListDateRuleItemOperatorFromJSON(object.operator)
        : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      offsetInDays: isSet(object.offsetInDays) ? Long.fromValue(object.offsetInDays) : undefined,
    };
  },

  toJSON(message: UserListDateRuleItemInfo): unknown {
    const obj: any = {};
    if (message.operator !== 0) {
      obj.operator = userListDateRuleItemOperatorEnum_UserListDateRuleItemOperatorToJSON(message.operator);
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.offsetInDays !== undefined) {
      obj.offsetInDays = (message.offsetInDays || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UserListDateRuleItemInfo>): UserListDateRuleItemInfo {
    return UserListDateRuleItemInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserListDateRuleItemInfo>): UserListDateRuleItemInfo {
    const message = createBaseUserListDateRuleItemInfo();
    message.operator = object.operator ?? 0;
    message.value = object.value ?? undefined;
    message.offsetInDays = (object.offsetInDays !== undefined && object.offsetInDays !== null)
      ? Long.fromValue(object.offsetInDays)
      : undefined;
    return message;
  },
};

function createBaseUserListNumberRuleItemInfo(): UserListNumberRuleItemInfo {
  return { operator: 0, value: undefined };
}

export const UserListNumberRuleItemInfo: MessageFns<UserListNumberRuleItemInfo> = {
  encode(message: UserListNumberRuleItemInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== 0) {
      writer.uint32(8).int32(message.operator);
    }
    if (message.value !== undefined) {
      writer.uint32(25).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserListNumberRuleItemInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserListNumberRuleItemInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserListNumberRuleItemInfo {
    return {
      operator: isSet(object.operator)
        ? userListNumberRuleItemOperatorEnum_UserListNumberRuleItemOperatorFromJSON(object.operator)
        : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : undefined,
    };
  },

  toJSON(message: UserListNumberRuleItemInfo): unknown {
    const obj: any = {};
    if (message.operator !== 0) {
      obj.operator = userListNumberRuleItemOperatorEnum_UserListNumberRuleItemOperatorToJSON(message.operator);
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<UserListNumberRuleItemInfo>): UserListNumberRuleItemInfo {
    return UserListNumberRuleItemInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserListNumberRuleItemInfo>): UserListNumberRuleItemInfo {
    const message = createBaseUserListNumberRuleItemInfo();
    message.operator = object.operator ?? 0;
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseUserListStringRuleItemInfo(): UserListStringRuleItemInfo {
  return { operator: 0, value: undefined };
}

export const UserListStringRuleItemInfo: MessageFns<UserListStringRuleItemInfo> = {
  encode(message: UserListStringRuleItemInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== 0) {
      writer.uint32(8).int32(message.operator);
    }
    if (message.value !== undefined) {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserListStringRuleItemInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserListStringRuleItemInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserListStringRuleItemInfo {
    return {
      operator: isSet(object.operator)
        ? userListStringRuleItemOperatorEnum_UserListStringRuleItemOperatorFromJSON(object.operator)
        : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
    };
  },

  toJSON(message: UserListStringRuleItemInfo): unknown {
    const obj: any = {};
    if (message.operator !== 0) {
      obj.operator = userListStringRuleItemOperatorEnum_UserListStringRuleItemOperatorToJSON(message.operator);
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<UserListStringRuleItemInfo>): UserListStringRuleItemInfo {
    return UserListStringRuleItemInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserListStringRuleItemInfo>): UserListStringRuleItemInfo {
    const message = createBaseUserListStringRuleItemInfo();
    message.operator = object.operator ?? 0;
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseFlexibleRuleOperandInfo(): FlexibleRuleOperandInfo {
  return { rule: undefined, lookbackWindowDays: undefined };
}

export const FlexibleRuleOperandInfo: MessageFns<FlexibleRuleOperandInfo> = {
  encode(message: FlexibleRuleOperandInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rule !== undefined) {
      UserListRuleInfo.encode(message.rule, writer.uint32(10).fork()).join();
    }
    if (message.lookbackWindowDays !== undefined) {
      writer.uint32(16).int64(message.lookbackWindowDays.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlexibleRuleOperandInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlexibleRuleOperandInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rule = UserListRuleInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lookbackWindowDays = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlexibleRuleOperandInfo {
    return {
      rule: isSet(object.rule) ? UserListRuleInfo.fromJSON(object.rule) : undefined,
      lookbackWindowDays: isSet(object.lookbackWindowDays) ? Long.fromValue(object.lookbackWindowDays) : undefined,
    };
  },

  toJSON(message: FlexibleRuleOperandInfo): unknown {
    const obj: any = {};
    if (message.rule !== undefined) {
      obj.rule = UserListRuleInfo.toJSON(message.rule);
    }
    if (message.lookbackWindowDays !== undefined) {
      obj.lookbackWindowDays = (message.lookbackWindowDays || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<FlexibleRuleOperandInfo>): FlexibleRuleOperandInfo {
    return FlexibleRuleOperandInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FlexibleRuleOperandInfo>): FlexibleRuleOperandInfo {
    const message = createBaseFlexibleRuleOperandInfo();
    message.rule = (object.rule !== undefined && object.rule !== null)
      ? UserListRuleInfo.fromPartial(object.rule)
      : undefined;
    message.lookbackWindowDays = (object.lookbackWindowDays !== undefined && object.lookbackWindowDays !== null)
      ? Long.fromValue(object.lookbackWindowDays)
      : undefined;
    return message;
  },
};

function createBaseFlexibleRuleUserListInfo(): FlexibleRuleUserListInfo {
  return { inclusiveRuleOperator: 0, inclusiveOperands: [], exclusiveOperands: [] };
}

export const FlexibleRuleUserListInfo: MessageFns<FlexibleRuleUserListInfo> = {
  encode(message: FlexibleRuleUserListInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inclusiveRuleOperator !== 0) {
      writer.uint32(8).int32(message.inclusiveRuleOperator);
    }
    for (const v of message.inclusiveOperands) {
      FlexibleRuleOperandInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.exclusiveOperands) {
      FlexibleRuleOperandInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlexibleRuleUserListInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlexibleRuleUserListInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.inclusiveRuleOperator = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inclusiveOperands.push(FlexibleRuleOperandInfo.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.exclusiveOperands.push(FlexibleRuleOperandInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlexibleRuleUserListInfo {
    return {
      inclusiveRuleOperator: isSet(object.inclusiveRuleOperator)
        ? userListFlexibleRuleOperatorEnum_UserListFlexibleRuleOperatorFromJSON(object.inclusiveRuleOperator)
        : 0,
      inclusiveOperands: globalThis.Array.isArray(object?.inclusiveOperands)
        ? object.inclusiveOperands.map((e: any) => FlexibleRuleOperandInfo.fromJSON(e))
        : [],
      exclusiveOperands: globalThis.Array.isArray(object?.exclusiveOperands)
        ? object.exclusiveOperands.map((e: any) => FlexibleRuleOperandInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FlexibleRuleUserListInfo): unknown {
    const obj: any = {};
    if (message.inclusiveRuleOperator !== 0) {
      obj.inclusiveRuleOperator = userListFlexibleRuleOperatorEnum_UserListFlexibleRuleOperatorToJSON(
        message.inclusiveRuleOperator,
      );
    }
    if (message.inclusiveOperands?.length) {
      obj.inclusiveOperands = message.inclusiveOperands.map((e) => FlexibleRuleOperandInfo.toJSON(e));
    }
    if (message.exclusiveOperands?.length) {
      obj.exclusiveOperands = message.exclusiveOperands.map((e) => FlexibleRuleOperandInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FlexibleRuleUserListInfo>): FlexibleRuleUserListInfo {
    return FlexibleRuleUserListInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FlexibleRuleUserListInfo>): FlexibleRuleUserListInfo {
    const message = createBaseFlexibleRuleUserListInfo();
    message.inclusiveRuleOperator = object.inclusiveRuleOperator ?? 0;
    message.inclusiveOperands = object.inclusiveOperands?.map((e) => FlexibleRuleOperandInfo.fromPartial(e)) || [];
    message.exclusiveOperands = object.exclusiveOperands?.map((e) => FlexibleRuleOperandInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRuleBasedUserListInfo(): RuleBasedUserListInfo {
  return { prepopulationStatus: 0, flexibleRuleUserList: undefined };
}

export const RuleBasedUserListInfo: MessageFns<RuleBasedUserListInfo> = {
  encode(message: RuleBasedUserListInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prepopulationStatus !== 0) {
      writer.uint32(8).int32(message.prepopulationStatus);
    }
    if (message.flexibleRuleUserList !== undefined) {
      FlexibleRuleUserListInfo.encode(message.flexibleRuleUserList, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuleBasedUserListInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleBasedUserListInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.prepopulationStatus = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.flexibleRuleUserList = FlexibleRuleUserListInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleBasedUserListInfo {
    return {
      prepopulationStatus: isSet(object.prepopulationStatus)
        ? userListPrepopulationStatusEnum_UserListPrepopulationStatusFromJSON(object.prepopulationStatus)
        : 0,
      flexibleRuleUserList: isSet(object.flexibleRuleUserList)
        ? FlexibleRuleUserListInfo.fromJSON(object.flexibleRuleUserList)
        : undefined,
    };
  },

  toJSON(message: RuleBasedUserListInfo): unknown {
    const obj: any = {};
    if (message.prepopulationStatus !== 0) {
      obj.prepopulationStatus = userListPrepopulationStatusEnum_UserListPrepopulationStatusToJSON(
        message.prepopulationStatus,
      );
    }
    if (message.flexibleRuleUserList !== undefined) {
      obj.flexibleRuleUserList = FlexibleRuleUserListInfo.toJSON(message.flexibleRuleUserList);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleBasedUserListInfo>): RuleBasedUserListInfo {
    return RuleBasedUserListInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleBasedUserListInfo>): RuleBasedUserListInfo {
    const message = createBaseRuleBasedUserListInfo();
    message.prepopulationStatus = object.prepopulationStatus ?? 0;
    message.flexibleRuleUserList = (object.flexibleRuleUserList !== undefined && object.flexibleRuleUserList !== null)
      ? FlexibleRuleUserListInfo.fromPartial(object.flexibleRuleUserList)
      : undefined;
    return message;
  },
};

function createBaseLogicalUserListInfo(): LogicalUserListInfo {
  return { rules: [] };
}

export const LogicalUserListInfo: MessageFns<LogicalUserListInfo> = {
  encode(message: LogicalUserListInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rules) {
      UserListLogicalRuleInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogicalUserListInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogicalUserListInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rules.push(UserListLogicalRuleInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogicalUserListInfo {
    return {
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => UserListLogicalRuleInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LogicalUserListInfo): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => UserListLogicalRuleInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LogicalUserListInfo>): LogicalUserListInfo {
    return LogicalUserListInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogicalUserListInfo>): LogicalUserListInfo {
    const message = createBaseLogicalUserListInfo();
    message.rules = object.rules?.map((e) => UserListLogicalRuleInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserListLogicalRuleInfo(): UserListLogicalRuleInfo {
  return { operator: 0, ruleOperands: [] };
}

export const UserListLogicalRuleInfo: MessageFns<UserListLogicalRuleInfo> = {
  encode(message: UserListLogicalRuleInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== 0) {
      writer.uint32(8).int32(message.operator);
    }
    for (const v of message.ruleOperands) {
      LogicalUserListOperandInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserListLogicalRuleInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserListLogicalRuleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ruleOperands.push(LogicalUserListOperandInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserListLogicalRuleInfo {
    return {
      operator: isSet(object.operator)
        ? userListLogicalRuleOperatorEnum_UserListLogicalRuleOperatorFromJSON(object.operator)
        : 0,
      ruleOperands: globalThis.Array.isArray(object?.ruleOperands)
        ? object.ruleOperands.map((e: any) => LogicalUserListOperandInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserListLogicalRuleInfo): unknown {
    const obj: any = {};
    if (message.operator !== 0) {
      obj.operator = userListLogicalRuleOperatorEnum_UserListLogicalRuleOperatorToJSON(message.operator);
    }
    if (message.ruleOperands?.length) {
      obj.ruleOperands = message.ruleOperands.map((e) => LogicalUserListOperandInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UserListLogicalRuleInfo>): UserListLogicalRuleInfo {
    return UserListLogicalRuleInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserListLogicalRuleInfo>): UserListLogicalRuleInfo {
    const message = createBaseUserListLogicalRuleInfo();
    message.operator = object.operator ?? 0;
    message.ruleOperands = object.ruleOperands?.map((e) => LogicalUserListOperandInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLogicalUserListOperandInfo(): LogicalUserListOperandInfo {
  return { userList: undefined };
}

export const LogicalUserListOperandInfo: MessageFns<LogicalUserListOperandInfo> = {
  encode(message: LogicalUserListOperandInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userList !== undefined) {
      writer.uint32(18).string(message.userList);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogicalUserListOperandInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogicalUserListOperandInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userList = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogicalUserListOperandInfo {
    return { userList: isSet(object.userList) ? globalThis.String(object.userList) : undefined };
  },

  toJSON(message: LogicalUserListOperandInfo): unknown {
    const obj: any = {};
    if (message.userList !== undefined) {
      obj.userList = message.userList;
    }
    return obj;
  },

  create(base?: DeepPartial<LogicalUserListOperandInfo>): LogicalUserListOperandInfo {
    return LogicalUserListOperandInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogicalUserListOperandInfo>): LogicalUserListOperandInfo {
    const message = createBaseLogicalUserListOperandInfo();
    message.userList = object.userList ?? undefined;
    return message;
  },
};

function createBaseBasicUserListInfo(): BasicUserListInfo {
  return { actions: [] };
}

export const BasicUserListInfo: MessageFns<BasicUserListInfo> = {
  encode(message: BasicUserListInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actions) {
      UserListActionInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicUserListInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicUserListInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actions.push(UserListActionInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasicUserListInfo {
    return {
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => UserListActionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BasicUserListInfo): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => UserListActionInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BasicUserListInfo>): BasicUserListInfo {
    return BasicUserListInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BasicUserListInfo>): BasicUserListInfo {
    const message = createBaseBasicUserListInfo();
    message.actions = object.actions?.map((e) => UserListActionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserListActionInfo(): UserListActionInfo {
  return { conversionAction: undefined, remarketingAction: undefined };
}

export const UserListActionInfo: MessageFns<UserListActionInfo> = {
  encode(message: UserListActionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversionAction !== undefined) {
      writer.uint32(26).string(message.conversionAction);
    }
    if (message.remarketingAction !== undefined) {
      writer.uint32(34).string(message.remarketingAction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserListActionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserListActionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.conversionAction = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.remarketingAction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserListActionInfo {
    return {
      conversionAction: isSet(object.conversionAction) ? globalThis.String(object.conversionAction) : undefined,
      remarketingAction: isSet(object.remarketingAction) ? globalThis.String(object.remarketingAction) : undefined,
    };
  },

  toJSON(message: UserListActionInfo): unknown {
    const obj: any = {};
    if (message.conversionAction !== undefined) {
      obj.conversionAction = message.conversionAction;
    }
    if (message.remarketingAction !== undefined) {
      obj.remarketingAction = message.remarketingAction;
    }
    return obj;
  },

  create(base?: DeepPartial<UserListActionInfo>): UserListActionInfo {
    return UserListActionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserListActionInfo>): UserListActionInfo {
    const message = createBaseUserListActionInfo();
    message.conversionAction = object.conversionAction ?? undefined;
    message.remarketingAction = object.remarketingAction ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
