// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v16/common/keyword_plan_common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { DeviceEnum_Device, deviceEnum_DeviceFromJSON, deviceEnum_DeviceToJSON } from "../enums/device.js";
import {
  KeywordPlanAggregateMetricTypeEnum_KeywordPlanAggregateMetricType,
  keywordPlanAggregateMetricTypeEnum_KeywordPlanAggregateMetricTypeFromJSON,
  keywordPlanAggregateMetricTypeEnum_KeywordPlanAggregateMetricTypeToJSON,
} from "../enums/keyword_plan_aggregate_metric_type.js";
import {
  KeywordPlanCompetitionLevelEnum_KeywordPlanCompetitionLevel,
  keywordPlanCompetitionLevelEnum_KeywordPlanCompetitionLevelFromJSON,
  keywordPlanCompetitionLevelEnum_KeywordPlanCompetitionLevelToJSON,
} from "../enums/keyword_plan_competition_level.js";
import {
  KeywordPlanConceptGroupTypeEnum_KeywordPlanConceptGroupType,
  keywordPlanConceptGroupTypeEnum_KeywordPlanConceptGroupTypeFromJSON,
  keywordPlanConceptGroupTypeEnum_KeywordPlanConceptGroupTypeToJSON,
} from "../enums/keyword_plan_concept_group_type.js";
import {
  MonthOfYearEnum_MonthOfYear,
  monthOfYearEnum_MonthOfYearFromJSON,
  monthOfYearEnum_MonthOfYearToJSON,
} from "../enums/month_of_year.js";
import { YearMonthRange } from "./dates.js";

export const protobufPackage = "google.ads.googleads.v16.common";

/**
 * Historical metrics specific to the targeting options selected.
 * Targeting options include geographies, network, and so on.
 * Refer to https://support.google.com/google-ads/answer/3022575 for more
 * details.
 */
export interface KeywordPlanHistoricalMetrics {
  /**
   * Approximate number of monthly searches on this query, averaged
   * for the past 12 months.
   */
  avgMonthlySearches?:
    | Long
    | undefined;
  /** Approximate number of searches on this query for the past twelve months. */
  monthlySearchVolumes: MonthlySearchVolume[];
  /** The competition level for the query. */
  competition: KeywordPlanCompetitionLevelEnum_KeywordPlanCompetitionLevel;
  /**
   * The competition index for the query in the range [0, 100].
   * Shows how competitive ad placement is for a keyword.
   * The level of competition from 0-100 is determined by the number of ad slots
   * filled divided by the total number of ad slots available. If not enough
   * data is available, null is returned.
   */
  competitionIndex?:
    | Long
    | undefined;
  /** Top of page bid low range (20th percentile) in micros for the keyword. */
  lowTopOfPageBidMicros?:
    | Long
    | undefined;
  /** Top of page bid high range (80th percentile) in micros for the keyword. */
  highTopOfPageBidMicros?:
    | Long
    | undefined;
  /** Average Cost Per Click in micros for the keyword. */
  averageCpcMicros?: Long | undefined;
}

/** Historical metrics options. */
export interface HistoricalMetricsOptions {
  /**
   * The year month range for historical metrics. If not specified, metrics
   * for the past 12 months are returned.
   * Search metrics are available for the past 4 years. If the search volume is
   * not available for the entire year_month_range provided, the subset of the
   * year month range for which search volume is available are returned.
   */
  yearMonthRange?:
    | YearMonthRange
    | undefined;
  /**
   * Indicates whether to include average cost per click value.
   * Average CPC is provided only for legacy support.
   */
  includeAverageCpc: boolean;
}

/** Monthly search volume. */
export interface MonthlySearchVolume {
  /** The year of the search volume (for example, 2020). */
  year?:
    | Long
    | undefined;
  /** The month of the search volume. */
  month: MonthOfYearEnum_MonthOfYear;
  /**
   * Approximate number of searches for the month.
   * A null value indicates the search volume is unavailable for
   * that month.
   */
  monthlySearches?: Long | undefined;
}

/** The aggregate metrics specification of the request. */
export interface KeywordPlanAggregateMetrics {
  /** The list of aggregate metrics to fetch data. */
  aggregateMetricTypes: KeywordPlanAggregateMetricTypeEnum_KeywordPlanAggregateMetricType[];
}

/** The aggregated historical metrics for keyword plan keywords. */
export interface KeywordPlanAggregateMetricResults {
  /**
   * The aggregate searches for all the keywords segmented by device
   * for the specified time.
   * Supports the following device types: MOBILE, TABLET, DESKTOP.
   *
   * This is only set when KeywordPlanAggregateMetricTypeEnum.DEVICE is set
   * in the KeywordPlanAggregateMetrics field in the request.
   */
  deviceSearches: KeywordPlanDeviceSearches[];
}

/** The total searches for the device type during the specified time period. */
export interface KeywordPlanDeviceSearches {
  /** The device type. */
  device: DeviceEnum_Device;
  /** The total searches for the device. */
  searchCount?: Long | undefined;
}

/** The annotations for the keyword plan keywords. */
export interface KeywordAnnotations {
  /** The list of concepts for the keyword. */
  concepts: KeywordConcept[];
}

/** The concept for the keyword. */
export interface KeywordConcept {
  /** The concept name for the keyword in the concept_group. */
  name: string;
  /** The concept group of the concept details. */
  conceptGroup: ConceptGroup | undefined;
}

/** The concept group for the keyword concept. */
export interface ConceptGroup {
  /** The concept group name. */
  name: string;
  /** The concept group type. */
  type: KeywordPlanConceptGroupTypeEnum_KeywordPlanConceptGroupType;
}

function createBaseKeywordPlanHistoricalMetrics(): KeywordPlanHistoricalMetrics {
  return {
    avgMonthlySearches: undefined,
    monthlySearchVolumes: [],
    competition: 0,
    competitionIndex: undefined,
    lowTopOfPageBidMicros: undefined,
    highTopOfPageBidMicros: undefined,
    averageCpcMicros: undefined,
  };
}

export const KeywordPlanHistoricalMetrics: MessageFns<KeywordPlanHistoricalMetrics> = {
  encode(message: KeywordPlanHistoricalMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.avgMonthlySearches !== undefined) {
      writer.uint32(56).int64(message.avgMonthlySearches.toString());
    }
    for (const v of message.monthlySearchVolumes) {
      MonthlySearchVolume.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.competition !== 0) {
      writer.uint32(16).int32(message.competition);
    }
    if (message.competitionIndex !== undefined) {
      writer.uint32(64).int64(message.competitionIndex.toString());
    }
    if (message.lowTopOfPageBidMicros !== undefined) {
      writer.uint32(72).int64(message.lowTopOfPageBidMicros.toString());
    }
    if (message.highTopOfPageBidMicros !== undefined) {
      writer.uint32(80).int64(message.highTopOfPageBidMicros.toString());
    }
    if (message.averageCpcMicros !== undefined) {
      writer.uint32(88).int64(message.averageCpcMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeywordPlanHistoricalMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeywordPlanHistoricalMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 56) {
            break;
          }

          message.avgMonthlySearches = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.monthlySearchVolumes.push(MonthlySearchVolume.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.competition = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.competitionIndex = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.lowTopOfPageBidMicros = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.highTopOfPageBidMicros = Long.fromString(reader.int64().toString());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.averageCpcMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeywordPlanHistoricalMetrics {
    return {
      avgMonthlySearches: isSet(object.avgMonthlySearches) ? Long.fromValue(object.avgMonthlySearches) : undefined,
      monthlySearchVolumes: globalThis.Array.isArray(object?.monthlySearchVolumes)
        ? object.monthlySearchVolumes.map((e: any) => MonthlySearchVolume.fromJSON(e))
        : [],
      competition: isSet(object.competition)
        ? keywordPlanCompetitionLevelEnum_KeywordPlanCompetitionLevelFromJSON(object.competition)
        : 0,
      competitionIndex: isSet(object.competitionIndex) ? Long.fromValue(object.competitionIndex) : undefined,
      lowTopOfPageBidMicros: isSet(object.lowTopOfPageBidMicros)
        ? Long.fromValue(object.lowTopOfPageBidMicros)
        : undefined,
      highTopOfPageBidMicros: isSet(object.highTopOfPageBidMicros)
        ? Long.fromValue(object.highTopOfPageBidMicros)
        : undefined,
      averageCpcMicros: isSet(object.averageCpcMicros) ? Long.fromValue(object.averageCpcMicros) : undefined,
    };
  },

  toJSON(message: KeywordPlanHistoricalMetrics): unknown {
    const obj: any = {};
    if (message.avgMonthlySearches !== undefined) {
      obj.avgMonthlySearches = (message.avgMonthlySearches || Long.ZERO).toString();
    }
    if (message.monthlySearchVolumes?.length) {
      obj.monthlySearchVolumes = message.monthlySearchVolumes.map((e) => MonthlySearchVolume.toJSON(e));
    }
    if (message.competition !== 0) {
      obj.competition = keywordPlanCompetitionLevelEnum_KeywordPlanCompetitionLevelToJSON(message.competition);
    }
    if (message.competitionIndex !== undefined) {
      obj.competitionIndex = (message.competitionIndex || Long.ZERO).toString();
    }
    if (message.lowTopOfPageBidMicros !== undefined) {
      obj.lowTopOfPageBidMicros = (message.lowTopOfPageBidMicros || Long.ZERO).toString();
    }
    if (message.highTopOfPageBidMicros !== undefined) {
      obj.highTopOfPageBidMicros = (message.highTopOfPageBidMicros || Long.ZERO).toString();
    }
    if (message.averageCpcMicros !== undefined) {
      obj.averageCpcMicros = (message.averageCpcMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<KeywordPlanHistoricalMetrics>): KeywordPlanHistoricalMetrics {
    return KeywordPlanHistoricalMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeywordPlanHistoricalMetrics>): KeywordPlanHistoricalMetrics {
    const message = createBaseKeywordPlanHistoricalMetrics();
    message.avgMonthlySearches = (object.avgMonthlySearches !== undefined && object.avgMonthlySearches !== null)
      ? Long.fromValue(object.avgMonthlySearches)
      : undefined;
    message.monthlySearchVolumes = object.monthlySearchVolumes?.map((e) => MonthlySearchVolume.fromPartial(e)) || [];
    message.competition = object.competition ?? 0;
    message.competitionIndex = (object.competitionIndex !== undefined && object.competitionIndex !== null)
      ? Long.fromValue(object.competitionIndex)
      : undefined;
    message.lowTopOfPageBidMicros =
      (object.lowTopOfPageBidMicros !== undefined && object.lowTopOfPageBidMicros !== null)
        ? Long.fromValue(object.lowTopOfPageBidMicros)
        : undefined;
    message.highTopOfPageBidMicros =
      (object.highTopOfPageBidMicros !== undefined && object.highTopOfPageBidMicros !== null)
        ? Long.fromValue(object.highTopOfPageBidMicros)
        : undefined;
    message.averageCpcMicros = (object.averageCpcMicros !== undefined && object.averageCpcMicros !== null)
      ? Long.fromValue(object.averageCpcMicros)
      : undefined;
    return message;
  },
};

function createBaseHistoricalMetricsOptions(): HistoricalMetricsOptions {
  return { yearMonthRange: undefined, includeAverageCpc: false };
}

export const HistoricalMetricsOptions: MessageFns<HistoricalMetricsOptions> = {
  encode(message: HistoricalMetricsOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.yearMonthRange !== undefined) {
      YearMonthRange.encode(message.yearMonthRange, writer.uint32(10).fork()).join();
    }
    if (message.includeAverageCpc !== false) {
      writer.uint32(16).bool(message.includeAverageCpc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HistoricalMetricsOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistoricalMetricsOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.yearMonthRange = YearMonthRange.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeAverageCpc = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HistoricalMetricsOptions {
    return {
      yearMonthRange: isSet(object.yearMonthRange) ? YearMonthRange.fromJSON(object.yearMonthRange) : undefined,
      includeAverageCpc: isSet(object.includeAverageCpc) ? globalThis.Boolean(object.includeAverageCpc) : false,
    };
  },

  toJSON(message: HistoricalMetricsOptions): unknown {
    const obj: any = {};
    if (message.yearMonthRange !== undefined) {
      obj.yearMonthRange = YearMonthRange.toJSON(message.yearMonthRange);
    }
    if (message.includeAverageCpc !== false) {
      obj.includeAverageCpc = message.includeAverageCpc;
    }
    return obj;
  },

  create(base?: DeepPartial<HistoricalMetricsOptions>): HistoricalMetricsOptions {
    return HistoricalMetricsOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HistoricalMetricsOptions>): HistoricalMetricsOptions {
    const message = createBaseHistoricalMetricsOptions();
    message.yearMonthRange = (object.yearMonthRange !== undefined && object.yearMonthRange !== null)
      ? YearMonthRange.fromPartial(object.yearMonthRange)
      : undefined;
    message.includeAverageCpc = object.includeAverageCpc ?? false;
    return message;
  },
};

function createBaseMonthlySearchVolume(): MonthlySearchVolume {
  return { year: undefined, month: 0, monthlySearches: undefined };
}

export const MonthlySearchVolume: MessageFns<MonthlySearchVolume> = {
  encode(message: MonthlySearchVolume, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.year !== undefined) {
      writer.uint32(32).int64(message.year.toString());
    }
    if (message.month !== 0) {
      writer.uint32(16).int32(message.month);
    }
    if (message.monthlySearches !== undefined) {
      writer.uint32(40).int64(message.monthlySearches.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonthlySearchVolume {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonthlySearchVolume();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 32) {
            break;
          }

          message.year = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.month = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.monthlySearches = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonthlySearchVolume {
    return {
      year: isSet(object.year) ? Long.fromValue(object.year) : undefined,
      month: isSet(object.month) ? monthOfYearEnum_MonthOfYearFromJSON(object.month) : 0,
      monthlySearches: isSet(object.monthlySearches) ? Long.fromValue(object.monthlySearches) : undefined,
    };
  },

  toJSON(message: MonthlySearchVolume): unknown {
    const obj: any = {};
    if (message.year !== undefined) {
      obj.year = (message.year || Long.ZERO).toString();
    }
    if (message.month !== 0) {
      obj.month = monthOfYearEnum_MonthOfYearToJSON(message.month);
    }
    if (message.monthlySearches !== undefined) {
      obj.monthlySearches = (message.monthlySearches || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MonthlySearchVolume>): MonthlySearchVolume {
    return MonthlySearchVolume.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonthlySearchVolume>): MonthlySearchVolume {
    const message = createBaseMonthlySearchVolume();
    message.year = (object.year !== undefined && object.year !== null) ? Long.fromValue(object.year) : undefined;
    message.month = object.month ?? 0;
    message.monthlySearches = (object.monthlySearches !== undefined && object.monthlySearches !== null)
      ? Long.fromValue(object.monthlySearches)
      : undefined;
    return message;
  },
};

function createBaseKeywordPlanAggregateMetrics(): KeywordPlanAggregateMetrics {
  return { aggregateMetricTypes: [] };
}

export const KeywordPlanAggregateMetrics: MessageFns<KeywordPlanAggregateMetrics> = {
  encode(message: KeywordPlanAggregateMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.aggregateMetricTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeywordPlanAggregateMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeywordPlanAggregateMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.aggregateMetricTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.aggregateMetricTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeywordPlanAggregateMetrics {
    return {
      aggregateMetricTypes: globalThis.Array.isArray(object?.aggregateMetricTypes)
        ? object.aggregateMetricTypes.map((e: any) =>
          keywordPlanAggregateMetricTypeEnum_KeywordPlanAggregateMetricTypeFromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: KeywordPlanAggregateMetrics): unknown {
    const obj: any = {};
    if (message.aggregateMetricTypes?.length) {
      obj.aggregateMetricTypes = message.aggregateMetricTypes.map((e) =>
        keywordPlanAggregateMetricTypeEnum_KeywordPlanAggregateMetricTypeToJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<KeywordPlanAggregateMetrics>): KeywordPlanAggregateMetrics {
    return KeywordPlanAggregateMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeywordPlanAggregateMetrics>): KeywordPlanAggregateMetrics {
    const message = createBaseKeywordPlanAggregateMetrics();
    message.aggregateMetricTypes = object.aggregateMetricTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseKeywordPlanAggregateMetricResults(): KeywordPlanAggregateMetricResults {
  return { deviceSearches: [] };
}

export const KeywordPlanAggregateMetricResults: MessageFns<KeywordPlanAggregateMetricResults> = {
  encode(message: KeywordPlanAggregateMetricResults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.deviceSearches) {
      KeywordPlanDeviceSearches.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeywordPlanAggregateMetricResults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeywordPlanAggregateMetricResults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deviceSearches.push(KeywordPlanDeviceSearches.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeywordPlanAggregateMetricResults {
    return {
      deviceSearches: globalThis.Array.isArray(object?.deviceSearches)
        ? object.deviceSearches.map((e: any) => KeywordPlanDeviceSearches.fromJSON(e))
        : [],
    };
  },

  toJSON(message: KeywordPlanAggregateMetricResults): unknown {
    const obj: any = {};
    if (message.deviceSearches?.length) {
      obj.deviceSearches = message.deviceSearches.map((e) => KeywordPlanDeviceSearches.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<KeywordPlanAggregateMetricResults>): KeywordPlanAggregateMetricResults {
    return KeywordPlanAggregateMetricResults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeywordPlanAggregateMetricResults>): KeywordPlanAggregateMetricResults {
    const message = createBaseKeywordPlanAggregateMetricResults();
    message.deviceSearches = object.deviceSearches?.map((e) => KeywordPlanDeviceSearches.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKeywordPlanDeviceSearches(): KeywordPlanDeviceSearches {
  return { device: 0, searchCount: undefined };
}

export const KeywordPlanDeviceSearches: MessageFns<KeywordPlanDeviceSearches> = {
  encode(message: KeywordPlanDeviceSearches, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.device !== 0) {
      writer.uint32(8).int32(message.device);
    }
    if (message.searchCount !== undefined) {
      writer.uint32(16).int64(message.searchCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeywordPlanDeviceSearches {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeywordPlanDeviceSearches();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.device = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.searchCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeywordPlanDeviceSearches {
    return {
      device: isSet(object.device) ? deviceEnum_DeviceFromJSON(object.device) : 0,
      searchCount: isSet(object.searchCount) ? Long.fromValue(object.searchCount) : undefined,
    };
  },

  toJSON(message: KeywordPlanDeviceSearches): unknown {
    const obj: any = {};
    if (message.device !== 0) {
      obj.device = deviceEnum_DeviceToJSON(message.device);
    }
    if (message.searchCount !== undefined) {
      obj.searchCount = (message.searchCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<KeywordPlanDeviceSearches>): KeywordPlanDeviceSearches {
    return KeywordPlanDeviceSearches.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeywordPlanDeviceSearches>): KeywordPlanDeviceSearches {
    const message = createBaseKeywordPlanDeviceSearches();
    message.device = object.device ?? 0;
    message.searchCount = (object.searchCount !== undefined && object.searchCount !== null)
      ? Long.fromValue(object.searchCount)
      : undefined;
    return message;
  },
};

function createBaseKeywordAnnotations(): KeywordAnnotations {
  return { concepts: [] };
}

export const KeywordAnnotations: MessageFns<KeywordAnnotations> = {
  encode(message: KeywordAnnotations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.concepts) {
      KeywordConcept.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeywordAnnotations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeywordAnnotations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.concepts.push(KeywordConcept.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeywordAnnotations {
    return {
      concepts: globalThis.Array.isArray(object?.concepts)
        ? object.concepts.map((e: any) => KeywordConcept.fromJSON(e))
        : [],
    };
  },

  toJSON(message: KeywordAnnotations): unknown {
    const obj: any = {};
    if (message.concepts?.length) {
      obj.concepts = message.concepts.map((e) => KeywordConcept.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<KeywordAnnotations>): KeywordAnnotations {
    return KeywordAnnotations.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeywordAnnotations>): KeywordAnnotations {
    const message = createBaseKeywordAnnotations();
    message.concepts = object.concepts?.map((e) => KeywordConcept.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKeywordConcept(): KeywordConcept {
  return { name: "", conceptGroup: undefined };
}

export const KeywordConcept: MessageFns<KeywordConcept> = {
  encode(message: KeywordConcept, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.conceptGroup !== undefined) {
      ConceptGroup.encode(message.conceptGroup, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeywordConcept {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeywordConcept();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conceptGroup = ConceptGroup.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeywordConcept {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      conceptGroup: isSet(object.conceptGroup) ? ConceptGroup.fromJSON(object.conceptGroup) : undefined,
    };
  },

  toJSON(message: KeywordConcept): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.conceptGroup !== undefined) {
      obj.conceptGroup = ConceptGroup.toJSON(message.conceptGroup);
    }
    return obj;
  },

  create(base?: DeepPartial<KeywordConcept>): KeywordConcept {
    return KeywordConcept.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeywordConcept>): KeywordConcept {
    const message = createBaseKeywordConcept();
    message.name = object.name ?? "";
    message.conceptGroup = (object.conceptGroup !== undefined && object.conceptGroup !== null)
      ? ConceptGroup.fromPartial(object.conceptGroup)
      : undefined;
    return message;
  },
};

function createBaseConceptGroup(): ConceptGroup {
  return { name: "", type: 0 };
}

export const ConceptGroup: MessageFns<ConceptGroup> = {
  encode(message: ConceptGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConceptGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConceptGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConceptGroup {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? keywordPlanConceptGroupTypeEnum_KeywordPlanConceptGroupTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: ConceptGroup): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = keywordPlanConceptGroupTypeEnum_KeywordPlanConceptGroupTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<ConceptGroup>): ConceptGroup {
    return ConceptGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConceptGroup>): ConceptGroup {
    const message = createBaseConceptGroup();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
