// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v16/resources/account_budget.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  AccountBudgetProposalTypeEnum_AccountBudgetProposalType,
  accountBudgetProposalTypeEnum_AccountBudgetProposalTypeFromJSON,
  accountBudgetProposalTypeEnum_AccountBudgetProposalTypeToJSON,
} from "../enums/account_budget_proposal_type.js";
import {
  AccountBudgetStatusEnum_AccountBudgetStatus,
  accountBudgetStatusEnum_AccountBudgetStatusFromJSON,
  accountBudgetStatusEnum_AccountBudgetStatusToJSON,
} from "../enums/account_budget_status.js";
import {
  SpendingLimitTypeEnum_SpendingLimitType,
  spendingLimitTypeEnum_SpendingLimitTypeFromJSON,
  spendingLimitTypeEnum_SpendingLimitTypeToJSON,
} from "../enums/spending_limit_type.js";
import {
  TimeTypeEnum_TimeType,
  timeTypeEnum_TimeTypeFromJSON,
  timeTypeEnum_TimeTypeToJSON,
} from "../enums/time_type.js";

export const protobufPackage = "google.ads.googleads.v16.resources";

/**
 * An account-level budget. It contains information about the budget itself,
 * as well as the most recently approved changes to the budget and proposed
 * changes that are pending approval. The proposed changes that are pending
 * approval, if any, are found in 'pending_proposal'.  Effective details about
 * the budget are found in fields prefixed 'approved_', 'adjusted_' and those
 * without a prefix.  Since some effective details may differ from what the user
 * had originally requested (for example, spending limit), these differences are
 * juxtaposed through 'proposed_', 'approved_', and possibly 'adjusted_' fields.
 *
 * This resource is mutated using AccountBudgetProposal and cannot be mutated
 * directly. A budget may have at most one pending proposal at any given time.
 * It is read through pending_proposal.
 *
 * Once approved, a budget may be subject to adjustments, such as credit
 * adjustments.  Adjustments create differences between the 'approved' and
 * 'adjusted' fields, which would otherwise be identical.
 */
export interface AccountBudget {
  /**
   * Output only. The resource name of the account-level budget.
   * AccountBudget resource names have the form:
   *
   * `customers/{customer_id}/accountBudgets/{account_budget_id}`
   */
  resourceName: string;
  /** Output only. The ID of the account-level budget. */
  id?:
    | Long
    | undefined;
  /**
   * Output only. The resource name of the billing setup associated with this
   * account-level budget.  BillingSetup resource names have the form:
   *
   * `customers/{customer_id}/billingSetups/{billing_setup_id}`
   */
  billingSetup?:
    | string
    | undefined;
  /** Output only. The status of this account-level budget. */
  status: AccountBudgetStatusEnum_AccountBudgetStatus;
  /** Output only. The name of the account-level budget. */
  name?:
    | string
    | undefined;
  /**
   * Output only. The proposed start time of the account-level budget in
   * yyyy-MM-dd HH:mm:ss format.  If a start time type of NOW was proposed,
   * this is the time of request.
   */
  proposedStartDateTime?:
    | string
    | undefined;
  /**
   * Output only. The approved start time of the account-level budget in
   * yyyy-MM-dd HH:mm:ss format.
   *
   * For example, if a new budget is approved after the proposed start time,
   * the approved start time is the time of approval.
   */
  approvedStartDateTime?:
    | string
    | undefined;
  /**
   * Output only. The total adjustments amount.
   *
   * An example of an adjustment is courtesy credits.
   */
  totalAdjustmentsMicros: Long;
  /**
   * Output only. The value of Ads that have been served, in micros.
   *
   * This includes overdelivery costs, in which case a credit might be
   * automatically applied to the budget (see total_adjustments_micros).
   */
  amountServedMicros: Long;
  /**
   * Output only. A purchase order number is a value that helps users reference
   * this budget in their monthly invoices.
   */
  purchaseOrderNumber?:
    | string
    | undefined;
  /** Output only. Notes associated with the budget. */
  notes?:
    | string
    | undefined;
  /** Output only. The pending proposal to modify this budget, if applicable. */
  pendingProposal:
    | AccountBudget_PendingAccountBudgetProposal
    | undefined;
  /** Output only. The proposed end time in yyyy-MM-dd HH:mm:ss format. */
  proposedEndDateTime?:
    | string
    | undefined;
  /**
   * Output only. The proposed end time as a well-defined type, for example,
   * FOREVER.
   */
  proposedEndTimeType?:
    | TimeTypeEnum_TimeType
    | undefined;
  /** Output only. The approved end time in yyyy-MM-dd HH:mm:ss format. */
  approvedEndDateTime?:
    | string
    | undefined;
  /**
   * Output only. The approved end time as a well-defined type, for example,
   * FOREVER.
   */
  approvedEndTimeType?:
    | TimeTypeEnum_TimeType
    | undefined;
  /**
   * Output only. The proposed spending limit in micros.  One million is
   * equivalent to one unit.
   */
  proposedSpendingLimitMicros?:
    | Long
    | undefined;
  /**
   * Output only. The proposed spending limit as a well-defined type, for
   * example, INFINITE.
   */
  proposedSpendingLimitType?:
    | SpendingLimitTypeEnum_SpendingLimitType
    | undefined;
  /**
   * Output only. The approved spending limit in micros.  One million is
   * equivalent to one unit.  This will only be populated if the proposed
   * spending limit is finite, and will always be greater than or equal to the
   * proposed spending limit.
   */
  approvedSpendingLimitMicros?:
    | Long
    | undefined;
  /**
   * Output only. The approved spending limit as a well-defined type, for
   * example, INFINITE.  This will only be populated if the approved spending
   * limit is INFINITE.
   */
  approvedSpendingLimitType?:
    | SpendingLimitTypeEnum_SpendingLimitType
    | undefined;
  /**
   * Output only. The adjusted spending limit in micros.  One million is
   * equivalent to one unit.
   *
   * If the approved spending limit is finite, the adjusted
   * spending limit may vary depending on the types of adjustments applied
   * to this budget, if applicable.
   *
   * The different kinds of adjustments are described here:
   * https://support.google.com/google-ads/answer/1704323
   *
   * For example, a debit adjustment reduces how much the account is
   * allowed to spend.
   */
  adjustedSpendingLimitMicros?:
    | Long
    | undefined;
  /**
   * Output only. The adjusted spending limit as a well-defined type, for
   * example, INFINITE. This will only be populated if the adjusted spending
   * limit is INFINITE, which is guaranteed to be true if the approved
   * spending limit is INFINITE.
   */
  adjustedSpendingLimitType?: SpendingLimitTypeEnum_SpendingLimitType | undefined;
}

/**
 * A pending proposal associated with the enclosing account-level budget,
 * if applicable.
 */
export interface AccountBudget_PendingAccountBudgetProposal {
  /**
   * Output only. The resource name of the proposal.
   * AccountBudgetProposal resource names have the form:
   *
   * `customers/{customer_id}/accountBudgetProposals/{account_budget_proposal_id}`
   */
  accountBudgetProposal?:
    | string
    | undefined;
  /**
   * Output only. The type of this proposal, for example, END to end the
   * budget associated with this proposal.
   */
  proposalType: AccountBudgetProposalTypeEnum_AccountBudgetProposalType;
  /** Output only. The name to assign to the account-level budget. */
  name?:
    | string
    | undefined;
  /** Output only. The start time in yyyy-MM-dd HH:mm:ss format. */
  startDateTime?:
    | string
    | undefined;
  /**
   * Output only. A purchase order number is a value that helps users
   * reference this budget in their monthly invoices.
   */
  purchaseOrderNumber?:
    | string
    | undefined;
  /** Output only. Notes associated with this budget. */
  notes?:
    | string
    | undefined;
  /**
   * Output only. The time when this account-level budget proposal was
   * created. Formatted as yyyy-MM-dd HH:mm:ss.
   */
  creationDateTime?:
    | string
    | undefined;
  /** Output only. The end time in yyyy-MM-dd HH:mm:ss format. */
  endDateTime?:
    | string
    | undefined;
  /** Output only. The end time as a well-defined type, for example, FOREVER. */
  endTimeType?:
    | TimeTypeEnum_TimeType
    | undefined;
  /**
   * Output only. The spending limit in micros.  One million is equivalent
   * to one unit.
   */
  spendingLimitMicros?:
    | Long
    | undefined;
  /**
   * Output only. The spending limit as a well-defined type, for example,
   * INFINITE.
   */
  spendingLimitType?: SpendingLimitTypeEnum_SpendingLimitType | undefined;
}

function createBaseAccountBudget(): AccountBudget {
  return {
    resourceName: "",
    id: undefined,
    billingSetup: undefined,
    status: 0,
    name: undefined,
    proposedStartDateTime: undefined,
    approvedStartDateTime: undefined,
    totalAdjustmentsMicros: Long.ZERO,
    amountServedMicros: Long.ZERO,
    purchaseOrderNumber: undefined,
    notes: undefined,
    pendingProposal: undefined,
    proposedEndDateTime: undefined,
    proposedEndTimeType: undefined,
    approvedEndDateTime: undefined,
    approvedEndTimeType: undefined,
    proposedSpendingLimitMicros: undefined,
    proposedSpendingLimitType: undefined,
    approvedSpendingLimitMicros: undefined,
    approvedSpendingLimitType: undefined,
    adjustedSpendingLimitMicros: undefined,
    adjustedSpendingLimitType: undefined,
  };
}

export const AccountBudget: MessageFns<AccountBudget> = {
  encode(message: AccountBudget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    if (message.id !== undefined) {
      writer.uint32(184).int64(message.id.toString());
    }
    if (message.billingSetup !== undefined) {
      writer.uint32(194).string(message.billingSetup);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.name !== undefined) {
      writer.uint32(202).string(message.name);
    }
    if (message.proposedStartDateTime !== undefined) {
      writer.uint32(210).string(message.proposedStartDateTime);
    }
    if (message.approvedStartDateTime !== undefined) {
      writer.uint32(218).string(message.approvedStartDateTime);
    }
    if (!message.totalAdjustmentsMicros.equals(Long.ZERO)) {
      writer.uint32(264).int64(message.totalAdjustmentsMicros.toString());
    }
    if (!message.amountServedMicros.equals(Long.ZERO)) {
      writer.uint32(272).int64(message.amountServedMicros.toString());
    }
    if (message.purchaseOrderNumber !== undefined) {
      writer.uint32(282).string(message.purchaseOrderNumber);
    }
    if (message.notes !== undefined) {
      writer.uint32(290).string(message.notes);
    }
    if (message.pendingProposal !== undefined) {
      AccountBudget_PendingAccountBudgetProposal.encode(message.pendingProposal, writer.uint32(178).fork()).join();
    }
    if (message.proposedEndDateTime !== undefined) {
      writer.uint32(226).string(message.proposedEndDateTime);
    }
    if (message.proposedEndTimeType !== undefined) {
      writer.uint32(72).int32(message.proposedEndTimeType);
    }
    if (message.approvedEndDateTime !== undefined) {
      writer.uint32(234).string(message.approvedEndDateTime);
    }
    if (message.approvedEndTimeType !== undefined) {
      writer.uint32(88).int32(message.approvedEndTimeType);
    }
    if (message.proposedSpendingLimitMicros !== undefined) {
      writer.uint32(240).int64(message.proposedSpendingLimitMicros.toString());
    }
    if (message.proposedSpendingLimitType !== undefined) {
      writer.uint32(104).int32(message.proposedSpendingLimitType);
    }
    if (message.approvedSpendingLimitMicros !== undefined) {
      writer.uint32(248).int64(message.approvedSpendingLimitMicros.toString());
    }
    if (message.approvedSpendingLimitType !== undefined) {
      writer.uint32(120).int32(message.approvedSpendingLimitType);
    }
    if (message.adjustedSpendingLimitMicros !== undefined) {
      writer.uint32(256).int64(message.adjustedSpendingLimitMicros.toString());
    }
    if (message.adjustedSpendingLimitType !== undefined) {
      writer.uint32(136).int32(message.adjustedSpendingLimitType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountBudget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountBudget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.billingSetup = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.name = reader.string();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.proposedStartDateTime = reader.string();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.approvedStartDateTime = reader.string();
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.totalAdjustmentsMicros = Long.fromString(reader.int64().toString());
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }

          message.amountServedMicros = Long.fromString(reader.int64().toString());
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.purchaseOrderNumber = reader.string();
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.pendingProposal = AccountBudget_PendingAccountBudgetProposal.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.proposedEndDateTime = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.proposedEndTimeType = reader.int32() as any;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.approvedEndDateTime = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.approvedEndTimeType = reader.int32() as any;
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.proposedSpendingLimitMicros = Long.fromString(reader.int64().toString());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.proposedSpendingLimitType = reader.int32() as any;
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.approvedSpendingLimitMicros = Long.fromString(reader.int64().toString());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.approvedSpendingLimitType = reader.int32() as any;
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.adjustedSpendingLimitMicros = Long.fromString(reader.int64().toString());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.adjustedSpendingLimitType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountBudget {
    return {
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      id: isSet(object.id) ? Long.fromValue(object.id) : undefined,
      billingSetup: isSet(object.billingSetup) ? globalThis.String(object.billingSetup) : undefined,
      status: isSet(object.status) ? accountBudgetStatusEnum_AccountBudgetStatusFromJSON(object.status) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      proposedStartDateTime: isSet(object.proposedStartDateTime)
        ? globalThis.String(object.proposedStartDateTime)
        : undefined,
      approvedStartDateTime: isSet(object.approvedStartDateTime)
        ? globalThis.String(object.approvedStartDateTime)
        : undefined,
      totalAdjustmentsMicros: isSet(object.totalAdjustmentsMicros)
        ? Long.fromValue(object.totalAdjustmentsMicros)
        : Long.ZERO,
      amountServedMicros: isSet(object.amountServedMicros) ? Long.fromValue(object.amountServedMicros) : Long.ZERO,
      purchaseOrderNumber: isSet(object.purchaseOrderNumber)
        ? globalThis.String(object.purchaseOrderNumber)
        : undefined,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : undefined,
      pendingProposal: isSet(object.pendingProposal)
        ? AccountBudget_PendingAccountBudgetProposal.fromJSON(object.pendingProposal)
        : undefined,
      proposedEndDateTime: isSet(object.proposedEndDateTime)
        ? globalThis.String(object.proposedEndDateTime)
        : undefined,
      proposedEndTimeType: isSet(object.proposedEndTimeType)
        ? timeTypeEnum_TimeTypeFromJSON(object.proposedEndTimeType)
        : undefined,
      approvedEndDateTime: isSet(object.approvedEndDateTime)
        ? globalThis.String(object.approvedEndDateTime)
        : undefined,
      approvedEndTimeType: isSet(object.approvedEndTimeType)
        ? timeTypeEnum_TimeTypeFromJSON(object.approvedEndTimeType)
        : undefined,
      proposedSpendingLimitMicros: isSet(object.proposedSpendingLimitMicros)
        ? Long.fromValue(object.proposedSpendingLimitMicros)
        : undefined,
      proposedSpendingLimitType: isSet(object.proposedSpendingLimitType)
        ? spendingLimitTypeEnum_SpendingLimitTypeFromJSON(object.proposedSpendingLimitType)
        : undefined,
      approvedSpendingLimitMicros: isSet(object.approvedSpendingLimitMicros)
        ? Long.fromValue(object.approvedSpendingLimitMicros)
        : undefined,
      approvedSpendingLimitType: isSet(object.approvedSpendingLimitType)
        ? spendingLimitTypeEnum_SpendingLimitTypeFromJSON(object.approvedSpendingLimitType)
        : undefined,
      adjustedSpendingLimitMicros: isSet(object.adjustedSpendingLimitMicros)
        ? Long.fromValue(object.adjustedSpendingLimitMicros)
        : undefined,
      adjustedSpendingLimitType: isSet(object.adjustedSpendingLimitType)
        ? spendingLimitTypeEnum_SpendingLimitTypeFromJSON(object.adjustedSpendingLimitType)
        : undefined,
    };
  },

  toJSON(message: AccountBudget): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.id !== undefined) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (message.billingSetup !== undefined) {
      obj.billingSetup = message.billingSetup;
    }
    if (message.status !== 0) {
      obj.status = accountBudgetStatusEnum_AccountBudgetStatusToJSON(message.status);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.proposedStartDateTime !== undefined) {
      obj.proposedStartDateTime = message.proposedStartDateTime;
    }
    if (message.approvedStartDateTime !== undefined) {
      obj.approvedStartDateTime = message.approvedStartDateTime;
    }
    if (!message.totalAdjustmentsMicros.equals(Long.ZERO)) {
      obj.totalAdjustmentsMicros = (message.totalAdjustmentsMicros || Long.ZERO).toString();
    }
    if (!message.amountServedMicros.equals(Long.ZERO)) {
      obj.amountServedMicros = (message.amountServedMicros || Long.ZERO).toString();
    }
    if (message.purchaseOrderNumber !== undefined) {
      obj.purchaseOrderNumber = message.purchaseOrderNumber;
    }
    if (message.notes !== undefined) {
      obj.notes = message.notes;
    }
    if (message.pendingProposal !== undefined) {
      obj.pendingProposal = AccountBudget_PendingAccountBudgetProposal.toJSON(message.pendingProposal);
    }
    if (message.proposedEndDateTime !== undefined) {
      obj.proposedEndDateTime = message.proposedEndDateTime;
    }
    if (message.proposedEndTimeType !== undefined) {
      obj.proposedEndTimeType = timeTypeEnum_TimeTypeToJSON(message.proposedEndTimeType);
    }
    if (message.approvedEndDateTime !== undefined) {
      obj.approvedEndDateTime = message.approvedEndDateTime;
    }
    if (message.approvedEndTimeType !== undefined) {
      obj.approvedEndTimeType = timeTypeEnum_TimeTypeToJSON(message.approvedEndTimeType);
    }
    if (message.proposedSpendingLimitMicros !== undefined) {
      obj.proposedSpendingLimitMicros = (message.proposedSpendingLimitMicros || Long.ZERO).toString();
    }
    if (message.proposedSpendingLimitType !== undefined) {
      obj.proposedSpendingLimitType = spendingLimitTypeEnum_SpendingLimitTypeToJSON(message.proposedSpendingLimitType);
    }
    if (message.approvedSpendingLimitMicros !== undefined) {
      obj.approvedSpendingLimitMicros = (message.approvedSpendingLimitMicros || Long.ZERO).toString();
    }
    if (message.approvedSpendingLimitType !== undefined) {
      obj.approvedSpendingLimitType = spendingLimitTypeEnum_SpendingLimitTypeToJSON(message.approvedSpendingLimitType);
    }
    if (message.adjustedSpendingLimitMicros !== undefined) {
      obj.adjustedSpendingLimitMicros = (message.adjustedSpendingLimitMicros || Long.ZERO).toString();
    }
    if (message.adjustedSpendingLimitType !== undefined) {
      obj.adjustedSpendingLimitType = spendingLimitTypeEnum_SpendingLimitTypeToJSON(message.adjustedSpendingLimitType);
    }
    return obj;
  },

  create(base?: DeepPartial<AccountBudget>): AccountBudget {
    return AccountBudget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountBudget>): AccountBudget {
    const message = createBaseAccountBudget();
    message.resourceName = object.resourceName ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : undefined;
    message.billingSetup = object.billingSetup ?? undefined;
    message.status = object.status ?? 0;
    message.name = object.name ?? undefined;
    message.proposedStartDateTime = object.proposedStartDateTime ?? undefined;
    message.approvedStartDateTime = object.approvedStartDateTime ?? undefined;
    message.totalAdjustmentsMicros =
      (object.totalAdjustmentsMicros !== undefined && object.totalAdjustmentsMicros !== null)
        ? Long.fromValue(object.totalAdjustmentsMicros)
        : Long.ZERO;
    message.amountServedMicros = (object.amountServedMicros !== undefined && object.amountServedMicros !== null)
      ? Long.fromValue(object.amountServedMicros)
      : Long.ZERO;
    message.purchaseOrderNumber = object.purchaseOrderNumber ?? undefined;
    message.notes = object.notes ?? undefined;
    message.pendingProposal = (object.pendingProposal !== undefined && object.pendingProposal !== null)
      ? AccountBudget_PendingAccountBudgetProposal.fromPartial(object.pendingProposal)
      : undefined;
    message.proposedEndDateTime = object.proposedEndDateTime ?? undefined;
    message.proposedEndTimeType = object.proposedEndTimeType ?? undefined;
    message.approvedEndDateTime = object.approvedEndDateTime ?? undefined;
    message.approvedEndTimeType = object.approvedEndTimeType ?? undefined;
    message.proposedSpendingLimitMicros =
      (object.proposedSpendingLimitMicros !== undefined && object.proposedSpendingLimitMicros !== null)
        ? Long.fromValue(object.proposedSpendingLimitMicros)
        : undefined;
    message.proposedSpendingLimitType = object.proposedSpendingLimitType ?? undefined;
    message.approvedSpendingLimitMicros =
      (object.approvedSpendingLimitMicros !== undefined && object.approvedSpendingLimitMicros !== null)
        ? Long.fromValue(object.approvedSpendingLimitMicros)
        : undefined;
    message.approvedSpendingLimitType = object.approvedSpendingLimitType ?? undefined;
    message.adjustedSpendingLimitMicros =
      (object.adjustedSpendingLimitMicros !== undefined && object.adjustedSpendingLimitMicros !== null)
        ? Long.fromValue(object.adjustedSpendingLimitMicros)
        : undefined;
    message.adjustedSpendingLimitType = object.adjustedSpendingLimitType ?? undefined;
    return message;
  },
};

function createBaseAccountBudget_PendingAccountBudgetProposal(): AccountBudget_PendingAccountBudgetProposal {
  return {
    accountBudgetProposal: undefined,
    proposalType: 0,
    name: undefined,
    startDateTime: undefined,
    purchaseOrderNumber: undefined,
    notes: undefined,
    creationDateTime: undefined,
    endDateTime: undefined,
    endTimeType: undefined,
    spendingLimitMicros: undefined,
    spendingLimitType: undefined,
  };
}

export const AccountBudget_PendingAccountBudgetProposal: MessageFns<AccountBudget_PendingAccountBudgetProposal> = {
  encode(message: AccountBudget_PendingAccountBudgetProposal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountBudgetProposal !== undefined) {
      writer.uint32(98).string(message.accountBudgetProposal);
    }
    if (message.proposalType !== 0) {
      writer.uint32(16).int32(message.proposalType);
    }
    if (message.name !== undefined) {
      writer.uint32(106).string(message.name);
    }
    if (message.startDateTime !== undefined) {
      writer.uint32(114).string(message.startDateTime);
    }
    if (message.purchaseOrderNumber !== undefined) {
      writer.uint32(138).string(message.purchaseOrderNumber);
    }
    if (message.notes !== undefined) {
      writer.uint32(146).string(message.notes);
    }
    if (message.creationDateTime !== undefined) {
      writer.uint32(154).string(message.creationDateTime);
    }
    if (message.endDateTime !== undefined) {
      writer.uint32(122).string(message.endDateTime);
    }
    if (message.endTimeType !== undefined) {
      writer.uint32(48).int32(message.endTimeType);
    }
    if (message.spendingLimitMicros !== undefined) {
      writer.uint32(128).int64(message.spendingLimitMicros.toString());
    }
    if (message.spendingLimitType !== undefined) {
      writer.uint32(64).int32(message.spendingLimitType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountBudget_PendingAccountBudgetProposal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountBudget_PendingAccountBudgetProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 12:
          if (tag !== 98) {
            break;
          }

          message.accountBudgetProposal = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.proposalType = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.name = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.startDateTime = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.purchaseOrderNumber = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.creationDateTime = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.endDateTime = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.endTimeType = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.spendingLimitMicros = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.spendingLimitType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountBudget_PendingAccountBudgetProposal {
    return {
      accountBudgetProposal: isSet(object.accountBudgetProposal)
        ? globalThis.String(object.accountBudgetProposal)
        : undefined,
      proposalType: isSet(object.proposalType)
        ? accountBudgetProposalTypeEnum_AccountBudgetProposalTypeFromJSON(object.proposalType)
        : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      startDateTime: isSet(object.startDateTime) ? globalThis.String(object.startDateTime) : undefined,
      purchaseOrderNumber: isSet(object.purchaseOrderNumber)
        ? globalThis.String(object.purchaseOrderNumber)
        : undefined,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : undefined,
      creationDateTime: isSet(object.creationDateTime) ? globalThis.String(object.creationDateTime) : undefined,
      endDateTime: isSet(object.endDateTime) ? globalThis.String(object.endDateTime) : undefined,
      endTimeType: isSet(object.endTimeType) ? timeTypeEnum_TimeTypeFromJSON(object.endTimeType) : undefined,
      spendingLimitMicros: isSet(object.spendingLimitMicros) ? Long.fromValue(object.spendingLimitMicros) : undefined,
      spendingLimitType: isSet(object.spendingLimitType)
        ? spendingLimitTypeEnum_SpendingLimitTypeFromJSON(object.spendingLimitType)
        : undefined,
    };
  },

  toJSON(message: AccountBudget_PendingAccountBudgetProposal): unknown {
    const obj: any = {};
    if (message.accountBudgetProposal !== undefined) {
      obj.accountBudgetProposal = message.accountBudgetProposal;
    }
    if (message.proposalType !== 0) {
      obj.proposalType = accountBudgetProposalTypeEnum_AccountBudgetProposalTypeToJSON(message.proposalType);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.startDateTime !== undefined) {
      obj.startDateTime = message.startDateTime;
    }
    if (message.purchaseOrderNumber !== undefined) {
      obj.purchaseOrderNumber = message.purchaseOrderNumber;
    }
    if (message.notes !== undefined) {
      obj.notes = message.notes;
    }
    if (message.creationDateTime !== undefined) {
      obj.creationDateTime = message.creationDateTime;
    }
    if (message.endDateTime !== undefined) {
      obj.endDateTime = message.endDateTime;
    }
    if (message.endTimeType !== undefined) {
      obj.endTimeType = timeTypeEnum_TimeTypeToJSON(message.endTimeType);
    }
    if (message.spendingLimitMicros !== undefined) {
      obj.spendingLimitMicros = (message.spendingLimitMicros || Long.ZERO).toString();
    }
    if (message.spendingLimitType !== undefined) {
      obj.spendingLimitType = spendingLimitTypeEnum_SpendingLimitTypeToJSON(message.spendingLimitType);
    }
    return obj;
  },

  create(base?: DeepPartial<AccountBudget_PendingAccountBudgetProposal>): AccountBudget_PendingAccountBudgetProposal {
    return AccountBudget_PendingAccountBudgetProposal.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AccountBudget_PendingAccountBudgetProposal>,
  ): AccountBudget_PendingAccountBudgetProposal {
    const message = createBaseAccountBudget_PendingAccountBudgetProposal();
    message.accountBudgetProposal = object.accountBudgetProposal ?? undefined;
    message.proposalType = object.proposalType ?? 0;
    message.name = object.name ?? undefined;
    message.startDateTime = object.startDateTime ?? undefined;
    message.purchaseOrderNumber = object.purchaseOrderNumber ?? undefined;
    message.notes = object.notes ?? undefined;
    message.creationDateTime = object.creationDateTime ?? undefined;
    message.endDateTime = object.endDateTime ?? undefined;
    message.endTimeType = object.endTimeType ?? undefined;
    message.spendingLimitMicros = (object.spendingLimitMicros !== undefined && object.spendingLimitMicros !== null)
      ? Long.fromValue(object.spendingLimitMicros)
      : undefined;
    message.spendingLimitType = object.spendingLimitType ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
