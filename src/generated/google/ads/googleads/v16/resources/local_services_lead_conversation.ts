// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v16/resources/local_services_lead_conversation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  LocalServicesLeadConversationTypeEnum_ConversationType,
  localServicesLeadConversationTypeEnum_ConversationTypeFromJSON,
  localServicesLeadConversationTypeEnum_ConversationTypeToJSON,
} from "../enums/local_services_conversation_type.js";
import {
  LocalServicesParticipantTypeEnum_ParticipantType,
  localServicesParticipantTypeEnum_ParticipantTypeFromJSON,
  localServicesParticipantTypeEnum_ParticipantTypeToJSON,
} from "../enums/local_services_participant_type.js";

export const protobufPackage = "google.ads.googleads.v16.resources";

/**
 * Data from Local Services Lead Conversation.
 * Contains details of Lead Conversation which is generated when user calls,
 * messages or books service from advertiser. These are appended to a Lead.
 * More info: https://ads.google.com/local-services-ads
 */
export interface LocalServicesLeadConversation {
  /**
   * Output only. The resource name of the local services lead conversation
   * data. Local Services Lead Conversation resource name have the form
   *
   * `customers/{customer_id}/localServicesLeadConversation/{local_services_lead_conversation_id}`
   */
  resourceName: string;
  /** Output only. ID of this Lead Conversation. */
  id: Long;
  /**
   * Output only. Type of GLS lead conversation, EMAIL, MESSAGE, PHONE_CALL,
   * SMS, etc.
   */
  conversationChannel: LocalServicesLeadConversationTypeEnum_ConversationType;
  /**
   * Output only. Type of participant in the lead conversation, ADVERTISER or
   * CONSUMER.
   */
  participantType: LocalServicesParticipantTypeEnum_ParticipantType;
  /** Output only. Resource name of Lead associated to the Lead Conversation. */
  lead: string;
  /**
   * Output only. The date time at which lead conversation was created by Local
   * Services Ads. The format is "YYYY-MM-DD HH:MM:SS" in the Google Ads
   * account's timezone. Examples: "2018-03-05 09:15:00" or "2018-02-01
   * 14:34:30"
   */
  eventDateTime: string;
  /** Output only. Details of phone call conversation in case of PHONE_CALL. */
  phoneCallDetails?:
    | PhoneCallDetails
    | undefined;
  /**
   * Output only. Details of message conversation in case of EMAIL, MESSAGE or
   * SMS.
   */
  messageDetails?: MessageDetails | undefined;
}

/** Represents details of a phone call conversation. */
export interface PhoneCallDetails {
  /** Output only. The duration (in milliseconds) of the phone call (end to end). */
  callDurationMillis: Long;
  /** Output only. URL to the call recording audio file. */
  callRecordingUrl: string;
}

/** Represents details of text message in case of email, message or SMS. */
export interface MessageDetails {
  /** Output only. Textual content of the message. */
  text: string;
  /**
   * Output only. URL to the SMS or email attachments. These URLs can be used to
   * download the contents of the attachment by using the developer token.
   */
  attachmentUrls: string[];
}

function createBaseLocalServicesLeadConversation(): LocalServicesLeadConversation {
  return {
    resourceName: "",
    id: Long.ZERO,
    conversationChannel: 0,
    participantType: 0,
    lead: "",
    eventDateTime: "",
    phoneCallDetails: undefined,
    messageDetails: undefined,
  };
}

export const LocalServicesLeadConversation: MessageFns<LocalServicesLeadConversation> = {
  encode(message: LocalServicesLeadConversation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    if (!message.id.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.id.toString());
    }
    if (message.conversationChannel !== 0) {
      writer.uint32(24).int32(message.conversationChannel);
    }
    if (message.participantType !== 0) {
      writer.uint32(32).int32(message.participantType);
    }
    if (message.lead !== "") {
      writer.uint32(42).string(message.lead);
    }
    if (message.eventDateTime !== "") {
      writer.uint32(50).string(message.eventDateTime);
    }
    if (message.phoneCallDetails !== undefined) {
      PhoneCallDetails.encode(message.phoneCallDetails, writer.uint32(58).fork()).join();
    }
    if (message.messageDetails !== undefined) {
      MessageDetails.encode(message.messageDetails, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalServicesLeadConversation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalServicesLeadConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.conversationChannel = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.participantType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lead = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.eventDateTime = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.phoneCallDetails = PhoneCallDetails.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.messageDetails = MessageDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalServicesLeadConversation {
    return {
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.ZERO,
      conversationChannel: isSet(object.conversationChannel)
        ? localServicesLeadConversationTypeEnum_ConversationTypeFromJSON(object.conversationChannel)
        : 0,
      participantType: isSet(object.participantType)
        ? localServicesParticipantTypeEnum_ParticipantTypeFromJSON(object.participantType)
        : 0,
      lead: isSet(object.lead) ? globalThis.String(object.lead) : "",
      eventDateTime: isSet(object.eventDateTime) ? globalThis.String(object.eventDateTime) : "",
      phoneCallDetails: isSet(object.phoneCallDetails) ? PhoneCallDetails.fromJSON(object.phoneCallDetails) : undefined,
      messageDetails: isSet(object.messageDetails) ? MessageDetails.fromJSON(object.messageDetails) : undefined,
    };
  },

  toJSON(message: LocalServicesLeadConversation): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (!message.id.equals(Long.ZERO)) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (message.conversationChannel !== 0) {
      obj.conversationChannel = localServicesLeadConversationTypeEnum_ConversationTypeToJSON(
        message.conversationChannel,
      );
    }
    if (message.participantType !== 0) {
      obj.participantType = localServicesParticipantTypeEnum_ParticipantTypeToJSON(message.participantType);
    }
    if (message.lead !== "") {
      obj.lead = message.lead;
    }
    if (message.eventDateTime !== "") {
      obj.eventDateTime = message.eventDateTime;
    }
    if (message.phoneCallDetails !== undefined) {
      obj.phoneCallDetails = PhoneCallDetails.toJSON(message.phoneCallDetails);
    }
    if (message.messageDetails !== undefined) {
      obj.messageDetails = MessageDetails.toJSON(message.messageDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<LocalServicesLeadConversation>): LocalServicesLeadConversation {
    return LocalServicesLeadConversation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocalServicesLeadConversation>): LocalServicesLeadConversation {
    const message = createBaseLocalServicesLeadConversation();
    message.resourceName = object.resourceName ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.ZERO;
    message.conversationChannel = object.conversationChannel ?? 0;
    message.participantType = object.participantType ?? 0;
    message.lead = object.lead ?? "";
    message.eventDateTime = object.eventDateTime ?? "";
    message.phoneCallDetails = (object.phoneCallDetails !== undefined && object.phoneCallDetails !== null)
      ? PhoneCallDetails.fromPartial(object.phoneCallDetails)
      : undefined;
    message.messageDetails = (object.messageDetails !== undefined && object.messageDetails !== null)
      ? MessageDetails.fromPartial(object.messageDetails)
      : undefined;
    return message;
  },
};

function createBasePhoneCallDetails(): PhoneCallDetails {
  return { callDurationMillis: Long.ZERO, callRecordingUrl: "" };
}

export const PhoneCallDetails: MessageFns<PhoneCallDetails> = {
  encode(message: PhoneCallDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.callDurationMillis.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.callDurationMillis.toString());
    }
    if (message.callRecordingUrl !== "") {
      writer.uint32(18).string(message.callRecordingUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhoneCallDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhoneCallDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.callDurationMillis = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.callRecordingUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhoneCallDetails {
    return {
      callDurationMillis: isSet(object.callDurationMillis) ? Long.fromValue(object.callDurationMillis) : Long.ZERO,
      callRecordingUrl: isSet(object.callRecordingUrl) ? globalThis.String(object.callRecordingUrl) : "",
    };
  },

  toJSON(message: PhoneCallDetails): unknown {
    const obj: any = {};
    if (!message.callDurationMillis.equals(Long.ZERO)) {
      obj.callDurationMillis = (message.callDurationMillis || Long.ZERO).toString();
    }
    if (message.callRecordingUrl !== "") {
      obj.callRecordingUrl = message.callRecordingUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<PhoneCallDetails>): PhoneCallDetails {
    return PhoneCallDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhoneCallDetails>): PhoneCallDetails {
    const message = createBasePhoneCallDetails();
    message.callDurationMillis = (object.callDurationMillis !== undefined && object.callDurationMillis !== null)
      ? Long.fromValue(object.callDurationMillis)
      : Long.ZERO;
    message.callRecordingUrl = object.callRecordingUrl ?? "";
    return message;
  },
};

function createBaseMessageDetails(): MessageDetails {
  return { text: "", attachmentUrls: [] };
}

export const MessageDetails: MessageFns<MessageDetails> = {
  encode(message: MessageDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    for (const v of message.attachmentUrls) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attachmentUrls.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageDetails {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      attachmentUrls: globalThis.Array.isArray(object?.attachmentUrls)
        ? object.attachmentUrls.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MessageDetails): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.attachmentUrls?.length) {
      obj.attachmentUrls = message.attachmentUrls;
    }
    return obj;
  },

  create(base?: DeepPartial<MessageDetails>): MessageDetails {
    return MessageDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageDetails>): MessageDetails {
    const message = createBaseMessageDetails();
    message.text = object.text ?? "";
    message.attachmentUrls = object.attachmentUrls?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
