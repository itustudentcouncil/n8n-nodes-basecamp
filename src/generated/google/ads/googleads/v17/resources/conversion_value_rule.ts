// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v17/resources/conversion_value_rule.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  ConversionValueRuleStatusEnum_ConversionValueRuleStatus,
  conversionValueRuleStatusEnum_ConversionValueRuleStatusFromJSON,
  conversionValueRuleStatusEnum_ConversionValueRuleStatusToJSON,
} from "../enums/conversion_value_rule_status.js";
import {
  ValueRuleDeviceTypeEnum_ValueRuleDeviceType,
  valueRuleDeviceTypeEnum_ValueRuleDeviceTypeFromJSON,
  valueRuleDeviceTypeEnum_ValueRuleDeviceTypeToJSON,
} from "../enums/value_rule_device_type.js";
import {
  ValueRuleGeoLocationMatchTypeEnum_ValueRuleGeoLocationMatchType,
  valueRuleGeoLocationMatchTypeEnum_ValueRuleGeoLocationMatchTypeFromJSON,
  valueRuleGeoLocationMatchTypeEnum_ValueRuleGeoLocationMatchTypeToJSON,
} from "../enums/value_rule_geo_location_match_type.js";
import {
  ValueRuleOperationEnum_ValueRuleOperation,
  valueRuleOperationEnum_ValueRuleOperationFromJSON,
  valueRuleOperationEnum_ValueRuleOperationToJSON,
} from "../enums/value_rule_operation.js";

export const protobufPackage = "google.ads.googleads.v17.resources";

/** A conversion value rule */
export interface ConversionValueRule {
  /**
   * Immutable. The resource name of the conversion value rule.
   * Conversion value rule resource names have the form:
   *
   * `customers/{customer_id}/conversionValueRules/{conversion_value_rule_id}`
   */
  resourceName: string;
  /** Output only. The ID of the conversion value rule. */
  id: Long;
  /** Action applied when the rule is triggered. */
  action:
    | ConversionValueRule_ValueRuleAction
    | undefined;
  /**
   * Condition for Geo location that must be satisfied for the value rule to
   * apply.
   */
  geoLocationCondition:
    | ConversionValueRule_ValueRuleGeoLocationCondition
    | undefined;
  /**
   * Condition for device type that must be satisfied for the value rule to
   * apply.
   */
  deviceCondition:
    | ConversionValueRule_ValueRuleDeviceCondition
    | undefined;
  /** Condition for audience that must be satisfied for the value rule to apply. */
  audienceCondition:
    | ConversionValueRule_ValueRuleAudienceCondition
    | undefined;
  /**
   * Output only. The resource name of the conversion value rule's owner
   * customer. When the value rule is inherited from a manager customer,
   * owner_customer will be the resource name of the manager whereas the
   * customer in the resource_name will be of the requesting serving customer.
   * ** Read-only **
   */
  ownerCustomer: string;
  /** The status of the conversion value rule. */
  status: ConversionValueRuleStatusEnum_ConversionValueRuleStatus;
}

/** Action applied when rule is applied. */
export interface ConversionValueRule_ValueRuleAction {
  /** Specifies applied operation. */
  operation: ValueRuleOperationEnum_ValueRuleOperation;
  /** Specifies applied value. */
  value: number;
}

/** Condition on Geo dimension. */
export interface ConversionValueRule_ValueRuleGeoLocationCondition {
  /** Geo locations that advertisers want to exclude. */
  excludedGeoTargetConstants: string[];
  /** Excluded Geo location match type. */
  excludedGeoMatchType: ValueRuleGeoLocationMatchTypeEnum_ValueRuleGeoLocationMatchType;
  /** Geo locations that advertisers want to include. */
  geoTargetConstants: string[];
  /** Included Geo location match type. */
  geoMatchType: ValueRuleGeoLocationMatchTypeEnum_ValueRuleGeoLocationMatchType;
}

/** Condition on Device dimension. */
export interface ConversionValueRule_ValueRuleDeviceCondition {
  /** Value for device type condition. */
  deviceTypes: ValueRuleDeviceTypeEnum_ValueRuleDeviceType[];
}

/** Condition on Audience dimension. */
export interface ConversionValueRule_ValueRuleAudienceCondition {
  /** User Lists. */
  userLists: string[];
  /** User Interests. */
  userInterests: string[];
}

function createBaseConversionValueRule(): ConversionValueRule {
  return {
    resourceName: "",
    id: Long.ZERO,
    action: undefined,
    geoLocationCondition: undefined,
    deviceCondition: undefined,
    audienceCondition: undefined,
    ownerCustomer: "",
    status: 0,
  };
}

export const ConversionValueRule: MessageFns<ConversionValueRule> = {
  encode(message: ConversionValueRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    if (!message.id.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.id.toString());
    }
    if (message.action !== undefined) {
      ConversionValueRule_ValueRuleAction.encode(message.action, writer.uint32(26).fork()).join();
    }
    if (message.geoLocationCondition !== undefined) {
      ConversionValueRule_ValueRuleGeoLocationCondition.encode(message.geoLocationCondition, writer.uint32(34).fork())
        .join();
    }
    if (message.deviceCondition !== undefined) {
      ConversionValueRule_ValueRuleDeviceCondition.encode(message.deviceCondition, writer.uint32(42).fork()).join();
    }
    if (message.audienceCondition !== undefined) {
      ConversionValueRule_ValueRuleAudienceCondition.encode(message.audienceCondition, writer.uint32(50).fork()).join();
    }
    if (message.ownerCustomer !== "") {
      writer.uint32(58).string(message.ownerCustomer);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionValueRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionValueRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.action = ConversionValueRule_ValueRuleAction.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.geoLocationCondition = ConversionValueRule_ValueRuleGeoLocationCondition.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.deviceCondition = ConversionValueRule_ValueRuleDeviceCondition.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.audienceCondition = ConversionValueRule_ValueRuleAudienceCondition.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ownerCustomer = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionValueRule {
    return {
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.ZERO,
      action: isSet(object.action) ? ConversionValueRule_ValueRuleAction.fromJSON(object.action) : undefined,
      geoLocationCondition: isSet(object.geoLocationCondition)
        ? ConversionValueRule_ValueRuleGeoLocationCondition.fromJSON(object.geoLocationCondition)
        : undefined,
      deviceCondition: isSet(object.deviceCondition)
        ? ConversionValueRule_ValueRuleDeviceCondition.fromJSON(object.deviceCondition)
        : undefined,
      audienceCondition: isSet(object.audienceCondition)
        ? ConversionValueRule_ValueRuleAudienceCondition.fromJSON(object.audienceCondition)
        : undefined,
      ownerCustomer: isSet(object.ownerCustomer) ? globalThis.String(object.ownerCustomer) : "",
      status: isSet(object.status) ? conversionValueRuleStatusEnum_ConversionValueRuleStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: ConversionValueRule): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (!message.id.equals(Long.ZERO)) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (message.action !== undefined) {
      obj.action = ConversionValueRule_ValueRuleAction.toJSON(message.action);
    }
    if (message.geoLocationCondition !== undefined) {
      obj.geoLocationCondition = ConversionValueRule_ValueRuleGeoLocationCondition.toJSON(message.geoLocationCondition);
    }
    if (message.deviceCondition !== undefined) {
      obj.deviceCondition = ConversionValueRule_ValueRuleDeviceCondition.toJSON(message.deviceCondition);
    }
    if (message.audienceCondition !== undefined) {
      obj.audienceCondition = ConversionValueRule_ValueRuleAudienceCondition.toJSON(message.audienceCondition);
    }
    if (message.ownerCustomer !== "") {
      obj.ownerCustomer = message.ownerCustomer;
    }
    if (message.status !== 0) {
      obj.status = conversionValueRuleStatusEnum_ConversionValueRuleStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionValueRule>): ConversionValueRule {
    return ConversionValueRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversionValueRule>): ConversionValueRule {
    const message = createBaseConversionValueRule();
    message.resourceName = object.resourceName ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.ZERO;
    message.action = (object.action !== undefined && object.action !== null)
      ? ConversionValueRule_ValueRuleAction.fromPartial(object.action)
      : undefined;
    message.geoLocationCondition = (object.geoLocationCondition !== undefined && object.geoLocationCondition !== null)
      ? ConversionValueRule_ValueRuleGeoLocationCondition.fromPartial(object.geoLocationCondition)
      : undefined;
    message.deviceCondition = (object.deviceCondition !== undefined && object.deviceCondition !== null)
      ? ConversionValueRule_ValueRuleDeviceCondition.fromPartial(object.deviceCondition)
      : undefined;
    message.audienceCondition = (object.audienceCondition !== undefined && object.audienceCondition !== null)
      ? ConversionValueRule_ValueRuleAudienceCondition.fromPartial(object.audienceCondition)
      : undefined;
    message.ownerCustomer = object.ownerCustomer ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseConversionValueRule_ValueRuleAction(): ConversionValueRule_ValueRuleAction {
  return { operation: 0, value: 0 };
}

export const ConversionValueRule_ValueRuleAction: MessageFns<ConversionValueRule_ValueRuleAction> = {
  encode(message: ConversionValueRule_ValueRuleAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== 0) {
      writer.uint32(8).int32(message.operation);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionValueRule_ValueRuleAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionValueRule_ValueRuleAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionValueRule_ValueRuleAction {
    return {
      operation: isSet(object.operation) ? valueRuleOperationEnum_ValueRuleOperationFromJSON(object.operation) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: ConversionValueRule_ValueRuleAction): unknown {
    const obj: any = {};
    if (message.operation !== 0) {
      obj.operation = valueRuleOperationEnum_ValueRuleOperationToJSON(message.operation);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionValueRule_ValueRuleAction>): ConversionValueRule_ValueRuleAction {
    return ConversionValueRule_ValueRuleAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversionValueRule_ValueRuleAction>): ConversionValueRule_ValueRuleAction {
    const message = createBaseConversionValueRule_ValueRuleAction();
    message.operation = object.operation ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseConversionValueRule_ValueRuleGeoLocationCondition(): ConversionValueRule_ValueRuleGeoLocationCondition {
  return { excludedGeoTargetConstants: [], excludedGeoMatchType: 0, geoTargetConstants: [], geoMatchType: 0 };
}

export const ConversionValueRule_ValueRuleGeoLocationCondition: MessageFns<
  ConversionValueRule_ValueRuleGeoLocationCondition
> = {
  encode(
    message: ConversionValueRule_ValueRuleGeoLocationCondition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.excludedGeoTargetConstants) {
      writer.uint32(10).string(v!);
    }
    if (message.excludedGeoMatchType !== 0) {
      writer.uint32(16).int32(message.excludedGeoMatchType);
    }
    for (const v of message.geoTargetConstants) {
      writer.uint32(26).string(v!);
    }
    if (message.geoMatchType !== 0) {
      writer.uint32(32).int32(message.geoMatchType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionValueRule_ValueRuleGeoLocationCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionValueRule_ValueRuleGeoLocationCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.excludedGeoTargetConstants.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.excludedGeoMatchType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.geoTargetConstants.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.geoMatchType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionValueRule_ValueRuleGeoLocationCondition {
    return {
      excludedGeoTargetConstants: globalThis.Array.isArray(object?.excludedGeoTargetConstants)
        ? object.excludedGeoTargetConstants.map((e: any) => globalThis.String(e))
        : [],
      excludedGeoMatchType: isSet(object.excludedGeoMatchType)
        ? valueRuleGeoLocationMatchTypeEnum_ValueRuleGeoLocationMatchTypeFromJSON(object.excludedGeoMatchType)
        : 0,
      geoTargetConstants: globalThis.Array.isArray(object?.geoTargetConstants)
        ? object.geoTargetConstants.map((e: any) => globalThis.String(e))
        : [],
      geoMatchType: isSet(object.geoMatchType)
        ? valueRuleGeoLocationMatchTypeEnum_ValueRuleGeoLocationMatchTypeFromJSON(object.geoMatchType)
        : 0,
    };
  },

  toJSON(message: ConversionValueRule_ValueRuleGeoLocationCondition): unknown {
    const obj: any = {};
    if (message.excludedGeoTargetConstants?.length) {
      obj.excludedGeoTargetConstants = message.excludedGeoTargetConstants;
    }
    if (message.excludedGeoMatchType !== 0) {
      obj.excludedGeoMatchType = valueRuleGeoLocationMatchTypeEnum_ValueRuleGeoLocationMatchTypeToJSON(
        message.excludedGeoMatchType,
      );
    }
    if (message.geoTargetConstants?.length) {
      obj.geoTargetConstants = message.geoTargetConstants;
    }
    if (message.geoMatchType !== 0) {
      obj.geoMatchType = valueRuleGeoLocationMatchTypeEnum_ValueRuleGeoLocationMatchTypeToJSON(message.geoMatchType);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ConversionValueRule_ValueRuleGeoLocationCondition>,
  ): ConversionValueRule_ValueRuleGeoLocationCondition {
    return ConversionValueRule_ValueRuleGeoLocationCondition.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ConversionValueRule_ValueRuleGeoLocationCondition>,
  ): ConversionValueRule_ValueRuleGeoLocationCondition {
    const message = createBaseConversionValueRule_ValueRuleGeoLocationCondition();
    message.excludedGeoTargetConstants = object.excludedGeoTargetConstants?.map((e) => e) || [];
    message.excludedGeoMatchType = object.excludedGeoMatchType ?? 0;
    message.geoTargetConstants = object.geoTargetConstants?.map((e) => e) || [];
    message.geoMatchType = object.geoMatchType ?? 0;
    return message;
  },
};

function createBaseConversionValueRule_ValueRuleDeviceCondition(): ConversionValueRule_ValueRuleDeviceCondition {
  return { deviceTypes: [] };
}

export const ConversionValueRule_ValueRuleDeviceCondition: MessageFns<ConversionValueRule_ValueRuleDeviceCondition> = {
  encode(
    message: ConversionValueRule_ValueRuleDeviceCondition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.deviceTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionValueRule_ValueRuleDeviceCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionValueRule_ValueRuleDeviceCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.deviceTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.deviceTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionValueRule_ValueRuleDeviceCondition {
    return {
      deviceTypes: globalThis.Array.isArray(object?.deviceTypes)
        ? object.deviceTypes.map((e: any) => valueRuleDeviceTypeEnum_ValueRuleDeviceTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: ConversionValueRule_ValueRuleDeviceCondition): unknown {
    const obj: any = {};
    if (message.deviceTypes?.length) {
      obj.deviceTypes = message.deviceTypes.map((e) => valueRuleDeviceTypeEnum_ValueRuleDeviceTypeToJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<ConversionValueRule_ValueRuleDeviceCondition>,
  ): ConversionValueRule_ValueRuleDeviceCondition {
    return ConversionValueRule_ValueRuleDeviceCondition.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ConversionValueRule_ValueRuleDeviceCondition>,
  ): ConversionValueRule_ValueRuleDeviceCondition {
    const message = createBaseConversionValueRule_ValueRuleDeviceCondition();
    message.deviceTypes = object.deviceTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseConversionValueRule_ValueRuleAudienceCondition(): ConversionValueRule_ValueRuleAudienceCondition {
  return { userLists: [], userInterests: [] };
}

export const ConversionValueRule_ValueRuleAudienceCondition: MessageFns<
  ConversionValueRule_ValueRuleAudienceCondition
> = {
  encode(
    message: ConversionValueRule_ValueRuleAudienceCondition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.userLists) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.userInterests) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionValueRule_ValueRuleAudienceCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionValueRule_ValueRuleAudienceCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userLists.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userInterests.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionValueRule_ValueRuleAudienceCondition {
    return {
      userLists: globalThis.Array.isArray(object?.userLists)
        ? object.userLists.map((e: any) => globalThis.String(e))
        : [],
      userInterests: globalThis.Array.isArray(object?.userInterests)
        ? object.userInterests.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ConversionValueRule_ValueRuleAudienceCondition): unknown {
    const obj: any = {};
    if (message.userLists?.length) {
      obj.userLists = message.userLists;
    }
    if (message.userInterests?.length) {
      obj.userInterests = message.userInterests;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ConversionValueRule_ValueRuleAudienceCondition>,
  ): ConversionValueRule_ValueRuleAudienceCondition {
    return ConversionValueRule_ValueRuleAudienceCondition.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ConversionValueRule_ValueRuleAudienceCondition>,
  ): ConversionValueRule_ValueRuleAudienceCondition {
    const message = createBaseConversionValueRule_ValueRuleAudienceCondition();
    message.userLists = object.userLists?.map((e) => e) || [];
    message.userInterests = object.userInterests?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
