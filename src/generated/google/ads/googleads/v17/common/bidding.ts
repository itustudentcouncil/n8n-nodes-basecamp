// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v17/common/bidding.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  FixedCpmGoalEnum_FixedCpmGoal,
  fixedCpmGoalEnum_FixedCpmGoalFromJSON,
  fixedCpmGoalEnum_FixedCpmGoalToJSON,
} from "../enums/fixed_cpm_goal.js";
import {
  FixedCpmTargetFrequencyTimeUnitEnum_FixedCpmTargetFrequencyTimeUnit,
  fixedCpmTargetFrequencyTimeUnitEnum_FixedCpmTargetFrequencyTimeUnitFromJSON,
  fixedCpmTargetFrequencyTimeUnitEnum_FixedCpmTargetFrequencyTimeUnitToJSON,
} from "../enums/fixed_cpm_target_frequency_time_unit.js";
import {
  TargetFrequencyTimeUnitEnum_TargetFrequencyTimeUnit,
  targetFrequencyTimeUnitEnum_TargetFrequencyTimeUnitFromJSON,
  targetFrequencyTimeUnitEnum_TargetFrequencyTimeUnitToJSON,
} from "../enums/target_frequency_time_unit.js";
import {
  TargetImpressionShareLocationEnum_TargetImpressionShareLocation,
  targetImpressionShareLocationEnum_TargetImpressionShareLocationFromJSON,
  targetImpressionShareLocationEnum_TargetImpressionShareLocationToJSON,
} from "../enums/target_impression_share_location.js";

export const protobufPackage = "google.ads.googleads.v17.common";

/**
 * Commission is an automatic bidding strategy in which the advertiser pays a
 * certain portion of the conversion value.
 */
export interface Commission {
  /**
   * Commission rate defines the portion of the conversion value that the
   * advertiser will be billed. A commission rate of x should be passed into
   * this field as (x * 1,000,000). For example, 106,000 represents a commission
   * rate of 0.106 (10.6%).
   */
  commissionRateMicros?: Long | undefined;
}

/**
 * An automated bidding strategy that raises bids for clicks
 * that seem more likely to lead to a conversion and lowers
 * them for clicks where they seem less likely.
 *
 * This bidding strategy is deprecated and cannot be created anymore. Use
 * ManualCpc with enhanced_cpc_enabled set to true for equivalent functionality.
 */
export interface EnhancedCpc {
}

/**
 * Manual bidding strategy that allows advertiser to set the bid per
 * advertiser-specified action.
 */
export interface ManualCpa {
}

/** Manual click-based bidding where user pays per click. */
export interface ManualCpc {
  /** Whether bids are to be enhanced based on conversion optimizer data. */
  enhancedCpcEnabled?: boolean | undefined;
}

/** Manual impression-based bidding where user pays per thousand impressions. */
export interface ManualCpm {
}

/** View based bidding where user pays per video view. */
export interface ManualCpv {
}

/**
 * An automated bidding strategy to help get the most conversions for your
 * campaigns while spending your budget.
 */
export interface MaximizeConversions {
  /**
   * Maximum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * Mutable for portfolio bidding strategies only.
   */
  cpcBidCeilingMicros: Long;
  /**
   * Minimum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * Mutable for portfolio bidding strategies only.
   */
  cpcBidFloorMicros: Long;
  /**
   * The target cost-per-action (CPA) option. This is the average amount that
   * you would like to spend per conversion action specified in micro units of
   * the bidding strategy's currency. If set, the bid strategy will get as many
   * conversions as possible at or below the target cost-per-action. If the
   * target CPA is not set, the bid strategy will aim to achieve the lowest
   * possible CPA given the budget.
   */
  targetCpaMicros: Long;
}

/**
 * An automated bidding strategy to help get the most conversion value for your
 * campaigns while spending your budget.
 */
export interface MaximizeConversionValue {
  /**
   * The target return on ad spend (ROAS) option. If set, the bid strategy will
   * maximize revenue while averaging the target return on ad spend. If the
   * target ROAS is high, the bid strategy may not be able to spend the full
   * budget. If the target ROAS is not set, the bid strategy will aim to
   * achieve the highest possible ROAS for the budget.
   */
  targetRoas: number;
  /**
   * Maximum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * Mutable for portfolio bidding strategies only.
   */
  cpcBidCeilingMicros: Long;
  /**
   * Minimum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * Mutable for portfolio bidding strategies only.
   */
  cpcBidFloorMicros: Long;
}

/**
 * An automated bid strategy that sets bids to help get as many conversions as
 * possible at the target cost-per-acquisition (CPA) you set.
 */
export interface TargetCpa {
  /**
   * Average CPA target.
   * This target should be greater than or equal to minimum billable unit based
   * on the currency for the account.
   */
  targetCpaMicros?:
    | Long
    | undefined;
  /**
   * Maximum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * This should only be set for portfolio bid strategies.
   */
  cpcBidCeilingMicros?:
    | Long
    | undefined;
  /**
   * Minimum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * This should only be set for portfolio bid strategies.
   */
  cpcBidFloorMicros?: Long | undefined;
}

/**
 * Target CPM (cost per thousand impressions) is an automated bidding strategy
 * that sets bids to optimize performance given the target CPM you set.
 */
export interface TargetCpm {
  /** Target Frequency bidding goal details. */
  targetFrequencyGoal?: TargetCpmTargetFrequencyGoal | undefined;
}

/** Target Frequency bidding goal details. */
export interface TargetCpmTargetFrequencyGoal {
  /**
   * Target Frequency count representing how many times you want to reach
   * a single user.
   */
  targetCount: Long;
  /**
   * Time window expressing the period over which you want to reach
   * the specified target_count.
   */
  timeUnit: TargetFrequencyTimeUnitEnum_TargetFrequencyTimeUnit;
}

/**
 * An automated bidding strategy that sets bids so that a certain percentage of
 * search ads are shown at the top of the first page (or other targeted
 * location).
 */
export interface TargetImpressionShare {
  /** The targeted location on the search results page. */
  location: TargetImpressionShareLocationEnum_TargetImpressionShareLocation;
  /**
   * The chosen fraction of ads to be shown in the targeted location in micros.
   * For example, 1% equals 10,000.
   */
  locationFractionMicros?:
    | Long
    | undefined;
  /**
   * The highest CPC bid the automated bidding system is permitted to specify.
   * This is a required field entered by the advertiser that sets the ceiling
   * and specified in local micros.
   */
  cpcBidCeilingMicros?: Long | undefined;
}

/**
 * An automated bidding strategy that helps you maximize revenue while
 * averaging a specific target return on ad spend (ROAS).
 */
export interface TargetRoas {
  /**
   * Required. The chosen revenue (based on conversion data) per unit of spend.
   * Value must be between 0.01 and 1000.0, inclusive.
   */
  targetRoas?:
    | number
    | undefined;
  /**
   * Maximum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * This should only be set for portfolio bid strategies.
   */
  cpcBidCeilingMicros?:
    | Long
    | undefined;
  /**
   * Minimum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   * This should only be set for portfolio bid strategies.
   */
  cpcBidFloorMicros?: Long | undefined;
}

/**
 * An automated bid strategy that sets your bids to help get as many clicks
 * as possible within your budget.
 */
export interface TargetSpend {
  /**
   * Deprecated: The spend target under which to maximize clicks.
   * A TargetSpend bidder will attempt to spend the smaller of this value
   * or the natural throttling spend amount.
   * If not specified, the budget is used as the spend target.
   * This field is deprecated and should no longer be used. See
   * https://ads-developers.googleblog.com/2020/05/reminder-about-sunset-creation-of.html
   * for details.
   *
   * @deprecated
   */
  targetSpendMicros?:
    | Long
    | undefined;
  /**
   * Maximum bid limit that can be set by the bid strategy.
   * The limit applies to all keywords managed by the strategy.
   */
  cpcBidCeilingMicros?: Long | undefined;
}

/**
 * A bidding strategy where bids are a fraction of the advertised price for
 * some good or service.
 */
export interface PercentCpc {
  /**
   * Maximum bid limit that can be set by the bid strategy. This is
   * an optional field entered by the advertiser and specified in local micros.
   * Note: A zero value is interpreted in the same way as having bid_ceiling
   * undefined.
   */
  cpcBidCeilingMicros?:
    | Long
    | undefined;
  /**
   * Adjusts the bid for each auction upward or downward, depending on the
   * likelihood of a conversion. Individual bids may exceed
   * cpc_bid_ceiling_micros, but the average bid amount for a campaign should
   * not.
   */
  enhancedCpcEnabled?: boolean | undefined;
}

/**
 * Fixed CPM (cost per thousand impression) bidding strategy. A manual bidding
 * strategy with a fixed CPM.
 */
export interface FixedCpm {
  /**
   * Fixed CPM bidding goal. Determines the exact bidding optimization
   * parameters.
   */
  goal: FixedCpmGoalEnum_FixedCpmGoal;
  /** Target frequency bidding goal details. */
  targetFrequencyInfo?: FixedCpmTargetFrequencyGoalInfo | undefined;
}

/**
 * Target frequency bidding goal details for Fixed CPM bidding strategy. Only
 * relevant if the goal of the bidding strategy is `TARGET_FREQUENCY`.
 */
export interface FixedCpmTargetFrequencyGoalInfo {
  /**
   * Target frequency count represents the number of times an advertiser wants
   * to show the ad to target a single user.
   */
  targetCount: Long;
  /**
   * Time window expressing the period over which you want to reach
   * the specified target_count.
   */
  timeUnit: FixedCpmTargetFrequencyTimeUnitEnum_FixedCpmTargetFrequencyTimeUnit;
}

/**
 * Target CPV (cost per view) bidding strategy. An automated bidding strategy
 * that sets bids to optimize performance given the target CPV you set.
 */
export interface TargetCpv {
}

function createBaseCommission(): Commission {
  return { commissionRateMicros: undefined };
}

export const Commission: MessageFns<Commission> = {
  encode(message: Commission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commissionRateMicros !== undefined) {
      writer.uint32(16).int64(message.commissionRateMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Commission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.commissionRateMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Commission {
    return {
      commissionRateMicros: isSet(object.commissionRateMicros)
        ? Long.fromValue(object.commissionRateMicros)
        : undefined,
    };
  },

  toJSON(message: Commission): unknown {
    const obj: any = {};
    if (message.commissionRateMicros !== undefined) {
      obj.commissionRateMicros = (message.commissionRateMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Commission>): Commission {
    return Commission.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Commission>): Commission {
    const message = createBaseCommission();
    message.commissionRateMicros = (object.commissionRateMicros !== undefined && object.commissionRateMicros !== null)
      ? Long.fromValue(object.commissionRateMicros)
      : undefined;
    return message;
  },
};

function createBaseEnhancedCpc(): EnhancedCpc {
  return {};
}

export const EnhancedCpc: MessageFns<EnhancedCpc> = {
  encode(_: EnhancedCpc, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnhancedCpc {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnhancedCpc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EnhancedCpc {
    return {};
  },

  toJSON(_: EnhancedCpc): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<EnhancedCpc>): EnhancedCpc {
    return EnhancedCpc.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<EnhancedCpc>): EnhancedCpc {
    const message = createBaseEnhancedCpc();
    return message;
  },
};

function createBaseManualCpa(): ManualCpa {
  return {};
}

export const ManualCpa: MessageFns<ManualCpa> = {
  encode(_: ManualCpa, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManualCpa {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManualCpa();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ManualCpa {
    return {};
  },

  toJSON(_: ManualCpa): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ManualCpa>): ManualCpa {
    return ManualCpa.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ManualCpa>): ManualCpa {
    const message = createBaseManualCpa();
    return message;
  },
};

function createBaseManualCpc(): ManualCpc {
  return { enhancedCpcEnabled: undefined };
}

export const ManualCpc: MessageFns<ManualCpc> = {
  encode(message: ManualCpc, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enhancedCpcEnabled !== undefined) {
      writer.uint32(16).bool(message.enhancedCpcEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManualCpc {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManualCpc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enhancedCpcEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ManualCpc {
    return {
      enhancedCpcEnabled: isSet(object.enhancedCpcEnabled) ? globalThis.Boolean(object.enhancedCpcEnabled) : undefined,
    };
  },

  toJSON(message: ManualCpc): unknown {
    const obj: any = {};
    if (message.enhancedCpcEnabled !== undefined) {
      obj.enhancedCpcEnabled = message.enhancedCpcEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<ManualCpc>): ManualCpc {
    return ManualCpc.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ManualCpc>): ManualCpc {
    const message = createBaseManualCpc();
    message.enhancedCpcEnabled = object.enhancedCpcEnabled ?? undefined;
    return message;
  },
};

function createBaseManualCpm(): ManualCpm {
  return {};
}

export const ManualCpm: MessageFns<ManualCpm> = {
  encode(_: ManualCpm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManualCpm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManualCpm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ManualCpm {
    return {};
  },

  toJSON(_: ManualCpm): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ManualCpm>): ManualCpm {
    return ManualCpm.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ManualCpm>): ManualCpm {
    const message = createBaseManualCpm();
    return message;
  },
};

function createBaseManualCpv(): ManualCpv {
  return {};
}

export const ManualCpv: MessageFns<ManualCpv> = {
  encode(_: ManualCpv, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManualCpv {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManualCpv();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ManualCpv {
    return {};
  },

  toJSON(_: ManualCpv): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ManualCpv>): ManualCpv {
    return ManualCpv.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ManualCpv>): ManualCpv {
    const message = createBaseManualCpv();
    return message;
  },
};

function createBaseMaximizeConversions(): MaximizeConversions {
  return { cpcBidCeilingMicros: Long.ZERO, cpcBidFloorMicros: Long.ZERO, targetCpaMicros: Long.ZERO };
}

export const MaximizeConversions: MessageFns<MaximizeConversions> = {
  encode(message: MaximizeConversions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.cpcBidCeilingMicros.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.cpcBidCeilingMicros.toString());
    }
    if (!message.cpcBidFloorMicros.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.cpcBidFloorMicros.toString());
    }
    if (!message.targetCpaMicros.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.targetCpaMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaximizeConversions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaximizeConversions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cpcBidFloorMicros = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.targetCpaMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaximizeConversions {
    return {
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : Long.ZERO,
      cpcBidFloorMicros: isSet(object.cpcBidFloorMicros) ? Long.fromValue(object.cpcBidFloorMicros) : Long.ZERO,
      targetCpaMicros: isSet(object.targetCpaMicros) ? Long.fromValue(object.targetCpaMicros) : Long.ZERO,
    };
  },

  toJSON(message: MaximizeConversions): unknown {
    const obj: any = {};
    if (!message.cpcBidCeilingMicros.equals(Long.ZERO)) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    if (!message.cpcBidFloorMicros.equals(Long.ZERO)) {
      obj.cpcBidFloorMicros = (message.cpcBidFloorMicros || Long.ZERO).toString();
    }
    if (!message.targetCpaMicros.equals(Long.ZERO)) {
      obj.targetCpaMicros = (message.targetCpaMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MaximizeConversions>): MaximizeConversions {
    return MaximizeConversions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaximizeConversions>): MaximizeConversions {
    const message = createBaseMaximizeConversions();
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : Long.ZERO;
    message.cpcBidFloorMicros = (object.cpcBidFloorMicros !== undefined && object.cpcBidFloorMicros !== null)
      ? Long.fromValue(object.cpcBidFloorMicros)
      : Long.ZERO;
    message.targetCpaMicros = (object.targetCpaMicros !== undefined && object.targetCpaMicros !== null)
      ? Long.fromValue(object.targetCpaMicros)
      : Long.ZERO;
    return message;
  },
};

function createBaseMaximizeConversionValue(): MaximizeConversionValue {
  return { targetRoas: 0, cpcBidCeilingMicros: Long.ZERO, cpcBidFloorMicros: Long.ZERO };
}

export const MaximizeConversionValue: MessageFns<MaximizeConversionValue> = {
  encode(message: MaximizeConversionValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetRoas !== 0) {
      writer.uint32(17).double(message.targetRoas);
    }
    if (!message.cpcBidCeilingMicros.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.cpcBidCeilingMicros.toString());
    }
    if (!message.cpcBidFloorMicros.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.cpcBidFloorMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaximizeConversionValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaximizeConversionValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 17) {
            break;
          }

          message.targetRoas = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cpcBidFloorMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaximizeConversionValue {
    return {
      targetRoas: isSet(object.targetRoas) ? globalThis.Number(object.targetRoas) : 0,
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : Long.ZERO,
      cpcBidFloorMicros: isSet(object.cpcBidFloorMicros) ? Long.fromValue(object.cpcBidFloorMicros) : Long.ZERO,
    };
  },

  toJSON(message: MaximizeConversionValue): unknown {
    const obj: any = {};
    if (message.targetRoas !== 0) {
      obj.targetRoas = message.targetRoas;
    }
    if (!message.cpcBidCeilingMicros.equals(Long.ZERO)) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    if (!message.cpcBidFloorMicros.equals(Long.ZERO)) {
      obj.cpcBidFloorMicros = (message.cpcBidFloorMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MaximizeConversionValue>): MaximizeConversionValue {
    return MaximizeConversionValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaximizeConversionValue>): MaximizeConversionValue {
    const message = createBaseMaximizeConversionValue();
    message.targetRoas = object.targetRoas ?? 0;
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : Long.ZERO;
    message.cpcBidFloorMicros = (object.cpcBidFloorMicros !== undefined && object.cpcBidFloorMicros !== null)
      ? Long.fromValue(object.cpcBidFloorMicros)
      : Long.ZERO;
    return message;
  },
};

function createBaseTargetCpa(): TargetCpa {
  return { targetCpaMicros: undefined, cpcBidCeilingMicros: undefined, cpcBidFloorMicros: undefined };
}

export const TargetCpa: MessageFns<TargetCpa> = {
  encode(message: TargetCpa, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetCpaMicros !== undefined) {
      writer.uint32(32).int64(message.targetCpaMicros.toString());
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      writer.uint32(40).int64(message.cpcBidCeilingMicros.toString());
    }
    if (message.cpcBidFloorMicros !== undefined) {
      writer.uint32(48).int64(message.cpcBidFloorMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetCpa {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetCpa();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 32) {
            break;
          }

          message.targetCpaMicros = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cpcBidFloorMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetCpa {
    return {
      targetCpaMicros: isSet(object.targetCpaMicros) ? Long.fromValue(object.targetCpaMicros) : undefined,
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : undefined,
      cpcBidFloorMicros: isSet(object.cpcBidFloorMicros) ? Long.fromValue(object.cpcBidFloorMicros) : undefined,
    };
  },

  toJSON(message: TargetCpa): unknown {
    const obj: any = {};
    if (message.targetCpaMicros !== undefined) {
      obj.targetCpaMicros = (message.targetCpaMicros || Long.ZERO).toString();
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    if (message.cpcBidFloorMicros !== undefined) {
      obj.cpcBidFloorMicros = (message.cpcBidFloorMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TargetCpa>): TargetCpa {
    return TargetCpa.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetCpa>): TargetCpa {
    const message = createBaseTargetCpa();
    message.targetCpaMicros = (object.targetCpaMicros !== undefined && object.targetCpaMicros !== null)
      ? Long.fromValue(object.targetCpaMicros)
      : undefined;
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : undefined;
    message.cpcBidFloorMicros = (object.cpcBidFloorMicros !== undefined && object.cpcBidFloorMicros !== null)
      ? Long.fromValue(object.cpcBidFloorMicros)
      : undefined;
    return message;
  },
};

function createBaseTargetCpm(): TargetCpm {
  return { targetFrequencyGoal: undefined };
}

export const TargetCpm: MessageFns<TargetCpm> = {
  encode(message: TargetCpm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetFrequencyGoal !== undefined) {
      TargetCpmTargetFrequencyGoal.encode(message.targetFrequencyGoal, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetCpm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetCpm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetFrequencyGoal = TargetCpmTargetFrequencyGoal.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetCpm {
    return {
      targetFrequencyGoal: isSet(object.targetFrequencyGoal)
        ? TargetCpmTargetFrequencyGoal.fromJSON(object.targetFrequencyGoal)
        : undefined,
    };
  },

  toJSON(message: TargetCpm): unknown {
    const obj: any = {};
    if (message.targetFrequencyGoal !== undefined) {
      obj.targetFrequencyGoal = TargetCpmTargetFrequencyGoal.toJSON(message.targetFrequencyGoal);
    }
    return obj;
  },

  create(base?: DeepPartial<TargetCpm>): TargetCpm {
    return TargetCpm.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetCpm>): TargetCpm {
    const message = createBaseTargetCpm();
    message.targetFrequencyGoal = (object.targetFrequencyGoal !== undefined && object.targetFrequencyGoal !== null)
      ? TargetCpmTargetFrequencyGoal.fromPartial(object.targetFrequencyGoal)
      : undefined;
    return message;
  },
};

function createBaseTargetCpmTargetFrequencyGoal(): TargetCpmTargetFrequencyGoal {
  return { targetCount: Long.ZERO, timeUnit: 0 };
}

export const TargetCpmTargetFrequencyGoal: MessageFns<TargetCpmTargetFrequencyGoal> = {
  encode(message: TargetCpmTargetFrequencyGoal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.targetCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.targetCount.toString());
    }
    if (message.timeUnit !== 0) {
      writer.uint32(16).int32(message.timeUnit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetCpmTargetFrequencyGoal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetCpmTargetFrequencyGoal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeUnit = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetCpmTargetFrequencyGoal {
    return {
      targetCount: isSet(object.targetCount) ? Long.fromValue(object.targetCount) : Long.ZERO,
      timeUnit: isSet(object.timeUnit)
        ? targetFrequencyTimeUnitEnum_TargetFrequencyTimeUnitFromJSON(object.timeUnit)
        : 0,
    };
  },

  toJSON(message: TargetCpmTargetFrequencyGoal): unknown {
    const obj: any = {};
    if (!message.targetCount.equals(Long.ZERO)) {
      obj.targetCount = (message.targetCount || Long.ZERO).toString();
    }
    if (message.timeUnit !== 0) {
      obj.timeUnit = targetFrequencyTimeUnitEnum_TargetFrequencyTimeUnitToJSON(message.timeUnit);
    }
    return obj;
  },

  create(base?: DeepPartial<TargetCpmTargetFrequencyGoal>): TargetCpmTargetFrequencyGoal {
    return TargetCpmTargetFrequencyGoal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetCpmTargetFrequencyGoal>): TargetCpmTargetFrequencyGoal {
    const message = createBaseTargetCpmTargetFrequencyGoal();
    message.targetCount = (object.targetCount !== undefined && object.targetCount !== null)
      ? Long.fromValue(object.targetCount)
      : Long.ZERO;
    message.timeUnit = object.timeUnit ?? 0;
    return message;
  },
};

function createBaseTargetImpressionShare(): TargetImpressionShare {
  return { location: 0, locationFractionMicros: undefined, cpcBidCeilingMicros: undefined };
}

export const TargetImpressionShare: MessageFns<TargetImpressionShare> = {
  encode(message: TargetImpressionShare, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== 0) {
      writer.uint32(8).int32(message.location);
    }
    if (message.locationFractionMicros !== undefined) {
      writer.uint32(32).int64(message.locationFractionMicros.toString());
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      writer.uint32(40).int64(message.cpcBidCeilingMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetImpressionShare {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetImpressionShare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.location = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.locationFractionMicros = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetImpressionShare {
    return {
      location: isSet(object.location)
        ? targetImpressionShareLocationEnum_TargetImpressionShareLocationFromJSON(object.location)
        : 0,
      locationFractionMicros: isSet(object.locationFractionMicros)
        ? Long.fromValue(object.locationFractionMicros)
        : undefined,
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : undefined,
    };
  },

  toJSON(message: TargetImpressionShare): unknown {
    const obj: any = {};
    if (message.location !== 0) {
      obj.location = targetImpressionShareLocationEnum_TargetImpressionShareLocationToJSON(message.location);
    }
    if (message.locationFractionMicros !== undefined) {
      obj.locationFractionMicros = (message.locationFractionMicros || Long.ZERO).toString();
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TargetImpressionShare>): TargetImpressionShare {
    return TargetImpressionShare.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetImpressionShare>): TargetImpressionShare {
    const message = createBaseTargetImpressionShare();
    message.location = object.location ?? 0;
    message.locationFractionMicros =
      (object.locationFractionMicros !== undefined && object.locationFractionMicros !== null)
        ? Long.fromValue(object.locationFractionMicros)
        : undefined;
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : undefined;
    return message;
  },
};

function createBaseTargetRoas(): TargetRoas {
  return { targetRoas: undefined, cpcBidCeilingMicros: undefined, cpcBidFloorMicros: undefined };
}

export const TargetRoas: MessageFns<TargetRoas> = {
  encode(message: TargetRoas, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetRoas !== undefined) {
      writer.uint32(33).double(message.targetRoas);
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      writer.uint32(40).int64(message.cpcBidCeilingMicros.toString());
    }
    if (message.cpcBidFloorMicros !== undefined) {
      writer.uint32(48).int64(message.cpcBidFloorMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetRoas {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetRoas();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 33) {
            break;
          }

          message.targetRoas = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cpcBidFloorMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetRoas {
    return {
      targetRoas: isSet(object.targetRoas) ? globalThis.Number(object.targetRoas) : undefined,
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : undefined,
      cpcBidFloorMicros: isSet(object.cpcBidFloorMicros) ? Long.fromValue(object.cpcBidFloorMicros) : undefined,
    };
  },

  toJSON(message: TargetRoas): unknown {
    const obj: any = {};
    if (message.targetRoas !== undefined) {
      obj.targetRoas = message.targetRoas;
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    if (message.cpcBidFloorMicros !== undefined) {
      obj.cpcBidFloorMicros = (message.cpcBidFloorMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TargetRoas>): TargetRoas {
    return TargetRoas.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetRoas>): TargetRoas {
    const message = createBaseTargetRoas();
    message.targetRoas = object.targetRoas ?? undefined;
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : undefined;
    message.cpcBidFloorMicros = (object.cpcBidFloorMicros !== undefined && object.cpcBidFloorMicros !== null)
      ? Long.fromValue(object.cpcBidFloorMicros)
      : undefined;
    return message;
  },
};

function createBaseTargetSpend(): TargetSpend {
  return { targetSpendMicros: undefined, cpcBidCeilingMicros: undefined };
}

export const TargetSpend: MessageFns<TargetSpend> = {
  encode(message: TargetSpend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetSpendMicros !== undefined) {
      writer.uint32(24).int64(message.targetSpendMicros.toString());
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      writer.uint32(32).int64(message.cpcBidCeilingMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetSpend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetSpend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.targetSpendMicros = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetSpend {
    return {
      targetSpendMicros: isSet(object.targetSpendMicros) ? Long.fromValue(object.targetSpendMicros) : undefined,
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : undefined,
    };
  },

  toJSON(message: TargetSpend): unknown {
    const obj: any = {};
    if (message.targetSpendMicros !== undefined) {
      obj.targetSpendMicros = (message.targetSpendMicros || Long.ZERO).toString();
    }
    if (message.cpcBidCeilingMicros !== undefined) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TargetSpend>): TargetSpend {
    return TargetSpend.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetSpend>): TargetSpend {
    const message = createBaseTargetSpend();
    message.targetSpendMicros = (object.targetSpendMicros !== undefined && object.targetSpendMicros !== null)
      ? Long.fromValue(object.targetSpendMicros)
      : undefined;
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : undefined;
    return message;
  },
};

function createBasePercentCpc(): PercentCpc {
  return { cpcBidCeilingMicros: undefined, enhancedCpcEnabled: undefined };
}

export const PercentCpc: MessageFns<PercentCpc> = {
  encode(message: PercentCpc, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpcBidCeilingMicros !== undefined) {
      writer.uint32(24).int64(message.cpcBidCeilingMicros.toString());
    }
    if (message.enhancedCpcEnabled !== undefined) {
      writer.uint32(32).bool(message.enhancedCpcEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PercentCpc {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePercentCpc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enhancedCpcEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PercentCpc {
    return {
      cpcBidCeilingMicros: isSet(object.cpcBidCeilingMicros) ? Long.fromValue(object.cpcBidCeilingMicros) : undefined,
      enhancedCpcEnabled: isSet(object.enhancedCpcEnabled) ? globalThis.Boolean(object.enhancedCpcEnabled) : undefined,
    };
  },

  toJSON(message: PercentCpc): unknown {
    const obj: any = {};
    if (message.cpcBidCeilingMicros !== undefined) {
      obj.cpcBidCeilingMicros = (message.cpcBidCeilingMicros || Long.ZERO).toString();
    }
    if (message.enhancedCpcEnabled !== undefined) {
      obj.enhancedCpcEnabled = message.enhancedCpcEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<PercentCpc>): PercentCpc {
    return PercentCpc.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PercentCpc>): PercentCpc {
    const message = createBasePercentCpc();
    message.cpcBidCeilingMicros = (object.cpcBidCeilingMicros !== undefined && object.cpcBidCeilingMicros !== null)
      ? Long.fromValue(object.cpcBidCeilingMicros)
      : undefined;
    message.enhancedCpcEnabled = object.enhancedCpcEnabled ?? undefined;
    return message;
  },
};

function createBaseFixedCpm(): FixedCpm {
  return { goal: 0, targetFrequencyInfo: undefined };
}

export const FixedCpm: MessageFns<FixedCpm> = {
  encode(message: FixedCpm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.goal !== 0) {
      writer.uint32(8).int32(message.goal);
    }
    if (message.targetFrequencyInfo !== undefined) {
      FixedCpmTargetFrequencyGoalInfo.encode(message.targetFrequencyInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FixedCpm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixedCpm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.goal = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetFrequencyInfo = FixedCpmTargetFrequencyGoalInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FixedCpm {
    return {
      goal: isSet(object.goal) ? fixedCpmGoalEnum_FixedCpmGoalFromJSON(object.goal) : 0,
      targetFrequencyInfo: isSet(object.targetFrequencyInfo)
        ? FixedCpmTargetFrequencyGoalInfo.fromJSON(object.targetFrequencyInfo)
        : undefined,
    };
  },

  toJSON(message: FixedCpm): unknown {
    const obj: any = {};
    if (message.goal !== 0) {
      obj.goal = fixedCpmGoalEnum_FixedCpmGoalToJSON(message.goal);
    }
    if (message.targetFrequencyInfo !== undefined) {
      obj.targetFrequencyInfo = FixedCpmTargetFrequencyGoalInfo.toJSON(message.targetFrequencyInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<FixedCpm>): FixedCpm {
    return FixedCpm.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FixedCpm>): FixedCpm {
    const message = createBaseFixedCpm();
    message.goal = object.goal ?? 0;
    message.targetFrequencyInfo = (object.targetFrequencyInfo !== undefined && object.targetFrequencyInfo !== null)
      ? FixedCpmTargetFrequencyGoalInfo.fromPartial(object.targetFrequencyInfo)
      : undefined;
    return message;
  },
};

function createBaseFixedCpmTargetFrequencyGoalInfo(): FixedCpmTargetFrequencyGoalInfo {
  return { targetCount: Long.ZERO, timeUnit: 0 };
}

export const FixedCpmTargetFrequencyGoalInfo: MessageFns<FixedCpmTargetFrequencyGoalInfo> = {
  encode(message: FixedCpmTargetFrequencyGoalInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.targetCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.targetCount.toString());
    }
    if (message.timeUnit !== 0) {
      writer.uint32(16).int32(message.timeUnit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FixedCpmTargetFrequencyGoalInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixedCpmTargetFrequencyGoalInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeUnit = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FixedCpmTargetFrequencyGoalInfo {
    return {
      targetCount: isSet(object.targetCount) ? Long.fromValue(object.targetCount) : Long.ZERO,
      timeUnit: isSet(object.timeUnit)
        ? fixedCpmTargetFrequencyTimeUnitEnum_FixedCpmTargetFrequencyTimeUnitFromJSON(object.timeUnit)
        : 0,
    };
  },

  toJSON(message: FixedCpmTargetFrequencyGoalInfo): unknown {
    const obj: any = {};
    if (!message.targetCount.equals(Long.ZERO)) {
      obj.targetCount = (message.targetCount || Long.ZERO).toString();
    }
    if (message.timeUnit !== 0) {
      obj.timeUnit = fixedCpmTargetFrequencyTimeUnitEnum_FixedCpmTargetFrequencyTimeUnitToJSON(message.timeUnit);
    }
    return obj;
  },

  create(base?: DeepPartial<FixedCpmTargetFrequencyGoalInfo>): FixedCpmTargetFrequencyGoalInfo {
    return FixedCpmTargetFrequencyGoalInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FixedCpmTargetFrequencyGoalInfo>): FixedCpmTargetFrequencyGoalInfo {
    const message = createBaseFixedCpmTargetFrequencyGoalInfo();
    message.targetCount = (object.targetCount !== undefined && object.targetCount !== null)
      ? Long.fromValue(object.targetCount)
      : Long.ZERO;
    message.timeUnit = object.timeUnit ?? 0;
    return message;
  },
};

function createBaseTargetCpv(): TargetCpv {
  return {};
}

export const TargetCpv: MessageFns<TargetCpv> = {
  encode(_: TargetCpv, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetCpv {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetCpv();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TargetCpv {
    return {};
  },

  toJSON(_: TargetCpv): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<TargetCpv>): TargetCpv {
    return TargetCpv.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<TargetCpv>): TargetCpv {
    const message = createBaseTargetCpv();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
