// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v17/services/audience_insights_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  AgeRangeInfo,
  GenderInfo,
  IncomeRangeInfo,
  LocationInfo,
  ParentalStatusInfo,
  UserInterestInfo,
  YouTubeChannelInfo,
} from "../common/criteria.js";
import { DateRange } from "../common/dates.js";
import {
  AudienceInsightsDimensionEnum_AudienceInsightsDimension,
  audienceInsightsDimensionEnum_AudienceInsightsDimensionFromJSON,
  audienceInsightsDimensionEnum_AudienceInsightsDimensionToJSON,
} from "../enums/audience_insights_dimension.js";

export const protobufPackage = "google.ads.googleads.v17.services";

/**
 * Request message for
 * [AudienceInsightsService.GenerateInsightsFinderReport][google.ads.googleads.v17.services.AudienceInsightsService.GenerateInsightsFinderReport].
 */
export interface GenerateInsightsFinderReportRequest {
  /** Required. The ID of the customer. */
  customerId: string;
  /**
   * Required. A baseline audience for this report, typically all people in a
   * region.
   */
  baselineAudience:
    | BasicInsightsAudience
    | undefined;
  /**
   * Required. The specific audience of interest for this report.  The insights
   * in the report will be based on attributes more prevalent in this audience
   * than in the report's baseline audience.
   */
  specificAudience:
    | BasicInsightsAudience
    | undefined;
  /** The name of the customer being planned for.  This is a user-defined value. */
  customerInsightsGroup: string;
}

/**
 * The response message for
 * [AudienceInsightsService.GenerateInsightsFinderReport][google.ads.googleads.v17.services.AudienceInsightsService.GenerateInsightsFinderReport],
 * containing the shareable URL for the report.
 */
export interface GenerateInsightsFinderReportResponse {
  /**
   * An HTTPS URL providing a deep link into the Insights Finder UI with the
   * report inputs filled in according to the request.
   */
  savedReportUrl: string;
}

/**
 * Request message for
 * [AudienceInsightsService.GenerateAudienceCompositionInsights][google.ads.googleads.v17.services.AudienceInsightsService.GenerateAudienceCompositionInsights].
 */
export interface GenerateAudienceCompositionInsightsRequest {
  /** Required. The ID of the customer. */
  customerId: string;
  /** Required. The audience of interest for which insights are being requested. */
  audience:
    | InsightsAudience
    | undefined;
  /**
   * The baseline audience to which the audience of interest is being
   * compared.
   */
  baselineAudience:
    | InsightsAudience
    | undefined;
  /**
   * The one-month range of historical data to use for insights, in the format
   * "yyyy-mm". If unset, insights will be returned for the last thirty days of
   * data.
   */
  dataMonth: string;
  /**
   * Required. The audience dimensions for which composition insights should be
   * returned.
   */
  dimensions: AudienceInsightsDimensionEnum_AudienceInsightsDimension[];
  /** The name of the customer being planned for.  This is a user-defined value. */
  customerInsightsGroup: string;
}

/**
 * Response message for
 * [AudienceInsightsService.GenerateAudienceCompositionInsights][google.ads.googleads.v17.services.AudienceInsightsService.GenerateAudienceCompositionInsights].
 */
export interface GenerateAudienceCompositionInsightsResponse {
  /**
   * The contents of the insights report, organized into sections.
   * Each section is associated with one of the AudienceInsightsDimension values
   * in the request. There may be more than one section per dimension.
   */
  sections: AudienceCompositionSection[];
}

/**
 * Request message for
 * [AudienceInsightsService.GenerateSuggestedTargetingInsights][google.ads.googleads.v17.services.AudienceInsightsService.GenerateSuggestedTargetingInsights].
 */
export interface GenerateSuggestedTargetingInsightsRequest {
  /** Required. The ID of the customer. */
  customerId: string;
  /** Required. The audience of interest for which insights are being requested. */
  audience:
    | InsightsAudience
    | undefined;
  /**
   * Optional. The baseline audience.  The default, if unspecified, is all
   * people in the same country as the audience of interest.
   */
  baselineAudience:
    | InsightsAudience
    | undefined;
  /**
   * Optional. The one-month range of historical data to use for insights, in
   * the format "yyyy-mm". If unset, insights will be returned for the last
   * thirty days of data.
   */
  dataMonth: string;
  /**
   * Optional. The name of the customer being planned for.  This is a
   * user-defined value.
   */
  customerInsightsGroup: string;
}

/**
 * Response message for
 * [AudienceInsightsService.GenerateSuggestedTargetingInsights][google.ads.googleads.v17.services.AudienceInsightsService.GenerateSuggestedTargetingInsights].
 */
export interface GenerateSuggestedTargetingInsightsResponse {
  /** Suggested insights for targetable audiences. */
  suggestions: TargetingSuggestionMetrics[];
}

/** A suggested targetable audience relevant to the requested audience. */
export interface TargetingSuggestionMetrics {
  /**
   * Suggested location targeting.  These attributes all have dimension
   * GEO_TARGET_COUNTRY or SUB_COUNTRY_LOCATION
   */
  locations: AudienceInsightsAttributeMetadata[];
  /** Suggested age targeting; may be empty indicating no age targeting. */
  ageRanges: AgeRangeInfo[];
  /**
   * Suggested gender targeting.  If present, this attribute has dimension
   * GENDER.
   */
  gender:
    | GenderInfo
    | undefined;
  /**
   * Suggested audience segments to target.  These attributes all have dimension
   * AFFINITY_USER_INTEREST or IN_MARKET_USER_INTEREST
   */
  userInterests: AudienceInsightsAttributeMetadata[];
  /**
   * The fraction (from 0 to 1 inclusive) of the requested audience that can be
   * reached using the suggested targeting.
   */
  coverage: number;
  /**
   * The ratio of coverage to the coverage of the baseline audience or zero if
   * this ratio is undefined or is not meaningful.
   */
  index: number;
  /**
   * The approximate estimated number of people that can be reached on YouTube
   * using this targeting.
   */
  potentialYoutubeReach: Long;
}

/**
 * Request message for
 * [AudienceInsightsService.ListAudienceInsightsAttributes][google.ads.googleads.v17.services.AudienceInsightsService.ListAudienceInsightsAttributes].
 */
export interface ListAudienceInsightsAttributesRequest {
  /** Required. The ID of the customer. */
  customerId: string;
  /** Required. The types of attributes to be returned. */
  dimensions: AudienceInsightsDimensionEnum_AudienceInsightsDimension[];
  /**
   * Required. A free text query.  If the requested dimensions include
   * Attributes CATEGORY or KNOWLEDGE_GRAPH, then the attributes returned for
   * those dimensions will match or be related to this string.  For other
   * dimensions, this field is ignored and all available attributes are
   * returned.
   */
  queryText: string;
  /** The name of the customer being planned for.  This is a user-defined value. */
  customerInsightsGroup: string;
  /**
   * If SUB_COUNTRY_LOCATION attributes are one of the requested dimensions and
   * this field is present, then the SUB_COUNTRY_LOCATION attributes returned
   * will be located in these countries. If this field is absent, then location
   * attributes are not filtered by country. Setting this field when
   * SUB_COUNTRY_LOCATION attributes are not requested will return an error.
   */
  locationCountryFilters: LocationInfo[];
  /**
   * If present, potential YouTube reach estimates within the specified market
   * will be returned for attributes for which they are available.  Reach is
   * only available for the AGE_RANGE, GENDER, AFFINITY_USER_INTEREST and
   * IN_MARKET_USER_INTEREST dimensions, and may not be available for every
   * attribute of those dimensions in every market.
   */
  youtubeReachLocation: LocationInfo | undefined;
}

/**
 * Response message for
 * [AudienceInsightsService.ListAudienceInsightsAttributes][google.ads.googleads.v17.services.AudienceInsightsService.ListAudienceInsightsAttributes].
 */
export interface ListAudienceInsightsAttributesResponse {
  /** The attributes matching the search query. */
  attributes: AudienceInsightsAttributeMetadata[];
}

/**
 * Request message for
 * [AudienceInsightsService.ListInsightsEligibleDates][google.ads.googleads.v17.services.AudienceInsightsService.ListInsightsEligibleDates].
 */
export interface ListInsightsEligibleDatesRequest {
}

/**
 * Response message for
 * [AudienceInsightsService.ListInsightsEligibleDates][google.ads.googleads.v17.services.AudienceInsightsService.ListInsightsEligibleDates].
 */
export interface ListInsightsEligibleDatesResponse {
  /**
   * The months for which AudienceInsights data is currently
   * available, each represented as a string in the form "YYYY-MM".
   */
  dataMonths: string[];
  /**
   * The actual dates covered by the "last 30 days" date range that will be used
   * implicitly for
   * [AudienceInsightsService.GenerateAudienceCompositionInsights][google.ads.googleads.v17.services.AudienceInsightsService.GenerateAudienceCompositionInsights]
   * requests that have no data_month set.
   */
  lastThirtyDays: DateRange | undefined;
}

/**
 * Request message for
 * [AudienceInsightsService.GenerateAudienceOverlapInsights][google.ads.googleads.v17.services.AudienceInsightsService.GenerateAudienceOverlapInsights].
 */
export interface GenerateAudienceOverlapInsightsRequest {
  /** Required. The ID of the customer. */
  customerId: string;
  /**
   * Required. The country in which to calculate the sizes and overlaps of
   * audiences.
   */
  countryLocation:
    | LocationInfo
    | undefined;
  /**
   * Required. The audience attribute that should be intersected with all other
   * eligible audiences.  This must be an Affinity or In-Market UserInterest, an
   * AgeRange or a Gender.
   */
  primaryAttribute:
    | AudienceInsightsAttribute
    | undefined;
  /**
   * Required. The types of attributes of which to calculate the overlap with
   * the primary_attribute. The values must be a subset of
   * AFFINITY_USER_INTEREST, IN_MARKET_USER_INTEREST, AGE_RANGE and GENDER.
   */
  dimensions: AudienceInsightsDimensionEnum_AudienceInsightsDimension[];
  /** The name of the customer being planned for.  This is a user-defined value. */
  customerInsightsGroup: string;
}

/**
 * Response message for
 * [AudienceInsightsService.GenerateAudienceOverlapInsights][google.ads.googleads.v17.services.AudienceInsightsService.GenerateAudienceOverlapInsights].
 */
export interface GenerateAudienceOverlapInsightsResponse {
  /** Metadata for the primary attribute, including potential YouTube reach. */
  primaryAttributeMetadata:
    | AudienceInsightsAttributeMetadata
    | undefined;
  /**
   * Lists of attributes and their overlap with the primary attribute, one list
   * per requested dimension.
   */
  dimensionResults: DimensionOverlapResult[];
}

/**
 * A list of audience attributes of a single dimension, including their overlap
 * with a primary attribute, returned as part of a
 * [GenerateAudienceOverlapInsightsResponse][google.ads.googleads.v17.services.GenerateAudienceOverlapInsightsResponse].
 */
export interface DimensionOverlapResult {
  /** The dimension of all the attributes in this section. */
  dimension: AudienceInsightsDimensionEnum_AudienceInsightsDimension;
  /** The attributes and their overlap with the primary attribute. */
  items: AudienceOverlapItem[];
}

/**
 * An audience attribute, with metadata including the overlap between this
 * attribute's potential YouTube reach and that of a primary attribute.
 */
export interface AudienceOverlapItem {
  /** The attribute and its metadata, including potential YouTube reach. */
  attributeMetadata:
    | AudienceInsightsAttributeMetadata
    | undefined;
  /**
   * The estimated size of the intersection of this audience attribute with the
   * primary attribute, that is, the number of reachable YouTube users who match
   * BOTH the primary attribute and this one.
   */
  potentialYoutubeReachIntersection: Long;
}

/**
 * An audience attribute that can be used to request insights about the
 * audience.
 */
export interface AudienceInsightsAttribute {
  /** An audience attribute defined by an age range. */
  ageRange?:
    | AgeRangeInfo
    | undefined;
  /** An audience attribute defined by a gender. */
  gender?:
    | GenderInfo
    | undefined;
  /** An audience attribute defined by a geographic location. */
  location?:
    | LocationInfo
    | undefined;
  /** An Affinity or In-Market audience. */
  userInterest?:
    | UserInterestInfo
    | undefined;
  /**
   * An audience attribute defined by interest in a topic represented by a
   * Knowledge Graph entity.
   */
  entity?:
    | AudienceInsightsEntity
    | undefined;
  /**
   * An audience attribute defined by interest in a Product & Service
   * category.
   */
  category?:
    | AudienceInsightsCategory
    | undefined;
  /** A YouTube Dynamic Lineup */
  dynamicLineup?:
    | AudienceInsightsDynamicLineup
    | undefined;
  /** A Parental Status value (parent, or not a parent). */
  parentalStatus?:
    | ParentalStatusInfo
    | undefined;
  /** A household income percentile range. */
  incomeRange?:
    | IncomeRangeInfo
    | undefined;
  /** A YouTube channel. */
  youtubeChannel?: YouTubeChannelInfo | undefined;
}

/** An entity or category representing a topic that defines an audience. */
export interface AudienceInsightsTopic {
  /** A Knowledge Graph entity */
  entity?:
    | AudienceInsightsEntity
    | undefined;
  /** A Product & Service category */
  category?: AudienceInsightsCategory | undefined;
}

/** A Knowledge Graph entity, represented by its machine id. */
export interface AudienceInsightsEntity {
  /** Required. The machine id (mid) of the Knowledge Graph entity. */
  knowledgeGraphMachineId: string;
}

/** A Product and Service category. */
export interface AudienceInsightsCategory {
  /** Required. The criterion id of the category. */
  categoryId: string;
}

/** A YouTube Dynamic Lineup. */
export interface AudienceInsightsDynamicLineup {
  /** Required. The numeric ID of the dynamic lineup. */
  dynamicLineupId: string;
}

/** A description of an audience used for requesting insights. */
export interface BasicInsightsAudience {
  /** Required. The countries for this audience. */
  countryLocation: LocationInfo[];
  /**
   * Sub-country geographic location attributes.  If present, each of these
   * must be contained in one of the countries in this audience.
   */
  subCountryLocations: LocationInfo[];
  /**
   * Gender for the audience.  If absent, the audience does not restrict by
   * gender.
   */
  gender:
    | GenderInfo
    | undefined;
  /**
   * Age ranges for the audience.  If absent, the audience represents all people
   * over 18 that match the other attributes.
   */
  ageRanges: AgeRangeInfo[];
  /**
   * User interests defining this audience.  Affinity and In-Market audiences
   * are supported.
   */
  userInterests: UserInterestInfo[];
  /**
   * Topics, represented by Knowledge Graph entities and/or Product & Service
   * categories, that this audience is interested in.
   */
  topics: AudienceInsightsTopic[];
}

/**
 * An audience attribute, with metadata about it, returned in response to a
 * search.
 */
export interface AudienceInsightsAttributeMetadata {
  /** The type of the attribute. */
  dimension: AudienceInsightsDimensionEnum_AudienceInsightsDimension;
  /** The attribute itself. */
  attribute:
    | AudienceInsightsAttribute
    | undefined;
  /** The human-readable name of the attribute. */
  displayName: string;
  /**
   * A string that supplements the display_name to identify the attribute.
   * If the dimension is TOPIC, this is a brief description of the
   * Knowledge Graph entity, such as "American singer-songwriter".
   * If the dimension is CATEGORY, this is the complete path to the category in
   * The Product & Service taxonomy, for example
   * "/Apparel/Clothing/Outerwear".
   */
  displayInfo: string;
  /**
   * An estimate of the number of reachable YouTube users matching this
   * attribute in the requested location, or zero if that information is not
   * available for this attribute.  Only populated in
   * GenerateAudienceOverlapInsightsResponses and in
   * ListAudienceInsightsAttributesResponses when youtube_reach_location is
   * present in the request.
   */
  potentialYoutubeReach: Long;
  /** Special metadata for a YouTube channel. */
  youtubeChannelMetadata?:
    | YouTubeChannelAttributeMetadata
    | undefined;
  /** Special metadata for a YouTube Dynamic Lineup. */
  dynamicAttributeMetadata?:
    | DynamicLineupAttributeMetadata
    | undefined;
  /** Special metadata for a Location. */
  locationAttributeMetadata?: LocationAttributeMetadata | undefined;
}

/** Metadata associated with a YouTube channel attribute. */
export interface YouTubeChannelAttributeMetadata {
  /** The approximate number of subscribers to the YouTube channel. */
  subscriberCount: Long;
}

/** Metadata associated with a Dynamic Lineup attribute. */
export interface DynamicLineupAttributeMetadata {
  /** The national market associated with the lineup. */
  inventoryCountry:
    | LocationInfo
    | undefined;
  /** The median number of impressions per month on this lineup. */
  medianMonthlyInventory?:
    | Long
    | undefined;
  /** The lower end of a range containing the number of channels in the lineup. */
  channelCountLowerBound?:
    | Long
    | undefined;
  /** The upper end of a range containing the number of channels in the lineup. */
  channelCountUpperBound?:
    | Long
    | undefined;
  /** Examples of channels that are included in the lineup. */
  sampleChannels: DynamicLineupAttributeMetadata_SampleChannel[];
}

/** A YouTube channel returned as an example of the content in a lineup. */
export interface DynamicLineupAttributeMetadata_SampleChannel {
  /** A YouTube channel. */
  youtubeChannel:
    | YouTubeChannelInfo
    | undefined;
  /** The name of the sample channel. */
  displayName: string;
  /** Metadata for the sample channel. */
  youtubeChannelMetadata: YouTubeChannelAttributeMetadata | undefined;
}

/** Metadata associated with a Location attribute. */
export interface LocationAttributeMetadata {
  /** The country location of the sub country location. */
  countryLocation: LocationInfo | undefined;
}

/**
 * A set of users, defined by various characteristics, for which insights can
 * be requested in AudienceInsightsService.
 */
export interface InsightsAudience {
  /** Required. The countries for the audience. */
  countryLocations: LocationInfo[];
  /**
   * Sub-country geographic location attributes.  If present, each of these
   * must be contained in one of the countries in this audience.  If absent, the
   * audience is geographically to the country_locations and no further.
   */
  subCountryLocations: LocationInfo[];
  /**
   * Gender for the audience.  If absent, the audience does not restrict by
   * gender.
   */
  gender:
    | GenderInfo
    | undefined;
  /**
   * Age ranges for the audience.  If absent, the audience represents all people
   * over 18 that match the other attributes.
   */
  ageRanges: AgeRangeInfo[];
  /**
   * Parental status for the audience.  If absent, the audience does not
   * restrict by parental status.
   */
  parentalStatus:
    | ParentalStatusInfo
    | undefined;
  /**
   * Household income percentile ranges for the audience.  If absent, the
   * audience does not restrict by household income range.
   */
  incomeRanges: IncomeRangeInfo[];
  /** Dynamic lineups representing the YouTube content viewed by the audience. */
  dynamicLineups: AudienceInsightsDynamicLineup[];
  /**
   * A combination of entity, category and user interest attributes defining the
   * audience. The combination has a logical AND-of-ORs structure: Attributes
   * within each InsightsAudienceAttributeGroup are combined with OR, and
   * the combinations themselves are combined together with AND.  For example,
   * the expression (Entity OR Affinity) AND (In-Market OR Category) can be
   * formed using two InsightsAudienceAttributeGroups with two Attributes
   * each.
   */
  topicAudienceCombinations: InsightsAudienceAttributeGroup[];
}

/** A list of AudienceInsightsAttributes. */
export interface InsightsAudienceAttributeGroup {
  /**
   * Required. A collection of audience attributes to be combined with logical
   * OR. Attributes need not all be the same dimension.  Only Knowledge Graph
   * entities, Product & Service Categories, and Affinity and In-Market
   * audiences are supported in this context.
   */
  attributes: AudienceInsightsAttribute[];
}

/**
 * A collection of related attributes of the same type in an audience
 * composition insights report.
 */
export interface AudienceCompositionSection {
  /** The type of the attributes in this section. */
  dimension: AudienceInsightsDimensionEnum_AudienceInsightsDimension;
  /**
   * The most relevant segments for this audience.  If dimension is GENDER,
   * AGE_RANGE or PARENTAL_STATUS, then this list of attributes is exhaustive.
   */
  topAttributes: AudienceCompositionAttribute[];
  /**
   * Additional attributes for this audience, grouped into clusters.  Only
   * populated if dimension is YOUTUBE_CHANNEL.
   */
  clusteredAttributes: AudienceCompositionAttributeCluster[];
}

/**
 * A collection of related attributes, with metadata and metrics, in an audience
 * composition insights report.
 */
export interface AudienceCompositionAttributeCluster {
  /** The name of this cluster of attributes */
  clusterDisplayName: string;
  /**
   * If the dimension associated with this cluster is YOUTUBE_CHANNEL, then
   * cluster_metrics are metrics associated with the cluster as a whole.
   * For other dimensions, this field is unset.
   */
  clusterMetrics:
    | AudienceCompositionMetrics
    | undefined;
  /**
   * The individual attributes that make up this cluster, with metadata and
   * metrics.
   */
  attributes: AudienceCompositionAttribute[];
}

/**
 * The share and index metrics associated with an attribute in an audience
 * composition insights report.
 */
export interface AudienceCompositionMetrics {
  /**
   * The fraction (from 0 to 1 inclusive) of the baseline audience that match
   * the attribute.
   */
  baselineAudienceShare: number;
  /**
   * The fraction (from 0 to 1 inclusive) of the specific audience that match
   * the attribute.
   */
  audienceShare: number;
  /**
   * The ratio of audience_share to baseline_audience_share, or zero if this
   * ratio is undefined or is not meaningful.
   */
  index: number;
  /** A relevance score from 0 to 1 inclusive. */
  score: number;
}

/** An audience attribute with metadata and metrics. */
export interface AudienceCompositionAttribute {
  /** The attribute with its metadata. */
  attributeMetadata:
    | AudienceInsightsAttributeMetadata
    | undefined;
  /** Share and index metrics for the attribute. */
  metrics: AudienceCompositionMetrics | undefined;
}

function createBaseGenerateInsightsFinderReportRequest(): GenerateInsightsFinderReportRequest {
  return { customerId: "", baselineAudience: undefined, specificAudience: undefined, customerInsightsGroup: "" };
}

export const GenerateInsightsFinderReportRequest: MessageFns<GenerateInsightsFinderReportRequest> = {
  encode(message: GenerateInsightsFinderReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.baselineAudience !== undefined) {
      BasicInsightsAudience.encode(message.baselineAudience, writer.uint32(18).fork()).join();
    }
    if (message.specificAudience !== undefined) {
      BasicInsightsAudience.encode(message.specificAudience, writer.uint32(26).fork()).join();
    }
    if (message.customerInsightsGroup !== "") {
      writer.uint32(34).string(message.customerInsightsGroup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateInsightsFinderReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateInsightsFinderReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.baselineAudience = BasicInsightsAudience.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.specificAudience = BasicInsightsAudience.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.customerInsightsGroup = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateInsightsFinderReportRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      baselineAudience: isSet(object.baselineAudience)
        ? BasicInsightsAudience.fromJSON(object.baselineAudience)
        : undefined,
      specificAudience: isSet(object.specificAudience)
        ? BasicInsightsAudience.fromJSON(object.specificAudience)
        : undefined,
      customerInsightsGroup: isSet(object.customerInsightsGroup) ? globalThis.String(object.customerInsightsGroup) : "",
    };
  },

  toJSON(message: GenerateInsightsFinderReportRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.baselineAudience !== undefined) {
      obj.baselineAudience = BasicInsightsAudience.toJSON(message.baselineAudience);
    }
    if (message.specificAudience !== undefined) {
      obj.specificAudience = BasicInsightsAudience.toJSON(message.specificAudience);
    }
    if (message.customerInsightsGroup !== "") {
      obj.customerInsightsGroup = message.customerInsightsGroup;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateInsightsFinderReportRequest>): GenerateInsightsFinderReportRequest {
    return GenerateInsightsFinderReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateInsightsFinderReportRequest>): GenerateInsightsFinderReportRequest {
    const message = createBaseGenerateInsightsFinderReportRequest();
    message.customerId = object.customerId ?? "";
    message.baselineAudience = (object.baselineAudience !== undefined && object.baselineAudience !== null)
      ? BasicInsightsAudience.fromPartial(object.baselineAudience)
      : undefined;
    message.specificAudience = (object.specificAudience !== undefined && object.specificAudience !== null)
      ? BasicInsightsAudience.fromPartial(object.specificAudience)
      : undefined;
    message.customerInsightsGroup = object.customerInsightsGroup ?? "";
    return message;
  },
};

function createBaseGenerateInsightsFinderReportResponse(): GenerateInsightsFinderReportResponse {
  return { savedReportUrl: "" };
}

export const GenerateInsightsFinderReportResponse: MessageFns<GenerateInsightsFinderReportResponse> = {
  encode(message: GenerateInsightsFinderReportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.savedReportUrl !== "") {
      writer.uint32(10).string(message.savedReportUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateInsightsFinderReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateInsightsFinderReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.savedReportUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateInsightsFinderReportResponse {
    return { savedReportUrl: isSet(object.savedReportUrl) ? globalThis.String(object.savedReportUrl) : "" };
  },

  toJSON(message: GenerateInsightsFinderReportResponse): unknown {
    const obj: any = {};
    if (message.savedReportUrl !== "") {
      obj.savedReportUrl = message.savedReportUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateInsightsFinderReportResponse>): GenerateInsightsFinderReportResponse {
    return GenerateInsightsFinderReportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateInsightsFinderReportResponse>): GenerateInsightsFinderReportResponse {
    const message = createBaseGenerateInsightsFinderReportResponse();
    message.savedReportUrl = object.savedReportUrl ?? "";
    return message;
  },
};

function createBaseGenerateAudienceCompositionInsightsRequest(): GenerateAudienceCompositionInsightsRequest {
  return {
    customerId: "",
    audience: undefined,
    baselineAudience: undefined,
    dataMonth: "",
    dimensions: [],
    customerInsightsGroup: "",
  };
}

export const GenerateAudienceCompositionInsightsRequest: MessageFns<GenerateAudienceCompositionInsightsRequest> = {
  encode(message: GenerateAudienceCompositionInsightsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.audience !== undefined) {
      InsightsAudience.encode(message.audience, writer.uint32(18).fork()).join();
    }
    if (message.baselineAudience !== undefined) {
      InsightsAudience.encode(message.baselineAudience, writer.uint32(50).fork()).join();
    }
    if (message.dataMonth !== "") {
      writer.uint32(26).string(message.dataMonth);
    }
    writer.uint32(34).fork();
    for (const v of message.dimensions) {
      writer.int32(v);
    }
    writer.join();
    if (message.customerInsightsGroup !== "") {
      writer.uint32(42).string(message.customerInsightsGroup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateAudienceCompositionInsightsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateAudienceCompositionInsightsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audience = InsightsAudience.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.baselineAudience = InsightsAudience.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dataMonth = reader.string();
          continue;
        case 4:
          if (tag === 32) {
            message.dimensions.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dimensions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customerInsightsGroup = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateAudienceCompositionInsightsRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      audience: isSet(object.audience) ? InsightsAudience.fromJSON(object.audience) : undefined,
      baselineAudience: isSet(object.baselineAudience) ? InsightsAudience.fromJSON(object.baselineAudience) : undefined,
      dataMonth: isSet(object.dataMonth) ? globalThis.String(object.dataMonth) : "",
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => audienceInsightsDimensionEnum_AudienceInsightsDimensionFromJSON(e))
        : [],
      customerInsightsGroup: isSet(object.customerInsightsGroup) ? globalThis.String(object.customerInsightsGroup) : "",
    };
  },

  toJSON(message: GenerateAudienceCompositionInsightsRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.audience !== undefined) {
      obj.audience = InsightsAudience.toJSON(message.audience);
    }
    if (message.baselineAudience !== undefined) {
      obj.baselineAudience = InsightsAudience.toJSON(message.baselineAudience);
    }
    if (message.dataMonth !== "") {
      obj.dataMonth = message.dataMonth;
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => audienceInsightsDimensionEnum_AudienceInsightsDimensionToJSON(e));
    }
    if (message.customerInsightsGroup !== "") {
      obj.customerInsightsGroup = message.customerInsightsGroup;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateAudienceCompositionInsightsRequest>): GenerateAudienceCompositionInsightsRequest {
    return GenerateAudienceCompositionInsightsRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenerateAudienceCompositionInsightsRequest>,
  ): GenerateAudienceCompositionInsightsRequest {
    const message = createBaseGenerateAudienceCompositionInsightsRequest();
    message.customerId = object.customerId ?? "";
    message.audience = (object.audience !== undefined && object.audience !== null)
      ? InsightsAudience.fromPartial(object.audience)
      : undefined;
    message.baselineAudience = (object.baselineAudience !== undefined && object.baselineAudience !== null)
      ? InsightsAudience.fromPartial(object.baselineAudience)
      : undefined;
    message.dataMonth = object.dataMonth ?? "";
    message.dimensions = object.dimensions?.map((e) => e) || [];
    message.customerInsightsGroup = object.customerInsightsGroup ?? "";
    return message;
  },
};

function createBaseGenerateAudienceCompositionInsightsResponse(): GenerateAudienceCompositionInsightsResponse {
  return { sections: [] };
}

export const GenerateAudienceCompositionInsightsResponse: MessageFns<GenerateAudienceCompositionInsightsResponse> = {
  encode(
    message: GenerateAudienceCompositionInsightsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.sections) {
      AudienceCompositionSection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateAudienceCompositionInsightsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateAudienceCompositionInsightsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sections.push(AudienceCompositionSection.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateAudienceCompositionInsightsResponse {
    return {
      sections: globalThis.Array.isArray(object?.sections)
        ? object.sections.map((e: any) => AudienceCompositionSection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateAudienceCompositionInsightsResponse): unknown {
    const obj: any = {};
    if (message.sections?.length) {
      obj.sections = message.sections.map((e) => AudienceCompositionSection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateAudienceCompositionInsightsResponse>): GenerateAudienceCompositionInsightsResponse {
    return GenerateAudienceCompositionInsightsResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenerateAudienceCompositionInsightsResponse>,
  ): GenerateAudienceCompositionInsightsResponse {
    const message = createBaseGenerateAudienceCompositionInsightsResponse();
    message.sections = object.sections?.map((e) => AudienceCompositionSection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateSuggestedTargetingInsightsRequest(): GenerateSuggestedTargetingInsightsRequest {
  return { customerId: "", audience: undefined, baselineAudience: undefined, dataMonth: "", customerInsightsGroup: "" };
}

export const GenerateSuggestedTargetingInsightsRequest: MessageFns<GenerateSuggestedTargetingInsightsRequest> = {
  encode(message: GenerateSuggestedTargetingInsightsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.audience !== undefined) {
      InsightsAudience.encode(message.audience, writer.uint32(18).fork()).join();
    }
    if (message.baselineAudience !== undefined) {
      InsightsAudience.encode(message.baselineAudience, writer.uint32(26).fork()).join();
    }
    if (message.dataMonth !== "") {
      writer.uint32(34).string(message.dataMonth);
    }
    if (message.customerInsightsGroup !== "") {
      writer.uint32(42).string(message.customerInsightsGroup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateSuggestedTargetingInsightsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateSuggestedTargetingInsightsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audience = InsightsAudience.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.baselineAudience = InsightsAudience.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dataMonth = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customerInsightsGroup = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateSuggestedTargetingInsightsRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      audience: isSet(object.audience) ? InsightsAudience.fromJSON(object.audience) : undefined,
      baselineAudience: isSet(object.baselineAudience) ? InsightsAudience.fromJSON(object.baselineAudience) : undefined,
      dataMonth: isSet(object.dataMonth) ? globalThis.String(object.dataMonth) : "",
      customerInsightsGroup: isSet(object.customerInsightsGroup) ? globalThis.String(object.customerInsightsGroup) : "",
    };
  },

  toJSON(message: GenerateSuggestedTargetingInsightsRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.audience !== undefined) {
      obj.audience = InsightsAudience.toJSON(message.audience);
    }
    if (message.baselineAudience !== undefined) {
      obj.baselineAudience = InsightsAudience.toJSON(message.baselineAudience);
    }
    if (message.dataMonth !== "") {
      obj.dataMonth = message.dataMonth;
    }
    if (message.customerInsightsGroup !== "") {
      obj.customerInsightsGroup = message.customerInsightsGroup;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateSuggestedTargetingInsightsRequest>): GenerateSuggestedTargetingInsightsRequest {
    return GenerateSuggestedTargetingInsightsRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenerateSuggestedTargetingInsightsRequest>,
  ): GenerateSuggestedTargetingInsightsRequest {
    const message = createBaseGenerateSuggestedTargetingInsightsRequest();
    message.customerId = object.customerId ?? "";
    message.audience = (object.audience !== undefined && object.audience !== null)
      ? InsightsAudience.fromPartial(object.audience)
      : undefined;
    message.baselineAudience = (object.baselineAudience !== undefined && object.baselineAudience !== null)
      ? InsightsAudience.fromPartial(object.baselineAudience)
      : undefined;
    message.dataMonth = object.dataMonth ?? "";
    message.customerInsightsGroup = object.customerInsightsGroup ?? "";
    return message;
  },
};

function createBaseGenerateSuggestedTargetingInsightsResponse(): GenerateSuggestedTargetingInsightsResponse {
  return { suggestions: [] };
}

export const GenerateSuggestedTargetingInsightsResponse: MessageFns<GenerateSuggestedTargetingInsightsResponse> = {
  encode(message: GenerateSuggestedTargetingInsightsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.suggestions) {
      TargetingSuggestionMetrics.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateSuggestedTargetingInsightsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateSuggestedTargetingInsightsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.suggestions.push(TargetingSuggestionMetrics.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateSuggestedTargetingInsightsResponse {
    return {
      suggestions: globalThis.Array.isArray(object?.suggestions)
        ? object.suggestions.map((e: any) => TargetingSuggestionMetrics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateSuggestedTargetingInsightsResponse): unknown {
    const obj: any = {};
    if (message.suggestions?.length) {
      obj.suggestions = message.suggestions.map((e) => TargetingSuggestionMetrics.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateSuggestedTargetingInsightsResponse>): GenerateSuggestedTargetingInsightsResponse {
    return GenerateSuggestedTargetingInsightsResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenerateSuggestedTargetingInsightsResponse>,
  ): GenerateSuggestedTargetingInsightsResponse {
    const message = createBaseGenerateSuggestedTargetingInsightsResponse();
    message.suggestions = object.suggestions?.map((e) => TargetingSuggestionMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTargetingSuggestionMetrics(): TargetingSuggestionMetrics {
  return {
    locations: [],
    ageRanges: [],
    gender: undefined,
    userInterests: [],
    coverage: 0,
    index: 0,
    potentialYoutubeReach: Long.ZERO,
  };
}

export const TargetingSuggestionMetrics: MessageFns<TargetingSuggestionMetrics> = {
  encode(message: TargetingSuggestionMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.locations) {
      AudienceInsightsAttributeMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.ageRanges) {
      AgeRangeInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.gender !== undefined) {
      GenderInfo.encode(message.gender, writer.uint32(26).fork()).join();
    }
    for (const v of message.userInterests) {
      AudienceInsightsAttributeMetadata.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.coverage !== 0) {
      writer.uint32(41).double(message.coverage);
    }
    if (message.index !== 0) {
      writer.uint32(49).double(message.index);
    }
    if (!message.potentialYoutubeReach.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.potentialYoutubeReach.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetingSuggestionMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetingSuggestionMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.locations.push(AudienceInsightsAttributeMetadata.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ageRanges.push(AgeRangeInfo.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gender = GenderInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userInterests.push(AudienceInsightsAttributeMetadata.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.coverage = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.index = reader.double();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.potentialYoutubeReach = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetingSuggestionMetrics {
    return {
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => AudienceInsightsAttributeMetadata.fromJSON(e))
        : [],
      ageRanges: globalThis.Array.isArray(object?.ageRanges)
        ? object.ageRanges.map((e: any) => AgeRangeInfo.fromJSON(e))
        : [],
      gender: isSet(object.gender) ? GenderInfo.fromJSON(object.gender) : undefined,
      userInterests: globalThis.Array.isArray(object?.userInterests)
        ? object.userInterests.map((e: any) => AudienceInsightsAttributeMetadata.fromJSON(e))
        : [],
      coverage: isSet(object.coverage) ? globalThis.Number(object.coverage) : 0,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      potentialYoutubeReach: isSet(object.potentialYoutubeReach)
        ? Long.fromValue(object.potentialYoutubeReach)
        : Long.ZERO,
    };
  },

  toJSON(message: TargetingSuggestionMetrics): unknown {
    const obj: any = {};
    if (message.locations?.length) {
      obj.locations = message.locations.map((e) => AudienceInsightsAttributeMetadata.toJSON(e));
    }
    if (message.ageRanges?.length) {
      obj.ageRanges = message.ageRanges.map((e) => AgeRangeInfo.toJSON(e));
    }
    if (message.gender !== undefined) {
      obj.gender = GenderInfo.toJSON(message.gender);
    }
    if (message.userInterests?.length) {
      obj.userInterests = message.userInterests.map((e) => AudienceInsightsAttributeMetadata.toJSON(e));
    }
    if (message.coverage !== 0) {
      obj.coverage = message.coverage;
    }
    if (message.index !== 0) {
      obj.index = message.index;
    }
    if (!message.potentialYoutubeReach.equals(Long.ZERO)) {
      obj.potentialYoutubeReach = (message.potentialYoutubeReach || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TargetingSuggestionMetrics>): TargetingSuggestionMetrics {
    return TargetingSuggestionMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetingSuggestionMetrics>): TargetingSuggestionMetrics {
    const message = createBaseTargetingSuggestionMetrics();
    message.locations = object.locations?.map((e) => AudienceInsightsAttributeMetadata.fromPartial(e)) || [];
    message.ageRanges = object.ageRanges?.map((e) => AgeRangeInfo.fromPartial(e)) || [];
    message.gender = (object.gender !== undefined && object.gender !== null)
      ? GenderInfo.fromPartial(object.gender)
      : undefined;
    message.userInterests = object.userInterests?.map((e) => AudienceInsightsAttributeMetadata.fromPartial(e)) || [];
    message.coverage = object.coverage ?? 0;
    message.index = object.index ?? 0;
    message.potentialYoutubeReach =
      (object.potentialYoutubeReach !== undefined && object.potentialYoutubeReach !== null)
        ? Long.fromValue(object.potentialYoutubeReach)
        : Long.ZERO;
    return message;
  },
};

function createBaseListAudienceInsightsAttributesRequest(): ListAudienceInsightsAttributesRequest {
  return {
    customerId: "",
    dimensions: [],
    queryText: "",
    customerInsightsGroup: "",
    locationCountryFilters: [],
    youtubeReachLocation: undefined,
  };
}

export const ListAudienceInsightsAttributesRequest: MessageFns<ListAudienceInsightsAttributesRequest> = {
  encode(message: ListAudienceInsightsAttributesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    writer.uint32(18).fork();
    for (const v of message.dimensions) {
      writer.int32(v);
    }
    writer.join();
    if (message.queryText !== "") {
      writer.uint32(26).string(message.queryText);
    }
    if (message.customerInsightsGroup !== "") {
      writer.uint32(34).string(message.customerInsightsGroup);
    }
    for (const v of message.locationCountryFilters) {
      LocationInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.youtubeReachLocation !== undefined) {
      LocationInfo.encode(message.youtubeReachLocation, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAudienceInsightsAttributesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAudienceInsightsAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.dimensions.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dimensions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.queryText = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.customerInsightsGroup = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.locationCountryFilters.push(LocationInfo.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.youtubeReachLocation = LocationInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAudienceInsightsAttributesRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => audienceInsightsDimensionEnum_AudienceInsightsDimensionFromJSON(e))
        : [],
      queryText: isSet(object.queryText) ? globalThis.String(object.queryText) : "",
      customerInsightsGroup: isSet(object.customerInsightsGroup) ? globalThis.String(object.customerInsightsGroup) : "",
      locationCountryFilters: globalThis.Array.isArray(object?.locationCountryFilters)
        ? object.locationCountryFilters.map((e: any) => LocationInfo.fromJSON(e))
        : [],
      youtubeReachLocation: isSet(object.youtubeReachLocation)
        ? LocationInfo.fromJSON(object.youtubeReachLocation)
        : undefined,
    };
  },

  toJSON(message: ListAudienceInsightsAttributesRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => audienceInsightsDimensionEnum_AudienceInsightsDimensionToJSON(e));
    }
    if (message.queryText !== "") {
      obj.queryText = message.queryText;
    }
    if (message.customerInsightsGroup !== "") {
      obj.customerInsightsGroup = message.customerInsightsGroup;
    }
    if (message.locationCountryFilters?.length) {
      obj.locationCountryFilters = message.locationCountryFilters.map((e) => LocationInfo.toJSON(e));
    }
    if (message.youtubeReachLocation !== undefined) {
      obj.youtubeReachLocation = LocationInfo.toJSON(message.youtubeReachLocation);
    }
    return obj;
  },

  create(base?: DeepPartial<ListAudienceInsightsAttributesRequest>): ListAudienceInsightsAttributesRequest {
    return ListAudienceInsightsAttributesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAudienceInsightsAttributesRequest>): ListAudienceInsightsAttributesRequest {
    const message = createBaseListAudienceInsightsAttributesRequest();
    message.customerId = object.customerId ?? "";
    message.dimensions = object.dimensions?.map((e) => e) || [];
    message.queryText = object.queryText ?? "";
    message.customerInsightsGroup = object.customerInsightsGroup ?? "";
    message.locationCountryFilters = object.locationCountryFilters?.map((e) => LocationInfo.fromPartial(e)) || [];
    message.youtubeReachLocation = (object.youtubeReachLocation !== undefined && object.youtubeReachLocation !== null)
      ? LocationInfo.fromPartial(object.youtubeReachLocation)
      : undefined;
    return message;
  },
};

function createBaseListAudienceInsightsAttributesResponse(): ListAudienceInsightsAttributesResponse {
  return { attributes: [] };
}

export const ListAudienceInsightsAttributesResponse: MessageFns<ListAudienceInsightsAttributesResponse> = {
  encode(message: ListAudienceInsightsAttributesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attributes) {
      AudienceInsightsAttributeMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAudienceInsightsAttributesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAudienceInsightsAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributes.push(AudienceInsightsAttributeMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAudienceInsightsAttributesResponse {
    return {
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => AudienceInsightsAttributeMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListAudienceInsightsAttributesResponse): unknown {
    const obj: any = {};
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => AudienceInsightsAttributeMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListAudienceInsightsAttributesResponse>): ListAudienceInsightsAttributesResponse {
    return ListAudienceInsightsAttributesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAudienceInsightsAttributesResponse>): ListAudienceInsightsAttributesResponse {
    const message = createBaseListAudienceInsightsAttributesResponse();
    message.attributes = object.attributes?.map((e) => AudienceInsightsAttributeMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListInsightsEligibleDatesRequest(): ListInsightsEligibleDatesRequest {
  return {};
}

export const ListInsightsEligibleDatesRequest: MessageFns<ListInsightsEligibleDatesRequest> = {
  encode(_: ListInsightsEligibleDatesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInsightsEligibleDatesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInsightsEligibleDatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListInsightsEligibleDatesRequest {
    return {};
  },

  toJSON(_: ListInsightsEligibleDatesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ListInsightsEligibleDatesRequest>): ListInsightsEligibleDatesRequest {
    return ListInsightsEligibleDatesRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ListInsightsEligibleDatesRequest>): ListInsightsEligibleDatesRequest {
    const message = createBaseListInsightsEligibleDatesRequest();
    return message;
  },
};

function createBaseListInsightsEligibleDatesResponse(): ListInsightsEligibleDatesResponse {
  return { dataMonths: [], lastThirtyDays: undefined };
}

export const ListInsightsEligibleDatesResponse: MessageFns<ListInsightsEligibleDatesResponse> = {
  encode(message: ListInsightsEligibleDatesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dataMonths) {
      writer.uint32(10).string(v!);
    }
    if (message.lastThirtyDays !== undefined) {
      DateRange.encode(message.lastThirtyDays, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInsightsEligibleDatesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInsightsEligibleDatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataMonths.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lastThirtyDays = DateRange.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInsightsEligibleDatesResponse {
    return {
      dataMonths: globalThis.Array.isArray(object?.dataMonths)
        ? object.dataMonths.map((e: any) => globalThis.String(e))
        : [],
      lastThirtyDays: isSet(object.lastThirtyDays) ? DateRange.fromJSON(object.lastThirtyDays) : undefined,
    };
  },

  toJSON(message: ListInsightsEligibleDatesResponse): unknown {
    const obj: any = {};
    if (message.dataMonths?.length) {
      obj.dataMonths = message.dataMonths;
    }
    if (message.lastThirtyDays !== undefined) {
      obj.lastThirtyDays = DateRange.toJSON(message.lastThirtyDays);
    }
    return obj;
  },

  create(base?: DeepPartial<ListInsightsEligibleDatesResponse>): ListInsightsEligibleDatesResponse {
    return ListInsightsEligibleDatesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInsightsEligibleDatesResponse>): ListInsightsEligibleDatesResponse {
    const message = createBaseListInsightsEligibleDatesResponse();
    message.dataMonths = object.dataMonths?.map((e) => e) || [];
    message.lastThirtyDays = (object.lastThirtyDays !== undefined && object.lastThirtyDays !== null)
      ? DateRange.fromPartial(object.lastThirtyDays)
      : undefined;
    return message;
  },
};

function createBaseGenerateAudienceOverlapInsightsRequest(): GenerateAudienceOverlapInsightsRequest {
  return {
    customerId: "",
    countryLocation: undefined,
    primaryAttribute: undefined,
    dimensions: [],
    customerInsightsGroup: "",
  };
}

export const GenerateAudienceOverlapInsightsRequest: MessageFns<GenerateAudienceOverlapInsightsRequest> = {
  encode(message: GenerateAudienceOverlapInsightsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.countryLocation !== undefined) {
      LocationInfo.encode(message.countryLocation, writer.uint32(18).fork()).join();
    }
    if (message.primaryAttribute !== undefined) {
      AudienceInsightsAttribute.encode(message.primaryAttribute, writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.dimensions) {
      writer.int32(v);
    }
    writer.join();
    if (message.customerInsightsGroup !== "") {
      writer.uint32(42).string(message.customerInsightsGroup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateAudienceOverlapInsightsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateAudienceOverlapInsightsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.countryLocation = LocationInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.primaryAttribute = AudienceInsightsAttribute.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag === 32) {
            message.dimensions.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dimensions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customerInsightsGroup = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateAudienceOverlapInsightsRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      countryLocation: isSet(object.countryLocation) ? LocationInfo.fromJSON(object.countryLocation) : undefined,
      primaryAttribute: isSet(object.primaryAttribute)
        ? AudienceInsightsAttribute.fromJSON(object.primaryAttribute)
        : undefined,
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => audienceInsightsDimensionEnum_AudienceInsightsDimensionFromJSON(e))
        : [],
      customerInsightsGroup: isSet(object.customerInsightsGroup) ? globalThis.String(object.customerInsightsGroup) : "",
    };
  },

  toJSON(message: GenerateAudienceOverlapInsightsRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.countryLocation !== undefined) {
      obj.countryLocation = LocationInfo.toJSON(message.countryLocation);
    }
    if (message.primaryAttribute !== undefined) {
      obj.primaryAttribute = AudienceInsightsAttribute.toJSON(message.primaryAttribute);
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => audienceInsightsDimensionEnum_AudienceInsightsDimensionToJSON(e));
    }
    if (message.customerInsightsGroup !== "") {
      obj.customerInsightsGroup = message.customerInsightsGroup;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateAudienceOverlapInsightsRequest>): GenerateAudienceOverlapInsightsRequest {
    return GenerateAudienceOverlapInsightsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateAudienceOverlapInsightsRequest>): GenerateAudienceOverlapInsightsRequest {
    const message = createBaseGenerateAudienceOverlapInsightsRequest();
    message.customerId = object.customerId ?? "";
    message.countryLocation = (object.countryLocation !== undefined && object.countryLocation !== null)
      ? LocationInfo.fromPartial(object.countryLocation)
      : undefined;
    message.primaryAttribute = (object.primaryAttribute !== undefined && object.primaryAttribute !== null)
      ? AudienceInsightsAttribute.fromPartial(object.primaryAttribute)
      : undefined;
    message.dimensions = object.dimensions?.map((e) => e) || [];
    message.customerInsightsGroup = object.customerInsightsGroup ?? "";
    return message;
  },
};

function createBaseGenerateAudienceOverlapInsightsResponse(): GenerateAudienceOverlapInsightsResponse {
  return { primaryAttributeMetadata: undefined, dimensionResults: [] };
}

export const GenerateAudienceOverlapInsightsResponse: MessageFns<GenerateAudienceOverlapInsightsResponse> = {
  encode(message: GenerateAudienceOverlapInsightsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primaryAttributeMetadata !== undefined) {
      AudienceInsightsAttributeMetadata.encode(message.primaryAttributeMetadata, writer.uint32(10).fork()).join();
    }
    for (const v of message.dimensionResults) {
      DimensionOverlapResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateAudienceOverlapInsightsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateAudienceOverlapInsightsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.primaryAttributeMetadata = AudienceInsightsAttributeMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimensionResults.push(DimensionOverlapResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateAudienceOverlapInsightsResponse {
    return {
      primaryAttributeMetadata: isSet(object.primaryAttributeMetadata)
        ? AudienceInsightsAttributeMetadata.fromJSON(object.primaryAttributeMetadata)
        : undefined,
      dimensionResults: globalThis.Array.isArray(object?.dimensionResults)
        ? object.dimensionResults.map((e: any) => DimensionOverlapResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateAudienceOverlapInsightsResponse): unknown {
    const obj: any = {};
    if (message.primaryAttributeMetadata !== undefined) {
      obj.primaryAttributeMetadata = AudienceInsightsAttributeMetadata.toJSON(message.primaryAttributeMetadata);
    }
    if (message.dimensionResults?.length) {
      obj.dimensionResults = message.dimensionResults.map((e) => DimensionOverlapResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateAudienceOverlapInsightsResponse>): GenerateAudienceOverlapInsightsResponse {
    return GenerateAudienceOverlapInsightsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateAudienceOverlapInsightsResponse>): GenerateAudienceOverlapInsightsResponse {
    const message = createBaseGenerateAudienceOverlapInsightsResponse();
    message.primaryAttributeMetadata =
      (object.primaryAttributeMetadata !== undefined && object.primaryAttributeMetadata !== null)
        ? AudienceInsightsAttributeMetadata.fromPartial(object.primaryAttributeMetadata)
        : undefined;
    message.dimensionResults = object.dimensionResults?.map((e) => DimensionOverlapResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDimensionOverlapResult(): DimensionOverlapResult {
  return { dimension: 0, items: [] };
}

export const DimensionOverlapResult: MessageFns<DimensionOverlapResult> = {
  encode(message: DimensionOverlapResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dimension !== 0) {
      writer.uint32(8).int32(message.dimension);
    }
    for (const v of message.items) {
      AudienceOverlapItem.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DimensionOverlapResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimensionOverlapResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dimension = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.items.push(AudienceOverlapItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DimensionOverlapResult {
    return {
      dimension: isSet(object.dimension)
        ? audienceInsightsDimensionEnum_AudienceInsightsDimensionFromJSON(object.dimension)
        : 0,
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => AudienceOverlapItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DimensionOverlapResult): unknown {
    const obj: any = {};
    if (message.dimension !== 0) {
      obj.dimension = audienceInsightsDimensionEnum_AudienceInsightsDimensionToJSON(message.dimension);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => AudienceOverlapItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DimensionOverlapResult>): DimensionOverlapResult {
    return DimensionOverlapResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DimensionOverlapResult>): DimensionOverlapResult {
    const message = createBaseDimensionOverlapResult();
    message.dimension = object.dimension ?? 0;
    message.items = object.items?.map((e) => AudienceOverlapItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAudienceOverlapItem(): AudienceOverlapItem {
  return { attributeMetadata: undefined, potentialYoutubeReachIntersection: Long.ZERO };
}

export const AudienceOverlapItem: MessageFns<AudienceOverlapItem> = {
  encode(message: AudienceOverlapItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attributeMetadata !== undefined) {
      AudienceInsightsAttributeMetadata.encode(message.attributeMetadata, writer.uint32(10).fork()).join();
    }
    if (!message.potentialYoutubeReachIntersection.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.potentialYoutubeReachIntersection.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceOverlapItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceOverlapItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeMetadata = AudienceInsightsAttributeMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.potentialYoutubeReachIntersection = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceOverlapItem {
    return {
      attributeMetadata: isSet(object.attributeMetadata)
        ? AudienceInsightsAttributeMetadata.fromJSON(object.attributeMetadata)
        : undefined,
      potentialYoutubeReachIntersection: isSet(object.potentialYoutubeReachIntersection)
        ? Long.fromValue(object.potentialYoutubeReachIntersection)
        : Long.ZERO,
    };
  },

  toJSON(message: AudienceOverlapItem): unknown {
    const obj: any = {};
    if (message.attributeMetadata !== undefined) {
      obj.attributeMetadata = AudienceInsightsAttributeMetadata.toJSON(message.attributeMetadata);
    }
    if (!message.potentialYoutubeReachIntersection.equals(Long.ZERO)) {
      obj.potentialYoutubeReachIntersection = (message.potentialYoutubeReachIntersection || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceOverlapItem>): AudienceOverlapItem {
    return AudienceOverlapItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceOverlapItem>): AudienceOverlapItem {
    const message = createBaseAudienceOverlapItem();
    message.attributeMetadata = (object.attributeMetadata !== undefined && object.attributeMetadata !== null)
      ? AudienceInsightsAttributeMetadata.fromPartial(object.attributeMetadata)
      : undefined;
    message.potentialYoutubeReachIntersection =
      (object.potentialYoutubeReachIntersection !== undefined && object.potentialYoutubeReachIntersection !== null)
        ? Long.fromValue(object.potentialYoutubeReachIntersection)
        : Long.ZERO;
    return message;
  },
};

function createBaseAudienceInsightsAttribute(): AudienceInsightsAttribute {
  return {
    ageRange: undefined,
    gender: undefined,
    location: undefined,
    userInterest: undefined,
    entity: undefined,
    category: undefined,
    dynamicLineup: undefined,
    parentalStatus: undefined,
    incomeRange: undefined,
    youtubeChannel: undefined,
  };
}

export const AudienceInsightsAttribute: MessageFns<AudienceInsightsAttribute> = {
  encode(message: AudienceInsightsAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ageRange !== undefined) {
      AgeRangeInfo.encode(message.ageRange, writer.uint32(10).fork()).join();
    }
    if (message.gender !== undefined) {
      GenderInfo.encode(message.gender, writer.uint32(18).fork()).join();
    }
    if (message.location !== undefined) {
      LocationInfo.encode(message.location, writer.uint32(26).fork()).join();
    }
    if (message.userInterest !== undefined) {
      UserInterestInfo.encode(message.userInterest, writer.uint32(34).fork()).join();
    }
    if (message.entity !== undefined) {
      AudienceInsightsEntity.encode(message.entity, writer.uint32(42).fork()).join();
    }
    if (message.category !== undefined) {
      AudienceInsightsCategory.encode(message.category, writer.uint32(50).fork()).join();
    }
    if (message.dynamicLineup !== undefined) {
      AudienceInsightsDynamicLineup.encode(message.dynamicLineup, writer.uint32(58).fork()).join();
    }
    if (message.parentalStatus !== undefined) {
      ParentalStatusInfo.encode(message.parentalStatus, writer.uint32(66).fork()).join();
    }
    if (message.incomeRange !== undefined) {
      IncomeRangeInfo.encode(message.incomeRange, writer.uint32(74).fork()).join();
    }
    if (message.youtubeChannel !== undefined) {
      YouTubeChannelInfo.encode(message.youtubeChannel, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceInsightsAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceInsightsAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ageRange = AgeRangeInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gender = GenderInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.location = LocationInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userInterest = UserInterestInfo.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.entity = AudienceInsightsEntity.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.category = AudienceInsightsCategory.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dynamicLineup = AudienceInsightsDynamicLineup.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.parentalStatus = ParentalStatusInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.incomeRange = IncomeRangeInfo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.youtubeChannel = YouTubeChannelInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceInsightsAttribute {
    return {
      ageRange: isSet(object.ageRange) ? AgeRangeInfo.fromJSON(object.ageRange) : undefined,
      gender: isSet(object.gender) ? GenderInfo.fromJSON(object.gender) : undefined,
      location: isSet(object.location) ? LocationInfo.fromJSON(object.location) : undefined,
      userInterest: isSet(object.userInterest) ? UserInterestInfo.fromJSON(object.userInterest) : undefined,
      entity: isSet(object.entity) ? AudienceInsightsEntity.fromJSON(object.entity) : undefined,
      category: isSet(object.category) ? AudienceInsightsCategory.fromJSON(object.category) : undefined,
      dynamicLineup: isSet(object.dynamicLineup)
        ? AudienceInsightsDynamicLineup.fromJSON(object.dynamicLineup)
        : undefined,
      parentalStatus: isSet(object.parentalStatus) ? ParentalStatusInfo.fromJSON(object.parentalStatus) : undefined,
      incomeRange: isSet(object.incomeRange) ? IncomeRangeInfo.fromJSON(object.incomeRange) : undefined,
      youtubeChannel: isSet(object.youtubeChannel) ? YouTubeChannelInfo.fromJSON(object.youtubeChannel) : undefined,
    };
  },

  toJSON(message: AudienceInsightsAttribute): unknown {
    const obj: any = {};
    if (message.ageRange !== undefined) {
      obj.ageRange = AgeRangeInfo.toJSON(message.ageRange);
    }
    if (message.gender !== undefined) {
      obj.gender = GenderInfo.toJSON(message.gender);
    }
    if (message.location !== undefined) {
      obj.location = LocationInfo.toJSON(message.location);
    }
    if (message.userInterest !== undefined) {
      obj.userInterest = UserInterestInfo.toJSON(message.userInterest);
    }
    if (message.entity !== undefined) {
      obj.entity = AudienceInsightsEntity.toJSON(message.entity);
    }
    if (message.category !== undefined) {
      obj.category = AudienceInsightsCategory.toJSON(message.category);
    }
    if (message.dynamicLineup !== undefined) {
      obj.dynamicLineup = AudienceInsightsDynamicLineup.toJSON(message.dynamicLineup);
    }
    if (message.parentalStatus !== undefined) {
      obj.parentalStatus = ParentalStatusInfo.toJSON(message.parentalStatus);
    }
    if (message.incomeRange !== undefined) {
      obj.incomeRange = IncomeRangeInfo.toJSON(message.incomeRange);
    }
    if (message.youtubeChannel !== undefined) {
      obj.youtubeChannel = YouTubeChannelInfo.toJSON(message.youtubeChannel);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceInsightsAttribute>): AudienceInsightsAttribute {
    return AudienceInsightsAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceInsightsAttribute>): AudienceInsightsAttribute {
    const message = createBaseAudienceInsightsAttribute();
    message.ageRange = (object.ageRange !== undefined && object.ageRange !== null)
      ? AgeRangeInfo.fromPartial(object.ageRange)
      : undefined;
    message.gender = (object.gender !== undefined && object.gender !== null)
      ? GenderInfo.fromPartial(object.gender)
      : undefined;
    message.location = (object.location !== undefined && object.location !== null)
      ? LocationInfo.fromPartial(object.location)
      : undefined;
    message.userInterest = (object.userInterest !== undefined && object.userInterest !== null)
      ? UserInterestInfo.fromPartial(object.userInterest)
      : undefined;
    message.entity = (object.entity !== undefined && object.entity !== null)
      ? AudienceInsightsEntity.fromPartial(object.entity)
      : undefined;
    message.category = (object.category !== undefined && object.category !== null)
      ? AudienceInsightsCategory.fromPartial(object.category)
      : undefined;
    message.dynamicLineup = (object.dynamicLineup !== undefined && object.dynamicLineup !== null)
      ? AudienceInsightsDynamicLineup.fromPartial(object.dynamicLineup)
      : undefined;
    message.parentalStatus = (object.parentalStatus !== undefined && object.parentalStatus !== null)
      ? ParentalStatusInfo.fromPartial(object.parentalStatus)
      : undefined;
    message.incomeRange = (object.incomeRange !== undefined && object.incomeRange !== null)
      ? IncomeRangeInfo.fromPartial(object.incomeRange)
      : undefined;
    message.youtubeChannel = (object.youtubeChannel !== undefined && object.youtubeChannel !== null)
      ? YouTubeChannelInfo.fromPartial(object.youtubeChannel)
      : undefined;
    return message;
  },
};

function createBaseAudienceInsightsTopic(): AudienceInsightsTopic {
  return { entity: undefined, category: undefined };
}

export const AudienceInsightsTopic: MessageFns<AudienceInsightsTopic> = {
  encode(message: AudienceInsightsTopic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entity !== undefined) {
      AudienceInsightsEntity.encode(message.entity, writer.uint32(10).fork()).join();
    }
    if (message.category !== undefined) {
      AudienceInsightsCategory.encode(message.category, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceInsightsTopic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceInsightsTopic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entity = AudienceInsightsEntity.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.category = AudienceInsightsCategory.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceInsightsTopic {
    return {
      entity: isSet(object.entity) ? AudienceInsightsEntity.fromJSON(object.entity) : undefined,
      category: isSet(object.category) ? AudienceInsightsCategory.fromJSON(object.category) : undefined,
    };
  },

  toJSON(message: AudienceInsightsTopic): unknown {
    const obj: any = {};
    if (message.entity !== undefined) {
      obj.entity = AudienceInsightsEntity.toJSON(message.entity);
    }
    if (message.category !== undefined) {
      obj.category = AudienceInsightsCategory.toJSON(message.category);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceInsightsTopic>): AudienceInsightsTopic {
    return AudienceInsightsTopic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceInsightsTopic>): AudienceInsightsTopic {
    const message = createBaseAudienceInsightsTopic();
    message.entity = (object.entity !== undefined && object.entity !== null)
      ? AudienceInsightsEntity.fromPartial(object.entity)
      : undefined;
    message.category = (object.category !== undefined && object.category !== null)
      ? AudienceInsightsCategory.fromPartial(object.category)
      : undefined;
    return message;
  },
};

function createBaseAudienceInsightsEntity(): AudienceInsightsEntity {
  return { knowledgeGraphMachineId: "" };
}

export const AudienceInsightsEntity: MessageFns<AudienceInsightsEntity> = {
  encode(message: AudienceInsightsEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.knowledgeGraphMachineId !== "") {
      writer.uint32(10).string(message.knowledgeGraphMachineId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceInsightsEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceInsightsEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.knowledgeGraphMachineId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceInsightsEntity {
    return {
      knowledgeGraphMachineId: isSet(object.knowledgeGraphMachineId)
        ? globalThis.String(object.knowledgeGraphMachineId)
        : "",
    };
  },

  toJSON(message: AudienceInsightsEntity): unknown {
    const obj: any = {};
    if (message.knowledgeGraphMachineId !== "") {
      obj.knowledgeGraphMachineId = message.knowledgeGraphMachineId;
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceInsightsEntity>): AudienceInsightsEntity {
    return AudienceInsightsEntity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceInsightsEntity>): AudienceInsightsEntity {
    const message = createBaseAudienceInsightsEntity();
    message.knowledgeGraphMachineId = object.knowledgeGraphMachineId ?? "";
    return message;
  },
};

function createBaseAudienceInsightsCategory(): AudienceInsightsCategory {
  return { categoryId: "" };
}

export const AudienceInsightsCategory: MessageFns<AudienceInsightsCategory> = {
  encode(message: AudienceInsightsCategory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.categoryId !== "") {
      writer.uint32(10).string(message.categoryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceInsightsCategory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceInsightsCategory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.categoryId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceInsightsCategory {
    return { categoryId: isSet(object.categoryId) ? globalThis.String(object.categoryId) : "" };
  },

  toJSON(message: AudienceInsightsCategory): unknown {
    const obj: any = {};
    if (message.categoryId !== "") {
      obj.categoryId = message.categoryId;
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceInsightsCategory>): AudienceInsightsCategory {
    return AudienceInsightsCategory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceInsightsCategory>): AudienceInsightsCategory {
    const message = createBaseAudienceInsightsCategory();
    message.categoryId = object.categoryId ?? "";
    return message;
  },
};

function createBaseAudienceInsightsDynamicLineup(): AudienceInsightsDynamicLineup {
  return { dynamicLineupId: "" };
}

export const AudienceInsightsDynamicLineup: MessageFns<AudienceInsightsDynamicLineup> = {
  encode(message: AudienceInsightsDynamicLineup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dynamicLineupId !== "") {
      writer.uint32(10).string(message.dynamicLineupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceInsightsDynamicLineup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceInsightsDynamicLineup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dynamicLineupId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceInsightsDynamicLineup {
    return { dynamicLineupId: isSet(object.dynamicLineupId) ? globalThis.String(object.dynamicLineupId) : "" };
  },

  toJSON(message: AudienceInsightsDynamicLineup): unknown {
    const obj: any = {};
    if (message.dynamicLineupId !== "") {
      obj.dynamicLineupId = message.dynamicLineupId;
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceInsightsDynamicLineup>): AudienceInsightsDynamicLineup {
    return AudienceInsightsDynamicLineup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceInsightsDynamicLineup>): AudienceInsightsDynamicLineup {
    const message = createBaseAudienceInsightsDynamicLineup();
    message.dynamicLineupId = object.dynamicLineupId ?? "";
    return message;
  },
};

function createBaseBasicInsightsAudience(): BasicInsightsAudience {
  return {
    countryLocation: [],
    subCountryLocations: [],
    gender: undefined,
    ageRanges: [],
    userInterests: [],
    topics: [],
  };
}

export const BasicInsightsAudience: MessageFns<BasicInsightsAudience> = {
  encode(message: BasicInsightsAudience, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.countryLocation) {
      LocationInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.subCountryLocations) {
      LocationInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.gender !== undefined) {
      GenderInfo.encode(message.gender, writer.uint32(26).fork()).join();
    }
    for (const v of message.ageRanges) {
      AgeRangeInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.userInterests) {
      UserInterestInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.topics) {
      AudienceInsightsTopic.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicInsightsAudience {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicInsightsAudience();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.countryLocation.push(LocationInfo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subCountryLocations.push(LocationInfo.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gender = GenderInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ageRanges.push(AgeRangeInfo.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.userInterests.push(UserInterestInfo.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.topics.push(AudienceInsightsTopic.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasicInsightsAudience {
    return {
      countryLocation: globalThis.Array.isArray(object?.countryLocation)
        ? object.countryLocation.map((e: any) => LocationInfo.fromJSON(e))
        : [],
      subCountryLocations: globalThis.Array.isArray(object?.subCountryLocations)
        ? object.subCountryLocations.map((e: any) => LocationInfo.fromJSON(e))
        : [],
      gender: isSet(object.gender) ? GenderInfo.fromJSON(object.gender) : undefined,
      ageRanges: globalThis.Array.isArray(object?.ageRanges)
        ? object.ageRanges.map((e: any) => AgeRangeInfo.fromJSON(e))
        : [],
      userInterests: globalThis.Array.isArray(object?.userInterests)
        ? object.userInterests.map((e: any) => UserInterestInfo.fromJSON(e))
        : [],
      topics: globalThis.Array.isArray(object?.topics)
        ? object.topics.map((e: any) => AudienceInsightsTopic.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BasicInsightsAudience): unknown {
    const obj: any = {};
    if (message.countryLocation?.length) {
      obj.countryLocation = message.countryLocation.map((e) => LocationInfo.toJSON(e));
    }
    if (message.subCountryLocations?.length) {
      obj.subCountryLocations = message.subCountryLocations.map((e) => LocationInfo.toJSON(e));
    }
    if (message.gender !== undefined) {
      obj.gender = GenderInfo.toJSON(message.gender);
    }
    if (message.ageRanges?.length) {
      obj.ageRanges = message.ageRanges.map((e) => AgeRangeInfo.toJSON(e));
    }
    if (message.userInterests?.length) {
      obj.userInterests = message.userInterests.map((e) => UserInterestInfo.toJSON(e));
    }
    if (message.topics?.length) {
      obj.topics = message.topics.map((e) => AudienceInsightsTopic.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BasicInsightsAudience>): BasicInsightsAudience {
    return BasicInsightsAudience.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BasicInsightsAudience>): BasicInsightsAudience {
    const message = createBaseBasicInsightsAudience();
    message.countryLocation = object.countryLocation?.map((e) => LocationInfo.fromPartial(e)) || [];
    message.subCountryLocations = object.subCountryLocations?.map((e) => LocationInfo.fromPartial(e)) || [];
    message.gender = (object.gender !== undefined && object.gender !== null)
      ? GenderInfo.fromPartial(object.gender)
      : undefined;
    message.ageRanges = object.ageRanges?.map((e) => AgeRangeInfo.fromPartial(e)) || [];
    message.userInterests = object.userInterests?.map((e) => UserInterestInfo.fromPartial(e)) || [];
    message.topics = object.topics?.map((e) => AudienceInsightsTopic.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAudienceInsightsAttributeMetadata(): AudienceInsightsAttributeMetadata {
  return {
    dimension: 0,
    attribute: undefined,
    displayName: "",
    displayInfo: "",
    potentialYoutubeReach: Long.ZERO,
    youtubeChannelMetadata: undefined,
    dynamicAttributeMetadata: undefined,
    locationAttributeMetadata: undefined,
  };
}

export const AudienceInsightsAttributeMetadata: MessageFns<AudienceInsightsAttributeMetadata> = {
  encode(message: AudienceInsightsAttributeMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dimension !== 0) {
      writer.uint32(8).int32(message.dimension);
    }
    if (message.attribute !== undefined) {
      AudienceInsightsAttribute.encode(message.attribute, writer.uint32(18).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.displayInfo !== "") {
      writer.uint32(42).string(message.displayInfo);
    }
    if (!message.potentialYoutubeReach.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.potentialYoutubeReach.toString());
    }
    if (message.youtubeChannelMetadata !== undefined) {
      YouTubeChannelAttributeMetadata.encode(message.youtubeChannelMetadata, writer.uint32(50).fork()).join();
    }
    if (message.dynamicAttributeMetadata !== undefined) {
      DynamicLineupAttributeMetadata.encode(message.dynamicAttributeMetadata, writer.uint32(58).fork()).join();
    }
    if (message.locationAttributeMetadata !== undefined) {
      LocationAttributeMetadata.encode(message.locationAttributeMetadata, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceInsightsAttributeMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceInsightsAttributeMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dimension = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attribute = AudienceInsightsAttribute.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayInfo = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.potentialYoutubeReach = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.youtubeChannelMetadata = YouTubeChannelAttributeMetadata.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dynamicAttributeMetadata = DynamicLineupAttributeMetadata.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.locationAttributeMetadata = LocationAttributeMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceInsightsAttributeMetadata {
    return {
      dimension: isSet(object.dimension)
        ? audienceInsightsDimensionEnum_AudienceInsightsDimensionFromJSON(object.dimension)
        : 0,
      attribute: isSet(object.attribute) ? AudienceInsightsAttribute.fromJSON(object.attribute) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      displayInfo: isSet(object.displayInfo) ? globalThis.String(object.displayInfo) : "",
      potentialYoutubeReach: isSet(object.potentialYoutubeReach)
        ? Long.fromValue(object.potentialYoutubeReach)
        : Long.ZERO,
      youtubeChannelMetadata: isSet(object.youtubeChannelMetadata)
        ? YouTubeChannelAttributeMetadata.fromJSON(object.youtubeChannelMetadata)
        : undefined,
      dynamicAttributeMetadata: isSet(object.dynamicAttributeMetadata)
        ? DynamicLineupAttributeMetadata.fromJSON(object.dynamicAttributeMetadata)
        : undefined,
      locationAttributeMetadata: isSet(object.locationAttributeMetadata)
        ? LocationAttributeMetadata.fromJSON(object.locationAttributeMetadata)
        : undefined,
    };
  },

  toJSON(message: AudienceInsightsAttributeMetadata): unknown {
    const obj: any = {};
    if (message.dimension !== 0) {
      obj.dimension = audienceInsightsDimensionEnum_AudienceInsightsDimensionToJSON(message.dimension);
    }
    if (message.attribute !== undefined) {
      obj.attribute = AudienceInsightsAttribute.toJSON(message.attribute);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.displayInfo !== "") {
      obj.displayInfo = message.displayInfo;
    }
    if (!message.potentialYoutubeReach.equals(Long.ZERO)) {
      obj.potentialYoutubeReach = (message.potentialYoutubeReach || Long.ZERO).toString();
    }
    if (message.youtubeChannelMetadata !== undefined) {
      obj.youtubeChannelMetadata = YouTubeChannelAttributeMetadata.toJSON(message.youtubeChannelMetadata);
    }
    if (message.dynamicAttributeMetadata !== undefined) {
      obj.dynamicAttributeMetadata = DynamicLineupAttributeMetadata.toJSON(message.dynamicAttributeMetadata);
    }
    if (message.locationAttributeMetadata !== undefined) {
      obj.locationAttributeMetadata = LocationAttributeMetadata.toJSON(message.locationAttributeMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceInsightsAttributeMetadata>): AudienceInsightsAttributeMetadata {
    return AudienceInsightsAttributeMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceInsightsAttributeMetadata>): AudienceInsightsAttributeMetadata {
    const message = createBaseAudienceInsightsAttributeMetadata();
    message.dimension = object.dimension ?? 0;
    message.attribute = (object.attribute !== undefined && object.attribute !== null)
      ? AudienceInsightsAttribute.fromPartial(object.attribute)
      : undefined;
    message.displayName = object.displayName ?? "";
    message.displayInfo = object.displayInfo ?? "";
    message.potentialYoutubeReach =
      (object.potentialYoutubeReach !== undefined && object.potentialYoutubeReach !== null)
        ? Long.fromValue(object.potentialYoutubeReach)
        : Long.ZERO;
    message.youtubeChannelMetadata =
      (object.youtubeChannelMetadata !== undefined && object.youtubeChannelMetadata !== null)
        ? YouTubeChannelAttributeMetadata.fromPartial(object.youtubeChannelMetadata)
        : undefined;
    message.dynamicAttributeMetadata =
      (object.dynamicAttributeMetadata !== undefined && object.dynamicAttributeMetadata !== null)
        ? DynamicLineupAttributeMetadata.fromPartial(object.dynamicAttributeMetadata)
        : undefined;
    message.locationAttributeMetadata =
      (object.locationAttributeMetadata !== undefined && object.locationAttributeMetadata !== null)
        ? LocationAttributeMetadata.fromPartial(object.locationAttributeMetadata)
        : undefined;
    return message;
  },
};

function createBaseYouTubeChannelAttributeMetadata(): YouTubeChannelAttributeMetadata {
  return { subscriberCount: Long.ZERO };
}

export const YouTubeChannelAttributeMetadata: MessageFns<YouTubeChannelAttributeMetadata> = {
  encode(message: YouTubeChannelAttributeMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.subscriberCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.subscriberCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YouTubeChannelAttributeMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYouTubeChannelAttributeMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.subscriberCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YouTubeChannelAttributeMetadata {
    return { subscriberCount: isSet(object.subscriberCount) ? Long.fromValue(object.subscriberCount) : Long.ZERO };
  },

  toJSON(message: YouTubeChannelAttributeMetadata): unknown {
    const obj: any = {};
    if (!message.subscriberCount.equals(Long.ZERO)) {
      obj.subscriberCount = (message.subscriberCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<YouTubeChannelAttributeMetadata>): YouTubeChannelAttributeMetadata {
    return YouTubeChannelAttributeMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<YouTubeChannelAttributeMetadata>): YouTubeChannelAttributeMetadata {
    const message = createBaseYouTubeChannelAttributeMetadata();
    message.subscriberCount = (object.subscriberCount !== undefined && object.subscriberCount !== null)
      ? Long.fromValue(object.subscriberCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseDynamicLineupAttributeMetadata(): DynamicLineupAttributeMetadata {
  return {
    inventoryCountry: undefined,
    medianMonthlyInventory: undefined,
    channelCountLowerBound: undefined,
    channelCountUpperBound: undefined,
    sampleChannels: [],
  };
}

export const DynamicLineupAttributeMetadata: MessageFns<DynamicLineupAttributeMetadata> = {
  encode(message: DynamicLineupAttributeMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inventoryCountry !== undefined) {
      LocationInfo.encode(message.inventoryCountry, writer.uint32(10).fork()).join();
    }
    if (message.medianMonthlyInventory !== undefined) {
      writer.uint32(16).int64(message.medianMonthlyInventory.toString());
    }
    if (message.channelCountLowerBound !== undefined) {
      writer.uint32(24).int64(message.channelCountLowerBound.toString());
    }
    if (message.channelCountUpperBound !== undefined) {
      writer.uint32(32).int64(message.channelCountUpperBound.toString());
    }
    for (const v of message.sampleChannels) {
      DynamicLineupAttributeMetadata_SampleChannel.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DynamicLineupAttributeMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDynamicLineupAttributeMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inventoryCountry = LocationInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.medianMonthlyInventory = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.channelCountLowerBound = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.channelCountUpperBound = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sampleChannels.push(DynamicLineupAttributeMetadata_SampleChannel.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DynamicLineupAttributeMetadata {
    return {
      inventoryCountry: isSet(object.inventoryCountry) ? LocationInfo.fromJSON(object.inventoryCountry) : undefined,
      medianMonthlyInventory: isSet(object.medianMonthlyInventory)
        ? Long.fromValue(object.medianMonthlyInventory)
        : undefined,
      channelCountLowerBound: isSet(object.channelCountLowerBound)
        ? Long.fromValue(object.channelCountLowerBound)
        : undefined,
      channelCountUpperBound: isSet(object.channelCountUpperBound)
        ? Long.fromValue(object.channelCountUpperBound)
        : undefined,
      sampleChannels: globalThis.Array.isArray(object?.sampleChannels)
        ? object.sampleChannels.map((e: any) => DynamicLineupAttributeMetadata_SampleChannel.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DynamicLineupAttributeMetadata): unknown {
    const obj: any = {};
    if (message.inventoryCountry !== undefined) {
      obj.inventoryCountry = LocationInfo.toJSON(message.inventoryCountry);
    }
    if (message.medianMonthlyInventory !== undefined) {
      obj.medianMonthlyInventory = (message.medianMonthlyInventory || Long.ZERO).toString();
    }
    if (message.channelCountLowerBound !== undefined) {
      obj.channelCountLowerBound = (message.channelCountLowerBound || Long.ZERO).toString();
    }
    if (message.channelCountUpperBound !== undefined) {
      obj.channelCountUpperBound = (message.channelCountUpperBound || Long.ZERO).toString();
    }
    if (message.sampleChannels?.length) {
      obj.sampleChannels = message.sampleChannels.map((e) => DynamicLineupAttributeMetadata_SampleChannel.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DynamicLineupAttributeMetadata>): DynamicLineupAttributeMetadata {
    return DynamicLineupAttributeMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DynamicLineupAttributeMetadata>): DynamicLineupAttributeMetadata {
    const message = createBaseDynamicLineupAttributeMetadata();
    message.inventoryCountry = (object.inventoryCountry !== undefined && object.inventoryCountry !== null)
      ? LocationInfo.fromPartial(object.inventoryCountry)
      : undefined;
    message.medianMonthlyInventory =
      (object.medianMonthlyInventory !== undefined && object.medianMonthlyInventory !== null)
        ? Long.fromValue(object.medianMonthlyInventory)
        : undefined;
    message.channelCountLowerBound =
      (object.channelCountLowerBound !== undefined && object.channelCountLowerBound !== null)
        ? Long.fromValue(object.channelCountLowerBound)
        : undefined;
    message.channelCountUpperBound =
      (object.channelCountUpperBound !== undefined && object.channelCountUpperBound !== null)
        ? Long.fromValue(object.channelCountUpperBound)
        : undefined;
    message.sampleChannels =
      object.sampleChannels?.map((e) => DynamicLineupAttributeMetadata_SampleChannel.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDynamicLineupAttributeMetadata_SampleChannel(): DynamicLineupAttributeMetadata_SampleChannel {
  return { youtubeChannel: undefined, displayName: "", youtubeChannelMetadata: undefined };
}

export const DynamicLineupAttributeMetadata_SampleChannel: MessageFns<DynamicLineupAttributeMetadata_SampleChannel> = {
  encode(
    message: DynamicLineupAttributeMetadata_SampleChannel,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.youtubeChannel !== undefined) {
      YouTubeChannelInfo.encode(message.youtubeChannel, writer.uint32(10).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.youtubeChannelMetadata !== undefined) {
      YouTubeChannelAttributeMetadata.encode(message.youtubeChannelMetadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DynamicLineupAttributeMetadata_SampleChannel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDynamicLineupAttributeMetadata_SampleChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.youtubeChannel = YouTubeChannelInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.youtubeChannelMetadata = YouTubeChannelAttributeMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DynamicLineupAttributeMetadata_SampleChannel {
    return {
      youtubeChannel: isSet(object.youtubeChannel) ? YouTubeChannelInfo.fromJSON(object.youtubeChannel) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      youtubeChannelMetadata: isSet(object.youtubeChannelMetadata)
        ? YouTubeChannelAttributeMetadata.fromJSON(object.youtubeChannelMetadata)
        : undefined,
    };
  },

  toJSON(message: DynamicLineupAttributeMetadata_SampleChannel): unknown {
    const obj: any = {};
    if (message.youtubeChannel !== undefined) {
      obj.youtubeChannel = YouTubeChannelInfo.toJSON(message.youtubeChannel);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.youtubeChannelMetadata !== undefined) {
      obj.youtubeChannelMetadata = YouTubeChannelAttributeMetadata.toJSON(message.youtubeChannelMetadata);
    }
    return obj;
  },

  create(
    base?: DeepPartial<DynamicLineupAttributeMetadata_SampleChannel>,
  ): DynamicLineupAttributeMetadata_SampleChannel {
    return DynamicLineupAttributeMetadata_SampleChannel.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DynamicLineupAttributeMetadata_SampleChannel>,
  ): DynamicLineupAttributeMetadata_SampleChannel {
    const message = createBaseDynamicLineupAttributeMetadata_SampleChannel();
    message.youtubeChannel = (object.youtubeChannel !== undefined && object.youtubeChannel !== null)
      ? YouTubeChannelInfo.fromPartial(object.youtubeChannel)
      : undefined;
    message.displayName = object.displayName ?? "";
    message.youtubeChannelMetadata =
      (object.youtubeChannelMetadata !== undefined && object.youtubeChannelMetadata !== null)
        ? YouTubeChannelAttributeMetadata.fromPartial(object.youtubeChannelMetadata)
        : undefined;
    return message;
  },
};

function createBaseLocationAttributeMetadata(): LocationAttributeMetadata {
  return { countryLocation: undefined };
}

export const LocationAttributeMetadata: MessageFns<LocationAttributeMetadata> = {
  encode(message: LocationAttributeMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryLocation !== undefined) {
      LocationInfo.encode(message.countryLocation, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationAttributeMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationAttributeMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.countryLocation = LocationInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationAttributeMetadata {
    return {
      countryLocation: isSet(object.countryLocation) ? LocationInfo.fromJSON(object.countryLocation) : undefined,
    };
  },

  toJSON(message: LocationAttributeMetadata): unknown {
    const obj: any = {};
    if (message.countryLocation !== undefined) {
      obj.countryLocation = LocationInfo.toJSON(message.countryLocation);
    }
    return obj;
  },

  create(base?: DeepPartial<LocationAttributeMetadata>): LocationAttributeMetadata {
    return LocationAttributeMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationAttributeMetadata>): LocationAttributeMetadata {
    const message = createBaseLocationAttributeMetadata();
    message.countryLocation = (object.countryLocation !== undefined && object.countryLocation !== null)
      ? LocationInfo.fromPartial(object.countryLocation)
      : undefined;
    return message;
  },
};

function createBaseInsightsAudience(): InsightsAudience {
  return {
    countryLocations: [],
    subCountryLocations: [],
    gender: undefined,
    ageRanges: [],
    parentalStatus: undefined,
    incomeRanges: [],
    dynamicLineups: [],
    topicAudienceCombinations: [],
  };
}

export const InsightsAudience: MessageFns<InsightsAudience> = {
  encode(message: InsightsAudience, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.countryLocations) {
      LocationInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.subCountryLocations) {
      LocationInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.gender !== undefined) {
      GenderInfo.encode(message.gender, writer.uint32(26).fork()).join();
    }
    for (const v of message.ageRanges) {
      AgeRangeInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.parentalStatus !== undefined) {
      ParentalStatusInfo.encode(message.parentalStatus, writer.uint32(42).fork()).join();
    }
    for (const v of message.incomeRanges) {
      IncomeRangeInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.dynamicLineups) {
      AudienceInsightsDynamicLineup.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.topicAudienceCombinations) {
      InsightsAudienceAttributeGroup.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsightsAudience {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsightsAudience();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.countryLocations.push(LocationInfo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subCountryLocations.push(LocationInfo.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gender = GenderInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ageRanges.push(AgeRangeInfo.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.parentalStatus = ParentalStatusInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.incomeRanges.push(IncomeRangeInfo.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dynamicLineups.push(AudienceInsightsDynamicLineup.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.topicAudienceCombinations.push(InsightsAudienceAttributeGroup.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsightsAudience {
    return {
      countryLocations: globalThis.Array.isArray(object?.countryLocations)
        ? object.countryLocations.map((e: any) => LocationInfo.fromJSON(e))
        : [],
      subCountryLocations: globalThis.Array.isArray(object?.subCountryLocations)
        ? object.subCountryLocations.map((e: any) => LocationInfo.fromJSON(e))
        : [],
      gender: isSet(object.gender) ? GenderInfo.fromJSON(object.gender) : undefined,
      ageRanges: globalThis.Array.isArray(object?.ageRanges)
        ? object.ageRanges.map((e: any) => AgeRangeInfo.fromJSON(e))
        : [],
      parentalStatus: isSet(object.parentalStatus) ? ParentalStatusInfo.fromJSON(object.parentalStatus) : undefined,
      incomeRanges: globalThis.Array.isArray(object?.incomeRanges)
        ? object.incomeRanges.map((e: any) => IncomeRangeInfo.fromJSON(e))
        : [],
      dynamicLineups: globalThis.Array.isArray(object?.dynamicLineups)
        ? object.dynamicLineups.map((e: any) => AudienceInsightsDynamicLineup.fromJSON(e))
        : [],
      topicAudienceCombinations: globalThis.Array.isArray(object?.topicAudienceCombinations)
        ? object.topicAudienceCombinations.map((e: any) => InsightsAudienceAttributeGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InsightsAudience): unknown {
    const obj: any = {};
    if (message.countryLocations?.length) {
      obj.countryLocations = message.countryLocations.map((e) => LocationInfo.toJSON(e));
    }
    if (message.subCountryLocations?.length) {
      obj.subCountryLocations = message.subCountryLocations.map((e) => LocationInfo.toJSON(e));
    }
    if (message.gender !== undefined) {
      obj.gender = GenderInfo.toJSON(message.gender);
    }
    if (message.ageRanges?.length) {
      obj.ageRanges = message.ageRanges.map((e) => AgeRangeInfo.toJSON(e));
    }
    if (message.parentalStatus !== undefined) {
      obj.parentalStatus = ParentalStatusInfo.toJSON(message.parentalStatus);
    }
    if (message.incomeRanges?.length) {
      obj.incomeRanges = message.incomeRanges.map((e) => IncomeRangeInfo.toJSON(e));
    }
    if (message.dynamicLineups?.length) {
      obj.dynamicLineups = message.dynamicLineups.map((e) => AudienceInsightsDynamicLineup.toJSON(e));
    }
    if (message.topicAudienceCombinations?.length) {
      obj.topicAudienceCombinations = message.topicAudienceCombinations.map((e) =>
        InsightsAudienceAttributeGroup.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<InsightsAudience>): InsightsAudience {
    return InsightsAudience.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsightsAudience>): InsightsAudience {
    const message = createBaseInsightsAudience();
    message.countryLocations = object.countryLocations?.map((e) => LocationInfo.fromPartial(e)) || [];
    message.subCountryLocations = object.subCountryLocations?.map((e) => LocationInfo.fromPartial(e)) || [];
    message.gender = (object.gender !== undefined && object.gender !== null)
      ? GenderInfo.fromPartial(object.gender)
      : undefined;
    message.ageRanges = object.ageRanges?.map((e) => AgeRangeInfo.fromPartial(e)) || [];
    message.parentalStatus = (object.parentalStatus !== undefined && object.parentalStatus !== null)
      ? ParentalStatusInfo.fromPartial(object.parentalStatus)
      : undefined;
    message.incomeRanges = object.incomeRanges?.map((e) => IncomeRangeInfo.fromPartial(e)) || [];
    message.dynamicLineups = object.dynamicLineups?.map((e) => AudienceInsightsDynamicLineup.fromPartial(e)) || [];
    message.topicAudienceCombinations =
      object.topicAudienceCombinations?.map((e) => InsightsAudienceAttributeGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInsightsAudienceAttributeGroup(): InsightsAudienceAttributeGroup {
  return { attributes: [] };
}

export const InsightsAudienceAttributeGroup: MessageFns<InsightsAudienceAttributeGroup> = {
  encode(message: InsightsAudienceAttributeGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attributes) {
      AudienceInsightsAttribute.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsightsAudienceAttributeGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsightsAudienceAttributeGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributes.push(AudienceInsightsAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsightsAudienceAttributeGroup {
    return {
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => AudienceInsightsAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InsightsAudienceAttributeGroup): unknown {
    const obj: any = {};
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => AudienceInsightsAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<InsightsAudienceAttributeGroup>): InsightsAudienceAttributeGroup {
    return InsightsAudienceAttributeGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsightsAudienceAttributeGroup>): InsightsAudienceAttributeGroup {
    const message = createBaseInsightsAudienceAttributeGroup();
    message.attributes = object.attributes?.map((e) => AudienceInsightsAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAudienceCompositionSection(): AudienceCompositionSection {
  return { dimension: 0, topAttributes: [], clusteredAttributes: [] };
}

export const AudienceCompositionSection: MessageFns<AudienceCompositionSection> = {
  encode(message: AudienceCompositionSection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dimension !== 0) {
      writer.uint32(8).int32(message.dimension);
    }
    for (const v of message.topAttributes) {
      AudienceCompositionAttribute.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.clusteredAttributes) {
      AudienceCompositionAttributeCluster.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceCompositionSection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceCompositionSection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dimension = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.topAttributes.push(AudienceCompositionAttribute.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clusteredAttributes.push(AudienceCompositionAttributeCluster.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceCompositionSection {
    return {
      dimension: isSet(object.dimension)
        ? audienceInsightsDimensionEnum_AudienceInsightsDimensionFromJSON(object.dimension)
        : 0,
      topAttributes: globalThis.Array.isArray(object?.topAttributes)
        ? object.topAttributes.map((e: any) => AudienceCompositionAttribute.fromJSON(e))
        : [],
      clusteredAttributes: globalThis.Array.isArray(object?.clusteredAttributes)
        ? object.clusteredAttributes.map((e: any) => AudienceCompositionAttributeCluster.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AudienceCompositionSection): unknown {
    const obj: any = {};
    if (message.dimension !== 0) {
      obj.dimension = audienceInsightsDimensionEnum_AudienceInsightsDimensionToJSON(message.dimension);
    }
    if (message.topAttributes?.length) {
      obj.topAttributes = message.topAttributes.map((e) => AudienceCompositionAttribute.toJSON(e));
    }
    if (message.clusteredAttributes?.length) {
      obj.clusteredAttributes = message.clusteredAttributes.map((e) => AudienceCompositionAttributeCluster.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceCompositionSection>): AudienceCompositionSection {
    return AudienceCompositionSection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceCompositionSection>): AudienceCompositionSection {
    const message = createBaseAudienceCompositionSection();
    message.dimension = object.dimension ?? 0;
    message.topAttributes = object.topAttributes?.map((e) => AudienceCompositionAttribute.fromPartial(e)) || [];
    message.clusteredAttributes =
      object.clusteredAttributes?.map((e) => AudienceCompositionAttributeCluster.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAudienceCompositionAttributeCluster(): AudienceCompositionAttributeCluster {
  return { clusterDisplayName: "", clusterMetrics: undefined, attributes: [] };
}

export const AudienceCompositionAttributeCluster: MessageFns<AudienceCompositionAttributeCluster> = {
  encode(message: AudienceCompositionAttributeCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusterDisplayName !== "") {
      writer.uint32(10).string(message.clusterDisplayName);
    }
    if (message.clusterMetrics !== undefined) {
      AudienceCompositionMetrics.encode(message.clusterMetrics, writer.uint32(26).fork()).join();
    }
    for (const v of message.attributes) {
      AudienceCompositionAttribute.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceCompositionAttributeCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceCompositionAttributeCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clusterDisplayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterMetrics = AudienceCompositionMetrics.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.attributes.push(AudienceCompositionAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceCompositionAttributeCluster {
    return {
      clusterDisplayName: isSet(object.clusterDisplayName) ? globalThis.String(object.clusterDisplayName) : "",
      clusterMetrics: isSet(object.clusterMetrics)
        ? AudienceCompositionMetrics.fromJSON(object.clusterMetrics)
        : undefined,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => AudienceCompositionAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AudienceCompositionAttributeCluster): unknown {
    const obj: any = {};
    if (message.clusterDisplayName !== "") {
      obj.clusterDisplayName = message.clusterDisplayName;
    }
    if (message.clusterMetrics !== undefined) {
      obj.clusterMetrics = AudienceCompositionMetrics.toJSON(message.clusterMetrics);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => AudienceCompositionAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceCompositionAttributeCluster>): AudienceCompositionAttributeCluster {
    return AudienceCompositionAttributeCluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceCompositionAttributeCluster>): AudienceCompositionAttributeCluster {
    const message = createBaseAudienceCompositionAttributeCluster();
    message.clusterDisplayName = object.clusterDisplayName ?? "";
    message.clusterMetrics = (object.clusterMetrics !== undefined && object.clusterMetrics !== null)
      ? AudienceCompositionMetrics.fromPartial(object.clusterMetrics)
      : undefined;
    message.attributes = object.attributes?.map((e) => AudienceCompositionAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAudienceCompositionMetrics(): AudienceCompositionMetrics {
  return { baselineAudienceShare: 0, audienceShare: 0, index: 0, score: 0 };
}

export const AudienceCompositionMetrics: MessageFns<AudienceCompositionMetrics> = {
  encode(message: AudienceCompositionMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baselineAudienceShare !== 0) {
      writer.uint32(9).double(message.baselineAudienceShare);
    }
    if (message.audienceShare !== 0) {
      writer.uint32(17).double(message.audienceShare);
    }
    if (message.index !== 0) {
      writer.uint32(25).double(message.index);
    }
    if (message.score !== 0) {
      writer.uint32(33).double(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceCompositionMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceCompositionMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.baselineAudienceShare = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.audienceShare = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.index = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.score = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceCompositionMetrics {
    return {
      baselineAudienceShare: isSet(object.baselineAudienceShare) ? globalThis.Number(object.baselineAudienceShare) : 0,
      audienceShare: isSet(object.audienceShare) ? globalThis.Number(object.audienceShare) : 0,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
    };
  },

  toJSON(message: AudienceCompositionMetrics): unknown {
    const obj: any = {};
    if (message.baselineAudienceShare !== 0) {
      obj.baselineAudienceShare = message.baselineAudienceShare;
    }
    if (message.audienceShare !== 0) {
      obj.audienceShare = message.audienceShare;
    }
    if (message.index !== 0) {
      obj.index = message.index;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceCompositionMetrics>): AudienceCompositionMetrics {
    return AudienceCompositionMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceCompositionMetrics>): AudienceCompositionMetrics {
    const message = createBaseAudienceCompositionMetrics();
    message.baselineAudienceShare = object.baselineAudienceShare ?? 0;
    message.audienceShare = object.audienceShare ?? 0;
    message.index = object.index ?? 0;
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseAudienceCompositionAttribute(): AudienceCompositionAttribute {
  return { attributeMetadata: undefined, metrics: undefined };
}

export const AudienceCompositionAttribute: MessageFns<AudienceCompositionAttribute> = {
  encode(message: AudienceCompositionAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attributeMetadata !== undefined) {
      AudienceInsightsAttributeMetadata.encode(message.attributeMetadata, writer.uint32(10).fork()).join();
    }
    if (message.metrics !== undefined) {
      AudienceCompositionMetrics.encode(message.metrics, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceCompositionAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceCompositionAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeMetadata = AudienceInsightsAttributeMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metrics = AudienceCompositionMetrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceCompositionAttribute {
    return {
      attributeMetadata: isSet(object.attributeMetadata)
        ? AudienceInsightsAttributeMetadata.fromJSON(object.attributeMetadata)
        : undefined,
      metrics: isSet(object.metrics) ? AudienceCompositionMetrics.fromJSON(object.metrics) : undefined,
    };
  },

  toJSON(message: AudienceCompositionAttribute): unknown {
    const obj: any = {};
    if (message.attributeMetadata !== undefined) {
      obj.attributeMetadata = AudienceInsightsAttributeMetadata.toJSON(message.attributeMetadata);
    }
    if (message.metrics !== undefined) {
      obj.metrics = AudienceCompositionMetrics.toJSON(message.metrics);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceCompositionAttribute>): AudienceCompositionAttribute {
    return AudienceCompositionAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceCompositionAttribute>): AudienceCompositionAttribute {
    const message = createBaseAudienceCompositionAttribute();
    message.attributeMetadata = (object.attributeMetadata !== undefined && object.attributeMetadata !== null)
      ? AudienceInsightsAttributeMetadata.fromPartial(object.attributeMetadata)
      : undefined;
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? AudienceCompositionMetrics.fromPartial(object.metrics)
      : undefined;
    return message;
  },
};

/**
 * Audience Insights Service helps users find information about groups of
 * people and how they can be reached with Google Ads. Accessible to
 * allowlisted customers only.
 */
export type AudienceInsightsServiceDefinition = typeof AudienceInsightsServiceDefinition;
export const AudienceInsightsServiceDefinition = {
  name: "AudienceInsightsService",
  fullName: "google.ads.googleads.v17.services.AudienceInsightsService",
  methods: {
    /**
     * Creates a saved report that can be viewed in the Insights Finder tool.
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [FieldError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [QuotaError]()
     *   [RangeError]()
     *   [RequestError]()
     */
    generateInsightsFinderReport: {
      name: "GenerateInsightsFinderReport",
      requestType: GenerateInsightsFinderReportRequest,
      requestStream: false,
      responseType: GenerateInsightsFinderReportResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              44,
              98,
              97,
              115,
              101,
              108,
              105,
              110,
              101,
              95,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              44,
              115,
              112,
              101,
              99,
              105,
              102,
              105,
              99,
              95,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              64,
              58,
              1,
              42,
              34,
              59,
              47,
              118,
              49,
              55,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              61,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              73,
              110,
              115,
              105,
              103,
              104,
              116,
              115,
              70,
              105,
              110,
              100,
              101,
              114,
              82,
              101,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Searches for audience attributes that can be used to generate insights.
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [FieldError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [QuotaError]()
     *   [RangeError]()
     *   [RequestError]()
     */
    listAudienceInsightsAttributes: {
      name: "ListAudienceInsightsAttributes",
      requestType: ListAudienceInsightsAttributesRequest,
      requestStream: false,
      responseType: ListAudienceInsightsAttributesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              33,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              44,
              100,
              105,
              109,
              101,
              110,
              115,
              105,
              111,
              110,
              115,
              44,
              113,
              117,
              101,
              114,
              121,
              95,
              116,
              101,
              120,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              49,
              55,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              61,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              65,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              73,
              110,
              115,
              105,
              103,
              104,
              116,
              115,
              65,
              116,
              116,
              114,
              105,
              98,
              117,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists date ranges for which audience insights data can be requested.
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [FieldError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [QuotaError]()
     *   [RangeError]()
     *   [RequestError]()
     */
    listInsightsEligibleDates: {
      name: "ListInsightsEligibleDates",
      requestType: ListInsightsEligibleDatesRequest,
      requestStream: false,
      responseType: ListInsightsEligibleDatesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              49,
              55,
              47,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              73,
              110,
              115,
              105,
              103,
              104,
              116,
              115,
              58,
              108,
              105,
              115,
              116,
              73,
              110,
              115,
              105,
              103,
              104,
              116,
              115,
              69,
              108,
              105,
              103,
              105,
              98,
              108,
              101,
              68,
              97,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns a collection of attributes that are represented in an audience of
     * interest, with metrics that compare each attribute's share of the audience
     * with its share of a baseline audience.
     *
     * List of thrown errors:
     *   [AudienceInsightsError]()
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [FieldError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [QuotaError]()
     *   [RangeError]()
     *   [RequestError]()
     */
    generateAudienceCompositionInsights: {
      name: "GenerateAudienceCompositionInsights",
      requestType: GenerateAudienceCompositionInsightsRequest,
      requestStream: false,
      responseType: GenerateAudienceCompositionInsightsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              31,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              44,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              44,
              100,
              105,
              109,
              101,
              110,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              1,
              42,
              34,
              66,
              47,
              118,
              49,
              55,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              61,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              65,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              67,
              111,
              109,
              112,
              111,
              115,
              105,
              116,
              105,
              111,
              110,
              73,
              110,
              115,
              105,
              103,
              104,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns a collection of targeting insights (e.g. targetable audiences) that
     * are relevant to the requested audience.
     *
     * List of thrown errors:
     *   [AudienceInsightsError]()
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [FieldError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [QuotaError]()
     *   [RangeError]()
     *   [RequestError]()
     */
    generateSuggestedTargetingInsights: {
      name: "GenerateSuggestedTargetingInsights",
      requestType: GenerateSuggestedTargetingInsightsRequest,
      requestStream: false,
      responseType: GenerateSuggestedTargetingInsightsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              44,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              70,
              58,
              1,
              42,
              34,
              65,
              47,
              118,
              49,
              55,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              61,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              83,
              117,
              103,
              103,
              101,
              115,
              116,
              101,
              100,
              84,
              97,
              114,
              103,
              101,
              116,
              105,
              110,
              103,
              73,
              110,
              115,
              105,
              103,
              104,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns a collection of audience attributes along with estimates of the
     * overlap between their potential YouTube reach and that of a given input
     * attribute.
     *
     * List of thrown errors:
     *   [AudienceInsightsError]()
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [FieldError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [QuotaError]()
     *   [RangeError]()
     *   [RequestError]()
     */
    generateAudienceOverlapInsights: {
      name: "GenerateAudienceOverlapInsights",
      requestType: GenerateAudienceOverlapInsightsRequest,
      requestStream: false,
      responseType: GenerateAudienceOverlapInsightsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              57,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              44,
              99,
              111,
              117,
              110,
              116,
              114,
              121,
              95,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              44,
              112,
              114,
              105,
              109,
              97,
              114,
              121,
              95,
              97,
              116,
              116,
              114,
              105,
              98,
              117,
              116,
              101,
              44,
              100,
              105,
              109,
              101,
              110,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              67,
              58,
              1,
              42,
              34,
              62,
              47,
              118,
              49,
              55,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              61,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              65,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              79,
              118,
              101,
              114,
              108,
              97,
              112,
              73,
              110,
              115,
              105,
              103,
              104,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AudienceInsightsServiceImplementation<CallContextExt = {}> {
  /**
   * Creates a saved report that can be viewed in the Insights Finder tool.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [RequestError]()
   */
  generateInsightsFinderReport(
    request: GenerateInsightsFinderReportRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateInsightsFinderReportResponse>>;
  /**
   * Searches for audience attributes that can be used to generate insights.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [RequestError]()
   */
  listAudienceInsightsAttributes(
    request: ListAudienceInsightsAttributesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAudienceInsightsAttributesResponse>>;
  /**
   * Lists date ranges for which audience insights data can be requested.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [RequestError]()
   */
  listInsightsEligibleDates(
    request: ListInsightsEligibleDatesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInsightsEligibleDatesResponse>>;
  /**
   * Returns a collection of attributes that are represented in an audience of
   * interest, with metrics that compare each attribute's share of the audience
   * with its share of a baseline audience.
   *
   * List of thrown errors:
   *   [AudienceInsightsError]()
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [RequestError]()
   */
  generateAudienceCompositionInsights(
    request: GenerateAudienceCompositionInsightsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateAudienceCompositionInsightsResponse>>;
  /**
   * Returns a collection of targeting insights (e.g. targetable audiences) that
   * are relevant to the requested audience.
   *
   * List of thrown errors:
   *   [AudienceInsightsError]()
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [RequestError]()
   */
  generateSuggestedTargetingInsights(
    request: GenerateSuggestedTargetingInsightsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateSuggestedTargetingInsightsResponse>>;
  /**
   * Returns a collection of audience attributes along with estimates of the
   * overlap between their potential YouTube reach and that of a given input
   * attribute.
   *
   * List of thrown errors:
   *   [AudienceInsightsError]()
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [RequestError]()
   */
  generateAudienceOverlapInsights(
    request: GenerateAudienceOverlapInsightsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateAudienceOverlapInsightsResponse>>;
}

export interface AudienceInsightsServiceClient<CallOptionsExt = {}> {
  /**
   * Creates a saved report that can be viewed in the Insights Finder tool.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [RequestError]()
   */
  generateInsightsFinderReport(
    request: DeepPartial<GenerateInsightsFinderReportRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateInsightsFinderReportResponse>;
  /**
   * Searches for audience attributes that can be used to generate insights.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [RequestError]()
   */
  listAudienceInsightsAttributes(
    request: DeepPartial<ListAudienceInsightsAttributesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAudienceInsightsAttributesResponse>;
  /**
   * Lists date ranges for which audience insights data can be requested.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [RequestError]()
   */
  listInsightsEligibleDates(
    request: DeepPartial<ListInsightsEligibleDatesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInsightsEligibleDatesResponse>;
  /**
   * Returns a collection of attributes that are represented in an audience of
   * interest, with metrics that compare each attribute's share of the audience
   * with its share of a baseline audience.
   *
   * List of thrown errors:
   *   [AudienceInsightsError]()
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [RequestError]()
   */
  generateAudienceCompositionInsights(
    request: DeepPartial<GenerateAudienceCompositionInsightsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateAudienceCompositionInsightsResponse>;
  /**
   * Returns a collection of targeting insights (e.g. targetable audiences) that
   * are relevant to the requested audience.
   *
   * List of thrown errors:
   *   [AudienceInsightsError]()
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [RequestError]()
   */
  generateSuggestedTargetingInsights(
    request: DeepPartial<GenerateSuggestedTargetingInsightsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateSuggestedTargetingInsightsResponse>;
  /**
   * Returns a collection of audience attributes along with estimates of the
   * overlap between their potential YouTube reach and that of a given input
   * attribute.
   *
   * List of thrown errors:
   *   [AudienceInsightsError]()
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [RequestError]()
   */
  generateAudienceOverlapInsights(
    request: DeepPartial<GenerateAudienceOverlapInsightsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateAudienceOverlapInsightsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
