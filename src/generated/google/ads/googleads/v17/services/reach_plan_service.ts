// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v17/services/reach_plan_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { DeviceInfo, GenderInfo, UserInterestInfo } from "../common/criteria.js";
import { DateRange } from "../common/dates.js";
import {
  FrequencyCapTimeUnitEnum_FrequencyCapTimeUnit,
  frequencyCapTimeUnitEnum_FrequencyCapTimeUnitFromJSON,
  frequencyCapTimeUnitEnum_FrequencyCapTimeUnitToJSON,
} from "../enums/frequency_cap_time_unit.js";
import {
  ReachPlanAgeRangeEnum_ReachPlanAgeRange,
  reachPlanAgeRangeEnum_ReachPlanAgeRangeFromJSON,
  reachPlanAgeRangeEnum_ReachPlanAgeRangeToJSON,
} from "../enums/reach_plan_age_range.js";
import {
  ReachPlanNetworkEnum_ReachPlanNetwork,
  reachPlanNetworkEnum_ReachPlanNetworkFromJSON,
  reachPlanNetworkEnum_ReachPlanNetworkToJSON,
} from "../enums/reach_plan_network.js";
import {
  ReachPlanSurfaceEnum_ReachPlanSurface,
  reachPlanSurfaceEnum_ReachPlanSurfaceFromJSON,
  reachPlanSurfaceEnum_ReachPlanSurfaceToJSON,
} from "../enums/reach_plan_surface.js";
import {
  TargetFrequencyTimeUnitEnum_TargetFrequencyTimeUnit,
  targetFrequencyTimeUnitEnum_TargetFrequencyTimeUnitFromJSON,
  targetFrequencyTimeUnitEnum_TargetFrequencyTimeUnitToJSON,
} from "../enums/target_frequency_time_unit.js";

export const protobufPackage = "google.ads.googleads.v17.services";

/**
 * Request message for
 * [ReachPlanService.ListPlannableLocations][google.ads.googleads.v17.services.ReachPlanService.ListPlannableLocations].
 */
export interface ListPlannableLocationsRequest {
}

/** The list of plannable locations. */
export interface ListPlannableLocationsResponse {
  /**
   * The list of locations available for planning.
   * See
   * https://developers.google.com/google-ads/api/reference/data/geotargets
   * for sample locations.
   */
  plannableLocations: PlannableLocation[];
}

/** A plannable location: country, metro region, province, etc. */
export interface PlannableLocation {
  /** The location identifier. */
  id?:
    | string
    | undefined;
  /** The unique location name in English. */
  name?:
    | string
    | undefined;
  /**
   * The parent country (not present if location is a country).
   * If present, will always be a GeoTargetConstant ID. Additional information
   * such as country name is provided by
   * [ReachPlanService.ListPlannableLocations][google.ads.googleads.v17.services.ReachPlanService.ListPlannableLocations]
   * or GoogleAdsService.Search/SearchStream.
   */
  parentCountryId?:
    | Long
    | undefined;
  /** The ISO-3166-1 alpha-2 country code that is associated with the location. */
  countryCode?:
    | string
    | undefined;
  /**
   * The location's type. Location types correspond to target_type returned by
   * searching location type in GoogleAdsService.Search/SearchStream.
   */
  locationType?: string | undefined;
}

/** Request to list available products in a given location. */
export interface ListPlannableProductsRequest {
  /**
   * Required. The ID of the selected location for planning. To list the
   * available plannable location IDs use
   * [ReachPlanService.ListPlannableLocations][google.ads.googleads.v17.services.ReachPlanService.ListPlannableLocations].
   */
  plannableLocationId: string;
}

/** A response with all available products. */
export interface ListPlannableProductsResponse {
  /** The list of products available for planning and related targeting metadata. */
  productMetadata: ProductMetadata[];
}

/** The metadata associated with an available plannable product. */
export interface ProductMetadata {
  /**
   * The code associated with the ad product (for example: BUMPER,
   * TRUEVIEW_IN_STREAM).
   * To list the available plannable product codes use
   * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v17.services.ReachPlanService.ListPlannableProducts].
   */
  plannableProductCode?:
    | string
    | undefined;
  /** The name associated with the ad product. */
  plannableProductName: string;
  /** The allowed plannable targeting for this product. */
  plannableTargeting: PlannableTargeting | undefined;
}

/** The targeting for which traffic metrics will be reported. */
export interface PlannableTargeting {
  /**
   * Allowed plannable age ranges for the product for which metrics will be
   * reported. Actual targeting is computed by mapping this age range onto
   * standard Google common.AgeRangeInfo values.
   */
  ageRanges: ReachPlanAgeRangeEnum_ReachPlanAgeRange[];
  /** Targetable genders for the ad product. */
  genders: GenderInfo[];
  /**
   * Targetable devices for the ad product.
   * TABLET device targeting is automatically applied to reported metrics
   * when MOBILE targeting is selected for CPM_MASTHEAD,
   * GOOGLE_PREFERRED_BUMPER, and GOOGLE_PREFERRED_SHORT products.
   */
  devices: DeviceInfo[];
  /** Targetable networks for the ad product. */
  networks: ReachPlanNetworkEnum_ReachPlanNetwork[];
  /** Targetable YouTube Select Lineups for the ad product. */
  youtubeSelectLineups: YouTubeSelectLineUp[];
  /** Targetable surface combinations for the ad product. */
  surfaceTargeting: SurfaceTargetingCombinations | undefined;
}

/**
 * Request message for
 * [ReachPlanService.GenerateReachForecast][google.ads.googleads.v17.services.ReachPlanService.GenerateReachForecast].
 */
export interface GenerateReachForecastRequest {
  /** Required. The ID of the customer. */
  customerId: string;
  /**
   * The currency code.
   * Three-character ISO 4217 currency code.
   */
  currencyCode?:
    | string
    | undefined;
  /** Required. Campaign duration. */
  campaignDuration:
    | CampaignDuration
    | undefined;
  /**
   * Chosen cookie frequency cap to be applied to each planned product.
   * This is equivalent to the frequency cap exposed in Google Ads when creating
   * a campaign, it represents the maximum number of times an ad can be shown to
   * the same user.
   * If not specified, no cap is applied.
   *
   * This field is deprecated in v4 and will eventually be removed.
   * Use cookie_frequency_cap_setting instead.
   */
  cookieFrequencyCap?:
    | number
    | undefined;
  /**
   * Chosen cookie frequency cap to be applied to each planned product.
   * This is equivalent to the frequency cap exposed in Google Ads when creating
   * a campaign, it represents the maximum number of times an ad can be shown to
   * the same user during a specified time interval.
   * If not specified, a default of 0 (no cap) is applied.
   *
   * This field replaces the deprecated cookie_frequency_cap field.
   */
  cookieFrequencyCapSetting:
    | FrequencyCap
    | undefined;
  /**
   * Chosen minimum effective frequency (the number of times a person was
   * exposed to the ad) for the reported reach metrics [1-10].
   * This won't affect the targeting, but just the reporting.
   * If not specified, a default of 1 is applied.
   *
   * This field cannot be combined with the effective_frequency_limit field.
   */
  minEffectiveFrequency?:
    | number
    | undefined;
  /**
   * The highest minimum effective frequency (the number of times a person was
   * exposed to the ad) value [1-10] to include in
   * Forecast.effective_frequency_breakdowns.
   * If not specified, Forecast.effective_frequency_breakdowns will not be
   * provided.
   *
   * The effective frequency value provided here will also be used as the
   * minimum effective frequency for the reported reach metrics.
   *
   * This field cannot be combined with the min_effective_frequency field.
   */
  effectiveFrequencyLimit?:
    | EffectiveFrequencyLimit
    | undefined;
  /**
   * The targeting to be applied to all products selected in the product mix.
   *
   * This is planned targeting: execution details might vary based on the
   * advertising product, consult an implementation specialist.
   *
   * See specific metrics for details on how targeting affects them.
   */
  targeting:
    | Targeting
    | undefined;
  /**
   * Required. The products to be forecast.
   * The max number of allowed planned products is 15.
   */
  plannedProducts: PlannedProduct[];
  /** Controls the forecast metrics returned in the response. */
  forecastMetricOptions:
    | ForecastMetricOptions
    | undefined;
  /** The name of the customer being planned for. This is a user-defined value. */
  customerReachGroup?: string | undefined;
}

/** Effective frequency limit. */
export interface EffectiveFrequencyLimit {
  /**
   * The highest effective frequency value to include in
   * Forecast.effective_frequency_breakdowns.
   * This field supports frequencies 1-10, inclusive.
   */
  effectiveFrequencyBreakdownLimit: number;
}

/**
 * A rule specifying the maximum number of times an ad can be shown to a user
 * over a particular time period.
 */
export interface FrequencyCap {
  /** Required. The number of impressions, inclusive. */
  impressions: number;
  /** Required. The type of time unit. */
  timeUnit: FrequencyCapTimeUnitEnum_FrequencyCapTimeUnit;
}

/** The targeting for which traffic metrics will be reported. */
export interface Targeting {
  /**
   * The ID of the selected location. Plannable location IDs can be
   * obtained from
   * [ReachPlanService.ListPlannableLocations][google.ads.googleads.v17.services.ReachPlanService.ListPlannableLocations].
   *
   * Requests must set either this field or `plannable_location_ids`.
   *
   * This field is deprecated as of V12 and will be removed in a future release.
   * Use `plannable_location_ids` instead.
   */
  plannableLocationId?:
    | string
    | undefined;
  /**
   * The list of plannable location IDs to target with this forecast.
   *
   * If more than one ID is provided, all IDs must have the same
   * `parent_country_id`. Planning for more than `parent_county` is not
   * supported. Plannable location IDs and their `parent_country_id` can be
   * obtained from
   * [ReachPlanService.ListPlannableLocations][google.ads.googleads.v17.services.ReachPlanService.ListPlannableLocations].
   *
   * Requests must set either this field or `plannable_location_id`.
   */
  plannableLocationIds: string[];
  /**
   * Targeted age range.
   * An unset value is equivalent to targeting all ages.
   */
  ageRange: ReachPlanAgeRangeEnum_ReachPlanAgeRange;
  /**
   * Targeted genders.
   * An unset value is equivalent to targeting MALE and FEMALE.
   */
  genders: GenderInfo[];
  /**
   * Targeted devices.
   * If not specified, targets all applicable devices. Applicable devices vary
   * by product and region and can be obtained from
   * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v17.services.ReachPlanService.ListPlannableProducts].
   */
  devices: DeviceInfo[];
  /**
   * Targetable network for the ad product.
   * If not specified, targets all applicable networks. Applicable networks vary
   * by product and region and can be obtained from
   * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v17.services.ReachPlanService.ListPlannableProducts].
   */
  network: ReachPlanNetworkEnum_ReachPlanNetwork;
  /**
   * Targeted audiences.
   * If not specified, does not target any specific audience.
   */
  audienceTargeting: AudienceTargeting | undefined;
}

/** The duration of a planned campaign. */
export interface CampaignDuration {
  /**
   * The duration value in days.
   *
   * This field cannot be combined with the date_range field.
   */
  durationInDays?:
    | number
    | undefined;
  /**
   * Date range of the campaign.
   * Dates are in the yyyy-mm-dd format and inclusive.
   * The end date must be < 1 year in the future and the
   * date range must be <= 92 days long.
   *
   * This field cannot be combined with the duration_in_days field.
   */
  dateRange: DateRange | undefined;
}

/** A product being planned for reach. */
export interface PlannedProduct {
  /**
   * Required. Selected product for planning.
   * The code associated with the ad product (for example: Trueview, Bumper).
   * To list the available plannable product codes use
   * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v17.services.ReachPlanService.ListPlannableProducts].
   */
  plannableProductCode?:
    | string
    | undefined;
  /**
   * Required. Maximum budget allocation in micros for the selected product.
   * The value is specified in the selected planning currency_code.
   * For example: 1 000 000$ = 1 000 000 000 000 micros.
   */
  budgetMicros?:
    | Long
    | undefined;
  /**
   * Targeting settings for the selected product.
   * To list the available targeting for each product use
   * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v17.services.ReachPlanService.ListPlannableProducts].
   */
  advancedProductTargeting: AdvancedProductTargeting | undefined;
}

/** Response message containing the generated reach curve. */
export interface GenerateReachForecastResponse {
  /** Reference on target audiences for this curve. */
  onTargetAudienceMetrics:
    | OnTargetAudienceMetrics
    | undefined;
  /** The generated reach curve for the planned product mix. */
  reachCurve: ReachCurve | undefined;
}

/** The reach curve for the planned products. */
export interface ReachCurve {
  /** All points on the reach curve. */
  reachForecasts: ReachForecast[];
}

/** A point on reach curve. */
export interface ReachForecast {
  /** The cost in micros. */
  costMicros: Long;
  /** Forecasted traffic metrics for this point. */
  forecast:
    | Forecast
    | undefined;
  /**
   * The forecasted allocation and traffic metrics for each planned product
   * at this point on the reach curve.
   */
  plannedProductReachForecasts: PlannedProductReachForecast[];
}

/** Forecasted traffic metrics for the planned products and targeting. */
export interface Forecast {
  /**
   * Number of unique people reached at least
   * GenerateReachForecastRequest.min_effective_frequency or
   * GenerateReachForecastRequest.effective_frequency_limit times that exactly
   * matches the Targeting.
   *
   * Note that a minimum number of unique people must be reached in order for
   * data to be reported. If the minimum number is not met, the on_target_reach
   * value will be rounded to 0.
   */
  onTargetReach?:
    | Long
    | undefined;
  /**
   * Total number of unique people reached at least
   * GenerateReachForecastRequest.min_effective_frequency or
   * GenerateReachForecastRequest.effective_frequency_limit times. This includes
   * people that may fall outside the specified Targeting.
   *
   * Note that a minimum number of unique people must be reached in order for
   * data to be reported. If the minimum number is not met, the total_reach
   * value will be rounded to 0.
   */
  totalReach?:
    | Long
    | undefined;
  /** Number of ad impressions that exactly matches the Targeting. */
  onTargetImpressions?:
    | Long
    | undefined;
  /**
   * Total number of ad impressions. This includes impressions that may fall
   * outside the specified Targeting, due to insufficient information on
   * signed-in users.
   */
  totalImpressions?:
    | Long
    | undefined;
  /**
   * Number of times the ad's impressions were considered viewable.
   * See https://support.google.com/google-ads/answer/7029393 for
   * more information about what makes an ad viewable and how
   * viewability is measured.
   */
  viewableImpressions?:
    | Long
    | undefined;
  /**
   * A list of effective frequency forecasts. The list is ordered starting with
   * 1+ and ending with the value set in
   * GenerateReachForecastRequest.effective_frequency_limit. If no
   * effective_frequency_limit was set, this list will be empty.
   */
  effectiveFrequencyBreakdowns: EffectiveFrequencyBreakdown[];
  /**
   * Number of unique people reached that exactly matches the Targeting
   * including co-viewers.
   */
  onTargetCoviewReach?:
    | Long
    | undefined;
  /**
   * Number of unique people reached including co-viewers. This includes
   * people that may fall outside the specified Targeting.
   */
  totalCoviewReach?:
    | Long
    | undefined;
  /**
   * Number of ad impressions that exactly matches the Targeting including
   * co-viewers.
   */
  onTargetCoviewImpressions?:
    | Long
    | undefined;
  /**
   * Total number of ad impressions including co-viewers. This includes
   * impressions that may fall outside the specified Targeting, due to
   * insufficient information on signed-in users.
   */
  totalCoviewImpressions?:
    | Long
    | undefined;
  /**
   * Number of ad views forecasted for the specified product and targeting.
   * A view is counted when a viewer views a larger portion or the entirety of
   * an ad beyond an impression.
   *
   * See https://support.google.com/google-ads/answer/2375431 for
   * more information on views.
   */
  views?: Long | undefined;
}

/**
 * The forecasted allocation and traffic metrics for a specific product
 * at a point on the reach curve.
 */
export interface PlannedProductReachForecast {
  /**
   * Selected product for planning. The product codes returned are within the
   * set of the ones returned by ListPlannableProducts when using the same
   * location ID.
   */
  plannableProductCode: string;
  /**
   * The cost in micros. This may differ from the product's input allocation
   * if one or more planned products cannot fulfill the budget because of
   * limited inventory.
   */
  costMicros: Long;
  /** Forecasted traffic metrics for this product. */
  plannedProductForecast: PlannedProductForecast | undefined;
}

/** Forecasted traffic metrics for a planned product. */
export interface PlannedProductForecast {
  /**
   * Number of unique people reached that exactly matches the Targeting.
   *
   * Note that a minimum number of unique people must be reached in order for
   * data to be reported. If the minimum number is not met, the on_target_reach
   * value will be rounded to 0.
   */
  onTargetReach: Long;
  /**
   * Number of unique people reached. This includes people that may fall
   * outside the specified Targeting.
   *
   * Note that a minimum number of unique people must be reached in order for
   * data to be reported. If the minimum number is not met, the total_reach
   * value will be rounded to 0.
   */
  totalReach: Long;
  /** Number of ad impressions that exactly matches the Targeting. */
  onTargetImpressions: Long;
  /**
   * Total number of ad impressions. This includes impressions that may fall
   * outside the specified Targeting, due to insufficient information on
   * signed-in users.
   */
  totalImpressions: Long;
  /**
   * Number of times the ad's impressions were considered viewable.
   * See https://support.google.com/google-ads/answer/7029393 for
   * more information about what makes an ad viewable and how
   * viewability is measured.
   */
  viewableImpressions?:
    | Long
    | undefined;
  /**
   * Number of unique people reached that exactly matches the Targeting
   * including co-viewers.
   */
  onTargetCoviewReach?:
    | Long
    | undefined;
  /**
   * Number of unique people reached including co-viewers. This includes
   * people that may fall outside the specified Targeting.
   */
  totalCoviewReach?:
    | Long
    | undefined;
  /**
   * Number of ad impressions that exactly matches the Targeting including
   * co-viewers.
   */
  onTargetCoviewImpressions?:
    | Long
    | undefined;
  /**
   * Total number of ad impressions including co-viewers. This includes
   * impressions that may fall outside the specified Targeting, due to
   * insufficient information on signed-in users.
   */
  totalCoviewImpressions?:
    | Long
    | undefined;
  /**
   * The number of times per selected time unit a user will see an ad, averaged
   * over the number of time units in the forecast length. This field will only
   * be populated for a Target Frequency campaign.
   *
   * See https://support.google.com/google-ads/answer/12400225 for more
   * information about Target Frequency campaigns.
   */
  averageFrequency?:
    | number
    | undefined;
  /**
   * Number of ad views forecasted for the specified product and targeting.
   * A view is counted when a viewer views a larger portion or the entirety of
   * an ad beyond an impression.
   *
   * See https://support.google.com/google-ads/answer/2375431 for
   * more information on views.
   */
  views?: Long | undefined;
}

/**
 * Audience metrics for the planned products.
 * These metrics consider the following targeting dimensions:
 *
 * - Location
 * - PlannableAgeRange
 * - Gender
 * - AudienceTargeting (only for youtube_audience_size)
 */
export interface OnTargetAudienceMetrics {
  /** Reference audience size matching the considered targeting for YouTube. */
  youtubeAudienceSize?:
    | Long
    | undefined;
  /** Reference audience size matching the considered targeting for Census. */
  censusAudienceSize?: Long | undefined;
}

/**
 * A breakdown of the number of unique people reached at a given effective
 * frequency.
 */
export interface EffectiveFrequencyBreakdown {
  /** The effective frequency [1-10]. */
  effectiveFrequency: number;
  /**
   * The number of unique people reached at least effective_frequency times that
   * exactly matches the Targeting.
   *
   * Note that a minimum number of unique people must be reached in order for
   * data to be reported. If the minimum number is not met, the on_target_reach
   * value will be rounded to 0.
   */
  onTargetReach: Long;
  /**
   * Total number of unique people reached at least effective_frequency times.
   * This includes people that may fall outside the specified Targeting.
   *
   * Note that a minimum number of unique people must be reached in order for
   * data to be reported. If the minimum number is not met, the total_reach
   * value will be rounded to 0.
   */
  totalReach: Long;
  /**
   * The number of users (including co-viewing users) reached for the associated
   * effective_frequency value.
   */
  effectiveCoviewReach?:
    | Long
    | undefined;
  /**
   * The number of users (including co-viewing users) reached for the associated
   * effective_frequency value within the specified plan demographic.
   */
  onTargetEffectiveCoviewReach?: Long | undefined;
}

/** Controls forecast metrics to return. */
export interface ForecastMetricOptions {
  /** Indicates whether to include co-view metrics in the response forecast. */
  includeCoview: boolean;
}

/** Audience targeting for reach forecast. */
export interface AudienceTargeting {
  /** List of audiences based on user interests to be targeted. */
  userInterest: UserInterestInfo[];
}

/** Advanced targeting settings for products. */
export interface AdvancedProductTargeting {
  /** Surface targeting settings for this product. */
  surfaceTargetingSettings:
    | SurfaceTargeting
    | undefined;
  /**
   * Settings for a Target frequency campaign. Must be set when selecting the
   * TARGET_FREQUENCY product.
   *
   * See https://support.google.com/google-ads/answer/12400225 for more
   * information about Target Frequency campaigns.
   */
  targetFrequencySettings:
    | TargetFrequencySettings
    | undefined;
  /** Settings for YouTube Select targeting. */
  youtubeSelectSettings?: YouTubeSelectSettings | undefined;
}

/** Request settings for YouTube Select Lineups */
export interface YouTubeSelectSettings {
  /** Lineup for YouTube Select Targeting. */
  lineupId: Long;
}

/** A Plannable YouTube Select Lineup for product targeting. */
export interface YouTubeSelectLineUp {
  /** The ID of the YouTube Select Lineup. */
  lineupId: Long;
  /** The unique name of the YouTube Select Lineup. */
  lineupName: string;
}

/** The surface targeting combinations available for an ad product. */
export interface SurfaceTargetingCombinations {
  /** Default surface targeting applied to the ad product. */
  defaultTargeting:
    | SurfaceTargeting
    | undefined;
  /** Available surface target combinations for the ad product. */
  availableTargetingCombinations: SurfaceTargeting[];
}

/**
 * Container for surfaces for a product. Surfaces refer to the available types
 * of ad inventories such as In-Feed, In-Stream, and Shorts.
 */
export interface SurfaceTargeting {
  /** List of surfaces available to target. */
  surfaces: ReachPlanSurfaceEnum_ReachPlanSurface[];
}

/** Target Frequency settings for a supported product. */
export interface TargetFrequencySettings {
  /**
   * Required. The time unit used to describe the time frame for
   * target_frequency.
   */
  timeUnit: TargetFrequencyTimeUnitEnum_TargetFrequencyTimeUnit;
  /** Required. The target frequency goal per selected time unit. */
  targetFrequency: number;
}

function createBaseListPlannableLocationsRequest(): ListPlannableLocationsRequest {
  return {};
}

export const ListPlannableLocationsRequest: MessageFns<ListPlannableLocationsRequest> = {
  encode(_: ListPlannableLocationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPlannableLocationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPlannableLocationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListPlannableLocationsRequest {
    return {};
  },

  toJSON(_: ListPlannableLocationsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ListPlannableLocationsRequest>): ListPlannableLocationsRequest {
    return ListPlannableLocationsRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ListPlannableLocationsRequest>): ListPlannableLocationsRequest {
    const message = createBaseListPlannableLocationsRequest();
    return message;
  },
};

function createBaseListPlannableLocationsResponse(): ListPlannableLocationsResponse {
  return { plannableLocations: [] };
}

export const ListPlannableLocationsResponse: MessageFns<ListPlannableLocationsResponse> = {
  encode(message: ListPlannableLocationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.plannableLocations) {
      PlannableLocation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPlannableLocationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPlannableLocationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.plannableLocations.push(PlannableLocation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPlannableLocationsResponse {
    return {
      plannableLocations: globalThis.Array.isArray(object?.plannableLocations)
        ? object.plannableLocations.map((e: any) => PlannableLocation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListPlannableLocationsResponse): unknown {
    const obj: any = {};
    if (message.plannableLocations?.length) {
      obj.plannableLocations = message.plannableLocations.map((e) => PlannableLocation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListPlannableLocationsResponse>): ListPlannableLocationsResponse {
    return ListPlannableLocationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPlannableLocationsResponse>): ListPlannableLocationsResponse {
    const message = createBaseListPlannableLocationsResponse();
    message.plannableLocations = object.plannableLocations?.map((e) => PlannableLocation.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlannableLocation(): PlannableLocation {
  return {
    id: undefined,
    name: undefined,
    parentCountryId: undefined,
    countryCode: undefined,
    locationType: undefined,
  };
}

export const PlannableLocation: MessageFns<PlannableLocation> = {
  encode(message: PlannableLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(34).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(42).string(message.name);
    }
    if (message.parentCountryId !== undefined) {
      writer.uint32(48).int64(message.parentCountryId.toString());
    }
    if (message.countryCode !== undefined) {
      writer.uint32(58).string(message.countryCode);
    }
    if (message.locationType !== undefined) {
      writer.uint32(66).string(message.locationType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannableLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannableLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.parentCountryId = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.locationType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlannableLocation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      parentCountryId: isSet(object.parentCountryId) ? Long.fromValue(object.parentCountryId) : undefined,
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : undefined,
      locationType: isSet(object.locationType) ? globalThis.String(object.locationType) : undefined,
    };
  },

  toJSON(message: PlannableLocation): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.parentCountryId !== undefined) {
      obj.parentCountryId = (message.parentCountryId || Long.ZERO).toString();
    }
    if (message.countryCode !== undefined) {
      obj.countryCode = message.countryCode;
    }
    if (message.locationType !== undefined) {
      obj.locationType = message.locationType;
    }
    return obj;
  },

  create(base?: DeepPartial<PlannableLocation>): PlannableLocation {
    return PlannableLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlannableLocation>): PlannableLocation {
    const message = createBasePlannableLocation();
    message.id = object.id ?? undefined;
    message.name = object.name ?? undefined;
    message.parentCountryId = (object.parentCountryId !== undefined && object.parentCountryId !== null)
      ? Long.fromValue(object.parentCountryId)
      : undefined;
    message.countryCode = object.countryCode ?? undefined;
    message.locationType = object.locationType ?? undefined;
    return message;
  },
};

function createBaseListPlannableProductsRequest(): ListPlannableProductsRequest {
  return { plannableLocationId: "" };
}

export const ListPlannableProductsRequest: MessageFns<ListPlannableProductsRequest> = {
  encode(message: ListPlannableProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plannableLocationId !== "") {
      writer.uint32(18).string(message.plannableLocationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPlannableProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPlannableProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.plannableLocationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPlannableProductsRequest {
    return {
      plannableLocationId: isSet(object.plannableLocationId) ? globalThis.String(object.plannableLocationId) : "",
    };
  },

  toJSON(message: ListPlannableProductsRequest): unknown {
    const obj: any = {};
    if (message.plannableLocationId !== "") {
      obj.plannableLocationId = message.plannableLocationId;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPlannableProductsRequest>): ListPlannableProductsRequest {
    return ListPlannableProductsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPlannableProductsRequest>): ListPlannableProductsRequest {
    const message = createBaseListPlannableProductsRequest();
    message.plannableLocationId = object.plannableLocationId ?? "";
    return message;
  },
};

function createBaseListPlannableProductsResponse(): ListPlannableProductsResponse {
  return { productMetadata: [] };
}

export const ListPlannableProductsResponse: MessageFns<ListPlannableProductsResponse> = {
  encode(message: ListPlannableProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.productMetadata) {
      ProductMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPlannableProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPlannableProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.productMetadata.push(ProductMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPlannableProductsResponse {
    return {
      productMetadata: globalThis.Array.isArray(object?.productMetadata)
        ? object.productMetadata.map((e: any) => ProductMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListPlannableProductsResponse): unknown {
    const obj: any = {};
    if (message.productMetadata?.length) {
      obj.productMetadata = message.productMetadata.map((e) => ProductMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListPlannableProductsResponse>): ListPlannableProductsResponse {
    return ListPlannableProductsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPlannableProductsResponse>): ListPlannableProductsResponse {
    const message = createBaseListPlannableProductsResponse();
    message.productMetadata = object.productMetadata?.map((e) => ProductMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProductMetadata(): ProductMetadata {
  return { plannableProductCode: undefined, plannableProductName: "", plannableTargeting: undefined };
}

export const ProductMetadata: MessageFns<ProductMetadata> = {
  encode(message: ProductMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plannableProductCode !== undefined) {
      writer.uint32(34).string(message.plannableProductCode);
    }
    if (message.plannableProductName !== "") {
      writer.uint32(26).string(message.plannableProductName);
    }
    if (message.plannableTargeting !== undefined) {
      PlannableTargeting.encode(message.plannableTargeting, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.plannableProductCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.plannableProductName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.plannableTargeting = PlannableTargeting.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductMetadata {
    return {
      plannableProductCode: isSet(object.plannableProductCode)
        ? globalThis.String(object.plannableProductCode)
        : undefined,
      plannableProductName: isSet(object.plannableProductName) ? globalThis.String(object.plannableProductName) : "",
      plannableTargeting: isSet(object.plannableTargeting)
        ? PlannableTargeting.fromJSON(object.plannableTargeting)
        : undefined,
    };
  },

  toJSON(message: ProductMetadata): unknown {
    const obj: any = {};
    if (message.plannableProductCode !== undefined) {
      obj.plannableProductCode = message.plannableProductCode;
    }
    if (message.plannableProductName !== "") {
      obj.plannableProductName = message.plannableProductName;
    }
    if (message.plannableTargeting !== undefined) {
      obj.plannableTargeting = PlannableTargeting.toJSON(message.plannableTargeting);
    }
    return obj;
  },

  create(base?: DeepPartial<ProductMetadata>): ProductMetadata {
    return ProductMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductMetadata>): ProductMetadata {
    const message = createBaseProductMetadata();
    message.plannableProductCode = object.plannableProductCode ?? undefined;
    message.plannableProductName = object.plannableProductName ?? "";
    message.plannableTargeting = (object.plannableTargeting !== undefined && object.plannableTargeting !== null)
      ? PlannableTargeting.fromPartial(object.plannableTargeting)
      : undefined;
    return message;
  },
};

function createBasePlannableTargeting(): PlannableTargeting {
  return {
    ageRanges: [],
    genders: [],
    devices: [],
    networks: [],
    youtubeSelectLineups: [],
    surfaceTargeting: undefined,
  };
}

export const PlannableTargeting: MessageFns<PlannableTargeting> = {
  encode(message: PlannableTargeting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.ageRanges) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.genders) {
      GenderInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.devices) {
      DeviceInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.networks) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.youtubeSelectLineups) {
      YouTubeSelectLineUp.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.surfaceTargeting !== undefined) {
      SurfaceTargetingCombinations.encode(message.surfaceTargeting, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannableTargeting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannableTargeting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.ageRanges.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ageRanges.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.genders.push(GenderInfo.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.devices.push(DeviceInfo.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag === 32) {
            message.networks.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.networks.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.youtubeSelectLineups.push(YouTubeSelectLineUp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.surfaceTargeting = SurfaceTargetingCombinations.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlannableTargeting {
    return {
      ageRanges: globalThis.Array.isArray(object?.ageRanges)
        ? object.ageRanges.map((e: any) => reachPlanAgeRangeEnum_ReachPlanAgeRangeFromJSON(e))
        : [],
      genders: globalThis.Array.isArray(object?.genders) ? object.genders.map((e: any) => GenderInfo.fromJSON(e)) : [],
      devices: globalThis.Array.isArray(object?.devices) ? object.devices.map((e: any) => DeviceInfo.fromJSON(e)) : [],
      networks: globalThis.Array.isArray(object?.networks)
        ? object.networks.map((e: any) => reachPlanNetworkEnum_ReachPlanNetworkFromJSON(e))
        : [],
      youtubeSelectLineups: globalThis.Array.isArray(object?.youtubeSelectLineups)
        ? object.youtubeSelectLineups.map((e: any) => YouTubeSelectLineUp.fromJSON(e))
        : [],
      surfaceTargeting: isSet(object.surfaceTargeting)
        ? SurfaceTargetingCombinations.fromJSON(object.surfaceTargeting)
        : undefined,
    };
  },

  toJSON(message: PlannableTargeting): unknown {
    const obj: any = {};
    if (message.ageRanges?.length) {
      obj.ageRanges = message.ageRanges.map((e) => reachPlanAgeRangeEnum_ReachPlanAgeRangeToJSON(e));
    }
    if (message.genders?.length) {
      obj.genders = message.genders.map((e) => GenderInfo.toJSON(e));
    }
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => DeviceInfo.toJSON(e));
    }
    if (message.networks?.length) {
      obj.networks = message.networks.map((e) => reachPlanNetworkEnum_ReachPlanNetworkToJSON(e));
    }
    if (message.youtubeSelectLineups?.length) {
      obj.youtubeSelectLineups = message.youtubeSelectLineups.map((e) => YouTubeSelectLineUp.toJSON(e));
    }
    if (message.surfaceTargeting !== undefined) {
      obj.surfaceTargeting = SurfaceTargetingCombinations.toJSON(message.surfaceTargeting);
    }
    return obj;
  },

  create(base?: DeepPartial<PlannableTargeting>): PlannableTargeting {
    return PlannableTargeting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlannableTargeting>): PlannableTargeting {
    const message = createBasePlannableTargeting();
    message.ageRanges = object.ageRanges?.map((e) => e) || [];
    message.genders = object.genders?.map((e) => GenderInfo.fromPartial(e)) || [];
    message.devices = object.devices?.map((e) => DeviceInfo.fromPartial(e)) || [];
    message.networks = object.networks?.map((e) => e) || [];
    message.youtubeSelectLineups = object.youtubeSelectLineups?.map((e) => YouTubeSelectLineUp.fromPartial(e)) || [];
    message.surfaceTargeting = (object.surfaceTargeting !== undefined && object.surfaceTargeting !== null)
      ? SurfaceTargetingCombinations.fromPartial(object.surfaceTargeting)
      : undefined;
    return message;
  },
};

function createBaseGenerateReachForecastRequest(): GenerateReachForecastRequest {
  return {
    customerId: "",
    currencyCode: undefined,
    campaignDuration: undefined,
    cookieFrequencyCap: undefined,
    cookieFrequencyCapSetting: undefined,
    minEffectiveFrequency: undefined,
    effectiveFrequencyLimit: undefined,
    targeting: undefined,
    plannedProducts: [],
    forecastMetricOptions: undefined,
    customerReachGroup: undefined,
  };
}

export const GenerateReachForecastRequest: MessageFns<GenerateReachForecastRequest> = {
  encode(message: GenerateReachForecastRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.currencyCode !== undefined) {
      writer.uint32(74).string(message.currencyCode);
    }
    if (message.campaignDuration !== undefined) {
      CampaignDuration.encode(message.campaignDuration, writer.uint32(26).fork()).join();
    }
    if (message.cookieFrequencyCap !== undefined) {
      writer.uint32(80).int32(message.cookieFrequencyCap);
    }
    if (message.cookieFrequencyCapSetting !== undefined) {
      FrequencyCap.encode(message.cookieFrequencyCapSetting, writer.uint32(66).fork()).join();
    }
    if (message.minEffectiveFrequency !== undefined) {
      writer.uint32(88).int32(message.minEffectiveFrequency);
    }
    if (message.effectiveFrequencyLimit !== undefined) {
      EffectiveFrequencyLimit.encode(message.effectiveFrequencyLimit, writer.uint32(98).fork()).join();
    }
    if (message.targeting !== undefined) {
      Targeting.encode(message.targeting, writer.uint32(50).fork()).join();
    }
    for (const v of message.plannedProducts) {
      PlannedProduct.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.forecastMetricOptions !== undefined) {
      ForecastMetricOptions.encode(message.forecastMetricOptions, writer.uint32(106).fork()).join();
    }
    if (message.customerReachGroup !== undefined) {
      writer.uint32(114).string(message.customerReachGroup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateReachForecastRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateReachForecastRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.campaignDuration = CampaignDuration.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.cookieFrequencyCap = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cookieFrequencyCapSetting = FrequencyCap.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.minEffectiveFrequency = reader.int32();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.effectiveFrequencyLimit = EffectiveFrequencyLimit.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.targeting = Targeting.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.plannedProducts.push(PlannedProduct.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.forecastMetricOptions = ForecastMetricOptions.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.customerReachGroup = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateReachForecastRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : undefined,
      campaignDuration: isSet(object.campaignDuration) ? CampaignDuration.fromJSON(object.campaignDuration) : undefined,
      cookieFrequencyCap: isSet(object.cookieFrequencyCap) ? globalThis.Number(object.cookieFrequencyCap) : undefined,
      cookieFrequencyCapSetting: isSet(object.cookieFrequencyCapSetting)
        ? FrequencyCap.fromJSON(object.cookieFrequencyCapSetting)
        : undefined,
      minEffectiveFrequency: isSet(object.minEffectiveFrequency)
        ? globalThis.Number(object.minEffectiveFrequency)
        : undefined,
      effectiveFrequencyLimit: isSet(object.effectiveFrequencyLimit)
        ? EffectiveFrequencyLimit.fromJSON(object.effectiveFrequencyLimit)
        : undefined,
      targeting: isSet(object.targeting) ? Targeting.fromJSON(object.targeting) : undefined,
      plannedProducts: globalThis.Array.isArray(object?.plannedProducts)
        ? object.plannedProducts.map((e: any) => PlannedProduct.fromJSON(e))
        : [],
      forecastMetricOptions: isSet(object.forecastMetricOptions)
        ? ForecastMetricOptions.fromJSON(object.forecastMetricOptions)
        : undefined,
      customerReachGroup: isSet(object.customerReachGroup) ? globalThis.String(object.customerReachGroup) : undefined,
    };
  },

  toJSON(message: GenerateReachForecastRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.currencyCode !== undefined) {
      obj.currencyCode = message.currencyCode;
    }
    if (message.campaignDuration !== undefined) {
      obj.campaignDuration = CampaignDuration.toJSON(message.campaignDuration);
    }
    if (message.cookieFrequencyCap !== undefined) {
      obj.cookieFrequencyCap = Math.round(message.cookieFrequencyCap);
    }
    if (message.cookieFrequencyCapSetting !== undefined) {
      obj.cookieFrequencyCapSetting = FrequencyCap.toJSON(message.cookieFrequencyCapSetting);
    }
    if (message.minEffectiveFrequency !== undefined) {
      obj.minEffectiveFrequency = Math.round(message.minEffectiveFrequency);
    }
    if (message.effectiveFrequencyLimit !== undefined) {
      obj.effectiveFrequencyLimit = EffectiveFrequencyLimit.toJSON(message.effectiveFrequencyLimit);
    }
    if (message.targeting !== undefined) {
      obj.targeting = Targeting.toJSON(message.targeting);
    }
    if (message.plannedProducts?.length) {
      obj.plannedProducts = message.plannedProducts.map((e) => PlannedProduct.toJSON(e));
    }
    if (message.forecastMetricOptions !== undefined) {
      obj.forecastMetricOptions = ForecastMetricOptions.toJSON(message.forecastMetricOptions);
    }
    if (message.customerReachGroup !== undefined) {
      obj.customerReachGroup = message.customerReachGroup;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateReachForecastRequest>): GenerateReachForecastRequest {
    return GenerateReachForecastRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateReachForecastRequest>): GenerateReachForecastRequest {
    const message = createBaseGenerateReachForecastRequest();
    message.customerId = object.customerId ?? "";
    message.currencyCode = object.currencyCode ?? undefined;
    message.campaignDuration = (object.campaignDuration !== undefined && object.campaignDuration !== null)
      ? CampaignDuration.fromPartial(object.campaignDuration)
      : undefined;
    message.cookieFrequencyCap = object.cookieFrequencyCap ?? undefined;
    message.cookieFrequencyCapSetting =
      (object.cookieFrequencyCapSetting !== undefined && object.cookieFrequencyCapSetting !== null)
        ? FrequencyCap.fromPartial(object.cookieFrequencyCapSetting)
        : undefined;
    message.minEffectiveFrequency = object.minEffectiveFrequency ?? undefined;
    message.effectiveFrequencyLimit =
      (object.effectiveFrequencyLimit !== undefined && object.effectiveFrequencyLimit !== null)
        ? EffectiveFrequencyLimit.fromPartial(object.effectiveFrequencyLimit)
        : undefined;
    message.targeting = (object.targeting !== undefined && object.targeting !== null)
      ? Targeting.fromPartial(object.targeting)
      : undefined;
    message.plannedProducts = object.plannedProducts?.map((e) => PlannedProduct.fromPartial(e)) || [];
    message.forecastMetricOptions =
      (object.forecastMetricOptions !== undefined && object.forecastMetricOptions !== null)
        ? ForecastMetricOptions.fromPartial(object.forecastMetricOptions)
        : undefined;
    message.customerReachGroup = object.customerReachGroup ?? undefined;
    return message;
  },
};

function createBaseEffectiveFrequencyLimit(): EffectiveFrequencyLimit {
  return { effectiveFrequencyBreakdownLimit: 0 };
}

export const EffectiveFrequencyLimit: MessageFns<EffectiveFrequencyLimit> = {
  encode(message: EffectiveFrequencyLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.effectiveFrequencyBreakdownLimit !== 0) {
      writer.uint32(8).int32(message.effectiveFrequencyBreakdownLimit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectiveFrequencyLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectiveFrequencyLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.effectiveFrequencyBreakdownLimit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectiveFrequencyLimit {
    return {
      effectiveFrequencyBreakdownLimit: isSet(object.effectiveFrequencyBreakdownLimit)
        ? globalThis.Number(object.effectiveFrequencyBreakdownLimit)
        : 0,
    };
  },

  toJSON(message: EffectiveFrequencyLimit): unknown {
    const obj: any = {};
    if (message.effectiveFrequencyBreakdownLimit !== 0) {
      obj.effectiveFrequencyBreakdownLimit = Math.round(message.effectiveFrequencyBreakdownLimit);
    }
    return obj;
  },

  create(base?: DeepPartial<EffectiveFrequencyLimit>): EffectiveFrequencyLimit {
    return EffectiveFrequencyLimit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EffectiveFrequencyLimit>): EffectiveFrequencyLimit {
    const message = createBaseEffectiveFrequencyLimit();
    message.effectiveFrequencyBreakdownLimit = object.effectiveFrequencyBreakdownLimit ?? 0;
    return message;
  },
};

function createBaseFrequencyCap(): FrequencyCap {
  return { impressions: 0, timeUnit: 0 };
}

export const FrequencyCap: MessageFns<FrequencyCap> = {
  encode(message: FrequencyCap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.impressions !== 0) {
      writer.uint32(24).int32(message.impressions);
    }
    if (message.timeUnit !== 0) {
      writer.uint32(16).int32(message.timeUnit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FrequencyCap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrequencyCap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.impressions = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeUnit = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FrequencyCap {
    return {
      impressions: isSet(object.impressions) ? globalThis.Number(object.impressions) : 0,
      timeUnit: isSet(object.timeUnit) ? frequencyCapTimeUnitEnum_FrequencyCapTimeUnitFromJSON(object.timeUnit) : 0,
    };
  },

  toJSON(message: FrequencyCap): unknown {
    const obj: any = {};
    if (message.impressions !== 0) {
      obj.impressions = Math.round(message.impressions);
    }
    if (message.timeUnit !== 0) {
      obj.timeUnit = frequencyCapTimeUnitEnum_FrequencyCapTimeUnitToJSON(message.timeUnit);
    }
    return obj;
  },

  create(base?: DeepPartial<FrequencyCap>): FrequencyCap {
    return FrequencyCap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FrequencyCap>): FrequencyCap {
    const message = createBaseFrequencyCap();
    message.impressions = object.impressions ?? 0;
    message.timeUnit = object.timeUnit ?? 0;
    return message;
  },
};

function createBaseTargeting(): Targeting {
  return {
    plannableLocationId: undefined,
    plannableLocationIds: [],
    ageRange: 0,
    genders: [],
    devices: [],
    network: 0,
    audienceTargeting: undefined,
  };
}

export const Targeting: MessageFns<Targeting> = {
  encode(message: Targeting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plannableLocationId !== undefined) {
      writer.uint32(50).string(message.plannableLocationId);
    }
    for (const v of message.plannableLocationIds) {
      writer.uint32(66).string(v!);
    }
    if (message.ageRange !== 0) {
      writer.uint32(16).int32(message.ageRange);
    }
    for (const v of message.genders) {
      GenderInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.devices) {
      DeviceInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.network !== 0) {
      writer.uint32(40).int32(message.network);
    }
    if (message.audienceTargeting !== undefined) {
      AudienceTargeting.encode(message.audienceTargeting, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Targeting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargeting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.plannableLocationId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.plannableLocationIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ageRange = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.genders.push(GenderInfo.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.devices.push(DeviceInfo.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.audienceTargeting = AudienceTargeting.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Targeting {
    return {
      plannableLocationId: isSet(object.plannableLocationId)
        ? globalThis.String(object.plannableLocationId)
        : undefined,
      plannableLocationIds: globalThis.Array.isArray(object?.plannableLocationIds)
        ? object.plannableLocationIds.map((e: any) => globalThis.String(e))
        : [],
      ageRange: isSet(object.ageRange) ? reachPlanAgeRangeEnum_ReachPlanAgeRangeFromJSON(object.ageRange) : 0,
      genders: globalThis.Array.isArray(object?.genders) ? object.genders.map((e: any) => GenderInfo.fromJSON(e)) : [],
      devices: globalThis.Array.isArray(object?.devices) ? object.devices.map((e: any) => DeviceInfo.fromJSON(e)) : [],
      network: isSet(object.network) ? reachPlanNetworkEnum_ReachPlanNetworkFromJSON(object.network) : 0,
      audienceTargeting: isSet(object.audienceTargeting)
        ? AudienceTargeting.fromJSON(object.audienceTargeting)
        : undefined,
    };
  },

  toJSON(message: Targeting): unknown {
    const obj: any = {};
    if (message.plannableLocationId !== undefined) {
      obj.plannableLocationId = message.plannableLocationId;
    }
    if (message.plannableLocationIds?.length) {
      obj.plannableLocationIds = message.plannableLocationIds;
    }
    if (message.ageRange !== 0) {
      obj.ageRange = reachPlanAgeRangeEnum_ReachPlanAgeRangeToJSON(message.ageRange);
    }
    if (message.genders?.length) {
      obj.genders = message.genders.map((e) => GenderInfo.toJSON(e));
    }
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => DeviceInfo.toJSON(e));
    }
    if (message.network !== 0) {
      obj.network = reachPlanNetworkEnum_ReachPlanNetworkToJSON(message.network);
    }
    if (message.audienceTargeting !== undefined) {
      obj.audienceTargeting = AudienceTargeting.toJSON(message.audienceTargeting);
    }
    return obj;
  },

  create(base?: DeepPartial<Targeting>): Targeting {
    return Targeting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Targeting>): Targeting {
    const message = createBaseTargeting();
    message.plannableLocationId = object.plannableLocationId ?? undefined;
    message.plannableLocationIds = object.plannableLocationIds?.map((e) => e) || [];
    message.ageRange = object.ageRange ?? 0;
    message.genders = object.genders?.map((e) => GenderInfo.fromPartial(e)) || [];
    message.devices = object.devices?.map((e) => DeviceInfo.fromPartial(e)) || [];
    message.network = object.network ?? 0;
    message.audienceTargeting = (object.audienceTargeting !== undefined && object.audienceTargeting !== null)
      ? AudienceTargeting.fromPartial(object.audienceTargeting)
      : undefined;
    return message;
  },
};

function createBaseCampaignDuration(): CampaignDuration {
  return { durationInDays: undefined, dateRange: undefined };
}

export const CampaignDuration: MessageFns<CampaignDuration> = {
  encode(message: CampaignDuration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.durationInDays !== undefined) {
      writer.uint32(16).int32(message.durationInDays);
    }
    if (message.dateRange !== undefined) {
      DateRange.encode(message.dateRange, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CampaignDuration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampaignDuration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.durationInDays = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dateRange = DateRange.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CampaignDuration {
    return {
      durationInDays: isSet(object.durationInDays) ? globalThis.Number(object.durationInDays) : undefined,
      dateRange: isSet(object.dateRange) ? DateRange.fromJSON(object.dateRange) : undefined,
    };
  },

  toJSON(message: CampaignDuration): unknown {
    const obj: any = {};
    if (message.durationInDays !== undefined) {
      obj.durationInDays = Math.round(message.durationInDays);
    }
    if (message.dateRange !== undefined) {
      obj.dateRange = DateRange.toJSON(message.dateRange);
    }
    return obj;
  },

  create(base?: DeepPartial<CampaignDuration>): CampaignDuration {
    return CampaignDuration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CampaignDuration>): CampaignDuration {
    const message = createBaseCampaignDuration();
    message.durationInDays = object.durationInDays ?? undefined;
    message.dateRange = (object.dateRange !== undefined && object.dateRange !== null)
      ? DateRange.fromPartial(object.dateRange)
      : undefined;
    return message;
  },
};

function createBasePlannedProduct(): PlannedProduct {
  return { plannableProductCode: undefined, budgetMicros: undefined, advancedProductTargeting: undefined };
}

export const PlannedProduct: MessageFns<PlannedProduct> = {
  encode(message: PlannedProduct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plannableProductCode !== undefined) {
      writer.uint32(26).string(message.plannableProductCode);
    }
    if (message.budgetMicros !== undefined) {
      writer.uint32(32).int64(message.budgetMicros.toString());
    }
    if (message.advancedProductTargeting !== undefined) {
      AdvancedProductTargeting.encode(message.advancedProductTargeting, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannedProduct {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannedProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.plannableProductCode = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.budgetMicros = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.advancedProductTargeting = AdvancedProductTargeting.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlannedProduct {
    return {
      plannableProductCode: isSet(object.plannableProductCode)
        ? globalThis.String(object.plannableProductCode)
        : undefined,
      budgetMicros: isSet(object.budgetMicros) ? Long.fromValue(object.budgetMicros) : undefined,
      advancedProductTargeting: isSet(object.advancedProductTargeting)
        ? AdvancedProductTargeting.fromJSON(object.advancedProductTargeting)
        : undefined,
    };
  },

  toJSON(message: PlannedProduct): unknown {
    const obj: any = {};
    if (message.plannableProductCode !== undefined) {
      obj.plannableProductCode = message.plannableProductCode;
    }
    if (message.budgetMicros !== undefined) {
      obj.budgetMicros = (message.budgetMicros || Long.ZERO).toString();
    }
    if (message.advancedProductTargeting !== undefined) {
      obj.advancedProductTargeting = AdvancedProductTargeting.toJSON(message.advancedProductTargeting);
    }
    return obj;
  },

  create(base?: DeepPartial<PlannedProduct>): PlannedProduct {
    return PlannedProduct.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlannedProduct>): PlannedProduct {
    const message = createBasePlannedProduct();
    message.plannableProductCode = object.plannableProductCode ?? undefined;
    message.budgetMicros = (object.budgetMicros !== undefined && object.budgetMicros !== null)
      ? Long.fromValue(object.budgetMicros)
      : undefined;
    message.advancedProductTargeting =
      (object.advancedProductTargeting !== undefined && object.advancedProductTargeting !== null)
        ? AdvancedProductTargeting.fromPartial(object.advancedProductTargeting)
        : undefined;
    return message;
  },
};

function createBaseGenerateReachForecastResponse(): GenerateReachForecastResponse {
  return { onTargetAudienceMetrics: undefined, reachCurve: undefined };
}

export const GenerateReachForecastResponse: MessageFns<GenerateReachForecastResponse> = {
  encode(message: GenerateReachForecastResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.onTargetAudienceMetrics !== undefined) {
      OnTargetAudienceMetrics.encode(message.onTargetAudienceMetrics, writer.uint32(10).fork()).join();
    }
    if (message.reachCurve !== undefined) {
      ReachCurve.encode(message.reachCurve, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateReachForecastResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateReachForecastResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.onTargetAudienceMetrics = OnTargetAudienceMetrics.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reachCurve = ReachCurve.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateReachForecastResponse {
    return {
      onTargetAudienceMetrics: isSet(object.onTargetAudienceMetrics)
        ? OnTargetAudienceMetrics.fromJSON(object.onTargetAudienceMetrics)
        : undefined,
      reachCurve: isSet(object.reachCurve) ? ReachCurve.fromJSON(object.reachCurve) : undefined,
    };
  },

  toJSON(message: GenerateReachForecastResponse): unknown {
    const obj: any = {};
    if (message.onTargetAudienceMetrics !== undefined) {
      obj.onTargetAudienceMetrics = OnTargetAudienceMetrics.toJSON(message.onTargetAudienceMetrics);
    }
    if (message.reachCurve !== undefined) {
      obj.reachCurve = ReachCurve.toJSON(message.reachCurve);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateReachForecastResponse>): GenerateReachForecastResponse {
    return GenerateReachForecastResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateReachForecastResponse>): GenerateReachForecastResponse {
    const message = createBaseGenerateReachForecastResponse();
    message.onTargetAudienceMetrics =
      (object.onTargetAudienceMetrics !== undefined && object.onTargetAudienceMetrics !== null)
        ? OnTargetAudienceMetrics.fromPartial(object.onTargetAudienceMetrics)
        : undefined;
    message.reachCurve = (object.reachCurve !== undefined && object.reachCurve !== null)
      ? ReachCurve.fromPartial(object.reachCurve)
      : undefined;
    return message;
  },
};

function createBaseReachCurve(): ReachCurve {
  return { reachForecasts: [] };
}

export const ReachCurve: MessageFns<ReachCurve> = {
  encode(message: ReachCurve, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reachForecasts) {
      ReachForecast.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReachCurve {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReachCurve();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reachForecasts.push(ReachForecast.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReachCurve {
    return {
      reachForecasts: globalThis.Array.isArray(object?.reachForecasts)
        ? object.reachForecasts.map((e: any) => ReachForecast.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReachCurve): unknown {
    const obj: any = {};
    if (message.reachForecasts?.length) {
      obj.reachForecasts = message.reachForecasts.map((e) => ReachForecast.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReachCurve>): ReachCurve {
    return ReachCurve.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReachCurve>): ReachCurve {
    const message = createBaseReachCurve();
    message.reachForecasts = object.reachForecasts?.map((e) => ReachForecast.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReachForecast(): ReachForecast {
  return { costMicros: Long.ZERO, forecast: undefined, plannedProductReachForecasts: [] };
}

export const ReachForecast: MessageFns<ReachForecast> = {
  encode(message: ReachForecast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.costMicros.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.costMicros.toString());
    }
    if (message.forecast !== undefined) {
      Forecast.encode(message.forecast, writer.uint32(18).fork()).join();
    }
    for (const v of message.plannedProductReachForecasts) {
      PlannedProductReachForecast.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReachForecast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReachForecast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 40) {
            break;
          }

          message.costMicros = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.forecast = Forecast.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.plannedProductReachForecasts.push(PlannedProductReachForecast.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReachForecast {
    return {
      costMicros: isSet(object.costMicros) ? Long.fromValue(object.costMicros) : Long.ZERO,
      forecast: isSet(object.forecast) ? Forecast.fromJSON(object.forecast) : undefined,
      plannedProductReachForecasts: globalThis.Array.isArray(object?.plannedProductReachForecasts)
        ? object.plannedProductReachForecasts.map((e: any) => PlannedProductReachForecast.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReachForecast): unknown {
    const obj: any = {};
    if (!message.costMicros.equals(Long.ZERO)) {
      obj.costMicros = (message.costMicros || Long.ZERO).toString();
    }
    if (message.forecast !== undefined) {
      obj.forecast = Forecast.toJSON(message.forecast);
    }
    if (message.plannedProductReachForecasts?.length) {
      obj.plannedProductReachForecasts = message.plannedProductReachForecasts.map((e) =>
        PlannedProductReachForecast.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ReachForecast>): ReachForecast {
    return ReachForecast.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReachForecast>): ReachForecast {
    const message = createBaseReachForecast();
    message.costMicros = (object.costMicros !== undefined && object.costMicros !== null)
      ? Long.fromValue(object.costMicros)
      : Long.ZERO;
    message.forecast = (object.forecast !== undefined && object.forecast !== null)
      ? Forecast.fromPartial(object.forecast)
      : undefined;
    message.plannedProductReachForecasts =
      object.plannedProductReachForecasts?.map((e) => PlannedProductReachForecast.fromPartial(e)) || [];
    return message;
  },
};

function createBaseForecast(): Forecast {
  return {
    onTargetReach: undefined,
    totalReach: undefined,
    onTargetImpressions: undefined,
    totalImpressions: undefined,
    viewableImpressions: undefined,
    effectiveFrequencyBreakdowns: [],
    onTargetCoviewReach: undefined,
    totalCoviewReach: undefined,
    onTargetCoviewImpressions: undefined,
    totalCoviewImpressions: undefined,
    views: undefined,
  };
}

export const Forecast: MessageFns<Forecast> = {
  encode(message: Forecast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.onTargetReach !== undefined) {
      writer.uint32(40).int64(message.onTargetReach.toString());
    }
    if (message.totalReach !== undefined) {
      writer.uint32(48).int64(message.totalReach.toString());
    }
    if (message.onTargetImpressions !== undefined) {
      writer.uint32(56).int64(message.onTargetImpressions.toString());
    }
    if (message.totalImpressions !== undefined) {
      writer.uint32(64).int64(message.totalImpressions.toString());
    }
    if (message.viewableImpressions !== undefined) {
      writer.uint32(72).int64(message.viewableImpressions.toString());
    }
    for (const v of message.effectiveFrequencyBreakdowns) {
      EffectiveFrequencyBreakdown.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.onTargetCoviewReach !== undefined) {
      writer.uint32(88).int64(message.onTargetCoviewReach.toString());
    }
    if (message.totalCoviewReach !== undefined) {
      writer.uint32(96).int64(message.totalCoviewReach.toString());
    }
    if (message.onTargetCoviewImpressions !== undefined) {
      writer.uint32(104).int64(message.onTargetCoviewImpressions.toString());
    }
    if (message.totalCoviewImpressions !== undefined) {
      writer.uint32(112).int64(message.totalCoviewImpressions.toString());
    }
    if (message.views !== undefined) {
      writer.uint32(120).int64(message.views.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Forecast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForecast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 40) {
            break;
          }

          message.onTargetReach = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalReach = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.onTargetImpressions = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.totalImpressions = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.viewableImpressions = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.effectiveFrequencyBreakdowns.push(EffectiveFrequencyBreakdown.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.onTargetCoviewReach = Long.fromString(reader.int64().toString());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.totalCoviewReach = Long.fromString(reader.int64().toString());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.onTargetCoviewImpressions = Long.fromString(reader.int64().toString());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.totalCoviewImpressions = Long.fromString(reader.int64().toString());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.views = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Forecast {
    return {
      onTargetReach: isSet(object.onTargetReach) ? Long.fromValue(object.onTargetReach) : undefined,
      totalReach: isSet(object.totalReach) ? Long.fromValue(object.totalReach) : undefined,
      onTargetImpressions: isSet(object.onTargetImpressions) ? Long.fromValue(object.onTargetImpressions) : undefined,
      totalImpressions: isSet(object.totalImpressions) ? Long.fromValue(object.totalImpressions) : undefined,
      viewableImpressions: isSet(object.viewableImpressions) ? Long.fromValue(object.viewableImpressions) : undefined,
      effectiveFrequencyBreakdowns: globalThis.Array.isArray(object?.effectiveFrequencyBreakdowns)
        ? object.effectiveFrequencyBreakdowns.map((e: any) => EffectiveFrequencyBreakdown.fromJSON(e))
        : [],
      onTargetCoviewReach: isSet(object.onTargetCoviewReach) ? Long.fromValue(object.onTargetCoviewReach) : undefined,
      totalCoviewReach: isSet(object.totalCoviewReach) ? Long.fromValue(object.totalCoviewReach) : undefined,
      onTargetCoviewImpressions: isSet(object.onTargetCoviewImpressions)
        ? Long.fromValue(object.onTargetCoviewImpressions)
        : undefined,
      totalCoviewImpressions: isSet(object.totalCoviewImpressions)
        ? Long.fromValue(object.totalCoviewImpressions)
        : undefined,
      views: isSet(object.views) ? Long.fromValue(object.views) : undefined,
    };
  },

  toJSON(message: Forecast): unknown {
    const obj: any = {};
    if (message.onTargetReach !== undefined) {
      obj.onTargetReach = (message.onTargetReach || Long.ZERO).toString();
    }
    if (message.totalReach !== undefined) {
      obj.totalReach = (message.totalReach || Long.ZERO).toString();
    }
    if (message.onTargetImpressions !== undefined) {
      obj.onTargetImpressions = (message.onTargetImpressions || Long.ZERO).toString();
    }
    if (message.totalImpressions !== undefined) {
      obj.totalImpressions = (message.totalImpressions || Long.ZERO).toString();
    }
    if (message.viewableImpressions !== undefined) {
      obj.viewableImpressions = (message.viewableImpressions || Long.ZERO).toString();
    }
    if (message.effectiveFrequencyBreakdowns?.length) {
      obj.effectiveFrequencyBreakdowns = message.effectiveFrequencyBreakdowns.map((e) =>
        EffectiveFrequencyBreakdown.toJSON(e)
      );
    }
    if (message.onTargetCoviewReach !== undefined) {
      obj.onTargetCoviewReach = (message.onTargetCoviewReach || Long.ZERO).toString();
    }
    if (message.totalCoviewReach !== undefined) {
      obj.totalCoviewReach = (message.totalCoviewReach || Long.ZERO).toString();
    }
    if (message.onTargetCoviewImpressions !== undefined) {
      obj.onTargetCoviewImpressions = (message.onTargetCoviewImpressions || Long.ZERO).toString();
    }
    if (message.totalCoviewImpressions !== undefined) {
      obj.totalCoviewImpressions = (message.totalCoviewImpressions || Long.ZERO).toString();
    }
    if (message.views !== undefined) {
      obj.views = (message.views || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Forecast>): Forecast {
    return Forecast.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Forecast>): Forecast {
    const message = createBaseForecast();
    message.onTargetReach = (object.onTargetReach !== undefined && object.onTargetReach !== null)
      ? Long.fromValue(object.onTargetReach)
      : undefined;
    message.totalReach = (object.totalReach !== undefined && object.totalReach !== null)
      ? Long.fromValue(object.totalReach)
      : undefined;
    message.onTargetImpressions = (object.onTargetImpressions !== undefined && object.onTargetImpressions !== null)
      ? Long.fromValue(object.onTargetImpressions)
      : undefined;
    message.totalImpressions = (object.totalImpressions !== undefined && object.totalImpressions !== null)
      ? Long.fromValue(object.totalImpressions)
      : undefined;
    message.viewableImpressions = (object.viewableImpressions !== undefined && object.viewableImpressions !== null)
      ? Long.fromValue(object.viewableImpressions)
      : undefined;
    message.effectiveFrequencyBreakdowns =
      object.effectiveFrequencyBreakdowns?.map((e) => EffectiveFrequencyBreakdown.fromPartial(e)) || [];
    message.onTargetCoviewReach = (object.onTargetCoviewReach !== undefined && object.onTargetCoviewReach !== null)
      ? Long.fromValue(object.onTargetCoviewReach)
      : undefined;
    message.totalCoviewReach = (object.totalCoviewReach !== undefined && object.totalCoviewReach !== null)
      ? Long.fromValue(object.totalCoviewReach)
      : undefined;
    message.onTargetCoviewImpressions =
      (object.onTargetCoviewImpressions !== undefined && object.onTargetCoviewImpressions !== null)
        ? Long.fromValue(object.onTargetCoviewImpressions)
        : undefined;
    message.totalCoviewImpressions =
      (object.totalCoviewImpressions !== undefined && object.totalCoviewImpressions !== null)
        ? Long.fromValue(object.totalCoviewImpressions)
        : undefined;
    message.views = (object.views !== undefined && object.views !== null) ? Long.fromValue(object.views) : undefined;
    return message;
  },
};

function createBasePlannedProductReachForecast(): PlannedProductReachForecast {
  return { plannableProductCode: "", costMicros: Long.ZERO, plannedProductForecast: undefined };
}

export const PlannedProductReachForecast: MessageFns<PlannedProductReachForecast> = {
  encode(message: PlannedProductReachForecast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plannableProductCode !== "") {
      writer.uint32(10).string(message.plannableProductCode);
    }
    if (!message.costMicros.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.costMicros.toString());
    }
    if (message.plannedProductForecast !== undefined) {
      PlannedProductForecast.encode(message.plannedProductForecast, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannedProductReachForecast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannedProductReachForecast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.plannableProductCode = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.costMicros = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.plannedProductForecast = PlannedProductForecast.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlannedProductReachForecast {
    return {
      plannableProductCode: isSet(object.plannableProductCode) ? globalThis.String(object.plannableProductCode) : "",
      costMicros: isSet(object.costMicros) ? Long.fromValue(object.costMicros) : Long.ZERO,
      plannedProductForecast: isSet(object.plannedProductForecast)
        ? PlannedProductForecast.fromJSON(object.plannedProductForecast)
        : undefined,
    };
  },

  toJSON(message: PlannedProductReachForecast): unknown {
    const obj: any = {};
    if (message.plannableProductCode !== "") {
      obj.plannableProductCode = message.plannableProductCode;
    }
    if (!message.costMicros.equals(Long.ZERO)) {
      obj.costMicros = (message.costMicros || Long.ZERO).toString();
    }
    if (message.plannedProductForecast !== undefined) {
      obj.plannedProductForecast = PlannedProductForecast.toJSON(message.plannedProductForecast);
    }
    return obj;
  },

  create(base?: DeepPartial<PlannedProductReachForecast>): PlannedProductReachForecast {
    return PlannedProductReachForecast.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlannedProductReachForecast>): PlannedProductReachForecast {
    const message = createBasePlannedProductReachForecast();
    message.plannableProductCode = object.plannableProductCode ?? "";
    message.costMicros = (object.costMicros !== undefined && object.costMicros !== null)
      ? Long.fromValue(object.costMicros)
      : Long.ZERO;
    message.plannedProductForecast =
      (object.plannedProductForecast !== undefined && object.plannedProductForecast !== null)
        ? PlannedProductForecast.fromPartial(object.plannedProductForecast)
        : undefined;
    return message;
  },
};

function createBasePlannedProductForecast(): PlannedProductForecast {
  return {
    onTargetReach: Long.ZERO,
    totalReach: Long.ZERO,
    onTargetImpressions: Long.ZERO,
    totalImpressions: Long.ZERO,
    viewableImpressions: undefined,
    onTargetCoviewReach: undefined,
    totalCoviewReach: undefined,
    onTargetCoviewImpressions: undefined,
    totalCoviewImpressions: undefined,
    averageFrequency: undefined,
    views: undefined,
  };
}

export const PlannedProductForecast: MessageFns<PlannedProductForecast> = {
  encode(message: PlannedProductForecast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.onTargetReach.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.onTargetReach.toString());
    }
    if (!message.totalReach.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.totalReach.toString());
    }
    if (!message.onTargetImpressions.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.onTargetImpressions.toString());
    }
    if (!message.totalImpressions.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.totalImpressions.toString());
    }
    if (message.viewableImpressions !== undefined) {
      writer.uint32(40).int64(message.viewableImpressions.toString());
    }
    if (message.onTargetCoviewReach !== undefined) {
      writer.uint32(48).int64(message.onTargetCoviewReach.toString());
    }
    if (message.totalCoviewReach !== undefined) {
      writer.uint32(56).int64(message.totalCoviewReach.toString());
    }
    if (message.onTargetCoviewImpressions !== undefined) {
      writer.uint32(64).int64(message.onTargetCoviewImpressions.toString());
    }
    if (message.totalCoviewImpressions !== undefined) {
      writer.uint32(72).int64(message.totalCoviewImpressions.toString());
    }
    if (message.averageFrequency !== undefined) {
      writer.uint32(81).double(message.averageFrequency);
    }
    if (message.views !== undefined) {
      writer.uint32(88).int64(message.views.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannedProductForecast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannedProductForecast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.onTargetReach = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalReach = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.onTargetImpressions = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalImpressions = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.viewableImpressions = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.onTargetCoviewReach = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.totalCoviewReach = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.onTargetCoviewImpressions = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.totalCoviewImpressions = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 81) {
            break;
          }

          message.averageFrequency = reader.double();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.views = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlannedProductForecast {
    return {
      onTargetReach: isSet(object.onTargetReach) ? Long.fromValue(object.onTargetReach) : Long.ZERO,
      totalReach: isSet(object.totalReach) ? Long.fromValue(object.totalReach) : Long.ZERO,
      onTargetImpressions: isSet(object.onTargetImpressions) ? Long.fromValue(object.onTargetImpressions) : Long.ZERO,
      totalImpressions: isSet(object.totalImpressions) ? Long.fromValue(object.totalImpressions) : Long.ZERO,
      viewableImpressions: isSet(object.viewableImpressions) ? Long.fromValue(object.viewableImpressions) : undefined,
      onTargetCoviewReach: isSet(object.onTargetCoviewReach) ? Long.fromValue(object.onTargetCoviewReach) : undefined,
      totalCoviewReach: isSet(object.totalCoviewReach) ? Long.fromValue(object.totalCoviewReach) : undefined,
      onTargetCoviewImpressions: isSet(object.onTargetCoviewImpressions)
        ? Long.fromValue(object.onTargetCoviewImpressions)
        : undefined,
      totalCoviewImpressions: isSet(object.totalCoviewImpressions)
        ? Long.fromValue(object.totalCoviewImpressions)
        : undefined,
      averageFrequency: isSet(object.averageFrequency) ? globalThis.Number(object.averageFrequency) : undefined,
      views: isSet(object.views) ? Long.fromValue(object.views) : undefined,
    };
  },

  toJSON(message: PlannedProductForecast): unknown {
    const obj: any = {};
    if (!message.onTargetReach.equals(Long.ZERO)) {
      obj.onTargetReach = (message.onTargetReach || Long.ZERO).toString();
    }
    if (!message.totalReach.equals(Long.ZERO)) {
      obj.totalReach = (message.totalReach || Long.ZERO).toString();
    }
    if (!message.onTargetImpressions.equals(Long.ZERO)) {
      obj.onTargetImpressions = (message.onTargetImpressions || Long.ZERO).toString();
    }
    if (!message.totalImpressions.equals(Long.ZERO)) {
      obj.totalImpressions = (message.totalImpressions || Long.ZERO).toString();
    }
    if (message.viewableImpressions !== undefined) {
      obj.viewableImpressions = (message.viewableImpressions || Long.ZERO).toString();
    }
    if (message.onTargetCoviewReach !== undefined) {
      obj.onTargetCoviewReach = (message.onTargetCoviewReach || Long.ZERO).toString();
    }
    if (message.totalCoviewReach !== undefined) {
      obj.totalCoviewReach = (message.totalCoviewReach || Long.ZERO).toString();
    }
    if (message.onTargetCoviewImpressions !== undefined) {
      obj.onTargetCoviewImpressions = (message.onTargetCoviewImpressions || Long.ZERO).toString();
    }
    if (message.totalCoviewImpressions !== undefined) {
      obj.totalCoviewImpressions = (message.totalCoviewImpressions || Long.ZERO).toString();
    }
    if (message.averageFrequency !== undefined) {
      obj.averageFrequency = message.averageFrequency;
    }
    if (message.views !== undefined) {
      obj.views = (message.views || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<PlannedProductForecast>): PlannedProductForecast {
    return PlannedProductForecast.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlannedProductForecast>): PlannedProductForecast {
    const message = createBasePlannedProductForecast();
    message.onTargetReach = (object.onTargetReach !== undefined && object.onTargetReach !== null)
      ? Long.fromValue(object.onTargetReach)
      : Long.ZERO;
    message.totalReach = (object.totalReach !== undefined && object.totalReach !== null)
      ? Long.fromValue(object.totalReach)
      : Long.ZERO;
    message.onTargetImpressions = (object.onTargetImpressions !== undefined && object.onTargetImpressions !== null)
      ? Long.fromValue(object.onTargetImpressions)
      : Long.ZERO;
    message.totalImpressions = (object.totalImpressions !== undefined && object.totalImpressions !== null)
      ? Long.fromValue(object.totalImpressions)
      : Long.ZERO;
    message.viewableImpressions = (object.viewableImpressions !== undefined && object.viewableImpressions !== null)
      ? Long.fromValue(object.viewableImpressions)
      : undefined;
    message.onTargetCoviewReach = (object.onTargetCoviewReach !== undefined && object.onTargetCoviewReach !== null)
      ? Long.fromValue(object.onTargetCoviewReach)
      : undefined;
    message.totalCoviewReach = (object.totalCoviewReach !== undefined && object.totalCoviewReach !== null)
      ? Long.fromValue(object.totalCoviewReach)
      : undefined;
    message.onTargetCoviewImpressions =
      (object.onTargetCoviewImpressions !== undefined && object.onTargetCoviewImpressions !== null)
        ? Long.fromValue(object.onTargetCoviewImpressions)
        : undefined;
    message.totalCoviewImpressions =
      (object.totalCoviewImpressions !== undefined && object.totalCoviewImpressions !== null)
        ? Long.fromValue(object.totalCoviewImpressions)
        : undefined;
    message.averageFrequency = object.averageFrequency ?? undefined;
    message.views = (object.views !== undefined && object.views !== null) ? Long.fromValue(object.views) : undefined;
    return message;
  },
};

function createBaseOnTargetAudienceMetrics(): OnTargetAudienceMetrics {
  return { youtubeAudienceSize: undefined, censusAudienceSize: undefined };
}

export const OnTargetAudienceMetrics: MessageFns<OnTargetAudienceMetrics> = {
  encode(message: OnTargetAudienceMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.youtubeAudienceSize !== undefined) {
      writer.uint32(24).int64(message.youtubeAudienceSize.toString());
    }
    if (message.censusAudienceSize !== undefined) {
      writer.uint32(32).int64(message.censusAudienceSize.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OnTargetAudienceMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnTargetAudienceMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.youtubeAudienceSize = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.censusAudienceSize = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnTargetAudienceMetrics {
    return {
      youtubeAudienceSize: isSet(object.youtubeAudienceSize) ? Long.fromValue(object.youtubeAudienceSize) : undefined,
      censusAudienceSize: isSet(object.censusAudienceSize) ? Long.fromValue(object.censusAudienceSize) : undefined,
    };
  },

  toJSON(message: OnTargetAudienceMetrics): unknown {
    const obj: any = {};
    if (message.youtubeAudienceSize !== undefined) {
      obj.youtubeAudienceSize = (message.youtubeAudienceSize || Long.ZERO).toString();
    }
    if (message.censusAudienceSize !== undefined) {
      obj.censusAudienceSize = (message.censusAudienceSize || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<OnTargetAudienceMetrics>): OnTargetAudienceMetrics {
    return OnTargetAudienceMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OnTargetAudienceMetrics>): OnTargetAudienceMetrics {
    const message = createBaseOnTargetAudienceMetrics();
    message.youtubeAudienceSize = (object.youtubeAudienceSize !== undefined && object.youtubeAudienceSize !== null)
      ? Long.fromValue(object.youtubeAudienceSize)
      : undefined;
    message.censusAudienceSize = (object.censusAudienceSize !== undefined && object.censusAudienceSize !== null)
      ? Long.fromValue(object.censusAudienceSize)
      : undefined;
    return message;
  },
};

function createBaseEffectiveFrequencyBreakdown(): EffectiveFrequencyBreakdown {
  return {
    effectiveFrequency: 0,
    onTargetReach: Long.ZERO,
    totalReach: Long.ZERO,
    effectiveCoviewReach: undefined,
    onTargetEffectiveCoviewReach: undefined,
  };
}

export const EffectiveFrequencyBreakdown: MessageFns<EffectiveFrequencyBreakdown> = {
  encode(message: EffectiveFrequencyBreakdown, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.effectiveFrequency !== 0) {
      writer.uint32(8).int32(message.effectiveFrequency);
    }
    if (!message.onTargetReach.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.onTargetReach.toString());
    }
    if (!message.totalReach.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.totalReach.toString());
    }
    if (message.effectiveCoviewReach !== undefined) {
      writer.uint32(32).int64(message.effectiveCoviewReach.toString());
    }
    if (message.onTargetEffectiveCoviewReach !== undefined) {
      writer.uint32(40).int64(message.onTargetEffectiveCoviewReach.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectiveFrequencyBreakdown {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectiveFrequencyBreakdown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.effectiveFrequency = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.onTargetReach = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalReach = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.effectiveCoviewReach = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.onTargetEffectiveCoviewReach = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectiveFrequencyBreakdown {
    return {
      effectiveFrequency: isSet(object.effectiveFrequency) ? globalThis.Number(object.effectiveFrequency) : 0,
      onTargetReach: isSet(object.onTargetReach) ? Long.fromValue(object.onTargetReach) : Long.ZERO,
      totalReach: isSet(object.totalReach) ? Long.fromValue(object.totalReach) : Long.ZERO,
      effectiveCoviewReach: isSet(object.effectiveCoviewReach)
        ? Long.fromValue(object.effectiveCoviewReach)
        : undefined,
      onTargetEffectiveCoviewReach: isSet(object.onTargetEffectiveCoviewReach)
        ? Long.fromValue(object.onTargetEffectiveCoviewReach)
        : undefined,
    };
  },

  toJSON(message: EffectiveFrequencyBreakdown): unknown {
    const obj: any = {};
    if (message.effectiveFrequency !== 0) {
      obj.effectiveFrequency = Math.round(message.effectiveFrequency);
    }
    if (!message.onTargetReach.equals(Long.ZERO)) {
      obj.onTargetReach = (message.onTargetReach || Long.ZERO).toString();
    }
    if (!message.totalReach.equals(Long.ZERO)) {
      obj.totalReach = (message.totalReach || Long.ZERO).toString();
    }
    if (message.effectiveCoviewReach !== undefined) {
      obj.effectiveCoviewReach = (message.effectiveCoviewReach || Long.ZERO).toString();
    }
    if (message.onTargetEffectiveCoviewReach !== undefined) {
      obj.onTargetEffectiveCoviewReach = (message.onTargetEffectiveCoviewReach || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EffectiveFrequencyBreakdown>): EffectiveFrequencyBreakdown {
    return EffectiveFrequencyBreakdown.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EffectiveFrequencyBreakdown>): EffectiveFrequencyBreakdown {
    const message = createBaseEffectiveFrequencyBreakdown();
    message.effectiveFrequency = object.effectiveFrequency ?? 0;
    message.onTargetReach = (object.onTargetReach !== undefined && object.onTargetReach !== null)
      ? Long.fromValue(object.onTargetReach)
      : Long.ZERO;
    message.totalReach = (object.totalReach !== undefined && object.totalReach !== null)
      ? Long.fromValue(object.totalReach)
      : Long.ZERO;
    message.effectiveCoviewReach = (object.effectiveCoviewReach !== undefined && object.effectiveCoviewReach !== null)
      ? Long.fromValue(object.effectiveCoviewReach)
      : undefined;
    message.onTargetEffectiveCoviewReach =
      (object.onTargetEffectiveCoviewReach !== undefined && object.onTargetEffectiveCoviewReach !== null)
        ? Long.fromValue(object.onTargetEffectiveCoviewReach)
        : undefined;
    return message;
  },
};

function createBaseForecastMetricOptions(): ForecastMetricOptions {
  return { includeCoview: false };
}

export const ForecastMetricOptions: MessageFns<ForecastMetricOptions> = {
  encode(message: ForecastMetricOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeCoview !== false) {
      writer.uint32(8).bool(message.includeCoview);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForecastMetricOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForecastMetricOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.includeCoview = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForecastMetricOptions {
    return { includeCoview: isSet(object.includeCoview) ? globalThis.Boolean(object.includeCoview) : false };
  },

  toJSON(message: ForecastMetricOptions): unknown {
    const obj: any = {};
    if (message.includeCoview !== false) {
      obj.includeCoview = message.includeCoview;
    }
    return obj;
  },

  create(base?: DeepPartial<ForecastMetricOptions>): ForecastMetricOptions {
    return ForecastMetricOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForecastMetricOptions>): ForecastMetricOptions {
    const message = createBaseForecastMetricOptions();
    message.includeCoview = object.includeCoview ?? false;
    return message;
  },
};

function createBaseAudienceTargeting(): AudienceTargeting {
  return { userInterest: [] };
}

export const AudienceTargeting: MessageFns<AudienceTargeting> = {
  encode(message: AudienceTargeting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userInterest) {
      UserInterestInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceTargeting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceTargeting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userInterest.push(UserInterestInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceTargeting {
    return {
      userInterest: globalThis.Array.isArray(object?.userInterest)
        ? object.userInterest.map((e: any) => UserInterestInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AudienceTargeting): unknown {
    const obj: any = {};
    if (message.userInterest?.length) {
      obj.userInterest = message.userInterest.map((e) => UserInterestInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceTargeting>): AudienceTargeting {
    return AudienceTargeting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceTargeting>): AudienceTargeting {
    const message = createBaseAudienceTargeting();
    message.userInterest = object.userInterest?.map((e) => UserInterestInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAdvancedProductTargeting(): AdvancedProductTargeting {
  return { surfaceTargetingSettings: undefined, targetFrequencySettings: undefined, youtubeSelectSettings: undefined };
}

export const AdvancedProductTargeting: MessageFns<AdvancedProductTargeting> = {
  encode(message: AdvancedProductTargeting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.surfaceTargetingSettings !== undefined) {
      SurfaceTargeting.encode(message.surfaceTargetingSettings, writer.uint32(18).fork()).join();
    }
    if (message.targetFrequencySettings !== undefined) {
      TargetFrequencySettings.encode(message.targetFrequencySettings, writer.uint32(26).fork()).join();
    }
    if (message.youtubeSelectSettings !== undefined) {
      YouTubeSelectSettings.encode(message.youtubeSelectSettings, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvancedProductTargeting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvancedProductTargeting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.surfaceTargetingSettings = SurfaceTargeting.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetFrequencySettings = TargetFrequencySettings.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.youtubeSelectSettings = YouTubeSelectSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvancedProductTargeting {
    return {
      surfaceTargetingSettings: isSet(object.surfaceTargetingSettings)
        ? SurfaceTargeting.fromJSON(object.surfaceTargetingSettings)
        : undefined,
      targetFrequencySettings: isSet(object.targetFrequencySettings)
        ? TargetFrequencySettings.fromJSON(object.targetFrequencySettings)
        : undefined,
      youtubeSelectSettings: isSet(object.youtubeSelectSettings)
        ? YouTubeSelectSettings.fromJSON(object.youtubeSelectSettings)
        : undefined,
    };
  },

  toJSON(message: AdvancedProductTargeting): unknown {
    const obj: any = {};
    if (message.surfaceTargetingSettings !== undefined) {
      obj.surfaceTargetingSettings = SurfaceTargeting.toJSON(message.surfaceTargetingSettings);
    }
    if (message.targetFrequencySettings !== undefined) {
      obj.targetFrequencySettings = TargetFrequencySettings.toJSON(message.targetFrequencySettings);
    }
    if (message.youtubeSelectSettings !== undefined) {
      obj.youtubeSelectSettings = YouTubeSelectSettings.toJSON(message.youtubeSelectSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<AdvancedProductTargeting>): AdvancedProductTargeting {
    return AdvancedProductTargeting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdvancedProductTargeting>): AdvancedProductTargeting {
    const message = createBaseAdvancedProductTargeting();
    message.surfaceTargetingSettings =
      (object.surfaceTargetingSettings !== undefined && object.surfaceTargetingSettings !== null)
        ? SurfaceTargeting.fromPartial(object.surfaceTargetingSettings)
        : undefined;
    message.targetFrequencySettings =
      (object.targetFrequencySettings !== undefined && object.targetFrequencySettings !== null)
        ? TargetFrequencySettings.fromPartial(object.targetFrequencySettings)
        : undefined;
    message.youtubeSelectSettings =
      (object.youtubeSelectSettings !== undefined && object.youtubeSelectSettings !== null)
        ? YouTubeSelectSettings.fromPartial(object.youtubeSelectSettings)
        : undefined;
    return message;
  },
};

function createBaseYouTubeSelectSettings(): YouTubeSelectSettings {
  return { lineupId: Long.ZERO };
}

export const YouTubeSelectSettings: MessageFns<YouTubeSelectSettings> = {
  encode(message: YouTubeSelectSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.lineupId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.lineupId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YouTubeSelectSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYouTubeSelectSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lineupId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YouTubeSelectSettings {
    return { lineupId: isSet(object.lineupId) ? Long.fromValue(object.lineupId) : Long.ZERO };
  },

  toJSON(message: YouTubeSelectSettings): unknown {
    const obj: any = {};
    if (!message.lineupId.equals(Long.ZERO)) {
      obj.lineupId = (message.lineupId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<YouTubeSelectSettings>): YouTubeSelectSettings {
    return YouTubeSelectSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<YouTubeSelectSettings>): YouTubeSelectSettings {
    const message = createBaseYouTubeSelectSettings();
    message.lineupId = (object.lineupId !== undefined && object.lineupId !== null)
      ? Long.fromValue(object.lineupId)
      : Long.ZERO;
    return message;
  },
};

function createBaseYouTubeSelectLineUp(): YouTubeSelectLineUp {
  return { lineupId: Long.ZERO, lineupName: "" };
}

export const YouTubeSelectLineUp: MessageFns<YouTubeSelectLineUp> = {
  encode(message: YouTubeSelectLineUp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.lineupId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.lineupId.toString());
    }
    if (message.lineupName !== "") {
      writer.uint32(18).string(message.lineupName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YouTubeSelectLineUp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYouTubeSelectLineUp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lineupId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lineupName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YouTubeSelectLineUp {
    return {
      lineupId: isSet(object.lineupId) ? Long.fromValue(object.lineupId) : Long.ZERO,
      lineupName: isSet(object.lineupName) ? globalThis.String(object.lineupName) : "",
    };
  },

  toJSON(message: YouTubeSelectLineUp): unknown {
    const obj: any = {};
    if (!message.lineupId.equals(Long.ZERO)) {
      obj.lineupId = (message.lineupId || Long.ZERO).toString();
    }
    if (message.lineupName !== "") {
      obj.lineupName = message.lineupName;
    }
    return obj;
  },

  create(base?: DeepPartial<YouTubeSelectLineUp>): YouTubeSelectLineUp {
    return YouTubeSelectLineUp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<YouTubeSelectLineUp>): YouTubeSelectLineUp {
    const message = createBaseYouTubeSelectLineUp();
    message.lineupId = (object.lineupId !== undefined && object.lineupId !== null)
      ? Long.fromValue(object.lineupId)
      : Long.ZERO;
    message.lineupName = object.lineupName ?? "";
    return message;
  },
};

function createBaseSurfaceTargetingCombinations(): SurfaceTargetingCombinations {
  return { defaultTargeting: undefined, availableTargetingCombinations: [] };
}

export const SurfaceTargetingCombinations: MessageFns<SurfaceTargetingCombinations> = {
  encode(message: SurfaceTargetingCombinations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultTargeting !== undefined) {
      SurfaceTargeting.encode(message.defaultTargeting, writer.uint32(10).fork()).join();
    }
    for (const v of message.availableTargetingCombinations) {
      SurfaceTargeting.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SurfaceTargetingCombinations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSurfaceTargetingCombinations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.defaultTargeting = SurfaceTargeting.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.availableTargetingCombinations.push(SurfaceTargeting.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SurfaceTargetingCombinations {
    return {
      defaultTargeting: isSet(object.defaultTargeting) ? SurfaceTargeting.fromJSON(object.defaultTargeting) : undefined,
      availableTargetingCombinations: globalThis.Array.isArray(object?.availableTargetingCombinations)
        ? object.availableTargetingCombinations.map((e: any) => SurfaceTargeting.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SurfaceTargetingCombinations): unknown {
    const obj: any = {};
    if (message.defaultTargeting !== undefined) {
      obj.defaultTargeting = SurfaceTargeting.toJSON(message.defaultTargeting);
    }
    if (message.availableTargetingCombinations?.length) {
      obj.availableTargetingCombinations = message.availableTargetingCombinations.map((e) =>
        SurfaceTargeting.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<SurfaceTargetingCombinations>): SurfaceTargetingCombinations {
    return SurfaceTargetingCombinations.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SurfaceTargetingCombinations>): SurfaceTargetingCombinations {
    const message = createBaseSurfaceTargetingCombinations();
    message.defaultTargeting = (object.defaultTargeting !== undefined && object.defaultTargeting !== null)
      ? SurfaceTargeting.fromPartial(object.defaultTargeting)
      : undefined;
    message.availableTargetingCombinations =
      object.availableTargetingCombinations?.map((e) => SurfaceTargeting.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSurfaceTargeting(): SurfaceTargeting {
  return { surfaces: [] };
}

export const SurfaceTargeting: MessageFns<SurfaceTargeting> = {
  encode(message: SurfaceTargeting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.surfaces) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SurfaceTargeting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSurfaceTargeting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.surfaces.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.surfaces.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SurfaceTargeting {
    return {
      surfaces: globalThis.Array.isArray(object?.surfaces)
        ? object.surfaces.map((e: any) => reachPlanSurfaceEnum_ReachPlanSurfaceFromJSON(e))
        : [],
    };
  },

  toJSON(message: SurfaceTargeting): unknown {
    const obj: any = {};
    if (message.surfaces?.length) {
      obj.surfaces = message.surfaces.map((e) => reachPlanSurfaceEnum_ReachPlanSurfaceToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SurfaceTargeting>): SurfaceTargeting {
    return SurfaceTargeting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SurfaceTargeting>): SurfaceTargeting {
    const message = createBaseSurfaceTargeting();
    message.surfaces = object.surfaces?.map((e) => e) || [];
    return message;
  },
};

function createBaseTargetFrequencySettings(): TargetFrequencySettings {
  return { timeUnit: 0, targetFrequency: 0 };
}

export const TargetFrequencySettings: MessageFns<TargetFrequencySettings> = {
  encode(message: TargetFrequencySettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeUnit !== 0) {
      writer.uint32(8).int32(message.timeUnit);
    }
    if (message.targetFrequency !== 0) {
      writer.uint32(16).int32(message.targetFrequency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetFrequencySettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetFrequencySettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.timeUnit = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetFrequency = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetFrequencySettings {
    return {
      timeUnit: isSet(object.timeUnit)
        ? targetFrequencyTimeUnitEnum_TargetFrequencyTimeUnitFromJSON(object.timeUnit)
        : 0,
      targetFrequency: isSet(object.targetFrequency) ? globalThis.Number(object.targetFrequency) : 0,
    };
  },

  toJSON(message: TargetFrequencySettings): unknown {
    const obj: any = {};
    if (message.timeUnit !== 0) {
      obj.timeUnit = targetFrequencyTimeUnitEnum_TargetFrequencyTimeUnitToJSON(message.timeUnit);
    }
    if (message.targetFrequency !== 0) {
      obj.targetFrequency = Math.round(message.targetFrequency);
    }
    return obj;
  },

  create(base?: DeepPartial<TargetFrequencySettings>): TargetFrequencySettings {
    return TargetFrequencySettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetFrequencySettings>): TargetFrequencySettings {
    const message = createBaseTargetFrequencySettings();
    message.timeUnit = object.timeUnit ?? 0;
    message.targetFrequency = object.targetFrequency ?? 0;
    return message;
  },
};

/**
 * Reach Plan Service gives users information about audience size that can
 * be reached through advertisement on YouTube. In particular,
 * GenerateReachForecast provides estimated number of people of specified
 * demographics that can be reached by an ad in a given market by a campaign of
 * certain duration with a defined budget.
 */
export type ReachPlanServiceDefinition = typeof ReachPlanServiceDefinition;
export const ReachPlanServiceDefinition = {
  name: "ReachPlanService",
  fullName: "google.ads.googleads.v17.services.ReachPlanService",
  methods: {
    /**
     * Returns the list of plannable locations (for example, countries).
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [QuotaError]()
     *   [RequestError]()
     */
    listPlannableLocations: {
      name: "ListPlannableLocations",
      requestType: ListPlannableLocationsRequest,
      requestStream: false,
      responseType: ListPlannableLocationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              32,
              58,
              1,
              42,
              34,
              27,
              47,
              118,
              49,
              55,
              58,
              108,
              105,
              115,
              116,
              80,
              108,
              97,
              110,
              110,
              97,
              98,
              108,
              101,
              76,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns the list of per-location plannable YouTube ad formats with allowed
     * targeting.
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [QuotaError]()
     *   [RequestError]()
     */
    listPlannableProducts: {
      name: "ListPlannableProducts",
      requestType: ListPlannableProductsRequest,
      requestStream: false,
      responseType: ListPlannableProductsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              112,
              108,
              97,
              110,
              110,
              97,
              98,
              108,
              101,
              95,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              31,
              58,
              1,
              42,
              34,
              26,
              47,
              118,
              49,
              55,
              58,
              108,
              105,
              115,
              116,
              80,
              108,
              97,
              110,
              110,
              97,
              98,
              108,
              101,
              80,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Generates a reach forecast for a given targeting / product mix.
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [FieldError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [QuotaError]()
     *   [RangeError]()
     *   [ReachPlanError]()
     *   [RequestError]()
     */
    generateReachForecast: {
      name: "GenerateReachForecast",
      requestType: GenerateReachForecastRequest,
      requestStream: false,
      responseType: GenerateReachForecastResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              46,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              44,
              99,
              97,
              109,
              112,
              97,
              105,
              103,
              110,
              95,
              100,
              117,
              114,
              97,
              116,
              105,
              111,
              110,
              44,
              112,
              108,
              97,
              110,
              110,
              101,
              100,
              95,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              57,
              58,
              1,
              42,
              34,
              52,
              47,
              118,
              49,
              55,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              61,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              82,
              101,
              97,
              99,
              104,
              70,
              111,
              114,
              101,
              99,
              97,
              115,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ReachPlanServiceImplementation<CallContextExt = {}> {
  /**
   * Returns the list of plannable locations (for example, countries).
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  listPlannableLocations(
    request: ListPlannableLocationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPlannableLocationsResponse>>;
  /**
   * Returns the list of per-location plannable YouTube ad formats with allowed
   * targeting.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  listPlannableProducts(
    request: ListPlannableProductsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPlannableProductsResponse>>;
  /**
   * Generates a reach forecast for a given targeting / product mix.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [ReachPlanError]()
   *   [RequestError]()
   */
  generateReachForecast(
    request: GenerateReachForecastRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateReachForecastResponse>>;
}

export interface ReachPlanServiceClient<CallOptionsExt = {}> {
  /**
   * Returns the list of plannable locations (for example, countries).
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  listPlannableLocations(
    request: DeepPartial<ListPlannableLocationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPlannableLocationsResponse>;
  /**
   * Returns the list of per-location plannable YouTube ad formats with allowed
   * targeting.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  listPlannableProducts(
    request: DeepPartial<ListPlannableProductsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPlannableProductsResponse>;
  /**
   * Generates a reach forecast for a given targeting / product mix.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [FieldError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RangeError]()
   *   [ReachPlanError]()
   *   [RequestError]()
   */
  generateReachForecast(
    request: DeepPartial<GenerateReachForecastRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateReachForecastResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
