// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/googleads/v17/services/keyword_plan_idea_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { KeywordInfo } from "../common/criteria.js";
import { DateRange } from "../common/dates.js";
import {
  HistoricalMetricsOptions,
  KeywordAnnotations,
  KeywordPlanAggregateMetricResults,
  KeywordPlanAggregateMetrics,
  KeywordPlanHistoricalMetrics,
} from "../common/keyword_plan_common.js";
import {
  KeywordMatchTypeEnum_KeywordMatchType,
  keywordMatchTypeEnum_KeywordMatchTypeFromJSON,
  keywordMatchTypeEnum_KeywordMatchTypeToJSON,
} from "../enums/keyword_match_type.js";
import {
  KeywordPlanKeywordAnnotationEnum_KeywordPlanKeywordAnnotation,
  keywordPlanKeywordAnnotationEnum_KeywordPlanKeywordAnnotationFromJSON,
  keywordPlanKeywordAnnotationEnum_KeywordPlanKeywordAnnotationToJSON,
} from "../enums/keyword_plan_keyword_annotation.js";
import {
  KeywordPlanNetworkEnum_KeywordPlanNetwork,
  keywordPlanNetworkEnum_KeywordPlanNetworkFromJSON,
  keywordPlanNetworkEnum_KeywordPlanNetworkToJSON,
} from "../enums/keyword_plan_network.js";

export const protobufPackage = "google.ads.googleads.v17.services";

/**
 * Request message for
 * [KeywordPlanIdeaService.GenerateKeywordIdeas][google.ads.googleads.v17.services.KeywordPlanIdeaService.GenerateKeywordIdeas].
 */
export interface GenerateKeywordIdeasRequest {
  /** The ID of the customer with the recommendation. */
  customerId: string;
  /**
   * The resource name of the language to target.
   * Each keyword belongs to some set of languages; a keyword is included if
   * language is one of its languages.
   * If not set, all keywords will be included.
   */
  language?:
    | string
    | undefined;
  /**
   * The resource names of the location to target. Maximum is 10.
   * An empty list MAY be used to specify all targeting geos.
   */
  geoTargetConstants: string[];
  /**
   * If true, adult keywords will be included in response.
   * The default value is false.
   */
  includeAdultKeywords: boolean;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. To request next page of results use the
   * value obtained from `next_page_token` in the previous response.
   * The request fields must match across pages.
   */
  pageToken: string;
  /**
   * Number of results to retrieve in a single page.
   * A maximum of 10,000 results may be returned, if the page_size
   * exceeds this, it is ignored.
   * If unspecified, at most 10,000 results will be returned.
   * The server may decide to further limit the number of returned resources.
   * If the response contains fewer than 10,000 results it may not be assumed
   * as last page of results.
   */
  pageSize: number;
  /**
   * Targeting network.
   * If not set, Google Search And Partners Network will be used.
   */
  keywordPlanNetwork: KeywordPlanNetworkEnum_KeywordPlanNetwork;
  /** The keyword annotations to include in response. */
  keywordAnnotation: KeywordPlanKeywordAnnotationEnum_KeywordPlanKeywordAnnotation[];
  /** The aggregate fields to include in response. */
  aggregateMetrics:
    | KeywordPlanAggregateMetrics
    | undefined;
  /** The options for historical metrics data. */
  historicalMetricsOptions:
    | HistoricalMetricsOptions
    | undefined;
  /**
   * A Keyword and a specific Url to generate ideas from
   * for example, cars, www.example.com/cars.
   */
  keywordAndUrlSeed?:
    | KeywordAndUrlSeed
    | undefined;
  /** A Keyword or phrase to generate ideas from, for example, cars. */
  keywordSeed?:
    | KeywordSeed
    | undefined;
  /** A specific url to generate ideas from, for example, www.example.com/cars. */
  urlSeed?:
    | UrlSeed
    | undefined;
  /** The site to generate ideas from, for example, www.example.com. */
  siteSeed?: SiteSeed | undefined;
}

/** Keyword And Url Seed */
export interface KeywordAndUrlSeed {
  /** The URL to crawl in order to generate keyword ideas. */
  url?:
    | string
    | undefined;
  /** Requires at least one keyword. */
  keywords: string[];
}

/** Keyword Seed */
export interface KeywordSeed {
  /** Requires at least one keyword. */
  keywords: string[];
}

/** Site Seed */
export interface SiteSeed {
  /**
   * The domain name of the site. If the customer requesting the ideas doesn't
   * own the site provided only public information is returned.
   */
  site?: string | undefined;
}

/** Url Seed */
export interface UrlSeed {
  /** The URL to crawl in order to generate keyword ideas. */
  url?: string | undefined;
}

/**
 * Response message for
 * [KeywordPlanIdeaService.GenerateKeywordIdeas][google.ads.googleads.v17.services.KeywordPlanIdeaService.GenerateKeywordIdeas].
 */
export interface GenerateKeywordIdeaResponse {
  /** Results of generating keyword ideas. */
  results: GenerateKeywordIdeaResult[];
  /** The aggregate metrics for all keyword ideas. */
  aggregateMetricResults:
    | KeywordPlanAggregateMetricResults
    | undefined;
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request.
   * `next_page_token` is not returned for the last page.
   */
  nextPageToken: string;
  /** Total number of results available. */
  totalSize: Long;
}

/** The result of generating keyword ideas. */
export interface GenerateKeywordIdeaResult {
  /**
   * Text of the keyword idea.
   * As in Keyword Plan historical metrics, this text may not be an actual
   * keyword, but the canonical form of multiple keywords.
   * See KeywordPlanKeywordHistoricalMetrics message in KeywordPlanService.
   */
  text?:
    | string
    | undefined;
  /** The historical metrics for the keyword. */
  keywordIdeaMetrics:
    | KeywordPlanHistoricalMetrics
    | undefined;
  /**
   * The annotations for the keyword.
   * The annotation data is only provided if requested.
   */
  keywordAnnotations:
    | KeywordAnnotations
    | undefined;
  /**
   * The list of close variants from the requested keywords that
   * are combined into this GenerateKeywordIdeaResult. See
   * https://support.google.com/google-ads/answer/9342105 for the
   * definition of "close variants".
   */
  closeVariants: string[];
}

/**
 * Request message for
 * [KeywordPlanIdeaService.GenerateKeywordHistoricalMetrics][google.ads.googleads.v17.services.KeywordPlanIdeaService.GenerateKeywordHistoricalMetrics].
 */
export interface GenerateKeywordHistoricalMetricsRequest {
  /** The ID of the customer with the recommendation. */
  customerId: string;
  /**
   * A list of keywords to get historical metrics.
   * Not all inputs will be returned as a result of near-exact deduplication.
   * For example, if stats for "car" and "cars" are requested, only "car" will
   * be returned.
   * A maximum of 10,000 keywords can be used.
   */
  keywords: string[];
  /**
   * The resource name of the language to target.
   * Each keyword belongs to some set of languages; a keyword is included if
   * language is one of its languages.
   * If not set, all keywords will be included.
   */
  language?:
    | string
    | undefined;
  /**
   * If true, adult keywords will be included in response.
   * The default value is false.
   */
  includeAdultKeywords: boolean;
  /**
   * The resource names of the location to target. Maximum is 10.
   * An empty list MAY be used to specify all targeting geos.
   */
  geoTargetConstants: string[];
  /**
   * Targeting network.
   * If not set, Google Search And Partners Network will be used.
   */
  keywordPlanNetwork: KeywordPlanNetworkEnum_KeywordPlanNetwork;
  /** The aggregate fields to include in response. */
  aggregateMetrics:
    | KeywordPlanAggregateMetrics
    | undefined;
  /** The options for historical metrics data. */
  historicalMetricsOptions: HistoricalMetricsOptions | undefined;
}

/**
 * Response message for
 * [KeywordPlanIdeaService.GenerateKeywordHistoricalMetrics][google.ads.googleads.v17.services.KeywordPlanIdeaService.GenerateKeywordHistoricalMetrics].
 */
export interface GenerateKeywordHistoricalMetricsResponse {
  /** List of keywords and their historical metrics. */
  results: GenerateKeywordHistoricalMetricsResult[];
  /** The aggregate metrics for all keywords. */
  aggregateMetricResults: KeywordPlanAggregateMetricResults | undefined;
}

/** The result of generating keyword historical metrics. */
export interface GenerateKeywordHistoricalMetricsResult {
  /**
   * The text of the query associated with one or more keywords.
   * Note that we de-dupe your keywords list, eliminating close variants
   * before returning the keywords as text. For example, if your request
   * originally contained the keywords "car" and "cars", the returned search
   * query will only contain "cars". The list of de-duped queries will be
   * included in close_variants field.
   */
  text?:
    | string
    | undefined;
  /**
   * The list of close variants from the requested keywords whose stats
   * are combined into this GenerateKeywordHistoricalMetricsResult.
   */
  closeVariants: string[];
  /** The historical metrics for text and its close variants */
  keywordMetrics: KeywordPlanHistoricalMetrics | undefined;
}

/**
 * Request message for
 * [KeywordPlanIdeaService.GenerateAdGroupThemes][google.ads.googleads.v17.services.KeywordPlanIdeaService.GenerateAdGroupThemes].
 */
export interface GenerateAdGroupThemesRequest {
  /** Required. The ID of the customer. */
  customerId: string;
  /** Required. A list of keywords to group into the provided AdGroups. */
  keywords: string[];
  /**
   * Required. A list of resource names of AdGroups to group keywords into.
   *  Resource name format: `customers/{customer_id}/adGroups/{ad_group_id}`
   */
  adGroups: string[];
}

/**
 * Response message for
 * [KeywordPlanIdeaService.GenerateAdGroupThemes][google.ads.googleads.v17.services.KeywordPlanIdeaService.GenerateAdGroupThemes].
 */
export interface GenerateAdGroupThemesResponse {
  /** A list of suggested AdGroup/keyword pairings. */
  adGroupKeywordSuggestions: AdGroupKeywordSuggestion[];
  /** A list of provided AdGroups that could not be used as suggestions. */
  unusableAdGroups: UnusableAdGroup[];
}

/** The suggested text and AdGroup/Campaign pairing for a given keyword. */
export interface AdGroupKeywordSuggestion {
  /** The original keyword text. */
  keywordText: string;
  /** The normalized version of keyword_text for BROAD/EXACT/PHRASE suggestions. */
  suggestedKeywordText: string;
  /** The suggested keyword match type. */
  suggestedMatchType: KeywordMatchTypeEnum_KeywordMatchType;
  /**
   * The suggested AdGroup for the keyword.
   * Resource name format: `customers/{customer_id}/adGroups/{ad_group_id}`
   */
  suggestedAdGroup: string;
  /**
   * The suggested Campaign for the keyword.
   * Resource name format: `customers/{customer_id}/campaigns/{campaign_id}`
   */
  suggestedCampaign: string;
}

/**
 * An AdGroup/Campaign pair that could not be used as a suggestion for keywords.
 *
 * AdGroups may not be usable if the AdGroup
 *
 * * belongs to a Campaign that is not ENABLED or PAUSED
 * * is itself not ENABLED
 */
export interface UnusableAdGroup {
  /**
   * The AdGroup resource name.
   * Resource name format: `customers/{customer_id}/adGroups/{ad_group_id}`
   */
  adGroup: string;
  /**
   * The Campaign resource name.
   * Resource name format: `customers/{customer_id}/campaigns/{campaign_id}`
   */
  campaign: string;
}

/** Request message for [KeywordPlanIdeaService.GenerateKeywordForecastMetrics]. */
export interface GenerateKeywordForecastMetricsRequest {
  /** The ID of the customer. */
  customerId: string;
  /**
   * The currency used for exchange rate conversion.
   * By default, the account currency of the customer is used.
   * Set this field only if the currency is different from the account currency.
   * The list of valid currency codes can be found at
   * https://developers.google.com/google-ads/api/data/codes-formats#currency-codes.
   */
  currencyCode?:
    | string
    | undefined;
  /**
   * The date range for the forecast. The start date must be in the future and
   * end date must be within 1 year from today. The reference timezone used is
   * the one of the Google Ads account belonging to the customer. If not set, a
   * default date range from next Sunday to the following Saturday will be used.
   */
  forecastPeriod:
    | DateRange
    | undefined;
  /** Required. The campaign used in the forecast. */
  campaign: CampaignToForecast | undefined;
}

/** A campaign to do a keyword campaign forecast. */
export interface CampaignToForecast {
  /**
   * The list of resource names of languages to be targeted. The resource name
   * is of the format "languageConstants/{criterion_id}". See
   * https://developers.google.com/google-ads/api/data/codes-formats#languages
   * for the list of language criterion codes.
   */
  languageConstants: string[];
  /** Locations to be targeted. Locations must be unique. */
  geoModifiers: CriterionBidModifier[];
  /** Required. The network used for targeting. */
  keywordPlanNetwork: KeywordPlanNetworkEnum_KeywordPlanNetwork;
  /**
   * The list of negative keywords to be used in the campaign when doing the
   * forecast.
   */
  negativeKeywords: KeywordInfo[];
  /** Required. The bidding strategy for the campaign. */
  biddingStrategy:
    | CampaignToForecast_CampaignBiddingStrategy
    | undefined;
  /**
   * The expected conversion rate (number of conversions divided by number of
   * total clicks) as defined by the user. This value is expressed as a decimal
   * value, so an expected conversion rate of 2% should be entered as 0.02. If
   * left empty, an estimated conversion rate will be used.
   */
  conversionRate?:
    | number
    | undefined;
  /** The ad groups in the new campaign to forecast. */
  adGroups: ForecastAdGroup[];
}

/** Supported bidding strategies for new campaign forecasts. */
export interface CampaignToForecast_CampaignBiddingStrategy {
  /** Use manual CPC bidding strategy for forecasting. */
  manualCpcBiddingStrategy?:
    | ManualCpcBiddingStrategy
    | undefined;
  /** Use maximize clicks bidding strategy for forecasting. */
  maximizeClicksBiddingStrategy?:
    | MaximizeClicksBiddingStrategy
    | undefined;
  /** Use maximize conversions bidding strategy for forecasting. */
  maximizeConversionsBiddingStrategy?: MaximizeConversionsBiddingStrategy | undefined;
}

/** An ad group that is part of a campaign to be forecasted. */
export interface ForecastAdGroup {
  /**
   * The max cpc to use for the ad group when generating forecasted traffic.
   * This value will override the max cpc value set in the bidding strategy.
   * Only specify this field for bidding strategies that max cpc values.
   */
  maxCpcBidMicros?:
    | Long
    | undefined;
  /**
   * Required. The list of biddable keywords to be used in the ad group when
   * doing the forecast. Requires at least one keyword.
   */
  biddableKeywords: BiddableKeyword[];
  /**
   * The details of the keyword. You should specify both the keyword text and
   * match type.
   */
  negativeKeywords: KeywordInfo[];
}

/** A biddable keyword part of an ad group. */
export interface BiddableKeyword {
  /** Required. Keyword. Must have text and match type. */
  keyword:
    | KeywordInfo
    | undefined;
  /**
   * A max cpc bid in micros that overrides the ad group level max cpc bid in
   * forecast simulation. This value will override the max cpc value set in the
   * bidding strategy and ad group. Only specify this field for bidding
   * strategies that support max cpc values.
   */
  maxCpcBidMicros?: Long | undefined;
}

/** Location Criterion bid modifier. */
export interface CriterionBidModifier {
  /**
   * The resource name of the geo location to target. The resource name is of
   * the format "geoTargetConstants/{criterion_id}".
   */
  geoTargetConstant: string;
  /**
   * The associated multiplier for the criterion_id. If set, this value cannot
   * be 0.
   */
  bidModifier?: number | undefined;
}

/** Manual CPC Bidding Strategy. */
export interface ManualCpcBiddingStrategy {
  /**
   * Campaign level budget in micros. If set, a minimum value
   * is enforced for the local currency used in the campaign. An error
   * will occur showing the minimum value if this field is set too low.
   */
  dailyBudgetMicros?:
    | Long
    | undefined;
  /**
   * Required. A bid in micros to be applied to ad groups within the campaign
   * for a manual CPC bidding strategy.
   */
  maxCpcBidMicros: Long;
}

/** Maximize Clicks Bidding Strategy. */
export interface MaximizeClicksBiddingStrategy {
  /**
   * Required. The daily target spend in micros to be used for estimation. A
   * minimum value is enforced for the local currency used in the campaign. An
   * error will occur showing the minimum value if this field is set too low.
   */
  dailyTargetSpendMicros: Long;
  /** Ceiling on max CPC bids in micros. */
  maxCpcBidCeilingMicros?: Long | undefined;
}

/** Maximize Conversions Bidding Strategy. */
export interface MaximizeConversionsBiddingStrategy {
  /**
   * Required. The daily target spend in micros to be used for estimation. This
   * value must be greater than zero.
   */
  dailyTargetSpendMicros: Long;
}

/** Response message for [KeywordPlanIdeaService.GenerateKeywordForecastMetrics]. */
export interface GenerateKeywordForecastMetricsResponse {
  /** Results of the campaign forecast. */
  campaignForecastMetrics?: KeywordForecastMetrics | undefined;
}

/** The forecast metrics for the planless keyword campaign. */
export interface KeywordForecastMetrics {
  /** The total number of impressions. */
  impressions?:
    | number
    | undefined;
  /** The average click through rate. Available only if impressions > 0. */
  clickThroughRate?:
    | number
    | undefined;
  /** The average cpc. Available only if clicks > 0. */
  averageCpcMicros?:
    | Long
    | undefined;
  /** The total number of clicks. */
  clicks?:
    | number
    | undefined;
  /** The total cost. */
  costMicros?:
    | Long
    | undefined;
  /** Forecasted number of conversions: clicks * conversion_rate. */
  conversions?:
    | number
    | undefined;
  /** Forecasted conversion rate. */
  conversionRate?:
    | number
    | undefined;
  /** Average cost per acquisition calculated as cost_micros / conversions. */
  averageCpaMicros?: Long | undefined;
}

function createBaseGenerateKeywordIdeasRequest(): GenerateKeywordIdeasRequest {
  return {
    customerId: "",
    language: undefined,
    geoTargetConstants: [],
    includeAdultKeywords: false,
    pageToken: "",
    pageSize: 0,
    keywordPlanNetwork: 0,
    keywordAnnotation: [],
    aggregateMetrics: undefined,
    historicalMetricsOptions: undefined,
    keywordAndUrlSeed: undefined,
    keywordSeed: undefined,
    urlSeed: undefined,
    siteSeed: undefined,
  };
}

export const GenerateKeywordIdeasRequest: MessageFns<GenerateKeywordIdeasRequest> = {
  encode(message: GenerateKeywordIdeasRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.language !== undefined) {
      writer.uint32(114).string(message.language);
    }
    for (const v of message.geoTargetConstants) {
      writer.uint32(122).string(v!);
    }
    if (message.includeAdultKeywords !== false) {
      writer.uint32(80).bool(message.includeAdultKeywords);
    }
    if (message.pageToken !== "") {
      writer.uint32(98).string(message.pageToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(104).int32(message.pageSize);
    }
    if (message.keywordPlanNetwork !== 0) {
      writer.uint32(72).int32(message.keywordPlanNetwork);
    }
    writer.uint32(138).fork();
    for (const v of message.keywordAnnotation) {
      writer.int32(v);
    }
    writer.join();
    if (message.aggregateMetrics !== undefined) {
      KeywordPlanAggregateMetrics.encode(message.aggregateMetrics, writer.uint32(130).fork()).join();
    }
    if (message.historicalMetricsOptions !== undefined) {
      HistoricalMetricsOptions.encode(message.historicalMetricsOptions, writer.uint32(146).fork()).join();
    }
    if (message.keywordAndUrlSeed !== undefined) {
      KeywordAndUrlSeed.encode(message.keywordAndUrlSeed, writer.uint32(18).fork()).join();
    }
    if (message.keywordSeed !== undefined) {
      KeywordSeed.encode(message.keywordSeed, writer.uint32(26).fork()).join();
    }
    if (message.urlSeed !== undefined) {
      UrlSeed.encode(message.urlSeed, writer.uint32(42).fork()).join();
    }
    if (message.siteSeed !== undefined) {
      SiteSeed.encode(message.siteSeed, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateKeywordIdeasRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateKeywordIdeasRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.language = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.geoTargetConstants.push(reader.string());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.includeAdultKeywords = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.keywordPlanNetwork = reader.int32() as any;
          continue;
        case 17:
          if (tag === 136) {
            message.keywordAnnotation.push(reader.int32() as any);

            continue;
          }

          if (tag === 138) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.keywordAnnotation.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.aggregateMetrics = KeywordPlanAggregateMetrics.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.historicalMetricsOptions = HistoricalMetricsOptions.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keywordAndUrlSeed = KeywordAndUrlSeed.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keywordSeed = KeywordSeed.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.urlSeed = UrlSeed.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.siteSeed = SiteSeed.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateKeywordIdeasRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : undefined,
      geoTargetConstants: globalThis.Array.isArray(object?.geoTargetConstants)
        ? object.geoTargetConstants.map((e: any) => globalThis.String(e))
        : [],
      includeAdultKeywords: isSet(object.includeAdultKeywords)
        ? globalThis.Boolean(object.includeAdultKeywords)
        : false,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      keywordPlanNetwork: isSet(object.keywordPlanNetwork)
        ? keywordPlanNetworkEnum_KeywordPlanNetworkFromJSON(object.keywordPlanNetwork)
        : 0,
      keywordAnnotation: globalThis.Array.isArray(object?.keywordAnnotation)
        ? object.keywordAnnotation.map((e: any) =>
          keywordPlanKeywordAnnotationEnum_KeywordPlanKeywordAnnotationFromJSON(e)
        )
        : [],
      aggregateMetrics: isSet(object.aggregateMetrics)
        ? KeywordPlanAggregateMetrics.fromJSON(object.aggregateMetrics)
        : undefined,
      historicalMetricsOptions: isSet(object.historicalMetricsOptions)
        ? HistoricalMetricsOptions.fromJSON(object.historicalMetricsOptions)
        : undefined,
      keywordAndUrlSeed: isSet(object.keywordAndUrlSeed)
        ? KeywordAndUrlSeed.fromJSON(object.keywordAndUrlSeed)
        : undefined,
      keywordSeed: isSet(object.keywordSeed) ? KeywordSeed.fromJSON(object.keywordSeed) : undefined,
      urlSeed: isSet(object.urlSeed) ? UrlSeed.fromJSON(object.urlSeed) : undefined,
      siteSeed: isSet(object.siteSeed) ? SiteSeed.fromJSON(object.siteSeed) : undefined,
    };
  },

  toJSON(message: GenerateKeywordIdeasRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.language !== undefined) {
      obj.language = message.language;
    }
    if (message.geoTargetConstants?.length) {
      obj.geoTargetConstants = message.geoTargetConstants;
    }
    if (message.includeAdultKeywords !== false) {
      obj.includeAdultKeywords = message.includeAdultKeywords;
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.keywordPlanNetwork !== 0) {
      obj.keywordPlanNetwork = keywordPlanNetworkEnum_KeywordPlanNetworkToJSON(message.keywordPlanNetwork);
    }
    if (message.keywordAnnotation?.length) {
      obj.keywordAnnotation = message.keywordAnnotation.map((e) =>
        keywordPlanKeywordAnnotationEnum_KeywordPlanKeywordAnnotationToJSON(e)
      );
    }
    if (message.aggregateMetrics !== undefined) {
      obj.aggregateMetrics = KeywordPlanAggregateMetrics.toJSON(message.aggregateMetrics);
    }
    if (message.historicalMetricsOptions !== undefined) {
      obj.historicalMetricsOptions = HistoricalMetricsOptions.toJSON(message.historicalMetricsOptions);
    }
    if (message.keywordAndUrlSeed !== undefined) {
      obj.keywordAndUrlSeed = KeywordAndUrlSeed.toJSON(message.keywordAndUrlSeed);
    }
    if (message.keywordSeed !== undefined) {
      obj.keywordSeed = KeywordSeed.toJSON(message.keywordSeed);
    }
    if (message.urlSeed !== undefined) {
      obj.urlSeed = UrlSeed.toJSON(message.urlSeed);
    }
    if (message.siteSeed !== undefined) {
      obj.siteSeed = SiteSeed.toJSON(message.siteSeed);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateKeywordIdeasRequest>): GenerateKeywordIdeasRequest {
    return GenerateKeywordIdeasRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateKeywordIdeasRequest>): GenerateKeywordIdeasRequest {
    const message = createBaseGenerateKeywordIdeasRequest();
    message.customerId = object.customerId ?? "";
    message.language = object.language ?? undefined;
    message.geoTargetConstants = object.geoTargetConstants?.map((e) => e) || [];
    message.includeAdultKeywords = object.includeAdultKeywords ?? false;
    message.pageToken = object.pageToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.keywordPlanNetwork = object.keywordPlanNetwork ?? 0;
    message.keywordAnnotation = object.keywordAnnotation?.map((e) => e) || [];
    message.aggregateMetrics = (object.aggregateMetrics !== undefined && object.aggregateMetrics !== null)
      ? KeywordPlanAggregateMetrics.fromPartial(object.aggregateMetrics)
      : undefined;
    message.historicalMetricsOptions =
      (object.historicalMetricsOptions !== undefined && object.historicalMetricsOptions !== null)
        ? HistoricalMetricsOptions.fromPartial(object.historicalMetricsOptions)
        : undefined;
    message.keywordAndUrlSeed = (object.keywordAndUrlSeed !== undefined && object.keywordAndUrlSeed !== null)
      ? KeywordAndUrlSeed.fromPartial(object.keywordAndUrlSeed)
      : undefined;
    message.keywordSeed = (object.keywordSeed !== undefined && object.keywordSeed !== null)
      ? KeywordSeed.fromPartial(object.keywordSeed)
      : undefined;
    message.urlSeed = (object.urlSeed !== undefined && object.urlSeed !== null)
      ? UrlSeed.fromPartial(object.urlSeed)
      : undefined;
    message.siteSeed = (object.siteSeed !== undefined && object.siteSeed !== null)
      ? SiteSeed.fromPartial(object.siteSeed)
      : undefined;
    return message;
  },
};

function createBaseKeywordAndUrlSeed(): KeywordAndUrlSeed {
  return { url: undefined, keywords: [] };
}

export const KeywordAndUrlSeed: MessageFns<KeywordAndUrlSeed> = {
  encode(message: KeywordAndUrlSeed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== undefined) {
      writer.uint32(26).string(message.url);
    }
    for (const v of message.keywords) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeywordAndUrlSeed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeywordAndUrlSeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.keywords.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeywordAndUrlSeed {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
      keywords: globalThis.Array.isArray(object?.keywords) ? object.keywords.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: KeywordAndUrlSeed): unknown {
    const obj: any = {};
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    if (message.keywords?.length) {
      obj.keywords = message.keywords;
    }
    return obj;
  },

  create(base?: DeepPartial<KeywordAndUrlSeed>): KeywordAndUrlSeed {
    return KeywordAndUrlSeed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeywordAndUrlSeed>): KeywordAndUrlSeed {
    const message = createBaseKeywordAndUrlSeed();
    message.url = object.url ?? undefined;
    message.keywords = object.keywords?.map((e) => e) || [];
    return message;
  },
};

function createBaseKeywordSeed(): KeywordSeed {
  return { keywords: [] };
}

export const KeywordSeed: MessageFns<KeywordSeed> = {
  encode(message: KeywordSeed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keywords) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeywordSeed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeywordSeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keywords.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeywordSeed {
    return {
      keywords: globalThis.Array.isArray(object?.keywords) ? object.keywords.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: KeywordSeed): unknown {
    const obj: any = {};
    if (message.keywords?.length) {
      obj.keywords = message.keywords;
    }
    return obj;
  },

  create(base?: DeepPartial<KeywordSeed>): KeywordSeed {
    return KeywordSeed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeywordSeed>): KeywordSeed {
    const message = createBaseKeywordSeed();
    message.keywords = object.keywords?.map((e) => e) || [];
    return message;
  },
};

function createBaseSiteSeed(): SiteSeed {
  return { site: undefined };
}

export const SiteSeed: MessageFns<SiteSeed> = {
  encode(message: SiteSeed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.site !== undefined) {
      writer.uint32(18).string(message.site);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SiteSeed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSiteSeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.site = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SiteSeed {
    return { site: isSet(object.site) ? globalThis.String(object.site) : undefined };
  },

  toJSON(message: SiteSeed): unknown {
    const obj: any = {};
    if (message.site !== undefined) {
      obj.site = message.site;
    }
    return obj;
  },

  create(base?: DeepPartial<SiteSeed>): SiteSeed {
    return SiteSeed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SiteSeed>): SiteSeed {
    const message = createBaseSiteSeed();
    message.site = object.site ?? undefined;
    return message;
  },
};

function createBaseUrlSeed(): UrlSeed {
  return { url: undefined };
}

export const UrlSeed: MessageFns<UrlSeed> = {
  encode(message: UrlSeed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== undefined) {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UrlSeed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUrlSeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UrlSeed {
    return { url: isSet(object.url) ? globalThis.String(object.url) : undefined };
  },

  toJSON(message: UrlSeed): unknown {
    const obj: any = {};
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<UrlSeed>): UrlSeed {
    return UrlSeed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UrlSeed>): UrlSeed {
    const message = createBaseUrlSeed();
    message.url = object.url ?? undefined;
    return message;
  },
};

function createBaseGenerateKeywordIdeaResponse(): GenerateKeywordIdeaResponse {
  return { results: [], aggregateMetricResults: undefined, nextPageToken: "", totalSize: Long.ZERO };
}

export const GenerateKeywordIdeaResponse: MessageFns<GenerateKeywordIdeaResponse> = {
  encode(message: GenerateKeywordIdeaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      GenerateKeywordIdeaResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.aggregateMetricResults !== undefined) {
      KeywordPlanAggregateMetricResults.encode(message.aggregateMetricResults, writer.uint32(34).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (!message.totalSize.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.totalSize.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateKeywordIdeaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateKeywordIdeaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(GenerateKeywordIdeaResult.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.aggregateMetricResults = KeywordPlanAggregateMetricResults.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateKeywordIdeaResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => GenerateKeywordIdeaResult.fromJSON(e))
        : [],
      aggregateMetricResults: isSet(object.aggregateMetricResults)
        ? KeywordPlanAggregateMetricResults.fromJSON(object.aggregateMetricResults)
        : undefined,
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? Long.fromValue(object.totalSize) : Long.ZERO,
    };
  },

  toJSON(message: GenerateKeywordIdeaResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => GenerateKeywordIdeaResult.toJSON(e));
    }
    if (message.aggregateMetricResults !== undefined) {
      obj.aggregateMetricResults = KeywordPlanAggregateMetricResults.toJSON(message.aggregateMetricResults);
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (!message.totalSize.equals(Long.ZERO)) {
      obj.totalSize = (message.totalSize || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateKeywordIdeaResponse>): GenerateKeywordIdeaResponse {
    return GenerateKeywordIdeaResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateKeywordIdeaResponse>): GenerateKeywordIdeaResponse {
    const message = createBaseGenerateKeywordIdeaResponse();
    message.results = object.results?.map((e) => GenerateKeywordIdeaResult.fromPartial(e)) || [];
    message.aggregateMetricResults =
      (object.aggregateMetricResults !== undefined && object.aggregateMetricResults !== null)
        ? KeywordPlanAggregateMetricResults.fromPartial(object.aggregateMetricResults)
        : undefined;
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = (object.totalSize !== undefined && object.totalSize !== null)
      ? Long.fromValue(object.totalSize)
      : Long.ZERO;
    return message;
  },
};

function createBaseGenerateKeywordIdeaResult(): GenerateKeywordIdeaResult {
  return { text: undefined, keywordIdeaMetrics: undefined, keywordAnnotations: undefined, closeVariants: [] };
}

export const GenerateKeywordIdeaResult: MessageFns<GenerateKeywordIdeaResult> = {
  encode(message: GenerateKeywordIdeaResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      writer.uint32(42).string(message.text);
    }
    if (message.keywordIdeaMetrics !== undefined) {
      KeywordPlanHistoricalMetrics.encode(message.keywordIdeaMetrics, writer.uint32(26).fork()).join();
    }
    if (message.keywordAnnotations !== undefined) {
      KeywordAnnotations.encode(message.keywordAnnotations, writer.uint32(50).fork()).join();
    }
    for (const v of message.closeVariants) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateKeywordIdeaResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateKeywordIdeaResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.text = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keywordIdeaMetrics = KeywordPlanHistoricalMetrics.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.keywordAnnotations = KeywordAnnotations.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.closeVariants.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateKeywordIdeaResult {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      keywordIdeaMetrics: isSet(object.keywordIdeaMetrics)
        ? KeywordPlanHistoricalMetrics.fromJSON(object.keywordIdeaMetrics)
        : undefined,
      keywordAnnotations: isSet(object.keywordAnnotations)
        ? KeywordAnnotations.fromJSON(object.keywordAnnotations)
        : undefined,
      closeVariants: globalThis.Array.isArray(object?.closeVariants)
        ? object.closeVariants.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GenerateKeywordIdeaResult): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.keywordIdeaMetrics !== undefined) {
      obj.keywordIdeaMetrics = KeywordPlanHistoricalMetrics.toJSON(message.keywordIdeaMetrics);
    }
    if (message.keywordAnnotations !== undefined) {
      obj.keywordAnnotations = KeywordAnnotations.toJSON(message.keywordAnnotations);
    }
    if (message.closeVariants?.length) {
      obj.closeVariants = message.closeVariants;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateKeywordIdeaResult>): GenerateKeywordIdeaResult {
    return GenerateKeywordIdeaResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateKeywordIdeaResult>): GenerateKeywordIdeaResult {
    const message = createBaseGenerateKeywordIdeaResult();
    message.text = object.text ?? undefined;
    message.keywordIdeaMetrics = (object.keywordIdeaMetrics !== undefined && object.keywordIdeaMetrics !== null)
      ? KeywordPlanHistoricalMetrics.fromPartial(object.keywordIdeaMetrics)
      : undefined;
    message.keywordAnnotations = (object.keywordAnnotations !== undefined && object.keywordAnnotations !== null)
      ? KeywordAnnotations.fromPartial(object.keywordAnnotations)
      : undefined;
    message.closeVariants = object.closeVariants?.map((e) => e) || [];
    return message;
  },
};

function createBaseGenerateKeywordHistoricalMetricsRequest(): GenerateKeywordHistoricalMetricsRequest {
  return {
    customerId: "",
    keywords: [],
    language: undefined,
    includeAdultKeywords: false,
    geoTargetConstants: [],
    keywordPlanNetwork: 0,
    aggregateMetrics: undefined,
    historicalMetricsOptions: undefined,
  };
}

export const GenerateKeywordHistoricalMetricsRequest: MessageFns<GenerateKeywordHistoricalMetricsRequest> = {
  encode(message: GenerateKeywordHistoricalMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    for (const v of message.keywords) {
      writer.uint32(18).string(v!);
    }
    if (message.language !== undefined) {
      writer.uint32(34).string(message.language);
    }
    if (message.includeAdultKeywords !== false) {
      writer.uint32(40).bool(message.includeAdultKeywords);
    }
    for (const v of message.geoTargetConstants) {
      writer.uint32(50).string(v!);
    }
    if (message.keywordPlanNetwork !== 0) {
      writer.uint32(56).int32(message.keywordPlanNetwork);
    }
    if (message.aggregateMetrics !== undefined) {
      KeywordPlanAggregateMetrics.encode(message.aggregateMetrics, writer.uint32(66).fork()).join();
    }
    if (message.historicalMetricsOptions !== undefined) {
      HistoricalMetricsOptions.encode(message.historicalMetricsOptions, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateKeywordHistoricalMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateKeywordHistoricalMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keywords.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.language = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.includeAdultKeywords = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.geoTargetConstants.push(reader.string());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.keywordPlanNetwork = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.aggregateMetrics = KeywordPlanAggregateMetrics.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.historicalMetricsOptions = HistoricalMetricsOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateKeywordHistoricalMetricsRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      keywords: globalThis.Array.isArray(object?.keywords) ? object.keywords.map((e: any) => globalThis.String(e)) : [],
      language: isSet(object.language) ? globalThis.String(object.language) : undefined,
      includeAdultKeywords: isSet(object.includeAdultKeywords)
        ? globalThis.Boolean(object.includeAdultKeywords)
        : false,
      geoTargetConstants: globalThis.Array.isArray(object?.geoTargetConstants)
        ? object.geoTargetConstants.map((e: any) => globalThis.String(e))
        : [],
      keywordPlanNetwork: isSet(object.keywordPlanNetwork)
        ? keywordPlanNetworkEnum_KeywordPlanNetworkFromJSON(object.keywordPlanNetwork)
        : 0,
      aggregateMetrics: isSet(object.aggregateMetrics)
        ? KeywordPlanAggregateMetrics.fromJSON(object.aggregateMetrics)
        : undefined,
      historicalMetricsOptions: isSet(object.historicalMetricsOptions)
        ? HistoricalMetricsOptions.fromJSON(object.historicalMetricsOptions)
        : undefined,
    };
  },

  toJSON(message: GenerateKeywordHistoricalMetricsRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.keywords?.length) {
      obj.keywords = message.keywords;
    }
    if (message.language !== undefined) {
      obj.language = message.language;
    }
    if (message.includeAdultKeywords !== false) {
      obj.includeAdultKeywords = message.includeAdultKeywords;
    }
    if (message.geoTargetConstants?.length) {
      obj.geoTargetConstants = message.geoTargetConstants;
    }
    if (message.keywordPlanNetwork !== 0) {
      obj.keywordPlanNetwork = keywordPlanNetworkEnum_KeywordPlanNetworkToJSON(message.keywordPlanNetwork);
    }
    if (message.aggregateMetrics !== undefined) {
      obj.aggregateMetrics = KeywordPlanAggregateMetrics.toJSON(message.aggregateMetrics);
    }
    if (message.historicalMetricsOptions !== undefined) {
      obj.historicalMetricsOptions = HistoricalMetricsOptions.toJSON(message.historicalMetricsOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateKeywordHistoricalMetricsRequest>): GenerateKeywordHistoricalMetricsRequest {
    return GenerateKeywordHistoricalMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateKeywordHistoricalMetricsRequest>): GenerateKeywordHistoricalMetricsRequest {
    const message = createBaseGenerateKeywordHistoricalMetricsRequest();
    message.customerId = object.customerId ?? "";
    message.keywords = object.keywords?.map((e) => e) || [];
    message.language = object.language ?? undefined;
    message.includeAdultKeywords = object.includeAdultKeywords ?? false;
    message.geoTargetConstants = object.geoTargetConstants?.map((e) => e) || [];
    message.keywordPlanNetwork = object.keywordPlanNetwork ?? 0;
    message.aggregateMetrics = (object.aggregateMetrics !== undefined && object.aggregateMetrics !== null)
      ? KeywordPlanAggregateMetrics.fromPartial(object.aggregateMetrics)
      : undefined;
    message.historicalMetricsOptions =
      (object.historicalMetricsOptions !== undefined && object.historicalMetricsOptions !== null)
        ? HistoricalMetricsOptions.fromPartial(object.historicalMetricsOptions)
        : undefined;
    return message;
  },
};

function createBaseGenerateKeywordHistoricalMetricsResponse(): GenerateKeywordHistoricalMetricsResponse {
  return { results: [], aggregateMetricResults: undefined };
}

export const GenerateKeywordHistoricalMetricsResponse: MessageFns<GenerateKeywordHistoricalMetricsResponse> = {
  encode(message: GenerateKeywordHistoricalMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      GenerateKeywordHistoricalMetricsResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.aggregateMetricResults !== undefined) {
      KeywordPlanAggregateMetricResults.encode(message.aggregateMetricResults, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateKeywordHistoricalMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateKeywordHistoricalMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(GenerateKeywordHistoricalMetricsResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.aggregateMetricResults = KeywordPlanAggregateMetricResults.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateKeywordHistoricalMetricsResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => GenerateKeywordHistoricalMetricsResult.fromJSON(e))
        : [],
      aggregateMetricResults: isSet(object.aggregateMetricResults)
        ? KeywordPlanAggregateMetricResults.fromJSON(object.aggregateMetricResults)
        : undefined,
    };
  },

  toJSON(message: GenerateKeywordHistoricalMetricsResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => GenerateKeywordHistoricalMetricsResult.toJSON(e));
    }
    if (message.aggregateMetricResults !== undefined) {
      obj.aggregateMetricResults = KeywordPlanAggregateMetricResults.toJSON(message.aggregateMetricResults);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateKeywordHistoricalMetricsResponse>): GenerateKeywordHistoricalMetricsResponse {
    return GenerateKeywordHistoricalMetricsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateKeywordHistoricalMetricsResponse>): GenerateKeywordHistoricalMetricsResponse {
    const message = createBaseGenerateKeywordHistoricalMetricsResponse();
    message.results = object.results?.map((e) => GenerateKeywordHistoricalMetricsResult.fromPartial(e)) || [];
    message.aggregateMetricResults =
      (object.aggregateMetricResults !== undefined && object.aggregateMetricResults !== null)
        ? KeywordPlanAggregateMetricResults.fromPartial(object.aggregateMetricResults)
        : undefined;
    return message;
  },
};

function createBaseGenerateKeywordHistoricalMetricsResult(): GenerateKeywordHistoricalMetricsResult {
  return { text: undefined, closeVariants: [], keywordMetrics: undefined };
}

export const GenerateKeywordHistoricalMetricsResult: MessageFns<GenerateKeywordHistoricalMetricsResult> = {
  encode(message: GenerateKeywordHistoricalMetricsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      writer.uint32(10).string(message.text);
    }
    for (const v of message.closeVariants) {
      writer.uint32(26).string(v!);
    }
    if (message.keywordMetrics !== undefined) {
      KeywordPlanHistoricalMetrics.encode(message.keywordMetrics, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateKeywordHistoricalMetricsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateKeywordHistoricalMetricsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.closeVariants.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keywordMetrics = KeywordPlanHistoricalMetrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateKeywordHistoricalMetricsResult {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      closeVariants: globalThis.Array.isArray(object?.closeVariants)
        ? object.closeVariants.map((e: any) => globalThis.String(e))
        : [],
      keywordMetrics: isSet(object.keywordMetrics)
        ? KeywordPlanHistoricalMetrics.fromJSON(object.keywordMetrics)
        : undefined,
    };
  },

  toJSON(message: GenerateKeywordHistoricalMetricsResult): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.closeVariants?.length) {
      obj.closeVariants = message.closeVariants;
    }
    if (message.keywordMetrics !== undefined) {
      obj.keywordMetrics = KeywordPlanHistoricalMetrics.toJSON(message.keywordMetrics);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateKeywordHistoricalMetricsResult>): GenerateKeywordHistoricalMetricsResult {
    return GenerateKeywordHistoricalMetricsResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateKeywordHistoricalMetricsResult>): GenerateKeywordHistoricalMetricsResult {
    const message = createBaseGenerateKeywordHistoricalMetricsResult();
    message.text = object.text ?? undefined;
    message.closeVariants = object.closeVariants?.map((e) => e) || [];
    message.keywordMetrics = (object.keywordMetrics !== undefined && object.keywordMetrics !== null)
      ? KeywordPlanHistoricalMetrics.fromPartial(object.keywordMetrics)
      : undefined;
    return message;
  },
};

function createBaseGenerateAdGroupThemesRequest(): GenerateAdGroupThemesRequest {
  return { customerId: "", keywords: [], adGroups: [] };
}

export const GenerateAdGroupThemesRequest: MessageFns<GenerateAdGroupThemesRequest> = {
  encode(message: GenerateAdGroupThemesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    for (const v of message.keywords) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.adGroups) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateAdGroupThemesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateAdGroupThemesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keywords.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.adGroups.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateAdGroupThemesRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      keywords: globalThis.Array.isArray(object?.keywords) ? object.keywords.map((e: any) => globalThis.String(e)) : [],
      adGroups: globalThis.Array.isArray(object?.adGroups) ? object.adGroups.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GenerateAdGroupThemesRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.keywords?.length) {
      obj.keywords = message.keywords;
    }
    if (message.adGroups?.length) {
      obj.adGroups = message.adGroups;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateAdGroupThemesRequest>): GenerateAdGroupThemesRequest {
    return GenerateAdGroupThemesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateAdGroupThemesRequest>): GenerateAdGroupThemesRequest {
    const message = createBaseGenerateAdGroupThemesRequest();
    message.customerId = object.customerId ?? "";
    message.keywords = object.keywords?.map((e) => e) || [];
    message.adGroups = object.adGroups?.map((e) => e) || [];
    return message;
  },
};

function createBaseGenerateAdGroupThemesResponse(): GenerateAdGroupThemesResponse {
  return { adGroupKeywordSuggestions: [], unusableAdGroups: [] };
}

export const GenerateAdGroupThemesResponse: MessageFns<GenerateAdGroupThemesResponse> = {
  encode(message: GenerateAdGroupThemesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.adGroupKeywordSuggestions) {
      AdGroupKeywordSuggestion.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.unusableAdGroups) {
      UnusableAdGroup.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateAdGroupThemesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateAdGroupThemesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adGroupKeywordSuggestions.push(AdGroupKeywordSuggestion.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.unusableAdGroups.push(UnusableAdGroup.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateAdGroupThemesResponse {
    return {
      adGroupKeywordSuggestions: globalThis.Array.isArray(object?.adGroupKeywordSuggestions)
        ? object.adGroupKeywordSuggestions.map((e: any) => AdGroupKeywordSuggestion.fromJSON(e))
        : [],
      unusableAdGroups: globalThis.Array.isArray(object?.unusableAdGroups)
        ? object.unusableAdGroups.map((e: any) => UnusableAdGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateAdGroupThemesResponse): unknown {
    const obj: any = {};
    if (message.adGroupKeywordSuggestions?.length) {
      obj.adGroupKeywordSuggestions = message.adGroupKeywordSuggestions.map((e) => AdGroupKeywordSuggestion.toJSON(e));
    }
    if (message.unusableAdGroups?.length) {
      obj.unusableAdGroups = message.unusableAdGroups.map((e) => UnusableAdGroup.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateAdGroupThemesResponse>): GenerateAdGroupThemesResponse {
    return GenerateAdGroupThemesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateAdGroupThemesResponse>): GenerateAdGroupThemesResponse {
    const message = createBaseGenerateAdGroupThemesResponse();
    message.adGroupKeywordSuggestions =
      object.adGroupKeywordSuggestions?.map((e) => AdGroupKeywordSuggestion.fromPartial(e)) || [];
    message.unusableAdGroups = object.unusableAdGroups?.map((e) => UnusableAdGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAdGroupKeywordSuggestion(): AdGroupKeywordSuggestion {
  return {
    keywordText: "",
    suggestedKeywordText: "",
    suggestedMatchType: 0,
    suggestedAdGroup: "",
    suggestedCampaign: "",
  };
}

export const AdGroupKeywordSuggestion: MessageFns<AdGroupKeywordSuggestion> = {
  encode(message: AdGroupKeywordSuggestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keywordText !== "") {
      writer.uint32(10).string(message.keywordText);
    }
    if (message.suggestedKeywordText !== "") {
      writer.uint32(18).string(message.suggestedKeywordText);
    }
    if (message.suggestedMatchType !== 0) {
      writer.uint32(24).int32(message.suggestedMatchType);
    }
    if (message.suggestedAdGroup !== "") {
      writer.uint32(34).string(message.suggestedAdGroup);
    }
    if (message.suggestedCampaign !== "") {
      writer.uint32(42).string(message.suggestedCampaign);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdGroupKeywordSuggestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdGroupKeywordSuggestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keywordText = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.suggestedKeywordText = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.suggestedMatchType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.suggestedAdGroup = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.suggestedCampaign = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdGroupKeywordSuggestion {
    return {
      keywordText: isSet(object.keywordText) ? globalThis.String(object.keywordText) : "",
      suggestedKeywordText: isSet(object.suggestedKeywordText) ? globalThis.String(object.suggestedKeywordText) : "",
      suggestedMatchType: isSet(object.suggestedMatchType)
        ? keywordMatchTypeEnum_KeywordMatchTypeFromJSON(object.suggestedMatchType)
        : 0,
      suggestedAdGroup: isSet(object.suggestedAdGroup) ? globalThis.String(object.suggestedAdGroup) : "",
      suggestedCampaign: isSet(object.suggestedCampaign) ? globalThis.String(object.suggestedCampaign) : "",
    };
  },

  toJSON(message: AdGroupKeywordSuggestion): unknown {
    const obj: any = {};
    if (message.keywordText !== "") {
      obj.keywordText = message.keywordText;
    }
    if (message.suggestedKeywordText !== "") {
      obj.suggestedKeywordText = message.suggestedKeywordText;
    }
    if (message.suggestedMatchType !== 0) {
      obj.suggestedMatchType = keywordMatchTypeEnum_KeywordMatchTypeToJSON(message.suggestedMatchType);
    }
    if (message.suggestedAdGroup !== "") {
      obj.suggestedAdGroup = message.suggestedAdGroup;
    }
    if (message.suggestedCampaign !== "") {
      obj.suggestedCampaign = message.suggestedCampaign;
    }
    return obj;
  },

  create(base?: DeepPartial<AdGroupKeywordSuggestion>): AdGroupKeywordSuggestion {
    return AdGroupKeywordSuggestion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdGroupKeywordSuggestion>): AdGroupKeywordSuggestion {
    const message = createBaseAdGroupKeywordSuggestion();
    message.keywordText = object.keywordText ?? "";
    message.suggestedKeywordText = object.suggestedKeywordText ?? "";
    message.suggestedMatchType = object.suggestedMatchType ?? 0;
    message.suggestedAdGroup = object.suggestedAdGroup ?? "";
    message.suggestedCampaign = object.suggestedCampaign ?? "";
    return message;
  },
};

function createBaseUnusableAdGroup(): UnusableAdGroup {
  return { adGroup: "", campaign: "" };
}

export const UnusableAdGroup: MessageFns<UnusableAdGroup> = {
  encode(message: UnusableAdGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.adGroup !== "") {
      writer.uint32(10).string(message.adGroup);
    }
    if (message.campaign !== "") {
      writer.uint32(18).string(message.campaign);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnusableAdGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnusableAdGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adGroup = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.campaign = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnusableAdGroup {
    return {
      adGroup: isSet(object.adGroup) ? globalThis.String(object.adGroup) : "",
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : "",
    };
  },

  toJSON(message: UnusableAdGroup): unknown {
    const obj: any = {};
    if (message.adGroup !== "") {
      obj.adGroup = message.adGroup;
    }
    if (message.campaign !== "") {
      obj.campaign = message.campaign;
    }
    return obj;
  },

  create(base?: DeepPartial<UnusableAdGroup>): UnusableAdGroup {
    return UnusableAdGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnusableAdGroup>): UnusableAdGroup {
    const message = createBaseUnusableAdGroup();
    message.adGroup = object.adGroup ?? "";
    message.campaign = object.campaign ?? "";
    return message;
  },
};

function createBaseGenerateKeywordForecastMetricsRequest(): GenerateKeywordForecastMetricsRequest {
  return { customerId: "", currencyCode: undefined, forecastPeriod: undefined, campaign: undefined };
}

export const GenerateKeywordForecastMetricsRequest: MessageFns<GenerateKeywordForecastMetricsRequest> = {
  encode(message: GenerateKeywordForecastMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerId !== "") {
      writer.uint32(10).string(message.customerId);
    }
    if (message.currencyCode !== undefined) {
      writer.uint32(18).string(message.currencyCode);
    }
    if (message.forecastPeriod !== undefined) {
      DateRange.encode(message.forecastPeriod, writer.uint32(26).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignToForecast.encode(message.campaign, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateKeywordForecastMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateKeywordForecastMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.forecastPeriod = DateRange.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.campaign = CampaignToForecast.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateKeywordForecastMetricsRequest {
    return {
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : undefined,
      forecastPeriod: isSet(object.forecastPeriod) ? DateRange.fromJSON(object.forecastPeriod) : undefined,
      campaign: isSet(object.campaign) ? CampaignToForecast.fromJSON(object.campaign) : undefined,
    };
  },

  toJSON(message: GenerateKeywordForecastMetricsRequest): unknown {
    const obj: any = {};
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.currencyCode !== undefined) {
      obj.currencyCode = message.currencyCode;
    }
    if (message.forecastPeriod !== undefined) {
      obj.forecastPeriod = DateRange.toJSON(message.forecastPeriod);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignToForecast.toJSON(message.campaign);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateKeywordForecastMetricsRequest>): GenerateKeywordForecastMetricsRequest {
    return GenerateKeywordForecastMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateKeywordForecastMetricsRequest>): GenerateKeywordForecastMetricsRequest {
    const message = createBaseGenerateKeywordForecastMetricsRequest();
    message.customerId = object.customerId ?? "";
    message.currencyCode = object.currencyCode ?? undefined;
    message.forecastPeriod = (object.forecastPeriod !== undefined && object.forecastPeriod !== null)
      ? DateRange.fromPartial(object.forecastPeriod)
      : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignToForecast.fromPartial(object.campaign)
      : undefined;
    return message;
  },
};

function createBaseCampaignToForecast(): CampaignToForecast {
  return {
    languageConstants: [],
    geoModifiers: [],
    keywordPlanNetwork: 0,
    negativeKeywords: [],
    biddingStrategy: undefined,
    conversionRate: undefined,
    adGroups: [],
  };
}

export const CampaignToForecast: MessageFns<CampaignToForecast> = {
  encode(message: CampaignToForecast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.languageConstants) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.geoModifiers) {
      CriterionBidModifier.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.keywordPlanNetwork !== 0) {
      writer.uint32(24).int32(message.keywordPlanNetwork);
    }
    for (const v of message.negativeKeywords) {
      KeywordInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.biddingStrategy !== undefined) {
      CampaignToForecast_CampaignBiddingStrategy.encode(message.biddingStrategy, writer.uint32(42).fork()).join();
    }
    if (message.conversionRate !== undefined) {
      writer.uint32(49).double(message.conversionRate);
    }
    for (const v of message.adGroups) {
      ForecastAdGroup.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CampaignToForecast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampaignToForecast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageConstants.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.geoModifiers.push(CriterionBidModifier.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.keywordPlanNetwork = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.negativeKeywords.push(KeywordInfo.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.biddingStrategy = CampaignToForecast_CampaignBiddingStrategy.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.conversionRate = reader.double();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.adGroups.push(ForecastAdGroup.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CampaignToForecast {
    return {
      languageConstants: globalThis.Array.isArray(object?.languageConstants)
        ? object.languageConstants.map((e: any) => globalThis.String(e))
        : [],
      geoModifiers: globalThis.Array.isArray(object?.geoModifiers)
        ? object.geoModifiers.map((e: any) => CriterionBidModifier.fromJSON(e))
        : [],
      keywordPlanNetwork: isSet(object.keywordPlanNetwork)
        ? keywordPlanNetworkEnum_KeywordPlanNetworkFromJSON(object.keywordPlanNetwork)
        : 0,
      negativeKeywords: globalThis.Array.isArray(object?.negativeKeywords)
        ? object.negativeKeywords.map((e: any) => KeywordInfo.fromJSON(e))
        : [],
      biddingStrategy: isSet(object.biddingStrategy)
        ? CampaignToForecast_CampaignBiddingStrategy.fromJSON(object.biddingStrategy)
        : undefined,
      conversionRate: isSet(object.conversionRate) ? globalThis.Number(object.conversionRate) : undefined,
      adGroups: globalThis.Array.isArray(object?.adGroups)
        ? object.adGroups.map((e: any) => ForecastAdGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CampaignToForecast): unknown {
    const obj: any = {};
    if (message.languageConstants?.length) {
      obj.languageConstants = message.languageConstants;
    }
    if (message.geoModifiers?.length) {
      obj.geoModifiers = message.geoModifiers.map((e) => CriterionBidModifier.toJSON(e));
    }
    if (message.keywordPlanNetwork !== 0) {
      obj.keywordPlanNetwork = keywordPlanNetworkEnum_KeywordPlanNetworkToJSON(message.keywordPlanNetwork);
    }
    if (message.negativeKeywords?.length) {
      obj.negativeKeywords = message.negativeKeywords.map((e) => KeywordInfo.toJSON(e));
    }
    if (message.biddingStrategy !== undefined) {
      obj.biddingStrategy = CampaignToForecast_CampaignBiddingStrategy.toJSON(message.biddingStrategy);
    }
    if (message.conversionRate !== undefined) {
      obj.conversionRate = message.conversionRate;
    }
    if (message.adGroups?.length) {
      obj.adGroups = message.adGroups.map((e) => ForecastAdGroup.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CampaignToForecast>): CampaignToForecast {
    return CampaignToForecast.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CampaignToForecast>): CampaignToForecast {
    const message = createBaseCampaignToForecast();
    message.languageConstants = object.languageConstants?.map((e) => e) || [];
    message.geoModifiers = object.geoModifiers?.map((e) => CriterionBidModifier.fromPartial(e)) || [];
    message.keywordPlanNetwork = object.keywordPlanNetwork ?? 0;
    message.negativeKeywords = object.negativeKeywords?.map((e) => KeywordInfo.fromPartial(e)) || [];
    message.biddingStrategy = (object.biddingStrategy !== undefined && object.biddingStrategy !== null)
      ? CampaignToForecast_CampaignBiddingStrategy.fromPartial(object.biddingStrategy)
      : undefined;
    message.conversionRate = object.conversionRate ?? undefined;
    message.adGroups = object.adGroups?.map((e) => ForecastAdGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCampaignToForecast_CampaignBiddingStrategy(): CampaignToForecast_CampaignBiddingStrategy {
  return {
    manualCpcBiddingStrategy: undefined,
    maximizeClicksBiddingStrategy: undefined,
    maximizeConversionsBiddingStrategy: undefined,
  };
}

export const CampaignToForecast_CampaignBiddingStrategy: MessageFns<CampaignToForecast_CampaignBiddingStrategy> = {
  encode(message: CampaignToForecast_CampaignBiddingStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.manualCpcBiddingStrategy !== undefined) {
      ManualCpcBiddingStrategy.encode(message.manualCpcBiddingStrategy, writer.uint32(10).fork()).join();
    }
    if (message.maximizeClicksBiddingStrategy !== undefined) {
      MaximizeClicksBiddingStrategy.encode(message.maximizeClicksBiddingStrategy, writer.uint32(18).fork()).join();
    }
    if (message.maximizeConversionsBiddingStrategy !== undefined) {
      MaximizeConversionsBiddingStrategy.encode(message.maximizeConversionsBiddingStrategy, writer.uint32(26).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CampaignToForecast_CampaignBiddingStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampaignToForecast_CampaignBiddingStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.manualCpcBiddingStrategy = ManualCpcBiddingStrategy.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maximizeClicksBiddingStrategy = MaximizeClicksBiddingStrategy.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maximizeConversionsBiddingStrategy = MaximizeConversionsBiddingStrategy.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CampaignToForecast_CampaignBiddingStrategy {
    return {
      manualCpcBiddingStrategy: isSet(object.manualCpcBiddingStrategy)
        ? ManualCpcBiddingStrategy.fromJSON(object.manualCpcBiddingStrategy)
        : undefined,
      maximizeClicksBiddingStrategy: isSet(object.maximizeClicksBiddingStrategy)
        ? MaximizeClicksBiddingStrategy.fromJSON(object.maximizeClicksBiddingStrategy)
        : undefined,
      maximizeConversionsBiddingStrategy: isSet(object.maximizeConversionsBiddingStrategy)
        ? MaximizeConversionsBiddingStrategy.fromJSON(object.maximizeConversionsBiddingStrategy)
        : undefined,
    };
  },

  toJSON(message: CampaignToForecast_CampaignBiddingStrategy): unknown {
    const obj: any = {};
    if (message.manualCpcBiddingStrategy !== undefined) {
      obj.manualCpcBiddingStrategy = ManualCpcBiddingStrategy.toJSON(message.manualCpcBiddingStrategy);
    }
    if (message.maximizeClicksBiddingStrategy !== undefined) {
      obj.maximizeClicksBiddingStrategy = MaximizeClicksBiddingStrategy.toJSON(message.maximizeClicksBiddingStrategy);
    }
    if (message.maximizeConversionsBiddingStrategy !== undefined) {
      obj.maximizeConversionsBiddingStrategy = MaximizeConversionsBiddingStrategy.toJSON(
        message.maximizeConversionsBiddingStrategy,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CampaignToForecast_CampaignBiddingStrategy>): CampaignToForecast_CampaignBiddingStrategy {
    return CampaignToForecast_CampaignBiddingStrategy.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CampaignToForecast_CampaignBiddingStrategy>,
  ): CampaignToForecast_CampaignBiddingStrategy {
    const message = createBaseCampaignToForecast_CampaignBiddingStrategy();
    message.manualCpcBiddingStrategy =
      (object.manualCpcBiddingStrategy !== undefined && object.manualCpcBiddingStrategy !== null)
        ? ManualCpcBiddingStrategy.fromPartial(object.manualCpcBiddingStrategy)
        : undefined;
    message.maximizeClicksBiddingStrategy =
      (object.maximizeClicksBiddingStrategy !== undefined && object.maximizeClicksBiddingStrategy !== null)
        ? MaximizeClicksBiddingStrategy.fromPartial(object.maximizeClicksBiddingStrategy)
        : undefined;
    message.maximizeConversionsBiddingStrategy =
      (object.maximizeConversionsBiddingStrategy !== undefined && object.maximizeConversionsBiddingStrategy !== null)
        ? MaximizeConversionsBiddingStrategy.fromPartial(object.maximizeConversionsBiddingStrategy)
        : undefined;
    return message;
  },
};

function createBaseForecastAdGroup(): ForecastAdGroup {
  return { maxCpcBidMicros: undefined, biddableKeywords: [], negativeKeywords: [] };
}

export const ForecastAdGroup: MessageFns<ForecastAdGroup> = {
  encode(message: ForecastAdGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxCpcBidMicros !== undefined) {
      writer.uint32(8).int64(message.maxCpcBidMicros.toString());
    }
    for (const v of message.biddableKeywords) {
      BiddableKeyword.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.negativeKeywords) {
      KeywordInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForecastAdGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForecastAdGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxCpcBidMicros = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.biddableKeywords.push(BiddableKeyword.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.negativeKeywords.push(KeywordInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForecastAdGroup {
    return {
      maxCpcBidMicros: isSet(object.maxCpcBidMicros) ? Long.fromValue(object.maxCpcBidMicros) : undefined,
      biddableKeywords: globalThis.Array.isArray(object?.biddableKeywords)
        ? object.biddableKeywords.map((e: any) => BiddableKeyword.fromJSON(e))
        : [],
      negativeKeywords: globalThis.Array.isArray(object?.negativeKeywords)
        ? object.negativeKeywords.map((e: any) => KeywordInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ForecastAdGroup): unknown {
    const obj: any = {};
    if (message.maxCpcBidMicros !== undefined) {
      obj.maxCpcBidMicros = (message.maxCpcBidMicros || Long.ZERO).toString();
    }
    if (message.biddableKeywords?.length) {
      obj.biddableKeywords = message.biddableKeywords.map((e) => BiddableKeyword.toJSON(e));
    }
    if (message.negativeKeywords?.length) {
      obj.negativeKeywords = message.negativeKeywords.map((e) => KeywordInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ForecastAdGroup>): ForecastAdGroup {
    return ForecastAdGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForecastAdGroup>): ForecastAdGroup {
    const message = createBaseForecastAdGroup();
    message.maxCpcBidMicros = (object.maxCpcBidMicros !== undefined && object.maxCpcBidMicros !== null)
      ? Long.fromValue(object.maxCpcBidMicros)
      : undefined;
    message.biddableKeywords = object.biddableKeywords?.map((e) => BiddableKeyword.fromPartial(e)) || [];
    message.negativeKeywords = object.negativeKeywords?.map((e) => KeywordInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBiddableKeyword(): BiddableKeyword {
  return { keyword: undefined, maxCpcBidMicros: undefined };
}

export const BiddableKeyword: MessageFns<BiddableKeyword> = {
  encode(message: BiddableKeyword, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyword !== undefined) {
      KeywordInfo.encode(message.keyword, writer.uint32(10).fork()).join();
    }
    if (message.maxCpcBidMicros !== undefined) {
      writer.uint32(16).int64(message.maxCpcBidMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BiddableKeyword {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBiddableKeyword();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyword = KeywordInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxCpcBidMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BiddableKeyword {
    return {
      keyword: isSet(object.keyword) ? KeywordInfo.fromJSON(object.keyword) : undefined,
      maxCpcBidMicros: isSet(object.maxCpcBidMicros) ? Long.fromValue(object.maxCpcBidMicros) : undefined,
    };
  },

  toJSON(message: BiddableKeyword): unknown {
    const obj: any = {};
    if (message.keyword !== undefined) {
      obj.keyword = KeywordInfo.toJSON(message.keyword);
    }
    if (message.maxCpcBidMicros !== undefined) {
      obj.maxCpcBidMicros = (message.maxCpcBidMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<BiddableKeyword>): BiddableKeyword {
    return BiddableKeyword.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BiddableKeyword>): BiddableKeyword {
    const message = createBaseBiddableKeyword();
    message.keyword = (object.keyword !== undefined && object.keyword !== null)
      ? KeywordInfo.fromPartial(object.keyword)
      : undefined;
    message.maxCpcBidMicros = (object.maxCpcBidMicros !== undefined && object.maxCpcBidMicros !== null)
      ? Long.fromValue(object.maxCpcBidMicros)
      : undefined;
    return message;
  },
};

function createBaseCriterionBidModifier(): CriterionBidModifier {
  return { geoTargetConstant: "", bidModifier: undefined };
}

export const CriterionBidModifier: MessageFns<CriterionBidModifier> = {
  encode(message: CriterionBidModifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.geoTargetConstant !== "") {
      writer.uint32(10).string(message.geoTargetConstant);
    }
    if (message.bidModifier !== undefined) {
      writer.uint32(17).double(message.bidModifier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CriterionBidModifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCriterionBidModifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.geoTargetConstant = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.bidModifier = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CriterionBidModifier {
    return {
      geoTargetConstant: isSet(object.geoTargetConstant) ? globalThis.String(object.geoTargetConstant) : "",
      bidModifier: isSet(object.bidModifier) ? globalThis.Number(object.bidModifier) : undefined,
    };
  },

  toJSON(message: CriterionBidModifier): unknown {
    const obj: any = {};
    if (message.geoTargetConstant !== "") {
      obj.geoTargetConstant = message.geoTargetConstant;
    }
    if (message.bidModifier !== undefined) {
      obj.bidModifier = message.bidModifier;
    }
    return obj;
  },

  create(base?: DeepPartial<CriterionBidModifier>): CriterionBidModifier {
    return CriterionBidModifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CriterionBidModifier>): CriterionBidModifier {
    const message = createBaseCriterionBidModifier();
    message.geoTargetConstant = object.geoTargetConstant ?? "";
    message.bidModifier = object.bidModifier ?? undefined;
    return message;
  },
};

function createBaseManualCpcBiddingStrategy(): ManualCpcBiddingStrategy {
  return { dailyBudgetMicros: undefined, maxCpcBidMicros: Long.ZERO };
}

export const ManualCpcBiddingStrategy: MessageFns<ManualCpcBiddingStrategy> = {
  encode(message: ManualCpcBiddingStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dailyBudgetMicros !== undefined) {
      writer.uint32(8).int64(message.dailyBudgetMicros.toString());
    }
    if (!message.maxCpcBidMicros.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.maxCpcBidMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManualCpcBiddingStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManualCpcBiddingStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dailyBudgetMicros = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxCpcBidMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ManualCpcBiddingStrategy {
    return {
      dailyBudgetMicros: isSet(object.dailyBudgetMicros) ? Long.fromValue(object.dailyBudgetMicros) : undefined,
      maxCpcBidMicros: isSet(object.maxCpcBidMicros) ? Long.fromValue(object.maxCpcBidMicros) : Long.ZERO,
    };
  },

  toJSON(message: ManualCpcBiddingStrategy): unknown {
    const obj: any = {};
    if (message.dailyBudgetMicros !== undefined) {
      obj.dailyBudgetMicros = (message.dailyBudgetMicros || Long.ZERO).toString();
    }
    if (!message.maxCpcBidMicros.equals(Long.ZERO)) {
      obj.maxCpcBidMicros = (message.maxCpcBidMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ManualCpcBiddingStrategy>): ManualCpcBiddingStrategy {
    return ManualCpcBiddingStrategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ManualCpcBiddingStrategy>): ManualCpcBiddingStrategy {
    const message = createBaseManualCpcBiddingStrategy();
    message.dailyBudgetMicros = (object.dailyBudgetMicros !== undefined && object.dailyBudgetMicros !== null)
      ? Long.fromValue(object.dailyBudgetMicros)
      : undefined;
    message.maxCpcBidMicros = (object.maxCpcBidMicros !== undefined && object.maxCpcBidMicros !== null)
      ? Long.fromValue(object.maxCpcBidMicros)
      : Long.ZERO;
    return message;
  },
};

function createBaseMaximizeClicksBiddingStrategy(): MaximizeClicksBiddingStrategy {
  return { dailyTargetSpendMicros: Long.ZERO, maxCpcBidCeilingMicros: undefined };
}

export const MaximizeClicksBiddingStrategy: MessageFns<MaximizeClicksBiddingStrategy> = {
  encode(message: MaximizeClicksBiddingStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.dailyTargetSpendMicros.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.dailyTargetSpendMicros.toString());
    }
    if (message.maxCpcBidCeilingMicros !== undefined) {
      writer.uint32(16).int64(message.maxCpcBidCeilingMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaximizeClicksBiddingStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaximizeClicksBiddingStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dailyTargetSpendMicros = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxCpcBidCeilingMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaximizeClicksBiddingStrategy {
    return {
      dailyTargetSpendMicros: isSet(object.dailyTargetSpendMicros)
        ? Long.fromValue(object.dailyTargetSpendMicros)
        : Long.ZERO,
      maxCpcBidCeilingMicros: isSet(object.maxCpcBidCeilingMicros)
        ? Long.fromValue(object.maxCpcBidCeilingMicros)
        : undefined,
    };
  },

  toJSON(message: MaximizeClicksBiddingStrategy): unknown {
    const obj: any = {};
    if (!message.dailyTargetSpendMicros.equals(Long.ZERO)) {
      obj.dailyTargetSpendMicros = (message.dailyTargetSpendMicros || Long.ZERO).toString();
    }
    if (message.maxCpcBidCeilingMicros !== undefined) {
      obj.maxCpcBidCeilingMicros = (message.maxCpcBidCeilingMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MaximizeClicksBiddingStrategy>): MaximizeClicksBiddingStrategy {
    return MaximizeClicksBiddingStrategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaximizeClicksBiddingStrategy>): MaximizeClicksBiddingStrategy {
    const message = createBaseMaximizeClicksBiddingStrategy();
    message.dailyTargetSpendMicros =
      (object.dailyTargetSpendMicros !== undefined && object.dailyTargetSpendMicros !== null)
        ? Long.fromValue(object.dailyTargetSpendMicros)
        : Long.ZERO;
    message.maxCpcBidCeilingMicros =
      (object.maxCpcBidCeilingMicros !== undefined && object.maxCpcBidCeilingMicros !== null)
        ? Long.fromValue(object.maxCpcBidCeilingMicros)
        : undefined;
    return message;
  },
};

function createBaseMaximizeConversionsBiddingStrategy(): MaximizeConversionsBiddingStrategy {
  return { dailyTargetSpendMicros: Long.ZERO };
}

export const MaximizeConversionsBiddingStrategy: MessageFns<MaximizeConversionsBiddingStrategy> = {
  encode(message: MaximizeConversionsBiddingStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.dailyTargetSpendMicros.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.dailyTargetSpendMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaximizeConversionsBiddingStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaximizeConversionsBiddingStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dailyTargetSpendMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaximizeConversionsBiddingStrategy {
    return {
      dailyTargetSpendMicros: isSet(object.dailyTargetSpendMicros)
        ? Long.fromValue(object.dailyTargetSpendMicros)
        : Long.ZERO,
    };
  },

  toJSON(message: MaximizeConversionsBiddingStrategy): unknown {
    const obj: any = {};
    if (!message.dailyTargetSpendMicros.equals(Long.ZERO)) {
      obj.dailyTargetSpendMicros = (message.dailyTargetSpendMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MaximizeConversionsBiddingStrategy>): MaximizeConversionsBiddingStrategy {
    return MaximizeConversionsBiddingStrategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaximizeConversionsBiddingStrategy>): MaximizeConversionsBiddingStrategy {
    const message = createBaseMaximizeConversionsBiddingStrategy();
    message.dailyTargetSpendMicros =
      (object.dailyTargetSpendMicros !== undefined && object.dailyTargetSpendMicros !== null)
        ? Long.fromValue(object.dailyTargetSpendMicros)
        : Long.ZERO;
    return message;
  },
};

function createBaseGenerateKeywordForecastMetricsResponse(): GenerateKeywordForecastMetricsResponse {
  return { campaignForecastMetrics: undefined };
}

export const GenerateKeywordForecastMetricsResponse: MessageFns<GenerateKeywordForecastMetricsResponse> = {
  encode(message: GenerateKeywordForecastMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.campaignForecastMetrics !== undefined) {
      KeywordForecastMetrics.encode(message.campaignForecastMetrics, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateKeywordForecastMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateKeywordForecastMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.campaignForecastMetrics = KeywordForecastMetrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateKeywordForecastMetricsResponse {
    return {
      campaignForecastMetrics: isSet(object.campaignForecastMetrics)
        ? KeywordForecastMetrics.fromJSON(object.campaignForecastMetrics)
        : undefined,
    };
  },

  toJSON(message: GenerateKeywordForecastMetricsResponse): unknown {
    const obj: any = {};
    if (message.campaignForecastMetrics !== undefined) {
      obj.campaignForecastMetrics = KeywordForecastMetrics.toJSON(message.campaignForecastMetrics);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateKeywordForecastMetricsResponse>): GenerateKeywordForecastMetricsResponse {
    return GenerateKeywordForecastMetricsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateKeywordForecastMetricsResponse>): GenerateKeywordForecastMetricsResponse {
    const message = createBaseGenerateKeywordForecastMetricsResponse();
    message.campaignForecastMetrics =
      (object.campaignForecastMetrics !== undefined && object.campaignForecastMetrics !== null)
        ? KeywordForecastMetrics.fromPartial(object.campaignForecastMetrics)
        : undefined;
    return message;
  },
};

function createBaseKeywordForecastMetrics(): KeywordForecastMetrics {
  return {
    impressions: undefined,
    clickThroughRate: undefined,
    averageCpcMicros: undefined,
    clicks: undefined,
    costMicros: undefined,
    conversions: undefined,
    conversionRate: undefined,
    averageCpaMicros: undefined,
  };
}

export const KeywordForecastMetrics: MessageFns<KeywordForecastMetrics> = {
  encode(message: KeywordForecastMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.impressions !== undefined) {
      writer.uint32(9).double(message.impressions);
    }
    if (message.clickThroughRate !== undefined) {
      writer.uint32(17).double(message.clickThroughRate);
    }
    if (message.averageCpcMicros !== undefined) {
      writer.uint32(24).int64(message.averageCpcMicros.toString());
    }
    if (message.clicks !== undefined) {
      writer.uint32(33).double(message.clicks);
    }
    if (message.costMicros !== undefined) {
      writer.uint32(40).int64(message.costMicros.toString());
    }
    if (message.conversions !== undefined) {
      writer.uint32(49).double(message.conversions);
    }
    if (message.conversionRate !== undefined) {
      writer.uint32(57).double(message.conversionRate);
    }
    if (message.averageCpaMicros !== undefined) {
      writer.uint32(64).int64(message.averageCpaMicros.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeywordForecastMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeywordForecastMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.impressions = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.clickThroughRate = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.averageCpcMicros = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.clicks = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.costMicros = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.conversions = reader.double();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.conversionRate = reader.double();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.averageCpaMicros = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeywordForecastMetrics {
    return {
      impressions: isSet(object.impressions) ? globalThis.Number(object.impressions) : undefined,
      clickThroughRate: isSet(object.clickThroughRate) ? globalThis.Number(object.clickThroughRate) : undefined,
      averageCpcMicros: isSet(object.averageCpcMicros) ? Long.fromValue(object.averageCpcMicros) : undefined,
      clicks: isSet(object.clicks) ? globalThis.Number(object.clicks) : undefined,
      costMicros: isSet(object.costMicros) ? Long.fromValue(object.costMicros) : undefined,
      conversions: isSet(object.conversions) ? globalThis.Number(object.conversions) : undefined,
      conversionRate: isSet(object.conversionRate) ? globalThis.Number(object.conversionRate) : undefined,
      averageCpaMicros: isSet(object.averageCpaMicros) ? Long.fromValue(object.averageCpaMicros) : undefined,
    };
  },

  toJSON(message: KeywordForecastMetrics): unknown {
    const obj: any = {};
    if (message.impressions !== undefined) {
      obj.impressions = message.impressions;
    }
    if (message.clickThroughRate !== undefined) {
      obj.clickThroughRate = message.clickThroughRate;
    }
    if (message.averageCpcMicros !== undefined) {
      obj.averageCpcMicros = (message.averageCpcMicros || Long.ZERO).toString();
    }
    if (message.clicks !== undefined) {
      obj.clicks = message.clicks;
    }
    if (message.costMicros !== undefined) {
      obj.costMicros = (message.costMicros || Long.ZERO).toString();
    }
    if (message.conversions !== undefined) {
      obj.conversions = message.conversions;
    }
    if (message.conversionRate !== undefined) {
      obj.conversionRate = message.conversionRate;
    }
    if (message.averageCpaMicros !== undefined) {
      obj.averageCpaMicros = (message.averageCpaMicros || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<KeywordForecastMetrics>): KeywordForecastMetrics {
    return KeywordForecastMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeywordForecastMetrics>): KeywordForecastMetrics {
    const message = createBaseKeywordForecastMetrics();
    message.impressions = object.impressions ?? undefined;
    message.clickThroughRate = object.clickThroughRate ?? undefined;
    message.averageCpcMicros = (object.averageCpcMicros !== undefined && object.averageCpcMicros !== null)
      ? Long.fromValue(object.averageCpcMicros)
      : undefined;
    message.clicks = object.clicks ?? undefined;
    message.costMicros = (object.costMicros !== undefined && object.costMicros !== null)
      ? Long.fromValue(object.costMicros)
      : undefined;
    message.conversions = object.conversions ?? undefined;
    message.conversionRate = object.conversionRate ?? undefined;
    message.averageCpaMicros = (object.averageCpaMicros !== undefined && object.averageCpaMicros !== null)
      ? Long.fromValue(object.averageCpaMicros)
      : undefined;
    return message;
  },
};

/** Service to generate keyword ideas. */
export type KeywordPlanIdeaServiceDefinition = typeof KeywordPlanIdeaServiceDefinition;
export const KeywordPlanIdeaServiceDefinition = {
  name: "KeywordPlanIdeaService",
  fullName: "google.ads.googleads.v17.services.KeywordPlanIdeaService",
  methods: {
    /**
     * Returns a list of keyword ideas.
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [CollectionSizeError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [KeywordPlanIdeaError]()
     *   [QuotaError]()
     *   [RequestError]()
     */
    generateKeywordIdeas: {
      name: "GenerateKeywordIdeas",
      requestType: GenerateKeywordIdeasRequest,
      requestStream: false,
      responseType: GenerateKeywordIdeaResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              56,
              58,
              1,
              42,
              34,
              51,
              47,
              118,
              49,
              55,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              61,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              75,
              101,
              121,
              119,
              111,
              114,
              100,
              73,
              100,
              101,
              97,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns a list of keyword historical metrics.
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [CollectionSizeError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [QuotaError]()
     *   [RequestError]()
     */
    generateKeywordHistoricalMetrics: {
      name: "GenerateKeywordHistoricalMetrics",
      requestType: GenerateKeywordHistoricalMetricsRequest,
      requestStream: false,
      responseType: GenerateKeywordHistoricalMetricsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              49,
              55,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              61,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              75,
              101,
              121,
              119,
              111,
              114,
              100,
              72,
              105,
              115,
              116,
              111,
              114,
              105,
              99,
              97,
              108,
              77,
              101,
              116,
              114,
              105,
              99,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns a list of suggested AdGroups and suggested modifications
     * (text, match type) for the given keywords.
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [CollectionSizeError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [QuotaError]()
     *   [RequestError]()
     */
    generateAdGroupThemes: {
      name: "GenerateAdGroupThemes",
      requestType: GenerateAdGroupThemesRequest,
      requestStream: false,
      responseType: GenerateAdGroupThemesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              57,
              58,
              1,
              42,
              34,
              52,
              47,
              118,
              49,
              55,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              61,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              65,
              100,
              71,
              114,
              111,
              117,
              112,
              84,
              104,
              101,
              109,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Returns metrics (such as impressions, clicks, total cost) of a keyword
     * forecast for the given campaign.
     *
     * List of thrown errors:
     *   [AuthenticationError]()
     *   [AuthorizationError]()
     *   [CollectionSizeError]()
     *   [HeaderError]()
     *   [InternalError]()
     *   [QuotaError]()
     *   [RequestError]()
     */
    generateKeywordForecastMetrics: {
      name: "GenerateKeywordForecastMetrics",
      requestType: GenerateKeywordForecastMetricsRequest,
      requestStream: false,
      responseType: GenerateKeywordForecastMetricsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              55,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              115,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              101,
              114,
              95,
              105,
              100,
              61,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              75,
              101,
              121,
              119,
              111,
              114,
              100,
              70,
              111,
              114,
              101,
              99,
              97,
              115,
              116,
              77,
              101,
              116,
              114,
              105,
              99,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface KeywordPlanIdeaServiceImplementation<CallContextExt = {}> {
  /**
   * Returns a list of keyword ideas.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [CollectionSizeError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [KeywordPlanIdeaError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  generateKeywordIdeas(
    request: GenerateKeywordIdeasRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateKeywordIdeaResponse>>;
  /**
   * Returns a list of keyword historical metrics.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [CollectionSizeError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  generateKeywordHistoricalMetrics(
    request: GenerateKeywordHistoricalMetricsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateKeywordHistoricalMetricsResponse>>;
  /**
   * Returns a list of suggested AdGroups and suggested modifications
   * (text, match type) for the given keywords.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [CollectionSizeError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  generateAdGroupThemes(
    request: GenerateAdGroupThemesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateAdGroupThemesResponse>>;
  /**
   * Returns metrics (such as impressions, clicks, total cost) of a keyword
   * forecast for the given campaign.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [CollectionSizeError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  generateKeywordForecastMetrics(
    request: GenerateKeywordForecastMetricsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateKeywordForecastMetricsResponse>>;
}

export interface KeywordPlanIdeaServiceClient<CallOptionsExt = {}> {
  /**
   * Returns a list of keyword ideas.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [CollectionSizeError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [KeywordPlanIdeaError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  generateKeywordIdeas(
    request: DeepPartial<GenerateKeywordIdeasRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateKeywordIdeaResponse>;
  /**
   * Returns a list of keyword historical metrics.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [CollectionSizeError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  generateKeywordHistoricalMetrics(
    request: DeepPartial<GenerateKeywordHistoricalMetricsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateKeywordHistoricalMetricsResponse>;
  /**
   * Returns a list of suggested AdGroups and suggested modifications
   * (text, match type) for the given keywords.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [CollectionSizeError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  generateAdGroupThemes(
    request: DeepPartial<GenerateAdGroupThemesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateAdGroupThemesResponse>;
  /**
   * Returns metrics (such as impressions, clicks, total cost) of a keyword
   * forecast for the given campaign.
   *
   * List of thrown errors:
   *   [AuthenticationError]()
   *   [AuthorizationError]()
   *   [CollectionSizeError]()
   *   [HeaderError]()
   *   [InternalError]()
   *   [QuotaError]()
   *   [RequestError]()
   */
  generateKeywordForecastMetrics(
    request: DeepPartial<GenerateKeywordForecastMetricsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateKeywordForecastMetricsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
