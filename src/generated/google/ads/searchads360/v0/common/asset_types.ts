// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/searchads360/v0/common/asset_types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  CallConversionReportingStateEnum_CallConversionReportingState,
  callConversionReportingStateEnum_CallConversionReportingStateFromJSON,
  callConversionReportingStateEnum_CallConversionReportingStateToJSON,
} from "../enums/call_conversion_reporting_state.js";
import {
  CallToActionTypeEnum_CallToActionType,
  callToActionTypeEnum_CallToActionTypeFromJSON,
  callToActionTypeEnum_CallToActionTypeToJSON,
} from "../enums/call_to_action_type.js";
import {
  LocationOwnershipTypeEnum_LocationOwnershipType,
  locationOwnershipTypeEnum_LocationOwnershipTypeFromJSON,
  locationOwnershipTypeEnum_LocationOwnershipTypeToJSON,
} from "../enums/location_ownership_type.js";
import {
  MimeTypeEnum_MimeType,
  mimeTypeEnum_MimeTypeFromJSON,
  mimeTypeEnum_MimeTypeToJSON,
} from "../enums/mime_type.js";
import {
  MobileAppVendorEnum_MobileAppVendor,
  mobileAppVendorEnum_MobileAppVendorFromJSON,
  mobileAppVendorEnum_MobileAppVendorToJSON,
} from "../enums/mobile_app_vendor.js";
import { AdScheduleInfo } from "./criteria.js";

export const protobufPackage = "google.ads.searchads360.v0.common";

/** A YouTube asset. */
export interface YoutubeVideoAsset {
  /**
   * YouTube video id. This is the 11 character string value used in the
   * YouTube video URL.
   */
  youtubeVideoId?:
    | string
    | undefined;
  /** YouTube video title. */
  youtubeVideoTitle: string;
}

/** An Image asset. */
export interface ImageAsset {
  /** File size of the image asset in bytes. */
  fileSize?:
    | Long
    | undefined;
  /** MIME type of the image asset. */
  mimeType: MimeTypeEnum_MimeType;
  /** Metadata for this image at its original size. */
  fullSize: ImageDimension | undefined;
}

/** Metadata for an image at a certain size, either original or resized. */
export interface ImageDimension {
  /** Height of the image. */
  heightPixels?:
    | Long
    | undefined;
  /** Width of the image. */
  widthPixels?:
    | Long
    | undefined;
  /** A URL that returns the image with this height and width. */
  url?: string | undefined;
}

/** A Text asset. */
export interface TextAsset {
  /** Text content of the text asset. */
  text?: string | undefined;
}

/** A unified callout asset. */
export interface UnifiedCalloutAsset {
  /**
   * The callout text.
   * The length of this string should be between 1 and 25, inclusive.
   */
  calloutText: string;
  /**
   * Start date of when this asset is effective and can begin serving, in
   * yyyy-MM-dd format.
   */
  startDate: string;
  /**
   * Last date of when this asset is effective and still serving, in yyyy-MM-dd
   * format.
   */
  endDate: string;
  /**
   * List of non-overlapping schedules specifying all time intervals for which
   * the asset may serve. There can be a maximum of 6 schedules per day, 42 in
   * total.
   */
  adScheduleTargets: AdScheduleInfo[];
  /**
   * Whether to show the asset in search user's time zone. Applies to Microsoft
   * Ads.
   */
  useSearcherTimeZone: boolean;
}

/** A unified sitelink asset. */
export interface UnifiedSitelinkAsset {
  /**
   * URL display text for the sitelink.
   * The length of this string should be between 1 and 25, inclusive.
   */
  linkText: string;
  /**
   * First line of the description for the sitelink.
   * If set, the length should be between 1 and 35, inclusive, and description2
   * must also be set.
   */
  description1: string;
  /**
   * Second line of the description for the sitelink.
   * If set, the length should be between 1 and 35, inclusive, and description1
   * must also be set.
   */
  description2: string;
  /**
   * Start date of when this asset is effective and can begin serving, in
   * yyyy-MM-dd format.
   */
  startDate: string;
  /**
   * Last date of when this asset is effective and still serving, in yyyy-MM-dd
   * format.
   */
  endDate: string;
  /**
   * List of non-overlapping schedules specifying all time intervals for which
   * the asset may serve. There can be a maximum of 6 schedules per day, 42 in
   * total.
   */
  adScheduleTargets: AdScheduleInfo[];
  /**
   * ID used for tracking clicks for the sitelink asset. This is a Yahoo! Japan
   * only field.
   */
  trackingId: Long;
  /**
   * Whether to show the sitelink asset in search user's time zone.
   * Applies to Microsoft Ads.
   */
  useSearcherTimeZone: boolean;
  /**
   * Whether the preference is for the sitelink asset to be displayed on mobile
   * devices. Applies to Microsoft Ads.
   */
  mobilePreferred: boolean;
}

/** A Unified Page Feed asset. */
export interface UnifiedPageFeedAsset {
  /** The webpage that advertisers want to target. */
  pageUrl: string;
  /** Labels used to group the page urls. */
  labels: string[];
}

/** An asset representing a mobile app. */
export interface MobileAppAsset {
  /**
   * Required. A string that uniquely identifies a mobile application. It should
   * just contain the platform native id, like "com.android.ebay" for Android or
   * "12345689" for iOS.
   */
  appId: string;
  /** Required. The application store that distributes this specific app. */
  appStore: MobileAppVendorEnum_MobileAppVendor;
}

/** A unified call asset. */
export interface UnifiedCallAsset {
  /** Two-letter country code of the phone number. Examples: 'US', 'us'. */
  countryCode: string;
  /** The advertiser's raw phone number. Examples: '1234567890', '(123)456-7890' */
  phoneNumber: string;
  /**
   * Output only. Indicates whether this CallAsset should use its own call
   * conversion setting, follow the account level setting, or disable call
   * conversion.
   */
  callConversionReportingState: CallConversionReportingStateEnum_CallConversionReportingState;
  /**
   * The conversion action to attribute a call conversion to. If not set, the
   * default conversion action is used. This field only has effect if
   * call_conversion_reporting_state is set to
   * USE_RESOURCE_LEVEL_CALL_CONVERSION_ACTION.
   */
  callConversionAction: string;
  /**
   * List of non-overlapping schedules specifying all time intervals for which
   * the asset may serve. There can be a maximum of 6 schedules per day, 42 in
   * total.
   */
  adScheduleTargets: AdScheduleInfo[];
  /**
   * Whether the call only shows the phone number without a link to the website.
   * Applies to Microsoft Ads.
   */
  callOnly: boolean;
  /**
   * Whether the call should be enabled on call tracking.
   * Applies to Microsoft Ads.
   */
  callTrackingEnabled: boolean;
  /**
   * Whether to show the call extension in search user's time zone.
   * Applies to Microsoft Ads.
   */
  useSearcherTimeZone: boolean;
  /**
   * Start date of when this asset is effective and can begin serving, in
   * yyyy-MM-dd format.
   */
  startDate: string;
  /**
   * Last date of when this asset is effective and still serving, in yyyy-MM-dd
   * format.
   */
  endDate: string;
}

/** A call to action asset. */
export interface CallToActionAsset {
  /** Call to action. */
  callToAction: CallToActionTypeEnum_CallToActionType;
}

/** A unified location asset. */
export interface UnifiedLocationAsset {
  /**
   * Place IDs uniquely identify a place in the Google Places database and on
   * Google Maps.
   * This field is unique for a given customer ID and asset type. See
   * https://developers.google.com/places/web-service/place-id to learn more
   * about Place ID.
   */
  placeId: string;
  /**
   * The list of business locations for the customer.
   * This will only be returned if the Location Asset is syncing from the
   * Business Profile account. It is possible to have multiple Business Profile
   * listings under the same account that point to the same Place ID.
   */
  businessProfileLocations: BusinessProfileLocation[];
  /**
   * The type of location ownership.
   * If the type is BUSINESS_OWNER, it will be served as a location extension.
   * If the type is AFFILIATE, it will be served as an affiliate location.
   */
  locationOwnershipType: LocationOwnershipTypeEnum_LocationOwnershipType;
}

/**
 * Business Profile location data synced from the linked Business Profile
 * account.
 */
export interface BusinessProfileLocation {
  /**
   * Advertiser specified label for the location on the Business Profile
   * account. This is synced from the Business Profile account.
   */
  labels: string[];
  /**
   * Business Profile store code of this location. This is synced from the
   * Business Profile account.
   */
  storeCode: string;
  /**
   * Listing ID of this Business Profile location. This is synced from the
   * linked Business Profile account.
   */
  listingId: Long;
}

function createBaseYoutubeVideoAsset(): YoutubeVideoAsset {
  return { youtubeVideoId: undefined, youtubeVideoTitle: "" };
}

export const YoutubeVideoAsset: MessageFns<YoutubeVideoAsset> = {
  encode(message: YoutubeVideoAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.youtubeVideoId !== undefined) {
      writer.uint32(18).string(message.youtubeVideoId);
    }
    if (message.youtubeVideoTitle !== "") {
      writer.uint32(26).string(message.youtubeVideoTitle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YoutubeVideoAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYoutubeVideoAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.youtubeVideoId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.youtubeVideoTitle = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YoutubeVideoAsset {
    return {
      youtubeVideoId: isSet(object.youtubeVideoId) ? globalThis.String(object.youtubeVideoId) : undefined,
      youtubeVideoTitle: isSet(object.youtubeVideoTitle) ? globalThis.String(object.youtubeVideoTitle) : "",
    };
  },

  toJSON(message: YoutubeVideoAsset): unknown {
    const obj: any = {};
    if (message.youtubeVideoId !== undefined) {
      obj.youtubeVideoId = message.youtubeVideoId;
    }
    if (message.youtubeVideoTitle !== "") {
      obj.youtubeVideoTitle = message.youtubeVideoTitle;
    }
    return obj;
  },

  create(base?: DeepPartial<YoutubeVideoAsset>): YoutubeVideoAsset {
    return YoutubeVideoAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<YoutubeVideoAsset>): YoutubeVideoAsset {
    const message = createBaseYoutubeVideoAsset();
    message.youtubeVideoId = object.youtubeVideoId ?? undefined;
    message.youtubeVideoTitle = object.youtubeVideoTitle ?? "";
    return message;
  },
};

function createBaseImageAsset(): ImageAsset {
  return { fileSize: undefined, mimeType: 0, fullSize: undefined };
}

export const ImageAsset: MessageFns<ImageAsset> = {
  encode(message: ImageAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileSize !== undefined) {
      writer.uint32(48).int64(message.fileSize.toString());
    }
    if (message.mimeType !== 0) {
      writer.uint32(24).int32(message.mimeType);
    }
    if (message.fullSize !== undefined) {
      ImageDimension.encode(message.fullSize, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 48) {
            break;
          }

          message.fileSize = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.mimeType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fullSize = ImageDimension.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageAsset {
    return {
      fileSize: isSet(object.fileSize) ? Long.fromValue(object.fileSize) : undefined,
      mimeType: isSet(object.mimeType) ? mimeTypeEnum_MimeTypeFromJSON(object.mimeType) : 0,
      fullSize: isSet(object.fullSize) ? ImageDimension.fromJSON(object.fullSize) : undefined,
    };
  },

  toJSON(message: ImageAsset): unknown {
    const obj: any = {};
    if (message.fileSize !== undefined) {
      obj.fileSize = (message.fileSize || Long.ZERO).toString();
    }
    if (message.mimeType !== 0) {
      obj.mimeType = mimeTypeEnum_MimeTypeToJSON(message.mimeType);
    }
    if (message.fullSize !== undefined) {
      obj.fullSize = ImageDimension.toJSON(message.fullSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ImageAsset>): ImageAsset {
    return ImageAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImageAsset>): ImageAsset {
    const message = createBaseImageAsset();
    message.fileSize = (object.fileSize !== undefined && object.fileSize !== null)
      ? Long.fromValue(object.fileSize)
      : undefined;
    message.mimeType = object.mimeType ?? 0;
    message.fullSize = (object.fullSize !== undefined && object.fullSize !== null)
      ? ImageDimension.fromPartial(object.fullSize)
      : undefined;
    return message;
  },
};

function createBaseImageDimension(): ImageDimension {
  return { heightPixels: undefined, widthPixels: undefined, url: undefined };
}

export const ImageDimension: MessageFns<ImageDimension> = {
  encode(message: ImageDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.heightPixels !== undefined) {
      writer.uint32(32).int64(message.heightPixels.toString());
    }
    if (message.widthPixels !== undefined) {
      writer.uint32(40).int64(message.widthPixels.toString());
    }
    if (message.url !== undefined) {
      writer.uint32(50).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 32) {
            break;
          }

          message.heightPixels = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.widthPixels = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageDimension {
    return {
      heightPixels: isSet(object.heightPixels) ? Long.fromValue(object.heightPixels) : undefined,
      widthPixels: isSet(object.widthPixels) ? Long.fromValue(object.widthPixels) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
    };
  },

  toJSON(message: ImageDimension): unknown {
    const obj: any = {};
    if (message.heightPixels !== undefined) {
      obj.heightPixels = (message.heightPixels || Long.ZERO).toString();
    }
    if (message.widthPixels !== undefined) {
      obj.widthPixels = (message.widthPixels || Long.ZERO).toString();
    }
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<ImageDimension>): ImageDimension {
    return ImageDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImageDimension>): ImageDimension {
    const message = createBaseImageDimension();
    message.heightPixels = (object.heightPixels !== undefined && object.heightPixels !== null)
      ? Long.fromValue(object.heightPixels)
      : undefined;
    message.widthPixels = (object.widthPixels !== undefined && object.widthPixels !== null)
      ? Long.fromValue(object.widthPixels)
      : undefined;
    message.url = object.url ?? undefined;
    return message;
  },
};

function createBaseTextAsset(): TextAsset {
  return { text: undefined };
}

export const TextAsset: MessageFns<TextAsset> = {
  encode(message: TextAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextAsset {
    return { text: isSet(object.text) ? globalThis.String(object.text) : undefined };
  },

  toJSON(message: TextAsset): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<TextAsset>): TextAsset {
    return TextAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextAsset>): TextAsset {
    const message = createBaseTextAsset();
    message.text = object.text ?? undefined;
    return message;
  },
};

function createBaseUnifiedCalloutAsset(): UnifiedCalloutAsset {
  return { calloutText: "", startDate: "", endDate: "", adScheduleTargets: [], useSearcherTimeZone: false };
}

export const UnifiedCalloutAsset: MessageFns<UnifiedCalloutAsset> = {
  encode(message: UnifiedCalloutAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.calloutText !== "") {
      writer.uint32(10).string(message.calloutText);
    }
    if (message.startDate !== "") {
      writer.uint32(18).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(26).string(message.endDate);
    }
    for (const v of message.adScheduleTargets) {
      AdScheduleInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.useSearcherTimeZone !== false) {
      writer.uint32(40).bool(message.useSearcherTimeZone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnifiedCalloutAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnifiedCalloutAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.calloutText = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endDate = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.adScheduleTargets.push(AdScheduleInfo.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.useSearcherTimeZone = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnifiedCalloutAsset {
    return {
      calloutText: isSet(object.calloutText) ? globalThis.String(object.calloutText) : "",
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : "",
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : "",
      adScheduleTargets: globalThis.Array.isArray(object?.adScheduleTargets)
        ? object.adScheduleTargets.map((e: any) => AdScheduleInfo.fromJSON(e))
        : [],
      useSearcherTimeZone: isSet(object.useSearcherTimeZone) ? globalThis.Boolean(object.useSearcherTimeZone) : false,
    };
  },

  toJSON(message: UnifiedCalloutAsset): unknown {
    const obj: any = {};
    if (message.calloutText !== "") {
      obj.calloutText = message.calloutText;
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    if (message.adScheduleTargets?.length) {
      obj.adScheduleTargets = message.adScheduleTargets.map((e) => AdScheduleInfo.toJSON(e));
    }
    if (message.useSearcherTimeZone !== false) {
      obj.useSearcherTimeZone = message.useSearcherTimeZone;
    }
    return obj;
  },

  create(base?: DeepPartial<UnifiedCalloutAsset>): UnifiedCalloutAsset {
    return UnifiedCalloutAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnifiedCalloutAsset>): UnifiedCalloutAsset {
    const message = createBaseUnifiedCalloutAsset();
    message.calloutText = object.calloutText ?? "";
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    message.adScheduleTargets = object.adScheduleTargets?.map((e) => AdScheduleInfo.fromPartial(e)) || [];
    message.useSearcherTimeZone = object.useSearcherTimeZone ?? false;
    return message;
  },
};

function createBaseUnifiedSitelinkAsset(): UnifiedSitelinkAsset {
  return {
    linkText: "",
    description1: "",
    description2: "",
    startDate: "",
    endDate: "",
    adScheduleTargets: [],
    trackingId: Long.ZERO,
    useSearcherTimeZone: false,
    mobilePreferred: false,
  };
}

export const UnifiedSitelinkAsset: MessageFns<UnifiedSitelinkAsset> = {
  encode(message: UnifiedSitelinkAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.linkText !== "") {
      writer.uint32(10).string(message.linkText);
    }
    if (message.description1 !== "") {
      writer.uint32(18).string(message.description1);
    }
    if (message.description2 !== "") {
      writer.uint32(26).string(message.description2);
    }
    if (message.startDate !== "") {
      writer.uint32(34).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(42).string(message.endDate);
    }
    for (const v of message.adScheduleTargets) {
      AdScheduleInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    if (!message.trackingId.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.trackingId.toString());
    }
    if (message.useSearcherTimeZone !== false) {
      writer.uint32(64).bool(message.useSearcherTimeZone);
    }
    if (message.mobilePreferred !== false) {
      writer.uint32(72).bool(message.mobilePreferred);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnifiedSitelinkAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnifiedSitelinkAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.linkText = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description1 = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description2 = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endDate = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.adScheduleTargets.push(AdScheduleInfo.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.trackingId = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.useSearcherTimeZone = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.mobilePreferred = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnifiedSitelinkAsset {
    return {
      linkText: isSet(object.linkText) ? globalThis.String(object.linkText) : "",
      description1: isSet(object.description1) ? globalThis.String(object.description1) : "",
      description2: isSet(object.description2) ? globalThis.String(object.description2) : "",
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : "",
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : "",
      adScheduleTargets: globalThis.Array.isArray(object?.adScheduleTargets)
        ? object.adScheduleTargets.map((e: any) => AdScheduleInfo.fromJSON(e))
        : [],
      trackingId: isSet(object.trackingId) ? Long.fromValue(object.trackingId) : Long.ZERO,
      useSearcherTimeZone: isSet(object.useSearcherTimeZone) ? globalThis.Boolean(object.useSearcherTimeZone) : false,
      mobilePreferred: isSet(object.mobilePreferred) ? globalThis.Boolean(object.mobilePreferred) : false,
    };
  },

  toJSON(message: UnifiedSitelinkAsset): unknown {
    const obj: any = {};
    if (message.linkText !== "") {
      obj.linkText = message.linkText;
    }
    if (message.description1 !== "") {
      obj.description1 = message.description1;
    }
    if (message.description2 !== "") {
      obj.description2 = message.description2;
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    if (message.adScheduleTargets?.length) {
      obj.adScheduleTargets = message.adScheduleTargets.map((e) => AdScheduleInfo.toJSON(e));
    }
    if (!message.trackingId.equals(Long.ZERO)) {
      obj.trackingId = (message.trackingId || Long.ZERO).toString();
    }
    if (message.useSearcherTimeZone !== false) {
      obj.useSearcherTimeZone = message.useSearcherTimeZone;
    }
    if (message.mobilePreferred !== false) {
      obj.mobilePreferred = message.mobilePreferred;
    }
    return obj;
  },

  create(base?: DeepPartial<UnifiedSitelinkAsset>): UnifiedSitelinkAsset {
    return UnifiedSitelinkAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnifiedSitelinkAsset>): UnifiedSitelinkAsset {
    const message = createBaseUnifiedSitelinkAsset();
    message.linkText = object.linkText ?? "";
    message.description1 = object.description1 ?? "";
    message.description2 = object.description2 ?? "";
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    message.adScheduleTargets = object.adScheduleTargets?.map((e) => AdScheduleInfo.fromPartial(e)) || [];
    message.trackingId = (object.trackingId !== undefined && object.trackingId !== null)
      ? Long.fromValue(object.trackingId)
      : Long.ZERO;
    message.useSearcherTimeZone = object.useSearcherTimeZone ?? false;
    message.mobilePreferred = object.mobilePreferred ?? false;
    return message;
  },
};

function createBaseUnifiedPageFeedAsset(): UnifiedPageFeedAsset {
  return { pageUrl: "", labels: [] };
}

export const UnifiedPageFeedAsset: MessageFns<UnifiedPageFeedAsset> = {
  encode(message: UnifiedPageFeedAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageUrl !== "") {
      writer.uint32(10).string(message.pageUrl);
    }
    for (const v of message.labels) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnifiedPageFeedAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnifiedPageFeedAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pageUrl = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.labels.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnifiedPageFeedAsset {
    return {
      pageUrl: isSet(object.pageUrl) ? globalThis.String(object.pageUrl) : "",
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: UnifiedPageFeedAsset): unknown {
    const obj: any = {};
    if (message.pageUrl !== "") {
      obj.pageUrl = message.pageUrl;
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    return obj;
  },

  create(base?: DeepPartial<UnifiedPageFeedAsset>): UnifiedPageFeedAsset {
    return UnifiedPageFeedAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnifiedPageFeedAsset>): UnifiedPageFeedAsset {
    const message = createBaseUnifiedPageFeedAsset();
    message.pageUrl = object.pageUrl ?? "";
    message.labels = object.labels?.map((e) => e) || [];
    return message;
  },
};

function createBaseMobileAppAsset(): MobileAppAsset {
  return { appId: "", appStore: 0 };
}

export const MobileAppAsset: MessageFns<MobileAppAsset> = {
  encode(message: MobileAppAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.appStore !== 0) {
      writer.uint32(16).int32(message.appStore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MobileAppAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMobileAppAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.appStore = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MobileAppAsset {
    return {
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      appStore: isSet(object.appStore) ? mobileAppVendorEnum_MobileAppVendorFromJSON(object.appStore) : 0,
    };
  },

  toJSON(message: MobileAppAsset): unknown {
    const obj: any = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.appStore !== 0) {
      obj.appStore = mobileAppVendorEnum_MobileAppVendorToJSON(message.appStore);
    }
    return obj;
  },

  create(base?: DeepPartial<MobileAppAsset>): MobileAppAsset {
    return MobileAppAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MobileAppAsset>): MobileAppAsset {
    const message = createBaseMobileAppAsset();
    message.appId = object.appId ?? "";
    message.appStore = object.appStore ?? 0;
    return message;
  },
};

function createBaseUnifiedCallAsset(): UnifiedCallAsset {
  return {
    countryCode: "",
    phoneNumber: "",
    callConversionReportingState: 0,
    callConversionAction: "",
    adScheduleTargets: [],
    callOnly: false,
    callTrackingEnabled: false,
    useSearcherTimeZone: false,
    startDate: "",
    endDate: "",
  };
}

export const UnifiedCallAsset: MessageFns<UnifiedCallAsset> = {
  encode(message: UnifiedCallAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryCode !== "") {
      writer.uint32(10).string(message.countryCode);
    }
    if (message.phoneNumber !== "") {
      writer.uint32(18).string(message.phoneNumber);
    }
    if (message.callConversionReportingState !== 0) {
      writer.uint32(24).int32(message.callConversionReportingState);
    }
    if (message.callConversionAction !== "") {
      writer.uint32(34).string(message.callConversionAction);
    }
    for (const v of message.adScheduleTargets) {
      AdScheduleInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.callOnly !== false) {
      writer.uint32(56).bool(message.callOnly);
    }
    if (message.callTrackingEnabled !== false) {
      writer.uint32(64).bool(message.callTrackingEnabled);
    }
    if (message.useSearcherTimeZone !== false) {
      writer.uint32(72).bool(message.useSearcherTimeZone);
    }
    if (message.startDate !== "") {
      writer.uint32(82).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(90).string(message.endDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnifiedCallAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnifiedCallAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.callConversionReportingState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.callConversionAction = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.adScheduleTargets.push(AdScheduleInfo.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.callOnly = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.callTrackingEnabled = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.useSearcherTimeZone = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.endDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnifiedCallAsset {
    return {
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : "",
      callConversionReportingState: isSet(object.callConversionReportingState)
        ? callConversionReportingStateEnum_CallConversionReportingStateFromJSON(object.callConversionReportingState)
        : 0,
      callConversionAction: isSet(object.callConversionAction) ? globalThis.String(object.callConversionAction) : "",
      adScheduleTargets: globalThis.Array.isArray(object?.adScheduleTargets)
        ? object.adScheduleTargets.map((e: any) => AdScheduleInfo.fromJSON(e))
        : [],
      callOnly: isSet(object.callOnly) ? globalThis.Boolean(object.callOnly) : false,
      callTrackingEnabled: isSet(object.callTrackingEnabled) ? globalThis.Boolean(object.callTrackingEnabled) : false,
      useSearcherTimeZone: isSet(object.useSearcherTimeZone) ? globalThis.Boolean(object.useSearcherTimeZone) : false,
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : "",
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : "",
    };
  },

  toJSON(message: UnifiedCallAsset): unknown {
    const obj: any = {};
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.phoneNumber !== "") {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.callConversionReportingState !== 0) {
      obj.callConversionReportingState = callConversionReportingStateEnum_CallConversionReportingStateToJSON(
        message.callConversionReportingState,
      );
    }
    if (message.callConversionAction !== "") {
      obj.callConversionAction = message.callConversionAction;
    }
    if (message.adScheduleTargets?.length) {
      obj.adScheduleTargets = message.adScheduleTargets.map((e) => AdScheduleInfo.toJSON(e));
    }
    if (message.callOnly !== false) {
      obj.callOnly = message.callOnly;
    }
    if (message.callTrackingEnabled !== false) {
      obj.callTrackingEnabled = message.callTrackingEnabled;
    }
    if (message.useSearcherTimeZone !== false) {
      obj.useSearcherTimeZone = message.useSearcherTimeZone;
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    return obj;
  },

  create(base?: DeepPartial<UnifiedCallAsset>): UnifiedCallAsset {
    return UnifiedCallAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnifiedCallAsset>): UnifiedCallAsset {
    const message = createBaseUnifiedCallAsset();
    message.countryCode = object.countryCode ?? "";
    message.phoneNumber = object.phoneNumber ?? "";
    message.callConversionReportingState = object.callConversionReportingState ?? 0;
    message.callConversionAction = object.callConversionAction ?? "";
    message.adScheduleTargets = object.adScheduleTargets?.map((e) => AdScheduleInfo.fromPartial(e)) || [];
    message.callOnly = object.callOnly ?? false;
    message.callTrackingEnabled = object.callTrackingEnabled ?? false;
    message.useSearcherTimeZone = object.useSearcherTimeZone ?? false;
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    return message;
  },
};

function createBaseCallToActionAsset(): CallToActionAsset {
  return { callToAction: 0 };
}

export const CallToActionAsset: MessageFns<CallToActionAsset> = {
  encode(message: CallToActionAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callToAction !== 0) {
      writer.uint32(8).int32(message.callToAction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallToActionAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallToActionAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.callToAction = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallToActionAsset {
    return {
      callToAction: isSet(object.callToAction) ? callToActionTypeEnum_CallToActionTypeFromJSON(object.callToAction) : 0,
    };
  },

  toJSON(message: CallToActionAsset): unknown {
    const obj: any = {};
    if (message.callToAction !== 0) {
      obj.callToAction = callToActionTypeEnum_CallToActionTypeToJSON(message.callToAction);
    }
    return obj;
  },

  create(base?: DeepPartial<CallToActionAsset>): CallToActionAsset {
    return CallToActionAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CallToActionAsset>): CallToActionAsset {
    const message = createBaseCallToActionAsset();
    message.callToAction = object.callToAction ?? 0;
    return message;
  },
};

function createBaseUnifiedLocationAsset(): UnifiedLocationAsset {
  return { placeId: "", businessProfileLocations: [], locationOwnershipType: 0 };
}

export const UnifiedLocationAsset: MessageFns<UnifiedLocationAsset> = {
  encode(message: UnifiedLocationAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.placeId !== "") {
      writer.uint32(10).string(message.placeId);
    }
    for (const v of message.businessProfileLocations) {
      BusinessProfileLocation.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.locationOwnershipType !== 0) {
      writer.uint32(24).int32(message.locationOwnershipType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnifiedLocationAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnifiedLocationAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.placeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.businessProfileLocations.push(BusinessProfileLocation.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.locationOwnershipType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnifiedLocationAsset {
    return {
      placeId: isSet(object.placeId) ? globalThis.String(object.placeId) : "",
      businessProfileLocations: globalThis.Array.isArray(object?.businessProfileLocations)
        ? object.businessProfileLocations.map((e: any) => BusinessProfileLocation.fromJSON(e))
        : [],
      locationOwnershipType: isSet(object.locationOwnershipType)
        ? locationOwnershipTypeEnum_LocationOwnershipTypeFromJSON(object.locationOwnershipType)
        : 0,
    };
  },

  toJSON(message: UnifiedLocationAsset): unknown {
    const obj: any = {};
    if (message.placeId !== "") {
      obj.placeId = message.placeId;
    }
    if (message.businessProfileLocations?.length) {
      obj.businessProfileLocations = message.businessProfileLocations.map((e) => BusinessProfileLocation.toJSON(e));
    }
    if (message.locationOwnershipType !== 0) {
      obj.locationOwnershipType = locationOwnershipTypeEnum_LocationOwnershipTypeToJSON(message.locationOwnershipType);
    }
    return obj;
  },

  create(base?: DeepPartial<UnifiedLocationAsset>): UnifiedLocationAsset {
    return UnifiedLocationAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnifiedLocationAsset>): UnifiedLocationAsset {
    const message = createBaseUnifiedLocationAsset();
    message.placeId = object.placeId ?? "";
    message.businessProfileLocations =
      object.businessProfileLocations?.map((e) => BusinessProfileLocation.fromPartial(e)) || [];
    message.locationOwnershipType = object.locationOwnershipType ?? 0;
    return message;
  },
};

function createBaseBusinessProfileLocation(): BusinessProfileLocation {
  return { labels: [], storeCode: "", listingId: Long.ZERO };
}

export const BusinessProfileLocation: MessageFns<BusinessProfileLocation> = {
  encode(message: BusinessProfileLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.labels) {
      writer.uint32(10).string(v!);
    }
    if (message.storeCode !== "") {
      writer.uint32(18).string(message.storeCode);
    }
    if (!message.listingId.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.listingId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessProfileLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessProfileLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.storeCode = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.listingId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BusinessProfileLocation {
    return {
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => globalThis.String(e)) : [],
      storeCode: isSet(object.storeCode) ? globalThis.String(object.storeCode) : "",
      listingId: isSet(object.listingId) ? Long.fromValue(object.listingId) : Long.ZERO,
    };
  },

  toJSON(message: BusinessProfileLocation): unknown {
    const obj: any = {};
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    if (message.storeCode !== "") {
      obj.storeCode = message.storeCode;
    }
    if (!message.listingId.equals(Long.ZERO)) {
      obj.listingId = (message.listingId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<BusinessProfileLocation>): BusinessProfileLocation {
    return BusinessProfileLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BusinessProfileLocation>): BusinessProfileLocation {
    const message = createBaseBusinessProfileLocation();
    message.labels = object.labels?.map((e) => e) || [];
    message.storeCode = object.storeCode ?? "";
    message.listingId = (object.listingId !== undefined && object.listingId !== null)
      ? Long.fromValue(object.listingId)
      : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
