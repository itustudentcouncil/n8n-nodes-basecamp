// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/searchads360/v0/resources/conversion_action.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  AttributionModelEnum_AttributionModel,
  attributionModelEnum_AttributionModelFromJSON,
  attributionModelEnum_AttributionModelToJSON,
} from "../enums/attribution_model.js";
import {
  ConversionActionCategoryEnum_ConversionActionCategory,
  conversionActionCategoryEnum_ConversionActionCategoryFromJSON,
  conversionActionCategoryEnum_ConversionActionCategoryToJSON,
} from "../enums/conversion_action_category.js";
import {
  ConversionActionStatusEnum_ConversionActionStatus,
  conversionActionStatusEnum_ConversionActionStatusFromJSON,
  conversionActionStatusEnum_ConversionActionStatusToJSON,
} from "../enums/conversion_action_status.js";
import {
  ConversionActionTypeEnum_ConversionActionType,
  conversionActionTypeEnum_ConversionActionTypeFromJSON,
  conversionActionTypeEnum_ConversionActionTypeToJSON,
} from "../enums/conversion_action_type.js";
import {
  DataDrivenModelStatusEnum_DataDrivenModelStatus,
  dataDrivenModelStatusEnum_DataDrivenModelStatusFromJSON,
  dataDrivenModelStatusEnum_DataDrivenModelStatusToJSON,
} from "../enums/data_driven_model_status.js";

export const protobufPackage = "google.ads.searchads360.v0.resources";

/** A conversion action. */
export interface ConversionAction {
  /**
   * Immutable. The resource name of the conversion action.
   * Conversion action resource names have the form:
   *
   * `customers/{customer_id}/conversionActions/{conversion_action_id}`
   */
  resourceName: string;
  /** Output only. The ID of the conversion action. */
  id?:
    | Long
    | undefined;
  /**
   * The name of the conversion action.
   *
   * This field is required and should not be empty when creating new
   * conversion actions.
   */
  name?:
    | string
    | undefined;
  /**
   * Output only. Timestamp of the Floodlight activity's creation, formatted in
   * ISO 8601.
   */
  creationTime: string;
  /** The status of this conversion action for conversion event accrual. */
  status: ConversionActionStatusEnum_ConversionActionStatus;
  /** Immutable. The type of this conversion action. */
  type: ConversionActionTypeEnum_ConversionActionType;
  /**
   * If a conversion action's primary_for_goal bit is false, the conversion
   * action is non-biddable for all campaigns regardless of their customer
   * conversion goal or campaign conversion goal.
   * However, custom conversion goals do not respect primary_for_goal, so if
   * a campaign has a custom conversion goal configured with a
   * primary_for_goal = false conversion action, that conversion action is
   * still biddable.
   * By default, primary_for_goal will be true if not set. In V9,
   * primary_for_goal can only be set to false after creation through an
   * 'update' operation because it's not declared as optional.
   */
  primaryForGoal?:
    | boolean
    | undefined;
  /** The category of conversions reported for this conversion action. */
  category: ConversionActionCategoryEnum_ConversionActionCategory;
  /**
   * Output only. The resource name of the conversion action owner customer, or
   * null if this is a system-defined conversion action.
   */
  ownerCustomer?:
    | string
    | undefined;
  /**
   * Whether this conversion action should be included in the
   * "client_account_conversions" metric.
   */
  includeInClientAccountConversionsMetric?:
    | boolean
    | undefined;
  /**
   * Output only. Whether this conversion action should be included in the
   * "conversions" metric.
   */
  includeInConversionsMetric?:
    | boolean
    | undefined;
  /**
   * The maximum number of days that may elapse between an interaction
   * (for example, a click) and a conversion event.
   */
  clickThroughLookbackWindowDays?:
    | Long
    | undefined;
  /**
   * Settings related to the value for conversion events associated with this
   * conversion action.
   */
  valueSettings:
    | ConversionAction_ValueSettings
    | undefined;
  /** Settings related to this conversion action's attribution model. */
  attributionModelSettings:
    | ConversionAction_AttributionModelSettings
    | undefined;
  /** App ID for an app conversion action. */
  appId?:
    | string
    | undefined;
  /** Output only. Floodlight settings for Floodlight conversion types. */
  floodlightSettings: ConversionAction_FloodlightSettings | undefined;
}

/** Settings related to this conversion action's attribution model. */
export interface ConversionAction_AttributionModelSettings {
  /** The attribution model type of this conversion action. */
  attributionModel: AttributionModelEnum_AttributionModel;
  /**
   * Output only. The status of the data-driven attribution model for the
   * conversion action.
   */
  dataDrivenModelStatus: DataDrivenModelStatusEnum_DataDrivenModelStatus;
}

/**
 * Settings related to the value for conversion events associated with this
 * conversion action.
 */
export interface ConversionAction_ValueSettings {
  /**
   * The value to use when conversion events for this conversion action are
   * sent with an invalid, disallowed or missing value, or when
   * this conversion action is configured to always use the default value.
   */
  defaultValue?:
    | number
    | undefined;
  /**
   * The currency code to use when conversion events for this conversion
   * action are sent with an invalid or missing currency code, or when this
   * conversion action is configured to always use the default value.
   */
  defaultCurrencyCode?:
    | string
    | undefined;
  /**
   * Controls whether the default value and default currency code are used in
   * place of the value and currency code specified in conversion events for
   * this conversion action.
   */
  alwaysUseDefaultValue?: boolean | undefined;
}

/** Settings related to a Floodlight conversion action. */
export interface ConversionAction_FloodlightSettings {
  /**
   * Output only. String used to identify a Floodlight activity group when
   * reporting conversions.
   */
  activityGroupTag: string;
  /**
   * Output only. String used to identify a Floodlight activity when reporting
   * conversions.
   */
  activityTag: string;
  /**
   * Output only. ID of the Floodlight activity in DoubleClick Campaign
   * Manager (DCM).
   */
  activityId: Long;
}

function createBaseConversionAction(): ConversionAction {
  return {
    resourceName: "",
    id: undefined,
    name: undefined,
    creationTime: "",
    status: 0,
    type: 0,
    primaryForGoal: undefined,
    category: 0,
    ownerCustomer: undefined,
    includeInClientAccountConversionsMetric: undefined,
    includeInConversionsMetric: undefined,
    clickThroughLookbackWindowDays: undefined,
    valueSettings: undefined,
    attributionModelSettings: undefined,
    appId: undefined,
    floodlightSettings: undefined,
  };
}

export const ConversionAction: MessageFns<ConversionAction> = {
  encode(message: ConversionAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    if (message.id !== undefined) {
      writer.uint32(168).int64(message.id.toString());
    }
    if (message.name !== undefined) {
      writer.uint32(178).string(message.name);
    }
    if (message.creationTime !== "") {
      writer.uint32(266).string(message.creationTime);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.primaryForGoal !== undefined) {
      writer.uint32(248).bool(message.primaryForGoal);
    }
    if (message.category !== 0) {
      writer.uint32(48).int32(message.category);
    }
    if (message.ownerCustomer !== undefined) {
      writer.uint32(186).string(message.ownerCustomer);
    }
    if (message.includeInClientAccountConversionsMetric !== undefined) {
      writer.uint32(192).bool(message.includeInClientAccountConversionsMetric);
    }
    if (message.includeInConversionsMetric !== undefined) {
      writer.uint32(256).bool(message.includeInConversionsMetric);
    }
    if (message.clickThroughLookbackWindowDays !== undefined) {
      writer.uint32(200).int64(message.clickThroughLookbackWindowDays.toString());
    }
    if (message.valueSettings !== undefined) {
      ConversionAction_ValueSettings.encode(message.valueSettings, writer.uint32(90).fork()).join();
    }
    if (message.attributionModelSettings !== undefined) {
      ConversionAction_AttributionModelSettings.encode(message.attributionModelSettings, writer.uint32(106).fork())
        .join();
    }
    if (message.appId !== undefined) {
      writer.uint32(226).string(message.appId);
    }
    if (message.floodlightSettings !== undefined) {
      ConversionAction_FloodlightSettings.encode(message.floodlightSettings, writer.uint32(234).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.name = reader.string();
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.creationTime = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.primaryForGoal = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.ownerCustomer = reader.string();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.includeInClientAccountConversionsMetric = reader.bool();
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.includeInConversionsMetric = reader.bool();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.clickThroughLookbackWindowDays = Long.fromString(reader.int64().toString());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.valueSettings = ConversionAction_ValueSettings.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.attributionModelSettings = ConversionAction_AttributionModelSettings.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.appId = reader.string();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.floodlightSettings = ConversionAction_FloodlightSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionAction {
    return {
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      id: isSet(object.id) ? Long.fromValue(object.id) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      creationTime: isSet(object.creationTime) ? globalThis.String(object.creationTime) : "",
      status: isSet(object.status) ? conversionActionStatusEnum_ConversionActionStatusFromJSON(object.status) : 0,
      type: isSet(object.type) ? conversionActionTypeEnum_ConversionActionTypeFromJSON(object.type) : 0,
      primaryForGoal: isSet(object.primaryForGoal) ? globalThis.Boolean(object.primaryForGoal) : undefined,
      category: isSet(object.category)
        ? conversionActionCategoryEnum_ConversionActionCategoryFromJSON(object.category)
        : 0,
      ownerCustomer: isSet(object.ownerCustomer) ? globalThis.String(object.ownerCustomer) : undefined,
      includeInClientAccountConversionsMetric: isSet(object.includeInClientAccountConversionsMetric)
        ? globalThis.Boolean(object.includeInClientAccountConversionsMetric)
        : undefined,
      includeInConversionsMetric: isSet(object.includeInConversionsMetric)
        ? globalThis.Boolean(object.includeInConversionsMetric)
        : undefined,
      clickThroughLookbackWindowDays: isSet(object.clickThroughLookbackWindowDays)
        ? Long.fromValue(object.clickThroughLookbackWindowDays)
        : undefined,
      valueSettings: isSet(object.valueSettings)
        ? ConversionAction_ValueSettings.fromJSON(object.valueSettings)
        : undefined,
      attributionModelSettings: isSet(object.attributionModelSettings)
        ? ConversionAction_AttributionModelSettings.fromJSON(object.attributionModelSettings)
        : undefined,
      appId: isSet(object.appId) ? globalThis.String(object.appId) : undefined,
      floodlightSettings: isSet(object.floodlightSettings)
        ? ConversionAction_FloodlightSettings.fromJSON(object.floodlightSettings)
        : undefined,
    };
  },

  toJSON(message: ConversionAction): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.id !== undefined) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.creationTime !== "") {
      obj.creationTime = message.creationTime;
    }
    if (message.status !== 0) {
      obj.status = conversionActionStatusEnum_ConversionActionStatusToJSON(message.status);
    }
    if (message.type !== 0) {
      obj.type = conversionActionTypeEnum_ConversionActionTypeToJSON(message.type);
    }
    if (message.primaryForGoal !== undefined) {
      obj.primaryForGoal = message.primaryForGoal;
    }
    if (message.category !== 0) {
      obj.category = conversionActionCategoryEnum_ConversionActionCategoryToJSON(message.category);
    }
    if (message.ownerCustomer !== undefined) {
      obj.ownerCustomer = message.ownerCustomer;
    }
    if (message.includeInClientAccountConversionsMetric !== undefined) {
      obj.includeInClientAccountConversionsMetric = message.includeInClientAccountConversionsMetric;
    }
    if (message.includeInConversionsMetric !== undefined) {
      obj.includeInConversionsMetric = message.includeInConversionsMetric;
    }
    if (message.clickThroughLookbackWindowDays !== undefined) {
      obj.clickThroughLookbackWindowDays = (message.clickThroughLookbackWindowDays || Long.ZERO).toString();
    }
    if (message.valueSettings !== undefined) {
      obj.valueSettings = ConversionAction_ValueSettings.toJSON(message.valueSettings);
    }
    if (message.attributionModelSettings !== undefined) {
      obj.attributionModelSettings = ConversionAction_AttributionModelSettings.toJSON(message.attributionModelSettings);
    }
    if (message.appId !== undefined) {
      obj.appId = message.appId;
    }
    if (message.floodlightSettings !== undefined) {
      obj.floodlightSettings = ConversionAction_FloodlightSettings.toJSON(message.floodlightSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionAction>): ConversionAction {
    return ConversionAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversionAction>): ConversionAction {
    const message = createBaseConversionAction();
    message.resourceName = object.resourceName ?? "";
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : undefined;
    message.name = object.name ?? undefined;
    message.creationTime = object.creationTime ?? "";
    message.status = object.status ?? 0;
    message.type = object.type ?? 0;
    message.primaryForGoal = object.primaryForGoal ?? undefined;
    message.category = object.category ?? 0;
    message.ownerCustomer = object.ownerCustomer ?? undefined;
    message.includeInClientAccountConversionsMetric = object.includeInClientAccountConversionsMetric ?? undefined;
    message.includeInConversionsMetric = object.includeInConversionsMetric ?? undefined;
    message.clickThroughLookbackWindowDays =
      (object.clickThroughLookbackWindowDays !== undefined && object.clickThroughLookbackWindowDays !== null)
        ? Long.fromValue(object.clickThroughLookbackWindowDays)
        : undefined;
    message.valueSettings = (object.valueSettings !== undefined && object.valueSettings !== null)
      ? ConversionAction_ValueSettings.fromPartial(object.valueSettings)
      : undefined;
    message.attributionModelSettings =
      (object.attributionModelSettings !== undefined && object.attributionModelSettings !== null)
        ? ConversionAction_AttributionModelSettings.fromPartial(object.attributionModelSettings)
        : undefined;
    message.appId = object.appId ?? undefined;
    message.floodlightSettings = (object.floodlightSettings !== undefined && object.floodlightSettings !== null)
      ? ConversionAction_FloodlightSettings.fromPartial(object.floodlightSettings)
      : undefined;
    return message;
  },
};

function createBaseConversionAction_AttributionModelSettings(): ConversionAction_AttributionModelSettings {
  return { attributionModel: 0, dataDrivenModelStatus: 0 };
}

export const ConversionAction_AttributionModelSettings: MessageFns<ConversionAction_AttributionModelSettings> = {
  encode(message: ConversionAction_AttributionModelSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attributionModel !== 0) {
      writer.uint32(8).int32(message.attributionModel);
    }
    if (message.dataDrivenModelStatus !== 0) {
      writer.uint32(16).int32(message.dataDrivenModelStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionAction_AttributionModelSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionAction_AttributionModelSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.attributionModel = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dataDrivenModelStatus = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionAction_AttributionModelSettings {
    return {
      attributionModel: isSet(object.attributionModel)
        ? attributionModelEnum_AttributionModelFromJSON(object.attributionModel)
        : 0,
      dataDrivenModelStatus: isSet(object.dataDrivenModelStatus)
        ? dataDrivenModelStatusEnum_DataDrivenModelStatusFromJSON(object.dataDrivenModelStatus)
        : 0,
    };
  },

  toJSON(message: ConversionAction_AttributionModelSettings): unknown {
    const obj: any = {};
    if (message.attributionModel !== 0) {
      obj.attributionModel = attributionModelEnum_AttributionModelToJSON(message.attributionModel);
    }
    if (message.dataDrivenModelStatus !== 0) {
      obj.dataDrivenModelStatus = dataDrivenModelStatusEnum_DataDrivenModelStatusToJSON(message.dataDrivenModelStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionAction_AttributionModelSettings>): ConversionAction_AttributionModelSettings {
    return ConversionAction_AttributionModelSettings.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ConversionAction_AttributionModelSettings>,
  ): ConversionAction_AttributionModelSettings {
    const message = createBaseConversionAction_AttributionModelSettings();
    message.attributionModel = object.attributionModel ?? 0;
    message.dataDrivenModelStatus = object.dataDrivenModelStatus ?? 0;
    return message;
  },
};

function createBaseConversionAction_ValueSettings(): ConversionAction_ValueSettings {
  return { defaultValue: undefined, defaultCurrencyCode: undefined, alwaysUseDefaultValue: undefined };
}

export const ConversionAction_ValueSettings: MessageFns<ConversionAction_ValueSettings> = {
  encode(message: ConversionAction_ValueSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultValue !== undefined) {
      writer.uint32(33).double(message.defaultValue);
    }
    if (message.defaultCurrencyCode !== undefined) {
      writer.uint32(42).string(message.defaultCurrencyCode);
    }
    if (message.alwaysUseDefaultValue !== undefined) {
      writer.uint32(48).bool(message.alwaysUseDefaultValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionAction_ValueSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionAction_ValueSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 33) {
            break;
          }

          message.defaultValue = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.defaultCurrencyCode = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.alwaysUseDefaultValue = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionAction_ValueSettings {
    return {
      defaultValue: isSet(object.defaultValue) ? globalThis.Number(object.defaultValue) : undefined,
      defaultCurrencyCode: isSet(object.defaultCurrencyCode)
        ? globalThis.String(object.defaultCurrencyCode)
        : undefined,
      alwaysUseDefaultValue: isSet(object.alwaysUseDefaultValue)
        ? globalThis.Boolean(object.alwaysUseDefaultValue)
        : undefined,
    };
  },

  toJSON(message: ConversionAction_ValueSettings): unknown {
    const obj: any = {};
    if (message.defaultValue !== undefined) {
      obj.defaultValue = message.defaultValue;
    }
    if (message.defaultCurrencyCode !== undefined) {
      obj.defaultCurrencyCode = message.defaultCurrencyCode;
    }
    if (message.alwaysUseDefaultValue !== undefined) {
      obj.alwaysUseDefaultValue = message.alwaysUseDefaultValue;
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionAction_ValueSettings>): ConversionAction_ValueSettings {
    return ConversionAction_ValueSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversionAction_ValueSettings>): ConversionAction_ValueSettings {
    const message = createBaseConversionAction_ValueSettings();
    message.defaultValue = object.defaultValue ?? undefined;
    message.defaultCurrencyCode = object.defaultCurrencyCode ?? undefined;
    message.alwaysUseDefaultValue = object.alwaysUseDefaultValue ?? undefined;
    return message;
  },
};

function createBaseConversionAction_FloodlightSettings(): ConversionAction_FloodlightSettings {
  return { activityGroupTag: "", activityTag: "", activityId: Long.ZERO };
}

export const ConversionAction_FloodlightSettings: MessageFns<ConversionAction_FloodlightSettings> = {
  encode(message: ConversionAction_FloodlightSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.activityGroupTag !== "") {
      writer.uint32(10).string(message.activityGroupTag);
    }
    if (message.activityTag !== "") {
      writer.uint32(18).string(message.activityTag);
    }
    if (!message.activityId.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.activityId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversionAction_FloodlightSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionAction_FloodlightSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.activityGroupTag = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.activityTag = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.activityId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionAction_FloodlightSettings {
    return {
      activityGroupTag: isSet(object.activityGroupTag) ? globalThis.String(object.activityGroupTag) : "",
      activityTag: isSet(object.activityTag) ? globalThis.String(object.activityTag) : "",
      activityId: isSet(object.activityId) ? Long.fromValue(object.activityId) : Long.ZERO,
    };
  },

  toJSON(message: ConversionAction_FloodlightSettings): unknown {
    const obj: any = {};
    if (message.activityGroupTag !== "") {
      obj.activityGroupTag = message.activityGroupTag;
    }
    if (message.activityTag !== "") {
      obj.activityTag = message.activityTag;
    }
    if (!message.activityId.equals(Long.ZERO)) {
      obj.activityId = (message.activityId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionAction_FloodlightSettings>): ConversionAction_FloodlightSettings {
    return ConversionAction_FloodlightSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversionAction_FloodlightSettings>): ConversionAction_FloodlightSettings {
    const message = createBaseConversionAction_FloodlightSettings();
    message.activityGroupTag = object.activityGroupTag ?? "";
    message.activityTag = object.activityTag ?? "";
    message.activityId = (object.activityId !== undefined && object.activityId !== null)
      ? Long.fromValue(object.activityId)
      : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
