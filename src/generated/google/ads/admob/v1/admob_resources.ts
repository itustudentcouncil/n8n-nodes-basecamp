// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ads/admob/v1/admob_resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { DateMessage } from "../../../type/date.js";

export const protobufPackage = "google.ads.admob.v1";

/** The sorting order. */
export enum SortOrder {
  /** SORT_ORDER_UNSPECIFIED - Default value for an unset field. Do not use. */
  SORT_ORDER_UNSPECIFIED = 0,
  /** ASCENDING - Sort dimension value or metric value in ascending order. */
  ASCENDING = 1,
  /** DESCENDING - Sort dimension value or metric value in descending order. */
  DESCENDING = 2,
  UNRECOGNIZED = -1,
}

export function sortOrderFromJSON(object: any): SortOrder {
  switch (object) {
    case 0:
    case "SORT_ORDER_UNSPECIFIED":
      return SortOrder.SORT_ORDER_UNSPECIFIED;
    case 1:
    case "ASCENDING":
      return SortOrder.ASCENDING;
    case 2:
    case "DESCENDING":
      return SortOrder.DESCENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SortOrder.UNRECOGNIZED;
  }
}

export function sortOrderToJSON(object: SortOrder): string {
  switch (object) {
    case SortOrder.SORT_ORDER_UNSPECIFIED:
      return "SORT_ORDER_UNSPECIFIED";
    case SortOrder.ASCENDING:
      return "ASCENDING";
    case SortOrder.DESCENDING:
      return "DESCENDING";
    case SortOrder.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A publisher account contains information relevant to the use of this API,
 * such as the time zone used for the reports.
 */
export interface PublisherAccount {
  /**
   * Resource name of this account.
   * Format is accounts/{publisher_id}.
   */
  name: string;
  /**
   * The unique ID by which this publisher account can be identified
   * in the API requests (for example, pub-1234567890).
   */
  publisherId: string;
  /**
   * The time zone that is used in reports that are generated for this account.
   * The value is a time-zone ID as specified by the CLDR project,
   * for example, "America/Los_Angeles".
   */
  reportingTimeZone: string;
  /**
   * Currency code of the earning-related metrics, which is the 3-letter code
   * defined in ISO 4217. The daily average rate is used for the currency
   * conversion.
   */
  currencyCode: string;
}

/**
 * The specification for generating an AdMob Network report.
 * For example, the specification to get clicks and estimated earnings for only
 * the 'US' and 'CN' countries can look like the following example:
 *
 *     {
 *       'date_range': {
 *         'start_date': {'year': 2018, 'month': 9, 'day': 1},
 *         'end_date': {'year': 2018, 'month': 9, 'day': 30}
 *       },
 *       'dimensions': ['DATE', 'APP', 'COUNTRY'],
 *       'metrics': ['CLICKS', 'ESTIMATED_EARNINGS'],
 *       'dimension_filters': [
 *         {
 *           'dimension': 'COUNTRY',
 *           'matches_any': {'values': [{'value': 'US', 'value': 'CN'}]}
 *         }
 *       ],
 *       'sort_conditions': [
 *         {'dimension':'APP', order: 'ASCENDING'},
 *         {'metric':'CLICKS', order: 'DESCENDING'}
 *       ],
 *       'localization_settings': {
 *         'currency_code': 'USD',
 *         'language_code': 'en-US'
 *       }
 *     }
 *
 * For a better understanding, you can treat the preceding specification like
 * the following pseudo SQL:
 *
 *     SELECT DATE, APP, COUNTRY, CLICKS, ESTIMATED_EARNINGS
 *     FROM NETWORK_REPORT
 *     WHERE DATE >= '2018-09-01' AND DATE <= '2018-09-30'
 *         AND COUNTRY IN ('US', 'CN')
 *     GROUP BY DATE, APP, COUNTRY
 *     ORDER BY APP ASC, CLICKS DESC;
 */
export interface NetworkReportSpec {
  /** The date range for which the report is generated. */
  dateRange:
    | DateRange
    | undefined;
  /**
   * List of dimensions of the report. The value combination of these dimensions
   * determines the row of the report. If no dimensions are specified, the
   * report returns a single row of requested metrics for the entire account.
   */
  dimensions: NetworkReportSpec_Dimension[];
  /** List of metrics of the report. A report must specify at least one metric. */
  metrics: NetworkReportSpec_Metric[];
  /** Describes which report rows to match based on their dimension values. */
  dimensionFilters: NetworkReportSpec_DimensionFilter[];
  /**
   * Describes the sorting of report rows. The order of the condition in the
   * list defines its precedence; the earlier the condition, the higher its
   * precedence. If no sort conditions are specified, the row ordering is
   * undefined.
   */
  sortConditions: NetworkReportSpec_SortCondition[];
  /** Localization settings of the report. */
  localizationSettings:
    | LocalizationSettings
    | undefined;
  /**
   * Maximum number of report data rows to return. If the value is not set, the
   * API returns as many rows as possible, up to 100000. Acceptable values are
   * 1-100000, inclusive. Any other values are treated as 100000.
   */
  maxReportRows: number;
  /**
   * A report time zone. Accepts an IANA TZ name values, such as
   * "America/Los_Angeles."  If no time zone is defined, the account default
   * takes effect. Check default value by the get account action.
   *
   * **Warning:** The "America/Los_Angeles" is the only supported value at
   * the moment.
   */
  timeZone: string;
}

/**
 * The dimensions of the network report. Dimensions are data attributes to
 * break down or refine the quantitative measurements (metrics) by certain
 * attributes, such as the ad format or the platform an ad was viewed on.
 */
export enum NetworkReportSpec_Dimension {
  /** DIMENSION_UNSPECIFIED - Default value for an unset field. Do not use. */
  DIMENSION_UNSPECIFIED = 0,
  /**
   * DATE - A date in the YYYY-MM-DD format (for example, "2018-12-21"). Requests can
   * specify at most one time dimension.
   */
  DATE = 1,
  /**
   * MONTH - A month in the YYYY-MM format (for example, "2018-12"). Requests can
   * specify at most one time dimension.
   */
  MONTH = 2,
  /**
   * WEEK - The date of the first day of a week in the YYYY-MM-DD format
   * (for example, "2018-12-21"). Requests can specify at most one time
   * dimension.
   */
  WEEK = 3,
  /**
   * AD_UNIT - The unique ID of the ad unit (for example, "ca-app-pub-1234/1234").
   * If AD_UNIT dimension is specified, then APP is included automatically.
   */
  AD_UNIT = 4,
  /**
   * APP - The unique ID of the mobile application (for example,
   * "ca-app-pub-1234~1234").
   */
  APP = 5,
  /**
   * AD_TYPE - Type of the ad (for example, "text" or "image"), an ad delivery
   * dimension.
   *
   * **Warning:** The dimension is incompatible with
   * [AD_REQUESTS](#Metric.ENUM_VALUES.AD_REQUESTS),
   * [MATCH_RATE](#Metric.ENUM_VALUES.MATCH_RATE) and
   * [IMPRESSION_RPM](#Metric.ENUM_VALUES.IMPRESSION_RPM) metrics.
   */
  AD_TYPE = 6,
  /**
   * COUNTRY - CLDR country code of the place where the ad views/clicks occur (for
   * example, "US" or "FR"). This is a geography dimension.
   */
  COUNTRY = 7,
  /**
   * FORMAT - Format of the ad unit (for example, "banner", "native"), an ad delivery
   * dimension.
   */
  FORMAT = 8,
  /** PLATFORM - Mobile OS platform of the app (for example, "Android" or "iOS"). */
  PLATFORM = 9,
  UNRECOGNIZED = -1,
}

export function networkReportSpec_DimensionFromJSON(object: any): NetworkReportSpec_Dimension {
  switch (object) {
    case 0:
    case "DIMENSION_UNSPECIFIED":
      return NetworkReportSpec_Dimension.DIMENSION_UNSPECIFIED;
    case 1:
    case "DATE":
      return NetworkReportSpec_Dimension.DATE;
    case 2:
    case "MONTH":
      return NetworkReportSpec_Dimension.MONTH;
    case 3:
    case "WEEK":
      return NetworkReportSpec_Dimension.WEEK;
    case 4:
    case "AD_UNIT":
      return NetworkReportSpec_Dimension.AD_UNIT;
    case 5:
    case "APP":
      return NetworkReportSpec_Dimension.APP;
    case 6:
    case "AD_TYPE":
      return NetworkReportSpec_Dimension.AD_TYPE;
    case 7:
    case "COUNTRY":
      return NetworkReportSpec_Dimension.COUNTRY;
    case 8:
    case "FORMAT":
      return NetworkReportSpec_Dimension.FORMAT;
    case 9:
    case "PLATFORM":
      return NetworkReportSpec_Dimension.PLATFORM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkReportSpec_Dimension.UNRECOGNIZED;
  }
}

export function networkReportSpec_DimensionToJSON(object: NetworkReportSpec_Dimension): string {
  switch (object) {
    case NetworkReportSpec_Dimension.DIMENSION_UNSPECIFIED:
      return "DIMENSION_UNSPECIFIED";
    case NetworkReportSpec_Dimension.DATE:
      return "DATE";
    case NetworkReportSpec_Dimension.MONTH:
      return "MONTH";
    case NetworkReportSpec_Dimension.WEEK:
      return "WEEK";
    case NetworkReportSpec_Dimension.AD_UNIT:
      return "AD_UNIT";
    case NetworkReportSpec_Dimension.APP:
      return "APP";
    case NetworkReportSpec_Dimension.AD_TYPE:
      return "AD_TYPE";
    case NetworkReportSpec_Dimension.COUNTRY:
      return "COUNTRY";
    case NetworkReportSpec_Dimension.FORMAT:
      return "FORMAT";
    case NetworkReportSpec_Dimension.PLATFORM:
      return "PLATFORM";
    case NetworkReportSpec_Dimension.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The metrics of the network report. Metrics are quantitative measurements
 * indicating how the publisher business is performing. They are aggregated
 * from the individual ad events and grouped by the report dimensions. The
 * metric value is either integer, or decimal (without rounding).
 */
export enum NetworkReportSpec_Metric {
  /** METRIC_UNSPECIFIED - Default value for an unset field. Do not use. */
  METRIC_UNSPECIFIED = 0,
  /**
   * AD_REQUESTS - The number of ad requests. The value is an integer.
   *
   * **Warning:** The metric is incompatible with
   * [AD_TYPE](#Dimension.ENUM_VALUES.AD_TYPE) dimension.
   */
  AD_REQUESTS = 1,
  /** CLICKS - The number of times a user clicks an ad. The value is an integer. */
  CLICKS = 2,
  /**
   * ESTIMATED_EARNINGS - The estimated earnings of the AdMob publisher. The currency unit (USD,
   * EUR, or other) of the earning metrics are determined by the localization
   * setting for currency. The amount is in micros. For example, $6.50 would
   * be represented as 6500000.
   */
  ESTIMATED_EARNINGS = 3,
  /** IMPRESSIONS - The total number of ads shown to users. The value is an integer. */
  IMPRESSIONS = 4,
  /**
   * IMPRESSION_CTR - The ratio of clicks over impressions. The value is a double precision
   * (approximate) decimal value.
   */
  IMPRESSION_CTR = 5,
  /**
   * IMPRESSION_RPM - The estimated earnings per thousand ad impressions. The value is in
   * micros. For example, $1.03 would be represented as 1030000.
   *
   * **Warning:** The metric is incompatible with
   * [AD_TYPE](#Dimension.ENUM_VALUES.AD_TYPE) dimension.
   */
  IMPRESSION_RPM = 6,
  /**
   * MATCHED_REQUESTS - The number of times ads are returned in response to a request. The value
   * is an integer.
   */
  MATCHED_REQUESTS = 7,
  /**
   * MATCH_RATE - The ratio of matched ad requests over the total ad requests. The value is
   * a double precision (approximate) decimal value.
   *
   * **Warning:** The metric is incompatible with
   * [AD_TYPE](#Dimension.ENUM_VALUES.AD_TYPE) dimension.
   */
  MATCH_RATE = 8,
  /**
   * SHOW_RATE - The ratio of ads that are displayed over ads that are returned, defined
   * as impressions / matched requests. The value is a double precision
   * (approximate) decimal value.
   */
  SHOW_RATE = 9,
  UNRECOGNIZED = -1,
}

export function networkReportSpec_MetricFromJSON(object: any): NetworkReportSpec_Metric {
  switch (object) {
    case 0:
    case "METRIC_UNSPECIFIED":
      return NetworkReportSpec_Metric.METRIC_UNSPECIFIED;
    case 1:
    case "AD_REQUESTS":
      return NetworkReportSpec_Metric.AD_REQUESTS;
    case 2:
    case "CLICKS":
      return NetworkReportSpec_Metric.CLICKS;
    case 3:
    case "ESTIMATED_EARNINGS":
      return NetworkReportSpec_Metric.ESTIMATED_EARNINGS;
    case 4:
    case "IMPRESSIONS":
      return NetworkReportSpec_Metric.IMPRESSIONS;
    case 5:
    case "IMPRESSION_CTR":
      return NetworkReportSpec_Metric.IMPRESSION_CTR;
    case 6:
    case "IMPRESSION_RPM":
      return NetworkReportSpec_Metric.IMPRESSION_RPM;
    case 7:
    case "MATCHED_REQUESTS":
      return NetworkReportSpec_Metric.MATCHED_REQUESTS;
    case 8:
    case "MATCH_RATE":
      return NetworkReportSpec_Metric.MATCH_RATE;
    case 9:
    case "SHOW_RATE":
      return NetworkReportSpec_Metric.SHOW_RATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkReportSpec_Metric.UNRECOGNIZED;
  }
}

export function networkReportSpec_MetricToJSON(object: NetworkReportSpec_Metric): string {
  switch (object) {
    case NetworkReportSpec_Metric.METRIC_UNSPECIFIED:
      return "METRIC_UNSPECIFIED";
    case NetworkReportSpec_Metric.AD_REQUESTS:
      return "AD_REQUESTS";
    case NetworkReportSpec_Metric.CLICKS:
      return "CLICKS";
    case NetworkReportSpec_Metric.ESTIMATED_EARNINGS:
      return "ESTIMATED_EARNINGS";
    case NetworkReportSpec_Metric.IMPRESSIONS:
      return "IMPRESSIONS";
    case NetworkReportSpec_Metric.IMPRESSION_CTR:
      return "IMPRESSION_CTR";
    case NetworkReportSpec_Metric.IMPRESSION_RPM:
      return "IMPRESSION_RPM";
    case NetworkReportSpec_Metric.MATCHED_REQUESTS:
      return "MATCHED_REQUESTS";
    case NetworkReportSpec_Metric.MATCH_RATE:
      return "MATCH_RATE";
    case NetworkReportSpec_Metric.SHOW_RATE:
      return "SHOW_RATE";
    case NetworkReportSpec_Metric.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Describes which report rows to match based on their dimension values. */
export interface NetworkReportSpec_DimensionFilter {
  /**
   * Matches a row if its value for the specified dimension is in one of the
   * values specified in this condition.
   */
  matchesAny?:
    | StringList
    | undefined;
  /** Applies the filter criterion to the specified dimension. */
  dimension: NetworkReportSpec_Dimension;
}

/** Sorting direction to be applied on a dimension or a metric. */
export interface NetworkReportSpec_SortCondition {
  /** Sort by the specified dimension. */
  dimension?:
    | NetworkReportSpec_Dimension
    | undefined;
  /** Sort by the specified metric. */
  metric?:
    | NetworkReportSpec_Metric
    | undefined;
  /** Sorting order of the dimension or metric. */
  order: SortOrder;
}

/**
 * The specification for generating an AdMob Mediation report.
 * For example, the specification to get observed ECPM sliced by ad source and
 * app for the 'US' and 'CN' countries can look like the following example:
 *
 *     {
 *       "date_range": {
 *         "start_date": {"year": 2018, "month": 9, "day": 1},
 *         "end_date": {"year": 2018, "month": 9, "day": 30}
 *       },
 *       "dimensions": ["AD_SOURCE", "APP", "COUNTRY"],
 *       "metrics": ["OBSERVED_ECPM"],
 *       "dimension_filters": [
 *         {
 *           "dimension": "COUNTRY",
 *           "matches_any": {"values": [{"value": "US", "value": "CN"}]}
 *         }
 *       ],
 *       "sort_conditions": [
 *         {"dimension":"APP", order: "ASCENDING"}
 *       ],
 *       "localization_settings": {
 *         "currency_code": "USD",
 *         "language_code": "en-US"
 *       }
 *     }
 *
 * For a better understanding, you can treat the preceding specification like
 * the following pseudo SQL:
 *
 *     SELECT AD_SOURCE, APP, COUNTRY, OBSERVED_ECPM
 *     FROM MEDIATION_REPORT
 *     WHERE DATE >= '2018-09-01' AND DATE <= '2018-09-30'
 *         AND COUNTRY IN ('US', 'CN')
 *     GROUP BY AD_SOURCE, APP, COUNTRY
 *     ORDER BY APP ASC;
 */
export interface MediationReportSpec {
  /** The date range for which the report is generated. */
  dateRange:
    | DateRange
    | undefined;
  /**
   * List of dimensions of the report. The value combination of these dimensions
   * determines the row of the report. If no dimensions are specified, the
   * report returns a single row of requested metrics for the entire account.
   */
  dimensions: MediationReportSpec_Dimension[];
  /** List of metrics of the report. A report must specify at least one metric. */
  metrics: MediationReportSpec_Metric[];
  /** Describes which report rows to match based on their dimension values. */
  dimensionFilters: MediationReportSpec_DimensionFilter[];
  /**
   * Describes the sorting of report rows. The order of the condition in the
   * list defines its precedence; the earlier the condition, the higher its
   * precedence. If no sort conditions are specified, the row ordering is
   * undefined.
   */
  sortConditions: MediationReportSpec_SortCondition[];
  /** Localization settings of the report. */
  localizationSettings:
    | LocalizationSettings
    | undefined;
  /**
   * Maximum number of report data rows to return. If the value is not set, the
   * API returns as many rows as possible, up to 100000. Acceptable values are
   * 1-100000, inclusive. Any other values are treated as 100000.
   */
  maxReportRows: number;
  /**
   * A report time zone. Accepts an IANA TZ name values, such as
   * "America/Los_Angeles."  If no time zone is defined, the account default
   * takes effect. Check default value by the get account action.
   *
   * **Warning:** The "America/Los_Angeles" is the only supported value at
   * the moment.
   */
  timeZone: string;
}

/**
 * The dimensions of the mediation report. Dimensions are data attributes to
 * break down or refine the quantitative measurements (metrics) by certain
 * attributes, such as the ad format or the platform an ad was viewed on.
 */
export enum MediationReportSpec_Dimension {
  /** DIMENSION_UNSPECIFIED - Default value for an unset field. Do not use. */
  DIMENSION_UNSPECIFIED = 0,
  /**
   * DATE - A date in the YYYY-MM-DD format (for example, "2018-12-21"). Requests can
   * specify at most one time dimension.
   */
  DATE = 1,
  /**
   * MONTH - A month in the YYYY-MM format (for example, "2018-12"). Requests can
   * specify at most one time dimension.
   */
  MONTH = 2,
  /**
   * WEEK - The date of the first day of a week in the YYYY-MM-DD format
   * (for example, "2018-12-21"). Requests can specify at most one time
   * dimension.
   */
  WEEK = 3,
  /**
   * AD_SOURCE - The [unique ID of the ad source](/admob/api/v1/ad_sources) (for example,
   * "5450213213286189855" and "AdMob Network" as label value).
   */
  AD_SOURCE = 4,
  /**
   * AD_SOURCE_INSTANCE - The unique ID of the ad source instance (for example,
   * "ca-app-pub-1234#5678" and "AdMob (default)" as label value).
   */
  AD_SOURCE_INSTANCE = 5,
  /**
   * AD_UNIT - The unique ID of the ad unit (for example, "ca-app-pub-1234/8790").
   * If AD_UNIT dimension is specified, then APP is included automatically.
   */
  AD_UNIT = 6,
  /**
   * APP - The unique ID of the mobile application (for example,
   * "ca-app-pub-1234~1234").
   */
  APP = 7,
  /**
   * MEDIATION_GROUP - The unique ID of the mediation group (for example,
   * "ca-app-pub-1234:mg:1234" and "AdMob (default)" as label value).
   */
  MEDIATION_GROUP = 11,
  /**
   * COUNTRY - CLDR country code of the place where the ad views/clicks occur (for
   * example, "US" or "FR"). This is a geography dimension.
   */
  COUNTRY = 8,
  /**
   * FORMAT - Format of the ad unit (for example, "banner", "native"), an ad delivery
   * dimension.
   */
  FORMAT = 9,
  /** PLATFORM - Mobile OS platform of the app (for example, "Android" or "iOS"). */
  PLATFORM = 10,
  UNRECOGNIZED = -1,
}

export function mediationReportSpec_DimensionFromJSON(object: any): MediationReportSpec_Dimension {
  switch (object) {
    case 0:
    case "DIMENSION_UNSPECIFIED":
      return MediationReportSpec_Dimension.DIMENSION_UNSPECIFIED;
    case 1:
    case "DATE":
      return MediationReportSpec_Dimension.DATE;
    case 2:
    case "MONTH":
      return MediationReportSpec_Dimension.MONTH;
    case 3:
    case "WEEK":
      return MediationReportSpec_Dimension.WEEK;
    case 4:
    case "AD_SOURCE":
      return MediationReportSpec_Dimension.AD_SOURCE;
    case 5:
    case "AD_SOURCE_INSTANCE":
      return MediationReportSpec_Dimension.AD_SOURCE_INSTANCE;
    case 6:
    case "AD_UNIT":
      return MediationReportSpec_Dimension.AD_UNIT;
    case 7:
    case "APP":
      return MediationReportSpec_Dimension.APP;
    case 11:
    case "MEDIATION_GROUP":
      return MediationReportSpec_Dimension.MEDIATION_GROUP;
    case 8:
    case "COUNTRY":
      return MediationReportSpec_Dimension.COUNTRY;
    case 9:
    case "FORMAT":
      return MediationReportSpec_Dimension.FORMAT;
    case 10:
    case "PLATFORM":
      return MediationReportSpec_Dimension.PLATFORM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MediationReportSpec_Dimension.UNRECOGNIZED;
  }
}

export function mediationReportSpec_DimensionToJSON(object: MediationReportSpec_Dimension): string {
  switch (object) {
    case MediationReportSpec_Dimension.DIMENSION_UNSPECIFIED:
      return "DIMENSION_UNSPECIFIED";
    case MediationReportSpec_Dimension.DATE:
      return "DATE";
    case MediationReportSpec_Dimension.MONTH:
      return "MONTH";
    case MediationReportSpec_Dimension.WEEK:
      return "WEEK";
    case MediationReportSpec_Dimension.AD_SOURCE:
      return "AD_SOURCE";
    case MediationReportSpec_Dimension.AD_SOURCE_INSTANCE:
      return "AD_SOURCE_INSTANCE";
    case MediationReportSpec_Dimension.AD_UNIT:
      return "AD_UNIT";
    case MediationReportSpec_Dimension.APP:
      return "APP";
    case MediationReportSpec_Dimension.MEDIATION_GROUP:
      return "MEDIATION_GROUP";
    case MediationReportSpec_Dimension.COUNTRY:
      return "COUNTRY";
    case MediationReportSpec_Dimension.FORMAT:
      return "FORMAT";
    case MediationReportSpec_Dimension.PLATFORM:
      return "PLATFORM";
    case MediationReportSpec_Dimension.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The metrics of the mediation report. Metrics are quantitative measurements
 * indicating how the publisher business is performing. They are aggregated
 * from the individual ad events and grouped by the report dimensions. The
 * metric value is either integer, or decimal (without rounding).
 */
export enum MediationReportSpec_Metric {
  /** METRIC_UNSPECIFIED - Default value for an unset field. Do not use. */
  METRIC_UNSPECIFIED = 0,
  /** AD_REQUESTS - The number of requests. The value is an integer. */
  AD_REQUESTS = 1,
  /** CLICKS - The number of times a user clicks an ad. The value is an integer. */
  CLICKS = 2,
  /**
   * ESTIMATED_EARNINGS - The estimated earnings of the AdMob publisher. The currency unit (USD,
   * EUR, or other) of the earning metrics are determined by the localization
   * setting for currency. The amount is in micros. For example, $6.50 would
   * be represented as 6500000.
   *
   * Estimated earnings per mediation group and per ad source instance level
   * is supported dating back to October 20, 2019. Third-party estimated
   * earnings will show 0 for dates prior to October 20, 2019.
   */
  ESTIMATED_EARNINGS = 3,
  /** IMPRESSIONS - The total number of ads shown to users. The value is an integer. */
  IMPRESSIONS = 4,
  /**
   * IMPRESSION_CTR - The ratio of clicks over impressions. The value is a double precision
   * (approximate) decimal value.
   */
  IMPRESSION_CTR = 5,
  /**
   * MATCHED_REQUESTS - The number of times ads are returned in response to a request. The value
   * is an integer.
   */
  MATCHED_REQUESTS = 6,
  /**
   * MATCH_RATE - The ratio of matched ad requests over the total ad requests. The value is
   * a double precision (approximate) decimal value.
   */
  MATCH_RATE = 7,
  /**
   * OBSERVED_ECPM - The third-party ad network's estimated average eCPM. The currency unit
   * (USD, EUR, or other) of the earning metrics are determined by the
   * localization setting for currency. The amount is in micros. For example,
   * $2.30 would be represented as 2300000.
   *
   * The estimated average eCPM per mediation group and per ad source instance
   * level is supported dating back to October 20, 2019. Third-party estimated
   * average eCPM will show 0 for dates prior to October 20, 2019.
   */
  OBSERVED_ECPM = 8,
  UNRECOGNIZED = -1,
}

export function mediationReportSpec_MetricFromJSON(object: any): MediationReportSpec_Metric {
  switch (object) {
    case 0:
    case "METRIC_UNSPECIFIED":
      return MediationReportSpec_Metric.METRIC_UNSPECIFIED;
    case 1:
    case "AD_REQUESTS":
      return MediationReportSpec_Metric.AD_REQUESTS;
    case 2:
    case "CLICKS":
      return MediationReportSpec_Metric.CLICKS;
    case 3:
    case "ESTIMATED_EARNINGS":
      return MediationReportSpec_Metric.ESTIMATED_EARNINGS;
    case 4:
    case "IMPRESSIONS":
      return MediationReportSpec_Metric.IMPRESSIONS;
    case 5:
    case "IMPRESSION_CTR":
      return MediationReportSpec_Metric.IMPRESSION_CTR;
    case 6:
    case "MATCHED_REQUESTS":
      return MediationReportSpec_Metric.MATCHED_REQUESTS;
    case 7:
    case "MATCH_RATE":
      return MediationReportSpec_Metric.MATCH_RATE;
    case 8:
    case "OBSERVED_ECPM":
      return MediationReportSpec_Metric.OBSERVED_ECPM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MediationReportSpec_Metric.UNRECOGNIZED;
  }
}

export function mediationReportSpec_MetricToJSON(object: MediationReportSpec_Metric): string {
  switch (object) {
    case MediationReportSpec_Metric.METRIC_UNSPECIFIED:
      return "METRIC_UNSPECIFIED";
    case MediationReportSpec_Metric.AD_REQUESTS:
      return "AD_REQUESTS";
    case MediationReportSpec_Metric.CLICKS:
      return "CLICKS";
    case MediationReportSpec_Metric.ESTIMATED_EARNINGS:
      return "ESTIMATED_EARNINGS";
    case MediationReportSpec_Metric.IMPRESSIONS:
      return "IMPRESSIONS";
    case MediationReportSpec_Metric.IMPRESSION_CTR:
      return "IMPRESSION_CTR";
    case MediationReportSpec_Metric.MATCHED_REQUESTS:
      return "MATCHED_REQUESTS";
    case MediationReportSpec_Metric.MATCH_RATE:
      return "MATCH_RATE";
    case MediationReportSpec_Metric.OBSERVED_ECPM:
      return "OBSERVED_ECPM";
    case MediationReportSpec_Metric.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Describes which report rows to match based on their dimension values. */
export interface MediationReportSpec_DimensionFilter {
  /**
   * Matches a row if its value for the specified dimension is in one of the
   * values specified in this condition.
   */
  matchesAny?:
    | StringList
    | undefined;
  /** Applies the filter criterion to the specified dimension. */
  dimension: MediationReportSpec_Dimension;
}

/** Sorting direction to be applied on a dimension or a metric. */
export interface MediationReportSpec_SortCondition {
  /** Sort by the specified dimension. */
  dimension?:
    | MediationReportSpec_Dimension
    | undefined;
  /** Sort by the specified metric. */
  metric?:
    | MediationReportSpec_Metric
    | undefined;
  /** Sorting order of the dimension or metric. */
  order: SortOrder;
}

/** A row of the returning report. */
export interface ReportRow {
  /** Map of dimension values in a row, with keys as enum name of the dimensions. */
  dimensionValues: { [key: string]: ReportRow_DimensionValue };
  /**
   * Map of metric values in a row, with keys as enum name of the metrics. If
   * a metric being requested has no value returned, the map will not include
   * it.
   */
  metricValues: { [key: string]: ReportRow_MetricValue };
}

/** Representation of a dimension value. */
export interface ReportRow_DimensionValue {
  /**
   * Dimension value in the format specified in the report's spec Dimension
   * enum.
   */
  value: string;
  /**
   * The localized string representation of the value. If unspecified, the
   * display label should be derived from the value.
   */
  displayLabel: string;
}

/** Representation of a metric value. */
export interface ReportRow_MetricValue {
  /** Metric integer value. */
  integerValue?:
    | Long
    | undefined;
  /** Double precision (approximate) decimal values. Rates are from 0 to 1. */
  doubleValue?:
    | number
    | undefined;
  /**
   * Amount in micros. One million is equivalent to one unit. Currency value
   * is in the unit (USD, EUR or other) specified by the request.
   * For example, $6.50 whould be represented as 6500000 micros.
   */
  microsValue?: Long | undefined;
}

export interface ReportRow_DimensionValuesEntry {
  key: string;
  value: ReportRow_DimensionValue | undefined;
}

export interface ReportRow_MetricValuesEntry {
  key: string;
  value: ReportRow_MetricValue | undefined;
}

/** Warnings associated with generation of the report. */
export interface ReportWarning {
  /** Type of the warning. */
  type: ReportWarning_Type;
  /** Describes the details of the warning message, in English. */
  description: string;
}

/** Warning type. */
export enum ReportWarning_Type {
  /** TYPE_UNSPECIFIED - Default value for an unset field. Do not use. */
  TYPE_UNSPECIFIED = 0,
  /**
   * DATA_BEFORE_ACCOUNT_TIMEZONE_CHANGE - Some data in this report is aggregated based on a time zone different
   * from the requested time zone. This could happen if a local time-zone
   * report has the start time before the last time this time zone changed.
   * The description field will contain the date of the last time zone
   * change.
   */
  DATA_BEFORE_ACCOUNT_TIMEZONE_CHANGE = 1,
  /**
   * DATA_DELAYED - There is an unusual delay in processing the source data for the
   * requested date range. The report results might be less up to date than
   * usual. AdMob is aware of the issue and is actively working to resolve
   * it.
   */
  DATA_DELAYED = 2,
  /**
   * OTHER - Warnings that are exposed without a specific type. Useful when new
   * warning types are added but the API is not changed yet.
   */
  OTHER = 3,
  /**
   * REPORT_CURRENCY_NOT_ACCOUNT_CURRENCY - The currency being requested is not the account currency. The earning
   * metrics will be based on the requested currency, and thus not a good
   * estimation of the final payment anymore, due to the currency rate
   * fluctuation.
   */
  REPORT_CURRENCY_NOT_ACCOUNT_CURRENCY = 4,
  UNRECOGNIZED = -1,
}

export function reportWarning_TypeFromJSON(object: any): ReportWarning_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return ReportWarning_Type.TYPE_UNSPECIFIED;
    case 1:
    case "DATA_BEFORE_ACCOUNT_TIMEZONE_CHANGE":
      return ReportWarning_Type.DATA_BEFORE_ACCOUNT_TIMEZONE_CHANGE;
    case 2:
    case "DATA_DELAYED":
      return ReportWarning_Type.DATA_DELAYED;
    case 3:
    case "OTHER":
      return ReportWarning_Type.OTHER;
    case 4:
    case "REPORT_CURRENCY_NOT_ACCOUNT_CURRENCY":
      return ReportWarning_Type.REPORT_CURRENCY_NOT_ACCOUNT_CURRENCY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReportWarning_Type.UNRECOGNIZED;
  }
}

export function reportWarning_TypeToJSON(object: ReportWarning_Type): string {
  switch (object) {
    case ReportWarning_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case ReportWarning_Type.DATA_BEFORE_ACCOUNT_TIMEZONE_CHANGE:
      return "DATA_BEFORE_ACCOUNT_TIMEZONE_CHANGE";
    case ReportWarning_Type.DATA_DELAYED:
      return "DATA_DELAYED";
    case ReportWarning_Type.OTHER:
      return "OTHER";
    case ReportWarning_Type.REPORT_CURRENCY_NOT_ACCOUNT_CURRENCY:
      return "REPORT_CURRENCY_NOT_ACCOUNT_CURRENCY";
    case ReportWarning_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Groups data helps to treat the generated report. Always sent as a first
 * message in the stream response.
 */
export interface ReportHeader {
  /**
   * The date range for which the report is generated. This is identical to the
   * range specified in the report request.
   */
  dateRange:
    | DateRange
    | undefined;
  /**
   * Localization settings of the report. This is identical to the settings
   * in the report request.
   */
  localizationSettings:
    | LocalizationSettings
    | undefined;
  /**
   * The report time zone. The value is a time-zone ID as specified by the CLDR
   * project, for example, "America/Los_Angeles".
   */
  reportingTimeZone: string;
}

/**
 * Groups data available after report generation, for example, warnings and row
 * counts. Always sent as the last message in the stream response.
 */
export interface ReportFooter {
  /** Warnings associated with generation of the report. */
  warnings: ReportWarning[];
  /**
   * Total number of rows that matched the request.
   *
   * Warning: This count does NOT always match the number of rows in the
   * response. Do not make that assumption when processing the response.
   */
  matchingRowCount: Long;
}

/** Specification of a single date range. Both dates are inclusive. */
export interface DateRange {
  /**
   * Start date of the date range, inclusive. Must be less than or equal to the
   * end date.
   */
  startDate:
    | DateMessage
    | undefined;
  /**
   * End date of the date range, inclusive. Must be greater than or equal to the
   * start date.
   */
  endDate: DateMessage | undefined;
}

/**
 * Localization settings for reports, such as currency and language. It affects
 * how metrics are calculated.
 */
export interface LocalizationSettings {
  /**
   * Currency code of the earning related metrics, which is the 3-letter code
   * defined in ISO 4217. The daily average rate is used for the currency
   * conversion. Defaults to the account currency code if unspecified.
   */
  currencyCode: string;
  /**
   * Language used for any localized text, such as some dimension value display
   * labels. The language tag defined in the IETF BCP47. Defaults to 'en-US' if
   * unspecified.
   */
  languageCode: string;
}

/** List of string values. */
export interface StringList {
  /** The string values. */
  values: string[];
}

function createBasePublisherAccount(): PublisherAccount {
  return { name: "", publisherId: "", reportingTimeZone: "", currencyCode: "" };
}

export const PublisherAccount: MessageFns<PublisherAccount> = {
  encode(message: PublisherAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.publisherId !== "") {
      writer.uint32(18).string(message.publisherId);
    }
    if (message.reportingTimeZone !== "") {
      writer.uint32(26).string(message.reportingTimeZone);
    }
    if (message.currencyCode !== "") {
      writer.uint32(34).string(message.currencyCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublisherAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublisherAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.publisherId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reportingTimeZone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublisherAccount {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      publisherId: isSet(object.publisherId) ? globalThis.String(object.publisherId) : "",
      reportingTimeZone: isSet(object.reportingTimeZone) ? globalThis.String(object.reportingTimeZone) : "",
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
    };
  },

  toJSON(message: PublisherAccount): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.publisherId !== "") {
      obj.publisherId = message.publisherId;
    }
    if (message.reportingTimeZone !== "") {
      obj.reportingTimeZone = message.reportingTimeZone;
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    return obj;
  },

  create(base?: DeepPartial<PublisherAccount>): PublisherAccount {
    return PublisherAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublisherAccount>): PublisherAccount {
    const message = createBasePublisherAccount();
    message.name = object.name ?? "";
    message.publisherId = object.publisherId ?? "";
    message.reportingTimeZone = object.reportingTimeZone ?? "";
    message.currencyCode = object.currencyCode ?? "";
    return message;
  },
};

function createBaseNetworkReportSpec(): NetworkReportSpec {
  return {
    dateRange: undefined,
    dimensions: [],
    metrics: [],
    dimensionFilters: [],
    sortConditions: [],
    localizationSettings: undefined,
    maxReportRows: 0,
    timeZone: "",
  };
}

export const NetworkReportSpec: MessageFns<NetworkReportSpec> = {
  encode(message: NetworkReportSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dateRange !== undefined) {
      DateRange.encode(message.dateRange, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.dimensions) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.metrics) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.dimensionFilters) {
      NetworkReportSpec_DimensionFilter.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.sortConditions) {
      NetworkReportSpec_SortCondition.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.localizationSettings !== undefined) {
      LocalizationSettings.encode(message.localizationSettings, writer.uint32(50).fork()).join();
    }
    if (message.maxReportRows !== 0) {
      writer.uint32(56).int32(message.maxReportRows);
    }
    if (message.timeZone !== "") {
      writer.uint32(66).string(message.timeZone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkReportSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkReportSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dateRange = DateRange.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag === 16) {
            message.dimensions.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dimensions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.metrics.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.metrics.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dimensionFilters.push(NetworkReportSpec_DimensionFilter.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sortConditions.push(NetworkReportSpec_SortCondition.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.localizationSettings = LocalizationSettings.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.maxReportRows = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.timeZone = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkReportSpec {
    return {
      dateRange: isSet(object.dateRange) ? DateRange.fromJSON(object.dateRange) : undefined,
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => networkReportSpec_DimensionFromJSON(e))
        : [],
      metrics: globalThis.Array.isArray(object?.metrics)
        ? object.metrics.map((e: any) => networkReportSpec_MetricFromJSON(e))
        : [],
      dimensionFilters: globalThis.Array.isArray(object?.dimensionFilters)
        ? object.dimensionFilters.map((e: any) => NetworkReportSpec_DimensionFilter.fromJSON(e))
        : [],
      sortConditions: globalThis.Array.isArray(object?.sortConditions)
        ? object.sortConditions.map((e: any) => NetworkReportSpec_SortCondition.fromJSON(e))
        : [],
      localizationSettings: isSet(object.localizationSettings)
        ? LocalizationSettings.fromJSON(object.localizationSettings)
        : undefined,
      maxReportRows: isSet(object.maxReportRows) ? globalThis.Number(object.maxReportRows) : 0,
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
    };
  },

  toJSON(message: NetworkReportSpec): unknown {
    const obj: any = {};
    if (message.dateRange !== undefined) {
      obj.dateRange = DateRange.toJSON(message.dateRange);
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => networkReportSpec_DimensionToJSON(e));
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => networkReportSpec_MetricToJSON(e));
    }
    if (message.dimensionFilters?.length) {
      obj.dimensionFilters = message.dimensionFilters.map((e) => NetworkReportSpec_DimensionFilter.toJSON(e));
    }
    if (message.sortConditions?.length) {
      obj.sortConditions = message.sortConditions.map((e) => NetworkReportSpec_SortCondition.toJSON(e));
    }
    if (message.localizationSettings !== undefined) {
      obj.localizationSettings = LocalizationSettings.toJSON(message.localizationSettings);
    }
    if (message.maxReportRows !== 0) {
      obj.maxReportRows = Math.round(message.maxReportRows);
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkReportSpec>): NetworkReportSpec {
    return NetworkReportSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkReportSpec>): NetworkReportSpec {
    const message = createBaseNetworkReportSpec();
    message.dateRange = (object.dateRange !== undefined && object.dateRange !== null)
      ? DateRange.fromPartial(object.dateRange)
      : undefined;
    message.dimensions = object.dimensions?.map((e) => e) || [];
    message.metrics = object.metrics?.map((e) => e) || [];
    message.dimensionFilters = object.dimensionFilters?.map((e) => NetworkReportSpec_DimensionFilter.fromPartial(e)) ||
      [];
    message.sortConditions = object.sortConditions?.map((e) => NetworkReportSpec_SortCondition.fromPartial(e)) || [];
    message.localizationSettings = (object.localizationSettings !== undefined && object.localizationSettings !== null)
      ? LocalizationSettings.fromPartial(object.localizationSettings)
      : undefined;
    message.maxReportRows = object.maxReportRows ?? 0;
    message.timeZone = object.timeZone ?? "";
    return message;
  },
};

function createBaseNetworkReportSpec_DimensionFilter(): NetworkReportSpec_DimensionFilter {
  return { matchesAny: undefined, dimension: 0 };
}

export const NetworkReportSpec_DimensionFilter: MessageFns<NetworkReportSpec_DimensionFilter> = {
  encode(message: NetworkReportSpec_DimensionFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchesAny !== undefined) {
      StringList.encode(message.matchesAny, writer.uint32(18).fork()).join();
    }
    if (message.dimension !== 0) {
      writer.uint32(8).int32(message.dimension);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkReportSpec_DimensionFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkReportSpec_DimensionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.matchesAny = StringList.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dimension = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkReportSpec_DimensionFilter {
    return {
      matchesAny: isSet(object.matchesAny) ? StringList.fromJSON(object.matchesAny) : undefined,
      dimension: isSet(object.dimension) ? networkReportSpec_DimensionFromJSON(object.dimension) : 0,
    };
  },

  toJSON(message: NetworkReportSpec_DimensionFilter): unknown {
    const obj: any = {};
    if (message.matchesAny !== undefined) {
      obj.matchesAny = StringList.toJSON(message.matchesAny);
    }
    if (message.dimension !== 0) {
      obj.dimension = networkReportSpec_DimensionToJSON(message.dimension);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkReportSpec_DimensionFilter>): NetworkReportSpec_DimensionFilter {
    return NetworkReportSpec_DimensionFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkReportSpec_DimensionFilter>): NetworkReportSpec_DimensionFilter {
    const message = createBaseNetworkReportSpec_DimensionFilter();
    message.matchesAny = (object.matchesAny !== undefined && object.matchesAny !== null)
      ? StringList.fromPartial(object.matchesAny)
      : undefined;
    message.dimension = object.dimension ?? 0;
    return message;
  },
};

function createBaseNetworkReportSpec_SortCondition(): NetworkReportSpec_SortCondition {
  return { dimension: undefined, metric: undefined, order: 0 };
}

export const NetworkReportSpec_SortCondition: MessageFns<NetworkReportSpec_SortCondition> = {
  encode(message: NetworkReportSpec_SortCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dimension !== undefined) {
      writer.uint32(8).int32(message.dimension);
    }
    if (message.metric !== undefined) {
      writer.uint32(16).int32(message.metric);
    }
    if (message.order !== 0) {
      writer.uint32(24).int32(message.order);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkReportSpec_SortCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkReportSpec_SortCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dimension = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.metric = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.order = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkReportSpec_SortCondition {
    return {
      dimension: isSet(object.dimension) ? networkReportSpec_DimensionFromJSON(object.dimension) : undefined,
      metric: isSet(object.metric) ? networkReportSpec_MetricFromJSON(object.metric) : undefined,
      order: isSet(object.order) ? sortOrderFromJSON(object.order) : 0,
    };
  },

  toJSON(message: NetworkReportSpec_SortCondition): unknown {
    const obj: any = {};
    if (message.dimension !== undefined) {
      obj.dimension = networkReportSpec_DimensionToJSON(message.dimension);
    }
    if (message.metric !== undefined) {
      obj.metric = networkReportSpec_MetricToJSON(message.metric);
    }
    if (message.order !== 0) {
      obj.order = sortOrderToJSON(message.order);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkReportSpec_SortCondition>): NetworkReportSpec_SortCondition {
    return NetworkReportSpec_SortCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkReportSpec_SortCondition>): NetworkReportSpec_SortCondition {
    const message = createBaseNetworkReportSpec_SortCondition();
    message.dimension = object.dimension ?? undefined;
    message.metric = object.metric ?? undefined;
    message.order = object.order ?? 0;
    return message;
  },
};

function createBaseMediationReportSpec(): MediationReportSpec {
  return {
    dateRange: undefined,
    dimensions: [],
    metrics: [],
    dimensionFilters: [],
    sortConditions: [],
    localizationSettings: undefined,
    maxReportRows: 0,
    timeZone: "",
  };
}

export const MediationReportSpec: MessageFns<MediationReportSpec> = {
  encode(message: MediationReportSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dateRange !== undefined) {
      DateRange.encode(message.dateRange, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.dimensions) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.metrics) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.dimensionFilters) {
      MediationReportSpec_DimensionFilter.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.sortConditions) {
      MediationReportSpec_SortCondition.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.localizationSettings !== undefined) {
      LocalizationSettings.encode(message.localizationSettings, writer.uint32(50).fork()).join();
    }
    if (message.maxReportRows !== 0) {
      writer.uint32(56).int32(message.maxReportRows);
    }
    if (message.timeZone !== "") {
      writer.uint32(66).string(message.timeZone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediationReportSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediationReportSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dateRange = DateRange.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag === 16) {
            message.dimensions.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dimensions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.metrics.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.metrics.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dimensionFilters.push(MediationReportSpec_DimensionFilter.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sortConditions.push(MediationReportSpec_SortCondition.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.localizationSettings = LocalizationSettings.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.maxReportRows = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.timeZone = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediationReportSpec {
    return {
      dateRange: isSet(object.dateRange) ? DateRange.fromJSON(object.dateRange) : undefined,
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => mediationReportSpec_DimensionFromJSON(e))
        : [],
      metrics: globalThis.Array.isArray(object?.metrics)
        ? object.metrics.map((e: any) => mediationReportSpec_MetricFromJSON(e))
        : [],
      dimensionFilters: globalThis.Array.isArray(object?.dimensionFilters)
        ? object.dimensionFilters.map((e: any) => MediationReportSpec_DimensionFilter.fromJSON(e))
        : [],
      sortConditions: globalThis.Array.isArray(object?.sortConditions)
        ? object.sortConditions.map((e: any) => MediationReportSpec_SortCondition.fromJSON(e))
        : [],
      localizationSettings: isSet(object.localizationSettings)
        ? LocalizationSettings.fromJSON(object.localizationSettings)
        : undefined,
      maxReportRows: isSet(object.maxReportRows) ? globalThis.Number(object.maxReportRows) : 0,
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
    };
  },

  toJSON(message: MediationReportSpec): unknown {
    const obj: any = {};
    if (message.dateRange !== undefined) {
      obj.dateRange = DateRange.toJSON(message.dateRange);
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => mediationReportSpec_DimensionToJSON(e));
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => mediationReportSpec_MetricToJSON(e));
    }
    if (message.dimensionFilters?.length) {
      obj.dimensionFilters = message.dimensionFilters.map((e) => MediationReportSpec_DimensionFilter.toJSON(e));
    }
    if (message.sortConditions?.length) {
      obj.sortConditions = message.sortConditions.map((e) => MediationReportSpec_SortCondition.toJSON(e));
    }
    if (message.localizationSettings !== undefined) {
      obj.localizationSettings = LocalizationSettings.toJSON(message.localizationSettings);
    }
    if (message.maxReportRows !== 0) {
      obj.maxReportRows = Math.round(message.maxReportRows);
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    return obj;
  },

  create(base?: DeepPartial<MediationReportSpec>): MediationReportSpec {
    return MediationReportSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MediationReportSpec>): MediationReportSpec {
    const message = createBaseMediationReportSpec();
    message.dateRange = (object.dateRange !== undefined && object.dateRange !== null)
      ? DateRange.fromPartial(object.dateRange)
      : undefined;
    message.dimensions = object.dimensions?.map((e) => e) || [];
    message.metrics = object.metrics?.map((e) => e) || [];
    message.dimensionFilters =
      object.dimensionFilters?.map((e) => MediationReportSpec_DimensionFilter.fromPartial(e)) || [];
    message.sortConditions = object.sortConditions?.map((e) => MediationReportSpec_SortCondition.fromPartial(e)) || [];
    message.localizationSettings = (object.localizationSettings !== undefined && object.localizationSettings !== null)
      ? LocalizationSettings.fromPartial(object.localizationSettings)
      : undefined;
    message.maxReportRows = object.maxReportRows ?? 0;
    message.timeZone = object.timeZone ?? "";
    return message;
  },
};

function createBaseMediationReportSpec_DimensionFilter(): MediationReportSpec_DimensionFilter {
  return { matchesAny: undefined, dimension: 0 };
}

export const MediationReportSpec_DimensionFilter: MessageFns<MediationReportSpec_DimensionFilter> = {
  encode(message: MediationReportSpec_DimensionFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchesAny !== undefined) {
      StringList.encode(message.matchesAny, writer.uint32(18).fork()).join();
    }
    if (message.dimension !== 0) {
      writer.uint32(8).int32(message.dimension);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediationReportSpec_DimensionFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediationReportSpec_DimensionFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.matchesAny = StringList.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dimension = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediationReportSpec_DimensionFilter {
    return {
      matchesAny: isSet(object.matchesAny) ? StringList.fromJSON(object.matchesAny) : undefined,
      dimension: isSet(object.dimension) ? mediationReportSpec_DimensionFromJSON(object.dimension) : 0,
    };
  },

  toJSON(message: MediationReportSpec_DimensionFilter): unknown {
    const obj: any = {};
    if (message.matchesAny !== undefined) {
      obj.matchesAny = StringList.toJSON(message.matchesAny);
    }
    if (message.dimension !== 0) {
      obj.dimension = mediationReportSpec_DimensionToJSON(message.dimension);
    }
    return obj;
  },

  create(base?: DeepPartial<MediationReportSpec_DimensionFilter>): MediationReportSpec_DimensionFilter {
    return MediationReportSpec_DimensionFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MediationReportSpec_DimensionFilter>): MediationReportSpec_DimensionFilter {
    const message = createBaseMediationReportSpec_DimensionFilter();
    message.matchesAny = (object.matchesAny !== undefined && object.matchesAny !== null)
      ? StringList.fromPartial(object.matchesAny)
      : undefined;
    message.dimension = object.dimension ?? 0;
    return message;
  },
};

function createBaseMediationReportSpec_SortCondition(): MediationReportSpec_SortCondition {
  return { dimension: undefined, metric: undefined, order: 0 };
}

export const MediationReportSpec_SortCondition: MessageFns<MediationReportSpec_SortCondition> = {
  encode(message: MediationReportSpec_SortCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dimension !== undefined) {
      writer.uint32(8).int32(message.dimension);
    }
    if (message.metric !== undefined) {
      writer.uint32(16).int32(message.metric);
    }
    if (message.order !== 0) {
      writer.uint32(24).int32(message.order);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediationReportSpec_SortCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediationReportSpec_SortCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dimension = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.metric = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.order = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediationReportSpec_SortCondition {
    return {
      dimension: isSet(object.dimension) ? mediationReportSpec_DimensionFromJSON(object.dimension) : undefined,
      metric: isSet(object.metric) ? mediationReportSpec_MetricFromJSON(object.metric) : undefined,
      order: isSet(object.order) ? sortOrderFromJSON(object.order) : 0,
    };
  },

  toJSON(message: MediationReportSpec_SortCondition): unknown {
    const obj: any = {};
    if (message.dimension !== undefined) {
      obj.dimension = mediationReportSpec_DimensionToJSON(message.dimension);
    }
    if (message.metric !== undefined) {
      obj.metric = mediationReportSpec_MetricToJSON(message.metric);
    }
    if (message.order !== 0) {
      obj.order = sortOrderToJSON(message.order);
    }
    return obj;
  },

  create(base?: DeepPartial<MediationReportSpec_SortCondition>): MediationReportSpec_SortCondition {
    return MediationReportSpec_SortCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MediationReportSpec_SortCondition>): MediationReportSpec_SortCondition {
    const message = createBaseMediationReportSpec_SortCondition();
    message.dimension = object.dimension ?? undefined;
    message.metric = object.metric ?? undefined;
    message.order = object.order ?? 0;
    return message;
  },
};

function createBaseReportRow(): ReportRow {
  return { dimensionValues: {}, metricValues: {} };
}

export const ReportRow: MessageFns<ReportRow> = {
  encode(message: ReportRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.dimensionValues).forEach(([key, value]) => {
      ReportRow_DimensionValuesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.metricValues).forEach(([key, value]) => {
      ReportRow_MetricValuesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ReportRow_DimensionValuesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.dimensionValues[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = ReportRow_MetricValuesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metricValues[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportRow {
    return {
      dimensionValues: isObject(object.dimensionValues)
        ? Object.entries(object.dimensionValues).reduce<{ [key: string]: ReportRow_DimensionValue }>(
          (acc, [key, value]) => {
            acc[key] = ReportRow_DimensionValue.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      metricValues: isObject(object.metricValues)
        ? Object.entries(object.metricValues).reduce<{ [key: string]: ReportRow_MetricValue }>((acc, [key, value]) => {
          acc[key] = ReportRow_MetricValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ReportRow): unknown {
    const obj: any = {};
    if (message.dimensionValues) {
      const entries = Object.entries(message.dimensionValues);
      if (entries.length > 0) {
        obj.dimensionValues = {};
        entries.forEach(([k, v]) => {
          obj.dimensionValues[k] = ReportRow_DimensionValue.toJSON(v);
        });
      }
    }
    if (message.metricValues) {
      const entries = Object.entries(message.metricValues);
      if (entries.length > 0) {
        obj.metricValues = {};
        entries.forEach(([k, v]) => {
          obj.metricValues[k] = ReportRow_MetricValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ReportRow>): ReportRow {
    return ReportRow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportRow>): ReportRow {
    const message = createBaseReportRow();
    message.dimensionValues = Object.entries(object.dimensionValues ?? {}).reduce<
      { [key: string]: ReportRow_DimensionValue }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = ReportRow_DimensionValue.fromPartial(value);
      }
      return acc;
    }, {});
    message.metricValues = Object.entries(object.metricValues ?? {}).reduce<{ [key: string]: ReportRow_MetricValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ReportRow_MetricValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseReportRow_DimensionValue(): ReportRow_DimensionValue {
  return { value: "", displayLabel: "" };
}

export const ReportRow_DimensionValue: MessageFns<ReportRow_DimensionValue> = {
  encode(message: ReportRow_DimensionValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.displayLabel !== "") {
      writer.uint32(18).string(message.displayLabel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportRow_DimensionValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportRow_DimensionValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayLabel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportRow_DimensionValue {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      displayLabel: isSet(object.displayLabel) ? globalThis.String(object.displayLabel) : "",
    };
  },

  toJSON(message: ReportRow_DimensionValue): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.displayLabel !== "") {
      obj.displayLabel = message.displayLabel;
    }
    return obj;
  },

  create(base?: DeepPartial<ReportRow_DimensionValue>): ReportRow_DimensionValue {
    return ReportRow_DimensionValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportRow_DimensionValue>): ReportRow_DimensionValue {
    const message = createBaseReportRow_DimensionValue();
    message.value = object.value ?? "";
    message.displayLabel = object.displayLabel ?? "";
    return message;
  },
};

function createBaseReportRow_MetricValue(): ReportRow_MetricValue {
  return { integerValue: undefined, doubleValue: undefined, microsValue: undefined };
}

export const ReportRow_MetricValue: MessageFns<ReportRow_MetricValue> = {
  encode(message: ReportRow_MetricValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.integerValue !== undefined) {
      writer.uint32(8).int64(message.integerValue.toString());
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(17).double(message.doubleValue);
    }
    if (message.microsValue !== undefined) {
      writer.uint32(24).int64(message.microsValue.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportRow_MetricValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportRow_MetricValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.integerValue = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.microsValue = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportRow_MetricValue {
    return {
      integerValue: isSet(object.integerValue) ? Long.fromValue(object.integerValue) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
      microsValue: isSet(object.microsValue) ? Long.fromValue(object.microsValue) : undefined,
    };
  },

  toJSON(message: ReportRow_MetricValue): unknown {
    const obj: any = {};
    if (message.integerValue !== undefined) {
      obj.integerValue = (message.integerValue || Long.ZERO).toString();
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    if (message.microsValue !== undefined) {
      obj.microsValue = (message.microsValue || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ReportRow_MetricValue>): ReportRow_MetricValue {
    return ReportRow_MetricValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportRow_MetricValue>): ReportRow_MetricValue {
    const message = createBaseReportRow_MetricValue();
    message.integerValue = (object.integerValue !== undefined && object.integerValue !== null)
      ? Long.fromValue(object.integerValue)
      : undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    message.microsValue = (object.microsValue !== undefined && object.microsValue !== null)
      ? Long.fromValue(object.microsValue)
      : undefined;
    return message;
  },
};

function createBaseReportRow_DimensionValuesEntry(): ReportRow_DimensionValuesEntry {
  return { key: "", value: undefined };
}

export const ReportRow_DimensionValuesEntry: MessageFns<ReportRow_DimensionValuesEntry> = {
  encode(message: ReportRow_DimensionValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ReportRow_DimensionValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportRow_DimensionValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportRow_DimensionValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ReportRow_DimensionValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportRow_DimensionValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ReportRow_DimensionValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ReportRow_DimensionValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ReportRow_DimensionValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ReportRow_DimensionValuesEntry>): ReportRow_DimensionValuesEntry {
    return ReportRow_DimensionValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportRow_DimensionValuesEntry>): ReportRow_DimensionValuesEntry {
    const message = createBaseReportRow_DimensionValuesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ReportRow_DimensionValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseReportRow_MetricValuesEntry(): ReportRow_MetricValuesEntry {
  return { key: "", value: undefined };
}

export const ReportRow_MetricValuesEntry: MessageFns<ReportRow_MetricValuesEntry> = {
  encode(message: ReportRow_MetricValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ReportRow_MetricValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportRow_MetricValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportRow_MetricValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ReportRow_MetricValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportRow_MetricValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ReportRow_MetricValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ReportRow_MetricValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ReportRow_MetricValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ReportRow_MetricValuesEntry>): ReportRow_MetricValuesEntry {
    return ReportRow_MetricValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportRow_MetricValuesEntry>): ReportRow_MetricValuesEntry {
    const message = createBaseReportRow_MetricValuesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ReportRow_MetricValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseReportWarning(): ReportWarning {
  return { type: 0, description: "" };
}

export const ReportWarning: MessageFns<ReportWarning> = {
  encode(message: ReportWarning, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportWarning {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportWarning();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportWarning {
    return {
      type: isSet(object.type) ? reportWarning_TypeFromJSON(object.type) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ReportWarning): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = reportWarning_TypeToJSON(message.type);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<ReportWarning>): ReportWarning {
    return ReportWarning.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportWarning>): ReportWarning {
    const message = createBaseReportWarning();
    message.type = object.type ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseReportHeader(): ReportHeader {
  return { dateRange: undefined, localizationSettings: undefined, reportingTimeZone: "" };
}

export const ReportHeader: MessageFns<ReportHeader> = {
  encode(message: ReportHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dateRange !== undefined) {
      DateRange.encode(message.dateRange, writer.uint32(10).fork()).join();
    }
    if (message.localizationSettings !== undefined) {
      LocalizationSettings.encode(message.localizationSettings, writer.uint32(18).fork()).join();
    }
    if (message.reportingTimeZone !== "") {
      writer.uint32(26).string(message.reportingTimeZone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dateRange = DateRange.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.localizationSettings = LocalizationSettings.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reportingTimeZone = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportHeader {
    return {
      dateRange: isSet(object.dateRange) ? DateRange.fromJSON(object.dateRange) : undefined,
      localizationSettings: isSet(object.localizationSettings)
        ? LocalizationSettings.fromJSON(object.localizationSettings)
        : undefined,
      reportingTimeZone: isSet(object.reportingTimeZone) ? globalThis.String(object.reportingTimeZone) : "",
    };
  },

  toJSON(message: ReportHeader): unknown {
    const obj: any = {};
    if (message.dateRange !== undefined) {
      obj.dateRange = DateRange.toJSON(message.dateRange);
    }
    if (message.localizationSettings !== undefined) {
      obj.localizationSettings = LocalizationSettings.toJSON(message.localizationSettings);
    }
    if (message.reportingTimeZone !== "") {
      obj.reportingTimeZone = message.reportingTimeZone;
    }
    return obj;
  },

  create(base?: DeepPartial<ReportHeader>): ReportHeader {
    return ReportHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportHeader>): ReportHeader {
    const message = createBaseReportHeader();
    message.dateRange = (object.dateRange !== undefined && object.dateRange !== null)
      ? DateRange.fromPartial(object.dateRange)
      : undefined;
    message.localizationSettings = (object.localizationSettings !== undefined && object.localizationSettings !== null)
      ? LocalizationSettings.fromPartial(object.localizationSettings)
      : undefined;
    message.reportingTimeZone = object.reportingTimeZone ?? "";
    return message;
  },
};

function createBaseReportFooter(): ReportFooter {
  return { warnings: [], matchingRowCount: Long.ZERO };
}

export const ReportFooter: MessageFns<ReportFooter> = {
  encode(message: ReportFooter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.warnings) {
      ReportWarning.encode(v!, writer.uint32(10).fork()).join();
    }
    if (!message.matchingRowCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.matchingRowCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportFooter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportFooter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.warnings.push(ReportWarning.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchingRowCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportFooter {
    return {
      warnings: globalThis.Array.isArray(object?.warnings)
        ? object.warnings.map((e: any) => ReportWarning.fromJSON(e))
        : [],
      matchingRowCount: isSet(object.matchingRowCount) ? Long.fromValue(object.matchingRowCount) : Long.ZERO,
    };
  },

  toJSON(message: ReportFooter): unknown {
    const obj: any = {};
    if (message.warnings?.length) {
      obj.warnings = message.warnings.map((e) => ReportWarning.toJSON(e));
    }
    if (!message.matchingRowCount.equals(Long.ZERO)) {
      obj.matchingRowCount = (message.matchingRowCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ReportFooter>): ReportFooter {
    return ReportFooter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportFooter>): ReportFooter {
    const message = createBaseReportFooter();
    message.warnings = object.warnings?.map((e) => ReportWarning.fromPartial(e)) || [];
    message.matchingRowCount = (object.matchingRowCount !== undefined && object.matchingRowCount !== null)
      ? Long.fromValue(object.matchingRowCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseDateRange(): DateRange {
  return { startDate: undefined, endDate: undefined };
}

export const DateRange: MessageFns<DateRange> = {
  encode(message: DateRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startDate !== undefined) {
      DateMessage.encode(message.startDate, writer.uint32(10).fork()).join();
    }
    if (message.endDate !== undefined) {
      DateMessage.encode(message.endDate, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endDate = DateMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateRange {
    return {
      startDate: isSet(object.startDate) ? DateMessage.fromJSON(object.startDate) : undefined,
      endDate: isSet(object.endDate) ? DateMessage.fromJSON(object.endDate) : undefined,
    };
  },

  toJSON(message: DateRange): unknown {
    const obj: any = {};
    if (message.startDate !== undefined) {
      obj.startDate = DateMessage.toJSON(message.startDate);
    }
    if (message.endDate !== undefined) {
      obj.endDate = DateMessage.toJSON(message.endDate);
    }
    return obj;
  },

  create(base?: DeepPartial<DateRange>): DateRange {
    return DateRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DateRange>): DateRange {
    const message = createBaseDateRange();
    message.startDate = (object.startDate !== undefined && object.startDate !== null)
      ? DateMessage.fromPartial(object.startDate)
      : undefined;
    message.endDate = (object.endDate !== undefined && object.endDate !== null)
      ? DateMessage.fromPartial(object.endDate)
      : undefined;
    return message;
  },
};

function createBaseLocalizationSettings(): LocalizationSettings {
  return { currencyCode: "", languageCode: "" };
}

export const LocalizationSettings: MessageFns<LocalizationSettings> = {
  encode(message: LocalizationSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currencyCode !== "") {
      writer.uint32(10).string(message.currencyCode);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalizationSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalizationSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalizationSettings {
    return {
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: LocalizationSettings): unknown {
    const obj: any = {};
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<LocalizationSettings>): LocalizationSettings {
    return LocalizationSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocalizationSettings>): LocalizationSettings {
    const message = createBaseLocalizationSettings();
    message.currencyCode = object.currencyCode ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseStringList(): StringList {
  return { values: [] };
}

export const StringList: MessageFns<StringList> = {
  encode(message: StringList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringList {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: StringList): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<StringList>): StringList {
    return StringList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringList>): StringList {
    const message = createBaseStringList();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
