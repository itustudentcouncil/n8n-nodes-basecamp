// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/shopping/css/v1/css_product_inputs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../protobuf/empty.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { CustomAttribute } from "../../type/types.js";
import { Attributes } from "./css_product_common.js";

export const protobufPackage = "google.shopping.css.v1";

/**
 * This resource represents input data you submit for a CSS Product, not
 * the processed CSS Product that you see in CSS Center, in Shopping Ads, or
 * across Google surfaces.
 */
export interface CssProductInput {
  /**
   * The name of the CSS Product input.
   * Format:
   * `accounts/{account}/cssProductInputs/{css_product_input}`
   */
  name: string;
  /**
   * Output only. The name of the processed CSS Product.
   * Format:
   * `accounts/{account}/cssProducts/{css_product}`
   * "
   */
  finalName: string;
  /**
   * Required. Your unique identifier for the CSS Product. This is the same for
   * the CSS Product input and processed CSS Product. We only allow ids with
   * alphanumerics, underscores and dashes. See the [products feed
   * specification](https://support.google.com/merchants/answer/188494#id) for
   * details.
   */
  rawProvidedId: string;
  /**
   * Required. The two-letter [ISO
   * 639-1](http://en.wikipedia.org/wiki/ISO_639-1) language code for the CSS
   * Product.
   */
  contentLanguage: string;
  /**
   * Required. The [feed
   * label](https://developers.google.com/shopping-content/guides/products/feed-labels)
   * for the CSS Product.
   * Feed Label is synonymous to "target country" and hence should always be a
   * valid region code. For example: 'DE' for Germany, 'FR' for France.
   */
  feedLabel: string;
  /**
   * Represents the existing version (freshness) of the CSS Product, which
   * can be used to preserve the right order when multiple updates are done at
   * the same time.
   *
   * This field must not be set to the future time.
   *
   * If set, the update is prevented if a newer version of the item already
   * exists in our system (that is the last update time of the existing
   * CSS products is later than the freshness time set in the update). If
   * the update happens, the last update time is then set to this freshness
   * time.
   *
   * If not set, the update will not be prevented and the last update time will
   * default to when this request was received by the CSS API.
   *
   * If the operation is prevented, the aborted exception will be
   * thrown.
   */
  freshnessTime:
    | Date
    | undefined;
  /** A list of CSS Product attributes. */
  attributes:
    | Attributes
    | undefined;
  /**
   * A list of custom (CSS-provided) attributes. It can also be used for
   * submitting any attribute of the feed specification in its generic
   * form (for example:
   * `{ "name": "size type", "value": "regular" }`).
   * This is useful for submitting attributes not explicitly exposed by the
   * API, such as additional attributes used for Buy on Google.
   */
  customAttributes: CustomAttribute[];
}

/** Request message for the InsertCssProductInput method. */
export interface InsertCssProductInputRequest {
  /**
   * Required. The account where this CSS Product will be inserted.
   * Format: accounts/{account}
   */
  parent: string;
  /** Required. The CSS Product Input to insert. */
  cssProductInput:
    | CssProductInput
    | undefined;
  /**
   * Required. The primary or supplemental feed id. If CSS Product already
   * exists and feed id provided is different, then the CSS Product will be
   * moved to a new feed. Note: For now, CSSs do not need to provide feed ids as
   * we create feeds on the fly. We do not have supplemental feed support for
   * CSS Products yet.
   */
  feedId: Long;
}

/** Request message for the DeleteCssProductInput method. */
export interface DeleteCssProductInputRequest {
  /**
   * Required. The name of the CSS product input resource to delete.
   * Format: accounts/{account}/cssProductInputs/{css_product_input}
   */
  name: string;
  /**
   * The Content API Supplemental Feed ID.
   * The field must not be set if the action applies to a primary feed.
   * If the field is set, then product action applies to a supplemental feed
   * instead of primary Content API feed.
   */
  supplementalFeedId?: Long | undefined;
}

function createBaseCssProductInput(): CssProductInput {
  return {
    name: "",
    finalName: "",
    rawProvidedId: "",
    contentLanguage: "",
    feedLabel: "",
    freshnessTime: undefined,
    attributes: undefined,
    customAttributes: [],
  };
}

export const CssProductInput: MessageFns<CssProductInput> = {
  encode(message: CssProductInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.finalName !== "") {
      writer.uint32(18).string(message.finalName);
    }
    if (message.rawProvidedId !== "") {
      writer.uint32(26).string(message.rawProvidedId);
    }
    if (message.contentLanguage !== "") {
      writer.uint32(34).string(message.contentLanguage);
    }
    if (message.feedLabel !== "") {
      writer.uint32(42).string(message.feedLabel);
    }
    if (message.freshnessTime !== undefined) {
      Timestamp.encode(toTimestamp(message.freshnessTime), writer.uint32(50).fork()).join();
    }
    if (message.attributes !== undefined) {
      Attributes.encode(message.attributes, writer.uint32(58).fork()).join();
    }
    for (const v of message.customAttributes) {
      CustomAttribute.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CssProductInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCssProductInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.finalName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rawProvidedId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentLanguage = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feedLabel = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.freshnessTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.attributes = Attributes.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.customAttributes.push(CustomAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CssProductInput {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      finalName: isSet(object.finalName) ? globalThis.String(object.finalName) : "",
      rawProvidedId: isSet(object.rawProvidedId) ? globalThis.String(object.rawProvidedId) : "",
      contentLanguage: isSet(object.contentLanguage) ? globalThis.String(object.contentLanguage) : "",
      feedLabel: isSet(object.feedLabel) ? globalThis.String(object.feedLabel) : "",
      freshnessTime: isSet(object.freshnessTime) ? fromJsonTimestamp(object.freshnessTime) : undefined,
      attributes: isSet(object.attributes) ? Attributes.fromJSON(object.attributes) : undefined,
      customAttributes: globalThis.Array.isArray(object?.customAttributes)
        ? object.customAttributes.map((e: any) => CustomAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CssProductInput): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.finalName !== "") {
      obj.finalName = message.finalName;
    }
    if (message.rawProvidedId !== "") {
      obj.rawProvidedId = message.rawProvidedId;
    }
    if (message.contentLanguage !== "") {
      obj.contentLanguage = message.contentLanguage;
    }
    if (message.feedLabel !== "") {
      obj.feedLabel = message.feedLabel;
    }
    if (message.freshnessTime !== undefined) {
      obj.freshnessTime = message.freshnessTime.toISOString();
    }
    if (message.attributes !== undefined) {
      obj.attributes = Attributes.toJSON(message.attributes);
    }
    if (message.customAttributes?.length) {
      obj.customAttributes = message.customAttributes.map((e) => CustomAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CssProductInput>): CssProductInput {
    return CssProductInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CssProductInput>): CssProductInput {
    const message = createBaseCssProductInput();
    message.name = object.name ?? "";
    message.finalName = object.finalName ?? "";
    message.rawProvidedId = object.rawProvidedId ?? "";
    message.contentLanguage = object.contentLanguage ?? "";
    message.feedLabel = object.feedLabel ?? "";
    message.freshnessTime = object.freshnessTime ?? undefined;
    message.attributes = (object.attributes !== undefined && object.attributes !== null)
      ? Attributes.fromPartial(object.attributes)
      : undefined;
    message.customAttributes = object.customAttributes?.map((e) => CustomAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInsertCssProductInputRequest(): InsertCssProductInputRequest {
  return { parent: "", cssProductInput: undefined, feedId: Long.ZERO };
}

export const InsertCssProductInputRequest: MessageFns<InsertCssProductInputRequest> = {
  encode(message: InsertCssProductInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.cssProductInput !== undefined) {
      CssProductInput.encode(message.cssProductInput, writer.uint32(18).fork()).join();
    }
    if (!message.feedId.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.feedId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertCssProductInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertCssProductInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cssProductInput = CssProductInput.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.feedId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertCssProductInputRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      cssProductInput: isSet(object.cssProductInput) ? CssProductInput.fromJSON(object.cssProductInput) : undefined,
      feedId: isSet(object.feedId) ? Long.fromValue(object.feedId) : Long.ZERO,
    };
  },

  toJSON(message: InsertCssProductInputRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.cssProductInput !== undefined) {
      obj.cssProductInput = CssProductInput.toJSON(message.cssProductInput);
    }
    if (!message.feedId.equals(Long.ZERO)) {
      obj.feedId = (message.feedId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<InsertCssProductInputRequest>): InsertCssProductInputRequest {
    return InsertCssProductInputRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsertCssProductInputRequest>): InsertCssProductInputRequest {
    const message = createBaseInsertCssProductInputRequest();
    message.parent = object.parent ?? "";
    message.cssProductInput = (object.cssProductInput !== undefined && object.cssProductInput !== null)
      ? CssProductInput.fromPartial(object.cssProductInput)
      : undefined;
    message.feedId = (object.feedId !== undefined && object.feedId !== null)
      ? Long.fromValue(object.feedId)
      : Long.ZERO;
    return message;
  },
};

function createBaseDeleteCssProductInputRequest(): DeleteCssProductInputRequest {
  return { name: "", supplementalFeedId: undefined };
}

export const DeleteCssProductInputRequest: MessageFns<DeleteCssProductInputRequest> = {
  encode(message: DeleteCssProductInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.supplementalFeedId !== undefined) {
      writer.uint32(16).int64(message.supplementalFeedId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCssProductInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCssProductInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.supplementalFeedId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCssProductInputRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      supplementalFeedId: isSet(object.supplementalFeedId) ? Long.fromValue(object.supplementalFeedId) : undefined,
    };
  },

  toJSON(message: DeleteCssProductInputRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.supplementalFeedId !== undefined) {
      obj.supplementalFeedId = (message.supplementalFeedId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCssProductInputRequest>): DeleteCssProductInputRequest {
    return DeleteCssProductInputRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCssProductInputRequest>): DeleteCssProductInputRequest {
    const message = createBaseDeleteCssProductInputRequest();
    message.name = object.name ?? "";
    message.supplementalFeedId = (object.supplementalFeedId !== undefined && object.supplementalFeedId !== null)
      ? Long.fromValue(object.supplementalFeedId)
      : undefined;
    return message;
  },
};

/**
 * Service to use CssProductInput resource.
 * This service helps to insert/update/delete CSS Products.
 */
export type CssProductInputsServiceDefinition = typeof CssProductInputsServiceDefinition;
export const CssProductInputsServiceDefinition = {
  name: "CssProductInputsService",
  fullName: "google.shopping.css.v1.CssProductInputsService",
  methods: {
    /**
     * Uploads a CssProductInput to your CSS Center account. If an
     * input with the same contentLanguage, identity, feedLabel and feedId already
     * exists, this method replaces that entry.
     *
     * After inserting, updating, or deleting a CSS Product input, it may
     * take several minutes before the processed CSS Product can be retrieved.
     */
    insertCssProductInput: {
      name: "InsertCssProductInput",
      requestType: InsertCssProductInputRequest,
      requestStream: false,
      responseType: CssProductInput,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              68,
              58,
              17,
              99,
              115,
              115,
              95,
              112,
              114,
              111,
              100,
              117,
              99,
              116,
              95,
              105,
              110,
              112,
              117,
              116,
              34,
              47,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              115,
              115,
              80,
              114,
              111,
              100,
              117,
              99,
              116,
              73,
              110,
              112,
              117,
              116,
              115,
              58,
              105,
              110,
              115,
              101,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a CSS Product input from your CSS Center account.
     *
     * After a delete it may take several minutes until the input is no longer
     * available.
     */
    deleteCssProductInput: {
      name: "DeleteCssProductInput",
      requestType: DeleteCssProductInputRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              42,
              42,
              40,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              115,
              115,
              80,
              114,
              111,
              100,
              117,
              99,
              116,
              73,
              110,
              112,
              117,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface CssProductInputsServiceImplementation<CallContextExt = {}> {
  /**
   * Uploads a CssProductInput to your CSS Center account. If an
   * input with the same contentLanguage, identity, feedLabel and feedId already
   * exists, this method replaces that entry.
   *
   * After inserting, updating, or deleting a CSS Product input, it may
   * take several minutes before the processed CSS Product can be retrieved.
   */
  insertCssProductInput(
    request: InsertCssProductInputRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CssProductInput>>;
  /**
   * Deletes a CSS Product input from your CSS Center account.
   *
   * After a delete it may take several minutes until the input is no longer
   * available.
   */
  deleteCssProductInput(
    request: DeleteCssProductInputRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface CssProductInputsServiceClient<CallOptionsExt = {}> {
  /**
   * Uploads a CssProductInput to your CSS Center account. If an
   * input with the same contentLanguage, identity, feedLabel and feedId already
   * exists, this method replaces that entry.
   *
   * After inserting, updating, or deleting a CSS Product input, it may
   * take several minutes before the processed CSS Product can be retrieved.
   */
  insertCssProductInput(
    request: DeepPartial<InsertCssProductInputRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CssProductInput>;
  /**
   * Deletes a CSS Product input from your CSS Center account.
   *
   * After a delete it may take several minutes until the input is no longer
   * available.
   */
  deleteCssProductInput(
    request: DeepPartial<DeleteCssProductInputRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
