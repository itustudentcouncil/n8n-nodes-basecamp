// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/shopping/merchant/lfp/v1beta/lfpstore.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../../protobuf/empty.js";

export const protobufPackage = "google.shopping.merchant.lfp.v1beta";

/**
 * A store for the merchant. This will be used to match to a store under the
 * Google Business Profile of the target merchant. If a matching store can't be
 * found, the inventories or sales submitted with the store code will not be
 * used.
 */
export interface LfpStore {
  /**
   * Output only. Identifier. The name of the `LfpStore` resource.
   * Format: `accounts/{account}/lfpStores/{target_merchant}~{store_code}`
   */
  name: string;
  /** Required. The Merchant Center id of the merchant to submit the store for. */
  targetAccount: Long;
  /**
   * Required. Immutable. A store identifier that is unique for the target
   * merchant.
   */
  storeCode: string;
  /**
   * Required. The street address of the store.
   * Example: 1600 Amphitheatre Pkwy, Mountain View, CA 94043, USA.
   */
  storeAddress: string;
  /** Optional. The merchant or store name. */
  storeName?:
    | string
    | undefined;
  /**
   * Optional. The store phone number in
   * [E.164](https://en.wikipedia.org/wiki/E.164) format. Example:
   * `+15556767888`
   */
  phoneNumber?:
    | string
    | undefined;
  /** Optional. The website URL for the store or merchant. */
  websiteUri?:
    | string
    | undefined;
  /**
   * Optional. [Google My Business category
   * id](https://gcid-explorer.corp.google.com/static/gcid.html).
   */
  gcidCategory: string[];
  /**
   * Optional. The [Google Place
   * Id](https://developers.google.com/maps/documentation/places/web-service/place-id#id-overview)
   * of the store location.
   */
  placeId?:
    | string
    | undefined;
  /**
   * Optional. Output only. The state of matching to a Google Business Profile.
   * See
   * [matchingStateHint][google.shopping.merchant.lfp.v1beta.LfpStore.matching_state_hint]
   * for further details if no match is found.
   */
  matchingState: LfpStore_StoreMatchingState;
  /**
   * Optional. Output only. The hint of why the matching has failed. This is
   * only set when
   * [matchingState][google.shopping.merchant.lfp.v1beta.LfpStore.matching_state]=`STORE_MATCHING_STATE_FAILED`.
   *
   * Possible values are:
   *
   * - "`linked-store-not-found`": There aren't any Google Business
   * Profile stores available for matching.
   * - "`store-match-not-found`": The provided `LfpStore` couldn't be matched to
   * any of the connected Google Business Profile stores. Merchant Center
   * account is connected correctly and stores are available on Google Business
   * Profile, but the `LfpStore` location address does not match with Google
   * Business Profile stores' addresses. Update the `LfpStore` address or Google
   * Business Profile store address to match correctly.
   * - "`store-match-unverified`": The provided `LfpStore` couldn't be matched
   * to any of the connected Google Business Profile stores, as the matched
   * Google Business Profile store is unverified. Go through the Google Business
   * Profile verification process to match correctly.
   */
  matchingStateHint?: string | undefined;
}

/** The state of matching `LfpStore` to a Google Business Profile. */
export enum LfpStore_StoreMatchingState {
  /** STORE_MATCHING_STATE_UNSPECIFIED - Store matching state unspecified. */
  STORE_MATCHING_STATE_UNSPECIFIED = 0,
  /**
   * STORE_MATCHING_STATE_MATCHED - The `LfpStore` is successfully matched with a Google Business Profile
   * store.
   */
  STORE_MATCHING_STATE_MATCHED = 1,
  /** STORE_MATCHING_STATE_FAILED - The `LfpStore` is not matched with a Google Business Profile store. */
  STORE_MATCHING_STATE_FAILED = 2,
  UNRECOGNIZED = -1,
}

export function lfpStore_StoreMatchingStateFromJSON(object: any): LfpStore_StoreMatchingState {
  switch (object) {
    case 0:
    case "STORE_MATCHING_STATE_UNSPECIFIED":
      return LfpStore_StoreMatchingState.STORE_MATCHING_STATE_UNSPECIFIED;
    case 1:
    case "STORE_MATCHING_STATE_MATCHED":
      return LfpStore_StoreMatchingState.STORE_MATCHING_STATE_MATCHED;
    case 2:
    case "STORE_MATCHING_STATE_FAILED":
      return LfpStore_StoreMatchingState.STORE_MATCHING_STATE_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LfpStore_StoreMatchingState.UNRECOGNIZED;
  }
}

export function lfpStore_StoreMatchingStateToJSON(object: LfpStore_StoreMatchingState): string {
  switch (object) {
    case LfpStore_StoreMatchingState.STORE_MATCHING_STATE_UNSPECIFIED:
      return "STORE_MATCHING_STATE_UNSPECIFIED";
    case LfpStore_StoreMatchingState.STORE_MATCHING_STATE_MATCHED:
      return "STORE_MATCHING_STATE_MATCHED";
    case LfpStore_StoreMatchingState.STORE_MATCHING_STATE_FAILED:
      return "STORE_MATCHING_STATE_FAILED";
    case LfpStore_StoreMatchingState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for the `GetLfpStore` method. */
export interface GetLfpStoreRequest {
  /**
   * Required. The name of the store to retrieve.
   * Format: `accounts/{account}/lfpStores/{target_merchant}~{store_code}`
   */
  name: string;
}

/** Request message for the InsertLfpStore method. */
export interface InsertLfpStoreRequest {
  /**
   * Required. The LFP provider account
   * Format: `accounts/{account}`
   */
  parent: string;
  /** Required. The store to insert. */
  lfpStore: LfpStore | undefined;
}

/** Request message for the DeleteLfpStore method. */
export interface DeleteLfpStoreRequest {
  /**
   * Required. The name of the store to delete for the target merchant account.
   * Format: `accounts/{account}/lfpStores/{target_merchant}~{store_code}`
   */
  name: string;
}

/** Request message for the ListLfpStores method. */
export interface ListLfpStoresRequest {
  /**
   * Required. The LFP partner.
   * Format: `accounts/{account}`
   */
  parent: string;
  /** Required. The Merchant Center id of the merchant to list stores for. */
  targetAccount: Long;
  /**
   * Optional. The maximum number of `LfpStore` resources for the given account
   * to return. The service returns fewer than this value if the number of
   * stores for the given account is less than the `pageSize`. The default value
   * is 250. The maximum value is 1000; If a value higher than the maximum is
   * specified, then the `pageSize` will default to the maximum.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListLfpStoresRequest`
   * call. Provide the page token to retrieve the subsequent page. When
   * paginating, all other parameters provided to `ListLfpStoresRequest` must
   * match the call that provided the page token. The token returned as
   * [nextPageToken][google.shopping.merchant.lfp.v1beta.ListLfpStoresResponse.next_page_token]
   * in the response to the previous request.
   */
  pageToken: string;
}

/** Response message for the ListLfpStores method. */
export interface ListLfpStoresResponse {
  /** The stores from the specified merchant. */
  lfpStores: LfpStore[];
  /**
   * A token, which can be sent as `pageToken` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

function createBaseLfpStore(): LfpStore {
  return {
    name: "",
    targetAccount: Long.ZERO,
    storeCode: "",
    storeAddress: "",
    storeName: undefined,
    phoneNumber: undefined,
    websiteUri: undefined,
    gcidCategory: [],
    placeId: undefined,
    matchingState: 0,
    matchingStateHint: undefined,
  };
}

export const LfpStore: MessageFns<LfpStore> = {
  encode(message: LfpStore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.targetAccount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.targetAccount.toString());
    }
    if (message.storeCode !== "") {
      writer.uint32(26).string(message.storeCode);
    }
    if (message.storeAddress !== "") {
      writer.uint32(34).string(message.storeAddress);
    }
    if (message.storeName !== undefined) {
      writer.uint32(42).string(message.storeName);
    }
    if (message.phoneNumber !== undefined) {
      writer.uint32(50).string(message.phoneNumber);
    }
    if (message.websiteUri !== undefined) {
      writer.uint32(58).string(message.websiteUri);
    }
    for (const v of message.gcidCategory) {
      writer.uint32(66).string(v!);
    }
    if (message.placeId !== undefined) {
      writer.uint32(74).string(message.placeId);
    }
    if (message.matchingState !== 0) {
      writer.uint32(80).int32(message.matchingState);
    }
    if (message.matchingStateHint !== undefined) {
      writer.uint32(90).string(message.matchingStateHint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LfpStore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLfpStore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetAccount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.storeCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.storeAddress = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.websiteUri = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.gcidCategory.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.placeId = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.matchingState = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.matchingStateHint = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LfpStore {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      targetAccount: isSet(object.targetAccount) ? Long.fromValue(object.targetAccount) : Long.ZERO,
      storeCode: isSet(object.storeCode) ? globalThis.String(object.storeCode) : "",
      storeAddress: isSet(object.storeAddress) ? globalThis.String(object.storeAddress) : "",
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : undefined,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : undefined,
      websiteUri: isSet(object.websiteUri) ? globalThis.String(object.websiteUri) : undefined,
      gcidCategory: globalThis.Array.isArray(object?.gcidCategory)
        ? object.gcidCategory.map((e: any) => globalThis.String(e))
        : [],
      placeId: isSet(object.placeId) ? globalThis.String(object.placeId) : undefined,
      matchingState: isSet(object.matchingState) ? lfpStore_StoreMatchingStateFromJSON(object.matchingState) : 0,
      matchingStateHint: isSet(object.matchingStateHint) ? globalThis.String(object.matchingStateHint) : undefined,
    };
  },

  toJSON(message: LfpStore): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.targetAccount.equals(Long.ZERO)) {
      obj.targetAccount = (message.targetAccount || Long.ZERO).toString();
    }
    if (message.storeCode !== "") {
      obj.storeCode = message.storeCode;
    }
    if (message.storeAddress !== "") {
      obj.storeAddress = message.storeAddress;
    }
    if (message.storeName !== undefined) {
      obj.storeName = message.storeName;
    }
    if (message.phoneNumber !== undefined) {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.websiteUri !== undefined) {
      obj.websiteUri = message.websiteUri;
    }
    if (message.gcidCategory?.length) {
      obj.gcidCategory = message.gcidCategory;
    }
    if (message.placeId !== undefined) {
      obj.placeId = message.placeId;
    }
    if (message.matchingState !== 0) {
      obj.matchingState = lfpStore_StoreMatchingStateToJSON(message.matchingState);
    }
    if (message.matchingStateHint !== undefined) {
      obj.matchingStateHint = message.matchingStateHint;
    }
    return obj;
  },

  create(base?: DeepPartial<LfpStore>): LfpStore {
    return LfpStore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LfpStore>): LfpStore {
    const message = createBaseLfpStore();
    message.name = object.name ?? "";
    message.targetAccount = (object.targetAccount !== undefined && object.targetAccount !== null)
      ? Long.fromValue(object.targetAccount)
      : Long.ZERO;
    message.storeCode = object.storeCode ?? "";
    message.storeAddress = object.storeAddress ?? "";
    message.storeName = object.storeName ?? undefined;
    message.phoneNumber = object.phoneNumber ?? undefined;
    message.websiteUri = object.websiteUri ?? undefined;
    message.gcidCategory = object.gcidCategory?.map((e) => e) || [];
    message.placeId = object.placeId ?? undefined;
    message.matchingState = object.matchingState ?? 0;
    message.matchingStateHint = object.matchingStateHint ?? undefined;
    return message;
  },
};

function createBaseGetLfpStoreRequest(): GetLfpStoreRequest {
  return { name: "" };
}

export const GetLfpStoreRequest: MessageFns<GetLfpStoreRequest> = {
  encode(message: GetLfpStoreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLfpStoreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLfpStoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLfpStoreRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetLfpStoreRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLfpStoreRequest>): GetLfpStoreRequest {
    return GetLfpStoreRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLfpStoreRequest>): GetLfpStoreRequest {
    const message = createBaseGetLfpStoreRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseInsertLfpStoreRequest(): InsertLfpStoreRequest {
  return { parent: "", lfpStore: undefined };
}

export const InsertLfpStoreRequest: MessageFns<InsertLfpStoreRequest> = {
  encode(message: InsertLfpStoreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.lfpStore !== undefined) {
      LfpStore.encode(message.lfpStore, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertLfpStoreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertLfpStoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lfpStore = LfpStore.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertLfpStoreRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      lfpStore: isSet(object.lfpStore) ? LfpStore.fromJSON(object.lfpStore) : undefined,
    };
  },

  toJSON(message: InsertLfpStoreRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.lfpStore !== undefined) {
      obj.lfpStore = LfpStore.toJSON(message.lfpStore);
    }
    return obj;
  },

  create(base?: DeepPartial<InsertLfpStoreRequest>): InsertLfpStoreRequest {
    return InsertLfpStoreRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsertLfpStoreRequest>): InsertLfpStoreRequest {
    const message = createBaseInsertLfpStoreRequest();
    message.parent = object.parent ?? "";
    message.lfpStore = (object.lfpStore !== undefined && object.lfpStore !== null)
      ? LfpStore.fromPartial(object.lfpStore)
      : undefined;
    return message;
  },
};

function createBaseDeleteLfpStoreRequest(): DeleteLfpStoreRequest {
  return { name: "" };
}

export const DeleteLfpStoreRequest: MessageFns<DeleteLfpStoreRequest> = {
  encode(message: DeleteLfpStoreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteLfpStoreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteLfpStoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteLfpStoreRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteLfpStoreRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteLfpStoreRequest>): DeleteLfpStoreRequest {
    return DeleteLfpStoreRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteLfpStoreRequest>): DeleteLfpStoreRequest {
    const message = createBaseDeleteLfpStoreRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListLfpStoresRequest(): ListLfpStoresRequest {
  return { parent: "", targetAccount: Long.ZERO, pageSize: 0, pageToken: "" };
}

export const ListLfpStoresRequest: MessageFns<ListLfpStoresRequest> = {
  encode(message: ListLfpStoresRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (!message.targetAccount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.targetAccount.toString());
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLfpStoresRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLfpStoresRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetAccount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLfpStoresRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      targetAccount: isSet(object.targetAccount) ? Long.fromValue(object.targetAccount) : Long.ZERO,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListLfpStoresRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (!message.targetAccount.equals(Long.ZERO)) {
      obj.targetAccount = (message.targetAccount || Long.ZERO).toString();
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListLfpStoresRequest>): ListLfpStoresRequest {
    return ListLfpStoresRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListLfpStoresRequest>): ListLfpStoresRequest {
    const message = createBaseListLfpStoresRequest();
    message.parent = object.parent ?? "";
    message.targetAccount = (object.targetAccount !== undefined && object.targetAccount !== null)
      ? Long.fromValue(object.targetAccount)
      : Long.ZERO;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListLfpStoresResponse(): ListLfpStoresResponse {
  return { lfpStores: [], nextPageToken: "" };
}

export const ListLfpStoresResponse: MessageFns<ListLfpStoresResponse> = {
  encode(message: ListLfpStoresResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lfpStores) {
      LfpStore.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLfpStoresResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLfpStoresResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lfpStores.push(LfpStore.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLfpStoresResponse {
    return {
      lfpStores: globalThis.Array.isArray(object?.lfpStores)
        ? object.lfpStores.map((e: any) => LfpStore.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListLfpStoresResponse): unknown {
    const obj: any = {};
    if (message.lfpStores?.length) {
      obj.lfpStores = message.lfpStores.map((e) => LfpStore.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListLfpStoresResponse>): ListLfpStoresResponse {
    return ListLfpStoresResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListLfpStoresResponse>): ListLfpStoresResponse {
    const message = createBaseListLfpStoresResponse();
    message.lfpStores = object.lfpStores?.map((e) => LfpStore.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/**
 * Service for a [LFP
 * partner](https://support.google.com/merchants/answer/7676652) to submit local
 * stores for a merchant.
 */
export type LfpStoreServiceDefinition = typeof LfpStoreServiceDefinition;
export const LfpStoreServiceDefinition = {
  name: "LfpStoreService",
  fullName: "google.shopping.merchant.lfp.v1beta.LfpStoreService",
  methods: {
    /** Retrieves information about a store. */
    getLfpStore: {
      name: "GetLfpStore",
      requestType: GetLfpStoreRequest,
      requestStream: false,
      responseType: LfpStore,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              43,
              18,
              41,
              47,
              108,
              102,
              112,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              108,
              102,
              112,
              83,
              116,
              111,
              114,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Inserts a store for the target merchant. If the store with the same store
     * code already exists, it will be replaced.
     */
    insertLfpStore: {
      name: "InsertLfpStore",
      requestType: InsertLfpStoreRequest,
      requestStream: false,
      responseType: LfpStore,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([16, 112, 97, 114, 101, 110, 116, 44, 108, 102, 112, 95, 115, 116, 111, 114, 101])],
          578365826: [
            Buffer.from([
              61,
              58,
              9,
              108,
              102,
              112,
              95,
              115,
              116,
              111,
              114,
              101,
              34,
              48,
              47,
              108,
              102,
              112,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              108,
              102,
              112,
              83,
              116,
              111,
              114,
              101,
              115,
              58,
              105,
              110,
              115,
              101,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /** Deletes a store for a target merchant. */
    deleteLfpStore: {
      name: "DeleteLfpStore",
      requestType: DeleteLfpStoreRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              43,
              42,
              41,
              47,
              108,
              102,
              112,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              108,
              102,
              112,
              83,
              116,
              111,
              114,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the stores of the target merchant, specified by the filter in
     * `ListLfpStoresRequest`.
     */
    listLfpStores: {
      name: "ListLfpStores",
      requestType: ListLfpStoresRequest,
      requestStream: false,
      responseType: ListLfpStoresResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              43,
              18,
              41,
              47,
              108,
              102,
              112,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              108,
              102,
              112,
              83,
              116,
              111,
              114,
              101,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface LfpStoreServiceImplementation<CallContextExt = {}> {
  /** Retrieves information about a store. */
  getLfpStore(request: GetLfpStoreRequest, context: CallContext & CallContextExt): Promise<DeepPartial<LfpStore>>;
  /**
   * Inserts a store for the target merchant. If the store with the same store
   * code already exists, it will be replaced.
   */
  insertLfpStore(request: InsertLfpStoreRequest, context: CallContext & CallContextExt): Promise<DeepPartial<LfpStore>>;
  /** Deletes a store for a target merchant. */
  deleteLfpStore(request: DeleteLfpStoreRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Lists the stores of the target merchant, specified by the filter in
   * `ListLfpStoresRequest`.
   */
  listLfpStores(
    request: ListLfpStoresRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListLfpStoresResponse>>;
}

export interface LfpStoreServiceClient<CallOptionsExt = {}> {
  /** Retrieves information about a store. */
  getLfpStore(request: DeepPartial<GetLfpStoreRequest>, options?: CallOptions & CallOptionsExt): Promise<LfpStore>;
  /**
   * Inserts a store for the target merchant. If the store with the same store
   * code already exists, it will be replaced.
   */
  insertLfpStore(
    request: DeepPartial<InsertLfpStoreRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<LfpStore>;
  /** Deletes a store for a target merchant. */
  deleteLfpStore(request: DeepPartial<DeleteLfpStoreRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Lists the stores of the target merchant, specified by the filter in
   * `ListLfpStoresRequest`.
   */
  listLfpStores(
    request: DeepPartial<ListLfpStoresRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListLfpStoresResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
