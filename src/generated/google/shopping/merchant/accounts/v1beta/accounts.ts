// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/shopping/merchant/accounts/v1beta/accounts.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { TimeZone } from "../../../../type/datetime.js";
import { AccountAggregation } from "./accountservices.js";
import { CreateUserRequest } from "./user.js";

export const protobufPackage = "google.shopping.merchant.accounts.v1beta";

/** An account. */
export interface Account {
  /**
   * Identifier. The resource name of the account.
   * Format: `accounts/{account}`
   */
  name: string;
  /** Output only. The ID of the account. */
  accountId: Long;
  /**
   * Required. A human-readable name of the account. See
   * [store name](https://support.google.com/merchants/answer/160556) and
   * [business name](https://support.google.com/merchants/answer/12159159) for
   * more information.
   */
  accountName: string;
  /** Whether this account contains adult content. */
  adultContent: boolean;
  /** Output only. Whether this is a test account. */
  testAccount: boolean;
  /**
   * Required. The time zone of the account.
   *
   * On writes, `time_zone` sets both the `reporting_time_zone` and the
   * `display_time_zone`.
   *
   * For reads, `time_zone` always returns the `display_time_zone`. If
   * `display_time_zone` doesn't exist for your account, `time_zone` is empty.
   */
  timeZone:
    | TimeZone
    | undefined;
  /**
   * Required. The account's [BCP-47 language
   * code](https://tools.ietf.org/html/bcp47), such as `en-US` or `sr-Latn`.
   */
  languageCode: string;
}

/** Request message for the `GetAccount` method. */
export interface GetAccountRequest {
  /**
   * Required. The name of the account to retrieve.
   * Format: `accounts/{account}`
   */
  name: string;
}

/** Request message for the `CreateAndConfigureAccount` method. */
export interface CreateAndConfigureAccountRequest {
  /** Required. The account to be created. */
  account:
    | Account
    | undefined;
  /** Optional. Users to be added to the account. */
  users: CreateUserRequest[];
  /**
   * Optional. The Terms of Service (ToS) to be accepted immediately upon
   * account creation.
   */
  acceptTermsOfService?:
    | CreateAndConfigureAccountRequest_AcceptTermsOfService
    | undefined;
  /**
   * Required. An account service between the account to be created and the
   * provider account is initialized as part of the creation. At least one such
   * service needs to be provided. Currently exactly one of these needs to be
   * `account_aggregation`, which means you can only create sub accounts, not
   * standalone account through this method. Additional `account_management` or
   * `product_management` services may be provided.
   */
  service: CreateAndConfigureAccountRequest_AddAccountService[];
}

/** Reference to a Terms of Service resource. */
export interface CreateAndConfigureAccountRequest_AcceptTermsOfService {
  /**
   * Required. The resource name of the terms of service version in the format
   * `termsOfService/{version}`. To retrieve the latest version, use the
   * [termsOfService.retrieveLatest](/merchant/api/reference/rest/accounts_v1beta/termsOfService/retrieveLatest)
   * method.
   */
  name: string;
  /**
   * Required. Region code as defined by [CLDR](https://cldr.unicode.org/).
   * This is either a country when the ToS applies specifically to that
   * country or `001` when it applies globally.
   */
  regionCode: string;
}

/**
 * Additional instructions to add account services during creation of the
 * account.
 */
export interface CreateAndConfigureAccountRequest_AddAccountService {
  /**
   * The provider is an
   * [aggregator](https://support.google.com/merchants/answer/188487) for
   * the account. Payload for service type Account Aggregation.
   */
  accountAggregation?:
    | AccountAggregation
    | undefined;
  /**
   * Optional. The provider of the service.
   * Format: `accounts/{account}`
   */
  provider?: string | undefined;
}

/** Request message for the `DeleteAccount` method. */
export interface DeleteAccountRequest {
  /**
   * Required. The name of the account to delete.
   * Format: `accounts/{account}`
   */
  name: string;
}

/** Request message for the `UpdateAccount` method. */
export interface UpdateAccountRequest {
  /** Required. The new version of the account. */
  account:
    | Account
    | undefined;
  /** Required. List of fields being updated. */
  updateMask: string[] | undefined;
}

/** Request message for the `ListAccounts` method. */
export interface ListAccountsRequest {
  /**
   * Optional. The maximum number of accounts to return. The service may return
   * fewer than this value.  If unspecified, at most 250 accounts are returned.
   * The maximum value is 500; values above 500 are coerced to 500.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListAccounts` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListAccounts` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Optional. Returns only accounts that match the
   * [filter](/merchant/api/guides/accounts/filter).
   * For more details, see the
   * [filter syntax reference](/merchant/api/guides/accounts/filter-syntax).
   */
  filter: string;
}

/** Response message for the `ListAccounts` method. */
export interface ListAccountsResponse {
  /** The accounts matching the `ListAccountsRequest`. */
  accounts: Account[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request message for the `ListSubAccounts` method. */
export interface ListSubAccountsRequest {
  /**
   * Required. The parent account.
   * Format: `accounts/{account}`
   */
  provider: string;
  /**
   * Optional. The maximum number of accounts to return. The service may return
   * fewer than this value.  If unspecified, at most 250 accounts are returned.
   * The maximum value is 500; values above 500 are coerced to 500.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListAccounts` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListAccounts` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

/** Response message for the `ListSubAccounts` method. */
export interface ListSubAccountsResponse {
  /** The accounts for which the given parent account is an aggregator. */
  accounts: Account[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

function createBaseAccount(): Account {
  return {
    name: "",
    accountId: Long.ZERO,
    accountName: "",
    adultContent: false,
    testAccount: false,
    timeZone: undefined,
    languageCode: "",
  };
}

export const Account: MessageFns<Account> = {
  encode(message: Account, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.accountId.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.accountId.toString());
    }
    if (message.accountName !== "") {
      writer.uint32(26).string(message.accountName);
    }
    if (message.adultContent !== false) {
      writer.uint32(32).bool(message.adultContent);
    }
    if (message.testAccount !== false) {
      writer.uint32(40).bool(message.testAccount);
    }
    if (message.timeZone !== undefined) {
      TimeZone.encode(message.timeZone, writer.uint32(50).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(58).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Account {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.accountId = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.adultContent = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.testAccount = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timeZone = TimeZone.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Account {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      accountId: isSet(object.accountId) ? Long.fromValue(object.accountId) : Long.ZERO,
      accountName: isSet(object.accountName) ? globalThis.String(object.accountName) : "",
      adultContent: isSet(object.adultContent) ? globalThis.Boolean(object.adultContent) : false,
      testAccount: isSet(object.testAccount) ? globalThis.Boolean(object.testAccount) : false,
      timeZone: isSet(object.timeZone) ? TimeZone.fromJSON(object.timeZone) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: Account): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.accountId.equals(Long.ZERO)) {
      obj.accountId = (message.accountId || Long.ZERO).toString();
    }
    if (message.accountName !== "") {
      obj.accountName = message.accountName;
    }
    if (message.adultContent !== false) {
      obj.adultContent = message.adultContent;
    }
    if (message.testAccount !== false) {
      obj.testAccount = message.testAccount;
    }
    if (message.timeZone !== undefined) {
      obj.timeZone = TimeZone.toJSON(message.timeZone);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<Account>): Account {
    return Account.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Account>): Account {
    const message = createBaseAccount();
    message.name = object.name ?? "";
    message.accountId = (object.accountId !== undefined && object.accountId !== null)
      ? Long.fromValue(object.accountId)
      : Long.ZERO;
    message.accountName = object.accountName ?? "";
    message.adultContent = object.adultContent ?? false;
    message.testAccount = object.testAccount ?? false;
    message.timeZone = (object.timeZone !== undefined && object.timeZone !== null)
      ? TimeZone.fromPartial(object.timeZone)
      : undefined;
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseGetAccountRequest(): GetAccountRequest {
  return { name: "" };
}

export const GetAccountRequest: MessageFns<GetAccountRequest> = {
  encode(message: GetAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccountRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAccountRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAccountRequest>): GetAccountRequest {
    return GetAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAccountRequest>): GetAccountRequest {
    const message = createBaseGetAccountRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateAndConfigureAccountRequest(): CreateAndConfigureAccountRequest {
  return { account: undefined, users: [], acceptTermsOfService: undefined, service: [] };
}

export const CreateAndConfigureAccountRequest: MessageFns<CreateAndConfigureAccountRequest> = {
  encode(message: CreateAndConfigureAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== undefined) {
      Account.encode(message.account, writer.uint32(10).fork()).join();
    }
    for (const v of message.users) {
      CreateUserRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.acceptTermsOfService !== undefined) {
      CreateAndConfigureAccountRequest_AcceptTermsOfService.encode(
        message.acceptTermsOfService,
        writer.uint32(26).fork(),
      ).join();
    }
    for (const v of message.service) {
      CreateAndConfigureAccountRequest_AddAccountService.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAndConfigureAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAndConfigureAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = Account.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.users.push(CreateUserRequest.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.acceptTermsOfService = CreateAndConfigureAccountRequest_AcceptTermsOfService.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.service.push(CreateAndConfigureAccountRequest_AddAccountService.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAndConfigureAccountRequest {
    return {
      account: isSet(object.account) ? Account.fromJSON(object.account) : undefined,
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => CreateUserRequest.fromJSON(e)) : [],
      acceptTermsOfService: isSet(object.acceptTermsOfService)
        ? CreateAndConfigureAccountRequest_AcceptTermsOfService.fromJSON(object.acceptTermsOfService)
        : undefined,
      service: globalThis.Array.isArray(object?.service)
        ? object.service.map((e: any) => CreateAndConfigureAccountRequest_AddAccountService.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateAndConfigureAccountRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = Account.toJSON(message.account);
    }
    if (message.users?.length) {
      obj.users = message.users.map((e) => CreateUserRequest.toJSON(e));
    }
    if (message.acceptTermsOfService !== undefined) {
      obj.acceptTermsOfService = CreateAndConfigureAccountRequest_AcceptTermsOfService.toJSON(
        message.acceptTermsOfService,
      );
    }
    if (message.service?.length) {
      obj.service = message.service.map((e) => CreateAndConfigureAccountRequest_AddAccountService.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAndConfigureAccountRequest>): CreateAndConfigureAccountRequest {
    return CreateAndConfigureAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAndConfigureAccountRequest>): CreateAndConfigureAccountRequest {
    const message = createBaseCreateAndConfigureAccountRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? Account.fromPartial(object.account)
      : undefined;
    message.users = object.users?.map((e) => CreateUserRequest.fromPartial(e)) || [];
    message.acceptTermsOfService = (object.acceptTermsOfService !== undefined && object.acceptTermsOfService !== null)
      ? CreateAndConfigureAccountRequest_AcceptTermsOfService.fromPartial(object.acceptTermsOfService)
      : undefined;
    message.service = object.service?.map((e) => CreateAndConfigureAccountRequest_AddAccountService.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCreateAndConfigureAccountRequest_AcceptTermsOfService(): CreateAndConfigureAccountRequest_AcceptTermsOfService {
  return { name: "", regionCode: "" };
}

export const CreateAndConfigureAccountRequest_AcceptTermsOfService: MessageFns<
  CreateAndConfigureAccountRequest_AcceptTermsOfService
> = {
  encode(
    message: CreateAndConfigureAccountRequest_AcceptTermsOfService,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.regionCode !== "") {
      writer.uint32(26).string(message.regionCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAndConfigureAccountRequest_AcceptTermsOfService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAndConfigureAccountRequest_AcceptTermsOfService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.regionCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAndConfigureAccountRequest_AcceptTermsOfService {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
    };
  },

  toJSON(message: CreateAndConfigureAccountRequest_AcceptTermsOfService): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateAndConfigureAccountRequest_AcceptTermsOfService>,
  ): CreateAndConfigureAccountRequest_AcceptTermsOfService {
    return CreateAndConfigureAccountRequest_AcceptTermsOfService.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateAndConfigureAccountRequest_AcceptTermsOfService>,
  ): CreateAndConfigureAccountRequest_AcceptTermsOfService {
    const message = createBaseCreateAndConfigureAccountRequest_AcceptTermsOfService();
    message.name = object.name ?? "";
    message.regionCode = object.regionCode ?? "";
    return message;
  },
};

function createBaseCreateAndConfigureAccountRequest_AddAccountService(): CreateAndConfigureAccountRequest_AddAccountService {
  return { accountAggregation: undefined, provider: undefined };
}

export const CreateAndConfigureAccountRequest_AddAccountService: MessageFns<
  CreateAndConfigureAccountRequest_AddAccountService
> = {
  encode(
    message: CreateAndConfigureAccountRequest_AddAccountService,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountAggregation !== undefined) {
      AccountAggregation.encode(message.accountAggregation, writer.uint32(826).fork()).join();
    }
    if (message.provider !== undefined) {
      writer.uint32(10).string(message.provider);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAndConfigureAccountRequest_AddAccountService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAndConfigureAccountRequest_AddAccountService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 103:
          if (tag !== 826) {
            break;
          }

          message.accountAggregation = AccountAggregation.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAndConfigureAccountRequest_AddAccountService {
    return {
      accountAggregation: isSet(object.accountAggregation)
        ? AccountAggregation.fromJSON(object.accountAggregation)
        : undefined,
      provider: isSet(object.provider) ? globalThis.String(object.provider) : undefined,
    };
  },

  toJSON(message: CreateAndConfigureAccountRequest_AddAccountService): unknown {
    const obj: any = {};
    if (message.accountAggregation !== undefined) {
      obj.accountAggregation = AccountAggregation.toJSON(message.accountAggregation);
    }
    if (message.provider !== undefined) {
      obj.provider = message.provider;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateAndConfigureAccountRequest_AddAccountService>,
  ): CreateAndConfigureAccountRequest_AddAccountService {
    return CreateAndConfigureAccountRequest_AddAccountService.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateAndConfigureAccountRequest_AddAccountService>,
  ): CreateAndConfigureAccountRequest_AddAccountService {
    const message = createBaseCreateAndConfigureAccountRequest_AddAccountService();
    message.accountAggregation = (object.accountAggregation !== undefined && object.accountAggregation !== null)
      ? AccountAggregation.fromPartial(object.accountAggregation)
      : undefined;
    message.provider = object.provider ?? undefined;
    return message;
  },
};

function createBaseDeleteAccountRequest(): DeleteAccountRequest {
  return { name: "" };
}

export const DeleteAccountRequest: MessageFns<DeleteAccountRequest> = {
  encode(message: DeleteAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAccountRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteAccountRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAccountRequest>): DeleteAccountRequest {
    return DeleteAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAccountRequest>): DeleteAccountRequest {
    const message = createBaseDeleteAccountRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateAccountRequest(): UpdateAccountRequest {
  return { account: undefined, updateMask: undefined };
}

export const UpdateAccountRequest: MessageFns<UpdateAccountRequest> = {
  encode(message: UpdateAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== undefined) {
      Account.encode(message.account, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = Account.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAccountRequest {
    return {
      account: isSet(object.account) ? Account.fromJSON(object.account) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateAccountRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = Account.toJSON(message.account);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAccountRequest>): UpdateAccountRequest {
    return UpdateAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAccountRequest>): UpdateAccountRequest {
    const message = createBaseUpdateAccountRequest();
    message.account = (object.account !== undefined && object.account !== null)
      ? Account.fromPartial(object.account)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseListAccountsRequest(): ListAccountsRequest {
  return { pageSize: 0, pageToken: "", filter: "" };
}

export const ListAccountsRequest: MessageFns<ListAccountsRequest> = {
  encode(message: ListAccountsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAccountsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAccountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAccountsRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListAccountsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAccountsRequest>): ListAccountsRequest {
    return ListAccountsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAccountsRequest>): ListAccountsRequest {
    const message = createBaseListAccountsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListAccountsResponse(): ListAccountsResponse {
  return { accounts: [], nextPageToken: "" };
}

export const ListAccountsResponse: MessageFns<ListAccountsResponse> = {
  encode(message: ListAccountsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      Account.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAccountsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAccountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accounts.push(Account.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAccountsResponse {
    return {
      accounts: globalThis.Array.isArray(object?.accounts) ? object.accounts.map((e: any) => Account.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAccountsResponse): unknown {
    const obj: any = {};
    if (message.accounts?.length) {
      obj.accounts = message.accounts.map((e) => Account.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAccountsResponse>): ListAccountsResponse {
    return ListAccountsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAccountsResponse>): ListAccountsResponse {
    const message = createBaseListAccountsResponse();
    message.accounts = object.accounts?.map((e) => Account.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListSubAccountsRequest(): ListSubAccountsRequest {
  return { provider: "", pageSize: 0, pageToken: "" };
}

export const ListSubAccountsRequest: MessageFns<ListSubAccountsRequest> = {
  encode(message: ListSubAccountsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubAccountsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubAccountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubAccountsRequest {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSubAccountsRequest): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSubAccountsRequest>): ListSubAccountsRequest {
    return ListSubAccountsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSubAccountsRequest>): ListSubAccountsRequest {
    const message = createBaseListSubAccountsRequest();
    message.provider = object.provider ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSubAccountsResponse(): ListSubAccountsResponse {
  return { accounts: [], nextPageToken: "" };
}

export const ListSubAccountsResponse: MessageFns<ListSubAccountsResponse> = {
  encode(message: ListSubAccountsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      Account.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubAccountsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubAccountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accounts.push(Account.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubAccountsResponse {
    return {
      accounts: globalThis.Array.isArray(object?.accounts) ? object.accounts.map((e: any) => Account.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSubAccountsResponse): unknown {
    const obj: any = {};
    if (message.accounts?.length) {
      obj.accounts = message.accounts.map((e) => Account.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSubAccountsResponse>): ListSubAccountsResponse {
    return ListSubAccountsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSubAccountsResponse>): ListSubAccountsResponse {
    const message = createBaseListSubAccountsResponse();
    message.accounts = object.accounts?.map((e) => Account.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/** Service to support Accounts API. */
export type AccountsServiceDefinition = typeof AccountsServiceDefinition;
export const AccountsServiceDefinition = {
  name: "AccountsService",
  fullName: "google.shopping.merchant.accounts.v1beta.AccountsService",
  methods: {
    /**
     * Retrieves an account from your Merchant Center account.
     * After inserting, updating, or deleting an account, it may take several
     * minutes before changes take effect.
     */
    getAccount: {
      name: "GetAccount",
      requestType: GetAccountRequest,
      requestStream: false,
      responseType: Account,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              36,
              18,
              34,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a standalone Merchant Center account with additional configuration.
     * Adds the user that makes the request as an admin for the new account.
     */
    createAndConfigureAccount: {
      name: "CreateAndConfigureAccount",
      requestType: CreateAndConfigureAccountRequest,
      requestStream: false,
      responseType: Account,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              49,
              58,
              1,
              42,
              34,
              44,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              58,
              99,
              114,
              101,
              97,
              116,
              101,
              65,
              110,
              100,
              67,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the specified account regardless of its type: standalone, MCA or
     * sub-account. Deleting an MCA leads to the deletion of all of its
     * sub-accounts. Executing this method requires admin access.
     */
    deleteAccount: {
      name: "DeleteAccount",
      requestType: DeleteAccountRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              36,
              42,
              34,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates an account regardless of its type: standalone, MCA or sub-account.
     * Executing this method requires admin access.
     */
    updateAccount: {
      name: "UpdateAccount",
      requestType: UpdateAccountRequest,
      requestStream: false,
      responseType: Account,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([19, 97, 99, 99, 111, 117, 110, 116, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              53,
              58,
              7,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              50,
              42,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists accounts accessible to the calling user and matching the
     * constraints of the request such as page size or filters.
     * This is not just listing the sub-accounts of an MCA, but all accounts the
     * calling user has access to including other MCAs, linked accounts,
     * standalone accounts and so on.
     */
    listAccounts: {
      name: "ListAccounts",
      requestType: ListAccountsRequest,
      requestStream: false,
      responseType: ListAccountsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              27,
              18,
              25,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * List all sub-accounts for a given multi client account. This is a
     * convenience wrapper for the more powerful `ListAccounts` method. This
     * method will produce the same results as calling `ListsAccounts` with the
     * following filter:
     * `relationship(providerId={parent} AND service(type="ACCOUNT_AGGREGATION"))`
     */
    listSubAccounts: {
      name: "ListSubAccounts",
      requestType: ListSubAccountsRequest,
      requestStream: false,
      responseType: ListSubAccountsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([8, 112, 114, 111, 118, 105, 100, 101, 114])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              108,
              105,
              115,
              116,
              83,
              117,
              98,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AccountsServiceImplementation<CallContextExt = {}> {
  /**
   * Retrieves an account from your Merchant Center account.
   * After inserting, updating, or deleting an account, it may take several
   * minutes before changes take effect.
   */
  getAccount(request: GetAccountRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Account>>;
  /**
   * Creates a standalone Merchant Center account with additional configuration.
   * Adds the user that makes the request as an admin for the new account.
   */
  createAndConfigureAccount(
    request: CreateAndConfigureAccountRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Account>>;
  /**
   * Deletes the specified account regardless of its type: standalone, MCA or
   * sub-account. Deleting an MCA leads to the deletion of all of its
   * sub-accounts. Executing this method requires admin access.
   */
  deleteAccount(request: DeleteAccountRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Updates an account regardless of its type: standalone, MCA or sub-account.
   * Executing this method requires admin access.
   */
  updateAccount(request: UpdateAccountRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Account>>;
  /**
   * Lists accounts accessible to the calling user and matching the
   * constraints of the request such as page size or filters.
   * This is not just listing the sub-accounts of an MCA, but all accounts the
   * calling user has access to including other MCAs, linked accounts,
   * standalone accounts and so on.
   */
  listAccounts(
    request: ListAccountsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAccountsResponse>>;
  /**
   * List all sub-accounts for a given multi client account. This is a
   * convenience wrapper for the more powerful `ListAccounts` method. This
   * method will produce the same results as calling `ListsAccounts` with the
   * following filter:
   * `relationship(providerId={parent} AND service(type="ACCOUNT_AGGREGATION"))`
   */
  listSubAccounts(
    request: ListSubAccountsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSubAccountsResponse>>;
}

export interface AccountsServiceClient<CallOptionsExt = {}> {
  /**
   * Retrieves an account from your Merchant Center account.
   * After inserting, updating, or deleting an account, it may take several
   * minutes before changes take effect.
   */
  getAccount(request: DeepPartial<GetAccountRequest>, options?: CallOptions & CallOptionsExt): Promise<Account>;
  /**
   * Creates a standalone Merchant Center account with additional configuration.
   * Adds the user that makes the request as an admin for the new account.
   */
  createAndConfigureAccount(
    request: DeepPartial<CreateAndConfigureAccountRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Account>;
  /**
   * Deletes the specified account regardless of its type: standalone, MCA or
   * sub-account. Deleting an MCA leads to the deletion of all of its
   * sub-accounts. Executing this method requires admin access.
   */
  deleteAccount(request: DeepPartial<DeleteAccountRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Updates an account regardless of its type: standalone, MCA or sub-account.
   * Executing this method requires admin access.
   */
  updateAccount(request: DeepPartial<UpdateAccountRequest>, options?: CallOptions & CallOptionsExt): Promise<Account>;
  /**
   * Lists accounts accessible to the calling user and matching the
   * constraints of the request such as page size or filters.
   * This is not just listing the sub-accounts of an MCA, but all accounts the
   * calling user has access to including other MCAs, linked accounts,
   * standalone accounts and so on.
   */
  listAccounts(
    request: DeepPartial<ListAccountsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAccountsResponse>;
  /**
   * List all sub-accounts for a given multi client account. This is a
   * convenience wrapper for the more powerful `ListAccounts` method. This
   * method will produce the same results as calling `ListsAccounts` with the
   * following filter:
   * `relationship(providerId={parent} AND service(type="ACCOUNT_AGGREGATION"))`
   */
  listSubAccounts(
    request: DeepPartial<ListSubAccountsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSubAccountsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
