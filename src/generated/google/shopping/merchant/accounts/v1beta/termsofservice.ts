// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/shopping/merchant/accounts/v1beta/termsofservice.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../../protobuf/empty.js";
import { TermsOfServiceKind, termsOfServiceKindFromJSON, termsOfServiceKindToJSON } from "./termsofservicekind.js";

export const protobufPackage = "google.shopping.merchant.accounts.v1beta";

/** A `TermsOfService`. */
export interface TermsOfService {
  /**
   * Identifier. The resource name of the terms of service version.
   * Format: `termsOfService/{version}`
   */
  name: string;
  /**
   * Region code as defined by [CLDR](https://cldr.unicode.org/). This is either
   * a country where the ToS applies specifically to that country or `001` when
   * the same `TermsOfService` can be signed in any country. However note that
   * when signing a ToS that applies globally we still expect that a specific
   * country is provided  (this should be merchant business country or program
   * country of participation).
   */
  regionCode: string;
  /** The Kind this terms of service version applies to. */
  kind: TermsOfServiceKind;
  /** URI for terms of service file that needs to be displayed to signing users. */
  fileUri?:
    | string
    | undefined;
  /**
   * Whether this terms of service version is external. External terms of
   * service versions can only be agreed through external processes and not
   * directly by the merchant through UI or API.
   */
  external: boolean;
}

/** Request message for the `GetTermsOfService` method. */
export interface GetTermsOfServiceRequest {
  /**
   * Required. The resource name of the terms of service version.
   * Format: `termsOfService/{version}`
   */
  name: string;
}

/** Request message for the `RetrieveLatestTermsOfService` method. */
export interface RetrieveLatestTermsOfServiceRequest {
  /**
   * Required. Region code as defined by [CLDR](https://cldr.unicode.org/). This
   * is either a country when the ToS applies specifically to that country or
   * 001 when it applies globally.
   */
  regionCode: string;
  /** Required. The Kind this terms of service version applies to. */
  kind: TermsOfServiceKind;
}

/** Request message for the `AcceptTermsOfService` method. */
export interface AcceptTermsOfServiceRequest {
  /**
   * Required. The resource name of the terms of service version.
   * Format: `termsOfService/{version}`
   */
  name: string;
  /** Required. The account for which to accept the ToS. */
  account: string;
  /**
   * Required. Region code as defined by [CLDR](https://cldr.unicode.org/). This
   * is either a country when the ToS applies specifically to that country or
   * 001 when it applies globally.
   */
  regionCode: string;
}

function createBaseTermsOfService(): TermsOfService {
  return { name: "", regionCode: "", kind: 0, fileUri: undefined, external: false };
}

export const TermsOfService: MessageFns<TermsOfService> = {
  encode(message: TermsOfService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.regionCode !== "") {
      writer.uint32(18).string(message.regionCode);
    }
    if (message.kind !== 0) {
      writer.uint32(24).int32(message.kind);
    }
    if (message.fileUri !== undefined) {
      writer.uint32(34).string(message.fileUri);
    }
    if (message.external !== false) {
      writer.uint32(40).bool(message.external);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TermsOfService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTermsOfService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fileUri = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.external = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TermsOfService {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      kind: isSet(object.kind) ? termsOfServiceKindFromJSON(object.kind) : 0,
      fileUri: isSet(object.fileUri) ? globalThis.String(object.fileUri) : undefined,
      external: isSet(object.external) ? globalThis.Boolean(object.external) : false,
    };
  },

  toJSON(message: TermsOfService): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.kind !== 0) {
      obj.kind = termsOfServiceKindToJSON(message.kind);
    }
    if (message.fileUri !== undefined) {
      obj.fileUri = message.fileUri;
    }
    if (message.external !== false) {
      obj.external = message.external;
    }
    return obj;
  },

  create(base?: DeepPartial<TermsOfService>): TermsOfService {
    return TermsOfService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TermsOfService>): TermsOfService {
    const message = createBaseTermsOfService();
    message.name = object.name ?? "";
    message.regionCode = object.regionCode ?? "";
    message.kind = object.kind ?? 0;
    message.fileUri = object.fileUri ?? undefined;
    message.external = object.external ?? false;
    return message;
  },
};

function createBaseGetTermsOfServiceRequest(): GetTermsOfServiceRequest {
  return { name: "" };
}

export const GetTermsOfServiceRequest: MessageFns<GetTermsOfServiceRequest> = {
  encode(message: GetTermsOfServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTermsOfServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTermsOfServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTermsOfServiceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTermsOfServiceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTermsOfServiceRequest>): GetTermsOfServiceRequest {
    return GetTermsOfServiceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTermsOfServiceRequest>): GetTermsOfServiceRequest {
    const message = createBaseGetTermsOfServiceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRetrieveLatestTermsOfServiceRequest(): RetrieveLatestTermsOfServiceRequest {
  return { regionCode: "", kind: 0 };
}

export const RetrieveLatestTermsOfServiceRequest: MessageFns<RetrieveLatestTermsOfServiceRequest> = {
  encode(message: RetrieveLatestTermsOfServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.regionCode !== "") {
      writer.uint32(10).string(message.regionCode);
    }
    if (message.kind !== 0) {
      writer.uint32(16).int32(message.kind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrieveLatestTermsOfServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrieveLatestTermsOfServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrieveLatestTermsOfServiceRequest {
    return {
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      kind: isSet(object.kind) ? termsOfServiceKindFromJSON(object.kind) : 0,
    };
  },

  toJSON(message: RetrieveLatestTermsOfServiceRequest): unknown {
    const obj: any = {};
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.kind !== 0) {
      obj.kind = termsOfServiceKindToJSON(message.kind);
    }
    return obj;
  },

  create(base?: DeepPartial<RetrieveLatestTermsOfServiceRequest>): RetrieveLatestTermsOfServiceRequest {
    return RetrieveLatestTermsOfServiceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetrieveLatestTermsOfServiceRequest>): RetrieveLatestTermsOfServiceRequest {
    const message = createBaseRetrieveLatestTermsOfServiceRequest();
    message.regionCode = object.regionCode ?? "";
    message.kind = object.kind ?? 0;
    return message;
  },
};

function createBaseAcceptTermsOfServiceRequest(): AcceptTermsOfServiceRequest {
  return { name: "", account: "", regionCode: "" };
}

export const AcceptTermsOfServiceRequest: MessageFns<AcceptTermsOfServiceRequest> = {
  encode(message: AcceptTermsOfServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.account !== "") {
      writer.uint32(18).string(message.account);
    }
    if (message.regionCode !== "") {
      writer.uint32(26).string(message.regionCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcceptTermsOfServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceptTermsOfServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.account = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.regionCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcceptTermsOfServiceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
    };
  },

  toJSON(message: AcceptTermsOfServiceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    return obj;
  },

  create(base?: DeepPartial<AcceptTermsOfServiceRequest>): AcceptTermsOfServiceRequest {
    return AcceptTermsOfServiceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcceptTermsOfServiceRequest>): AcceptTermsOfServiceRequest {
    const message = createBaseAcceptTermsOfServiceRequest();
    message.name = object.name ?? "";
    message.account = object.account ?? "";
    message.regionCode = object.regionCode ?? "";
    return message;
  },
};

/** Service to support `TermsOfService` API. */
export type TermsOfServiceServiceDefinition = typeof TermsOfServiceServiceDefinition;
export const TermsOfServiceServiceDefinition = {
  name: "TermsOfServiceService",
  fullName: "google.shopping.merchant.accounts.v1beta.TermsOfServiceService",
  methods: {
    /** Retrieves the `TermsOfService` associated with the provided version. */
    getTermsOfService: {
      name: "GetTermsOfService",
      requestType: GetTermsOfServiceRequest,
      requestStream: false,
      responseType: TermsOfService,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              42,
              18,
              40,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              116,
              101,
              114,
              109,
              115,
              79,
              102,
              83,
              101,
              114,
              118,
              105,
              99,
              101,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves the latest version of the `TermsOfService` for a given `kind` and
     * `region_code`.
     */
    retrieveLatestTermsOfService: {
      name: "RetrieveLatestTermsOfService",
      requestType: RetrieveLatestTermsOfServiceRequest,
      requestStream: false,
      responseType: TermsOfService,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              48,
              18,
              46,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              116,
              101,
              114,
              109,
              115,
              79,
              102,
              83,
              101,
              114,
              118,
              105,
              99,
              101,
              58,
              114,
              101,
              116,
              114,
              105,
              101,
              118,
              101,
              76,
              97,
              116,
              101,
              115,
              116,
            ]),
          ],
        },
      },
    },
    /** Accepts a `TermsOfService`. Executing this method requires admin access. */
    acceptTermsOfService: {
      name: "AcceptTermsOfService",
      requestType: AcceptTermsOfServiceRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              116,
              101,
              114,
              109,
              115,
              79,
              102,
              83,
              101,
              114,
              118,
              105,
              99,
              101,
              47,
              42,
              125,
              58,
              97,
              99,
              99,
              101,
              112,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface TermsOfServiceServiceImplementation<CallContextExt = {}> {
  /** Retrieves the `TermsOfService` associated with the provided version. */
  getTermsOfService(
    request: GetTermsOfServiceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TermsOfService>>;
  /**
   * Retrieves the latest version of the `TermsOfService` for a given `kind` and
   * `region_code`.
   */
  retrieveLatestTermsOfService(
    request: RetrieveLatestTermsOfServiceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TermsOfService>>;
  /** Accepts a `TermsOfService`. Executing this method requires admin access. */
  acceptTermsOfService(
    request: AcceptTermsOfServiceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface TermsOfServiceServiceClient<CallOptionsExt = {}> {
  /** Retrieves the `TermsOfService` associated with the provided version. */
  getTermsOfService(
    request: DeepPartial<GetTermsOfServiceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TermsOfService>;
  /**
   * Retrieves the latest version of the `TermsOfService` for a given `kind` and
   * `region_code`.
   */
  retrieveLatestTermsOfService(
    request: DeepPartial<RetrieveLatestTermsOfServiceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TermsOfService>;
  /** Accepts a `TermsOfService`. Executing this method requires admin access. */
  acceptTermsOfService(
    request: DeepPartial<AcceptTermsOfServiceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
