// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/shopping/merchant/accounts/v1beta/shippingsettings.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Price, Weight } from "../../../type/types.js";

export const protobufPackage = "google.shopping.merchant.accounts.v1beta";

/**
 * The merchant account's [shipping
 * setting](https://support.google.com/merchants/answer/6069284).
 */
export interface ShippingSettings {
  /**
   * Identifier. The resource name of the shipping setting.
   * Format: `accounts/{account}/shippingSetting`
   */
  name: string;
  /** Optional. The target account's list of services. */
  services: Service[];
  /** Optional. A list of warehouses which can be referred to in `services`. */
  warehouses: Warehouse[];
  /**
   * Required. This field is used for avoid async issue. Make sure shipping
   * setting data
   *  didn't change between get call and insert call. The user should do
   *  following stepsï¼š
   *
   * 1. Set etag field as empty string for initial shipping setting creation.
   *
   * 2. After initial creation, call get method to obtain an etag and current
   * shipping setting data before call insert.
   *
   * 3. Modify to wanted shipping setting information.
   *
   * 4. Call insert method with the wanted shipping setting information with
   * the etag obtained from step 2.
   *
   * 5. If shipping setting data changed between step 2 and step 4. Insert
   * request will fail because the etag changes every time the shipping setting
   * data changes. User should repeate step 2-4 with the new etag.
   */
  etag: string;
}

/** Shipping service. */
export interface Service {
  /**
   * Required. Free-form name of the service. Must be unique within target
   * account.
   */
  serviceName?:
    | string
    | undefined;
  /** Required. A boolean exposing the active status of the shipping service. */
  active?:
    | boolean
    | undefined;
  /**
   * Required. The CLDR territory code of the countries to which the service
   * applies.
   */
  deliveryCountries: string[];
  /**
   * The CLDR code of the currency to which this service applies. Must match
   * that of the prices in rate groups.
   */
  currencyCode?:
    | string
    | undefined;
  /**
   * Required. Time spent in various aspects from order to the delivery of the
   * product.
   */
  deliveryTime?:
    | DeliveryTime
    | undefined;
  /**
   * Optional. Shipping rate group definitions. Only the last one is allowed to
   * have an empty `applicable_shipping_labels`, which means "everything else".
   * The other `applicable_shipping_labels` must not overlap.
   */
  rateGroups: RateGroup[];
  /** Type of locations this service ships orders to. */
  shipmentType?:
    | Service_ShipmentType
    | undefined;
  /**
   * Minimum order value for this service. If set, indicates that customers
   * will have to spend at least this amount.
   * All prices within a service must have the same currency.
   * Cannot be set together with minimum_order_value_table.
   */
  minimumOrderValue?:
    | Price
    | undefined;
  /**
   * Table of per store minimum order values for the pickup fulfillment type.
   * Cannot be set together with minimum_order_value.
   */
  minimumOrderValueTable?:
    | MinimumOrderValueTable
    | undefined;
  /**
   * A list of stores your products are delivered from.
   * This is only valid for the local delivery shipment type.
   */
  storeConfig?:
    | Service_StoreConfig
    | undefined;
  /** Optional. Loyalty programs that this shipping service is limited to. */
  loyaltyPrograms: Service_LoyaltyProgram[];
}

/** Shipment type of shipping service. */
export enum Service_ShipmentType {
  /** SHIPMENT_TYPE_UNSPECIFIED - This service did not specify shipment type. */
  SHIPMENT_TYPE_UNSPECIFIED = 0,
  /** DELIVERY - This service ships orders to an address chosen by the customer. */
  DELIVERY = 1,
  /**
   * LOCAL_DELIVERY - This service ships orders to an address chosen by the customer.
   * The order is shipped from a local store near by.
   */
  LOCAL_DELIVERY = 2,
  /**
   * COLLECTION_POINT - This service ships orders to an address chosen by the customer.
   * The order is shipped from a collection point.
   */
  COLLECTION_POINT = 3,
  UNRECOGNIZED = -1,
}

export function service_ShipmentTypeFromJSON(object: any): Service_ShipmentType {
  switch (object) {
    case 0:
    case "SHIPMENT_TYPE_UNSPECIFIED":
      return Service_ShipmentType.SHIPMENT_TYPE_UNSPECIFIED;
    case 1:
    case "DELIVERY":
      return Service_ShipmentType.DELIVERY;
    case 2:
    case "LOCAL_DELIVERY":
      return Service_ShipmentType.LOCAL_DELIVERY;
    case 3:
    case "COLLECTION_POINT":
      return Service_ShipmentType.COLLECTION_POINT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Service_ShipmentType.UNRECOGNIZED;
  }
}

export function service_ShipmentTypeToJSON(object: Service_ShipmentType): string {
  switch (object) {
    case Service_ShipmentType.SHIPMENT_TYPE_UNSPECIFIED:
      return "SHIPMENT_TYPE_UNSPECIFIED";
    case Service_ShipmentType.DELIVERY:
      return "DELIVERY";
    case Service_ShipmentType.LOCAL_DELIVERY:
      return "LOCAL_DELIVERY";
    case Service_ShipmentType.COLLECTION_POINT:
      return "COLLECTION_POINT";
    case Service_ShipmentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A list of stores your products are delivered from.
 * This is only valid for the local delivery shipment type.
 */
export interface Service_StoreConfig {
  /**
   * Indicates whether all stores, or selected stores, listed by this
   * merchant provide local delivery.
   */
  storeServiceType?:
    | Service_StoreConfig_StoreServiceType
    | undefined;
  /**
   * Optional. A list of store codes that provide local delivery.
   * If empty, then `all_stores` must be true.
   */
  storeCodes: string[];
  /** Configs related to local delivery ends for the day. */
  cutoffConfig?:
    | Service_StoreConfig_CutoffConfig
    | undefined;
  /**
   * Maximum delivery radius.
   * This is only required for the local delivery shipment type.
   */
  serviceRadius?: Distance | undefined;
}

/**
 * Indicates whether all stores, or selected stores, listed by the
 * merchant provide local delivery.
 */
export enum Service_StoreConfig_StoreServiceType {
  /** STORE_SERVICE_TYPE_UNSPECIFIED - Did not specify store service type. */
  STORE_SERVICE_TYPE_UNSPECIFIED = 0,
  /**
   * ALL_STORES - Indicates whether all stores, current and future, listed by this
   * merchant provide local delivery.
   */
  ALL_STORES = 1,
  /**
   * SELECTED_STORES - Indicates that only the stores listed in `store_codes` are eligible
   * for local delivery.
   */
  SELECTED_STORES = 2,
  UNRECOGNIZED = -1,
}

export function service_StoreConfig_StoreServiceTypeFromJSON(object: any): Service_StoreConfig_StoreServiceType {
  switch (object) {
    case 0:
    case "STORE_SERVICE_TYPE_UNSPECIFIED":
      return Service_StoreConfig_StoreServiceType.STORE_SERVICE_TYPE_UNSPECIFIED;
    case 1:
    case "ALL_STORES":
      return Service_StoreConfig_StoreServiceType.ALL_STORES;
    case 2:
    case "SELECTED_STORES":
      return Service_StoreConfig_StoreServiceType.SELECTED_STORES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Service_StoreConfig_StoreServiceType.UNRECOGNIZED;
  }
}

export function service_StoreConfig_StoreServiceTypeToJSON(object: Service_StoreConfig_StoreServiceType): string {
  switch (object) {
    case Service_StoreConfig_StoreServiceType.STORE_SERVICE_TYPE_UNSPECIFIED:
      return "STORE_SERVICE_TYPE_UNSPECIFIED";
    case Service_StoreConfig_StoreServiceType.ALL_STORES:
      return "ALL_STORES";
    case Service_StoreConfig_StoreServiceType.SELECTED_STORES:
      return "SELECTED_STORES";
    case Service_StoreConfig_StoreServiceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configs related to local delivery ends for the day. */
export interface Service_StoreConfig_CutoffConfig {
  /** Time that local delivery ends for the day. */
  localCutoffTime?:
    | Service_StoreConfig_CutoffConfig_LocalCutoffTime
    | undefined;
  /**
   * Only valid with local delivery fulfillment. Represents cutoff time
   * as the number of hours before store closing. Mutually exclusive
   * with `local_cutoff_time`.
   */
  storeCloseOffsetHours?:
    | Long
    | undefined;
  /**
   * Merchants can opt-out of showing n+1 day local delivery when they have
   * a shipping service configured to n day local delivery. For example, if
   * the shipping service defines same-day delivery, and it's past the
   * cut-off, setting this field to `true` results in the calculated
   * shipping service rate returning `NO_DELIVERY_POST_CUTOFF`. In the
   * same example, setting this field to `false` results in the calculated
   * shipping time being one day. This is only for local delivery.
   */
  noDeliveryPostCutoff?: boolean | undefined;
}

/** Time that local delivery ends for the day. */
export interface Service_StoreConfig_CutoffConfig_LocalCutoffTime {
  /**
   * Hour local delivery orders must be placed by to process the same
   * day.
   */
  hour?:
    | Long
    | undefined;
  /**
   * Minute local delivery orders must be placed by to process the same
   * day.
   */
  minute?: Long | undefined;
}

/**
 * [Loyalty program](https://support.google.com/merchants/answer/12922446)
 * provided by a merchant.
 */
export interface Service_LoyaltyProgram {
  /**
   * This is the loyalty program label set in your loyalty program settings in
   * Merchant Center. This sub-attribute allows Google to map your loyalty
   * program to eligible offers.
   */
  programLabel?:
    | string
    | undefined;
  /** Optional. Loyalty program tier of this shipping service. */
  loyaltyProgramTiers: Service_LoyaltyProgram_LoyaltyProgramTiers[];
}

/** Subset of a merchants loyalty program. */
export interface Service_LoyaltyProgram_LoyaltyProgramTiers {
  /**
   * The tier label [tier_label] sub-attribute differentiates offer level
   * benefits between each tier. This value is also set in your program
   * settings in Merchant Center, and is required for data source changes
   * even if your loyalty program only has 1 tier.
   */
  tierLabel?: string | undefined;
}

/**
 * Maximum delivery radius.
 * This is only required for the local delivery shipment type.
 */
export interface Distance {
  /** Integer value of distance. */
  value?:
    | Long
    | undefined;
  /**
   * Unit can differ based on country, it is parameterized to include miles
   * and kilometers.
   */
  unit?: Distance_Unit | undefined;
}

/**
 * Unit can differ based on country, it is parameterized to include miles
 * and kilometers.
 */
export enum Distance_Unit {
  /** UNIT_UNSPECIFIED - Unit unspecified */
  UNIT_UNSPECIFIED = 0,
  /** MILES - Unit in miles */
  MILES = 1,
  /** KILOMETERS - Unit in kilometers */
  KILOMETERS = 2,
  UNRECOGNIZED = -1,
}

export function distance_UnitFromJSON(object: any): Distance_Unit {
  switch (object) {
    case 0:
    case "UNIT_UNSPECIFIED":
      return Distance_Unit.UNIT_UNSPECIFIED;
    case 1:
    case "MILES":
      return Distance_Unit.MILES;
    case 2:
    case "KILOMETERS":
      return Distance_Unit.KILOMETERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Distance_Unit.UNRECOGNIZED;
  }
}

export function distance_UnitToJSON(object: Distance_Unit): string {
  switch (object) {
    case Distance_Unit.UNIT_UNSPECIFIED:
      return "UNIT_UNSPECIFIED";
    case Distance_Unit.MILES:
      return "MILES";
    case Distance_Unit.KILOMETERS:
      return "KILOMETERS";
    case Distance_Unit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A fulfillment warehouse, which stores and handles inventory.
 * Next tag: 7
 */
export interface Warehouse {
  /** Required. The name of the warehouse. Must be unique within account. */
  name?:
    | string
    | undefined;
  /** Required. Shipping address of the warehouse. */
  shippingAddress?:
    | Address
    | undefined;
  /**
   * Required. The latest time of day that an order can be accepted and begin
   * processing. Later orders will be processed in the next day. The time is
   * based on the warehouse postal code.
   */
  cutoffTime?:
    | WarehouseCutoffTime
    | undefined;
  /**
   * Required. The number of days it takes for this warehouse to pack up and
   * ship an item. This is on the warehouse level, but can be overridden on the
   * offer level based on the attributes of an item.
   */
  handlingDays?:
    | Long
    | undefined;
  /**
   * Business days of the warehouse.
   * If not set, will be Monday to Friday by default.
   */
  businessDayConfig?: BusinessDayConfig | undefined;
}

/**
 * The latest time of day that an order can be accepted and begin processing.
 * Later orders will be processed in the next day. The time is based on the
 * warehouse postal code.
 */
export interface WarehouseCutoffTime {
  /**
   * Required. Hour of the cutoff time until which an order has to be placed to
   * be processed in the same day by the warehouse. Hour is based on the
   * timezone of warehouse.
   */
  hour?:
    | number
    | undefined;
  /**
   * Required. Minute of the cutoff time until which an order has to be placed
   * to be processed in the same day by the warehouse. Minute is based on the
   * timezone of warehouse.
   */
  minute?: number | undefined;
}

/** Shipping address of the warehouse. */
export interface Address {
  /** Street-level part of the address. For example: `111w 31st Street`. */
  streetAddress?:
    | string
    | undefined;
  /**
   * Required. City, town or commune. May also include dependent localities or
   * sublocalities (For example neighborhoods or suburbs).
   */
  city?:
    | string
    | undefined;
  /**
   * Required. Top-level administrative subdivision of the country. For example,
   * a state like California ("CA") or a province like Quebec ("QC").
   */
  administrativeArea?:
    | string
    | undefined;
  /** Required. Postal code or ZIP (For example "94043"). */
  postalCode?:
    | string
    | undefined;
  /**
   * Required. [CLDR country
   * code](http://www.unicode.org/repos/cldr/tags/latest/common/main/en.xml)
   * (For example "US").
   */
  regionCode?: string | undefined;
}

/** Time spent in various aspects from order to the delivery of the product. */
export interface DeliveryTime {
  /**
   * Minimum number of business days that is spent in transit. 0 means same
   * day delivery, 1 means next day delivery.
   * Either `min_transit_days`, `max_transit_days` or
   * `transit_time_table` must be set, but not both.
   */
  minTransitDays?:
    | number
    | undefined;
  /**
   * Maximum number of business days that is spent in transit. 0 means same
   * day delivery, 1 means next day delivery. Must be greater than or equal
   * to `min_transit_days`.
   */
  maxTransitDays?:
    | number
    | undefined;
  /**
   * Business days cutoff time definition.
   * If not configured the cutoff time will be defaulted to 8AM PST.
   */
  cutoffTime?:
    | CutoffTime
    | undefined;
  /**
   * Minimum number of business days spent before an order is shipped.
   * 0 means same day shipped, 1 means next day shipped.
   * 'min_handling_days' and 'max_handling_days' should be either set or not set
   * at the same time.
   */
  minHandlingDays?:
    | number
    | undefined;
  /**
   * Maximum number of business days spent before an order is shipped.
   * 0 means same day shipped, 1 means next day shipped.
   * Must be greater than or equal to `min_handling_days`.
   * 'min_handling_days' and 'max_handling_days' should be either set or not set
   * at the same time.
   */
  maxHandlingDays?:
    | number
    | undefined;
  /**
   * Transit time table, number of business days spent in transit based on row
   * and column dimensions. Either `min_transit_days`, `max_transit_days` or
   * `transit_time_table` can be set, but not both.
   */
  transitTimeTable?:
    | TransitTable
    | undefined;
  /**
   * The business days during which orders can be handled.
   * If not provided, Monday to Friday business days will be assumed.
   */
  handlingBusinessDayConfig?:
    | BusinessDayConfig
    | undefined;
  /**
   * The business days during which orders can be in-transit.
   * If not provided, Monday to Friday business days will be assumed.
   */
  transitBusinessDayConfig?:
    | BusinessDayConfig
    | undefined;
  /**
   * Optional. Indicates that the delivery time should be calculated per
   * warehouse (shipping origin location) based on the settings of the selected
   * carrier. When set, no other transit time related field in [delivery
   * time][[google.shopping.content.bundles.ShippingSetting.DeliveryTime] should
   * be set.
   */
  warehouseBasedDeliveryTimes: WarehouseBasedDeliveryTime[];
}

/** Business days cutoff time definition. */
export interface CutoffTime {
  /**
   * Required. Hour of the cutoff time until which an order has to be placed to
   * be processed in the same day.
   */
  hour?:
    | number
    | undefined;
  /**
   * Required. Minute of the cutoff time until which an order has to be placed
   * to be processed in the same day.
   */
  minute?:
    | number
    | undefined;
  /**
   * Required. [Timezone
   * identifier](https://developers.google.com/adwords/api/docs/appendix/codes-formats#timezone-ids)
   * For example "Europe/Zurich".
   */
  timeZone?: string | undefined;
}

/** Business days of the warehouse. */
export interface BusinessDayConfig {
  /**
   * Required. Regular business days.
   * May not be empty.
   */
  businessDays: BusinessDayConfig_Weekday[];
}

export enum BusinessDayConfig_Weekday {
  WEEKDAY_UNSPECIFIED = 0,
  MONDAY = 1,
  TUESDAY = 2,
  WEDNESDAY = 3,
  THURSDAY = 4,
  FRIDAY = 5,
  SATURDAY = 6,
  SUNDAY = 7,
  UNRECOGNIZED = -1,
}

export function businessDayConfig_WeekdayFromJSON(object: any): BusinessDayConfig_Weekday {
  switch (object) {
    case 0:
    case "WEEKDAY_UNSPECIFIED":
      return BusinessDayConfig_Weekday.WEEKDAY_UNSPECIFIED;
    case 1:
    case "MONDAY":
      return BusinessDayConfig_Weekday.MONDAY;
    case 2:
    case "TUESDAY":
      return BusinessDayConfig_Weekday.TUESDAY;
    case 3:
    case "WEDNESDAY":
      return BusinessDayConfig_Weekday.WEDNESDAY;
    case 4:
    case "THURSDAY":
      return BusinessDayConfig_Weekday.THURSDAY;
    case 5:
    case "FRIDAY":
      return BusinessDayConfig_Weekday.FRIDAY;
    case 6:
    case "SATURDAY":
      return BusinessDayConfig_Weekday.SATURDAY;
    case 7:
    case "SUNDAY":
      return BusinessDayConfig_Weekday.SUNDAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BusinessDayConfig_Weekday.UNRECOGNIZED;
  }
}

export function businessDayConfig_WeekdayToJSON(object: BusinessDayConfig_Weekday): string {
  switch (object) {
    case BusinessDayConfig_Weekday.WEEKDAY_UNSPECIFIED:
      return "WEEKDAY_UNSPECIFIED";
    case BusinessDayConfig_Weekday.MONDAY:
      return "MONDAY";
    case BusinessDayConfig_Weekday.TUESDAY:
      return "TUESDAY";
    case BusinessDayConfig_Weekday.WEDNESDAY:
      return "WEDNESDAY";
    case BusinessDayConfig_Weekday.THURSDAY:
      return "THURSDAY";
    case BusinessDayConfig_Weekday.FRIDAY:
      return "FRIDAY";
    case BusinessDayConfig_Weekday.SATURDAY:
      return "SATURDAY";
    case BusinessDayConfig_Weekday.SUNDAY:
      return "SUNDAY";
    case BusinessDayConfig_Weekday.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Indicates that the delivery time should be calculated per warehouse
 * (shipping origin location) based on the settings of the selected carrier.
 * When set, no other transit time related field in `delivery_time` should be
 * set.
 */
export interface WarehouseBasedDeliveryTime {
  /** Required. Carrier, such as `"UPS"` or `"Fedex"`. */
  carrier?:
    | string
    | undefined;
  /**
   * Required. Carrier service, such as `"ground"` or `"2 days"`. The name of
   * the service must be in the eddSupportedServices list.
   */
  carrierService?:
    | string
    | undefined;
  /**
   * Required. Warehouse name. This should match
   * [warehouse][ShippingSetting.warehouses.name]
   */
  warehouse?: string | undefined;
}

/**
 * Shipping rate group definitions. Only the last one is allowed to have an
 * empty `applicable_shipping_labels`, which means
 * "everything else". The other `applicable_shipping_labels` must
 * not overlap.
 */
export interface RateGroup {
  /**
   * Required. A list of [shipping
   * labels](https://support.google.com/merchants/answer/6324504) defining the
   * products to which this rate group applies to. This is a disjunction: only
   * one of the labels has to match for the rate group to apply. May only be
   * empty for the last rate group of a service.
   */
  applicableShippingLabels: string[];
  /**
   * The value of the rate group (For example flat rate $10). Can only be set
   * if `main_table` and `subtables` are not set.
   */
  singleValue?:
    | Value
    | undefined;
  /**
   * A table defining the rate group, when `single_value` is not
   * expressive enough. Can only be set if `single_value` is not
   * set.
   */
  mainTable?:
    | Table
    | undefined;
  /**
   * Optional. A list of subtables referred to by `main_table`. Can only
   * be set if `main_table` is set.
   */
  subtables: Table[];
  /**
   * Optional. A list of carrier rates that can be referred to by
   * `main_table` or `single_value`.
   */
  carrierRates: CarrierRate[];
  /**
   * Optional. Name of the rate group.
   * If set has to be unique within shipping service.
   */
  name?: string | undefined;
}

/**
 * A table defining the rate group, when `single_value` is not
 * expressive enough.
 */
export interface Table {
  /** Name of the table. Required for subtables, ignored for the main table. */
  name?:
    | string
    | undefined;
  /** Required. Headers of the table's rows. */
  rowHeaders?:
    | Headers
    | undefined;
  /**
   * Headers of the table's columns. Optional: if not set then the table has
   * only one dimension.
   */
  columnHeaders?:
    | Headers
    | undefined;
  /**
   * Required. The list of rows that constitute the table. Must have the same
   * length as `row_headers`.
   */
  rows: Row[];
}

/**
 * Transit time table, number of business days spent in transit based on row
 * and column dimensions. Either `min_transit_days`, `max_transit_days` or
 * `transit_time_table` can be set, but not both.
 */
export interface TransitTable {
  /**
   * Required. A list of region names
   * [Region.name][google.shopping.merchant.accounts.v1beta.Region.name] . The
   * last value can be
   * `"all other locations"`. Example:
   * `["zone 1", "zone 2", "all other locations"]`. The referred
   * postal code groups must match the delivery country of the service.
   */
  postalCodeGroupNames: string[];
  /**
   * Required. A list of transit time labels. The last value can be
   * `"all other labels"`. Example:
   * `["food", "electronics", "all other labels"]`.
   */
  transitTimeLabels: string[];
  /**
   * Required. If there's only one dimension set of `postal_code_group_names` or
   * `transit_time_labels`, there are multiple rows each with one value
   * for that dimension. If there are two dimensions, each row corresponds to a
   * `postal_code_group_names`, and columns (values) to a
   * `transit_time_labels`.
   */
  rows: TransitTable_TransitTimeRow[];
}

/**
 * If there's only one dimension set of `postal_code_group_names` or
 * `transit_time_labels`, there are multiple rows each with one value
 * for that dimension. If there are two dimensions, each row corresponds to a
 * `postal_code_group_names`, and columns (values) to a
 * `transit_time_labels`.
 */
export interface TransitTable_TransitTimeRow {
  /** Required. Transit time range (min-max) in business days. */
  values: TransitTable_TransitTimeRow_TransitTimeValue[];
}

/** Transit time range (min-max) in business days. */
export interface TransitTable_TransitTimeRow_TransitTimeValue {
  /**
   * Minimum transit time range in business days. 0 means same
   * day delivery, 1 means next day delivery.
   */
  minTransitDays?:
    | number
    | undefined;
  /** Must be greater than or equal to `min_transit_days`. */
  maxTransitDays?: number | undefined;
}

/** Table of per store minimum order values for the pickup fulfillment type. */
export interface MinimumOrderValueTable {
  /**
   * Required. A list of store code sets sharing the same minimum order value
   * (MOV). At least two sets are required and the last one must be empty, which
   * signifies 'MOV for all other stores'. Each store code can only appear once
   * across all the sets. All prices within a service must have the same
   * currency.
   */
  storeCodeSetWithMovs: MinimumOrderValueTable_StoreCodeSetWithMov[];
}

/**
 * A list of store code sets sharing the same minimum order value. At least
 * two sets are required and the last one must be empty, which signifies
 * 'MOV for all other stores'.
 * Each store code can only appear once across all the sets.
 * All prices within a service must have the same currency.
 */
export interface MinimumOrderValueTable_StoreCodeSetWithMov {
  /** Optional. A list of unique store codes or empty for the catch all. */
  storeCodes: string[];
  /** The minimum order value for the given stores. */
  value?: Price | undefined;
}

/**
 * A non-empty list of row or column headers for a table.
 * Exactly one of `prices`, `weights`,
 * `num_items`, `postal_code_group_names`, or
 * `location` must be set.
 */
export interface Headers {
  /**
   * Required. A list of inclusive order price upper bounds. The last price's
   * value can be infinity by setting price amount_micros = -1. For example
   * `[{"amount_micros": 10000000, "currency_code": "USD"},
   * {"amount_micros": 500000000, "currency_code": "USD"},
   * {"amount_micros": -1, "currency_code": "USD"}]` represents the headers
   * "<= $10", "<= $500", and "> $500". All prices within a service must have
   * the same currency. Must be non-empty. Must be positive except -1. Can only
   * be set if all other fields are not set.
   */
  prices: Price[];
  /**
   * Required. A list of inclusive order weight upper bounds. The last weight's
   * value can be infinity by setting price amount_micros = -1. For example
   * `[{"amount_micros": 10000000, "unit": "kg"}, {"amount_micros": 50000000,
   * "unit": "kg"},
   * {"amount_micros": -1, "unit": "kg"}]` represents the headers
   * "<= 10kg", "<= 50kg", and "> 50kg". All weights within a service must have
   * the same unit. Must be non-empty. Must be positive except -1. Can only be
   * set if all other fields are not set.
   */
  weights: Weight[];
  /**
   * Required. A list of inclusive number of items upper bounds. The last value
   * can be
   * `"infinity"`. For example
   * `["10", "50", "infinity"]` represents the headers
   * "<= 10 items", "<= 50 items", and "> 50 items". Must be non-empty. Can
   * only be set if all other fields are not set.
   */
  numberOfItems: string[];
  /**
   * Required. A list of postal group names. The last value can be
   * `"all other locations"`. Example:
   * `["zone 1", "zone 2", "all other locations"]`. The referred
   * postal code groups must match the delivery country of the service. Must
   * be non-empty. Can only be set if all other fields are not set.
   */
  postalCodeGroupNames: string[];
  /**
   * Required. A list of location ID sets. Must be non-empty. Can only be set if
   * all other fields are not set.
   */
  locations: LocationIdSet[];
}

/**
 * A list of location ID sets. Must be non-empty. Can only be set if all
 * other fields are not set.
 */
export interface LocationIdSet {
  /**
   * Required. A non-empty list of
   * [location
   * IDs](https://developers.google.com/adwords/api/docs/appendix/geotargeting).
   * They must all be of the same location type (For
   * example, state).
   */
  locationIds: string[];
}

/** Include a list of cells. */
export interface Row {
  /**
   * Required. The list of cells that constitute the row. Must have the same
   * length as `columnHeaders` for two-dimensional tables, a length of 1 for
   * one-dimensional tables.
   */
  cells: Value[];
}

/**
 * The single value of a rate group or the value of a rate group table's cell.
 * Exactly one of `no_shipping`, `flat_rate`,
 * `price_percentage`, `carrier_rateName`,
 * `subtable_name` must be set.
 */
export interface Value {
  /**
   * If true, then the product can't be shipped. Must be true when set, can only
   * be set if all other fields are not set.
   */
  noShipping?:
    | boolean
    | undefined;
  /** A flat rate. Can only be set if all other fields are not set. */
  flatRate?:
    | Price
    | undefined;
  /**
   * A percentage of the price represented as a number in decimal notation
   * (For example, `"5.4"`). Can only be set if all other fields are not
   * set.
   */
  pricePercentage?:
    | string
    | undefined;
  /**
   * The name of a carrier rate referring to a carrier rate defined in the
   * same rate group. Can only be set if all other fields are not set.
   */
  carrierRate?:
    | string
    | undefined;
  /**
   * The name of a subtable. Can only be set in table cells (For example, not
   * for single values), and only if all other fields are not set.
   */
  subtable?: string | undefined;
}

/**
 * A list of carrier rates that can be referred to by
 * `main_table` or `single_value`.
 */
export interface CarrierRate {
  /** Required. Name of the carrier rate. Must be unique per rate group. */
  name?:
    | string
    | undefined;
  /** Required. Carrier service, such as `"UPS"` or `"Fedex"`. */
  carrier?:
    | string
    | undefined;
  /** Required. Carrier service, such as `"ground"` or `"2 days"`. */
  carrierService?:
    | string
    | undefined;
  /** Required. Shipping origin for this carrier rate. */
  originPostalCode?:
    | string
    | undefined;
  /**
   * Optional. Multiplicative shipping rate modifier as a number in decimal
   * notation. Can be negative. For example `"5.4"` increases the rate by 5.4%,
   * `"-3"` decreases the rate by 3%.
   */
  percentageAdjustment?:
    | string
    | undefined;
  /**
   * Optional. Additive shipping rate modifier. Can be negative. For example
   * `{ "amount_micros": 1, "currency_code" : "USD" }` adds $1 to the rate,
   * `{ "amount_micros": -3, "currency_code" : "USD" }` removes $3 from the
   * rate.
   */
  flatAdjustment?: Price | undefined;
}

/** Request message for the `GetShippingSetting` method. */
export interface GetShippingSettingsRequest {
  /**
   * Required. The name of the shipping setting to retrieve.
   * Format: `accounts/{account}/shippingsetting`
   */
  name: string;
}

/** Request message for the `InsertShippingSetting` method. */
export interface InsertShippingSettingsRequest {
  /**
   * Required. The account where this product will be inserted.
   * Format: accounts/{account}
   */
  parent: string;
  /** Required. The new version of the account. */
  shippingSetting: ShippingSettings | undefined;
}

function createBaseShippingSettings(): ShippingSettings {
  return { name: "", services: [], warehouses: [], etag: "" };
}

export const ShippingSettings: MessageFns<ShippingSettings> = {
  encode(message: ShippingSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.services) {
      Service.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.warehouses) {
      Warehouse.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(34).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShippingSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShippingSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.services.push(Service.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.warehouses.push(Warehouse.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShippingSettings {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      services: globalThis.Array.isArray(object?.services) ? object.services.map((e: any) => Service.fromJSON(e)) : [],
      warehouses: globalThis.Array.isArray(object?.warehouses)
        ? object.warehouses.map((e: any) => Warehouse.fromJSON(e))
        : [],
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: ShippingSettings): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.services?.length) {
      obj.services = message.services.map((e) => Service.toJSON(e));
    }
    if (message.warehouses?.length) {
      obj.warehouses = message.warehouses.map((e) => Warehouse.toJSON(e));
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<ShippingSettings>): ShippingSettings {
    return ShippingSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShippingSettings>): ShippingSettings {
    const message = createBaseShippingSettings();
    message.name = object.name ?? "";
    message.services = object.services?.map((e) => Service.fromPartial(e)) || [];
    message.warehouses = object.warehouses?.map((e) => Warehouse.fromPartial(e)) || [];
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseService(): Service {
  return {
    serviceName: undefined,
    active: undefined,
    deliveryCountries: [],
    currencyCode: undefined,
    deliveryTime: undefined,
    rateGroups: [],
    shipmentType: undefined,
    minimumOrderValue: undefined,
    minimumOrderValueTable: undefined,
    storeConfig: undefined,
    loyaltyPrograms: [],
  };
}

export const Service: MessageFns<Service> = {
  encode(message: Service, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== undefined) {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.active !== undefined) {
      writer.uint32(16).bool(message.active);
    }
    for (const v of message.deliveryCountries) {
      writer.uint32(26).string(v!);
    }
    if (message.currencyCode !== undefined) {
      writer.uint32(34).string(message.currencyCode);
    }
    if (message.deliveryTime !== undefined) {
      DeliveryTime.encode(message.deliveryTime, writer.uint32(42).fork()).join();
    }
    for (const v of message.rateGroups) {
      RateGroup.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.shipmentType !== undefined) {
      writer.uint32(56).int32(message.shipmentType);
    }
    if (message.minimumOrderValue !== undefined) {
      Price.encode(message.minimumOrderValue, writer.uint32(66).fork()).join();
    }
    if (message.minimumOrderValueTable !== undefined) {
      MinimumOrderValueTable.encode(message.minimumOrderValueTable, writer.uint32(74).fork()).join();
    }
    if (message.storeConfig !== undefined) {
      Service_StoreConfig.encode(message.storeConfig, writer.uint32(82).fork()).join();
    }
    for (const v of message.loyaltyPrograms) {
      Service_LoyaltyProgram.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.active = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deliveryCountries.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.deliveryTime = DeliveryTime.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rateGroups.push(RateGroup.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.shipmentType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.minimumOrderValue = Price.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.minimumOrderValueTable = MinimumOrderValueTable.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.storeConfig = Service_StoreConfig.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.loyaltyPrograms.push(Service_LoyaltyProgram.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : undefined,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : undefined,
      deliveryCountries: globalThis.Array.isArray(object?.deliveryCountries)
        ? object.deliveryCountries.map((e: any) => globalThis.String(e))
        : [],
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : undefined,
      deliveryTime: isSet(object.deliveryTime) ? DeliveryTime.fromJSON(object.deliveryTime) : undefined,
      rateGroups: globalThis.Array.isArray(object?.rateGroups)
        ? object.rateGroups.map((e: any) => RateGroup.fromJSON(e))
        : [],
      shipmentType: isSet(object.shipmentType) ? service_ShipmentTypeFromJSON(object.shipmentType) : undefined,
      minimumOrderValue: isSet(object.minimumOrderValue) ? Price.fromJSON(object.minimumOrderValue) : undefined,
      minimumOrderValueTable: isSet(object.minimumOrderValueTable)
        ? MinimumOrderValueTable.fromJSON(object.minimumOrderValueTable)
        : undefined,
      storeConfig: isSet(object.storeConfig) ? Service_StoreConfig.fromJSON(object.storeConfig) : undefined,
      loyaltyPrograms: globalThis.Array.isArray(object?.loyaltyPrograms)
        ? object.loyaltyPrograms.map((e: any) => Service_LoyaltyProgram.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Service): unknown {
    const obj: any = {};
    if (message.serviceName !== undefined) {
      obj.serviceName = message.serviceName;
    }
    if (message.active !== undefined) {
      obj.active = message.active;
    }
    if (message.deliveryCountries?.length) {
      obj.deliveryCountries = message.deliveryCountries;
    }
    if (message.currencyCode !== undefined) {
      obj.currencyCode = message.currencyCode;
    }
    if (message.deliveryTime !== undefined) {
      obj.deliveryTime = DeliveryTime.toJSON(message.deliveryTime);
    }
    if (message.rateGroups?.length) {
      obj.rateGroups = message.rateGroups.map((e) => RateGroup.toJSON(e));
    }
    if (message.shipmentType !== undefined) {
      obj.shipmentType = service_ShipmentTypeToJSON(message.shipmentType);
    }
    if (message.minimumOrderValue !== undefined) {
      obj.minimumOrderValue = Price.toJSON(message.minimumOrderValue);
    }
    if (message.minimumOrderValueTable !== undefined) {
      obj.minimumOrderValueTable = MinimumOrderValueTable.toJSON(message.minimumOrderValueTable);
    }
    if (message.storeConfig !== undefined) {
      obj.storeConfig = Service_StoreConfig.toJSON(message.storeConfig);
    }
    if (message.loyaltyPrograms?.length) {
      obj.loyaltyPrograms = message.loyaltyPrograms.map((e) => Service_LoyaltyProgram.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Service>): Service {
    return Service.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service>): Service {
    const message = createBaseService();
    message.serviceName = object.serviceName ?? undefined;
    message.active = object.active ?? undefined;
    message.deliveryCountries = object.deliveryCountries?.map((e) => e) || [];
    message.currencyCode = object.currencyCode ?? undefined;
    message.deliveryTime = (object.deliveryTime !== undefined && object.deliveryTime !== null)
      ? DeliveryTime.fromPartial(object.deliveryTime)
      : undefined;
    message.rateGroups = object.rateGroups?.map((e) => RateGroup.fromPartial(e)) || [];
    message.shipmentType = object.shipmentType ?? undefined;
    message.minimumOrderValue = (object.minimumOrderValue !== undefined && object.minimumOrderValue !== null)
      ? Price.fromPartial(object.minimumOrderValue)
      : undefined;
    message.minimumOrderValueTable =
      (object.minimumOrderValueTable !== undefined && object.minimumOrderValueTable !== null)
        ? MinimumOrderValueTable.fromPartial(object.minimumOrderValueTable)
        : undefined;
    message.storeConfig = (object.storeConfig !== undefined && object.storeConfig !== null)
      ? Service_StoreConfig.fromPartial(object.storeConfig)
      : undefined;
    message.loyaltyPrograms = object.loyaltyPrograms?.map((e) => Service_LoyaltyProgram.fromPartial(e)) || [];
    return message;
  },
};

function createBaseService_StoreConfig(): Service_StoreConfig {
  return { storeServiceType: undefined, storeCodes: [], cutoffConfig: undefined, serviceRadius: undefined };
}

export const Service_StoreConfig: MessageFns<Service_StoreConfig> = {
  encode(message: Service_StoreConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.storeServiceType !== undefined) {
      writer.uint32(8).int32(message.storeServiceType);
    }
    for (const v of message.storeCodes) {
      writer.uint32(18).string(v!);
    }
    if (message.cutoffConfig !== undefined) {
      Service_StoreConfig_CutoffConfig.encode(message.cutoffConfig, writer.uint32(26).fork()).join();
    }
    if (message.serviceRadius !== undefined) {
      Distance.encode(message.serviceRadius, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_StoreConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_StoreConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.storeServiceType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.storeCodes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cutoffConfig = Service_StoreConfig_CutoffConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.serviceRadius = Distance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_StoreConfig {
    return {
      storeServiceType: isSet(object.storeServiceType)
        ? service_StoreConfig_StoreServiceTypeFromJSON(object.storeServiceType)
        : undefined,
      storeCodes: globalThis.Array.isArray(object?.storeCodes)
        ? object.storeCodes.map((e: any) => globalThis.String(e))
        : [],
      cutoffConfig: isSet(object.cutoffConfig)
        ? Service_StoreConfig_CutoffConfig.fromJSON(object.cutoffConfig)
        : undefined,
      serviceRadius: isSet(object.serviceRadius) ? Distance.fromJSON(object.serviceRadius) : undefined,
    };
  },

  toJSON(message: Service_StoreConfig): unknown {
    const obj: any = {};
    if (message.storeServiceType !== undefined) {
      obj.storeServiceType = service_StoreConfig_StoreServiceTypeToJSON(message.storeServiceType);
    }
    if (message.storeCodes?.length) {
      obj.storeCodes = message.storeCodes;
    }
    if (message.cutoffConfig !== undefined) {
      obj.cutoffConfig = Service_StoreConfig_CutoffConfig.toJSON(message.cutoffConfig);
    }
    if (message.serviceRadius !== undefined) {
      obj.serviceRadius = Distance.toJSON(message.serviceRadius);
    }
    return obj;
  },

  create(base?: DeepPartial<Service_StoreConfig>): Service_StoreConfig {
    return Service_StoreConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_StoreConfig>): Service_StoreConfig {
    const message = createBaseService_StoreConfig();
    message.storeServiceType = object.storeServiceType ?? undefined;
    message.storeCodes = object.storeCodes?.map((e) => e) || [];
    message.cutoffConfig = (object.cutoffConfig !== undefined && object.cutoffConfig !== null)
      ? Service_StoreConfig_CutoffConfig.fromPartial(object.cutoffConfig)
      : undefined;
    message.serviceRadius = (object.serviceRadius !== undefined && object.serviceRadius !== null)
      ? Distance.fromPartial(object.serviceRadius)
      : undefined;
    return message;
  },
};

function createBaseService_StoreConfig_CutoffConfig(): Service_StoreConfig_CutoffConfig {
  return { localCutoffTime: undefined, storeCloseOffsetHours: undefined, noDeliveryPostCutoff: undefined };
}

export const Service_StoreConfig_CutoffConfig: MessageFns<Service_StoreConfig_CutoffConfig> = {
  encode(message: Service_StoreConfig_CutoffConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.localCutoffTime !== undefined) {
      Service_StoreConfig_CutoffConfig_LocalCutoffTime.encode(message.localCutoffTime, writer.uint32(10).fork()).join();
    }
    if (message.storeCloseOffsetHours !== undefined) {
      writer.uint32(16).int64(message.storeCloseOffsetHours.toString());
    }
    if (message.noDeliveryPostCutoff !== undefined) {
      writer.uint32(24).bool(message.noDeliveryPostCutoff);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_StoreConfig_CutoffConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_StoreConfig_CutoffConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.localCutoffTime = Service_StoreConfig_CutoffConfig_LocalCutoffTime.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.storeCloseOffsetHours = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.noDeliveryPostCutoff = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_StoreConfig_CutoffConfig {
    return {
      localCutoffTime: isSet(object.localCutoffTime)
        ? Service_StoreConfig_CutoffConfig_LocalCutoffTime.fromJSON(object.localCutoffTime)
        : undefined,
      storeCloseOffsetHours: isSet(object.storeCloseOffsetHours)
        ? Long.fromValue(object.storeCloseOffsetHours)
        : undefined,
      noDeliveryPostCutoff: isSet(object.noDeliveryPostCutoff)
        ? globalThis.Boolean(object.noDeliveryPostCutoff)
        : undefined,
    };
  },

  toJSON(message: Service_StoreConfig_CutoffConfig): unknown {
    const obj: any = {};
    if (message.localCutoffTime !== undefined) {
      obj.localCutoffTime = Service_StoreConfig_CutoffConfig_LocalCutoffTime.toJSON(message.localCutoffTime);
    }
    if (message.storeCloseOffsetHours !== undefined) {
      obj.storeCloseOffsetHours = (message.storeCloseOffsetHours || Long.ZERO).toString();
    }
    if (message.noDeliveryPostCutoff !== undefined) {
      obj.noDeliveryPostCutoff = message.noDeliveryPostCutoff;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_StoreConfig_CutoffConfig>): Service_StoreConfig_CutoffConfig {
    return Service_StoreConfig_CutoffConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_StoreConfig_CutoffConfig>): Service_StoreConfig_CutoffConfig {
    const message = createBaseService_StoreConfig_CutoffConfig();
    message.localCutoffTime = (object.localCutoffTime !== undefined && object.localCutoffTime !== null)
      ? Service_StoreConfig_CutoffConfig_LocalCutoffTime.fromPartial(object.localCutoffTime)
      : undefined;
    message.storeCloseOffsetHours =
      (object.storeCloseOffsetHours !== undefined && object.storeCloseOffsetHours !== null)
        ? Long.fromValue(object.storeCloseOffsetHours)
        : undefined;
    message.noDeliveryPostCutoff = object.noDeliveryPostCutoff ?? undefined;
    return message;
  },
};

function createBaseService_StoreConfig_CutoffConfig_LocalCutoffTime(): Service_StoreConfig_CutoffConfig_LocalCutoffTime {
  return { hour: undefined, minute: undefined };
}

export const Service_StoreConfig_CutoffConfig_LocalCutoffTime: MessageFns<
  Service_StoreConfig_CutoffConfig_LocalCutoffTime
> = {
  encode(
    message: Service_StoreConfig_CutoffConfig_LocalCutoffTime,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.hour !== undefined) {
      writer.uint32(8).int64(message.hour.toString());
    }
    if (message.minute !== undefined) {
      writer.uint32(16).int64(message.minute.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_StoreConfig_CutoffConfig_LocalCutoffTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_StoreConfig_CutoffConfig_LocalCutoffTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.hour = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minute = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_StoreConfig_CutoffConfig_LocalCutoffTime {
    return {
      hour: isSet(object.hour) ? Long.fromValue(object.hour) : undefined,
      minute: isSet(object.minute) ? Long.fromValue(object.minute) : undefined,
    };
  },

  toJSON(message: Service_StoreConfig_CutoffConfig_LocalCutoffTime): unknown {
    const obj: any = {};
    if (message.hour !== undefined) {
      obj.hour = (message.hour || Long.ZERO).toString();
    }
    if (message.minute !== undefined) {
      obj.minute = (message.minute || Long.ZERO).toString();
    }
    return obj;
  },

  create(
    base?: DeepPartial<Service_StoreConfig_CutoffConfig_LocalCutoffTime>,
  ): Service_StoreConfig_CutoffConfig_LocalCutoffTime {
    return Service_StoreConfig_CutoffConfig_LocalCutoffTime.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Service_StoreConfig_CutoffConfig_LocalCutoffTime>,
  ): Service_StoreConfig_CutoffConfig_LocalCutoffTime {
    const message = createBaseService_StoreConfig_CutoffConfig_LocalCutoffTime();
    message.hour = (object.hour !== undefined && object.hour !== null) ? Long.fromValue(object.hour) : undefined;
    message.minute = (object.minute !== undefined && object.minute !== null)
      ? Long.fromValue(object.minute)
      : undefined;
    return message;
  },
};

function createBaseService_LoyaltyProgram(): Service_LoyaltyProgram {
  return { programLabel: undefined, loyaltyProgramTiers: [] };
}

export const Service_LoyaltyProgram: MessageFns<Service_LoyaltyProgram> = {
  encode(message: Service_LoyaltyProgram, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programLabel !== undefined) {
      writer.uint32(10).string(message.programLabel);
    }
    for (const v of message.loyaltyProgramTiers) {
      Service_LoyaltyProgram_LoyaltyProgramTiers.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_LoyaltyProgram {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_LoyaltyProgram();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.programLabel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.loyaltyProgramTiers.push(Service_LoyaltyProgram_LoyaltyProgramTiers.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_LoyaltyProgram {
    return {
      programLabel: isSet(object.programLabel) ? globalThis.String(object.programLabel) : undefined,
      loyaltyProgramTiers: globalThis.Array.isArray(object?.loyaltyProgramTiers)
        ? object.loyaltyProgramTiers.map((e: any) => Service_LoyaltyProgram_LoyaltyProgramTiers.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Service_LoyaltyProgram): unknown {
    const obj: any = {};
    if (message.programLabel !== undefined) {
      obj.programLabel = message.programLabel;
    }
    if (message.loyaltyProgramTiers?.length) {
      obj.loyaltyProgramTiers = message.loyaltyProgramTiers.map((e) =>
        Service_LoyaltyProgram_LoyaltyProgramTiers.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<Service_LoyaltyProgram>): Service_LoyaltyProgram {
    return Service_LoyaltyProgram.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_LoyaltyProgram>): Service_LoyaltyProgram {
    const message = createBaseService_LoyaltyProgram();
    message.programLabel = object.programLabel ?? undefined;
    message.loyaltyProgramTiers =
      object.loyaltyProgramTiers?.map((e) => Service_LoyaltyProgram_LoyaltyProgramTiers.fromPartial(e)) || [];
    return message;
  },
};

function createBaseService_LoyaltyProgram_LoyaltyProgramTiers(): Service_LoyaltyProgram_LoyaltyProgramTiers {
  return { tierLabel: undefined };
}

export const Service_LoyaltyProgram_LoyaltyProgramTiers: MessageFns<Service_LoyaltyProgram_LoyaltyProgramTiers> = {
  encode(message: Service_LoyaltyProgram_LoyaltyProgramTiers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tierLabel !== undefined) {
      writer.uint32(10).string(message.tierLabel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_LoyaltyProgram_LoyaltyProgramTiers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_LoyaltyProgram_LoyaltyProgramTiers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tierLabel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_LoyaltyProgram_LoyaltyProgramTiers {
    return { tierLabel: isSet(object.tierLabel) ? globalThis.String(object.tierLabel) : undefined };
  },

  toJSON(message: Service_LoyaltyProgram_LoyaltyProgramTiers): unknown {
    const obj: any = {};
    if (message.tierLabel !== undefined) {
      obj.tierLabel = message.tierLabel;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_LoyaltyProgram_LoyaltyProgramTiers>): Service_LoyaltyProgram_LoyaltyProgramTiers {
    return Service_LoyaltyProgram_LoyaltyProgramTiers.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Service_LoyaltyProgram_LoyaltyProgramTiers>,
  ): Service_LoyaltyProgram_LoyaltyProgramTiers {
    const message = createBaseService_LoyaltyProgram_LoyaltyProgramTiers();
    message.tierLabel = object.tierLabel ?? undefined;
    return message;
  },
};

function createBaseDistance(): Distance {
  return { value: undefined, unit: undefined };
}

export const Distance: MessageFns<Distance> = {
  encode(message: Distance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(8).int64(message.value.toString());
    }
    if (message.unit !== undefined) {
      writer.uint32(16).int32(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Distance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.unit = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Distance {
    return {
      value: isSet(object.value) ? Long.fromValue(object.value) : undefined,
      unit: isSet(object.unit) ? distance_UnitFromJSON(object.unit) : undefined,
    };
  },

  toJSON(message: Distance): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    if (message.unit !== undefined) {
      obj.unit = distance_UnitToJSON(message.unit);
    }
    return obj;
  },

  create(base?: DeepPartial<Distance>): Distance {
    return Distance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Distance>): Distance {
    const message = createBaseDistance();
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : undefined;
    message.unit = object.unit ?? undefined;
    return message;
  },
};

function createBaseWarehouse(): Warehouse {
  return {
    name: undefined,
    shippingAddress: undefined,
    cutoffTime: undefined,
    handlingDays: undefined,
    businessDayConfig: undefined,
  };
}

export const Warehouse: MessageFns<Warehouse> = {
  encode(message: Warehouse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.shippingAddress !== undefined) {
      Address.encode(message.shippingAddress, writer.uint32(18).fork()).join();
    }
    if (message.cutoffTime !== undefined) {
      WarehouseCutoffTime.encode(message.cutoffTime, writer.uint32(26).fork()).join();
    }
    if (message.handlingDays !== undefined) {
      writer.uint32(32).int64(message.handlingDays.toString());
    }
    if (message.businessDayConfig !== undefined) {
      BusinessDayConfig.encode(message.businessDayConfig, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Warehouse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWarehouse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.shippingAddress = Address.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cutoffTime = WarehouseCutoffTime.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.handlingDays = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.businessDayConfig = BusinessDayConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Warehouse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      shippingAddress: isSet(object.shippingAddress) ? Address.fromJSON(object.shippingAddress) : undefined,
      cutoffTime: isSet(object.cutoffTime) ? WarehouseCutoffTime.fromJSON(object.cutoffTime) : undefined,
      handlingDays: isSet(object.handlingDays) ? Long.fromValue(object.handlingDays) : undefined,
      businessDayConfig: isSet(object.businessDayConfig)
        ? BusinessDayConfig.fromJSON(object.businessDayConfig)
        : undefined,
    };
  },

  toJSON(message: Warehouse): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.shippingAddress !== undefined) {
      obj.shippingAddress = Address.toJSON(message.shippingAddress);
    }
    if (message.cutoffTime !== undefined) {
      obj.cutoffTime = WarehouseCutoffTime.toJSON(message.cutoffTime);
    }
    if (message.handlingDays !== undefined) {
      obj.handlingDays = (message.handlingDays || Long.ZERO).toString();
    }
    if (message.businessDayConfig !== undefined) {
      obj.businessDayConfig = BusinessDayConfig.toJSON(message.businessDayConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Warehouse>): Warehouse {
    return Warehouse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Warehouse>): Warehouse {
    const message = createBaseWarehouse();
    message.name = object.name ?? undefined;
    message.shippingAddress = (object.shippingAddress !== undefined && object.shippingAddress !== null)
      ? Address.fromPartial(object.shippingAddress)
      : undefined;
    message.cutoffTime = (object.cutoffTime !== undefined && object.cutoffTime !== null)
      ? WarehouseCutoffTime.fromPartial(object.cutoffTime)
      : undefined;
    message.handlingDays = (object.handlingDays !== undefined && object.handlingDays !== null)
      ? Long.fromValue(object.handlingDays)
      : undefined;
    message.businessDayConfig = (object.businessDayConfig !== undefined && object.businessDayConfig !== null)
      ? BusinessDayConfig.fromPartial(object.businessDayConfig)
      : undefined;
    return message;
  },
};

function createBaseWarehouseCutoffTime(): WarehouseCutoffTime {
  return { hour: undefined, minute: undefined };
}

export const WarehouseCutoffTime: MessageFns<WarehouseCutoffTime> = {
  encode(message: WarehouseCutoffTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hour !== undefined) {
      writer.uint32(8).int32(message.hour);
    }
    if (message.minute !== undefined) {
      writer.uint32(16).int32(message.minute);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WarehouseCutoffTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWarehouseCutoffTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.hour = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minute = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WarehouseCutoffTime {
    return {
      hour: isSet(object.hour) ? globalThis.Number(object.hour) : undefined,
      minute: isSet(object.minute) ? globalThis.Number(object.minute) : undefined,
    };
  },

  toJSON(message: WarehouseCutoffTime): unknown {
    const obj: any = {};
    if (message.hour !== undefined) {
      obj.hour = Math.round(message.hour);
    }
    if (message.minute !== undefined) {
      obj.minute = Math.round(message.minute);
    }
    return obj;
  },

  create(base?: DeepPartial<WarehouseCutoffTime>): WarehouseCutoffTime {
    return WarehouseCutoffTime.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WarehouseCutoffTime>): WarehouseCutoffTime {
    const message = createBaseWarehouseCutoffTime();
    message.hour = object.hour ?? undefined;
    message.minute = object.minute ?? undefined;
    return message;
  },
};

function createBaseAddress(): Address {
  return {
    streetAddress: undefined,
    city: undefined,
    administrativeArea: undefined,
    postalCode: undefined,
    regionCode: undefined,
  };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streetAddress !== undefined) {
      writer.uint32(10).string(message.streetAddress);
    }
    if (message.city !== undefined) {
      writer.uint32(18).string(message.city);
    }
    if (message.administrativeArea !== undefined) {
      writer.uint32(26).string(message.administrativeArea);
    }
    if (message.postalCode !== undefined) {
      writer.uint32(34).string(message.postalCode);
    }
    if (message.regionCode !== undefined) {
      writer.uint32(42).string(message.regionCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streetAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.city = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.administrativeArea = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.regionCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      streetAddress: isSet(object.streetAddress) ? globalThis.String(object.streetAddress) : undefined,
      city: isSet(object.city) ? globalThis.String(object.city) : undefined,
      administrativeArea: isSet(object.administrativeArea) ? globalThis.String(object.administrativeArea) : undefined,
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : undefined,
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : undefined,
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.streetAddress !== undefined) {
      obj.streetAddress = message.streetAddress;
    }
    if (message.city !== undefined) {
      obj.city = message.city;
    }
    if (message.administrativeArea !== undefined) {
      obj.administrativeArea = message.administrativeArea;
    }
    if (message.postalCode !== undefined) {
      obj.postalCode = message.postalCode;
    }
    if (message.regionCode !== undefined) {
      obj.regionCode = message.regionCode;
    }
    return obj;
  },

  create(base?: DeepPartial<Address>): Address {
    return Address.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Address>): Address {
    const message = createBaseAddress();
    message.streetAddress = object.streetAddress ?? undefined;
    message.city = object.city ?? undefined;
    message.administrativeArea = object.administrativeArea ?? undefined;
    message.postalCode = object.postalCode ?? undefined;
    message.regionCode = object.regionCode ?? undefined;
    return message;
  },
};

function createBaseDeliveryTime(): DeliveryTime {
  return {
    minTransitDays: undefined,
    maxTransitDays: undefined,
    cutoffTime: undefined,
    minHandlingDays: undefined,
    maxHandlingDays: undefined,
    transitTimeTable: undefined,
    handlingBusinessDayConfig: undefined,
    transitBusinessDayConfig: undefined,
    warehouseBasedDeliveryTimes: [],
  };
}

export const DeliveryTime: MessageFns<DeliveryTime> = {
  encode(message: DeliveryTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minTransitDays !== undefined) {
      writer.uint32(8).int32(message.minTransitDays);
    }
    if (message.maxTransitDays !== undefined) {
      writer.uint32(16).int32(message.maxTransitDays);
    }
    if (message.cutoffTime !== undefined) {
      CutoffTime.encode(message.cutoffTime, writer.uint32(26).fork()).join();
    }
    if (message.minHandlingDays !== undefined) {
      writer.uint32(32).int32(message.minHandlingDays);
    }
    if (message.maxHandlingDays !== undefined) {
      writer.uint32(40).int32(message.maxHandlingDays);
    }
    if (message.transitTimeTable !== undefined) {
      TransitTable.encode(message.transitTimeTable, writer.uint32(50).fork()).join();
    }
    if (message.handlingBusinessDayConfig !== undefined) {
      BusinessDayConfig.encode(message.handlingBusinessDayConfig, writer.uint32(58).fork()).join();
    }
    if (message.transitBusinessDayConfig !== undefined) {
      BusinessDayConfig.encode(message.transitBusinessDayConfig, writer.uint32(66).fork()).join();
    }
    for (const v of message.warehouseBasedDeliveryTimes) {
      WarehouseBasedDeliveryTime.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliveryTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliveryTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.minTransitDays = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxTransitDays = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cutoffTime = CutoffTime.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.minHandlingDays = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxHandlingDays = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transitTimeTable = TransitTable.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.handlingBusinessDayConfig = BusinessDayConfig.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.transitBusinessDayConfig = BusinessDayConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.warehouseBasedDeliveryTimes.push(WarehouseBasedDeliveryTime.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliveryTime {
    return {
      minTransitDays: isSet(object.minTransitDays) ? globalThis.Number(object.minTransitDays) : undefined,
      maxTransitDays: isSet(object.maxTransitDays) ? globalThis.Number(object.maxTransitDays) : undefined,
      cutoffTime: isSet(object.cutoffTime) ? CutoffTime.fromJSON(object.cutoffTime) : undefined,
      minHandlingDays: isSet(object.minHandlingDays) ? globalThis.Number(object.minHandlingDays) : undefined,
      maxHandlingDays: isSet(object.maxHandlingDays) ? globalThis.Number(object.maxHandlingDays) : undefined,
      transitTimeTable: isSet(object.transitTimeTable) ? TransitTable.fromJSON(object.transitTimeTable) : undefined,
      handlingBusinessDayConfig: isSet(object.handlingBusinessDayConfig)
        ? BusinessDayConfig.fromJSON(object.handlingBusinessDayConfig)
        : undefined,
      transitBusinessDayConfig: isSet(object.transitBusinessDayConfig)
        ? BusinessDayConfig.fromJSON(object.transitBusinessDayConfig)
        : undefined,
      warehouseBasedDeliveryTimes: globalThis.Array.isArray(object?.warehouseBasedDeliveryTimes)
        ? object.warehouseBasedDeliveryTimes.map((e: any) => WarehouseBasedDeliveryTime.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DeliveryTime): unknown {
    const obj: any = {};
    if (message.minTransitDays !== undefined) {
      obj.minTransitDays = Math.round(message.minTransitDays);
    }
    if (message.maxTransitDays !== undefined) {
      obj.maxTransitDays = Math.round(message.maxTransitDays);
    }
    if (message.cutoffTime !== undefined) {
      obj.cutoffTime = CutoffTime.toJSON(message.cutoffTime);
    }
    if (message.minHandlingDays !== undefined) {
      obj.minHandlingDays = Math.round(message.minHandlingDays);
    }
    if (message.maxHandlingDays !== undefined) {
      obj.maxHandlingDays = Math.round(message.maxHandlingDays);
    }
    if (message.transitTimeTable !== undefined) {
      obj.transitTimeTable = TransitTable.toJSON(message.transitTimeTable);
    }
    if (message.handlingBusinessDayConfig !== undefined) {
      obj.handlingBusinessDayConfig = BusinessDayConfig.toJSON(message.handlingBusinessDayConfig);
    }
    if (message.transitBusinessDayConfig !== undefined) {
      obj.transitBusinessDayConfig = BusinessDayConfig.toJSON(message.transitBusinessDayConfig);
    }
    if (message.warehouseBasedDeliveryTimes?.length) {
      obj.warehouseBasedDeliveryTimes = message.warehouseBasedDeliveryTimes.map((e) =>
        WarehouseBasedDeliveryTime.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<DeliveryTime>): DeliveryTime {
    return DeliveryTime.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeliveryTime>): DeliveryTime {
    const message = createBaseDeliveryTime();
    message.minTransitDays = object.minTransitDays ?? undefined;
    message.maxTransitDays = object.maxTransitDays ?? undefined;
    message.cutoffTime = (object.cutoffTime !== undefined && object.cutoffTime !== null)
      ? CutoffTime.fromPartial(object.cutoffTime)
      : undefined;
    message.minHandlingDays = object.minHandlingDays ?? undefined;
    message.maxHandlingDays = object.maxHandlingDays ?? undefined;
    message.transitTimeTable = (object.transitTimeTable !== undefined && object.transitTimeTable !== null)
      ? TransitTable.fromPartial(object.transitTimeTable)
      : undefined;
    message.handlingBusinessDayConfig =
      (object.handlingBusinessDayConfig !== undefined && object.handlingBusinessDayConfig !== null)
        ? BusinessDayConfig.fromPartial(object.handlingBusinessDayConfig)
        : undefined;
    message.transitBusinessDayConfig =
      (object.transitBusinessDayConfig !== undefined && object.transitBusinessDayConfig !== null)
        ? BusinessDayConfig.fromPartial(object.transitBusinessDayConfig)
        : undefined;
    message.warehouseBasedDeliveryTimes =
      object.warehouseBasedDeliveryTimes?.map((e) => WarehouseBasedDeliveryTime.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCutoffTime(): CutoffTime {
  return { hour: undefined, minute: undefined, timeZone: undefined };
}

export const CutoffTime: MessageFns<CutoffTime> = {
  encode(message: CutoffTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hour !== undefined) {
      writer.uint32(8).int32(message.hour);
    }
    if (message.minute !== undefined) {
      writer.uint32(16).int32(message.minute);
    }
    if (message.timeZone !== undefined) {
      writer.uint32(26).string(message.timeZone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CutoffTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCutoffTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.hour = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minute = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timeZone = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CutoffTime {
    return {
      hour: isSet(object.hour) ? globalThis.Number(object.hour) : undefined,
      minute: isSet(object.minute) ? globalThis.Number(object.minute) : undefined,
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : undefined,
    };
  },

  toJSON(message: CutoffTime): unknown {
    const obj: any = {};
    if (message.hour !== undefined) {
      obj.hour = Math.round(message.hour);
    }
    if (message.minute !== undefined) {
      obj.minute = Math.round(message.minute);
    }
    if (message.timeZone !== undefined) {
      obj.timeZone = message.timeZone;
    }
    return obj;
  },

  create(base?: DeepPartial<CutoffTime>): CutoffTime {
    return CutoffTime.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CutoffTime>): CutoffTime {
    const message = createBaseCutoffTime();
    message.hour = object.hour ?? undefined;
    message.minute = object.minute ?? undefined;
    message.timeZone = object.timeZone ?? undefined;
    return message;
  },
};

function createBaseBusinessDayConfig(): BusinessDayConfig {
  return { businessDays: [] };
}

export const BusinessDayConfig: MessageFns<BusinessDayConfig> = {
  encode(message: BusinessDayConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.businessDays) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessDayConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessDayConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.businessDays.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.businessDays.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BusinessDayConfig {
    return {
      businessDays: globalThis.Array.isArray(object?.businessDays)
        ? object.businessDays.map((e: any) => businessDayConfig_WeekdayFromJSON(e))
        : [],
    };
  },

  toJSON(message: BusinessDayConfig): unknown {
    const obj: any = {};
    if (message.businessDays?.length) {
      obj.businessDays = message.businessDays.map((e) => businessDayConfig_WeekdayToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BusinessDayConfig>): BusinessDayConfig {
    return BusinessDayConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BusinessDayConfig>): BusinessDayConfig {
    const message = createBaseBusinessDayConfig();
    message.businessDays = object.businessDays?.map((e) => e) || [];
    return message;
  },
};

function createBaseWarehouseBasedDeliveryTime(): WarehouseBasedDeliveryTime {
  return { carrier: undefined, carrierService: undefined, warehouse: undefined };
}

export const WarehouseBasedDeliveryTime: MessageFns<WarehouseBasedDeliveryTime> = {
  encode(message: WarehouseBasedDeliveryTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.carrier !== undefined) {
      writer.uint32(10).string(message.carrier);
    }
    if (message.carrierService !== undefined) {
      writer.uint32(18).string(message.carrierService);
    }
    if (message.warehouse !== undefined) {
      writer.uint32(26).string(message.warehouse);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WarehouseBasedDeliveryTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWarehouseBasedDeliveryTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.carrier = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.carrierService = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.warehouse = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WarehouseBasedDeliveryTime {
    return {
      carrier: isSet(object.carrier) ? globalThis.String(object.carrier) : undefined,
      carrierService: isSet(object.carrierService) ? globalThis.String(object.carrierService) : undefined,
      warehouse: isSet(object.warehouse) ? globalThis.String(object.warehouse) : undefined,
    };
  },

  toJSON(message: WarehouseBasedDeliveryTime): unknown {
    const obj: any = {};
    if (message.carrier !== undefined) {
      obj.carrier = message.carrier;
    }
    if (message.carrierService !== undefined) {
      obj.carrierService = message.carrierService;
    }
    if (message.warehouse !== undefined) {
      obj.warehouse = message.warehouse;
    }
    return obj;
  },

  create(base?: DeepPartial<WarehouseBasedDeliveryTime>): WarehouseBasedDeliveryTime {
    return WarehouseBasedDeliveryTime.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WarehouseBasedDeliveryTime>): WarehouseBasedDeliveryTime {
    const message = createBaseWarehouseBasedDeliveryTime();
    message.carrier = object.carrier ?? undefined;
    message.carrierService = object.carrierService ?? undefined;
    message.warehouse = object.warehouse ?? undefined;
    return message;
  },
};

function createBaseRateGroup(): RateGroup {
  return {
    applicableShippingLabels: [],
    singleValue: undefined,
    mainTable: undefined,
    subtables: [],
    carrierRates: [],
    name: undefined,
  };
}

export const RateGroup: MessageFns<RateGroup> = {
  encode(message: RateGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.applicableShippingLabels) {
      writer.uint32(10).string(v!);
    }
    if (message.singleValue !== undefined) {
      Value.encode(message.singleValue, writer.uint32(18).fork()).join();
    }
    if (message.mainTable !== undefined) {
      Table.encode(message.mainTable, writer.uint32(26).fork()).join();
    }
    for (const v of message.subtables) {
      Table.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.carrierRates) {
      CarrierRate.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.name !== undefined) {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.applicableShippingLabels.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.singleValue = Value.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mainTable = Table.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subtables.push(Table.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.carrierRates.push(CarrierRate.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateGroup {
    return {
      applicableShippingLabels: globalThis.Array.isArray(object?.applicableShippingLabels)
        ? object.applicableShippingLabels.map((e: any) => globalThis.String(e))
        : [],
      singleValue: isSet(object.singleValue) ? Value.fromJSON(object.singleValue) : undefined,
      mainTable: isSet(object.mainTable) ? Table.fromJSON(object.mainTable) : undefined,
      subtables: globalThis.Array.isArray(object?.subtables) ? object.subtables.map((e: any) => Table.fromJSON(e)) : [],
      carrierRates: globalThis.Array.isArray(object?.carrierRates)
        ? object.carrierRates.map((e: any) => CarrierRate.fromJSON(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
    };
  },

  toJSON(message: RateGroup): unknown {
    const obj: any = {};
    if (message.applicableShippingLabels?.length) {
      obj.applicableShippingLabels = message.applicableShippingLabels;
    }
    if (message.singleValue !== undefined) {
      obj.singleValue = Value.toJSON(message.singleValue);
    }
    if (message.mainTable !== undefined) {
      obj.mainTable = Table.toJSON(message.mainTable);
    }
    if (message.subtables?.length) {
      obj.subtables = message.subtables.map((e) => Table.toJSON(e));
    }
    if (message.carrierRates?.length) {
      obj.carrierRates = message.carrierRates.map((e) => CarrierRate.toJSON(e));
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<RateGroup>): RateGroup {
    return RateGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RateGroup>): RateGroup {
    const message = createBaseRateGroup();
    message.applicableShippingLabels = object.applicableShippingLabels?.map((e) => e) || [];
    message.singleValue = (object.singleValue !== undefined && object.singleValue !== null)
      ? Value.fromPartial(object.singleValue)
      : undefined;
    message.mainTable = (object.mainTable !== undefined && object.mainTable !== null)
      ? Table.fromPartial(object.mainTable)
      : undefined;
    message.subtables = object.subtables?.map((e) => Table.fromPartial(e)) || [];
    message.carrierRates = object.carrierRates?.map((e) => CarrierRate.fromPartial(e)) || [];
    message.name = object.name ?? undefined;
    return message;
  },
};

function createBaseTable(): Table {
  return { name: undefined, rowHeaders: undefined, columnHeaders: undefined, rows: [] };
}

export const Table: MessageFns<Table> = {
  encode(message: Table, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.rowHeaders !== undefined) {
      Headers.encode(message.rowHeaders, writer.uint32(18).fork()).join();
    }
    if (message.columnHeaders !== undefined) {
      Headers.encode(message.columnHeaders, writer.uint32(26).fork()).join();
    }
    for (const v of message.rows) {
      Row.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Table {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rowHeaders = Headers.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.columnHeaders = Headers.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rows.push(Row.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Table {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      rowHeaders: isSet(object.rowHeaders) ? Headers.fromJSON(object.rowHeaders) : undefined,
      columnHeaders: isSet(object.columnHeaders) ? Headers.fromJSON(object.columnHeaders) : undefined,
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => Row.fromJSON(e)) : [],
    };
  },

  toJSON(message: Table): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.rowHeaders !== undefined) {
      obj.rowHeaders = Headers.toJSON(message.rowHeaders);
    }
    if (message.columnHeaders !== undefined) {
      obj.columnHeaders = Headers.toJSON(message.columnHeaders);
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => Row.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Table>): Table {
    return Table.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Table>): Table {
    const message = createBaseTable();
    message.name = object.name ?? undefined;
    message.rowHeaders = (object.rowHeaders !== undefined && object.rowHeaders !== null)
      ? Headers.fromPartial(object.rowHeaders)
      : undefined;
    message.columnHeaders = (object.columnHeaders !== undefined && object.columnHeaders !== null)
      ? Headers.fromPartial(object.columnHeaders)
      : undefined;
    message.rows = object.rows?.map((e) => Row.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransitTable(): TransitTable {
  return { postalCodeGroupNames: [], transitTimeLabels: [], rows: [] };
}

export const TransitTable: MessageFns<TransitTable> = {
  encode(message: TransitTable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.postalCodeGroupNames) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.transitTimeLabels) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.rows) {
      TransitTable_TransitTimeRow.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitTable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.postalCodeGroupNames.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transitTimeLabels.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rows.push(TransitTable_TransitTimeRow.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitTable {
    return {
      postalCodeGroupNames: globalThis.Array.isArray(object?.postalCodeGroupNames)
        ? object.postalCodeGroupNames.map((e: any) => globalThis.String(e))
        : [],
      transitTimeLabels: globalThis.Array.isArray(object?.transitTimeLabels)
        ? object.transitTimeLabels.map((e: any) => globalThis.String(e))
        : [],
      rows: globalThis.Array.isArray(object?.rows)
        ? object.rows.map((e: any) => TransitTable_TransitTimeRow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransitTable): unknown {
    const obj: any = {};
    if (message.postalCodeGroupNames?.length) {
      obj.postalCodeGroupNames = message.postalCodeGroupNames;
    }
    if (message.transitTimeLabels?.length) {
      obj.transitTimeLabels = message.transitTimeLabels;
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => TransitTable_TransitTimeRow.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TransitTable>): TransitTable {
    return TransitTable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransitTable>): TransitTable {
    const message = createBaseTransitTable();
    message.postalCodeGroupNames = object.postalCodeGroupNames?.map((e) => e) || [];
    message.transitTimeLabels = object.transitTimeLabels?.map((e) => e) || [];
    message.rows = object.rows?.map((e) => TransitTable_TransitTimeRow.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransitTable_TransitTimeRow(): TransitTable_TransitTimeRow {
  return { values: [] };
}

export const TransitTable_TransitTimeRow: MessageFns<TransitTable_TransitTimeRow> = {
  encode(message: TransitTable_TransitTimeRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      TransitTable_TransitTimeRow_TransitTimeValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitTable_TransitTimeRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitTable_TransitTimeRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(TransitTable_TransitTimeRow_TransitTimeValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitTable_TransitTimeRow {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => TransitTable_TransitTimeRow_TransitTimeValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransitTable_TransitTimeRow): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => TransitTable_TransitTimeRow_TransitTimeValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TransitTable_TransitTimeRow>): TransitTable_TransitTimeRow {
    return TransitTable_TransitTimeRow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransitTable_TransitTimeRow>): TransitTable_TransitTimeRow {
    const message = createBaseTransitTable_TransitTimeRow();
    message.values = object.values?.map((e) => TransitTable_TransitTimeRow_TransitTimeValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransitTable_TransitTimeRow_TransitTimeValue(): TransitTable_TransitTimeRow_TransitTimeValue {
  return { minTransitDays: undefined, maxTransitDays: undefined };
}

export const TransitTable_TransitTimeRow_TransitTimeValue: MessageFns<TransitTable_TransitTimeRow_TransitTimeValue> = {
  encode(
    message: TransitTable_TransitTimeRow_TransitTimeValue,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.minTransitDays !== undefined) {
      writer.uint32(8).int32(message.minTransitDays);
    }
    if (message.maxTransitDays !== undefined) {
      writer.uint32(16).int32(message.maxTransitDays);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitTable_TransitTimeRow_TransitTimeValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitTable_TransitTimeRow_TransitTimeValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.minTransitDays = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxTransitDays = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitTable_TransitTimeRow_TransitTimeValue {
    return {
      minTransitDays: isSet(object.minTransitDays) ? globalThis.Number(object.minTransitDays) : undefined,
      maxTransitDays: isSet(object.maxTransitDays) ? globalThis.Number(object.maxTransitDays) : undefined,
    };
  },

  toJSON(message: TransitTable_TransitTimeRow_TransitTimeValue): unknown {
    const obj: any = {};
    if (message.minTransitDays !== undefined) {
      obj.minTransitDays = Math.round(message.minTransitDays);
    }
    if (message.maxTransitDays !== undefined) {
      obj.maxTransitDays = Math.round(message.maxTransitDays);
    }
    return obj;
  },

  create(
    base?: DeepPartial<TransitTable_TransitTimeRow_TransitTimeValue>,
  ): TransitTable_TransitTimeRow_TransitTimeValue {
    return TransitTable_TransitTimeRow_TransitTimeValue.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<TransitTable_TransitTimeRow_TransitTimeValue>,
  ): TransitTable_TransitTimeRow_TransitTimeValue {
    const message = createBaseTransitTable_TransitTimeRow_TransitTimeValue();
    message.minTransitDays = object.minTransitDays ?? undefined;
    message.maxTransitDays = object.maxTransitDays ?? undefined;
    return message;
  },
};

function createBaseMinimumOrderValueTable(): MinimumOrderValueTable {
  return { storeCodeSetWithMovs: [] };
}

export const MinimumOrderValueTable: MessageFns<MinimumOrderValueTable> = {
  encode(message: MinimumOrderValueTable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.storeCodeSetWithMovs) {
      MinimumOrderValueTable_StoreCodeSetWithMov.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MinimumOrderValueTable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMinimumOrderValueTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeCodeSetWithMovs.push(MinimumOrderValueTable_StoreCodeSetWithMov.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MinimumOrderValueTable {
    return {
      storeCodeSetWithMovs: globalThis.Array.isArray(object?.storeCodeSetWithMovs)
        ? object.storeCodeSetWithMovs.map((e: any) => MinimumOrderValueTable_StoreCodeSetWithMov.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MinimumOrderValueTable): unknown {
    const obj: any = {};
    if (message.storeCodeSetWithMovs?.length) {
      obj.storeCodeSetWithMovs = message.storeCodeSetWithMovs.map((e) =>
        MinimumOrderValueTable_StoreCodeSetWithMov.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<MinimumOrderValueTable>): MinimumOrderValueTable {
    return MinimumOrderValueTable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MinimumOrderValueTable>): MinimumOrderValueTable {
    const message = createBaseMinimumOrderValueTable();
    message.storeCodeSetWithMovs =
      object.storeCodeSetWithMovs?.map((e) => MinimumOrderValueTable_StoreCodeSetWithMov.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMinimumOrderValueTable_StoreCodeSetWithMov(): MinimumOrderValueTable_StoreCodeSetWithMov {
  return { storeCodes: [], value: undefined };
}

export const MinimumOrderValueTable_StoreCodeSetWithMov: MessageFns<MinimumOrderValueTable_StoreCodeSetWithMov> = {
  encode(message: MinimumOrderValueTable_StoreCodeSetWithMov, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.storeCodes) {
      writer.uint32(10).string(v!);
    }
    if (message.value !== undefined) {
      Price.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MinimumOrderValueTable_StoreCodeSetWithMov {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMinimumOrderValueTable_StoreCodeSetWithMov();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeCodes.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Price.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MinimumOrderValueTable_StoreCodeSetWithMov {
    return {
      storeCodes: globalThis.Array.isArray(object?.storeCodes)
        ? object.storeCodes.map((e: any) => globalThis.String(e))
        : [],
      value: isSet(object.value) ? Price.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MinimumOrderValueTable_StoreCodeSetWithMov): unknown {
    const obj: any = {};
    if (message.storeCodes?.length) {
      obj.storeCodes = message.storeCodes;
    }
    if (message.value !== undefined) {
      obj.value = Price.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MinimumOrderValueTable_StoreCodeSetWithMov>): MinimumOrderValueTable_StoreCodeSetWithMov {
    return MinimumOrderValueTable_StoreCodeSetWithMov.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<MinimumOrderValueTable_StoreCodeSetWithMov>,
  ): MinimumOrderValueTable_StoreCodeSetWithMov {
    const message = createBaseMinimumOrderValueTable_StoreCodeSetWithMov();
    message.storeCodes = object.storeCodes?.map((e) => e) || [];
    message.value = (object.value !== undefined && object.value !== null) ? Price.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseHeaders(): Headers {
  return { prices: [], weights: [], numberOfItems: [], postalCodeGroupNames: [], locations: [] };
}

export const Headers: MessageFns<Headers> = {
  encode(message: Headers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.prices) {
      Price.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.weights) {
      Weight.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.numberOfItems) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.postalCodeGroupNames) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.locations) {
      LocationIdSet.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Headers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeaders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prices.push(Price.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.weights.push(Weight.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.numberOfItems.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.postalCodeGroupNames.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.locations.push(LocationIdSet.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Headers {
    return {
      prices: globalThis.Array.isArray(object?.prices) ? object.prices.map((e: any) => Price.fromJSON(e)) : [],
      weights: globalThis.Array.isArray(object?.weights) ? object.weights.map((e: any) => Weight.fromJSON(e)) : [],
      numberOfItems: globalThis.Array.isArray(object?.numberOfItems)
        ? object.numberOfItems.map((e: any) => globalThis.String(e))
        : [],
      postalCodeGroupNames: globalThis.Array.isArray(object?.postalCodeGroupNames)
        ? object.postalCodeGroupNames.map((e: any) => globalThis.String(e))
        : [],
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => LocationIdSet.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Headers): unknown {
    const obj: any = {};
    if (message.prices?.length) {
      obj.prices = message.prices.map((e) => Price.toJSON(e));
    }
    if (message.weights?.length) {
      obj.weights = message.weights.map((e) => Weight.toJSON(e));
    }
    if (message.numberOfItems?.length) {
      obj.numberOfItems = message.numberOfItems;
    }
    if (message.postalCodeGroupNames?.length) {
      obj.postalCodeGroupNames = message.postalCodeGroupNames;
    }
    if (message.locations?.length) {
      obj.locations = message.locations.map((e) => LocationIdSet.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Headers>): Headers {
    return Headers.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Headers>): Headers {
    const message = createBaseHeaders();
    message.prices = object.prices?.map((e) => Price.fromPartial(e)) || [];
    message.weights = object.weights?.map((e) => Weight.fromPartial(e)) || [];
    message.numberOfItems = object.numberOfItems?.map((e) => e) || [];
    message.postalCodeGroupNames = object.postalCodeGroupNames?.map((e) => e) || [];
    message.locations = object.locations?.map((e) => LocationIdSet.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLocationIdSet(): LocationIdSet {
  return { locationIds: [] };
}

export const LocationIdSet: MessageFns<LocationIdSet> = {
  encode(message: LocationIdSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.locationIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationIdSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationIdSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.locationIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationIdSet {
    return {
      locationIds: globalThis.Array.isArray(object?.locationIds)
        ? object.locationIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: LocationIdSet): unknown {
    const obj: any = {};
    if (message.locationIds?.length) {
      obj.locationIds = message.locationIds;
    }
    return obj;
  },

  create(base?: DeepPartial<LocationIdSet>): LocationIdSet {
    return LocationIdSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationIdSet>): LocationIdSet {
    const message = createBaseLocationIdSet();
    message.locationIds = object.locationIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseRow(): Row {
  return { cells: [] };
}

export const Row: MessageFns<Row> = {
  encode(message: Row, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cells) {
      Value.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Row {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cells.push(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Row {
    return { cells: globalThis.Array.isArray(object?.cells) ? object.cells.map((e: any) => Value.fromJSON(e)) : [] };
  },

  toJSON(message: Row): unknown {
    const obj: any = {};
    if (message.cells?.length) {
      obj.cells = message.cells.map((e) => Value.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Row>): Row {
    return Row.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Row>): Row {
    const message = createBaseRow();
    message.cells = object.cells?.map((e) => Value.fromPartial(e)) || [];
    return message;
  },
};

function createBaseValue(): Value {
  return {
    noShipping: undefined,
    flatRate: undefined,
    pricePercentage: undefined,
    carrierRate: undefined,
    subtable: undefined,
  };
}

export const Value: MessageFns<Value> = {
  encode(message: Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.noShipping !== undefined) {
      writer.uint32(8).bool(message.noShipping);
    }
    if (message.flatRate !== undefined) {
      Price.encode(message.flatRate, writer.uint32(18).fork()).join();
    }
    if (message.pricePercentage !== undefined) {
      writer.uint32(26).string(message.pricePercentage);
    }
    if (message.carrierRate !== undefined) {
      writer.uint32(34).string(message.carrierRate);
    }
    if (message.subtable !== undefined) {
      writer.uint32(42).string(message.subtable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.noShipping = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.flatRate = Price.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pricePercentage = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.carrierRate = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.subtable = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      noShipping: isSet(object.noShipping) ? globalThis.Boolean(object.noShipping) : undefined,
      flatRate: isSet(object.flatRate) ? Price.fromJSON(object.flatRate) : undefined,
      pricePercentage: isSet(object.pricePercentage) ? globalThis.String(object.pricePercentage) : undefined,
      carrierRate: isSet(object.carrierRate) ? globalThis.String(object.carrierRate) : undefined,
      subtable: isSet(object.subtable) ? globalThis.String(object.subtable) : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.noShipping !== undefined) {
      obj.noShipping = message.noShipping;
    }
    if (message.flatRate !== undefined) {
      obj.flatRate = Price.toJSON(message.flatRate);
    }
    if (message.pricePercentage !== undefined) {
      obj.pricePercentage = message.pricePercentage;
    }
    if (message.carrierRate !== undefined) {
      obj.carrierRate = message.carrierRate;
    }
    if (message.subtable !== undefined) {
      obj.subtable = message.subtable;
    }
    return obj;
  },

  create(base?: DeepPartial<Value>): Value {
    return Value.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Value>): Value {
    const message = createBaseValue();
    message.noShipping = object.noShipping ?? undefined;
    message.flatRate = (object.flatRate !== undefined && object.flatRate !== null)
      ? Price.fromPartial(object.flatRate)
      : undefined;
    message.pricePercentage = object.pricePercentage ?? undefined;
    message.carrierRate = object.carrierRate ?? undefined;
    message.subtable = object.subtable ?? undefined;
    return message;
  },
};

function createBaseCarrierRate(): CarrierRate {
  return {
    name: undefined,
    carrier: undefined,
    carrierService: undefined,
    originPostalCode: undefined,
    percentageAdjustment: undefined,
    flatAdjustment: undefined,
  };
}

export const CarrierRate: MessageFns<CarrierRate> = {
  encode(message: CarrierRate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.carrier !== undefined) {
      writer.uint32(18).string(message.carrier);
    }
    if (message.carrierService !== undefined) {
      writer.uint32(26).string(message.carrierService);
    }
    if (message.originPostalCode !== undefined) {
      writer.uint32(34).string(message.originPostalCode);
    }
    if (message.percentageAdjustment !== undefined) {
      writer.uint32(42).string(message.percentageAdjustment);
    }
    if (message.flatAdjustment !== undefined) {
      Price.encode(message.flatAdjustment, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CarrierRate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCarrierRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.carrier = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.carrierService = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.originPostalCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.percentageAdjustment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.flatAdjustment = Price.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CarrierRate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      carrier: isSet(object.carrier) ? globalThis.String(object.carrier) : undefined,
      carrierService: isSet(object.carrierService) ? globalThis.String(object.carrierService) : undefined,
      originPostalCode: isSet(object.originPostalCode) ? globalThis.String(object.originPostalCode) : undefined,
      percentageAdjustment: isSet(object.percentageAdjustment)
        ? globalThis.String(object.percentageAdjustment)
        : undefined,
      flatAdjustment: isSet(object.flatAdjustment) ? Price.fromJSON(object.flatAdjustment) : undefined,
    };
  },

  toJSON(message: CarrierRate): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.carrier !== undefined) {
      obj.carrier = message.carrier;
    }
    if (message.carrierService !== undefined) {
      obj.carrierService = message.carrierService;
    }
    if (message.originPostalCode !== undefined) {
      obj.originPostalCode = message.originPostalCode;
    }
    if (message.percentageAdjustment !== undefined) {
      obj.percentageAdjustment = message.percentageAdjustment;
    }
    if (message.flatAdjustment !== undefined) {
      obj.flatAdjustment = Price.toJSON(message.flatAdjustment);
    }
    return obj;
  },

  create(base?: DeepPartial<CarrierRate>): CarrierRate {
    return CarrierRate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CarrierRate>): CarrierRate {
    const message = createBaseCarrierRate();
    message.name = object.name ?? undefined;
    message.carrier = object.carrier ?? undefined;
    message.carrierService = object.carrierService ?? undefined;
    message.originPostalCode = object.originPostalCode ?? undefined;
    message.percentageAdjustment = object.percentageAdjustment ?? undefined;
    message.flatAdjustment = (object.flatAdjustment !== undefined && object.flatAdjustment !== null)
      ? Price.fromPartial(object.flatAdjustment)
      : undefined;
    return message;
  },
};

function createBaseGetShippingSettingsRequest(): GetShippingSettingsRequest {
  return { name: "" };
}

export const GetShippingSettingsRequest: MessageFns<GetShippingSettingsRequest> = {
  encode(message: GetShippingSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetShippingSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetShippingSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetShippingSettingsRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetShippingSettingsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetShippingSettingsRequest>): GetShippingSettingsRequest {
    return GetShippingSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetShippingSettingsRequest>): GetShippingSettingsRequest {
    const message = createBaseGetShippingSettingsRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseInsertShippingSettingsRequest(): InsertShippingSettingsRequest {
  return { parent: "", shippingSetting: undefined };
}

export const InsertShippingSettingsRequest: MessageFns<InsertShippingSettingsRequest> = {
  encode(message: InsertShippingSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.shippingSetting !== undefined) {
      ShippingSettings.encode(message.shippingSetting, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertShippingSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertShippingSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.shippingSetting = ShippingSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertShippingSettingsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      shippingSetting: isSet(object.shippingSetting) ? ShippingSettings.fromJSON(object.shippingSetting) : undefined,
    };
  },

  toJSON(message: InsertShippingSettingsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.shippingSetting !== undefined) {
      obj.shippingSetting = ShippingSettings.toJSON(message.shippingSetting);
    }
    return obj;
  },

  create(base?: DeepPartial<InsertShippingSettingsRequest>): InsertShippingSettingsRequest {
    return InsertShippingSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsertShippingSettingsRequest>): InsertShippingSettingsRequest {
    const message = createBaseInsertShippingSettingsRequest();
    message.parent = object.parent ?? "";
    message.shippingSetting = (object.shippingSetting !== undefined && object.shippingSetting !== null)
      ? ShippingSettings.fromPartial(object.shippingSetting)
      : undefined;
    return message;
  },
};

/**
 * Service to get method call shipping setting information per Merchant API
 * method.
 */
export type ShippingSettingsServiceDefinition = typeof ShippingSettingsServiceDefinition;
export const ShippingSettingsServiceDefinition = {
  name: "ShippingSettingsService",
  fullName: "google.shopping.merchant.accounts.v1beta.ShippingSettingsService",
  methods: {
    /** Retrieve shipping setting information. */
    getShippingSettings: {
      name: "GetShippingSettings",
      requestType: GetShippingSettingsRequest,
      requestStream: false,
      responseType: ShippingSettings,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              115,
              104,
              105,
              112,
              112,
              105,
              110,
              103,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Replace the shipping setting of a merchant with the request shipping
     * setting. Executing this method requires admin access.
     */
    insertShippingSettings: {
      name: "InsertShippingSettings",
      requestType: InsertShippingSettingsRequest,
      requestStream: false,
      responseType: ShippingSettings,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              80,
              58,
              16,
              115,
              104,
              105,
              112,
              112,
              105,
              110,
              103,
              95,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              34,
              60,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              104,
              105,
              112,
              112,
              105,
              110,
              103,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              58,
              105,
              110,
              115,
              101,
              114,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ShippingSettingsServiceImplementation<CallContextExt = {}> {
  /** Retrieve shipping setting information. */
  getShippingSettings(
    request: GetShippingSettingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ShippingSettings>>;
  /**
   * Replace the shipping setting of a merchant with the request shipping
   * setting. Executing this method requires admin access.
   */
  insertShippingSettings(
    request: InsertShippingSettingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ShippingSettings>>;
}

export interface ShippingSettingsServiceClient<CallOptionsExt = {}> {
  /** Retrieve shipping setting information. */
  getShippingSettings(
    request: DeepPartial<GetShippingSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ShippingSettings>;
  /**
   * Replace the shipping setting of a merchant with the request shipping
   * setting. Executing this method requires admin access.
   */
  insertShippingSettings(
    request: DeepPartial<InsertShippingSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ShippingSettings>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
