// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/shopping/merchant/products/v1beta/products_common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { Interval } from "../../../../type/interval.js";
import {
  Price,
  ReportingContext_ReportingContextEnum,
  reportingContext_ReportingContextEnumFromJSON,
  reportingContext_ReportingContextEnumToJSON,
} from "../../../type/types.js";

export const protobufPackage = "google.shopping.merchant.products.v1beta";

/** The subscription period of the product. */
export enum SubscriptionPeriod {
  /** SUBSCRIPTION_PERIOD_UNSPECIFIED - Indicates that the subscription period is unspecified. */
  SUBSCRIPTION_PERIOD_UNSPECIFIED = 0,
  /** MONTH - Indicates that the subscription period is month. */
  MONTH = 1,
  /** YEAR - Indicates that the subscription period is year. */
  YEAR = 2,
  UNRECOGNIZED = -1,
}

export function subscriptionPeriodFromJSON(object: any): SubscriptionPeriod {
  switch (object) {
    case 0:
    case "SUBSCRIPTION_PERIOD_UNSPECIFIED":
      return SubscriptionPeriod.SUBSCRIPTION_PERIOD_UNSPECIFIED;
    case 1:
    case "MONTH":
      return SubscriptionPeriod.MONTH;
    case 2:
    case "YEAR":
      return SubscriptionPeriod.YEAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubscriptionPeriod.UNRECOGNIZED;
  }
}

export function subscriptionPeriodToJSON(object: SubscriptionPeriod): string {
  switch (object) {
    case SubscriptionPeriod.SUBSCRIPTION_PERIOD_UNSPECIFIED:
      return "SUBSCRIPTION_PERIOD_UNSPECIFIED";
    case SubscriptionPeriod.MONTH:
      return "MONTH";
    case SubscriptionPeriod.YEAR:
      return "YEAR";
    case SubscriptionPeriod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Attributes. */
export interface Attributes {
  /**
   * Set this value to false when the item does not have unique product
   * identifiers appropriate to its category, such as GTIN, MPN, and brand.
   * Defaults to true, if not provided.
   */
  identifierExists?:
    | boolean
    | undefined;
  /**
   * Whether the item is a merchant-defined bundle. A bundle is a custom
   * grouping of different products sold by a merchant for a single price.
   */
  isBundle?:
    | boolean
    | undefined;
  /** Title of the item. */
  title?:
    | string
    | undefined;
  /** Description of the item. */
  description?:
    | string
    | undefined;
  /** URL directly linking to your item's page on your online store. */
  link?:
    | string
    | undefined;
  /** URL for the mobile-optimized version of your item's landing page. */
  mobileLink?:
    | string
    | undefined;
  /** URL for the canonical version of your item's landing page. */
  canonicalLink?:
    | string
    | undefined;
  /** URL of an image of the item. */
  imageLink?:
    | string
    | undefined;
  /** Additional URLs of images of the item. */
  additionalImageLinks: string[];
  /**
   * Date on which the item should expire, as specified upon insertion, in
   * [ISO
   * 8601](http://en.wikipedia.org/wiki/ISO_8601) format. The actual
   * expiration date is exposed in `productstatuses` as
   * [googleExpirationDate](https://support.google.com/merchants/answer/6324499)
   * and might be earlier if `expirationDate` is too far in the future.
   */
  expirationDate:
    | Date
    | undefined;
  /**
   * The date time when an offer becomes visible in search results across
   * Googleâ€™s YouTube surfaces, in [ISO
   * 8601](http://en.wikipedia.org/wiki/ISO_8601) format. See [Disclosure date](
   * https://support.google.com/merchants/answer/13034208) for more information.
   */
  disclosureDate:
    | Date
    | undefined;
  /** Set to true if the item is targeted towards adults. */
  adult?:
    | boolean
    | undefined;
  /**
   * Target [age group](https://support.google.com/merchants/answer/6324463) of
   * the item.
   */
  ageGroup?:
    | string
    | undefined;
  /** Availability status of the item. */
  availability?:
    | string
    | undefined;
  /**
   * The day a pre-ordered product becomes available for delivery, in [ISO
   * 8601](http://en.wikipedia.org/wiki/ISO_8601) format.
   */
  availabilityDate:
    | Date
    | undefined;
  /** Brand of the item. */
  brand?:
    | string
    | undefined;
  /** Color of the item. */
  color?:
    | string
    | undefined;
  /** Condition or state of the item. */
  condition?:
    | string
    | undefined;
  /** Target gender of the item. */
  gender?:
    | string
    | undefined;
  /**
   * Google's category of the item (see [Google product
   * taxonomy](https://support.google.com/merchants/answer/1705911)). When
   * querying products, this field will contain the user provided value. There
   * is currently no way to get back the auto assigned google product
   * categories through the API.
   */
  googleProductCategory?:
    | string
    | undefined;
  /**
   * Global Trade Item Number
   * ([GTIN](https://support.google.com/merchants/answer/188494#gtin)) of the
   * item.
   */
  gtin?:
    | string
    | undefined;
  /** Shared identifier for all variants of the same product. */
  itemGroupId?:
    | string
    | undefined;
  /** The material of which the item is made. */
  material?:
    | string
    | undefined;
  /**
   * Manufacturer Part Number
   * ([MPN](https://support.google.com/merchants/answer/188494#mpn)) of the
   * item.
   */
  mpn?:
    | string
    | undefined;
  /** The item's pattern (for example, polka dots). */
  pattern?:
    | string
    | undefined;
  /** Price of the item. */
  price:
    | Price
    | undefined;
  /** Number and amount of installments to pay for an item. */
  installment:
    | Installment
    | undefined;
  /**
   * Number of periods (months or years) and amount of payment per period
   * for an item with an associated subscription contract.
   */
  subscriptionCost:
    | SubscriptionCost
    | undefined;
  /** Loyalty points that users receive after purchasing the item. Japan only. */
  loyaltyPoints:
    | LoyaltyPoints
    | undefined;
  /**
   * A list of loyalty program information that is used to surface loyalty
   * benefits (for example, better pricing, points, etc) to the user of this
   * item.
   */
  loyaltyPrograms: LoyaltyProgram[];
  /**
   * Categories of the item (formatted as in [product data
   * specification](https://support.google.com/merchants/answer/188494#product_type)).
   */
  productTypes: string[];
  /** Advertised sale price of the item. */
  salePrice:
    | Price
    | undefined;
  /**
   * Date range during which the item is on sale (see [product data
   * specification](https://support.google.com/merchants/answer/188494#sale_price_effective_date)).
   */
  salePriceEffectiveDate:
    | Interval
    | undefined;
  /**
   * The quantity of the product that is available for selling on Google.
   * Supported only for online products.
   */
  sellOnGoogleQuantity?:
    | Long
    | undefined;
  /**
   * The height of the product in the units provided. The value must be
   * between
   * 0 (exclusive) and 3000 (inclusive).
   */
  productHeight:
    | ProductDimension
    | undefined;
  /**
   * The length of the product in the units provided. The value must be
   * between 0 (exclusive) and 3000 (inclusive).
   */
  productLength:
    | ProductDimension
    | undefined;
  /**
   * The width of the product in the units provided. The value must be between
   * 0 (exclusive) and 3000 (inclusive).
   */
  productWidth:
    | ProductDimension
    | undefined;
  /**
   * The weight of the product in the units provided. The value must be
   * between 0 (exclusive) and 2000 (inclusive).
   */
  productWeight:
    | ProductWeight
    | undefined;
  /** Shipping rules. */
  shipping: Shipping[];
  /** Conditions to be met for a product to have free shipping. */
  freeShippingThreshold: FreeShippingThreshold[];
  /** Weight of the item for shipping. */
  shippingWeight:
    | ShippingWeight
    | undefined;
  /** Length of the item for shipping. */
  shippingLength:
    | ShippingDimension
    | undefined;
  /** Width of the item for shipping. */
  shippingWidth:
    | ShippingDimension
    | undefined;
  /** Height of the item for shipping. */
  shippingHeight:
    | ShippingDimension
    | undefined;
  /** Maximal product handling time (in business days). */
  maxHandlingTime?:
    | Long
    | undefined;
  /** Minimal product handling time (in business days). */
  minHandlingTime?:
    | Long
    | undefined;
  /**
   * The shipping label of the product, used to group product in account-level
   * shipping rules.
   */
  shippingLabel?:
    | string
    | undefined;
  /**
   * The transit time label of the product, used to group product in
   * account-level transit time tables.
   */
  transitTimeLabel?:
    | string
    | undefined;
  /**
   * Size of the item. Only one value is allowed. For variants with different
   * sizes, insert a separate product for each size with the same
   * `itemGroupId` value (see
   * [https://support.google.com/merchants/answer/6324492](size definition)).
   */
  size?:
    | string
    | undefined;
  /** System in which the size is specified. Recommended for apparel items. */
  sizeSystem?:
    | string
    | undefined;
  /**
   * The cut of the item. It can be used to represent combined size types for
   * apparel items. Maximum two of size types can be provided (see
   * [https://support.google.com/merchants/answer/6324497](size type)).
   */
  sizeTypes: string[];
  /** Tax information. */
  taxes: Tax[];
  /**
   * The tax category of the product, used to configure detailed tax nexus
   * in account-level tax settings.
   */
  taxCategory?:
    | string
    | undefined;
  /** The energy efficiency class as defined in EU directive 2010/30/EU. */
  energyEfficiencyClass?:
    | string
    | undefined;
  /** The energy efficiency class as defined in EU directive 2010/30/EU. */
  minEnergyEfficiencyClass?:
    | string
    | undefined;
  /** The energy efficiency class as defined in EU directive 2010/30/EU. */
  maxEnergyEfficiencyClass?:
    | string
    | undefined;
  /** The measure and dimension of an item. */
  unitPricingMeasure:
    | UnitPricingMeasure
    | undefined;
  /** The preference of the denominator of the unit price. */
  unitPricingBaseMeasure:
    | UnitPricingBaseMeasure
    | undefined;
  /** The number of identical products in a merchant-defined multipack. */
  multipack?:
    | Long
    | undefined;
  /**
   * Used to group items in an arbitrary way. Only for CPA%, discouraged
   * otherwise.
   */
  adsGrouping?:
    | string
    | undefined;
  /** Similar to ads_grouping, but only works on CPC. */
  adsLabels: string[];
  /**
   * Allows advertisers to override the item URL when the product is shown
   * within the context of Product ads.
   */
  adsRedirect?:
    | string
    | undefined;
  /** Cost of goods sold. Used for gross profit reporting. */
  costOfGoodsSold:
    | Price
    | undefined;
  /** Technical specification or additional product details. */
  productDetails: ProductDetail[];
  /** Bullet points describing the most relevant highlights of a product. */
  productHighlights: string[];
  /** An identifier for an item for dynamic remarketing campaigns. */
  displayAdsId?:
    | string
    | undefined;
  /** Advertiser-specified recommendations. */
  displayAdsSimilarIds: string[];
  /** Title of an item for dynamic remarketing campaigns. */
  displayAdsTitle?:
    | string
    | undefined;
  /**
   * URL directly to your item's landing page for dynamic remarketing
   * campaigns.
   */
  displayAdsLink?:
    | string
    | undefined;
  /** Offer margin for dynamic remarketing campaigns. */
  displayAdsValue?:
    | number
    | undefined;
  /** The unique ID of a promotion. */
  promotionIds: string[];
  /** The pick up option for the item. */
  pickupMethod?:
    | string
    | undefined;
  /** Item store pickup timeline. */
  pickupSla?:
    | string
    | undefined;
  /** Link template for merchant hosted local storefront. */
  linkTemplate?:
    | string
    | undefined;
  /**
   * Link template for merchant hosted local storefront optimized for mobile
   * devices.
   */
  mobileLinkTemplate?:
    | string
    | undefined;
  /** Custom label 0 for custom grouping of items in a Shopping campaign. */
  customLabel0?:
    | string
    | undefined;
  /** Custom label 1 for custom grouping of items in a Shopping campaign. */
  customLabel1?:
    | string
    | undefined;
  /** Custom label 2 for custom grouping of items in a Shopping campaign. */
  customLabel2?:
    | string
    | undefined;
  /** Custom label 3 for custom grouping of items in a Shopping campaign. */
  customLabel3?:
    | string
    | undefined;
  /** Custom label 4 for custom grouping of items in a Shopping campaign. */
  customLabel4?:
    | string
    | undefined;
  /**
   * The list of destinations to include for this target (corresponds to
   * checked check boxes in Merchant Center). Default destinations are always
   * included unless provided in `excludedDestinations`.
   */
  includedDestinations: string[];
  /**
   * The list of destinations to exclude for this target (corresponds to
   * unchecked check boxes in Merchant Center).
   */
  excludedDestinations: string[];
  /**
   * List of country codes (ISO 3166-1 alpha-2) to exclude the offer from
   * Shopping Ads destination.
   * Countries from this list are removed from countries configured
   * in data source settings.
   */
  shoppingAdsExcludedCountries: string[];
  /**
   * Required for multi-seller accounts. Use this attribute if you're a
   * marketplace uploading products for various sellers to your multi-seller
   * account.
   */
  externalSellerId?:
    | string
    | undefined;
  /**
   * Publication of this item will be temporarily
   * [paused](https://support.google.com/merchants/answer/11909930).
   */
  pause?:
    | string
    | undefined;
  /**
   * Additional URLs of lifestyle images of the item, used to explicitly
   * identify images that showcase your item in a real-world context. See the
   * [Help Center article](https://support.google.com/merchants/answer/9103186)
   * for more information.
   */
  lifestyleImageLinks: string[];
  /** Extra fields to export to the Cloud Retail program. */
  cloudExportAdditionalProperties: CloudExportAdditionalProperties[];
  /**
   * URL of the 3D image of the item. See the
   * [Help Center article](https://support.google.com/merchants/answer/13674896)
   * for more information.
   */
  virtualModelLink?:
    | string
    | undefined;
  /**
   * Product Certifications, for example for energy efficiency labeling of
   * products recorded in the [EU EPREL](https://eprel.ec.europa.eu/screen/home)
   * database. See the [Help
   * Center](https://support.google.com/merchants/answer/13528839)
   * article for more information.
   */
  certifications: Certification[];
  /** Structured title, for algorithmically (AI)-generated titles. */
  structuredTitle?:
    | ProductStructuredTitle
    | undefined;
  /** Structured description, for algorithmically (AI)-generated descriptions. */
  structuredDescription?:
    | ProductStructuredDescription
    | undefined;
  /**
   * A safeguard in the "Automated Discounts"
   * (https://support.google.com/merchants/answer/10295759) and
   * "Dynamic Promotions"
   * (https://support.google.com/merchants/answer/13949249) projects,
   * ensuring that discounts on merchants' offers do not fall below this value,
   * thereby preserving the offer's value and profitability.
   */
  autoPricingMinPrice: Price | undefined;
}

/** The Tax of the product. */
export interface Tax {
  /** The percentage of tax rate that applies to the item price. */
  rate: number;
  /**
   * The country within which the item is taxed, specified as a [CLDR
   * territory
   * code](http://www.unicode.org/repos/cldr/tags/latest/common/main/en.xml).
   */
  country: string;
  /** The geographic region to which the tax rate applies. */
  region: string;
  /** Set to true if tax is charged on shipping. */
  taxShip: boolean;
  /**
   * The numeric ID of a location that the tax rate applies to as defined in
   * the [AdWords
   * API](https://developers.google.com/adwords/api/docs/appendix/geotargeting).
   */
  locationId: Long;
  /**
   * The postal code range that the tax rate applies to, represented by
   * a ZIP code, a ZIP code prefix using * wildcard, a range between two ZIP
   * codes or two ZIP code prefixes of equal length.
   * Examples: 94114, 94*, 94002-95460, 94*-95*.
   */
  postalCode: string;
}

/** The ShippingWeight of the product. */
export interface ShippingWeight {
  /**
   * The weight of the product used to calculate the shipping cost of the
   * item.
   */
  value: number;
  /** The unit of value. */
  unit: string;
}

/** The ShippingDimension of the product. */
export interface ShippingDimension {
  /**
   * The dimension of the product used to calculate the shipping cost of the
   * item.
   */
  value: number;
  /** The unit of value. */
  unit: string;
}

/** The UnitPricingBaseMeasure of the product. */
export interface UnitPricingBaseMeasure {
  /** The denominator of the unit price. */
  value: Long;
  /** The unit of the denominator. */
  unit: string;
}

/** The UnitPricingMeasure of the product. */
export interface UnitPricingMeasure {
  /** The measure of an item. */
  value: number;
  /** The unit of the measure. */
  unit: string;
}

/** The SubscriptionCost of the product. */
export interface SubscriptionCost {
  /**
   * The type of subscription period.
   * Supported values are:
   *   * "`month`"
   *   * "`year`"
   */
  period: SubscriptionPeriod;
  /** The number of subscription periods the buyer has to pay. */
  periodLength: Long;
  /** The amount the buyer has to pay per subscription period. */
  amount: Price | undefined;
}

/** A message that represents installment. */
export interface Installment {
  /** The number of installments the buyer has to pay. */
  months: Long;
  /** The amount the buyer has to pay per month. */
  amount:
    | Price
    | undefined;
  /** The up-front down payment amount the buyer has to pay. */
  downpayment?:
    | Price
    | undefined;
  /**
   * Type of installment payments.
   * Supported values are:
   *   * "`finance`"
   *   * "`lease`"
   */
  creditType?: string | undefined;
}

/** A message that represents loyalty points. */
export interface LoyaltyPoints {
  /**
   * Name of loyalty points program. It is recommended to limit the name to
   * 12 full-width characters or 24 Roman characters.
   */
  name: string;
  /** The retailer's loyalty points in absolute value. */
  pointsValue: Long;
  /**
   * The ratio of a point when converted to currency. Google assumes currency
   * based on Merchant Center settings. If ratio is left out, it defaults to
   * 1.0.
   */
  ratio: number;
}

/** A message that represents loyalty program. */
export interface LoyaltyProgram {
  /**
   * The label of the loyalty program. This is an internal label that uniquely
   * identifies the relationship between a merchant entity and a loyalty
   * program entity. The label must be provided so that the system can associate
   * the assets below (for example, price and points) with a merchant. The
   * corresponding program must be linked to the merchant account.
   */
  programLabel?:
    | string
    | undefined;
  /**
   * The label of the tier within the loyalty program.
   * Must match one of the labels within the program.
   */
  tierLabel?:
    | string
    | undefined;
  /**
   * The price for members of the given tier, that is, the instant discount
   * price. Must be smaller or equal to the regular price.
   */
  price?:
    | Price
    | undefined;
  /** The cashback that can be used for future purchases. */
  cashbackForFutureUse?:
    | Price
    | undefined;
  /** The amount of loyalty points earned on a purchase. */
  loyaltyPoints?: Long | undefined;
}

/** The Shipping of the product. */
export interface Shipping {
  /** Fixed shipping price, represented as a number. */
  price:
    | Price
    | undefined;
  /**
   * The [CLDR territory
   * code](http://www.unicode.org/repos/cldr/tags/latest/common/main/en.xml)
   * of the country to which an item will ship.
   */
  country: string;
  /**
   * The geographic region to which a shipping rate applies.
   * See [region](https://support.google.com/merchants/answer/6324484) for more
   * information.
   */
  region: string;
  /** A free-form description of the service class or delivery speed. */
  service: string;
  /**
   * The numeric ID of a location that the shipping rate applies to as
   * defined in the [AdWords
   * API](https://developers.google.com/adwords/api/docs/appendix/geotargeting).
   */
  locationId: Long;
  /**
   * The location where the shipping is applicable, represented by a
   * location group name.
   */
  locationGroupName: string;
  /**
   * The postal code range that the shipping rate applies to, represented by
   * a postal code, a postal code prefix followed by a * wildcard, a range
   * between two postal codes or two postal code prefixes of equal length.
   */
  postalCode: string;
  /**
   * Minimum handling time (inclusive) between when the order is received and
   * shipped in business days. 0 means that the order is shipped on the same
   * day as it is received if it happens before the cut-off time.
   * [minHandlingTime][google.shopping.content.bundles.Products.Shipping.min_handling_time]
   * can only be present together with
   * [maxHandlingTime][google.shopping.content.bundles.Products.Shipping.max_handling_time];
   * but it is not required if
   * [maxHandlingTime][google.shopping.content.bundles.Products.Shipping.max_handling_time]
   * is present.
   */
  minHandlingTime?:
    | Long
    | undefined;
  /**
   * Maximum handling time (inclusive) between when the order is received and
   * shipped in business days. 0 means that the order is shipped on the same
   * day as it is received if it happens before the cut-off time. Both
   * [maxHandlingTime][google.shopping.content.bundles.Products.Shipping.max_handling_time]
   * and
   * [maxTransitTime][google.shopping.content.bundles.Products.Shipping.max_transit_time]
   * are required if providing shipping speeds.
   * [minHandlingTime][google.shopping.content.bundles.Products.Shipping.min_handling_time]
   * is optional if
   * [maxHandlingTime][google.shopping.content.bundles.Products.Shipping.max_handling_time]
   * is present.
   */
  maxHandlingTime?:
    | Long
    | undefined;
  /**
   * Minimum transit time (inclusive) between when the order has shipped and
   * when it is delivered in business days. 0 means that the order is
   * delivered on the same day as it ships.
   * [minTransitTime][google.shopping.content.bundles.Products.Shipping.min_transit_time]
   * can only be present together with
   * [maxTransitTime][google.shopping.content.bundles.Products.Shipping.max_transit_time];
   * but it is not required if
   * [maxTransitTime][google.shopping.content.bundles.Products.Shipping.max_transit_time]
   * is present.
   */
  minTransitTime?:
    | Long
    | undefined;
  /**
   * Maximum transit time (inclusive) between when the order has shipped and
   * when it is delivered in business days. 0 means that the order is
   * delivered on the same day as it ships. Both
   * [maxHandlingTime][google.shopping.content.bundles.Products.Shipping.max_handling_time]
   * and
   * [maxTransitTime][google.shopping.content.bundles.Products.Shipping.max_transit_time]
   * are required if providing shipping speeds.
   * [minTransitTime][google.shopping.content.bundles.Products.Shipping.min_transit_time]
   * is optional if
   * [maxTransitTime][google.shopping.content.bundles.Products.Shipping.max_transit_time]
   * is present.
   */
  maxTransitTime?: Long | undefined;
}

/** Conditions to be met for a product to have free shipping. */
export interface FreeShippingThreshold {
  /**
   * The [CLDR territory
   * code](http://www.unicode.org/repos/cldr/tags/latest/common/main/en.xml)
   * of the country to which an item will ship.
   */
  country?:
    | string
    | undefined;
  /**
   * The minimum product price for the shipping cost to become free. Represented
   * as a number.
   */
  priceThreshold?: Price | undefined;
}

/** The product details. */
export interface ProductDetail {
  /** The section header used to group a set of product details. */
  sectionName: string;
  /** The name of the product detail. */
  attributeName: string;
  /** The value of the product detail. */
  attributeValue: string;
}

/**
 * Product
 * [certification](https://support.google.com/merchants/answer/13528839),
 * initially introduced for EU energy efficiency labeling compliance using the
 * EU EPREL database.
 */
export interface Certification {
  /**
   * The certification authority, for example "European_Commission".
   * Maximum length is 2000 characters.
   */
  certificationAuthority?:
    | string
    | undefined;
  /**
   * The name of the certification, for example "EPREL".
   * Maximum length is 2000 characters.
   */
  certificationName?:
    | string
    | undefined;
  /**
   * The certification code.
   * Maximum length is 2000 characters.
   */
  certificationCode?:
    | string
    | undefined;
  /**
   * The certification value (also known as class, level or grade), for example
   * "A+", "C", "gold".
   * Maximum length is 2000 characters.
   */
  certificationValue?: string | undefined;
}

/** Structured title, for algorithmically (AI)-generated titles. */
export interface ProductStructuredTitle {
  /**
   * The digital source type, for example "trained_algorithmic_media".
   * Following [IPTC](https://cv.iptc.org/newscodes/digitalsourcetype).
   * Maximum length is 40 characters.
   */
  digitalSourceType?:
    | string
    | undefined;
  /**
   * The title text
   * Maximum length is 150 characters
   */
  content?: string | undefined;
}

/** Structured description, for algorithmically (AI)-generated descriptions. */
export interface ProductStructuredDescription {
  /**
   * The digital source type, for example "trained_algorithmic_media".
   * Following [IPTC](https://cv.iptc.org/newscodes/digitalsourcetype).
   * Maximum length is 40 characters.
   */
  digitalSourceType?:
    | string
    | undefined;
  /**
   * The description text
   * Maximum length is 5000 characters
   */
  content?: string | undefined;
}

/** The dimension of the product. */
export interface ProductDimension {
  /**
   * Required. The dimension value represented as a number. The value can have a
   * maximum precision of four decimal places.
   */
  value: number;
  /**
   * Required. The dimension units.
   * Acceptable values are:
   *   * "`in`"
   *   * "`cm`"
   */
  unit: string;
}

/** The weight of the product. */
export interface ProductWeight {
  /**
   * Required. The weight represented as a number. The weight can have a maximum
   * precision of four decimal places.
   */
  value: number;
  /**
   * Required. The weight unit.
   * Acceptable values are:
   *   * "`g`"
   *   * "`kg`"
   *   * "`oz`"
   *   * "`lb`"
   */
  unit: string;
}

/**
 * The status of a product, data validation issues, that is, information about
 * a product computed asynchronously.
 */
export interface ProductStatus {
  /** The intended destinations for the product. */
  destinationStatuses: ProductStatus_DestinationStatus[];
  /** A list of all issues associated with the product. */
  itemLevelIssues: ProductStatus_ItemLevelIssue[];
  /**
   * Date on which the item has been created, in [ISO
   * 8601](http://en.wikipedia.org/wiki/ISO_8601) format.
   */
  creationDate:
    | Date
    | undefined;
  /**
   * Date on which the item has been last updated, in [ISO
   * 8601](http://en.wikipedia.org/wiki/ISO_8601) format.
   */
  lastUpdateDate:
    | Date
    | undefined;
  /**
   * Date on which the item expires, in [ISO
   * 8601](http://en.wikipedia.org/wiki/ISO_8601) format.
   */
  googleExpirationDate: Date | undefined;
}

/** The destination status of the product status. */
export interface ProductStatus_DestinationStatus {
  /** The name of the reporting context. */
  reportingContext: ReportingContext_ReportingContextEnum;
  /** List of country codes (ISO 3166-1 alpha-2) where the offer is approved. */
  approvedCountries: string[];
  /**
   * List of country codes (ISO 3166-1 alpha-2) where the offer is pending
   * approval.
   */
  pendingCountries: string[];
  /**
   * List of country codes (ISO 3166-1 alpha-2) where the offer is
   * disapproved.
   */
  disapprovedCountries: string[];
}

/** The ItemLevelIssue of the product status. */
export interface ProductStatus_ItemLevelIssue {
  /** The error code of the issue. */
  code: string;
  /** How this issue affects serving of the offer. */
  severity: ProductStatus_ItemLevelIssue_Severity;
  /** Whether the issue can be resolved by the merchant. */
  resolution: string;
  /** The attribute's name, if the issue is caused by a single attribute. */
  attribute: string;
  /** The reporting context the issue applies to. */
  reportingContext: ReportingContext_ReportingContextEnum;
  /** A short issue description in English. */
  description: string;
  /** A detailed issue description in English. */
  detail: string;
  /** The URL of a web page to help with resolving this issue. */
  documentation: string;
  /**
   * List of country codes (ISO 3166-1 alpha-2) where issue applies to the
   * offer.
   */
  applicableCountries: string[];
}

/** How the issue affects the serving of the product. */
export enum ProductStatus_ItemLevelIssue_Severity {
  /** SEVERITY_UNSPECIFIED - Not specified. */
  SEVERITY_UNSPECIFIED = 0,
  /**
   * NOT_IMPACTED - This issue represents a warning and does not have a direct affect
   * on the product.
   */
  NOT_IMPACTED = 1,
  /**
   * DEMOTED - The product is demoted and most likely have limited performance
   * in search results
   */
  DEMOTED = 2,
  /** DISAPPROVED - Issue disapproves the product. */
  DISAPPROVED = 3,
  UNRECOGNIZED = -1,
}

export function productStatus_ItemLevelIssue_SeverityFromJSON(object: any): ProductStatus_ItemLevelIssue_Severity {
  switch (object) {
    case 0:
    case "SEVERITY_UNSPECIFIED":
      return ProductStatus_ItemLevelIssue_Severity.SEVERITY_UNSPECIFIED;
    case 1:
    case "NOT_IMPACTED":
      return ProductStatus_ItemLevelIssue_Severity.NOT_IMPACTED;
    case 2:
    case "DEMOTED":
      return ProductStatus_ItemLevelIssue_Severity.DEMOTED;
    case 3:
    case "DISAPPROVED":
      return ProductStatus_ItemLevelIssue_Severity.DISAPPROVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProductStatus_ItemLevelIssue_Severity.UNRECOGNIZED;
  }
}

export function productStatus_ItemLevelIssue_SeverityToJSON(object: ProductStatus_ItemLevelIssue_Severity): string {
  switch (object) {
    case ProductStatus_ItemLevelIssue_Severity.SEVERITY_UNSPECIFIED:
      return "SEVERITY_UNSPECIFIED";
    case ProductStatus_ItemLevelIssue_Severity.NOT_IMPACTED:
      return "NOT_IMPACTED";
    case ProductStatus_ItemLevelIssue_Severity.DEMOTED:
      return "DEMOTED";
    case ProductStatus_ItemLevelIssue_Severity.DISAPPROVED:
      return "DISAPPROVED";
    case ProductStatus_ItemLevelIssue_Severity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Product property for the Cloud Retail API.
 * For example, properties for a TV product could be "Screen-Resolution" or
 * "Screen-Size".
 */
export interface CloudExportAdditionalProperties {
  /**
   * Name of the given property. For example,
   * "Screen-Resolution" for a TV product. Maximum string size is 256
   * characters.
   */
  propertyName?:
    | string
    | undefined;
  /**
   * Text value of the given property. For example,
   * "8K(UHD)" could be a text value for a TV product. Maximum
   * repeatedness of this value is 400. Values are stored in an arbitrary but
   * consistent order. Maximum string size is 256 characters.
   */
  textValue: string[];
  /**
   * Boolean value of the given property. For example for a TV product,
   * "True" or "False" if the screen is UHD.
   */
  boolValue?:
    | boolean
    | undefined;
  /**
   * Integer values of the given property. For example, 1080 for a TV
   * product's Screen Resolution. Maximum repeatedness of this value
   * is 400. Values are stored in an arbitrary but consistent order.
   */
  intValue: Long[];
  /**
   * Float values of the given property. For example for a TV product
   * 1.2345. Maximum repeatedness of this value is 400. Values
   * are stored in an arbitrary but consistent order.
   */
  floatValue: number[];
  /**
   * Minimum float value of the given property. For example for a TV
   * product 1.00.
   */
  minValue?:
    | number
    | undefined;
  /**
   * Maximum float value of the given property. For example for a TV
   * product 100.00.
   */
  maxValue?:
    | number
    | undefined;
  /**
   * Unit of the given property. For example, "Pixels" for a TV product. Maximum
   * string size is 256B.
   */
  unitCode?: string | undefined;
}

function createBaseAttributes(): Attributes {
  return {
    identifierExists: undefined,
    isBundle: undefined,
    title: undefined,
    description: undefined,
    link: undefined,
    mobileLink: undefined,
    canonicalLink: undefined,
    imageLink: undefined,
    additionalImageLinks: [],
    expirationDate: undefined,
    disclosureDate: undefined,
    adult: undefined,
    ageGroup: undefined,
    availability: undefined,
    availabilityDate: undefined,
    brand: undefined,
    color: undefined,
    condition: undefined,
    gender: undefined,
    googleProductCategory: undefined,
    gtin: undefined,
    itemGroupId: undefined,
    material: undefined,
    mpn: undefined,
    pattern: undefined,
    price: undefined,
    installment: undefined,
    subscriptionCost: undefined,
    loyaltyPoints: undefined,
    loyaltyPrograms: [],
    productTypes: [],
    salePrice: undefined,
    salePriceEffectiveDate: undefined,
    sellOnGoogleQuantity: undefined,
    productHeight: undefined,
    productLength: undefined,
    productWidth: undefined,
    productWeight: undefined,
    shipping: [],
    freeShippingThreshold: [],
    shippingWeight: undefined,
    shippingLength: undefined,
    shippingWidth: undefined,
    shippingHeight: undefined,
    maxHandlingTime: undefined,
    minHandlingTime: undefined,
    shippingLabel: undefined,
    transitTimeLabel: undefined,
    size: undefined,
    sizeSystem: undefined,
    sizeTypes: [],
    taxes: [],
    taxCategory: undefined,
    energyEfficiencyClass: undefined,
    minEnergyEfficiencyClass: undefined,
    maxEnergyEfficiencyClass: undefined,
    unitPricingMeasure: undefined,
    unitPricingBaseMeasure: undefined,
    multipack: undefined,
    adsGrouping: undefined,
    adsLabels: [],
    adsRedirect: undefined,
    costOfGoodsSold: undefined,
    productDetails: [],
    productHighlights: [],
    displayAdsId: undefined,
    displayAdsSimilarIds: [],
    displayAdsTitle: undefined,
    displayAdsLink: undefined,
    displayAdsValue: undefined,
    promotionIds: [],
    pickupMethod: undefined,
    pickupSla: undefined,
    linkTemplate: undefined,
    mobileLinkTemplate: undefined,
    customLabel0: undefined,
    customLabel1: undefined,
    customLabel2: undefined,
    customLabel3: undefined,
    customLabel4: undefined,
    includedDestinations: [],
    excludedDestinations: [],
    shoppingAdsExcludedCountries: [],
    externalSellerId: undefined,
    pause: undefined,
    lifestyleImageLinks: [],
    cloudExportAdditionalProperties: [],
    virtualModelLink: undefined,
    certifications: [],
    structuredTitle: undefined,
    structuredDescription: undefined,
    autoPricingMinPrice: undefined,
  };
}

export const Attributes: MessageFns<Attributes> = {
  encode(message: Attributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identifierExists !== undefined) {
      writer.uint32(32).bool(message.identifierExists);
    }
    if (message.isBundle !== undefined) {
      writer.uint32(40).bool(message.isBundle);
    }
    if (message.title !== undefined) {
      writer.uint32(50).string(message.title);
    }
    if (message.description !== undefined) {
      writer.uint32(58).string(message.description);
    }
    if (message.link !== undefined) {
      writer.uint32(66).string(message.link);
    }
    if (message.mobileLink !== undefined) {
      writer.uint32(74).string(message.mobileLink);
    }
    if (message.canonicalLink !== undefined) {
      writer.uint32(82).string(message.canonicalLink);
    }
    if (message.imageLink !== undefined) {
      writer.uint32(90).string(message.imageLink);
    }
    for (const v of message.additionalImageLinks) {
      writer.uint32(98).string(v!);
    }
    if (message.expirationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.expirationDate), writer.uint32(130).fork()).join();
    }
    if (message.disclosureDate !== undefined) {
      Timestamp.encode(toTimestamp(message.disclosureDate), writer.uint32(634).fork()).join();
    }
    if (message.adult !== undefined) {
      writer.uint32(136).bool(message.adult);
    }
    if (message.ageGroup !== undefined) {
      writer.uint32(146).string(message.ageGroup);
    }
    if (message.availability !== undefined) {
      writer.uint32(154).string(message.availability);
    }
    if (message.availabilityDate !== undefined) {
      Timestamp.encode(toTimestamp(message.availabilityDate), writer.uint32(162).fork()).join();
    }
    if (message.brand !== undefined) {
      writer.uint32(170).string(message.brand);
    }
    if (message.color !== undefined) {
      writer.uint32(178).string(message.color);
    }
    if (message.condition !== undefined) {
      writer.uint32(186).string(message.condition);
    }
    if (message.gender !== undefined) {
      writer.uint32(194).string(message.gender);
    }
    if (message.googleProductCategory !== undefined) {
      writer.uint32(202).string(message.googleProductCategory);
    }
    if (message.gtin !== undefined) {
      writer.uint32(210).string(message.gtin);
    }
    if (message.itemGroupId !== undefined) {
      writer.uint32(218).string(message.itemGroupId);
    }
    if (message.material !== undefined) {
      writer.uint32(226).string(message.material);
    }
    if (message.mpn !== undefined) {
      writer.uint32(234).string(message.mpn);
    }
    if (message.pattern !== undefined) {
      writer.uint32(242).string(message.pattern);
    }
    if (message.price !== undefined) {
      Price.encode(message.price, writer.uint32(250).fork()).join();
    }
    if (message.installment !== undefined) {
      Installment.encode(message.installment, writer.uint32(258).fork()).join();
    }
    if (message.subscriptionCost !== undefined) {
      SubscriptionCost.encode(message.subscriptionCost, writer.uint32(266).fork()).join();
    }
    if (message.loyaltyPoints !== undefined) {
      LoyaltyPoints.encode(message.loyaltyPoints, writer.uint32(274).fork()).join();
    }
    for (const v of message.loyaltyPrograms) {
      LoyaltyProgram.encode(v!, writer.uint32(1090).fork()).join();
    }
    for (const v of message.productTypes) {
      writer.uint32(282).string(v!);
    }
    if (message.salePrice !== undefined) {
      Price.encode(message.salePrice, writer.uint32(290).fork()).join();
    }
    if (message.salePriceEffectiveDate !== undefined) {
      Interval.encode(message.salePriceEffectiveDate, writer.uint32(298).fork()).join();
    }
    if (message.sellOnGoogleQuantity !== undefined) {
      writer.uint32(304).int64(message.sellOnGoogleQuantity.toString());
    }
    if (message.productHeight !== undefined) {
      ProductDimension.encode(message.productHeight, writer.uint32(954).fork()).join();
    }
    if (message.productLength !== undefined) {
      ProductDimension.encode(message.productLength, writer.uint32(962).fork()).join();
    }
    if (message.productWidth !== undefined) {
      ProductDimension.encode(message.productWidth, writer.uint32(970).fork()).join();
    }
    if (message.productWeight !== undefined) {
      ProductWeight.encode(message.productWeight, writer.uint32(978).fork()).join();
    }
    for (const v of message.shipping) {
      Shipping.encode(v!, writer.uint32(314).fork()).join();
    }
    for (const v of message.freeShippingThreshold) {
      FreeShippingThreshold.encode(v!, writer.uint32(1082).fork()).join();
    }
    if (message.shippingWeight !== undefined) {
      ShippingWeight.encode(message.shippingWeight, writer.uint32(322).fork()).join();
    }
    if (message.shippingLength !== undefined) {
      ShippingDimension.encode(message.shippingLength, writer.uint32(330).fork()).join();
    }
    if (message.shippingWidth !== undefined) {
      ShippingDimension.encode(message.shippingWidth, writer.uint32(338).fork()).join();
    }
    if (message.shippingHeight !== undefined) {
      ShippingDimension.encode(message.shippingHeight, writer.uint32(346).fork()).join();
    }
    if (message.maxHandlingTime !== undefined) {
      writer.uint32(352).int64(message.maxHandlingTime.toString());
    }
    if (message.minHandlingTime !== undefined) {
      writer.uint32(360).int64(message.minHandlingTime.toString());
    }
    if (message.shippingLabel !== undefined) {
      writer.uint32(370).string(message.shippingLabel);
    }
    if (message.transitTimeLabel !== undefined) {
      writer.uint32(378).string(message.transitTimeLabel);
    }
    if (message.size !== undefined) {
      writer.uint32(386).string(message.size);
    }
    if (message.sizeSystem !== undefined) {
      writer.uint32(394).string(message.sizeSystem);
    }
    for (const v of message.sizeTypes) {
      writer.uint32(402).string(v!);
    }
    for (const v of message.taxes) {
      Tax.encode(v!, writer.uint32(410).fork()).join();
    }
    if (message.taxCategory !== undefined) {
      writer.uint32(418).string(message.taxCategory);
    }
    if (message.energyEfficiencyClass !== undefined) {
      writer.uint32(426).string(message.energyEfficiencyClass);
    }
    if (message.minEnergyEfficiencyClass !== undefined) {
      writer.uint32(434).string(message.minEnergyEfficiencyClass);
    }
    if (message.maxEnergyEfficiencyClass !== undefined) {
      writer.uint32(442).string(message.maxEnergyEfficiencyClass);
    }
    if (message.unitPricingMeasure !== undefined) {
      UnitPricingMeasure.encode(message.unitPricingMeasure, writer.uint32(450).fork()).join();
    }
    if (message.unitPricingBaseMeasure !== undefined) {
      UnitPricingBaseMeasure.encode(message.unitPricingBaseMeasure, writer.uint32(458).fork()).join();
    }
    if (message.multipack !== undefined) {
      writer.uint32(464).int64(message.multipack.toString());
    }
    if (message.adsGrouping !== undefined) {
      writer.uint32(474).string(message.adsGrouping);
    }
    for (const v of message.adsLabels) {
      writer.uint32(482).string(v!);
    }
    if (message.adsRedirect !== undefined) {
      writer.uint32(490).string(message.adsRedirect);
    }
    if (message.costOfGoodsSold !== undefined) {
      Price.encode(message.costOfGoodsSold, writer.uint32(498).fork()).join();
    }
    for (const v of message.productDetails) {
      ProductDetail.encode(v!, writer.uint32(506).fork()).join();
    }
    for (const v of message.productHighlights) {
      writer.uint32(514).string(v!);
    }
    if (message.displayAdsId !== undefined) {
      writer.uint32(522).string(message.displayAdsId);
    }
    for (const v of message.displayAdsSimilarIds) {
      writer.uint32(530).string(v!);
    }
    if (message.displayAdsTitle !== undefined) {
      writer.uint32(538).string(message.displayAdsTitle);
    }
    if (message.displayAdsLink !== undefined) {
      writer.uint32(546).string(message.displayAdsLink);
    }
    if (message.displayAdsValue !== undefined) {
      writer.uint32(553).double(message.displayAdsValue);
    }
    for (const v of message.promotionIds) {
      writer.uint32(562).string(v!);
    }
    if (message.pickupMethod !== undefined) {
      writer.uint32(642).string(message.pickupMethod);
    }
    if (message.pickupSla !== undefined) {
      writer.uint32(650).string(message.pickupSla);
    }
    if (message.linkTemplate !== undefined) {
      writer.uint32(658).string(message.linkTemplate);
    }
    if (message.mobileLinkTemplate !== undefined) {
      writer.uint32(666).string(message.mobileLinkTemplate);
    }
    if (message.customLabel0 !== undefined) {
      writer.uint32(570).string(message.customLabel0);
    }
    if (message.customLabel1 !== undefined) {
      writer.uint32(578).string(message.customLabel1);
    }
    if (message.customLabel2 !== undefined) {
      writer.uint32(586).string(message.customLabel2);
    }
    if (message.customLabel3 !== undefined) {
      writer.uint32(594).string(message.customLabel3);
    }
    if (message.customLabel4 !== undefined) {
      writer.uint32(602).string(message.customLabel4);
    }
    for (const v of message.includedDestinations) {
      writer.uint32(610).string(v!);
    }
    for (const v of message.excludedDestinations) {
      writer.uint32(618).string(v!);
    }
    for (const v of message.shoppingAdsExcludedCountries) {
      writer.uint32(626).string(v!);
    }
    if (message.externalSellerId !== undefined) {
      writer.uint32(10).string(message.externalSellerId);
    }
    if (message.pause !== undefined) {
      writer.uint32(106).string(message.pause);
    }
    for (const v of message.lifestyleImageLinks) {
      writer.uint32(114).string(v!);
    }
    for (const v of message.cloudExportAdditionalProperties) {
      CloudExportAdditionalProperties.encode(v!, writer.uint32(674).fork()).join();
    }
    if (message.virtualModelLink !== undefined) {
      writer.uint32(1042).string(message.virtualModelLink);
    }
    for (const v of message.certifications) {
      Certification.encode(v!, writer.uint32(986).fork()).join();
    }
    if (message.structuredTitle !== undefined) {
      ProductStructuredTitle.encode(message.structuredTitle, writer.uint32(1058).fork()).join();
    }
    if (message.structuredDescription !== undefined) {
      ProductStructuredDescription.encode(message.structuredDescription, writer.uint32(1066).fork()).join();
    }
    if (message.autoPricingMinPrice !== undefined) {
      Price.encode(message.autoPricingMinPrice, writer.uint32(994).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 32) {
            break;
          }

          message.identifierExists = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isBundle = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.title = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.link = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.mobileLink = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.canonicalLink = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.imageLink = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.additionalImageLinks.push(reader.string());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.expirationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 79:
          if (tag !== 634) {
            break;
          }

          message.disclosureDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.adult = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.ageGroup = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.availability = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.availabilityDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.brand = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.color = reader.string();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.gender = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.googleProductCategory = reader.string();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.gtin = reader.string();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.itemGroupId = reader.string();
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.material = reader.string();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.mpn = reader.string();
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.pattern = reader.string();
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.price = Price.decode(reader, reader.uint32());
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.installment = Installment.decode(reader, reader.uint32());
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.subscriptionCost = SubscriptionCost.decode(reader, reader.uint32());
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.loyaltyPoints = LoyaltyPoints.decode(reader, reader.uint32());
          continue;
        case 136:
          if (tag !== 1090) {
            break;
          }

          message.loyaltyPrograms.push(LoyaltyProgram.decode(reader, reader.uint32()));
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.productTypes.push(reader.string());
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.salePrice = Price.decode(reader, reader.uint32());
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.salePriceEffectiveDate = Interval.decode(reader, reader.uint32());
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }

          message.sellOnGoogleQuantity = Long.fromString(reader.int64().toString());
          continue;
        case 119:
          if (tag !== 954) {
            break;
          }

          message.productHeight = ProductDimension.decode(reader, reader.uint32());
          continue;
        case 120:
          if (tag !== 962) {
            break;
          }

          message.productLength = ProductDimension.decode(reader, reader.uint32());
          continue;
        case 121:
          if (tag !== 970) {
            break;
          }

          message.productWidth = ProductDimension.decode(reader, reader.uint32());
          continue;
        case 122:
          if (tag !== 978) {
            break;
          }

          message.productWeight = ProductWeight.decode(reader, reader.uint32());
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.shipping.push(Shipping.decode(reader, reader.uint32()));
          continue;
        case 135:
          if (tag !== 1082) {
            break;
          }

          message.freeShippingThreshold.push(FreeShippingThreshold.decode(reader, reader.uint32()));
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.shippingWeight = ShippingWeight.decode(reader, reader.uint32());
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.shippingLength = ShippingDimension.decode(reader, reader.uint32());
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.shippingWidth = ShippingDimension.decode(reader, reader.uint32());
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.shippingHeight = ShippingDimension.decode(reader, reader.uint32());
          continue;
        case 44:
          if (tag !== 352) {
            break;
          }

          message.maxHandlingTime = Long.fromString(reader.int64().toString());
          continue;
        case 45:
          if (tag !== 360) {
            break;
          }

          message.minHandlingTime = Long.fromString(reader.int64().toString());
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }

          message.shippingLabel = reader.string();
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }

          message.transitTimeLabel = reader.string();
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }

          message.size = reader.string();
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }

          message.sizeSystem = reader.string();
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.sizeTypes.push(reader.string());
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.taxes.push(Tax.decode(reader, reader.uint32()));
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }

          message.taxCategory = reader.string();
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }

          message.energyEfficiencyClass = reader.string();
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }

          message.minEnergyEfficiencyClass = reader.string();
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }

          message.maxEnergyEfficiencyClass = reader.string();
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }

          message.unitPricingMeasure = UnitPricingMeasure.decode(reader, reader.uint32());
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }

          message.unitPricingBaseMeasure = UnitPricingBaseMeasure.decode(reader, reader.uint32());
          continue;
        case 58:
          if (tag !== 464) {
            break;
          }

          message.multipack = Long.fromString(reader.int64().toString());
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }

          message.adsGrouping = reader.string();
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }

          message.adsLabels.push(reader.string());
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }

          message.adsRedirect = reader.string();
          continue;
        case 62:
          if (tag !== 498) {
            break;
          }

          message.costOfGoodsSold = Price.decode(reader, reader.uint32());
          continue;
        case 63:
          if (tag !== 506) {
            break;
          }

          message.productDetails.push(ProductDetail.decode(reader, reader.uint32()));
          continue;
        case 64:
          if (tag !== 514) {
            break;
          }

          message.productHighlights.push(reader.string());
          continue;
        case 65:
          if (tag !== 522) {
            break;
          }

          message.displayAdsId = reader.string();
          continue;
        case 66:
          if (tag !== 530) {
            break;
          }

          message.displayAdsSimilarIds.push(reader.string());
          continue;
        case 67:
          if (tag !== 538) {
            break;
          }

          message.displayAdsTitle = reader.string();
          continue;
        case 68:
          if (tag !== 546) {
            break;
          }

          message.displayAdsLink = reader.string();
          continue;
        case 69:
          if (tag !== 553) {
            break;
          }

          message.displayAdsValue = reader.double();
          continue;
        case 70:
          if (tag !== 562) {
            break;
          }

          message.promotionIds.push(reader.string());
          continue;
        case 80:
          if (tag !== 642) {
            break;
          }

          message.pickupMethod = reader.string();
          continue;
        case 81:
          if (tag !== 650) {
            break;
          }

          message.pickupSla = reader.string();
          continue;
        case 82:
          if (tag !== 658) {
            break;
          }

          message.linkTemplate = reader.string();
          continue;
        case 83:
          if (tag !== 666) {
            break;
          }

          message.mobileLinkTemplate = reader.string();
          continue;
        case 71:
          if (tag !== 570) {
            break;
          }

          message.customLabel0 = reader.string();
          continue;
        case 72:
          if (tag !== 578) {
            break;
          }

          message.customLabel1 = reader.string();
          continue;
        case 73:
          if (tag !== 586) {
            break;
          }

          message.customLabel2 = reader.string();
          continue;
        case 74:
          if (tag !== 594) {
            break;
          }

          message.customLabel3 = reader.string();
          continue;
        case 75:
          if (tag !== 602) {
            break;
          }

          message.customLabel4 = reader.string();
          continue;
        case 76:
          if (tag !== 610) {
            break;
          }

          message.includedDestinations.push(reader.string());
          continue;
        case 77:
          if (tag !== 618) {
            break;
          }

          message.excludedDestinations.push(reader.string());
          continue;
        case 78:
          if (tag !== 626) {
            break;
          }

          message.shoppingAdsExcludedCountries.push(reader.string());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalSellerId = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.pause = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.lifestyleImageLinks.push(reader.string());
          continue;
        case 84:
          if (tag !== 674) {
            break;
          }

          message.cloudExportAdditionalProperties.push(CloudExportAdditionalProperties.decode(reader, reader.uint32()));
          continue;
        case 130:
          if (tag !== 1042) {
            break;
          }

          message.virtualModelLink = reader.string();
          continue;
        case 123:
          if (tag !== 986) {
            break;
          }

          message.certifications.push(Certification.decode(reader, reader.uint32()));
          continue;
        case 132:
          if (tag !== 1058) {
            break;
          }

          message.structuredTitle = ProductStructuredTitle.decode(reader, reader.uint32());
          continue;
        case 133:
          if (tag !== 1066) {
            break;
          }

          message.structuredDescription = ProductStructuredDescription.decode(reader, reader.uint32());
          continue;
        case 124:
          if (tag !== 994) {
            break;
          }

          message.autoPricingMinPrice = Price.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attributes {
    return {
      identifierExists: isSet(object.identifierExists) ? globalThis.Boolean(object.identifierExists) : undefined,
      isBundle: isSet(object.isBundle) ? globalThis.Boolean(object.isBundle) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      link: isSet(object.link) ? globalThis.String(object.link) : undefined,
      mobileLink: isSet(object.mobileLink) ? globalThis.String(object.mobileLink) : undefined,
      canonicalLink: isSet(object.canonicalLink) ? globalThis.String(object.canonicalLink) : undefined,
      imageLink: isSet(object.imageLink) ? globalThis.String(object.imageLink) : undefined,
      additionalImageLinks: globalThis.Array.isArray(object?.additionalImageLinks)
        ? object.additionalImageLinks.map((e: any) => globalThis.String(e))
        : [],
      expirationDate: isSet(object.expirationDate) ? fromJsonTimestamp(object.expirationDate) : undefined,
      disclosureDate: isSet(object.disclosureDate) ? fromJsonTimestamp(object.disclosureDate) : undefined,
      adult: isSet(object.adult) ? globalThis.Boolean(object.adult) : undefined,
      ageGroup: isSet(object.ageGroup) ? globalThis.String(object.ageGroup) : undefined,
      availability: isSet(object.availability) ? globalThis.String(object.availability) : undefined,
      availabilityDate: isSet(object.availabilityDate) ? fromJsonTimestamp(object.availabilityDate) : undefined,
      brand: isSet(object.brand) ? globalThis.String(object.brand) : undefined,
      color: isSet(object.color) ? globalThis.String(object.color) : undefined,
      condition: isSet(object.condition) ? globalThis.String(object.condition) : undefined,
      gender: isSet(object.gender) ? globalThis.String(object.gender) : undefined,
      googleProductCategory: isSet(object.googleProductCategory)
        ? globalThis.String(object.googleProductCategory)
        : undefined,
      gtin: isSet(object.gtin) ? globalThis.String(object.gtin) : undefined,
      itemGroupId: isSet(object.itemGroupId) ? globalThis.String(object.itemGroupId) : undefined,
      material: isSet(object.material) ? globalThis.String(object.material) : undefined,
      mpn: isSet(object.mpn) ? globalThis.String(object.mpn) : undefined,
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : undefined,
      price: isSet(object.price) ? Price.fromJSON(object.price) : undefined,
      installment: isSet(object.installment) ? Installment.fromJSON(object.installment) : undefined,
      subscriptionCost: isSet(object.subscriptionCost) ? SubscriptionCost.fromJSON(object.subscriptionCost) : undefined,
      loyaltyPoints: isSet(object.loyaltyPoints) ? LoyaltyPoints.fromJSON(object.loyaltyPoints) : undefined,
      loyaltyPrograms: globalThis.Array.isArray(object?.loyaltyPrograms)
        ? object.loyaltyPrograms.map((e: any) => LoyaltyProgram.fromJSON(e))
        : [],
      productTypes: globalThis.Array.isArray(object?.productTypes)
        ? object.productTypes.map((e: any) => globalThis.String(e))
        : [],
      salePrice: isSet(object.salePrice) ? Price.fromJSON(object.salePrice) : undefined,
      salePriceEffectiveDate: isSet(object.salePriceEffectiveDate)
        ? Interval.fromJSON(object.salePriceEffectiveDate)
        : undefined,
      sellOnGoogleQuantity: isSet(object.sellOnGoogleQuantity)
        ? Long.fromValue(object.sellOnGoogleQuantity)
        : undefined,
      productHeight: isSet(object.productHeight) ? ProductDimension.fromJSON(object.productHeight) : undefined,
      productLength: isSet(object.productLength) ? ProductDimension.fromJSON(object.productLength) : undefined,
      productWidth: isSet(object.productWidth) ? ProductDimension.fromJSON(object.productWidth) : undefined,
      productWeight: isSet(object.productWeight) ? ProductWeight.fromJSON(object.productWeight) : undefined,
      shipping: globalThis.Array.isArray(object?.shipping) ? object.shipping.map((e: any) => Shipping.fromJSON(e)) : [],
      freeShippingThreshold: globalThis.Array.isArray(object?.freeShippingThreshold)
        ? object.freeShippingThreshold.map((e: any) => FreeShippingThreshold.fromJSON(e))
        : [],
      shippingWeight: isSet(object.shippingWeight) ? ShippingWeight.fromJSON(object.shippingWeight) : undefined,
      shippingLength: isSet(object.shippingLength) ? ShippingDimension.fromJSON(object.shippingLength) : undefined,
      shippingWidth: isSet(object.shippingWidth) ? ShippingDimension.fromJSON(object.shippingWidth) : undefined,
      shippingHeight: isSet(object.shippingHeight) ? ShippingDimension.fromJSON(object.shippingHeight) : undefined,
      maxHandlingTime: isSet(object.maxHandlingTime) ? Long.fromValue(object.maxHandlingTime) : undefined,
      minHandlingTime: isSet(object.minHandlingTime) ? Long.fromValue(object.minHandlingTime) : undefined,
      shippingLabel: isSet(object.shippingLabel) ? globalThis.String(object.shippingLabel) : undefined,
      transitTimeLabel: isSet(object.transitTimeLabel) ? globalThis.String(object.transitTimeLabel) : undefined,
      size: isSet(object.size) ? globalThis.String(object.size) : undefined,
      sizeSystem: isSet(object.sizeSystem) ? globalThis.String(object.sizeSystem) : undefined,
      sizeTypes: globalThis.Array.isArray(object?.sizeTypes)
        ? object.sizeTypes.map((e: any) => globalThis.String(e))
        : [],
      taxes: globalThis.Array.isArray(object?.taxes)
        ? object.taxes.map((e: any) => Tax.fromJSON(e))
        : [],
      taxCategory: isSet(object.taxCategory) ? globalThis.String(object.taxCategory) : undefined,
      energyEfficiencyClass: isSet(object.energyEfficiencyClass)
        ? globalThis.String(object.energyEfficiencyClass)
        : undefined,
      minEnergyEfficiencyClass: isSet(object.minEnergyEfficiencyClass)
        ? globalThis.String(object.minEnergyEfficiencyClass)
        : undefined,
      maxEnergyEfficiencyClass: isSet(object.maxEnergyEfficiencyClass)
        ? globalThis.String(object.maxEnergyEfficiencyClass)
        : undefined,
      unitPricingMeasure: isSet(object.unitPricingMeasure)
        ? UnitPricingMeasure.fromJSON(object.unitPricingMeasure)
        : undefined,
      unitPricingBaseMeasure: isSet(object.unitPricingBaseMeasure)
        ? UnitPricingBaseMeasure.fromJSON(object.unitPricingBaseMeasure)
        : undefined,
      multipack: isSet(object.multipack) ? Long.fromValue(object.multipack) : undefined,
      adsGrouping: isSet(object.adsGrouping) ? globalThis.String(object.adsGrouping) : undefined,
      adsLabels: globalThis.Array.isArray(object?.adsLabels)
        ? object.adsLabels.map((e: any) => globalThis.String(e))
        : [],
      adsRedirect: isSet(object.adsRedirect) ? globalThis.String(object.adsRedirect) : undefined,
      costOfGoodsSold: isSet(object.costOfGoodsSold) ? Price.fromJSON(object.costOfGoodsSold) : undefined,
      productDetails: globalThis.Array.isArray(object?.productDetails)
        ? object.productDetails.map((e: any) => ProductDetail.fromJSON(e))
        : [],
      productHighlights: globalThis.Array.isArray(object?.productHighlights)
        ? object.productHighlights.map((e: any) => globalThis.String(e))
        : [],
      displayAdsId: isSet(object.displayAdsId) ? globalThis.String(object.displayAdsId) : undefined,
      displayAdsSimilarIds: globalThis.Array.isArray(object?.displayAdsSimilarIds)
        ? object.displayAdsSimilarIds.map((e: any) => globalThis.String(e))
        : [],
      displayAdsTitle: isSet(object.displayAdsTitle) ? globalThis.String(object.displayAdsTitle) : undefined,
      displayAdsLink: isSet(object.displayAdsLink) ? globalThis.String(object.displayAdsLink) : undefined,
      displayAdsValue: isSet(object.displayAdsValue) ? globalThis.Number(object.displayAdsValue) : undefined,
      promotionIds: globalThis.Array.isArray(object?.promotionIds)
        ? object.promotionIds.map((e: any) => globalThis.String(e))
        : [],
      pickupMethod: isSet(object.pickupMethod) ? globalThis.String(object.pickupMethod) : undefined,
      pickupSla: isSet(object.pickupSla) ? globalThis.String(object.pickupSla) : undefined,
      linkTemplate: isSet(object.linkTemplate) ? globalThis.String(object.linkTemplate) : undefined,
      mobileLinkTemplate: isSet(object.mobileLinkTemplate) ? globalThis.String(object.mobileLinkTemplate) : undefined,
      customLabel0: isSet(object.customLabel0) ? globalThis.String(object.customLabel0) : undefined,
      customLabel1: isSet(object.customLabel1) ? globalThis.String(object.customLabel1) : undefined,
      customLabel2: isSet(object.customLabel2) ? globalThis.String(object.customLabel2) : undefined,
      customLabel3: isSet(object.customLabel3) ? globalThis.String(object.customLabel3) : undefined,
      customLabel4: isSet(object.customLabel4) ? globalThis.String(object.customLabel4) : undefined,
      includedDestinations: globalThis.Array.isArray(object?.includedDestinations)
        ? object.includedDestinations.map((e: any) => globalThis.String(e))
        : [],
      excludedDestinations: globalThis.Array.isArray(object?.excludedDestinations)
        ? object.excludedDestinations.map((e: any) => globalThis.String(e))
        : [],
      shoppingAdsExcludedCountries: globalThis.Array.isArray(object?.shoppingAdsExcludedCountries)
        ? object.shoppingAdsExcludedCountries.map((e: any) => globalThis.String(e))
        : [],
      externalSellerId: isSet(object.externalSellerId) ? globalThis.String(object.externalSellerId) : undefined,
      pause: isSet(object.pause) ? globalThis.String(object.pause) : undefined,
      lifestyleImageLinks: globalThis.Array.isArray(object?.lifestyleImageLinks)
        ? object.lifestyleImageLinks.map((e: any) => globalThis.String(e))
        : [],
      cloudExportAdditionalProperties: globalThis.Array.isArray(object?.cloudExportAdditionalProperties)
        ? object.cloudExportAdditionalProperties.map((e: any) => CloudExportAdditionalProperties.fromJSON(e))
        : [],
      virtualModelLink: isSet(object.virtualModelLink) ? globalThis.String(object.virtualModelLink) : undefined,
      certifications: globalThis.Array.isArray(object?.certifications)
        ? object.certifications.map((e: any) => Certification.fromJSON(e))
        : [],
      structuredTitle: isSet(object.structuredTitle)
        ? ProductStructuredTitle.fromJSON(object.structuredTitle)
        : undefined,
      structuredDescription: isSet(object.structuredDescription)
        ? ProductStructuredDescription.fromJSON(object.structuredDescription)
        : undefined,
      autoPricingMinPrice: isSet(object.autoPricingMinPrice) ? Price.fromJSON(object.autoPricingMinPrice) : undefined,
    };
  },

  toJSON(message: Attributes): unknown {
    const obj: any = {};
    if (message.identifierExists !== undefined) {
      obj.identifierExists = message.identifierExists;
    }
    if (message.isBundle !== undefined) {
      obj.isBundle = message.isBundle;
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.link !== undefined) {
      obj.link = message.link;
    }
    if (message.mobileLink !== undefined) {
      obj.mobileLink = message.mobileLink;
    }
    if (message.canonicalLink !== undefined) {
      obj.canonicalLink = message.canonicalLink;
    }
    if (message.imageLink !== undefined) {
      obj.imageLink = message.imageLink;
    }
    if (message.additionalImageLinks?.length) {
      obj.additionalImageLinks = message.additionalImageLinks;
    }
    if (message.expirationDate !== undefined) {
      obj.expirationDate = message.expirationDate.toISOString();
    }
    if (message.disclosureDate !== undefined) {
      obj.disclosureDate = message.disclosureDate.toISOString();
    }
    if (message.adult !== undefined) {
      obj.adult = message.adult;
    }
    if (message.ageGroup !== undefined) {
      obj.ageGroup = message.ageGroup;
    }
    if (message.availability !== undefined) {
      obj.availability = message.availability;
    }
    if (message.availabilityDate !== undefined) {
      obj.availabilityDate = message.availabilityDate.toISOString();
    }
    if (message.brand !== undefined) {
      obj.brand = message.brand;
    }
    if (message.color !== undefined) {
      obj.color = message.color;
    }
    if (message.condition !== undefined) {
      obj.condition = message.condition;
    }
    if (message.gender !== undefined) {
      obj.gender = message.gender;
    }
    if (message.googleProductCategory !== undefined) {
      obj.googleProductCategory = message.googleProductCategory;
    }
    if (message.gtin !== undefined) {
      obj.gtin = message.gtin;
    }
    if (message.itemGroupId !== undefined) {
      obj.itemGroupId = message.itemGroupId;
    }
    if (message.material !== undefined) {
      obj.material = message.material;
    }
    if (message.mpn !== undefined) {
      obj.mpn = message.mpn;
    }
    if (message.pattern !== undefined) {
      obj.pattern = message.pattern;
    }
    if (message.price !== undefined) {
      obj.price = Price.toJSON(message.price);
    }
    if (message.installment !== undefined) {
      obj.installment = Installment.toJSON(message.installment);
    }
    if (message.subscriptionCost !== undefined) {
      obj.subscriptionCost = SubscriptionCost.toJSON(message.subscriptionCost);
    }
    if (message.loyaltyPoints !== undefined) {
      obj.loyaltyPoints = LoyaltyPoints.toJSON(message.loyaltyPoints);
    }
    if (message.loyaltyPrograms?.length) {
      obj.loyaltyPrograms = message.loyaltyPrograms.map((e) => LoyaltyProgram.toJSON(e));
    }
    if (message.productTypes?.length) {
      obj.productTypes = message.productTypes;
    }
    if (message.salePrice !== undefined) {
      obj.salePrice = Price.toJSON(message.salePrice);
    }
    if (message.salePriceEffectiveDate !== undefined) {
      obj.salePriceEffectiveDate = Interval.toJSON(message.salePriceEffectiveDate);
    }
    if (message.sellOnGoogleQuantity !== undefined) {
      obj.sellOnGoogleQuantity = (message.sellOnGoogleQuantity || Long.ZERO).toString();
    }
    if (message.productHeight !== undefined) {
      obj.productHeight = ProductDimension.toJSON(message.productHeight);
    }
    if (message.productLength !== undefined) {
      obj.productLength = ProductDimension.toJSON(message.productLength);
    }
    if (message.productWidth !== undefined) {
      obj.productWidth = ProductDimension.toJSON(message.productWidth);
    }
    if (message.productWeight !== undefined) {
      obj.productWeight = ProductWeight.toJSON(message.productWeight);
    }
    if (message.shipping?.length) {
      obj.shipping = message.shipping.map((e) => Shipping.toJSON(e));
    }
    if (message.freeShippingThreshold?.length) {
      obj.freeShippingThreshold = message.freeShippingThreshold.map((e) => FreeShippingThreshold.toJSON(e));
    }
    if (message.shippingWeight !== undefined) {
      obj.shippingWeight = ShippingWeight.toJSON(message.shippingWeight);
    }
    if (message.shippingLength !== undefined) {
      obj.shippingLength = ShippingDimension.toJSON(message.shippingLength);
    }
    if (message.shippingWidth !== undefined) {
      obj.shippingWidth = ShippingDimension.toJSON(message.shippingWidth);
    }
    if (message.shippingHeight !== undefined) {
      obj.shippingHeight = ShippingDimension.toJSON(message.shippingHeight);
    }
    if (message.maxHandlingTime !== undefined) {
      obj.maxHandlingTime = (message.maxHandlingTime || Long.ZERO).toString();
    }
    if (message.minHandlingTime !== undefined) {
      obj.minHandlingTime = (message.minHandlingTime || Long.ZERO).toString();
    }
    if (message.shippingLabel !== undefined) {
      obj.shippingLabel = message.shippingLabel;
    }
    if (message.transitTimeLabel !== undefined) {
      obj.transitTimeLabel = message.transitTimeLabel;
    }
    if (message.size !== undefined) {
      obj.size = message.size;
    }
    if (message.sizeSystem !== undefined) {
      obj.sizeSystem = message.sizeSystem;
    }
    if (message.sizeTypes?.length) {
      obj.sizeTypes = message.sizeTypes;
    }
    if (message.taxes?.length) {
      obj.taxes = message.taxes.map((e) => Tax.toJSON(e));
    }
    if (message.taxCategory !== undefined) {
      obj.taxCategory = message.taxCategory;
    }
    if (message.energyEfficiencyClass !== undefined) {
      obj.energyEfficiencyClass = message.energyEfficiencyClass;
    }
    if (message.minEnergyEfficiencyClass !== undefined) {
      obj.minEnergyEfficiencyClass = message.minEnergyEfficiencyClass;
    }
    if (message.maxEnergyEfficiencyClass !== undefined) {
      obj.maxEnergyEfficiencyClass = message.maxEnergyEfficiencyClass;
    }
    if (message.unitPricingMeasure !== undefined) {
      obj.unitPricingMeasure = UnitPricingMeasure.toJSON(message.unitPricingMeasure);
    }
    if (message.unitPricingBaseMeasure !== undefined) {
      obj.unitPricingBaseMeasure = UnitPricingBaseMeasure.toJSON(message.unitPricingBaseMeasure);
    }
    if (message.multipack !== undefined) {
      obj.multipack = (message.multipack || Long.ZERO).toString();
    }
    if (message.adsGrouping !== undefined) {
      obj.adsGrouping = message.adsGrouping;
    }
    if (message.adsLabels?.length) {
      obj.adsLabels = message.adsLabels;
    }
    if (message.adsRedirect !== undefined) {
      obj.adsRedirect = message.adsRedirect;
    }
    if (message.costOfGoodsSold !== undefined) {
      obj.costOfGoodsSold = Price.toJSON(message.costOfGoodsSold);
    }
    if (message.productDetails?.length) {
      obj.productDetails = message.productDetails.map((e) => ProductDetail.toJSON(e));
    }
    if (message.productHighlights?.length) {
      obj.productHighlights = message.productHighlights;
    }
    if (message.displayAdsId !== undefined) {
      obj.displayAdsId = message.displayAdsId;
    }
    if (message.displayAdsSimilarIds?.length) {
      obj.displayAdsSimilarIds = message.displayAdsSimilarIds;
    }
    if (message.displayAdsTitle !== undefined) {
      obj.displayAdsTitle = message.displayAdsTitle;
    }
    if (message.displayAdsLink !== undefined) {
      obj.displayAdsLink = message.displayAdsLink;
    }
    if (message.displayAdsValue !== undefined) {
      obj.displayAdsValue = message.displayAdsValue;
    }
    if (message.promotionIds?.length) {
      obj.promotionIds = message.promotionIds;
    }
    if (message.pickupMethod !== undefined) {
      obj.pickupMethod = message.pickupMethod;
    }
    if (message.pickupSla !== undefined) {
      obj.pickupSla = message.pickupSla;
    }
    if (message.linkTemplate !== undefined) {
      obj.linkTemplate = message.linkTemplate;
    }
    if (message.mobileLinkTemplate !== undefined) {
      obj.mobileLinkTemplate = message.mobileLinkTemplate;
    }
    if (message.customLabel0 !== undefined) {
      obj.customLabel0 = message.customLabel0;
    }
    if (message.customLabel1 !== undefined) {
      obj.customLabel1 = message.customLabel1;
    }
    if (message.customLabel2 !== undefined) {
      obj.customLabel2 = message.customLabel2;
    }
    if (message.customLabel3 !== undefined) {
      obj.customLabel3 = message.customLabel3;
    }
    if (message.customLabel4 !== undefined) {
      obj.customLabel4 = message.customLabel4;
    }
    if (message.includedDestinations?.length) {
      obj.includedDestinations = message.includedDestinations;
    }
    if (message.excludedDestinations?.length) {
      obj.excludedDestinations = message.excludedDestinations;
    }
    if (message.shoppingAdsExcludedCountries?.length) {
      obj.shoppingAdsExcludedCountries = message.shoppingAdsExcludedCountries;
    }
    if (message.externalSellerId !== undefined) {
      obj.externalSellerId = message.externalSellerId;
    }
    if (message.pause !== undefined) {
      obj.pause = message.pause;
    }
    if (message.lifestyleImageLinks?.length) {
      obj.lifestyleImageLinks = message.lifestyleImageLinks;
    }
    if (message.cloudExportAdditionalProperties?.length) {
      obj.cloudExportAdditionalProperties = message.cloudExportAdditionalProperties.map((e) =>
        CloudExportAdditionalProperties.toJSON(e)
      );
    }
    if (message.virtualModelLink !== undefined) {
      obj.virtualModelLink = message.virtualModelLink;
    }
    if (message.certifications?.length) {
      obj.certifications = message.certifications.map((e) => Certification.toJSON(e));
    }
    if (message.structuredTitle !== undefined) {
      obj.structuredTitle = ProductStructuredTitle.toJSON(message.structuredTitle);
    }
    if (message.structuredDescription !== undefined) {
      obj.structuredDescription = ProductStructuredDescription.toJSON(message.structuredDescription);
    }
    if (message.autoPricingMinPrice !== undefined) {
      obj.autoPricingMinPrice = Price.toJSON(message.autoPricingMinPrice);
    }
    return obj;
  },

  create(base?: DeepPartial<Attributes>): Attributes {
    return Attributes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Attributes>): Attributes {
    const message = createBaseAttributes();
    message.identifierExists = object.identifierExists ?? undefined;
    message.isBundle = object.isBundle ?? undefined;
    message.title = object.title ?? undefined;
    message.description = object.description ?? undefined;
    message.link = object.link ?? undefined;
    message.mobileLink = object.mobileLink ?? undefined;
    message.canonicalLink = object.canonicalLink ?? undefined;
    message.imageLink = object.imageLink ?? undefined;
    message.additionalImageLinks = object.additionalImageLinks?.map((e) => e) || [];
    message.expirationDate = object.expirationDate ?? undefined;
    message.disclosureDate = object.disclosureDate ?? undefined;
    message.adult = object.adult ?? undefined;
    message.ageGroup = object.ageGroup ?? undefined;
    message.availability = object.availability ?? undefined;
    message.availabilityDate = object.availabilityDate ?? undefined;
    message.brand = object.brand ?? undefined;
    message.color = object.color ?? undefined;
    message.condition = object.condition ?? undefined;
    message.gender = object.gender ?? undefined;
    message.googleProductCategory = object.googleProductCategory ?? undefined;
    message.gtin = object.gtin ?? undefined;
    message.itemGroupId = object.itemGroupId ?? undefined;
    message.material = object.material ?? undefined;
    message.mpn = object.mpn ?? undefined;
    message.pattern = object.pattern ?? undefined;
    message.price = (object.price !== undefined && object.price !== null) ? Price.fromPartial(object.price) : undefined;
    message.installment = (object.installment !== undefined && object.installment !== null)
      ? Installment.fromPartial(object.installment)
      : undefined;
    message.subscriptionCost = (object.subscriptionCost !== undefined && object.subscriptionCost !== null)
      ? SubscriptionCost.fromPartial(object.subscriptionCost)
      : undefined;
    message.loyaltyPoints = (object.loyaltyPoints !== undefined && object.loyaltyPoints !== null)
      ? LoyaltyPoints.fromPartial(object.loyaltyPoints)
      : undefined;
    message.loyaltyPrograms = object.loyaltyPrograms?.map((e) => LoyaltyProgram.fromPartial(e)) || [];
    message.productTypes = object.productTypes?.map((e) => e) || [];
    message.salePrice = (object.salePrice !== undefined && object.salePrice !== null)
      ? Price.fromPartial(object.salePrice)
      : undefined;
    message.salePriceEffectiveDate =
      (object.salePriceEffectiveDate !== undefined && object.salePriceEffectiveDate !== null)
        ? Interval.fromPartial(object.salePriceEffectiveDate)
        : undefined;
    message.sellOnGoogleQuantity = (object.sellOnGoogleQuantity !== undefined && object.sellOnGoogleQuantity !== null)
      ? Long.fromValue(object.sellOnGoogleQuantity)
      : undefined;
    message.productHeight = (object.productHeight !== undefined && object.productHeight !== null)
      ? ProductDimension.fromPartial(object.productHeight)
      : undefined;
    message.productLength = (object.productLength !== undefined && object.productLength !== null)
      ? ProductDimension.fromPartial(object.productLength)
      : undefined;
    message.productWidth = (object.productWidth !== undefined && object.productWidth !== null)
      ? ProductDimension.fromPartial(object.productWidth)
      : undefined;
    message.productWeight = (object.productWeight !== undefined && object.productWeight !== null)
      ? ProductWeight.fromPartial(object.productWeight)
      : undefined;
    message.shipping = object.shipping?.map((e) => Shipping.fromPartial(e)) || [];
    message.freeShippingThreshold = object.freeShippingThreshold?.map((e) => FreeShippingThreshold.fromPartial(e)) ||
      [];
    message.shippingWeight = (object.shippingWeight !== undefined && object.shippingWeight !== null)
      ? ShippingWeight.fromPartial(object.shippingWeight)
      : undefined;
    message.shippingLength = (object.shippingLength !== undefined && object.shippingLength !== null)
      ? ShippingDimension.fromPartial(object.shippingLength)
      : undefined;
    message.shippingWidth = (object.shippingWidth !== undefined && object.shippingWidth !== null)
      ? ShippingDimension.fromPartial(object.shippingWidth)
      : undefined;
    message.shippingHeight = (object.shippingHeight !== undefined && object.shippingHeight !== null)
      ? ShippingDimension.fromPartial(object.shippingHeight)
      : undefined;
    message.maxHandlingTime = (object.maxHandlingTime !== undefined && object.maxHandlingTime !== null)
      ? Long.fromValue(object.maxHandlingTime)
      : undefined;
    message.minHandlingTime = (object.minHandlingTime !== undefined && object.minHandlingTime !== null)
      ? Long.fromValue(object.minHandlingTime)
      : undefined;
    message.shippingLabel = object.shippingLabel ?? undefined;
    message.transitTimeLabel = object.transitTimeLabel ?? undefined;
    message.size = object.size ?? undefined;
    message.sizeSystem = object.sizeSystem ?? undefined;
    message.sizeTypes = object.sizeTypes?.map((e) => e) || [];
    message.taxes = object.taxes?.map((e) => Tax.fromPartial(e)) || [];
    message.taxCategory = object.taxCategory ?? undefined;
    message.energyEfficiencyClass = object.energyEfficiencyClass ?? undefined;
    message.minEnergyEfficiencyClass = object.minEnergyEfficiencyClass ?? undefined;
    message.maxEnergyEfficiencyClass = object.maxEnergyEfficiencyClass ?? undefined;
    message.unitPricingMeasure = (object.unitPricingMeasure !== undefined && object.unitPricingMeasure !== null)
      ? UnitPricingMeasure.fromPartial(object.unitPricingMeasure)
      : undefined;
    message.unitPricingBaseMeasure =
      (object.unitPricingBaseMeasure !== undefined && object.unitPricingBaseMeasure !== null)
        ? UnitPricingBaseMeasure.fromPartial(object.unitPricingBaseMeasure)
        : undefined;
    message.multipack = (object.multipack !== undefined && object.multipack !== null)
      ? Long.fromValue(object.multipack)
      : undefined;
    message.adsGrouping = object.adsGrouping ?? undefined;
    message.adsLabels = object.adsLabels?.map((e) => e) || [];
    message.adsRedirect = object.adsRedirect ?? undefined;
    message.costOfGoodsSold = (object.costOfGoodsSold !== undefined && object.costOfGoodsSold !== null)
      ? Price.fromPartial(object.costOfGoodsSold)
      : undefined;
    message.productDetails = object.productDetails?.map((e) => ProductDetail.fromPartial(e)) || [];
    message.productHighlights = object.productHighlights?.map((e) => e) || [];
    message.displayAdsId = object.displayAdsId ?? undefined;
    message.displayAdsSimilarIds = object.displayAdsSimilarIds?.map((e) => e) || [];
    message.displayAdsTitle = object.displayAdsTitle ?? undefined;
    message.displayAdsLink = object.displayAdsLink ?? undefined;
    message.displayAdsValue = object.displayAdsValue ?? undefined;
    message.promotionIds = object.promotionIds?.map((e) => e) || [];
    message.pickupMethod = object.pickupMethod ?? undefined;
    message.pickupSla = object.pickupSla ?? undefined;
    message.linkTemplate = object.linkTemplate ?? undefined;
    message.mobileLinkTemplate = object.mobileLinkTemplate ?? undefined;
    message.customLabel0 = object.customLabel0 ?? undefined;
    message.customLabel1 = object.customLabel1 ?? undefined;
    message.customLabel2 = object.customLabel2 ?? undefined;
    message.customLabel3 = object.customLabel3 ?? undefined;
    message.customLabel4 = object.customLabel4 ?? undefined;
    message.includedDestinations = object.includedDestinations?.map((e) => e) || [];
    message.excludedDestinations = object.excludedDestinations?.map((e) => e) || [];
    message.shoppingAdsExcludedCountries = object.shoppingAdsExcludedCountries?.map((e) => e) || [];
    message.externalSellerId = object.externalSellerId ?? undefined;
    message.pause = object.pause ?? undefined;
    message.lifestyleImageLinks = object.lifestyleImageLinks?.map((e) => e) || [];
    message.cloudExportAdditionalProperties =
      object.cloudExportAdditionalProperties?.map((e) => CloudExportAdditionalProperties.fromPartial(e)) || [];
    message.virtualModelLink = object.virtualModelLink ?? undefined;
    message.certifications = object.certifications?.map((e) => Certification.fromPartial(e)) || [];
    message.structuredTitle = (object.structuredTitle !== undefined && object.structuredTitle !== null)
      ? ProductStructuredTitle.fromPartial(object.structuredTitle)
      : undefined;
    message.structuredDescription =
      (object.structuredDescription !== undefined && object.structuredDescription !== null)
        ? ProductStructuredDescription.fromPartial(object.structuredDescription)
        : undefined;
    message.autoPricingMinPrice = (object.autoPricingMinPrice !== undefined && object.autoPricingMinPrice !== null)
      ? Price.fromPartial(object.autoPricingMinPrice)
      : undefined;
    return message;
  },
};

function createBaseTax(): Tax {
  return { rate: 0, country: "", region: "", taxShip: false, locationId: Long.ZERO, postalCode: "" };
}

export const Tax: MessageFns<Tax> = {
  encode(message: Tax, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rate !== 0) {
      writer.uint32(9).double(message.rate);
    }
    if (message.country !== "") {
      writer.uint32(18).string(message.country);
    }
    if (message.region !== "") {
      writer.uint32(26).string(message.region);
    }
    if (message.taxShip !== false) {
      writer.uint32(32).bool(message.taxShip);
    }
    if (!message.locationId.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.locationId.toString());
    }
    if (message.postalCode !== "") {
      writer.uint32(50).string(message.postalCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tax {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTax();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.rate = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.country = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.region = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.taxShip = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.locationId = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.postalCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tax {
    return {
      rate: isSet(object.rate) ? globalThis.Number(object.rate) : 0,
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      taxShip: isSet(object.taxShip) ? globalThis.Boolean(object.taxShip) : false,
      locationId: isSet(object.locationId) ? Long.fromValue(object.locationId) : Long.ZERO,
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : "",
    };
  },

  toJSON(message: Tax): unknown {
    const obj: any = {};
    if (message.rate !== 0) {
      obj.rate = message.rate;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.taxShip !== false) {
      obj.taxShip = message.taxShip;
    }
    if (!message.locationId.equals(Long.ZERO)) {
      obj.locationId = (message.locationId || Long.ZERO).toString();
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    return obj;
  },

  create(base?: DeepPartial<Tax>): Tax {
    return Tax.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tax>): Tax {
    const message = createBaseTax();
    message.rate = object.rate ?? 0;
    message.country = object.country ?? "";
    message.region = object.region ?? "";
    message.taxShip = object.taxShip ?? false;
    message.locationId = (object.locationId !== undefined && object.locationId !== null)
      ? Long.fromValue(object.locationId)
      : Long.ZERO;
    message.postalCode = object.postalCode ?? "";
    return message;
  },
};

function createBaseShippingWeight(): ShippingWeight {
  return { value: 0, unit: "" };
}

export const ShippingWeight: MessageFns<ShippingWeight> = {
  encode(message: ShippingWeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    if (message.unit !== "") {
      writer.uint32(18).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShippingWeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShippingWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.unit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShippingWeight {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
    };
  },

  toJSON(message: ShippingWeight): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    return obj;
  },

  create(base?: DeepPartial<ShippingWeight>): ShippingWeight {
    return ShippingWeight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShippingWeight>): ShippingWeight {
    const message = createBaseShippingWeight();
    message.value = object.value ?? 0;
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseShippingDimension(): ShippingDimension {
  return { value: 0, unit: "" };
}

export const ShippingDimension: MessageFns<ShippingDimension> = {
  encode(message: ShippingDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    if (message.unit !== "") {
      writer.uint32(18).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShippingDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShippingDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.unit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShippingDimension {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
    };
  },

  toJSON(message: ShippingDimension): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    return obj;
  },

  create(base?: DeepPartial<ShippingDimension>): ShippingDimension {
    return ShippingDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShippingDimension>): ShippingDimension {
    const message = createBaseShippingDimension();
    message.value = object.value ?? 0;
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseUnitPricingBaseMeasure(): UnitPricingBaseMeasure {
  return { value: Long.ZERO, unit: "" };
}

export const UnitPricingBaseMeasure: MessageFns<UnitPricingBaseMeasure> = {
  encode(message: UnitPricingBaseMeasure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.value.toString());
    }
    if (message.unit !== "") {
      writer.uint32(18).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnitPricingBaseMeasure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnitPricingBaseMeasure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.unit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnitPricingBaseMeasure {
    return {
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
    };
  },

  toJSON(message: UnitPricingBaseMeasure): unknown {
    const obj: any = {};
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    return obj;
  },

  create(base?: DeepPartial<UnitPricingBaseMeasure>): UnitPricingBaseMeasure {
    return UnitPricingBaseMeasure.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnitPricingBaseMeasure>): UnitPricingBaseMeasure {
    const message = createBaseUnitPricingBaseMeasure();
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseUnitPricingMeasure(): UnitPricingMeasure {
  return { value: 0, unit: "" };
}

export const UnitPricingMeasure: MessageFns<UnitPricingMeasure> = {
  encode(message: UnitPricingMeasure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    if (message.unit !== "") {
      writer.uint32(18).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnitPricingMeasure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnitPricingMeasure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.unit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnitPricingMeasure {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
    };
  },

  toJSON(message: UnitPricingMeasure): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    return obj;
  },

  create(base?: DeepPartial<UnitPricingMeasure>): UnitPricingMeasure {
    return UnitPricingMeasure.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnitPricingMeasure>): UnitPricingMeasure {
    const message = createBaseUnitPricingMeasure();
    message.value = object.value ?? 0;
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseSubscriptionCost(): SubscriptionCost {
  return { period: 0, periodLength: Long.ZERO, amount: undefined };
}

export const SubscriptionCost: MessageFns<SubscriptionCost> = {
  encode(message: SubscriptionCost, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.period !== 0) {
      writer.uint32(8).int32(message.period);
    }
    if (!message.periodLength.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.periodLength.toString());
    }
    if (message.amount !== undefined) {
      Price.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionCost {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionCost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.period = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.periodLength = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = Price.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionCost {
    return {
      period: isSet(object.period) ? subscriptionPeriodFromJSON(object.period) : 0,
      periodLength: isSet(object.periodLength) ? Long.fromValue(object.periodLength) : Long.ZERO,
      amount: isSet(object.amount) ? Price.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: SubscriptionCost): unknown {
    const obj: any = {};
    if (message.period !== 0) {
      obj.period = subscriptionPeriodToJSON(message.period);
    }
    if (!message.periodLength.equals(Long.ZERO)) {
      obj.periodLength = (message.periodLength || Long.ZERO).toString();
    }
    if (message.amount !== undefined) {
      obj.amount = Price.toJSON(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<SubscriptionCost>): SubscriptionCost {
    return SubscriptionCost.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscriptionCost>): SubscriptionCost {
    const message = createBaseSubscriptionCost();
    message.period = object.period ?? 0;
    message.periodLength = (object.periodLength !== undefined && object.periodLength !== null)
      ? Long.fromValue(object.periodLength)
      : Long.ZERO;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Price.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseInstallment(): Installment {
  return { months: Long.ZERO, amount: undefined, downpayment: undefined, creditType: undefined };
}

export const Installment: MessageFns<Installment> = {
  encode(message: Installment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.months.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.months.toString());
    }
    if (message.amount !== undefined) {
      Price.encode(message.amount, writer.uint32(18).fork()).join();
    }
    if (message.downpayment !== undefined) {
      Price.encode(message.downpayment, writer.uint32(26).fork()).join();
    }
    if (message.creditType !== undefined) {
      writer.uint32(34).string(message.creditType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Installment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstallment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.months = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = Price.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.downpayment = Price.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.creditType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Installment {
    return {
      months: isSet(object.months) ? Long.fromValue(object.months) : Long.ZERO,
      amount: isSet(object.amount) ? Price.fromJSON(object.amount) : undefined,
      downpayment: isSet(object.downpayment) ? Price.fromJSON(object.downpayment) : undefined,
      creditType: isSet(object.creditType) ? globalThis.String(object.creditType) : undefined,
    };
  },

  toJSON(message: Installment): unknown {
    const obj: any = {};
    if (!message.months.equals(Long.ZERO)) {
      obj.months = (message.months || Long.ZERO).toString();
    }
    if (message.amount !== undefined) {
      obj.amount = Price.toJSON(message.amount);
    }
    if (message.downpayment !== undefined) {
      obj.downpayment = Price.toJSON(message.downpayment);
    }
    if (message.creditType !== undefined) {
      obj.creditType = message.creditType;
    }
    return obj;
  },

  create(base?: DeepPartial<Installment>): Installment {
    return Installment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Installment>): Installment {
    const message = createBaseInstallment();
    message.months = (object.months !== undefined && object.months !== null)
      ? Long.fromValue(object.months)
      : Long.ZERO;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Price.fromPartial(object.amount)
      : undefined;
    message.downpayment = (object.downpayment !== undefined && object.downpayment !== null)
      ? Price.fromPartial(object.downpayment)
      : undefined;
    message.creditType = object.creditType ?? undefined;
    return message;
  },
};

function createBaseLoyaltyPoints(): LoyaltyPoints {
  return { name: "", pointsValue: Long.ZERO, ratio: 0 };
}

export const LoyaltyPoints: MessageFns<LoyaltyPoints> = {
  encode(message: LoyaltyPoints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.pointsValue.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.pointsValue.toString());
    }
    if (message.ratio !== 0) {
      writer.uint32(25).double(message.ratio);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoyaltyPoints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoyaltyPoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pointsValue = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.ratio = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoyaltyPoints {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pointsValue: isSet(object.pointsValue) ? Long.fromValue(object.pointsValue) : Long.ZERO,
      ratio: isSet(object.ratio) ? globalThis.Number(object.ratio) : 0,
    };
  },

  toJSON(message: LoyaltyPoints): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.pointsValue.equals(Long.ZERO)) {
      obj.pointsValue = (message.pointsValue || Long.ZERO).toString();
    }
    if (message.ratio !== 0) {
      obj.ratio = message.ratio;
    }
    return obj;
  },

  create(base?: DeepPartial<LoyaltyPoints>): LoyaltyPoints {
    return LoyaltyPoints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoyaltyPoints>): LoyaltyPoints {
    const message = createBaseLoyaltyPoints();
    message.name = object.name ?? "";
    message.pointsValue = (object.pointsValue !== undefined && object.pointsValue !== null)
      ? Long.fromValue(object.pointsValue)
      : Long.ZERO;
    message.ratio = object.ratio ?? 0;
    return message;
  },
};

function createBaseLoyaltyProgram(): LoyaltyProgram {
  return {
    programLabel: undefined,
    tierLabel: undefined,
    price: undefined,
    cashbackForFutureUse: undefined,
    loyaltyPoints: undefined,
  };
}

export const LoyaltyProgram: MessageFns<LoyaltyProgram> = {
  encode(message: LoyaltyProgram, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.programLabel !== undefined) {
      writer.uint32(10).string(message.programLabel);
    }
    if (message.tierLabel !== undefined) {
      writer.uint32(18).string(message.tierLabel);
    }
    if (message.price !== undefined) {
      Price.encode(message.price, writer.uint32(26).fork()).join();
    }
    if (message.cashbackForFutureUse !== undefined) {
      Price.encode(message.cashbackForFutureUse, writer.uint32(34).fork()).join();
    }
    if (message.loyaltyPoints !== undefined) {
      writer.uint32(40).int64(message.loyaltyPoints.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoyaltyProgram {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoyaltyProgram();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.programLabel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tierLabel = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.price = Price.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cashbackForFutureUse = Price.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.loyaltyPoints = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoyaltyProgram {
    return {
      programLabel: isSet(object.programLabel) ? globalThis.String(object.programLabel) : undefined,
      tierLabel: isSet(object.tierLabel) ? globalThis.String(object.tierLabel) : undefined,
      price: isSet(object.price) ? Price.fromJSON(object.price) : undefined,
      cashbackForFutureUse: isSet(object.cashbackForFutureUse)
        ? Price.fromJSON(object.cashbackForFutureUse)
        : undefined,
      loyaltyPoints: isSet(object.loyaltyPoints) ? Long.fromValue(object.loyaltyPoints) : undefined,
    };
  },

  toJSON(message: LoyaltyProgram): unknown {
    const obj: any = {};
    if (message.programLabel !== undefined) {
      obj.programLabel = message.programLabel;
    }
    if (message.tierLabel !== undefined) {
      obj.tierLabel = message.tierLabel;
    }
    if (message.price !== undefined) {
      obj.price = Price.toJSON(message.price);
    }
    if (message.cashbackForFutureUse !== undefined) {
      obj.cashbackForFutureUse = Price.toJSON(message.cashbackForFutureUse);
    }
    if (message.loyaltyPoints !== undefined) {
      obj.loyaltyPoints = (message.loyaltyPoints || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<LoyaltyProgram>): LoyaltyProgram {
    return LoyaltyProgram.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoyaltyProgram>): LoyaltyProgram {
    const message = createBaseLoyaltyProgram();
    message.programLabel = object.programLabel ?? undefined;
    message.tierLabel = object.tierLabel ?? undefined;
    message.price = (object.price !== undefined && object.price !== null) ? Price.fromPartial(object.price) : undefined;
    message.cashbackForFutureUse = (object.cashbackForFutureUse !== undefined && object.cashbackForFutureUse !== null)
      ? Price.fromPartial(object.cashbackForFutureUse)
      : undefined;
    message.loyaltyPoints = (object.loyaltyPoints !== undefined && object.loyaltyPoints !== null)
      ? Long.fromValue(object.loyaltyPoints)
      : undefined;
    return message;
  },
};

function createBaseShipping(): Shipping {
  return {
    price: undefined,
    country: "",
    region: "",
    service: "",
    locationId: Long.ZERO,
    locationGroupName: "",
    postalCode: "",
    minHandlingTime: undefined,
    maxHandlingTime: undefined,
    minTransitTime: undefined,
    maxTransitTime: undefined,
  };
}

export const Shipping: MessageFns<Shipping> = {
  encode(message: Shipping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.price !== undefined) {
      Price.encode(message.price, writer.uint32(10).fork()).join();
    }
    if (message.country !== "") {
      writer.uint32(18).string(message.country);
    }
    if (message.region !== "") {
      writer.uint32(26).string(message.region);
    }
    if (message.service !== "") {
      writer.uint32(34).string(message.service);
    }
    if (!message.locationId.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.locationId.toString());
    }
    if (message.locationGroupName !== "") {
      writer.uint32(50).string(message.locationGroupName);
    }
    if (message.postalCode !== "") {
      writer.uint32(58).string(message.postalCode);
    }
    if (message.minHandlingTime !== undefined) {
      writer.uint32(64).int64(message.minHandlingTime.toString());
    }
    if (message.maxHandlingTime !== undefined) {
      writer.uint32(72).int64(message.maxHandlingTime.toString());
    }
    if (message.minTransitTime !== undefined) {
      writer.uint32(80).int64(message.minTransitTime.toString());
    }
    if (message.maxTransitTime !== undefined) {
      writer.uint32(88).int64(message.maxTransitTime.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Shipping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShipping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.price = Price.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.country = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.region = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.service = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.locationId = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.locationGroupName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.minHandlingTime = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.maxHandlingTime = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.minTransitTime = Long.fromString(reader.int64().toString());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.maxTransitTime = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Shipping {
    return {
      price: isSet(object.price) ? Price.fromJSON(object.price) : undefined,
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      locationId: isSet(object.locationId) ? Long.fromValue(object.locationId) : Long.ZERO,
      locationGroupName: isSet(object.locationGroupName) ? globalThis.String(object.locationGroupName) : "",
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : "",
      minHandlingTime: isSet(object.minHandlingTime) ? Long.fromValue(object.minHandlingTime) : undefined,
      maxHandlingTime: isSet(object.maxHandlingTime) ? Long.fromValue(object.maxHandlingTime) : undefined,
      minTransitTime: isSet(object.minTransitTime) ? Long.fromValue(object.minTransitTime) : undefined,
      maxTransitTime: isSet(object.maxTransitTime) ? Long.fromValue(object.maxTransitTime) : undefined,
    };
  },

  toJSON(message: Shipping): unknown {
    const obj: any = {};
    if (message.price !== undefined) {
      obj.price = Price.toJSON(message.price);
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (!message.locationId.equals(Long.ZERO)) {
      obj.locationId = (message.locationId || Long.ZERO).toString();
    }
    if (message.locationGroupName !== "") {
      obj.locationGroupName = message.locationGroupName;
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    if (message.minHandlingTime !== undefined) {
      obj.minHandlingTime = (message.minHandlingTime || Long.ZERO).toString();
    }
    if (message.maxHandlingTime !== undefined) {
      obj.maxHandlingTime = (message.maxHandlingTime || Long.ZERO).toString();
    }
    if (message.minTransitTime !== undefined) {
      obj.minTransitTime = (message.minTransitTime || Long.ZERO).toString();
    }
    if (message.maxTransitTime !== undefined) {
      obj.maxTransitTime = (message.maxTransitTime || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Shipping>): Shipping {
    return Shipping.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Shipping>): Shipping {
    const message = createBaseShipping();
    message.price = (object.price !== undefined && object.price !== null) ? Price.fromPartial(object.price) : undefined;
    message.country = object.country ?? "";
    message.region = object.region ?? "";
    message.service = object.service ?? "";
    message.locationId = (object.locationId !== undefined && object.locationId !== null)
      ? Long.fromValue(object.locationId)
      : Long.ZERO;
    message.locationGroupName = object.locationGroupName ?? "";
    message.postalCode = object.postalCode ?? "";
    message.minHandlingTime = (object.minHandlingTime !== undefined && object.minHandlingTime !== null)
      ? Long.fromValue(object.minHandlingTime)
      : undefined;
    message.maxHandlingTime = (object.maxHandlingTime !== undefined && object.maxHandlingTime !== null)
      ? Long.fromValue(object.maxHandlingTime)
      : undefined;
    message.minTransitTime = (object.minTransitTime !== undefined && object.minTransitTime !== null)
      ? Long.fromValue(object.minTransitTime)
      : undefined;
    message.maxTransitTime = (object.maxTransitTime !== undefined && object.maxTransitTime !== null)
      ? Long.fromValue(object.maxTransitTime)
      : undefined;
    return message;
  },
};

function createBaseFreeShippingThreshold(): FreeShippingThreshold {
  return { country: undefined, priceThreshold: undefined };
}

export const FreeShippingThreshold: MessageFns<FreeShippingThreshold> = {
  encode(message: FreeShippingThreshold, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.country !== undefined) {
      writer.uint32(10).string(message.country);
    }
    if (message.priceThreshold !== undefined) {
      Price.encode(message.priceThreshold, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FreeShippingThreshold {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreeShippingThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.country = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.priceThreshold = Price.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FreeShippingThreshold {
    return {
      country: isSet(object.country) ? globalThis.String(object.country) : undefined,
      priceThreshold: isSet(object.priceThreshold) ? Price.fromJSON(object.priceThreshold) : undefined,
    };
  },

  toJSON(message: FreeShippingThreshold): unknown {
    const obj: any = {};
    if (message.country !== undefined) {
      obj.country = message.country;
    }
    if (message.priceThreshold !== undefined) {
      obj.priceThreshold = Price.toJSON(message.priceThreshold);
    }
    return obj;
  },

  create(base?: DeepPartial<FreeShippingThreshold>): FreeShippingThreshold {
    return FreeShippingThreshold.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FreeShippingThreshold>): FreeShippingThreshold {
    const message = createBaseFreeShippingThreshold();
    message.country = object.country ?? undefined;
    message.priceThreshold = (object.priceThreshold !== undefined && object.priceThreshold !== null)
      ? Price.fromPartial(object.priceThreshold)
      : undefined;
    return message;
  },
};

function createBaseProductDetail(): ProductDetail {
  return { sectionName: "", attributeName: "", attributeValue: "" };
}

export const ProductDetail: MessageFns<ProductDetail> = {
  encode(message: ProductDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sectionName !== "") {
      writer.uint32(10).string(message.sectionName);
    }
    if (message.attributeName !== "") {
      writer.uint32(18).string(message.attributeName);
    }
    if (message.attributeValue !== "") {
      writer.uint32(26).string(message.attributeValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sectionName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.attributeValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductDetail {
    return {
      sectionName: isSet(object.sectionName) ? globalThis.String(object.sectionName) : "",
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
      attributeValue: isSet(object.attributeValue) ? globalThis.String(object.attributeValue) : "",
    };
  },

  toJSON(message: ProductDetail): unknown {
    const obj: any = {};
    if (message.sectionName !== "") {
      obj.sectionName = message.sectionName;
    }
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    if (message.attributeValue !== "") {
      obj.attributeValue = message.attributeValue;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductDetail>): ProductDetail {
    return ProductDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductDetail>): ProductDetail {
    const message = createBaseProductDetail();
    message.sectionName = object.sectionName ?? "";
    message.attributeName = object.attributeName ?? "";
    message.attributeValue = object.attributeValue ?? "";
    return message;
  },
};

function createBaseCertification(): Certification {
  return {
    certificationAuthority: undefined,
    certificationName: undefined,
    certificationCode: undefined,
    certificationValue: undefined,
  };
}

export const Certification: MessageFns<Certification> = {
  encode(message: Certification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.certificationAuthority !== undefined) {
      writer.uint32(10).string(message.certificationAuthority);
    }
    if (message.certificationName !== undefined) {
      writer.uint32(18).string(message.certificationName);
    }
    if (message.certificationCode !== undefined) {
      writer.uint32(26).string(message.certificationCode);
    }
    if (message.certificationValue !== undefined) {
      writer.uint32(34).string(message.certificationValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.certificationAuthority = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.certificationName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.certificationCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.certificationValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certification {
    return {
      certificationAuthority: isSet(object.certificationAuthority)
        ? globalThis.String(object.certificationAuthority)
        : undefined,
      certificationName: isSet(object.certificationName) ? globalThis.String(object.certificationName) : undefined,
      certificationCode: isSet(object.certificationCode) ? globalThis.String(object.certificationCode) : undefined,
      certificationValue: isSet(object.certificationValue) ? globalThis.String(object.certificationValue) : undefined,
    };
  },

  toJSON(message: Certification): unknown {
    const obj: any = {};
    if (message.certificationAuthority !== undefined) {
      obj.certificationAuthority = message.certificationAuthority;
    }
    if (message.certificationName !== undefined) {
      obj.certificationName = message.certificationName;
    }
    if (message.certificationCode !== undefined) {
      obj.certificationCode = message.certificationCode;
    }
    if (message.certificationValue !== undefined) {
      obj.certificationValue = message.certificationValue;
    }
    return obj;
  },

  create(base?: DeepPartial<Certification>): Certification {
    return Certification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Certification>): Certification {
    const message = createBaseCertification();
    message.certificationAuthority = object.certificationAuthority ?? undefined;
    message.certificationName = object.certificationName ?? undefined;
    message.certificationCode = object.certificationCode ?? undefined;
    message.certificationValue = object.certificationValue ?? undefined;
    return message;
  },
};

function createBaseProductStructuredTitle(): ProductStructuredTitle {
  return { digitalSourceType: undefined, content: undefined };
}

export const ProductStructuredTitle: MessageFns<ProductStructuredTitle> = {
  encode(message: ProductStructuredTitle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.digitalSourceType !== undefined) {
      writer.uint32(10).string(message.digitalSourceType);
    }
    if (message.content !== undefined) {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductStructuredTitle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductStructuredTitle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.digitalSourceType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductStructuredTitle {
    return {
      digitalSourceType: isSet(object.digitalSourceType) ? globalThis.String(object.digitalSourceType) : undefined,
      content: isSet(object.content) ? globalThis.String(object.content) : undefined,
    };
  },

  toJSON(message: ProductStructuredTitle): unknown {
    const obj: any = {};
    if (message.digitalSourceType !== undefined) {
      obj.digitalSourceType = message.digitalSourceType;
    }
    if (message.content !== undefined) {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductStructuredTitle>): ProductStructuredTitle {
    return ProductStructuredTitle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductStructuredTitle>): ProductStructuredTitle {
    const message = createBaseProductStructuredTitle();
    message.digitalSourceType = object.digitalSourceType ?? undefined;
    message.content = object.content ?? undefined;
    return message;
  },
};

function createBaseProductStructuredDescription(): ProductStructuredDescription {
  return { digitalSourceType: undefined, content: undefined };
}

export const ProductStructuredDescription: MessageFns<ProductStructuredDescription> = {
  encode(message: ProductStructuredDescription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.digitalSourceType !== undefined) {
      writer.uint32(10).string(message.digitalSourceType);
    }
    if (message.content !== undefined) {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductStructuredDescription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductStructuredDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.digitalSourceType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductStructuredDescription {
    return {
      digitalSourceType: isSet(object.digitalSourceType) ? globalThis.String(object.digitalSourceType) : undefined,
      content: isSet(object.content) ? globalThis.String(object.content) : undefined,
    };
  },

  toJSON(message: ProductStructuredDescription): unknown {
    const obj: any = {};
    if (message.digitalSourceType !== undefined) {
      obj.digitalSourceType = message.digitalSourceType;
    }
    if (message.content !== undefined) {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductStructuredDescription>): ProductStructuredDescription {
    return ProductStructuredDescription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductStructuredDescription>): ProductStructuredDescription {
    const message = createBaseProductStructuredDescription();
    message.digitalSourceType = object.digitalSourceType ?? undefined;
    message.content = object.content ?? undefined;
    return message;
  },
};

function createBaseProductDimension(): ProductDimension {
  return { value: 0, unit: "" };
}

export const ProductDimension: MessageFns<ProductDimension> = {
  encode(message: ProductDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    if (message.unit !== "") {
      writer.uint32(18).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.unit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductDimension {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
    };
  },

  toJSON(message: ProductDimension): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductDimension>): ProductDimension {
    return ProductDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductDimension>): ProductDimension {
    const message = createBaseProductDimension();
    message.value = object.value ?? 0;
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseProductWeight(): ProductWeight {
  return { value: 0, unit: "" };
}

export const ProductWeight: MessageFns<ProductWeight> = {
  encode(message: ProductWeight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    if (message.unit !== "") {
      writer.uint32(18).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductWeight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.unit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductWeight {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
    };
  },

  toJSON(message: ProductWeight): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductWeight>): ProductWeight {
    return ProductWeight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductWeight>): ProductWeight {
    const message = createBaseProductWeight();
    message.value = object.value ?? 0;
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseProductStatus(): ProductStatus {
  return {
    destinationStatuses: [],
    itemLevelIssues: [],
    creationDate: undefined,
    lastUpdateDate: undefined,
    googleExpirationDate: undefined,
  };
}

export const ProductStatus: MessageFns<ProductStatus> = {
  encode(message: ProductStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.destinationStatuses) {
      ProductStatus_DestinationStatus.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.itemLevelIssues) {
      ProductStatus_ItemLevelIssue.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.creationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDate), writer.uint32(42).fork()).join();
    }
    if (message.lastUpdateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdateDate), writer.uint32(50).fork()).join();
    }
    if (message.googleExpirationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.googleExpirationDate), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destinationStatuses.push(ProductStatus_DestinationStatus.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.itemLevelIssues.push(ProductStatus_ItemLevelIssue.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.lastUpdateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.googleExpirationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductStatus {
    return {
      destinationStatuses: globalThis.Array.isArray(object?.destinationStatuses)
        ? object.destinationStatuses.map((e: any) => ProductStatus_DestinationStatus.fromJSON(e))
        : [],
      itemLevelIssues: globalThis.Array.isArray(object?.itemLevelIssues)
        ? object.itemLevelIssues.map((e: any) => ProductStatus_ItemLevelIssue.fromJSON(e))
        : [],
      creationDate: isSet(object.creationDate) ? fromJsonTimestamp(object.creationDate) : undefined,
      lastUpdateDate: isSet(object.lastUpdateDate) ? fromJsonTimestamp(object.lastUpdateDate) : undefined,
      googleExpirationDate: isSet(object.googleExpirationDate)
        ? fromJsonTimestamp(object.googleExpirationDate)
        : undefined,
    };
  },

  toJSON(message: ProductStatus): unknown {
    const obj: any = {};
    if (message.destinationStatuses?.length) {
      obj.destinationStatuses = message.destinationStatuses.map((e) => ProductStatus_DestinationStatus.toJSON(e));
    }
    if (message.itemLevelIssues?.length) {
      obj.itemLevelIssues = message.itemLevelIssues.map((e) => ProductStatus_ItemLevelIssue.toJSON(e));
    }
    if (message.creationDate !== undefined) {
      obj.creationDate = message.creationDate.toISOString();
    }
    if (message.lastUpdateDate !== undefined) {
      obj.lastUpdateDate = message.lastUpdateDate.toISOString();
    }
    if (message.googleExpirationDate !== undefined) {
      obj.googleExpirationDate = message.googleExpirationDate.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ProductStatus>): ProductStatus {
    return ProductStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductStatus>): ProductStatus {
    const message = createBaseProductStatus();
    message.destinationStatuses =
      object.destinationStatuses?.map((e) => ProductStatus_DestinationStatus.fromPartial(e)) || [];
    message.itemLevelIssues = object.itemLevelIssues?.map((e) => ProductStatus_ItemLevelIssue.fromPartial(e)) || [];
    message.creationDate = object.creationDate ?? undefined;
    message.lastUpdateDate = object.lastUpdateDate ?? undefined;
    message.googleExpirationDate = object.googleExpirationDate ?? undefined;
    return message;
  },
};

function createBaseProductStatus_DestinationStatus(): ProductStatus_DestinationStatus {
  return { reportingContext: 0, approvedCountries: [], pendingCountries: [], disapprovedCountries: [] };
}

export const ProductStatus_DestinationStatus: MessageFns<ProductStatus_DestinationStatus> = {
  encode(message: ProductStatus_DestinationStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reportingContext !== 0) {
      writer.uint32(8).int32(message.reportingContext);
    }
    for (const v of message.approvedCountries) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.pendingCountries) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.disapprovedCountries) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductStatus_DestinationStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductStatus_DestinationStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reportingContext = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.approvedCountries.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pendingCountries.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.disapprovedCountries.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductStatus_DestinationStatus {
    return {
      reportingContext: isSet(object.reportingContext)
        ? reportingContext_ReportingContextEnumFromJSON(object.reportingContext)
        : 0,
      approvedCountries: globalThis.Array.isArray(object?.approvedCountries)
        ? object.approvedCountries.map((e: any) => globalThis.String(e))
        : [],
      pendingCountries: globalThis.Array.isArray(object?.pendingCountries)
        ? object.pendingCountries.map((e: any) => globalThis.String(e))
        : [],
      disapprovedCountries: globalThis.Array.isArray(object?.disapprovedCountries)
        ? object.disapprovedCountries.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ProductStatus_DestinationStatus): unknown {
    const obj: any = {};
    if (message.reportingContext !== 0) {
      obj.reportingContext = reportingContext_ReportingContextEnumToJSON(message.reportingContext);
    }
    if (message.approvedCountries?.length) {
      obj.approvedCountries = message.approvedCountries;
    }
    if (message.pendingCountries?.length) {
      obj.pendingCountries = message.pendingCountries;
    }
    if (message.disapprovedCountries?.length) {
      obj.disapprovedCountries = message.disapprovedCountries;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductStatus_DestinationStatus>): ProductStatus_DestinationStatus {
    return ProductStatus_DestinationStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductStatus_DestinationStatus>): ProductStatus_DestinationStatus {
    const message = createBaseProductStatus_DestinationStatus();
    message.reportingContext = object.reportingContext ?? 0;
    message.approvedCountries = object.approvedCountries?.map((e) => e) || [];
    message.pendingCountries = object.pendingCountries?.map((e) => e) || [];
    message.disapprovedCountries = object.disapprovedCountries?.map((e) => e) || [];
    return message;
  },
};

function createBaseProductStatus_ItemLevelIssue(): ProductStatus_ItemLevelIssue {
  return {
    code: "",
    severity: 0,
    resolution: "",
    attribute: "",
    reportingContext: 0,
    description: "",
    detail: "",
    documentation: "",
    applicableCountries: [],
  };
}

export const ProductStatus_ItemLevelIssue: MessageFns<ProductStatus_ItemLevelIssue> = {
  encode(message: ProductStatus_ItemLevelIssue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.severity !== 0) {
      writer.uint32(16).int32(message.severity);
    }
    if (message.resolution !== "") {
      writer.uint32(26).string(message.resolution);
    }
    if (message.attribute !== "") {
      writer.uint32(34).string(message.attribute);
    }
    if (message.reportingContext !== 0) {
      writer.uint32(40).int32(message.reportingContext);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.detail !== "") {
      writer.uint32(58).string(message.detail);
    }
    if (message.documentation !== "") {
      writer.uint32(66).string(message.documentation);
    }
    for (const v of message.applicableCountries) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductStatus_ItemLevelIssue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductStatus_ItemLevelIssue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resolution = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.attribute = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.reportingContext = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.detail = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.documentation = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.applicableCountries.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductStatus_ItemLevelIssue {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      severity: isSet(object.severity) ? productStatus_ItemLevelIssue_SeverityFromJSON(object.severity) : 0,
      resolution: isSet(object.resolution) ? globalThis.String(object.resolution) : "",
      attribute: isSet(object.attribute) ? globalThis.String(object.attribute) : "",
      reportingContext: isSet(object.reportingContext)
        ? reportingContext_ReportingContextEnumFromJSON(object.reportingContext)
        : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      detail: isSet(object.detail) ? globalThis.String(object.detail) : "",
      documentation: isSet(object.documentation) ? globalThis.String(object.documentation) : "",
      applicableCountries: globalThis.Array.isArray(object?.applicableCountries)
        ? object.applicableCountries.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ProductStatus_ItemLevelIssue): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.severity !== 0) {
      obj.severity = productStatus_ItemLevelIssue_SeverityToJSON(message.severity);
    }
    if (message.resolution !== "") {
      obj.resolution = message.resolution;
    }
    if (message.attribute !== "") {
      obj.attribute = message.attribute;
    }
    if (message.reportingContext !== 0) {
      obj.reportingContext = reportingContext_ReportingContextEnumToJSON(message.reportingContext);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.detail !== "") {
      obj.detail = message.detail;
    }
    if (message.documentation !== "") {
      obj.documentation = message.documentation;
    }
    if (message.applicableCountries?.length) {
      obj.applicableCountries = message.applicableCountries;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductStatus_ItemLevelIssue>): ProductStatus_ItemLevelIssue {
    return ProductStatus_ItemLevelIssue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductStatus_ItemLevelIssue>): ProductStatus_ItemLevelIssue {
    const message = createBaseProductStatus_ItemLevelIssue();
    message.code = object.code ?? "";
    message.severity = object.severity ?? 0;
    message.resolution = object.resolution ?? "";
    message.attribute = object.attribute ?? "";
    message.reportingContext = object.reportingContext ?? 0;
    message.description = object.description ?? "";
    message.detail = object.detail ?? "";
    message.documentation = object.documentation ?? "";
    message.applicableCountries = object.applicableCountries?.map((e) => e) || [];
    return message;
  },
};

function createBaseCloudExportAdditionalProperties(): CloudExportAdditionalProperties {
  return {
    propertyName: undefined,
    textValue: [],
    boolValue: undefined,
    intValue: [],
    floatValue: [],
    minValue: undefined,
    maxValue: undefined,
    unitCode: undefined,
  };
}

export const CloudExportAdditionalProperties: MessageFns<CloudExportAdditionalProperties> = {
  encode(message: CloudExportAdditionalProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.propertyName !== undefined) {
      writer.uint32(10).string(message.propertyName);
    }
    for (const v of message.textValue) {
      writer.uint32(18).string(v!);
    }
    if (message.boolValue !== undefined) {
      writer.uint32(24).bool(message.boolValue);
    }
    writer.uint32(34).fork();
    for (const v of message.intValue) {
      writer.int64(v.toString());
    }
    writer.join();
    writer.uint32(42).fork();
    for (const v of message.floatValue) {
      writer.float(v);
    }
    writer.join();
    if (message.minValue !== undefined) {
      writer.uint32(53).float(message.minValue);
    }
    if (message.maxValue !== undefined) {
      writer.uint32(61).float(message.maxValue);
    }
    if (message.unitCode !== undefined) {
      writer.uint32(66).string(message.unitCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudExportAdditionalProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudExportAdditionalProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.propertyName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textValue.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 4:
          if (tag === 32) {
            message.intValue.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.intValue.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
        case 5:
          if (tag === 45) {
            message.floatValue.push(reader.float());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.floatValue.push(reader.float());
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.minValue = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.maxValue = reader.float();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.unitCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudExportAdditionalProperties {
    return {
      propertyName: isSet(object.propertyName) ? globalThis.String(object.propertyName) : undefined,
      textValue: globalThis.Array.isArray(object?.textValue)
        ? object.textValue.map((e: any) => globalThis.String(e))
        : [],
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      intValue: globalThis.Array.isArray(object?.intValue) ? object.intValue.map((e: any) => Long.fromValue(e)) : [],
      floatValue: globalThis.Array.isArray(object?.floatValue)
        ? object.floatValue.map((e: any) => globalThis.Number(e))
        : [],
      minValue: isSet(object.minValue) ? globalThis.Number(object.minValue) : undefined,
      maxValue: isSet(object.maxValue) ? globalThis.Number(object.maxValue) : undefined,
      unitCode: isSet(object.unitCode) ? globalThis.String(object.unitCode) : undefined,
    };
  },

  toJSON(message: CloudExportAdditionalProperties): unknown {
    const obj: any = {};
    if (message.propertyName !== undefined) {
      obj.propertyName = message.propertyName;
    }
    if (message.textValue?.length) {
      obj.textValue = message.textValue;
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.intValue?.length) {
      obj.intValue = message.intValue.map((e) => (e || Long.ZERO).toString());
    }
    if (message.floatValue?.length) {
      obj.floatValue = message.floatValue;
    }
    if (message.minValue !== undefined) {
      obj.minValue = message.minValue;
    }
    if (message.maxValue !== undefined) {
      obj.maxValue = message.maxValue;
    }
    if (message.unitCode !== undefined) {
      obj.unitCode = message.unitCode;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudExportAdditionalProperties>): CloudExportAdditionalProperties {
    return CloudExportAdditionalProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudExportAdditionalProperties>): CloudExportAdditionalProperties {
    const message = createBaseCloudExportAdditionalProperties();
    message.propertyName = object.propertyName ?? undefined;
    message.textValue = object.textValue?.map((e) => e) || [];
    message.boolValue = object.boolValue ?? undefined;
    message.intValue = object.intValue?.map((e) => Long.fromValue(e)) || [];
    message.floatValue = object.floatValue?.map((e) => e) || [];
    message.minValue = object.minValue ?? undefined;
    message.maxValue = object.maxValue ?? undefined;
    message.unitCode = object.unitCode ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
