// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/shopping/merchant/datasources/v1beta/datasources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import {
  LocalInventoryDataSource,
  PrimaryProductDataSource,
  PromotionDataSource,
  RegionalInventoryDataSource,
  SupplementalProductDataSource,
} from "./datasourcetypes.js";
import { FileInput } from "./fileinputs.js";

export const protobufPackage = "google.shopping.merchant.datasources.v1beta";

/**
 * The [data source](https://support.google.com/merchants/answer/7439058) for
 * the Merchant Center account.
 */
export interface DataSource {
  /**
   * Required. The [primary data
   * source](https://support.google.com/merchants/answer/7439058) for local
   * and online products.
   */
  primaryProductDataSource?:
    | PrimaryProductDataSource
    | undefined;
  /**
   * Required. The [supplemental data
   * source](https://support.google.com/merchants/answer/7439058) for local
   * and online products.
   */
  supplementalProductDataSource?:
    | SupplementalProductDataSource
    | undefined;
  /**
   * Required. The [local
   * inventory](https://support.google.com/merchants/answer/7023001) data
   * source.
   */
  localInventoryDataSource?:
    | LocalInventoryDataSource
    | undefined;
  /**
   * Required. The [regional
   * inventory](https://support.google.com/merchants/answer/7439058) data
   * source.
   */
  regionalInventoryDataSource?:
    | RegionalInventoryDataSource
    | undefined;
  /**
   * Required. The
   * [promotion](https://support.google.com/merchants/answer/2906014) data
   * source.
   */
  promotionDataSource?:
    | PromotionDataSource
    | undefined;
  /**
   * Identifier. The name of the data source.
   * Format:
   * `{datasource.name=accounts/{account}/dataSources/{datasource}}`
   */
  name: string;
  /** Output only. The data source id. */
  dataSourceId: Long;
  /** Required. The displayed data source name in the Merchant Center UI. */
  displayName: string;
  /**
   * Output only. Determines the type of input to the data source. Based on the
   * input some settings might not work. Only generic data sources can be
   * created through the API.
   */
  input: DataSource_Input;
  /** Optional. The field is used only when data is managed through a file. */
  fileInput: FileInput | undefined;
}

/**
 * Determines the type of input to the data source. Based on the input some
 * settings might not be supported.
 */
export enum DataSource_Input {
  /** INPUT_UNSPECIFIED - Input unspecified. */
  INPUT_UNSPECIFIED = 0,
  /**
   * API - Represents data sources for which the data is primarily provided through
   * the API.
   */
  API = 1,
  /**
   * FILE - Represents data sources for which the data is primarily provided through
   * file input. Data can still be provided through the API.
   */
  FILE = 2,
  /**
   * UI - The data source for products added directly in Merchant Center.
   *
   * This type of data source can not be created or updated through this API,
   * only by Merchant Center UI.
   *
   * This type of data source is read only.
   */
  UI = 3,
  /**
   * AUTOFEED - This is also known as
   * [Automated feeds](https://support.google.com/merchants/answer/12158480)
   * used to automatically build your product data. This type of data source
   * can be enabled or disabled through the Accounts bundle.
   */
  AUTOFEED = 4,
  UNRECOGNIZED = -1,
}

export function dataSource_InputFromJSON(object: any): DataSource_Input {
  switch (object) {
    case 0:
    case "INPUT_UNSPECIFIED":
      return DataSource_Input.INPUT_UNSPECIFIED;
    case 1:
    case "API":
      return DataSource_Input.API;
    case 2:
    case "FILE":
      return DataSource_Input.FILE;
    case 3:
    case "UI":
      return DataSource_Input.UI;
    case 4:
    case "AUTOFEED":
      return DataSource_Input.AUTOFEED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSource_Input.UNRECOGNIZED;
  }
}

export function dataSource_InputToJSON(object: DataSource_Input): string {
  switch (object) {
    case DataSource_Input.INPUT_UNSPECIFIED:
      return "INPUT_UNSPECIFIED";
    case DataSource_Input.API:
      return "API";
    case DataSource_Input.FILE:
      return "FILE";
    case DataSource_Input.UI:
      return "UI";
    case DataSource_Input.AUTOFEED:
      return "AUTOFEED";
    case DataSource_Input.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for the GetDataSource method. */
export interface GetDataSourceRequest {
  /**
   * Required. The name of the data source to retrieve.
   * Format: `accounts/{account}/dataSources/{datasource}`
   */
  name: string;
}

/** Request message for the ListDataSources method. */
export interface ListDataSourcesRequest {
  /**
   * Required. The account to list data sources for.
   * Format: `accounts/{account}`
   */
  parent: string;
  /**
   * Optional. The maximum number of data sources to return. The service may
   * return fewer than this value. The maximum value is 1000; values above 1000
   * will be coerced to 1000. If unspecified, the maximum number of data sources
   * will be returned.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListDataSources` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListDataSources`
   * must match the call that provided the page token.
   */
  pageToken: string;
}

/** Response message for the ListDataSources method. */
export interface ListDataSourcesResponse {
  /** The data sources from the specified account. */
  dataSources: DataSource[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request message for the CreateDataSource method. */
export interface CreateDataSourceRequest {
  /**
   * Required. The account where this data source will be created.
   * Format: `accounts/{account}`
   */
  parent: string;
  /** Required. The data source to create. */
  dataSource: DataSource | undefined;
}

/** Request message for the UpdateDataSource method. */
export interface UpdateDataSourceRequest {
  /** Required. The data source resource to update. */
  dataSource:
    | DataSource
    | undefined;
  /**
   * Required. The list of data source fields to be updated.
   *
   * Fields specified in the update mask without a value specified in the
   * body will be deleted from the data source.
   *
   * Providing special "*" value for full data source replacement is not
   * supported.
   */
  updateMask: string[] | undefined;
}

/** Request message for the FetchDataSource method. */
export interface FetchDataSourceRequest {
  /**
   * Required. The name of the data source resource to fetch.
   * Format: `accounts/{account}/dataSources/{datasource}`
   */
  name: string;
}

/** Request message for the DeleteDataSource method. */
export interface DeleteDataSourceRequest {
  /**
   * Required. The name of the data source to delete.
   * Format: `accounts/{account}/dataSources/{datasource}`
   */
  name: string;
}

function createBaseDataSource(): DataSource {
  return {
    primaryProductDataSource: undefined,
    supplementalProductDataSource: undefined,
    localInventoryDataSource: undefined,
    regionalInventoryDataSource: undefined,
    promotionDataSource: undefined,
    name: "",
    dataSourceId: Long.ZERO,
    displayName: "",
    input: 0,
    fileInput: undefined,
  };
}

export const DataSource: MessageFns<DataSource> = {
  encode(message: DataSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primaryProductDataSource !== undefined) {
      PrimaryProductDataSource.encode(message.primaryProductDataSource, writer.uint32(34).fork()).join();
    }
    if (message.supplementalProductDataSource !== undefined) {
      SupplementalProductDataSource.encode(message.supplementalProductDataSource, writer.uint32(42).fork()).join();
    }
    if (message.localInventoryDataSource !== undefined) {
      LocalInventoryDataSource.encode(message.localInventoryDataSource, writer.uint32(50).fork()).join();
    }
    if (message.regionalInventoryDataSource !== undefined) {
      RegionalInventoryDataSource.encode(message.regionalInventoryDataSource, writer.uint32(58).fork()).join();
    }
    if (message.promotionDataSource !== undefined) {
      PromotionDataSource.encode(message.promotionDataSource, writer.uint32(66).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.dataSourceId.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.dataSourceId.toString());
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.input !== 0) {
      writer.uint32(80).int32(message.input);
    }
    if (message.fileInput !== undefined) {
      FileInput.encode(message.fileInput, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.primaryProductDataSource = PrimaryProductDataSource.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.supplementalProductDataSource = SupplementalProductDataSource.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.localInventoryDataSource = LocalInventoryDataSource.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.regionalInventoryDataSource = RegionalInventoryDataSource.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.promotionDataSource = PromotionDataSource.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dataSourceId = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.input = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.fileInput = FileInput.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSource {
    return {
      primaryProductDataSource: isSet(object.primaryProductDataSource)
        ? PrimaryProductDataSource.fromJSON(object.primaryProductDataSource)
        : undefined,
      supplementalProductDataSource: isSet(object.supplementalProductDataSource)
        ? SupplementalProductDataSource.fromJSON(object.supplementalProductDataSource)
        : undefined,
      localInventoryDataSource: isSet(object.localInventoryDataSource)
        ? LocalInventoryDataSource.fromJSON(object.localInventoryDataSource)
        : undefined,
      regionalInventoryDataSource: isSet(object.regionalInventoryDataSource)
        ? RegionalInventoryDataSource.fromJSON(object.regionalInventoryDataSource)
        : undefined,
      promotionDataSource: isSet(object.promotionDataSource)
        ? PromotionDataSource.fromJSON(object.promotionDataSource)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataSourceId: isSet(object.dataSourceId) ? Long.fromValue(object.dataSourceId) : Long.ZERO,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      input: isSet(object.input) ? dataSource_InputFromJSON(object.input) : 0,
      fileInput: isSet(object.fileInput) ? FileInput.fromJSON(object.fileInput) : undefined,
    };
  },

  toJSON(message: DataSource): unknown {
    const obj: any = {};
    if (message.primaryProductDataSource !== undefined) {
      obj.primaryProductDataSource = PrimaryProductDataSource.toJSON(message.primaryProductDataSource);
    }
    if (message.supplementalProductDataSource !== undefined) {
      obj.supplementalProductDataSource = SupplementalProductDataSource.toJSON(message.supplementalProductDataSource);
    }
    if (message.localInventoryDataSource !== undefined) {
      obj.localInventoryDataSource = LocalInventoryDataSource.toJSON(message.localInventoryDataSource);
    }
    if (message.regionalInventoryDataSource !== undefined) {
      obj.regionalInventoryDataSource = RegionalInventoryDataSource.toJSON(message.regionalInventoryDataSource);
    }
    if (message.promotionDataSource !== undefined) {
      obj.promotionDataSource = PromotionDataSource.toJSON(message.promotionDataSource);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.dataSourceId.equals(Long.ZERO)) {
      obj.dataSourceId = (message.dataSourceId || Long.ZERO).toString();
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.input !== 0) {
      obj.input = dataSource_InputToJSON(message.input);
    }
    if (message.fileInput !== undefined) {
      obj.fileInput = FileInput.toJSON(message.fileInput);
    }
    return obj;
  },

  create(base?: DeepPartial<DataSource>): DataSource {
    return DataSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSource>): DataSource {
    const message = createBaseDataSource();
    message.primaryProductDataSource =
      (object.primaryProductDataSource !== undefined && object.primaryProductDataSource !== null)
        ? PrimaryProductDataSource.fromPartial(object.primaryProductDataSource)
        : undefined;
    message.supplementalProductDataSource =
      (object.supplementalProductDataSource !== undefined && object.supplementalProductDataSource !== null)
        ? SupplementalProductDataSource.fromPartial(object.supplementalProductDataSource)
        : undefined;
    message.localInventoryDataSource =
      (object.localInventoryDataSource !== undefined && object.localInventoryDataSource !== null)
        ? LocalInventoryDataSource.fromPartial(object.localInventoryDataSource)
        : undefined;
    message.regionalInventoryDataSource =
      (object.regionalInventoryDataSource !== undefined && object.regionalInventoryDataSource !== null)
        ? RegionalInventoryDataSource.fromPartial(object.regionalInventoryDataSource)
        : undefined;
    message.promotionDataSource = (object.promotionDataSource !== undefined && object.promotionDataSource !== null)
      ? PromotionDataSource.fromPartial(object.promotionDataSource)
      : undefined;
    message.name = object.name ?? "";
    message.dataSourceId = (object.dataSourceId !== undefined && object.dataSourceId !== null)
      ? Long.fromValue(object.dataSourceId)
      : Long.ZERO;
    message.displayName = object.displayName ?? "";
    message.input = object.input ?? 0;
    message.fileInput = (object.fileInput !== undefined && object.fileInput !== null)
      ? FileInput.fromPartial(object.fileInput)
      : undefined;
    return message;
  },
};

function createBaseGetDataSourceRequest(): GetDataSourceRequest {
  return { name: "" };
}

export const GetDataSourceRequest: MessageFns<GetDataSourceRequest> = {
  encode(message: GetDataSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDataSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDataSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDataSourceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDataSourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDataSourceRequest>): GetDataSourceRequest {
    return GetDataSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDataSourceRequest>): GetDataSourceRequest {
    const message = createBaseGetDataSourceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListDataSourcesRequest(): ListDataSourcesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListDataSourcesRequest: MessageFns<ListDataSourcesRequest> = {
  encode(message: ListDataSourcesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDataSourcesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDataSourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDataSourcesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListDataSourcesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDataSourcesRequest>): ListDataSourcesRequest {
    return ListDataSourcesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDataSourcesRequest>): ListDataSourcesRequest {
    const message = createBaseListDataSourcesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListDataSourcesResponse(): ListDataSourcesResponse {
  return { dataSources: [], nextPageToken: "" };
}

export const ListDataSourcesResponse: MessageFns<ListDataSourcesResponse> = {
  encode(message: ListDataSourcesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dataSources) {
      DataSource.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDataSourcesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDataSourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSources.push(DataSource.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDataSourcesResponse {
    return {
      dataSources: globalThis.Array.isArray(object?.dataSources)
        ? object.dataSources.map((e: any) => DataSource.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDataSourcesResponse): unknown {
    const obj: any = {};
    if (message.dataSources?.length) {
      obj.dataSources = message.dataSources.map((e) => DataSource.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDataSourcesResponse>): ListDataSourcesResponse {
    return ListDataSourcesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDataSourcesResponse>): ListDataSourcesResponse {
    const message = createBaseListDataSourcesResponse();
    message.dataSources = object.dataSources?.map((e) => DataSource.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateDataSourceRequest(): CreateDataSourceRequest {
  return { parent: "", dataSource: undefined };
}

export const CreateDataSourceRequest: MessageFns<CreateDataSourceRequest> = {
  encode(message: CreateDataSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.dataSource !== undefined) {
      DataSource.encode(message.dataSource, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDataSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDataSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataSource = DataSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDataSourceRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      dataSource: isSet(object.dataSource) ? DataSource.fromJSON(object.dataSource) : undefined,
    };
  },

  toJSON(message: CreateDataSourceRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.dataSource !== undefined) {
      obj.dataSource = DataSource.toJSON(message.dataSource);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDataSourceRequest>): CreateDataSourceRequest {
    return CreateDataSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDataSourceRequest>): CreateDataSourceRequest {
    const message = createBaseCreateDataSourceRequest();
    message.parent = object.parent ?? "";
    message.dataSource = (object.dataSource !== undefined && object.dataSource !== null)
      ? DataSource.fromPartial(object.dataSource)
      : undefined;
    return message;
  },
};

function createBaseUpdateDataSourceRequest(): UpdateDataSourceRequest {
  return { dataSource: undefined, updateMask: undefined };
}

export const UpdateDataSourceRequest: MessageFns<UpdateDataSourceRequest> = {
  encode(message: UpdateDataSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataSource !== undefined) {
      DataSource.encode(message.dataSource, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDataSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDataSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSource = DataSource.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDataSourceRequest {
    return {
      dataSource: isSet(object.dataSource) ? DataSource.fromJSON(object.dataSource) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateDataSourceRequest): unknown {
    const obj: any = {};
    if (message.dataSource !== undefined) {
      obj.dataSource = DataSource.toJSON(message.dataSource);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDataSourceRequest>): UpdateDataSourceRequest {
    return UpdateDataSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDataSourceRequest>): UpdateDataSourceRequest {
    const message = createBaseUpdateDataSourceRequest();
    message.dataSource = (object.dataSource !== undefined && object.dataSource !== null)
      ? DataSource.fromPartial(object.dataSource)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseFetchDataSourceRequest(): FetchDataSourceRequest {
  return { name: "" };
}

export const FetchDataSourceRequest: MessageFns<FetchDataSourceRequest> = {
  encode(message: FetchDataSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchDataSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchDataSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchDataSourceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: FetchDataSourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchDataSourceRequest>): FetchDataSourceRequest {
    return FetchDataSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchDataSourceRequest>): FetchDataSourceRequest {
    const message = createBaseFetchDataSourceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteDataSourceRequest(): DeleteDataSourceRequest {
  return { name: "" };
}

export const DeleteDataSourceRequest: MessageFns<DeleteDataSourceRequest> = {
  encode(message: DeleteDataSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDataSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDataSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDataSourceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteDataSourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDataSourceRequest>): DeleteDataSourceRequest {
    return DeleteDataSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDataSourceRequest>): DeleteDataSourceRequest {
    const message = createBaseDeleteDataSourceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

/**
 * Service to manage primary, supplemental, inventory and other data sources.
 * See more in the [Merchant
 * Center](https://support.google.com/merchants/answer/7439058) help article.
 */
export type DataSourcesServiceDefinition = typeof DataSourcesServiceDefinition;
export const DataSourcesServiceDefinition = {
  name: "DataSourcesService",
  fullName: "google.shopping.merchant.datasources.v1beta.DataSourcesService",
  methods: {
    /** Retrieves the data source configuration for the given account. */
    getDataSource: {
      name: "GetDataSource",
      requestType: GetDataSourceRequest,
      requestStream: false,
      responseType: DataSource,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              100,
              97,
              116,
              97,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists the configurations for data sources for the given account. */
    listDataSources: {
      name: "ListDataSources",
      requestType: ListDataSourcesRequest,
      requestStream: false,
      responseType: ListDataSourcesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              100,
              97,
              116,
              97,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              83,
              111,
              117,
              114,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates the new data source configuration for the given account. */
    createDataSource: {
      name: "CreateDataSource",
      requestType: CreateDataSourceRequest,
      requestStream: false,
      responseType: DataSource,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([18, 112, 97, 114, 101, 110, 116, 44, 100, 97, 116, 97, 95, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              66,
              58,
              11,
              100,
              97,
              116,
              97,
              95,
              115,
              111,
              117,
              114,
              99,
              101,
              34,
              51,
              47,
              100,
              97,
              116,
              97,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              83,
              111,
              117,
              114,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the existing data source configuration. The fields that are
     * set in the update mask but not provided in the resource will be deleted.
     */
    updateDataSource: {
      name: "UpdateDataSource",
      requestType: UpdateDataSourceRequest,
      requestStream: false,
      responseType: DataSource,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              100,
              97,
              116,
              97,
              95,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              78,
              58,
              11,
              100,
              97,
              116,
              97,
              95,
              115,
              111,
              117,
              114,
              99,
              101,
              50,
              63,
              47,
              100,
              97,
              116,
              97,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              100,
              97,
              116,
              97,
              95,
              115,
              111,
              117,
              114,
              99,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a data source from your Merchant Center account. */
    deleteDataSource: {
      name: "DeleteDataSource",
      requestType: DeleteDataSourceRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              42,
              51,
              47,
              100,
              97,
              116,
              97,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Performs the data fetch immediately (even outside fetch schedule) on a
     * data source from your Merchant Center Account. If you need to call
     * this method more than once per day, you should use the Products service to
     * update your product data instead.
     * This method only works on data sources with a file input set.
     */
    fetchDataSource: {
      name: "FetchDataSource",
      requestType: FetchDataSourceRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              62,
              58,
              1,
              42,
              34,
              57,
              47,
              100,
              97,
              116,
              97,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              83,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              102,
              101,
              116,
              99,
              104,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface DataSourcesServiceImplementation<CallContextExt = {}> {
  /** Retrieves the data source configuration for the given account. */
  getDataSource(request: GetDataSourceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<DataSource>>;
  /** Lists the configurations for data sources for the given account. */
  listDataSources(
    request: ListDataSourcesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDataSourcesResponse>>;
  /** Creates the new data source configuration for the given account. */
  createDataSource(
    request: CreateDataSourceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DataSource>>;
  /**
   * Updates the existing data source configuration. The fields that are
   * set in the update mask but not provided in the resource will be deleted.
   */
  updateDataSource(
    request: UpdateDataSourceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DataSource>>;
  /** Deletes a data source from your Merchant Center account. */
  deleteDataSource(
    request: DeleteDataSourceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Performs the data fetch immediately (even outside fetch schedule) on a
   * data source from your Merchant Center Account. If you need to call
   * this method more than once per day, you should use the Products service to
   * update your product data instead.
   * This method only works on data sources with a file input set.
   */
  fetchDataSource(request: FetchDataSourceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
}

export interface DataSourcesServiceClient<CallOptionsExt = {}> {
  /** Retrieves the data source configuration for the given account. */
  getDataSource(
    request: DeepPartial<GetDataSourceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DataSource>;
  /** Lists the configurations for data sources for the given account. */
  listDataSources(
    request: DeepPartial<ListDataSourcesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDataSourcesResponse>;
  /** Creates the new data source configuration for the given account. */
  createDataSource(
    request: DeepPartial<CreateDataSourceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DataSource>;
  /**
   * Updates the existing data source configuration. The fields that are
   * set in the update mask but not provided in the resource will be deleted.
   */
  updateDataSource(
    request: DeepPartial<UpdateDataSourceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DataSource>;
  /** Deletes a data source from your Merchant Center account. */
  deleteDataSource(
    request: DeepPartial<DeleteDataSourceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Performs the data fetch immediately (even outside fetch schedule) on a
   * data source from your Merchant Center Account. If you need to call
   * this method more than once per day, you should use the Products service to
   * update your product data instead.
   * This method only works on data sources with a file input set.
   */
  fetchDataSource(request: DeepPartial<FetchDataSourceRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
