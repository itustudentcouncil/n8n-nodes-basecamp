// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/shopping/merchant/datasources/v1beta/fileinputs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { DayOfWeek, dayOfWeekFromJSON, dayOfWeekToJSON } from "../../../../type/dayofweek.js";
import { TimeOfDay } from "../../../../type/timeofday.js";

export const protobufPackage = "google.shopping.merchant.datasources.v1beta";

/**
 * The data specific for file data sources. This field is empty for other
 * data source inputs.
 */
export interface FileInput {
  /**
   * Optional. Fetch details to deliver the data source. It contains settings
   * for `FETCH` and `GOOGLE_SHEETS` file input types. The required fields vary
   * based on the frequency of fetching.
   */
  fetchSettings:
    | FileInput_FetchSettings
    | undefined;
  /**
   * Optional. The file name of the data source. Required for `UPLOAD` file
   * input type.
   */
  fileName: string;
  /** Output only. The type of file input. */
  fileInputType: FileInput_FileInputType;
}

/** The method of file delivery. */
export enum FileInput_FileInputType {
  /** FILE_INPUT_TYPE_UNSPECIFIED - File input type unspecified. */
  FILE_INPUT_TYPE_UNSPECIFIED = 0,
  /**
   * UPLOAD - The file is uploaded through SFTP, Google Cloud Storage or manually in
   * the Merchant Center.
   */
  UPLOAD = 1,
  /**
   * FETCH - The file is fetched from the configured
   * [fetch_uri][google.shopping.content.bundles.DataSources.FileInput.FetchSettings.fetch_uri].
   */
  FETCH = 2,
  /**
   * GOOGLE_SHEETS - The file is fetched from Google Sheets specified in the
   * [fetch_uri][google.shopping.content.bundles.DataSources.FileInput.FetchSettings.fetch_uri].
   */
  GOOGLE_SHEETS = 3,
  UNRECOGNIZED = -1,
}

export function fileInput_FileInputTypeFromJSON(object: any): FileInput_FileInputType {
  switch (object) {
    case 0:
    case "FILE_INPUT_TYPE_UNSPECIFIED":
      return FileInput_FileInputType.FILE_INPUT_TYPE_UNSPECIFIED;
    case 1:
    case "UPLOAD":
      return FileInput_FileInputType.UPLOAD;
    case 2:
    case "FETCH":
      return FileInput_FileInputType.FETCH;
    case 3:
    case "GOOGLE_SHEETS":
      return FileInput_FileInputType.GOOGLE_SHEETS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileInput_FileInputType.UNRECOGNIZED;
  }
}

export function fileInput_FileInputTypeToJSON(object: FileInput_FileInputType): string {
  switch (object) {
    case FileInput_FileInputType.FILE_INPUT_TYPE_UNSPECIFIED:
      return "FILE_INPUT_TYPE_UNSPECIFIED";
    case FileInput_FileInputType.UPLOAD:
      return "UPLOAD";
    case FileInput_FileInputType.FETCH:
      return "FETCH";
    case FileInput_FileInputType.GOOGLE_SHEETS:
      return "GOOGLE_SHEETS";
    case FileInput_FileInputType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Fetch details to deliver the data source. */
export interface FileInput_FetchSettings {
  /** Optional. Enables or pauses the fetch schedule. */
  enabled: boolean;
  /**
   * Optional. The day of the month when the data source file should be
   * fetched (1-31). This field can only be set for monthly frequency.
   */
  dayOfMonth: number;
  /**
   * Optional. The hour of the day when the data source file should be
   * fetched. Minutes and seconds are not supported and will be ignored.
   */
  timeOfDay:
    | TimeOfDay
    | undefined;
  /**
   * Optional. The day of the week when the data source file should be
   * fetched. This field can only be set for weekly frequency.
   */
  dayOfWeek: DayOfWeek;
  /**
   * Optional. [Time zone](https://cldr.unicode.org) used for schedule. UTC by
   * default. For example, "America/Los_Angeles".
   */
  timeZone: string;
  /** Required. The frequency describing fetch schedule. */
  frequency: FileInput_FetchSettings_Frequency;
  /**
   * Optional. The URL where the data source file can be fetched. Google
   * Merchant Center supports automatic scheduled uploads using the HTTP,
   * HTTPS or SFTP protocols, so the value will need to be a valid link using
   * one of those three protocols. Immutable for Google Sheets files.
   */
  fetchUri: string;
  /**
   * Optional. An optional user name for [fetch
   * url][google.shopping.content.bundles.DataSources.FileInput.fetch_url].
   * Used for [submitting data sources through
   * SFTP](https://support.google.com/merchants/answer/13813117).
   */
  username: string;
  /**
   * Optional. An optional password for [fetch
   * url][google.shopping.content.bundles.DataSources.FileInput.fetch_url].
   * Used for [submitting data sources through
   * SFTP](https://support.google.com/merchants/answer/13813117).
   */
  password: string;
}

/**
 * The required fields vary based on the frequency of fetching. For a
 * monthly
 * fetch schedule,
 * [day of
 * month][google.shopping.content.bundles.DataSources.FileInput.FetchSchedule.day_of_month]
 * and
 * [hour of
 * day][google.shopping.content.bundles.DataSources.FileInput.FetchSchedule.time_of_day]
 * are required. For a weekly fetch schedule,
 * [day of
 * week][google.shopping.content.bundles.DataSources.FileInput.FetchSchedule.day_of_week]
 * and [hour of
 * day][google.shopping.content.bundles.DataSources.FileInput.FetchSchedule.time_of_day]
 * are required. For a daily fetch schedule, only an [hour of
 * day][google.shopping.content.bundles.DataSources.FileInput.FetchSchedule.time_of_day]
 * is required.
 */
export enum FileInput_FetchSettings_Frequency {
  /** FREQUENCY_UNSPECIFIED - Frequency unspecified. */
  FREQUENCY_UNSPECIFIED = 0,
  /** FREQUENCY_DAILY - The fetch happens every day. */
  FREQUENCY_DAILY = 1,
  /** FREQUENCY_WEEKLY - The fetch happens every week. */
  FREQUENCY_WEEKLY = 2,
  /** FREQUENCY_MONTHLY - The fetch happens every month. */
  FREQUENCY_MONTHLY = 3,
  UNRECOGNIZED = -1,
}

export function fileInput_FetchSettings_FrequencyFromJSON(object: any): FileInput_FetchSettings_Frequency {
  switch (object) {
    case 0:
    case "FREQUENCY_UNSPECIFIED":
      return FileInput_FetchSettings_Frequency.FREQUENCY_UNSPECIFIED;
    case 1:
    case "FREQUENCY_DAILY":
      return FileInput_FetchSettings_Frequency.FREQUENCY_DAILY;
    case 2:
    case "FREQUENCY_WEEKLY":
      return FileInput_FetchSettings_Frequency.FREQUENCY_WEEKLY;
    case 3:
    case "FREQUENCY_MONTHLY":
      return FileInput_FetchSettings_Frequency.FREQUENCY_MONTHLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileInput_FetchSettings_Frequency.UNRECOGNIZED;
  }
}

export function fileInput_FetchSettings_FrequencyToJSON(object: FileInput_FetchSettings_Frequency): string {
  switch (object) {
    case FileInput_FetchSettings_Frequency.FREQUENCY_UNSPECIFIED:
      return "FREQUENCY_UNSPECIFIED";
    case FileInput_FetchSettings_Frequency.FREQUENCY_DAILY:
      return "FREQUENCY_DAILY";
    case FileInput_FetchSettings_Frequency.FREQUENCY_WEEKLY:
      return "FREQUENCY_WEEKLY";
    case FileInput_FetchSettings_Frequency.FREQUENCY_MONTHLY:
      return "FREQUENCY_MONTHLY";
    case FileInput_FetchSettings_Frequency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseFileInput(): FileInput {
  return { fetchSettings: undefined, fileName: "", fileInputType: 0 };
}

export const FileInput: MessageFns<FileInput> = {
  encode(message: FileInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fetchSettings !== undefined) {
      FileInput_FetchSettings.encode(message.fetchSettings, writer.uint32(10).fork()).join();
    }
    if (message.fileName !== "") {
      writer.uint32(18).string(message.fileName);
    }
    if (message.fileInputType !== 0) {
      writer.uint32(24).int32(message.fileInputType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fetchSettings = FileInput_FetchSettings.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fileName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fileInputType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileInput {
    return {
      fetchSettings: isSet(object.fetchSettings) ? FileInput_FetchSettings.fromJSON(object.fetchSettings) : undefined,
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      fileInputType: isSet(object.fileInputType) ? fileInput_FileInputTypeFromJSON(object.fileInputType) : 0,
    };
  },

  toJSON(message: FileInput): unknown {
    const obj: any = {};
    if (message.fetchSettings !== undefined) {
      obj.fetchSettings = FileInput_FetchSettings.toJSON(message.fetchSettings);
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.fileInputType !== 0) {
      obj.fileInputType = fileInput_FileInputTypeToJSON(message.fileInputType);
    }
    return obj;
  },

  create(base?: DeepPartial<FileInput>): FileInput {
    return FileInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileInput>): FileInput {
    const message = createBaseFileInput();
    message.fetchSettings = (object.fetchSettings !== undefined && object.fetchSettings !== null)
      ? FileInput_FetchSettings.fromPartial(object.fetchSettings)
      : undefined;
    message.fileName = object.fileName ?? "";
    message.fileInputType = object.fileInputType ?? 0;
    return message;
  },
};

function createBaseFileInput_FetchSettings(): FileInput_FetchSettings {
  return {
    enabled: false,
    dayOfMonth: 0,
    timeOfDay: undefined,
    dayOfWeek: 0,
    timeZone: "",
    frequency: 0,
    fetchUri: "",
    username: "",
    password: "",
  };
}

export const FileInput_FetchSettings: MessageFns<FileInput_FetchSettings> = {
  encode(message: FileInput_FetchSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.dayOfMonth !== 0) {
      writer.uint32(16).int32(message.dayOfMonth);
    }
    if (message.timeOfDay !== undefined) {
      TimeOfDay.encode(message.timeOfDay, writer.uint32(26).fork()).join();
    }
    if (message.dayOfWeek !== 0) {
      writer.uint32(32).int32(message.dayOfWeek);
    }
    if (message.timeZone !== "") {
      writer.uint32(42).string(message.timeZone);
    }
    if (message.frequency !== 0) {
      writer.uint32(48).int32(message.frequency);
    }
    if (message.fetchUri !== "") {
      writer.uint32(58).string(message.fetchUri);
    }
    if (message.username !== "") {
      writer.uint32(66).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(74).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileInput_FetchSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileInput_FetchSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dayOfMonth = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timeOfDay = TimeOfDay.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.dayOfWeek = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.timeZone = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.frequency = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.fetchUri = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.username = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileInput_FetchSettings {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      dayOfMonth: isSet(object.dayOfMonth) ? globalThis.Number(object.dayOfMonth) : 0,
      timeOfDay: isSet(object.timeOfDay) ? TimeOfDay.fromJSON(object.timeOfDay) : undefined,
      dayOfWeek: isSet(object.dayOfWeek) ? dayOfWeekFromJSON(object.dayOfWeek) : 0,
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
      frequency: isSet(object.frequency) ? fileInput_FetchSettings_FrequencyFromJSON(object.frequency) : 0,
      fetchUri: isSet(object.fetchUri) ? globalThis.String(object.fetchUri) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: FileInput_FetchSettings): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.dayOfMonth !== 0) {
      obj.dayOfMonth = Math.round(message.dayOfMonth);
    }
    if (message.timeOfDay !== undefined) {
      obj.timeOfDay = TimeOfDay.toJSON(message.timeOfDay);
    }
    if (message.dayOfWeek !== 0) {
      obj.dayOfWeek = dayOfWeekToJSON(message.dayOfWeek);
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    if (message.frequency !== 0) {
      obj.frequency = fileInput_FetchSettings_FrequencyToJSON(message.frequency);
    }
    if (message.fetchUri !== "") {
      obj.fetchUri = message.fetchUri;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create(base?: DeepPartial<FileInput_FetchSettings>): FileInput_FetchSettings {
    return FileInput_FetchSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileInput_FetchSettings>): FileInput_FetchSettings {
    const message = createBaseFileInput_FetchSettings();
    message.enabled = object.enabled ?? false;
    message.dayOfMonth = object.dayOfMonth ?? 0;
    message.timeOfDay = (object.timeOfDay !== undefined && object.timeOfDay !== null)
      ? TimeOfDay.fromPartial(object.timeOfDay)
      : undefined;
    message.dayOfWeek = object.dayOfWeek ?? 0;
    message.timeZone = object.timeZone ?? "";
    message.frequency = object.frequency ?? 0;
    message.fetchUri = object.fetchUri ?? "";
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
