// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/monitoring/v3/uptime.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { MonitoredResource } from "../../api/monitored_resource.js";
import { Duration } from "../../protobuf/duration.js";

export const protobufPackage = "google.monitoring.v3";

/** The regions from which an Uptime check can be run. */
export enum UptimeCheckRegion {
  /**
   * REGION_UNSPECIFIED - Default value if no region is specified. Will result in Uptime checks
   * running from all regions.
   */
  REGION_UNSPECIFIED = 0,
  /** USA - Allows checks to run from locations within the United States of America. */
  USA = 1,
  /** EUROPE - Allows checks to run from locations within the continent of Europe. */
  EUROPE = 2,
  /**
   * SOUTH_AMERICA - Allows checks to run from locations within the continent of South
   * America.
   */
  SOUTH_AMERICA = 3,
  /**
   * ASIA_PACIFIC - Allows checks to run from locations within the Asia Pacific area (ex:
   * Singapore).
   */
  ASIA_PACIFIC = 4,
  /**
   * USA_OREGON - Allows checks to run from locations within the western United States of
   * America
   */
  USA_OREGON = 5,
  /**
   * USA_IOWA - Allows checks to run from locations within the central United States of
   * America
   */
  USA_IOWA = 6,
  /**
   * USA_VIRGINIA - Allows checks to run from locations within the eastern United States of
   * America
   */
  USA_VIRGINIA = 7,
  UNRECOGNIZED = -1,
}

export function uptimeCheckRegionFromJSON(object: any): UptimeCheckRegion {
  switch (object) {
    case 0:
    case "REGION_UNSPECIFIED":
      return UptimeCheckRegion.REGION_UNSPECIFIED;
    case 1:
    case "USA":
      return UptimeCheckRegion.USA;
    case 2:
    case "EUROPE":
      return UptimeCheckRegion.EUROPE;
    case 3:
    case "SOUTH_AMERICA":
      return UptimeCheckRegion.SOUTH_AMERICA;
    case 4:
    case "ASIA_PACIFIC":
      return UptimeCheckRegion.ASIA_PACIFIC;
    case 5:
    case "USA_OREGON":
      return UptimeCheckRegion.USA_OREGON;
    case 6:
    case "USA_IOWA":
      return UptimeCheckRegion.USA_IOWA;
    case 7:
    case "USA_VIRGINIA":
      return UptimeCheckRegion.USA_VIRGINIA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UptimeCheckRegion.UNRECOGNIZED;
  }
}

export function uptimeCheckRegionToJSON(object: UptimeCheckRegion): string {
  switch (object) {
    case UptimeCheckRegion.REGION_UNSPECIFIED:
      return "REGION_UNSPECIFIED";
    case UptimeCheckRegion.USA:
      return "USA";
    case UptimeCheckRegion.EUROPE:
      return "EUROPE";
    case UptimeCheckRegion.SOUTH_AMERICA:
      return "SOUTH_AMERICA";
    case UptimeCheckRegion.ASIA_PACIFIC:
      return "ASIA_PACIFIC";
    case UptimeCheckRegion.USA_OREGON:
      return "USA_OREGON";
    case UptimeCheckRegion.USA_IOWA:
      return "USA_IOWA";
    case UptimeCheckRegion.USA_VIRGINIA:
      return "USA_VIRGINIA";
    case UptimeCheckRegion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The supported resource types that can be used as values of
 * `group_resource.resource_type`.
 * `INSTANCE` includes `gce_instance` and `aws_ec2_instance` resource types.
 * The resource types `gae_app` and `uptime_url` are not valid here because
 * group checks on App Engine modules and URLs are not allowed.
 */
export enum GroupResourceType {
  /** RESOURCE_TYPE_UNSPECIFIED - Default value (not valid). */
  RESOURCE_TYPE_UNSPECIFIED = 0,
  /**
   * INSTANCE - A group of instances from Google Cloud Platform (GCP) or
   * Amazon Web Services (AWS).
   */
  INSTANCE = 1,
  /** AWS_ELB_LOAD_BALANCER - A group of Amazon ELB load balancers. */
  AWS_ELB_LOAD_BALANCER = 2,
  UNRECOGNIZED = -1,
}

export function groupResourceTypeFromJSON(object: any): GroupResourceType {
  switch (object) {
    case 0:
    case "RESOURCE_TYPE_UNSPECIFIED":
      return GroupResourceType.RESOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "INSTANCE":
      return GroupResourceType.INSTANCE;
    case 2:
    case "AWS_ELB_LOAD_BALANCER":
      return GroupResourceType.AWS_ELB_LOAD_BALANCER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GroupResourceType.UNRECOGNIZED;
  }
}

export function groupResourceTypeToJSON(object: GroupResourceType): string {
  switch (object) {
    case GroupResourceType.RESOURCE_TYPE_UNSPECIFIED:
      return "RESOURCE_TYPE_UNSPECIFIED";
    case GroupResourceType.INSTANCE:
      return "INSTANCE";
    case GroupResourceType.AWS_ELB_LOAD_BALANCER:
      return "AWS_ELB_LOAD_BALANCER";
    case GroupResourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An internal checker allows Uptime checks to run on private/internal GCP
 * resources.
 *
 * @deprecated
 */
export interface InternalChecker {
  /**
   * A unique resource name for this InternalChecker. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID]
   *
   * `[PROJECT_ID_OR_NUMBER]` is the Cloud Monitoring Metrics Scope project for
   * the Uptime check config associated with the internal checker.
   */
  name: string;
  /**
   * The checker's human-readable name. The display name
   * should be unique within a Cloud Monitoring Metrics Scope in order to make
   * it easier to identify; however, uniqueness is not enforced.
   */
  displayName: string;
  /**
   * The [GCP VPC network](https://cloud.google.com/vpc/docs/vpc) where the
   * internal resource lives (ex: "default").
   */
  network: string;
  /**
   * The GCP zone the Uptime check should egress from. Only respected for
   * internal Uptime checks, where internal_network is specified.
   */
  gcpZone: string;
  /**
   * The GCP project ID where the internal checker lives. Not necessary
   * the same as the Metrics Scope project.
   */
  peerProjectId: string;
  /** The current operational state of the internal checker. */
  state: InternalChecker_State;
}

/** Operational states for an internal checker. */
export enum InternalChecker_State {
  /** UNSPECIFIED - An internal checker should never be in the unspecified state. */
  UNSPECIFIED = 0,
  /**
   * CREATING - The checker is being created, provisioned, and configured. A checker in
   * this state can be returned by `ListInternalCheckers` or
   * `GetInternalChecker`, as well as by examining the [long running
   * Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
   * that created it.
   */
  CREATING = 1,
  /**
   * RUNNING - The checker is running and available for use. A checker in this state
   * can be returned by `ListInternalCheckers` or `GetInternalChecker` as
   * well as by examining the [long running
   * Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
   * that created it.
   * If a checker is being torn down, it is neither visible nor usable, so
   * there is no "deleting" or "down" state.
   */
  RUNNING = 2,
  UNRECOGNIZED = -1,
}

export function internalChecker_StateFromJSON(object: any): InternalChecker_State {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return InternalChecker_State.UNSPECIFIED;
    case 1:
    case "CREATING":
      return InternalChecker_State.CREATING;
    case 2:
    case "RUNNING":
      return InternalChecker_State.RUNNING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InternalChecker_State.UNRECOGNIZED;
  }
}

export function internalChecker_StateToJSON(object: InternalChecker_State): string {
  switch (object) {
    case InternalChecker_State.UNSPECIFIED:
      return "UNSPECIFIED";
    case InternalChecker_State.CREATING:
      return "CREATING";
    case InternalChecker_State.RUNNING:
      return "RUNNING";
    case InternalChecker_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Describes a Synthetic Monitor to be invoked by Uptime. */
export interface SyntheticMonitorTarget {
  /** Target a Synthetic Monitor GCFv2 instance. */
  cloudFunctionV2?: SyntheticMonitorTarget_CloudFunctionV2Target | undefined;
}

/** A Synthetic Monitor deployed to a Cloud Functions V2 instance. */
export interface SyntheticMonitorTarget_CloudFunctionV2Target {
  /**
   * Required. Fully qualified GCFv2 resource name
   * i.e. `projects/{project}/locations/{location}/functions/{function}`
   * Required.
   */
  name: string;
  /**
   * Output only. The `cloud_run_revision` Monitored Resource associated with
   * the GCFv2. The Synthetic Monitor execution results (metrics, logs, and
   * spans) are reported against this Monitored Resource. This field is output
   * only.
   */
  cloudRunRevision: MonitoredResource | undefined;
}

/**
 * This message configures which resources and services to monitor for
 * availability.
 */
export interface UptimeCheckConfig {
  /**
   * Identifier. A unique resource name for this Uptime check configuration. The
   * format is:
   *
   *      projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
   *
   * `[PROJECT_ID_OR_NUMBER]` is the Workspace host project associated with the
   * Uptime check.
   *
   * This field should be omitted when creating the Uptime check configuration;
   * on create, the resource name is assigned by the server and included in the
   * response.
   */
  name: string;
  /**
   * A human-friendly name for the Uptime check configuration. The display name
   * should be unique within a Cloud Monitoring Workspace in order to make it
   * easier to identify; however, uniqueness is not enforced. Required.
   */
  displayName: string;
  /**
   * The [monitored
   * resource](https://cloud.google.com/monitoring/api/resources) associated
   * with the configuration.
   * The following monitored resource types are valid for this field:
   *   `uptime_url`,
   *   `gce_instance`,
   *   `gae_app`,
   *   `aws_ec2_instance`,
   *   `aws_elb_load_balancer`
   *   `k8s_service`
   *   `servicedirectory_service`
   *   `cloud_run_revision`
   */
  monitoredResource?:
    | MonitoredResource
    | undefined;
  /** The group resource associated with the configuration. */
  resourceGroup?:
    | UptimeCheckConfig_ResourceGroup
    | undefined;
  /** Specifies a Synthetic Monitor to invoke. */
  syntheticMonitor?:
    | SyntheticMonitorTarget
    | undefined;
  /** Contains information needed to make an HTTP or HTTPS check. */
  httpCheck?:
    | UptimeCheckConfig_HttpCheck
    | undefined;
  /** Contains information needed to make a TCP check. */
  tcpCheck?:
    | UptimeCheckConfig_TcpCheck
    | undefined;
  /**
   * How often, in seconds, the Uptime check is performed.
   * Currently, the only supported values are `60s` (1 minute), `300s`
   * (5 minutes), `600s` (10 minutes), and `900s` (15 minutes). Optional,
   * defaults to `60s`.
   */
  period:
    | Duration
    | undefined;
  /**
   * The maximum amount of time to wait for the request to complete (must be
   * between 1 and 60 seconds). Required.
   */
  timeout:
    | Duration
    | undefined;
  /**
   * The content that is expected to appear in the data returned by the target
   * server against which the check is run.  Currently, only the first entry
   * in the `content_matchers` list is supported, and additional entries will
   * be ignored. This field is optional and should only be specified if a
   * content match is required as part of the/ Uptime check.
   */
  contentMatchers: UptimeCheckConfig_ContentMatcher[];
  /** The type of checkers to use to execute the Uptime check. */
  checkerType: UptimeCheckConfig_CheckerType;
  /**
   * The list of regions from which the check will be run.
   * Some regions contain one location, and others contain more than one.
   * If this field is specified, enough regions must be provided to include a
   * minimum of 3 locations.  Not specifying this field will result in Uptime
   * checks running from all available regions.
   */
  selectedRegions: UptimeCheckRegion[];
  /**
   * If this is `true`, then checks are made only from the 'internal_checkers'.
   * If it is `false`, then checks are made only from the 'selected_regions'.
   * It is an error to provide 'selected_regions' when is_internal is `true`,
   * or to provide 'internal_checkers' when is_internal is `false`.
   *
   * @deprecated
   */
  isInternal: boolean;
  /**
   * The internal checkers that this check will egress from. If `is_internal` is
   * `true` and this list is empty, the check will egress from all the
   * InternalCheckers configured for the project that owns this
   * `UptimeCheckConfig`.
   *
   * @deprecated
   */
  internalCheckers: InternalChecker[];
  /**
   * User-supplied key/value data to be used for organizing and
   * identifying the `UptimeCheckConfig` objects.
   *
   * The field can contain up to 64 entries. Each key and value is limited to
   * 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
   * values can contain only lowercase letters, numerals, underscores, and
   * dashes. Keys must begin with a letter.
   */
  userLabels: { [key: string]: string };
}

/** What kind of checkers are available to be used by the check. */
export enum UptimeCheckConfig_CheckerType {
  /**
   * CHECKER_TYPE_UNSPECIFIED - The default checker type. Currently converted to `STATIC_IP_CHECKERS`
   * on creation, the default conversion behavior may change in the future.
   */
  CHECKER_TYPE_UNSPECIFIED = 0,
  /**
   * STATIC_IP_CHECKERS - `STATIC_IP_CHECKERS` are used for uptime checks that perform egress
   * across the public internet. `STATIC_IP_CHECKERS` use the static IP
   * addresses returned by `ListUptimeCheckIps`.
   */
  STATIC_IP_CHECKERS = 1,
  /**
   * VPC_CHECKERS - `VPC_CHECKERS` are used for uptime checks that perform egress using
   * Service Directory and private network access. When using `VPC_CHECKERS`,
   * the monitored resource type must be `servicedirectory_service`.
   */
  VPC_CHECKERS = 3,
  UNRECOGNIZED = -1,
}

export function uptimeCheckConfig_CheckerTypeFromJSON(object: any): UptimeCheckConfig_CheckerType {
  switch (object) {
    case 0:
    case "CHECKER_TYPE_UNSPECIFIED":
      return UptimeCheckConfig_CheckerType.CHECKER_TYPE_UNSPECIFIED;
    case 1:
    case "STATIC_IP_CHECKERS":
      return UptimeCheckConfig_CheckerType.STATIC_IP_CHECKERS;
    case 3:
    case "VPC_CHECKERS":
      return UptimeCheckConfig_CheckerType.VPC_CHECKERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UptimeCheckConfig_CheckerType.UNRECOGNIZED;
  }
}

export function uptimeCheckConfig_CheckerTypeToJSON(object: UptimeCheckConfig_CheckerType): string {
  switch (object) {
    case UptimeCheckConfig_CheckerType.CHECKER_TYPE_UNSPECIFIED:
      return "CHECKER_TYPE_UNSPECIFIED";
    case UptimeCheckConfig_CheckerType.STATIC_IP_CHECKERS:
      return "STATIC_IP_CHECKERS";
    case UptimeCheckConfig_CheckerType.VPC_CHECKERS:
      return "VPC_CHECKERS";
    case UptimeCheckConfig_CheckerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The resource submessage for group checks. It can be used instead of a
 * monitored resource, when multiple resources are being monitored.
 */
export interface UptimeCheckConfig_ResourceGroup {
  /**
   * The group of resources being monitored. Should be only the `[GROUP_ID]`,
   * and not the full-path
   * `projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]`.
   */
  groupId: string;
  /** The resource type of the group members. */
  resourceType: GroupResourceType;
}

/**
 * Information involved in sending ICMP pings alongside public HTTP/TCP
 * checks. For HTTP, the pings are performed for each part of the redirect
 * chain.
 */
export interface UptimeCheckConfig_PingConfig {
  /** Number of ICMP pings. A maximum of 3 ICMP pings is currently supported. */
  pingsCount: number;
}

/** Information involved in an HTTP/HTTPS Uptime check request. */
export interface UptimeCheckConfig_HttpCheck {
  /**
   * The HTTP request method to use for the check. If set to
   * `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
   */
  requestMethod: UptimeCheckConfig_HttpCheck_RequestMethod;
  /** If `true`, use HTTPS instead of HTTP to run the check. */
  useSsl: boolean;
  /**
   * Optional (defaults to "/"). The path to the page against which to run
   * the check. Will be combined with the `host` (specified within the
   * `monitored_resource`) and `port` to construct the full URL. If the
   * provided path does not begin with "/", a "/" will be prepended
   * automatically.
   */
  path: string;
  /**
   * Optional (defaults to 80 when `use_ssl` is `false`, and 443 when
   * `use_ssl` is `true`). The TCP port on the HTTP server against which to
   * run the check. Will be combined with host (specified within the
   * `monitored_resource`) and `path` to construct the full URL.
   */
  port: number;
  /**
   * The authentication information. Optional when creating an HTTP check;
   * defaults to empty.
   * Do not set both `auth_method` and `auth_info`.
   */
  authInfo:
    | UptimeCheckConfig_HttpCheck_BasicAuthentication
    | undefined;
  /**
   * Boolean specifying whether to encrypt the header information.
   * Encryption should be specified for any headers related to authentication
   * that you do not wish to be seen when retrieving the configuration. The
   * server will be responsible for encrypting the headers.
   * On Get/List calls, if `mask_headers` is set to `true` then the headers
   * will be obscured with `******.`
   */
  maskHeaders: boolean;
  /**
   * The list of headers to send as part of the Uptime check request.
   * If two headers have the same key and different values, they should
   * be entered as a single header, with the value being a comma-separated
   * list of all the desired values as described at
   * https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31).
   * Entering two separate headers with the same key in a Create call will
   * cause the first to be overwritten by the second.
   * The maximum number of headers allowed is 100.
   */
  headers: { [key: string]: string };
  /**
   * The content type header to use for the check. The following
   * configurations result in errors:
   * 1. Content type is specified in both the `headers` field and the
   * `content_type` field.
   * 2. Request method is `GET` and `content_type` is not `TYPE_UNSPECIFIED`
   * 3. Request method is `POST` and `content_type` is `TYPE_UNSPECIFIED`.
   * 4. Request method is `POST` and a "Content-Type" header is provided via
   * `headers` field. The `content_type` field should be used instead.
   */
  contentType: UptimeCheckConfig_HttpCheck_ContentType;
  /**
   * A user provided content type header to use for the check. The invalid
   * configurations outlined in the `content_type` field apply to
   * `custom_content_type`, as well as the following:
   * 1. `content_type` is `URL_ENCODED` and `custom_content_type` is set.
   * 2. `content_type` is `USER_PROVIDED` and `custom_content_type` is not
   * set.
   */
  customContentType: string;
  /**
   * Boolean specifying whether to include SSL certificate validation as a
   * part of the Uptime check. Only applies to checks where
   * `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`,
   * setting `validate_ssl` to `true` has no effect.
   */
  validateSsl: boolean;
  /**
   * The request body associated with the HTTP POST request. If `content_type`
   * is `URL_ENCODED`, the body passed in must be URL-encoded. Users can
   * provide a `Content-Length` header via the `headers` field or the API will
   * do so. If the `request_method` is `GET` and `body` is not empty, the API
   * will return an error. The maximum byte size is 1 megabyte.
   *
   * Note: If client libraries aren't used (which performs the conversion
   * automatically) base64 encode your `body` data since the field is of
   * `bytes` type.
   */
  body: Buffer;
  /**
   * If present, the check will only pass if the HTTP response status code is
   * in this set of status codes. If empty, the HTTP status code will only
   * pass if the HTTP status code is 200-299.
   */
  acceptedResponseStatusCodes: UptimeCheckConfig_HttpCheck_ResponseStatusCode[];
  /** Contains information needed to add pings to an HTTP check. */
  pingConfig:
    | UptimeCheckConfig_PingConfig
    | undefined;
  /**
   * If specified, Uptime will generate and attach an OIDC JWT token for the
   * Monitoring service agent service account as an `Authorization` header
   * in the HTTP request when probing.
   */
  serviceAgentAuthentication?: UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication | undefined;
}

/** The HTTP request method options. */
export enum UptimeCheckConfig_HttpCheck_RequestMethod {
  /** METHOD_UNSPECIFIED - No request method specified. */
  METHOD_UNSPECIFIED = 0,
  /** GET - GET request. */
  GET = 1,
  /** POST - POST request. */
  POST = 2,
  UNRECOGNIZED = -1,
}

export function uptimeCheckConfig_HttpCheck_RequestMethodFromJSON(
  object: any,
): UptimeCheckConfig_HttpCheck_RequestMethod {
  switch (object) {
    case 0:
    case "METHOD_UNSPECIFIED":
      return UptimeCheckConfig_HttpCheck_RequestMethod.METHOD_UNSPECIFIED;
    case 1:
    case "GET":
      return UptimeCheckConfig_HttpCheck_RequestMethod.GET;
    case 2:
    case "POST":
      return UptimeCheckConfig_HttpCheck_RequestMethod.POST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UptimeCheckConfig_HttpCheck_RequestMethod.UNRECOGNIZED;
  }
}

export function uptimeCheckConfig_HttpCheck_RequestMethodToJSON(
  object: UptimeCheckConfig_HttpCheck_RequestMethod,
): string {
  switch (object) {
    case UptimeCheckConfig_HttpCheck_RequestMethod.METHOD_UNSPECIFIED:
      return "METHOD_UNSPECIFIED";
    case UptimeCheckConfig_HttpCheck_RequestMethod.GET:
      return "GET";
    case UptimeCheckConfig_HttpCheck_RequestMethod.POST:
      return "POST";
    case UptimeCheckConfig_HttpCheck_RequestMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Header options corresponding to the content type of a HTTP request body. */
export enum UptimeCheckConfig_HttpCheck_ContentType {
  /** TYPE_UNSPECIFIED - No content type specified. */
  TYPE_UNSPECIFIED = 0,
  /**
   * URL_ENCODED - `body` is in URL-encoded form. Equivalent to setting the `Content-Type`
   * to `application/x-www-form-urlencoded` in the HTTP request.
   */
  URL_ENCODED = 1,
  /**
   * USER_PROVIDED - `body` is in `custom_content_type` form. Equivalent to setting the
   * `Content-Type` to the contents of `custom_content_type` in the HTTP
   * request.
   */
  USER_PROVIDED = 2,
  UNRECOGNIZED = -1,
}

export function uptimeCheckConfig_HttpCheck_ContentTypeFromJSON(object: any): UptimeCheckConfig_HttpCheck_ContentType {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return UptimeCheckConfig_HttpCheck_ContentType.TYPE_UNSPECIFIED;
    case 1:
    case "URL_ENCODED":
      return UptimeCheckConfig_HttpCheck_ContentType.URL_ENCODED;
    case 2:
    case "USER_PROVIDED":
      return UptimeCheckConfig_HttpCheck_ContentType.USER_PROVIDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UptimeCheckConfig_HttpCheck_ContentType.UNRECOGNIZED;
  }
}

export function uptimeCheckConfig_HttpCheck_ContentTypeToJSON(object: UptimeCheckConfig_HttpCheck_ContentType): string {
  switch (object) {
    case UptimeCheckConfig_HttpCheck_ContentType.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case UptimeCheckConfig_HttpCheck_ContentType.URL_ENCODED:
      return "URL_ENCODED";
    case UptimeCheckConfig_HttpCheck_ContentType.USER_PROVIDED:
      return "USER_PROVIDED";
    case UptimeCheckConfig_HttpCheck_ContentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The authentication parameters to provide to the specified resource or
 * URL that requires a username and password. Currently, only
 * [Basic HTTP authentication](https://tools.ietf.org/html/rfc7617) is
 * supported in Uptime checks.
 */
export interface UptimeCheckConfig_HttpCheck_BasicAuthentication {
  /** The username to use when authenticating with the HTTP server. */
  username: string;
  /** The password to use when authenticating with the HTTP server. */
  password: string;
}

/**
 * A status to accept. Either a status code class like "2xx", or an integer
 * status code like "200".
 */
export interface UptimeCheckConfig_HttpCheck_ResponseStatusCode {
  /** A status code to accept. */
  statusValue?:
    | number
    | undefined;
  /** A class of status codes to accept. */
  statusClass?: UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass | undefined;
}

/** An HTTP status code class. */
export enum UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass {
  /** STATUS_CLASS_UNSPECIFIED - Default value that matches no status codes. */
  STATUS_CLASS_UNSPECIFIED = 0,
  /** STATUS_CLASS_1XX - The class of status codes between 100 and 199. */
  STATUS_CLASS_1XX = 100,
  /** STATUS_CLASS_2XX - The class of status codes between 200 and 299. */
  STATUS_CLASS_2XX = 200,
  /** STATUS_CLASS_3XX - The class of status codes between 300 and 399. */
  STATUS_CLASS_3XX = 300,
  /** STATUS_CLASS_4XX - The class of status codes between 400 and 499. */
  STATUS_CLASS_4XX = 400,
  /** STATUS_CLASS_5XX - The class of status codes between 500 and 599. */
  STATUS_CLASS_5XX = 500,
  /** STATUS_CLASS_ANY - The class of all status codes. */
  STATUS_CLASS_ANY = 1000,
  UNRECOGNIZED = -1,
}

export function uptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClassFromJSON(
  object: any,
): UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass {
  switch (object) {
    case 0:
    case "STATUS_CLASS_UNSPECIFIED":
      return UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_UNSPECIFIED;
    case 100:
    case "STATUS_CLASS_1XX":
      return UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_1XX;
    case 200:
    case "STATUS_CLASS_2XX":
      return UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_2XX;
    case 300:
    case "STATUS_CLASS_3XX":
      return UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_3XX;
    case 400:
    case "STATUS_CLASS_4XX":
      return UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_4XX;
    case 500:
    case "STATUS_CLASS_5XX":
      return UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_5XX;
    case 1000:
    case "STATUS_CLASS_ANY":
      return UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_ANY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.UNRECOGNIZED;
  }
}

export function uptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClassToJSON(
  object: UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass,
): string {
  switch (object) {
    case UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_UNSPECIFIED:
      return "STATUS_CLASS_UNSPECIFIED";
    case UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_1XX:
      return "STATUS_CLASS_1XX";
    case UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_2XX:
      return "STATUS_CLASS_2XX";
    case UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_3XX:
      return "STATUS_CLASS_3XX";
    case UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_4XX:
      return "STATUS_CLASS_4XX";
    case UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_5XX:
      return "STATUS_CLASS_5XX";
    case UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.STATUS_CLASS_ANY:
      return "STATUS_CLASS_ANY";
    case UptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClass.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Contains information needed for generating an
 * [OpenID Connect
 * token](https://developers.google.com/identity/protocols/OpenIDConnect).
 * The OIDC token will be generated for the Monitoring service agent service
 * account.
 */
export interface UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication {
  /** Type of authentication. */
  type: UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationType;
}

/** Type of authentication. */
export enum UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationType {
  /** SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED - Default value, will result in OIDC Authentication. */
  SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED = 0,
  /** OIDC_TOKEN - OIDC Authentication */
  OIDC_TOKEN = 1,
  UNRECOGNIZED = -1,
}

export function uptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationTypeFromJSON(
  object: any,
): UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationType {
  switch (object) {
    case 0:
    case "SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED":
      return UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationType
        .SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED;
    case 1:
    case "OIDC_TOKEN":
      return UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationType.OIDC_TOKEN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationType.UNRECOGNIZED;
  }
}

export function uptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationTypeToJSON(
  object: UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationType,
): string {
  switch (object) {
    case UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationType
      .SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED:
      return "SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED";
    case UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationType.OIDC_TOKEN:
      return "OIDC_TOKEN";
    case UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface UptimeCheckConfig_HttpCheck_HeadersEntry {
  key: string;
  value: string;
}

/** Information required for a TCP Uptime check request. */
export interface UptimeCheckConfig_TcpCheck {
  /**
   * The TCP port on the server against which to run the check. Will be
   * combined with host (specified within the `monitored_resource`) to
   * construct the full URL. Required.
   */
  port: number;
  /** Contains information needed to add pings to a TCP check. */
  pingConfig: UptimeCheckConfig_PingConfig | undefined;
}

/**
 * Optional. Used to perform content matching. This allows matching based on
 * substrings and regular expressions, together with their negations. Only the
 * first 4&nbsp;MB of an HTTP or HTTPS check's response (and the first
 * 1&nbsp;MB of a TCP check's response) are examined for purposes of content
 * matching.
 */
export interface UptimeCheckConfig_ContentMatcher {
  /**
   * String, regex or JSON content to match. Maximum 1024 bytes. An empty
   * `content` string indicates no content matching is to be performed.
   */
  content: string;
  /**
   * The type of content matcher that will be applied to the server output,
   * compared to the `content` string when the check is run.
   */
  matcher: UptimeCheckConfig_ContentMatcher_ContentMatcherOption;
  /** Matcher information for `MATCHES_JSON_PATH` and `NOT_MATCHES_JSON_PATH` */
  jsonPathMatcher?: UptimeCheckConfig_ContentMatcher_JsonPathMatcher | undefined;
}

/** Options to perform content matching. */
export enum UptimeCheckConfig_ContentMatcher_ContentMatcherOption {
  /**
   * CONTENT_MATCHER_OPTION_UNSPECIFIED - No content matcher type specified (maintained for backward
   * compatibility, but deprecated for future use).
   * Treated as `CONTAINS_STRING`.
   */
  CONTENT_MATCHER_OPTION_UNSPECIFIED = 0,
  /**
   * CONTAINS_STRING - Selects substring matching. The match succeeds if the output contains
   * the `content` string.  This is the default value for checks without
   * a `matcher` option, or where the value of `matcher` is
   * `CONTENT_MATCHER_OPTION_UNSPECIFIED`.
   */
  CONTAINS_STRING = 1,
  /**
   * NOT_CONTAINS_STRING - Selects negation of substring matching. The match succeeds if the
   * output does _NOT_ contain the `content` string.
   */
  NOT_CONTAINS_STRING = 2,
  /**
   * MATCHES_REGEX - Selects regular-expression matching. The match succeeds if the output
   * matches the regular expression specified in the `content` string.
   * Regex matching is only supported for HTTP/HTTPS checks.
   */
  MATCHES_REGEX = 3,
  /**
   * NOT_MATCHES_REGEX - Selects negation of regular-expression matching. The match succeeds if
   * the output does _NOT_ match the regular expression specified in the
   * `content` string. Regex matching is only supported for HTTP/HTTPS
   * checks.
   */
  NOT_MATCHES_REGEX = 4,
  /**
   * MATCHES_JSON_PATH - Selects JSONPath matching. See `JsonPathMatcher` for details on when
   * the match succeeds. JSONPath matching is only supported for HTTP/HTTPS
   * checks.
   */
  MATCHES_JSON_PATH = 5,
  /**
   * NOT_MATCHES_JSON_PATH - Selects JSONPath matching. See `JsonPathMatcher` for details on when
   * the match succeeds. Succeeds when output does _NOT_ match as specified.
   * JSONPath is only supported for HTTP/HTTPS checks.
   */
  NOT_MATCHES_JSON_PATH = 6,
  UNRECOGNIZED = -1,
}

export function uptimeCheckConfig_ContentMatcher_ContentMatcherOptionFromJSON(
  object: any,
): UptimeCheckConfig_ContentMatcher_ContentMatcherOption {
  switch (object) {
    case 0:
    case "CONTENT_MATCHER_OPTION_UNSPECIFIED":
      return UptimeCheckConfig_ContentMatcher_ContentMatcherOption.CONTENT_MATCHER_OPTION_UNSPECIFIED;
    case 1:
    case "CONTAINS_STRING":
      return UptimeCheckConfig_ContentMatcher_ContentMatcherOption.CONTAINS_STRING;
    case 2:
    case "NOT_CONTAINS_STRING":
      return UptimeCheckConfig_ContentMatcher_ContentMatcherOption.NOT_CONTAINS_STRING;
    case 3:
    case "MATCHES_REGEX":
      return UptimeCheckConfig_ContentMatcher_ContentMatcherOption.MATCHES_REGEX;
    case 4:
    case "NOT_MATCHES_REGEX":
      return UptimeCheckConfig_ContentMatcher_ContentMatcherOption.NOT_MATCHES_REGEX;
    case 5:
    case "MATCHES_JSON_PATH":
      return UptimeCheckConfig_ContentMatcher_ContentMatcherOption.MATCHES_JSON_PATH;
    case 6:
    case "NOT_MATCHES_JSON_PATH":
      return UptimeCheckConfig_ContentMatcher_ContentMatcherOption.NOT_MATCHES_JSON_PATH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UptimeCheckConfig_ContentMatcher_ContentMatcherOption.UNRECOGNIZED;
  }
}

export function uptimeCheckConfig_ContentMatcher_ContentMatcherOptionToJSON(
  object: UptimeCheckConfig_ContentMatcher_ContentMatcherOption,
): string {
  switch (object) {
    case UptimeCheckConfig_ContentMatcher_ContentMatcherOption.CONTENT_MATCHER_OPTION_UNSPECIFIED:
      return "CONTENT_MATCHER_OPTION_UNSPECIFIED";
    case UptimeCheckConfig_ContentMatcher_ContentMatcherOption.CONTAINS_STRING:
      return "CONTAINS_STRING";
    case UptimeCheckConfig_ContentMatcher_ContentMatcherOption.NOT_CONTAINS_STRING:
      return "NOT_CONTAINS_STRING";
    case UptimeCheckConfig_ContentMatcher_ContentMatcherOption.MATCHES_REGEX:
      return "MATCHES_REGEX";
    case UptimeCheckConfig_ContentMatcher_ContentMatcherOption.NOT_MATCHES_REGEX:
      return "NOT_MATCHES_REGEX";
    case UptimeCheckConfig_ContentMatcher_ContentMatcherOption.MATCHES_JSON_PATH:
      return "MATCHES_JSON_PATH";
    case UptimeCheckConfig_ContentMatcher_ContentMatcherOption.NOT_MATCHES_JSON_PATH:
      return "NOT_MATCHES_JSON_PATH";
    case UptimeCheckConfig_ContentMatcher_ContentMatcherOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Information needed to perform a JSONPath content match.
 * Used for `ContentMatcherOption::MATCHES_JSON_PATH` and
 * `ContentMatcherOption::NOT_MATCHES_JSON_PATH`.
 */
export interface UptimeCheckConfig_ContentMatcher_JsonPathMatcher {
  /**
   * JSONPath within the response output pointing to the expected
   * `ContentMatcher::content` to match against.
   */
  jsonPath: string;
  /**
   * The type of JSONPath match that will be applied to the JSON output
   * (`ContentMatcher.content`)
   */
  jsonMatcher: UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption;
}

/** Options to perform JSONPath content matching. */
export enum UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption {
  /** JSON_PATH_MATCHER_OPTION_UNSPECIFIED - No JSONPath matcher type specified (not valid). */
  JSON_PATH_MATCHER_OPTION_UNSPECIFIED = 0,
  /**
   * EXACT_MATCH - Selects 'exact string' matching. The match succeeds if the content at
   * the `json_path` within the output is exactly the same as the
   * `content` string.
   */
  EXACT_MATCH = 1,
  /**
   * REGEX_MATCH - Selects regular-expression matching. The match succeeds if the
   * content at the `json_path` within the output matches the regular
   * expression specified in the `content` string.
   */
  REGEX_MATCH = 2,
  UNRECOGNIZED = -1,
}

export function uptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOptionFromJSON(
  object: any,
): UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption {
  switch (object) {
    case 0:
    case "JSON_PATH_MATCHER_OPTION_UNSPECIFIED":
      return UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption
        .JSON_PATH_MATCHER_OPTION_UNSPECIFIED;
    case 1:
    case "EXACT_MATCH":
      return UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption.EXACT_MATCH;
    case 2:
    case "REGEX_MATCH":
      return UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption.REGEX_MATCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption.UNRECOGNIZED;
  }
}

export function uptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOptionToJSON(
  object: UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption,
): string {
  switch (object) {
    case UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption.JSON_PATH_MATCHER_OPTION_UNSPECIFIED:
      return "JSON_PATH_MATCHER_OPTION_UNSPECIFIED";
    case UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption.EXACT_MATCH:
      return "EXACT_MATCH";
    case UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption.REGEX_MATCH:
      return "REGEX_MATCH";
    case UptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface UptimeCheckConfig_UserLabelsEntry {
  key: string;
  value: string;
}

/**
 * Contains the region, location, and list of IP
 * addresses where checkers in the location run from.
 */
export interface UptimeCheckIp {
  /** A broad region category in which the IP address is located. */
  region: UptimeCheckRegion;
  /**
   * A more specific location within the region that typically encodes
   * a particular city/town/metro (and its containing state/province or country)
   * within the broader umbrella region category.
   */
  location: string;
  /**
   * The IP address from which the Uptime check originates. This is a fully
   * specified IP address (not an IP address range). Most IP addresses, as of
   * this publication, are in IPv4 format; however, one should not rely on the
   * IP addresses being in IPv4 format indefinitely, and should support
   * interpreting this field in either IPv4 or IPv6 format.
   */
  ipAddress: string;
}

function createBaseInternalChecker(): InternalChecker {
  return { name: "", displayName: "", network: "", gcpZone: "", peerProjectId: "", state: 0 };
}

export const InternalChecker: MessageFns<InternalChecker> = {
  encode(message: InternalChecker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.network !== "") {
      writer.uint32(26).string(message.network);
    }
    if (message.gcpZone !== "") {
      writer.uint32(34).string(message.gcpZone);
    }
    if (message.peerProjectId !== "") {
      writer.uint32(50).string(message.peerProjectId);
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InternalChecker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalChecker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.network = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gcpZone = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.peerProjectId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InternalChecker {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      gcpZone: isSet(object.gcpZone) ? globalThis.String(object.gcpZone) : "",
      peerProjectId: isSet(object.peerProjectId) ? globalThis.String(object.peerProjectId) : "",
      state: isSet(object.state) ? internalChecker_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: InternalChecker): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.gcpZone !== "") {
      obj.gcpZone = message.gcpZone;
    }
    if (message.peerProjectId !== "") {
      obj.peerProjectId = message.peerProjectId;
    }
    if (message.state !== 0) {
      obj.state = internalChecker_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<InternalChecker>): InternalChecker {
    return InternalChecker.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InternalChecker>): InternalChecker {
    const message = createBaseInternalChecker();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.network = object.network ?? "";
    message.gcpZone = object.gcpZone ?? "";
    message.peerProjectId = object.peerProjectId ?? "";
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseSyntheticMonitorTarget(): SyntheticMonitorTarget {
  return { cloudFunctionV2: undefined };
}

export const SyntheticMonitorTarget: MessageFns<SyntheticMonitorTarget> = {
  encode(message: SyntheticMonitorTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudFunctionV2 !== undefined) {
      SyntheticMonitorTarget_CloudFunctionV2Target.encode(message.cloudFunctionV2, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyntheticMonitorTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyntheticMonitorTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cloudFunctionV2 = SyntheticMonitorTarget_CloudFunctionV2Target.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyntheticMonitorTarget {
    return {
      cloudFunctionV2: isSet(object.cloudFunctionV2)
        ? SyntheticMonitorTarget_CloudFunctionV2Target.fromJSON(object.cloudFunctionV2)
        : undefined,
    };
  },

  toJSON(message: SyntheticMonitorTarget): unknown {
    const obj: any = {};
    if (message.cloudFunctionV2 !== undefined) {
      obj.cloudFunctionV2 = SyntheticMonitorTarget_CloudFunctionV2Target.toJSON(message.cloudFunctionV2);
    }
    return obj;
  },

  create(base?: DeepPartial<SyntheticMonitorTarget>): SyntheticMonitorTarget {
    return SyntheticMonitorTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SyntheticMonitorTarget>): SyntheticMonitorTarget {
    const message = createBaseSyntheticMonitorTarget();
    message.cloudFunctionV2 = (object.cloudFunctionV2 !== undefined && object.cloudFunctionV2 !== null)
      ? SyntheticMonitorTarget_CloudFunctionV2Target.fromPartial(object.cloudFunctionV2)
      : undefined;
    return message;
  },
};

function createBaseSyntheticMonitorTarget_CloudFunctionV2Target(): SyntheticMonitorTarget_CloudFunctionV2Target {
  return { name: "", cloudRunRevision: undefined };
}

export const SyntheticMonitorTarget_CloudFunctionV2Target: MessageFns<SyntheticMonitorTarget_CloudFunctionV2Target> = {
  encode(
    message: SyntheticMonitorTarget_CloudFunctionV2Target,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.cloudRunRevision !== undefined) {
      MonitoredResource.encode(message.cloudRunRevision, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyntheticMonitorTarget_CloudFunctionV2Target {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyntheticMonitorTarget_CloudFunctionV2Target();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cloudRunRevision = MonitoredResource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyntheticMonitorTarget_CloudFunctionV2Target {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cloudRunRevision: isSet(object.cloudRunRevision)
        ? MonitoredResource.fromJSON(object.cloudRunRevision)
        : undefined,
    };
  },

  toJSON(message: SyntheticMonitorTarget_CloudFunctionV2Target): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.cloudRunRevision !== undefined) {
      obj.cloudRunRevision = MonitoredResource.toJSON(message.cloudRunRevision);
    }
    return obj;
  },

  create(
    base?: DeepPartial<SyntheticMonitorTarget_CloudFunctionV2Target>,
  ): SyntheticMonitorTarget_CloudFunctionV2Target {
    return SyntheticMonitorTarget_CloudFunctionV2Target.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SyntheticMonitorTarget_CloudFunctionV2Target>,
  ): SyntheticMonitorTarget_CloudFunctionV2Target {
    const message = createBaseSyntheticMonitorTarget_CloudFunctionV2Target();
    message.name = object.name ?? "";
    message.cloudRunRevision = (object.cloudRunRevision !== undefined && object.cloudRunRevision !== null)
      ? MonitoredResource.fromPartial(object.cloudRunRevision)
      : undefined;
    return message;
  },
};

function createBaseUptimeCheckConfig(): UptimeCheckConfig {
  return {
    name: "",
    displayName: "",
    monitoredResource: undefined,
    resourceGroup: undefined,
    syntheticMonitor: undefined,
    httpCheck: undefined,
    tcpCheck: undefined,
    period: undefined,
    timeout: undefined,
    contentMatchers: [],
    checkerType: 0,
    selectedRegions: [],
    isInternal: false,
    internalCheckers: [],
    userLabels: {},
  };
}

export const UptimeCheckConfig: MessageFns<UptimeCheckConfig> = {
  encode(message: UptimeCheckConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.monitoredResource !== undefined) {
      MonitoredResource.encode(message.monitoredResource, writer.uint32(26).fork()).join();
    }
    if (message.resourceGroup !== undefined) {
      UptimeCheckConfig_ResourceGroup.encode(message.resourceGroup, writer.uint32(34).fork()).join();
    }
    if (message.syntheticMonitor !== undefined) {
      SyntheticMonitorTarget.encode(message.syntheticMonitor, writer.uint32(170).fork()).join();
    }
    if (message.httpCheck !== undefined) {
      UptimeCheckConfig_HttpCheck.encode(message.httpCheck, writer.uint32(42).fork()).join();
    }
    if (message.tcpCheck !== undefined) {
      UptimeCheckConfig_TcpCheck.encode(message.tcpCheck, writer.uint32(50).fork()).join();
    }
    if (message.period !== undefined) {
      Duration.encode(message.period, writer.uint32(58).fork()).join();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(66).fork()).join();
    }
    for (const v of message.contentMatchers) {
      UptimeCheckConfig_ContentMatcher.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.checkerType !== 0) {
      writer.uint32(136).int32(message.checkerType);
    }
    writer.uint32(82).fork();
    for (const v of message.selectedRegions) {
      writer.int32(v);
    }
    writer.join();
    if (message.isInternal !== false) {
      writer.uint32(120).bool(message.isInternal);
    }
    for (const v of message.internalCheckers) {
      InternalChecker.encode(v!, writer.uint32(114).fork()).join();
    }
    Object.entries(message.userLabels).forEach(([key, value]) => {
      UptimeCheckConfig_UserLabelsEntry.encode({ key: key as any, value }, writer.uint32(162).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UptimeCheckConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeCheckConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.monitoredResource = MonitoredResource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resourceGroup = UptimeCheckConfig_ResourceGroup.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.syntheticMonitor = SyntheticMonitorTarget.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.httpCheck = UptimeCheckConfig_HttpCheck.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tcpCheck = UptimeCheckConfig_TcpCheck.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.period = Duration.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.contentMatchers.push(UptimeCheckConfig_ContentMatcher.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.checkerType = reader.int32() as any;
          continue;
        case 10:
          if (tag === 80) {
            message.selectedRegions.push(reader.int32() as any);

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.selectedRegions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.isInternal = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.internalCheckers.push(InternalChecker.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          const entry20 = UptimeCheckConfig_UserLabelsEntry.decode(reader, reader.uint32());
          if (entry20.value !== undefined) {
            message.userLabels[entry20.key] = entry20.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeCheckConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      monitoredResource: isSet(object.monitoredResource)
        ? MonitoredResource.fromJSON(object.monitoredResource)
        : undefined,
      resourceGroup: isSet(object.resourceGroup)
        ? UptimeCheckConfig_ResourceGroup.fromJSON(object.resourceGroup)
        : undefined,
      syntheticMonitor: isSet(object.syntheticMonitor)
        ? SyntheticMonitorTarget.fromJSON(object.syntheticMonitor)
        : undefined,
      httpCheck: isSet(object.httpCheck) ? UptimeCheckConfig_HttpCheck.fromJSON(object.httpCheck) : undefined,
      tcpCheck: isSet(object.tcpCheck) ? UptimeCheckConfig_TcpCheck.fromJSON(object.tcpCheck) : undefined,
      period: isSet(object.period) ? Duration.fromJSON(object.period) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      contentMatchers: globalThis.Array.isArray(object?.contentMatchers)
        ? object.contentMatchers.map((e: any) => UptimeCheckConfig_ContentMatcher.fromJSON(e))
        : [],
      checkerType: isSet(object.checkerType) ? uptimeCheckConfig_CheckerTypeFromJSON(object.checkerType) : 0,
      selectedRegions: globalThis.Array.isArray(object?.selectedRegions)
        ? object.selectedRegions.map((e: any) => uptimeCheckRegionFromJSON(e))
        : [],
      isInternal: isSet(object.isInternal) ? globalThis.Boolean(object.isInternal) : false,
      internalCheckers: globalThis.Array.isArray(object?.internalCheckers)
        ? object.internalCheckers.map((e: any) => InternalChecker.fromJSON(e))
        : [],
      userLabels: isObject(object.userLabels)
        ? Object.entries(object.userLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UptimeCheckConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.monitoredResource !== undefined) {
      obj.monitoredResource = MonitoredResource.toJSON(message.monitoredResource);
    }
    if (message.resourceGroup !== undefined) {
      obj.resourceGroup = UptimeCheckConfig_ResourceGroup.toJSON(message.resourceGroup);
    }
    if (message.syntheticMonitor !== undefined) {
      obj.syntheticMonitor = SyntheticMonitorTarget.toJSON(message.syntheticMonitor);
    }
    if (message.httpCheck !== undefined) {
      obj.httpCheck = UptimeCheckConfig_HttpCheck.toJSON(message.httpCheck);
    }
    if (message.tcpCheck !== undefined) {
      obj.tcpCheck = UptimeCheckConfig_TcpCheck.toJSON(message.tcpCheck);
    }
    if (message.period !== undefined) {
      obj.period = Duration.toJSON(message.period);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.contentMatchers?.length) {
      obj.contentMatchers = message.contentMatchers.map((e) => UptimeCheckConfig_ContentMatcher.toJSON(e));
    }
    if (message.checkerType !== 0) {
      obj.checkerType = uptimeCheckConfig_CheckerTypeToJSON(message.checkerType);
    }
    if (message.selectedRegions?.length) {
      obj.selectedRegions = message.selectedRegions.map((e) => uptimeCheckRegionToJSON(e));
    }
    if (message.isInternal !== false) {
      obj.isInternal = message.isInternal;
    }
    if (message.internalCheckers?.length) {
      obj.internalCheckers = message.internalCheckers.map((e) => InternalChecker.toJSON(e));
    }
    if (message.userLabels) {
      const entries = Object.entries(message.userLabels);
      if (entries.length > 0) {
        obj.userLabels = {};
        entries.forEach(([k, v]) => {
          obj.userLabels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<UptimeCheckConfig>): UptimeCheckConfig {
    return UptimeCheckConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UptimeCheckConfig>): UptimeCheckConfig {
    const message = createBaseUptimeCheckConfig();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.monitoredResource = (object.monitoredResource !== undefined && object.monitoredResource !== null)
      ? MonitoredResource.fromPartial(object.monitoredResource)
      : undefined;
    message.resourceGroup = (object.resourceGroup !== undefined && object.resourceGroup !== null)
      ? UptimeCheckConfig_ResourceGroup.fromPartial(object.resourceGroup)
      : undefined;
    message.syntheticMonitor = (object.syntheticMonitor !== undefined && object.syntheticMonitor !== null)
      ? SyntheticMonitorTarget.fromPartial(object.syntheticMonitor)
      : undefined;
    message.httpCheck = (object.httpCheck !== undefined && object.httpCheck !== null)
      ? UptimeCheckConfig_HttpCheck.fromPartial(object.httpCheck)
      : undefined;
    message.tcpCheck = (object.tcpCheck !== undefined && object.tcpCheck !== null)
      ? UptimeCheckConfig_TcpCheck.fromPartial(object.tcpCheck)
      : undefined;
    message.period = (object.period !== undefined && object.period !== null)
      ? Duration.fromPartial(object.period)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.contentMatchers = object.contentMatchers?.map((e) => UptimeCheckConfig_ContentMatcher.fromPartial(e)) || [];
    message.checkerType = object.checkerType ?? 0;
    message.selectedRegions = object.selectedRegions?.map((e) => e) || [];
    message.isInternal = object.isInternal ?? false;
    message.internalCheckers = object.internalCheckers?.map((e) => InternalChecker.fromPartial(e)) || [];
    message.userLabels = Object.entries(object.userLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseUptimeCheckConfig_ResourceGroup(): UptimeCheckConfig_ResourceGroup {
  return { groupId: "", resourceType: 0 };
}

export const UptimeCheckConfig_ResourceGroup: MessageFns<UptimeCheckConfig_ResourceGroup> = {
  encode(message: UptimeCheckConfig_ResourceGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== "") {
      writer.uint32(10).string(message.groupId);
    }
    if (message.resourceType !== 0) {
      writer.uint32(16).int32(message.resourceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UptimeCheckConfig_ResourceGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeCheckConfig_ResourceGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.groupId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.resourceType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeCheckConfig_ResourceGroup {
    return {
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      resourceType: isSet(object.resourceType) ? groupResourceTypeFromJSON(object.resourceType) : 0,
    };
  },

  toJSON(message: UptimeCheckConfig_ResourceGroup): unknown {
    const obj: any = {};
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.resourceType !== 0) {
      obj.resourceType = groupResourceTypeToJSON(message.resourceType);
    }
    return obj;
  },

  create(base?: DeepPartial<UptimeCheckConfig_ResourceGroup>): UptimeCheckConfig_ResourceGroup {
    return UptimeCheckConfig_ResourceGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UptimeCheckConfig_ResourceGroup>): UptimeCheckConfig_ResourceGroup {
    const message = createBaseUptimeCheckConfig_ResourceGroup();
    message.groupId = object.groupId ?? "";
    message.resourceType = object.resourceType ?? 0;
    return message;
  },
};

function createBaseUptimeCheckConfig_PingConfig(): UptimeCheckConfig_PingConfig {
  return { pingsCount: 0 };
}

export const UptimeCheckConfig_PingConfig: MessageFns<UptimeCheckConfig_PingConfig> = {
  encode(message: UptimeCheckConfig_PingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pingsCount !== 0) {
      writer.uint32(8).int32(message.pingsCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UptimeCheckConfig_PingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeCheckConfig_PingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pingsCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeCheckConfig_PingConfig {
    return { pingsCount: isSet(object.pingsCount) ? globalThis.Number(object.pingsCount) : 0 };
  },

  toJSON(message: UptimeCheckConfig_PingConfig): unknown {
    const obj: any = {};
    if (message.pingsCount !== 0) {
      obj.pingsCount = Math.round(message.pingsCount);
    }
    return obj;
  },

  create(base?: DeepPartial<UptimeCheckConfig_PingConfig>): UptimeCheckConfig_PingConfig {
    return UptimeCheckConfig_PingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UptimeCheckConfig_PingConfig>): UptimeCheckConfig_PingConfig {
    const message = createBaseUptimeCheckConfig_PingConfig();
    message.pingsCount = object.pingsCount ?? 0;
    return message;
  },
};

function createBaseUptimeCheckConfig_HttpCheck(): UptimeCheckConfig_HttpCheck {
  return {
    requestMethod: 0,
    useSsl: false,
    path: "",
    port: 0,
    authInfo: undefined,
    maskHeaders: false,
    headers: {},
    contentType: 0,
    customContentType: "",
    validateSsl: false,
    body: Buffer.alloc(0),
    acceptedResponseStatusCodes: [],
    pingConfig: undefined,
    serviceAgentAuthentication: undefined,
  };
}

export const UptimeCheckConfig_HttpCheck: MessageFns<UptimeCheckConfig_HttpCheck> = {
  encode(message: UptimeCheckConfig_HttpCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestMethod !== 0) {
      writer.uint32(64).int32(message.requestMethod);
    }
    if (message.useSsl !== false) {
      writer.uint32(8).bool(message.useSsl);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    if (message.authInfo !== undefined) {
      UptimeCheckConfig_HttpCheck_BasicAuthentication.encode(message.authInfo, writer.uint32(34).fork()).join();
    }
    if (message.maskHeaders !== false) {
      writer.uint32(40).bool(message.maskHeaders);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      UptimeCheckConfig_HttpCheck_HeadersEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.contentType !== 0) {
      writer.uint32(72).int32(message.contentType);
    }
    if (message.customContentType !== "") {
      writer.uint32(106).string(message.customContentType);
    }
    if (message.validateSsl !== false) {
      writer.uint32(56).bool(message.validateSsl);
    }
    if (message.body.length !== 0) {
      writer.uint32(82).bytes(message.body);
    }
    for (const v of message.acceptedResponseStatusCodes) {
      UptimeCheckConfig_HttpCheck_ResponseStatusCode.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.pingConfig !== undefined) {
      UptimeCheckConfig_PingConfig.encode(message.pingConfig, writer.uint32(98).fork()).join();
    }
    if (message.serviceAgentAuthentication !== undefined) {
      UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication.encode(
        message.serviceAgentAuthentication,
        writer.uint32(114).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UptimeCheckConfig_HttpCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeCheckConfig_HttpCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 64) {
            break;
          }

          message.requestMethod = reader.int32() as any;
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useSsl = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.authInfo = UptimeCheckConfig_HttpCheck_BasicAuthentication.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maskHeaders = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = UptimeCheckConfig_HttpCheck_HeadersEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.headers[entry6.key] = entry6.value;
          }
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.contentType = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.customContentType = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.validateSsl = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.body = Buffer.from(reader.bytes());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.acceptedResponseStatusCodes.push(
            UptimeCheckConfig_HttpCheck_ResponseStatusCode.decode(reader, reader.uint32()),
          );
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.pingConfig = UptimeCheckConfig_PingConfig.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.serviceAgentAuthentication = UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeCheckConfig_HttpCheck {
    return {
      requestMethod: isSet(object.requestMethod)
        ? uptimeCheckConfig_HttpCheck_RequestMethodFromJSON(object.requestMethod)
        : 0,
      useSsl: isSet(object.useSsl) ? globalThis.Boolean(object.useSsl) : false,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      authInfo: isSet(object.authInfo)
        ? UptimeCheckConfig_HttpCheck_BasicAuthentication.fromJSON(object.authInfo)
        : undefined,
      maskHeaders: isSet(object.maskHeaders) ? globalThis.Boolean(object.maskHeaders) : false,
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      contentType: isSet(object.contentType) ? uptimeCheckConfig_HttpCheck_ContentTypeFromJSON(object.contentType) : 0,
      customContentType: isSet(object.customContentType) ? globalThis.String(object.customContentType) : "",
      validateSsl: isSet(object.validateSsl) ? globalThis.Boolean(object.validateSsl) : false,
      body: isSet(object.body) ? Buffer.from(bytesFromBase64(object.body)) : Buffer.alloc(0),
      acceptedResponseStatusCodes: globalThis.Array.isArray(object?.acceptedResponseStatusCodes)
        ? object.acceptedResponseStatusCodes.map((e: any) => UptimeCheckConfig_HttpCheck_ResponseStatusCode.fromJSON(e))
        : [],
      pingConfig: isSet(object.pingConfig) ? UptimeCheckConfig_PingConfig.fromJSON(object.pingConfig) : undefined,
      serviceAgentAuthentication: isSet(object.serviceAgentAuthentication)
        ? UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication.fromJSON(object.serviceAgentAuthentication)
        : undefined,
    };
  },

  toJSON(message: UptimeCheckConfig_HttpCheck): unknown {
    const obj: any = {};
    if (message.requestMethod !== 0) {
      obj.requestMethod = uptimeCheckConfig_HttpCheck_RequestMethodToJSON(message.requestMethod);
    }
    if (message.useSsl !== false) {
      obj.useSsl = message.useSsl;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.authInfo !== undefined) {
      obj.authInfo = UptimeCheckConfig_HttpCheck_BasicAuthentication.toJSON(message.authInfo);
    }
    if (message.maskHeaders !== false) {
      obj.maskHeaders = message.maskHeaders;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.contentType !== 0) {
      obj.contentType = uptimeCheckConfig_HttpCheck_ContentTypeToJSON(message.contentType);
    }
    if (message.customContentType !== "") {
      obj.customContentType = message.customContentType;
    }
    if (message.validateSsl !== false) {
      obj.validateSsl = message.validateSsl;
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.acceptedResponseStatusCodes?.length) {
      obj.acceptedResponseStatusCodes = message.acceptedResponseStatusCodes.map((e) =>
        UptimeCheckConfig_HttpCheck_ResponseStatusCode.toJSON(e)
      );
    }
    if (message.pingConfig !== undefined) {
      obj.pingConfig = UptimeCheckConfig_PingConfig.toJSON(message.pingConfig);
    }
    if (message.serviceAgentAuthentication !== undefined) {
      obj.serviceAgentAuthentication = UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication.toJSON(
        message.serviceAgentAuthentication,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<UptimeCheckConfig_HttpCheck>): UptimeCheckConfig_HttpCheck {
    return UptimeCheckConfig_HttpCheck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UptimeCheckConfig_HttpCheck>): UptimeCheckConfig_HttpCheck {
    const message = createBaseUptimeCheckConfig_HttpCheck();
    message.requestMethod = object.requestMethod ?? 0;
    message.useSsl = object.useSsl ?? false;
    message.path = object.path ?? "";
    message.port = object.port ?? 0;
    message.authInfo = (object.authInfo !== undefined && object.authInfo !== null)
      ? UptimeCheckConfig_HttpCheck_BasicAuthentication.fromPartial(object.authInfo)
      : undefined;
    message.maskHeaders = object.maskHeaders ?? false;
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.contentType = object.contentType ?? 0;
    message.customContentType = object.customContentType ?? "";
    message.validateSsl = object.validateSsl ?? false;
    message.body = object.body ?? Buffer.alloc(0);
    message.acceptedResponseStatusCodes =
      object.acceptedResponseStatusCodes?.map((e) => UptimeCheckConfig_HttpCheck_ResponseStatusCode.fromPartial(e)) ||
      [];
    message.pingConfig = (object.pingConfig !== undefined && object.pingConfig !== null)
      ? UptimeCheckConfig_PingConfig.fromPartial(object.pingConfig)
      : undefined;
    message.serviceAgentAuthentication =
      (object.serviceAgentAuthentication !== undefined && object.serviceAgentAuthentication !== null)
        ? UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication.fromPartial(object.serviceAgentAuthentication)
        : undefined;
    return message;
  },
};

function createBaseUptimeCheckConfig_HttpCheck_BasicAuthentication(): UptimeCheckConfig_HttpCheck_BasicAuthentication {
  return { username: "", password: "" };
}

export const UptimeCheckConfig_HttpCheck_BasicAuthentication: MessageFns<
  UptimeCheckConfig_HttpCheck_BasicAuthentication
> = {
  encode(
    message: UptimeCheckConfig_HttpCheck_BasicAuthentication,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UptimeCheckConfig_HttpCheck_BasicAuthentication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeCheckConfig_HttpCheck_BasicAuthentication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeCheckConfig_HttpCheck_BasicAuthentication {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: UptimeCheckConfig_HttpCheck_BasicAuthentication): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create(
    base?: DeepPartial<UptimeCheckConfig_HttpCheck_BasicAuthentication>,
  ): UptimeCheckConfig_HttpCheck_BasicAuthentication {
    return UptimeCheckConfig_HttpCheck_BasicAuthentication.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<UptimeCheckConfig_HttpCheck_BasicAuthentication>,
  ): UptimeCheckConfig_HttpCheck_BasicAuthentication {
    const message = createBaseUptimeCheckConfig_HttpCheck_BasicAuthentication();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseUptimeCheckConfig_HttpCheck_ResponseStatusCode(): UptimeCheckConfig_HttpCheck_ResponseStatusCode {
  return { statusValue: undefined, statusClass: undefined };
}

export const UptimeCheckConfig_HttpCheck_ResponseStatusCode: MessageFns<
  UptimeCheckConfig_HttpCheck_ResponseStatusCode
> = {
  encode(
    message: UptimeCheckConfig_HttpCheck_ResponseStatusCode,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.statusValue !== undefined) {
      writer.uint32(8).int32(message.statusValue);
    }
    if (message.statusClass !== undefined) {
      writer.uint32(16).int32(message.statusClass);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UptimeCheckConfig_HttpCheck_ResponseStatusCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeCheckConfig_HttpCheck_ResponseStatusCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.statusValue = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.statusClass = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeCheckConfig_HttpCheck_ResponseStatusCode {
    return {
      statusValue: isSet(object.statusValue) ? globalThis.Number(object.statusValue) : undefined,
      statusClass: isSet(object.statusClass)
        ? uptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClassFromJSON(object.statusClass)
        : undefined,
    };
  },

  toJSON(message: UptimeCheckConfig_HttpCheck_ResponseStatusCode): unknown {
    const obj: any = {};
    if (message.statusValue !== undefined) {
      obj.statusValue = Math.round(message.statusValue);
    }
    if (message.statusClass !== undefined) {
      obj.statusClass = uptimeCheckConfig_HttpCheck_ResponseStatusCode_StatusClassToJSON(message.statusClass);
    }
    return obj;
  },

  create(
    base?: DeepPartial<UptimeCheckConfig_HttpCheck_ResponseStatusCode>,
  ): UptimeCheckConfig_HttpCheck_ResponseStatusCode {
    return UptimeCheckConfig_HttpCheck_ResponseStatusCode.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<UptimeCheckConfig_HttpCheck_ResponseStatusCode>,
  ): UptimeCheckConfig_HttpCheck_ResponseStatusCode {
    const message = createBaseUptimeCheckConfig_HttpCheck_ResponseStatusCode();
    message.statusValue = object.statusValue ?? undefined;
    message.statusClass = object.statusClass ?? undefined;
    return message;
  },
};

function createBaseUptimeCheckConfig_HttpCheck_ServiceAgentAuthentication(): UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication {
  return { type: 0 };
}

export const UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication: MessageFns<
  UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication
> = {
  encode(
    message: UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeCheckConfig_HttpCheck_ServiceAgentAuthentication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication {
    return {
      type: isSet(object.type)
        ? uptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationTypeFromJSON(object.type)
        : 0,
    };
  },

  toJSON(message: UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = uptimeCheckConfig_HttpCheck_ServiceAgentAuthentication_ServiceAgentAuthenticationTypeToJSON(
        message.type,
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication>,
  ): UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication {
    return UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication>,
  ): UptimeCheckConfig_HttpCheck_ServiceAgentAuthentication {
    const message = createBaseUptimeCheckConfig_HttpCheck_ServiceAgentAuthentication();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseUptimeCheckConfig_HttpCheck_HeadersEntry(): UptimeCheckConfig_HttpCheck_HeadersEntry {
  return { key: "", value: "" };
}

export const UptimeCheckConfig_HttpCheck_HeadersEntry: MessageFns<UptimeCheckConfig_HttpCheck_HeadersEntry> = {
  encode(message: UptimeCheckConfig_HttpCheck_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UptimeCheckConfig_HttpCheck_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeCheckConfig_HttpCheck_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeCheckConfig_HttpCheck_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UptimeCheckConfig_HttpCheck_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<UptimeCheckConfig_HttpCheck_HeadersEntry>): UptimeCheckConfig_HttpCheck_HeadersEntry {
    return UptimeCheckConfig_HttpCheck_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UptimeCheckConfig_HttpCheck_HeadersEntry>): UptimeCheckConfig_HttpCheck_HeadersEntry {
    const message = createBaseUptimeCheckConfig_HttpCheck_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUptimeCheckConfig_TcpCheck(): UptimeCheckConfig_TcpCheck {
  return { port: 0, pingConfig: undefined };
}

export const UptimeCheckConfig_TcpCheck: MessageFns<UptimeCheckConfig_TcpCheck> = {
  encode(message: UptimeCheckConfig_TcpCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.port !== 0) {
      writer.uint32(8).int32(message.port);
    }
    if (message.pingConfig !== undefined) {
      UptimeCheckConfig_PingConfig.encode(message.pingConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UptimeCheckConfig_TcpCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeCheckConfig_TcpCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pingConfig = UptimeCheckConfig_PingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeCheckConfig_TcpCheck {
    return {
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      pingConfig: isSet(object.pingConfig) ? UptimeCheckConfig_PingConfig.fromJSON(object.pingConfig) : undefined,
    };
  },

  toJSON(message: UptimeCheckConfig_TcpCheck): unknown {
    const obj: any = {};
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.pingConfig !== undefined) {
      obj.pingConfig = UptimeCheckConfig_PingConfig.toJSON(message.pingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<UptimeCheckConfig_TcpCheck>): UptimeCheckConfig_TcpCheck {
    return UptimeCheckConfig_TcpCheck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UptimeCheckConfig_TcpCheck>): UptimeCheckConfig_TcpCheck {
    const message = createBaseUptimeCheckConfig_TcpCheck();
    message.port = object.port ?? 0;
    message.pingConfig = (object.pingConfig !== undefined && object.pingConfig !== null)
      ? UptimeCheckConfig_PingConfig.fromPartial(object.pingConfig)
      : undefined;
    return message;
  },
};

function createBaseUptimeCheckConfig_ContentMatcher(): UptimeCheckConfig_ContentMatcher {
  return { content: "", matcher: 0, jsonPathMatcher: undefined };
}

export const UptimeCheckConfig_ContentMatcher: MessageFns<UptimeCheckConfig_ContentMatcher> = {
  encode(message: UptimeCheckConfig_ContentMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.matcher !== 0) {
      writer.uint32(16).int32(message.matcher);
    }
    if (message.jsonPathMatcher !== undefined) {
      UptimeCheckConfig_ContentMatcher_JsonPathMatcher.encode(message.jsonPathMatcher, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UptimeCheckConfig_ContentMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeCheckConfig_ContentMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matcher = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.jsonPathMatcher = UptimeCheckConfig_ContentMatcher_JsonPathMatcher.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeCheckConfig_ContentMatcher {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      matcher: isSet(object.matcher)
        ? uptimeCheckConfig_ContentMatcher_ContentMatcherOptionFromJSON(object.matcher)
        : 0,
      jsonPathMatcher: isSet(object.jsonPathMatcher)
        ? UptimeCheckConfig_ContentMatcher_JsonPathMatcher.fromJSON(object.jsonPathMatcher)
        : undefined,
    };
  },

  toJSON(message: UptimeCheckConfig_ContentMatcher): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.matcher !== 0) {
      obj.matcher = uptimeCheckConfig_ContentMatcher_ContentMatcherOptionToJSON(message.matcher);
    }
    if (message.jsonPathMatcher !== undefined) {
      obj.jsonPathMatcher = UptimeCheckConfig_ContentMatcher_JsonPathMatcher.toJSON(message.jsonPathMatcher);
    }
    return obj;
  },

  create(base?: DeepPartial<UptimeCheckConfig_ContentMatcher>): UptimeCheckConfig_ContentMatcher {
    return UptimeCheckConfig_ContentMatcher.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UptimeCheckConfig_ContentMatcher>): UptimeCheckConfig_ContentMatcher {
    const message = createBaseUptimeCheckConfig_ContentMatcher();
    message.content = object.content ?? "";
    message.matcher = object.matcher ?? 0;
    message.jsonPathMatcher = (object.jsonPathMatcher !== undefined && object.jsonPathMatcher !== null)
      ? UptimeCheckConfig_ContentMatcher_JsonPathMatcher.fromPartial(object.jsonPathMatcher)
      : undefined;
    return message;
  },
};

function createBaseUptimeCheckConfig_ContentMatcher_JsonPathMatcher(): UptimeCheckConfig_ContentMatcher_JsonPathMatcher {
  return { jsonPath: "", jsonMatcher: 0 };
}

export const UptimeCheckConfig_ContentMatcher_JsonPathMatcher: MessageFns<
  UptimeCheckConfig_ContentMatcher_JsonPathMatcher
> = {
  encode(
    message: UptimeCheckConfig_ContentMatcher_JsonPathMatcher,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.jsonPath !== "") {
      writer.uint32(10).string(message.jsonPath);
    }
    if (message.jsonMatcher !== 0) {
      writer.uint32(16).int32(message.jsonMatcher);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UptimeCheckConfig_ContentMatcher_JsonPathMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeCheckConfig_ContentMatcher_JsonPathMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jsonPath = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.jsonMatcher = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeCheckConfig_ContentMatcher_JsonPathMatcher {
    return {
      jsonPath: isSet(object.jsonPath) ? globalThis.String(object.jsonPath) : "",
      jsonMatcher: isSet(object.jsonMatcher)
        ? uptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOptionFromJSON(object.jsonMatcher)
        : 0,
    };
  },

  toJSON(message: UptimeCheckConfig_ContentMatcher_JsonPathMatcher): unknown {
    const obj: any = {};
    if (message.jsonPath !== "") {
      obj.jsonPath = message.jsonPath;
    }
    if (message.jsonMatcher !== 0) {
      obj.jsonMatcher = uptimeCheckConfig_ContentMatcher_JsonPathMatcher_JsonPathMatcherOptionToJSON(
        message.jsonMatcher,
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<UptimeCheckConfig_ContentMatcher_JsonPathMatcher>,
  ): UptimeCheckConfig_ContentMatcher_JsonPathMatcher {
    return UptimeCheckConfig_ContentMatcher_JsonPathMatcher.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<UptimeCheckConfig_ContentMatcher_JsonPathMatcher>,
  ): UptimeCheckConfig_ContentMatcher_JsonPathMatcher {
    const message = createBaseUptimeCheckConfig_ContentMatcher_JsonPathMatcher();
    message.jsonPath = object.jsonPath ?? "";
    message.jsonMatcher = object.jsonMatcher ?? 0;
    return message;
  },
};

function createBaseUptimeCheckConfig_UserLabelsEntry(): UptimeCheckConfig_UserLabelsEntry {
  return { key: "", value: "" };
}

export const UptimeCheckConfig_UserLabelsEntry: MessageFns<UptimeCheckConfig_UserLabelsEntry> = {
  encode(message: UptimeCheckConfig_UserLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UptimeCheckConfig_UserLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeCheckConfig_UserLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeCheckConfig_UserLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UptimeCheckConfig_UserLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<UptimeCheckConfig_UserLabelsEntry>): UptimeCheckConfig_UserLabelsEntry {
    return UptimeCheckConfig_UserLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UptimeCheckConfig_UserLabelsEntry>): UptimeCheckConfig_UserLabelsEntry {
    const message = createBaseUptimeCheckConfig_UserLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUptimeCheckIp(): UptimeCheckIp {
  return { region: 0, location: "", ipAddress: "" };
}

export const UptimeCheckIp: MessageFns<UptimeCheckIp> = {
  encode(message: UptimeCheckIp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.region !== 0) {
      writer.uint32(8).int32(message.region);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.ipAddress !== "") {
      writer.uint32(26).string(message.ipAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UptimeCheckIp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeCheckIp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.region = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeCheckIp {
    return {
      region: isSet(object.region) ? uptimeCheckRegionFromJSON(object.region) : 0,
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
    };
  },

  toJSON(message: UptimeCheckIp): unknown {
    const obj: any = {};
    if (message.region !== 0) {
      obj.region = uptimeCheckRegionToJSON(message.region);
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<UptimeCheckIp>): UptimeCheckIp {
    return UptimeCheckIp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UptimeCheckIp>): UptimeCheckIp {
    const message = createBaseUptimeCheckIp();
    message.region = object.region ?? 0;
    message.location = object.location ?? "";
    message.ipAddress = object.ipAddress ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
