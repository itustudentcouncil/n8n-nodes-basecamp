// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/monitoring/v3/notification.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { LabelDescriptor } from "../../api/label.js";
import { LaunchStage, launchStageFromJSON, launchStageToJSON } from "../../api/launch_stage.js";
import { BoolValue } from "../../protobuf/wrappers.js";
import { ServiceTier, serviceTierFromJSON, serviceTierToJSON } from "./common.js";
import { MutationRecord } from "./mutation_record.js";

export const protobufPackage = "google.monitoring.v3";

/**
 * A description of a notification channel. The descriptor includes
 * the properties of the channel and the set of labels or fields that
 * must be specified to configure channels of a given type.
 */
export interface NotificationChannelDescriptor {
  /**
   * The full REST resource name for this descriptor. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[TYPE]
   *
   * In the above, `[TYPE]` is the value of the `type` field.
   */
  name: string;
  /**
   * The type of notification channel, such as "email" and "sms". To view the
   * full list of channels, see
   * [Channel
   * descriptors](https://cloud.google.com/monitoring/alerts/using-channels-api#ncd).
   * Notification channel types are globally unique.
   */
  type: string;
  /**
   * A human-readable name for the notification channel type.  This
   * form of the name is suitable for a user interface.
   */
  displayName: string;
  /**
   * A human-readable description of the notification channel
   * type. The description may include a description of the properties
   * of the channel and pointers to external documentation.
   */
  description: string;
  /**
   * The set of labels that must be defined to identify a particular
   * channel of the corresponding type. Each label includes a
   * description for how that field should be populated.
   */
  labels: LabelDescriptor[];
  /**
   * The tiers that support this notification channel; the project service tier
   * must be one of the supported_tiers.
   *
   * @deprecated
   */
  supportedTiers: ServiceTier[];
  /** The product launch stage for channels of this type. */
  launchStage: LaunchStage;
}

/**
 * A `NotificationChannel` is a medium through which an alert is
 * delivered when a policy violation is detected. Examples of channels
 * include email, SMS, and third-party messaging applications. Fields
 * containing sensitive information like authentication tokens or
 * contact info are only partially populated on retrieval.
 */
export interface NotificationChannel {
  /**
   * The type of the notification channel. This field matches the
   * value of the
   * [NotificationChannelDescriptor.type][google.monitoring.v3.NotificationChannelDescriptor.type]
   * field.
   */
  type: string;
  /**
   * The full REST resource name for this channel. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
   *
   * The `[CHANNEL_ID]` is automatically assigned by the server on creation.
   */
  name: string;
  /**
   * An optional human-readable name for this notification channel. It is
   * recommended that you specify a non-empty and unique name in order to
   * make it easier to identify the channels in your project, though this is
   * not enforced. The display name is limited to 512 Unicode characters.
   */
  displayName: string;
  /**
   * An optional human-readable description of this notification channel. This
   * description may provide additional details, beyond the display
   * name, for the channel. This may not exceed 1024 Unicode characters.
   */
  description: string;
  /**
   * Configuration fields that define the channel and its behavior. The
   * permissible and required labels are specified in the
   * [NotificationChannelDescriptor.labels][google.monitoring.v3.NotificationChannelDescriptor.labels]
   * of the `NotificationChannelDescriptor` corresponding to the `type` field.
   */
  labels: { [key: string]: string };
  /**
   * User-supplied key/value data that does not need to conform to
   * the corresponding `NotificationChannelDescriptor`'s schema, unlike
   * the `labels` field. This field is intended to be used for organizing
   * and identifying the `NotificationChannel` objects.
   *
   * The field can contain up to 64 entries. Each key and value is limited to
   * 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
   * values can contain only lowercase letters, numerals, underscores, and
   * dashes. Keys must begin with a letter.
   */
  userLabels: { [key: string]: string };
  /**
   * Indicates whether this channel has been verified or not. On a
   * [`ListNotificationChannels`][google.monitoring.v3.NotificationChannelService.ListNotificationChannels]
   * or
   * [`GetNotificationChannel`][google.monitoring.v3.NotificationChannelService.GetNotificationChannel]
   * operation, this field is expected to be populated.
   *
   * If the value is `UNVERIFIED`, then it indicates that the channel is
   * non-functioning (it both requires verification and lacks verification);
   * otherwise, it is assumed that the channel works.
   *
   * If the channel is neither `VERIFIED` nor `UNVERIFIED`, it implies that
   * the channel is of a type that does not require verification or that
   * this specific channel has been exempted from verification because it was
   * created prior to verification being required for channels of this type.
   *
   * This field cannot be modified using a standard
   * [`UpdateNotificationChannel`][google.monitoring.v3.NotificationChannelService.UpdateNotificationChannel]
   * operation. To change the value of this field, you must call
   * [`VerifyNotificationChannel`][google.monitoring.v3.NotificationChannelService.VerifyNotificationChannel].
   */
  verificationStatus: NotificationChannel_VerificationStatus;
  /**
   * Whether notifications are forwarded to the described channel. This makes
   * it possible to disable delivery of notifications to a particular channel
   * without removing the channel from all alerting policies that reference
   * the channel. This is a more convenient approach when the change is
   * temporary and you want to receive notifications from the same set
   * of alerting policies on the channel at some point in the future.
   */
  enabled:
    | boolean
    | undefined;
  /** Record of the creation of this channel. */
  creationRecord:
    | MutationRecord
    | undefined;
  /** Records of the modification of this channel. */
  mutationRecords: MutationRecord[];
}

/**
 * Indicates whether the channel has been verified or not. It is illegal
 * to specify this field in a
 * [`CreateNotificationChannel`][google.monitoring.v3.NotificationChannelService.CreateNotificationChannel]
 * or an
 * [`UpdateNotificationChannel`][google.monitoring.v3.NotificationChannelService.UpdateNotificationChannel]
 * operation.
 */
export enum NotificationChannel_VerificationStatus {
  /**
   * VERIFICATION_STATUS_UNSPECIFIED - Sentinel value used to indicate that the state is unknown, omitted, or
   * is not applicable (as in the case of channels that neither support
   * nor require verification in order to function).
   */
  VERIFICATION_STATUS_UNSPECIFIED = 0,
  /**
   * UNVERIFIED - The channel has yet to be verified and requires verification to function.
   * Note that this state also applies to the case where the verification
   * process has been initiated by sending a verification code but where
   * the verification code has not been submitted to complete the process.
   */
  UNVERIFIED = 1,
  /**
   * VERIFIED - It has been proven that notifications can be received on this
   * notification channel and that someone on the project has access
   * to messages that are delivered to that channel.
   */
  VERIFIED = 2,
  UNRECOGNIZED = -1,
}

export function notificationChannel_VerificationStatusFromJSON(object: any): NotificationChannel_VerificationStatus {
  switch (object) {
    case 0:
    case "VERIFICATION_STATUS_UNSPECIFIED":
      return NotificationChannel_VerificationStatus.VERIFICATION_STATUS_UNSPECIFIED;
    case 1:
    case "UNVERIFIED":
      return NotificationChannel_VerificationStatus.UNVERIFIED;
    case 2:
    case "VERIFIED":
      return NotificationChannel_VerificationStatus.VERIFIED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotificationChannel_VerificationStatus.UNRECOGNIZED;
  }
}

export function notificationChannel_VerificationStatusToJSON(object: NotificationChannel_VerificationStatus): string {
  switch (object) {
    case NotificationChannel_VerificationStatus.VERIFICATION_STATUS_UNSPECIFIED:
      return "VERIFICATION_STATUS_UNSPECIFIED";
    case NotificationChannel_VerificationStatus.UNVERIFIED:
      return "UNVERIFIED";
    case NotificationChannel_VerificationStatus.VERIFIED:
      return "VERIFIED";
    case NotificationChannel_VerificationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface NotificationChannel_LabelsEntry {
  key: string;
  value: string;
}

export interface NotificationChannel_UserLabelsEntry {
  key: string;
  value: string;
}

function createBaseNotificationChannelDescriptor(): NotificationChannelDescriptor {
  return { name: "", type: "", displayName: "", description: "", labels: [], supportedTiers: [], launchStage: 0 };
}

export const NotificationChannelDescriptor: MessageFns<NotificationChannelDescriptor> = {
  encode(message: NotificationChannelDescriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.labels) {
      LabelDescriptor.encode(v!, writer.uint32(34).fork()).join();
    }
    writer.uint32(42).fork();
    for (const v of message.supportedTiers) {
      writer.int32(v);
    }
    writer.join();
    if (message.launchStage !== 0) {
      writer.uint32(56).int32(message.launchStage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationChannelDescriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationChannelDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.labels.push(LabelDescriptor.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag === 40) {
            message.supportedTiers.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedTiers.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.launchStage = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationChannelDescriptor {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      labels: globalThis.Array.isArray(object?.labels)
        ? object.labels.map((e: any) => LabelDescriptor.fromJSON(e))
        : [],
      supportedTiers: globalThis.Array.isArray(object?.supportedTiers)
        ? object.supportedTiers.map((e: any) => serviceTierFromJSON(e))
        : [],
      launchStage: isSet(object.launchStage) ? launchStageFromJSON(object.launchStage) : 0,
    };
  },

  toJSON(message: NotificationChannelDescriptor): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.labels?.length) {
      obj.labels = message.labels.map((e) => LabelDescriptor.toJSON(e));
    }
    if (message.supportedTiers?.length) {
      obj.supportedTiers = message.supportedTiers.map((e) => serviceTierToJSON(e));
    }
    if (message.launchStage !== 0) {
      obj.launchStage = launchStageToJSON(message.launchStage);
    }
    return obj;
  },

  create(base?: DeepPartial<NotificationChannelDescriptor>): NotificationChannelDescriptor {
    return NotificationChannelDescriptor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotificationChannelDescriptor>): NotificationChannelDescriptor {
    const message = createBaseNotificationChannelDescriptor();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.labels = object.labels?.map((e) => LabelDescriptor.fromPartial(e)) || [];
    message.supportedTiers = object.supportedTiers?.map((e) => e) || [];
    message.launchStage = object.launchStage ?? 0;
    return message;
  },
};

function createBaseNotificationChannel(): NotificationChannel {
  return {
    type: "",
    name: "",
    displayName: "",
    description: "",
    labels: {},
    userLabels: {},
    verificationStatus: 0,
    enabled: undefined,
    creationRecord: undefined,
    mutationRecords: [],
  };
}

export const NotificationChannel: MessageFns<NotificationChannel> = {
  encode(message: NotificationChannel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      NotificationChannel_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    Object.entries(message.userLabels).forEach(([key, value]) => {
      NotificationChannel_UserLabelsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.verificationStatus !== 0) {
      writer.uint32(72).int32(message.verificationStatus);
    }
    if (message.enabled !== undefined) {
      BoolValue.encode({ value: message.enabled! }, writer.uint32(90).fork()).join();
    }
    if (message.creationRecord !== undefined) {
      MutationRecord.encode(message.creationRecord, writer.uint32(98).fork()).join();
    }
    for (const v of message.mutationRecords) {
      MutationRecord.encode(v!, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationChannel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = NotificationChannel_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = NotificationChannel_UserLabelsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.userLabels[entry8.key] = entry8.value;
          }
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.verificationStatus = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.enabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.creationRecord = MutationRecord.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.mutationRecords.push(MutationRecord.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationChannel {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      userLabels: isObject(object.userLabels)
        ? Object.entries(object.userLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      verificationStatus: isSet(object.verificationStatus)
        ? notificationChannel_VerificationStatusFromJSON(object.verificationStatus)
        : 0,
      enabled: isSet(object.enabled) ? Boolean(object.enabled) : undefined,
      creationRecord: isSet(object.creationRecord) ? MutationRecord.fromJSON(object.creationRecord) : undefined,
      mutationRecords: globalThis.Array.isArray(object?.mutationRecords)
        ? object.mutationRecords.map((e: any) => MutationRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NotificationChannel): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.userLabels) {
      const entries = Object.entries(message.userLabels);
      if (entries.length > 0) {
        obj.userLabels = {};
        entries.forEach(([k, v]) => {
          obj.userLabels[k] = v;
        });
      }
    }
    if (message.verificationStatus !== 0) {
      obj.verificationStatus = notificationChannel_VerificationStatusToJSON(message.verificationStatus);
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    if (message.creationRecord !== undefined) {
      obj.creationRecord = MutationRecord.toJSON(message.creationRecord);
    }
    if (message.mutationRecords?.length) {
      obj.mutationRecords = message.mutationRecords.map((e) => MutationRecord.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NotificationChannel>): NotificationChannel {
    return NotificationChannel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotificationChannel>): NotificationChannel {
    const message = createBaseNotificationChannel();
    message.type = object.type ?? "";
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.userLabels = Object.entries(object.userLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.verificationStatus = object.verificationStatus ?? 0;
    message.enabled = object.enabled ?? undefined;
    message.creationRecord = (object.creationRecord !== undefined && object.creationRecord !== null)
      ? MutationRecord.fromPartial(object.creationRecord)
      : undefined;
    message.mutationRecords = object.mutationRecords?.map((e) => MutationRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNotificationChannel_LabelsEntry(): NotificationChannel_LabelsEntry {
  return { key: "", value: "" };
}

export const NotificationChannel_LabelsEntry: MessageFns<NotificationChannel_LabelsEntry> = {
  encode(message: NotificationChannel_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationChannel_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationChannel_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationChannel_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NotificationChannel_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NotificationChannel_LabelsEntry>): NotificationChannel_LabelsEntry {
    return NotificationChannel_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotificationChannel_LabelsEntry>): NotificationChannel_LabelsEntry {
    const message = createBaseNotificationChannel_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNotificationChannel_UserLabelsEntry(): NotificationChannel_UserLabelsEntry {
  return { key: "", value: "" };
}

export const NotificationChannel_UserLabelsEntry: MessageFns<NotificationChannel_UserLabelsEntry> = {
  encode(message: NotificationChannel_UserLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationChannel_UserLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationChannel_UserLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationChannel_UserLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NotificationChannel_UserLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NotificationChannel_UserLabelsEntry>): NotificationChannel_UserLabelsEntry {
    return NotificationChannel_UserLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotificationChannel_UserLabelsEntry>): NotificationChannel_UserLabelsEntry {
    const message = createBaseNotificationChannel_UserLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
